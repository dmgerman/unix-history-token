begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Cameron Grant<cg@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|OLDPCM_IOCTL
end_define

begin_decl_stmt
specifier|static
name|d_open_t
name|dsp_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|dsp_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|dsp_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|dsp_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|dsp_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|dsp_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|dsp_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cdevsw
name|dsp_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|dsp_open
block|,
operator|.
name|d_close
operator|=
name|dsp_close
block|,
operator|.
name|d_read
operator|=
name|dsp_read
block|,
operator|.
name|d_write
operator|=
name|dsp_write
block|,
operator|.
name|d_ioctl
operator|=
name|dsp_ioctl
block|,
operator|.
name|d_poll
operator|=
name|dsp_poll
block|,
operator|.
name|d_mmap
operator|=
name|dsp_mmap
block|,
operator|.
name|d_name
operator|=
literal|"dsp"
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USING_DEVFS
end_ifdef

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|dsp_ehtag
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|snddev_info
modifier|*
name|dsp_get_info
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|PCMUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|devclass_get_maxunit
argument_list|(
name|pcm_devclass
argument_list|)
condition|)
return|return
name|NULL
return|;
name|d
operator|=
name|devclass_get_softc
argument_list|(
name|pcm_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|dsp_get_flags
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|device_t
name|bdev
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|PCMUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|devclass_get_maxunit
argument_list|(
name|pcm_devclass
argument_list|)
condition|)
return|return
literal|0xffffffff
return|;
name|bdev
operator|=
name|devclass_get_device
argument_list|(
name|pcm_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|pcm_getflags
argument_list|(
name|bdev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_set_flags
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
block|{
name|device_t
name|bdev
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|PCMUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|devclass_get_maxunit
argument_list|(
name|pcm_devclass
argument_list|)
condition|)
return|return;
name|bdev
operator|=
name|devclass_get_device
argument_list|(
name|pcm_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|pcm_setflags
argument_list|(
name|bdev
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return the channels associated with an open device instance.  * set the priority if the device is simplex and one direction (only) is  * specified.  * lock channels specified.  */
end_comment

begin_function
specifier|static
name|int
name|getchns
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|pcm_channel
modifier|*
modifier|*
name|rdch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
modifier|*
name|wrch
parameter_list|,
name|u_int32_t
name|prio
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|flags
operator|=
name|dsp_get_flags
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pcm_inprog
argument_list|(
name|d
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
name|SD_F_PRIO_SET
operator|)
operator|!=
name|SD_F_PRIO_SET
argument_list|, \
operator|(
literal|"getchns: read and write both prioritised"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SD_F_PRIO_SET
operator|)
operator|==
literal|0
operator|&&
operator|(
name|prio
operator|!=
operator|(
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
operator|)
operator|)
condition|)
block|{
name|flags
operator||=
name|prio
operator|&
operator|(
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
operator|)
expr_stmt|;
name|dsp_set_flags
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
operator|*
name|rdch
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
operator|*
name|wrch
operator|=
name|dev
operator|->
name|si_drv2
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SD_F_SIMPLEX
operator|)
operator|&&
operator|(
name|flags
operator|&
name|SD_F_PRIO_SET
operator|)
condition|)
block|{
if|if
condition|(
name|prio
condition|)
block|{
if|if
condition|(
operator|*
name|rdch
operator|&&
name|flags
operator|&
name|SD_F_PRIO_WR
condition|)
block|{
name|dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
operator|*
name|rdch
operator|=
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|wrch
operator|&&
name|flags
operator|&
name|SD_F_PRIO_RD
condition|)
block|{
name|dev
operator|->
name|si_drv2
operator|=
name|NULL
expr_stmt|;
operator|*
name|wrch
operator|=
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
operator|->
name|flags
operator||=
name|CHN_F_BUSY
expr_stmt|;
block|}
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rdch
operator|&&
operator|*
name|rdch
operator|!=
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_RD
operator|)
condition|)
name|CHN_LOCK
argument_list|(
operator|*
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|wrch
operator|&&
operator|*
name|wrch
operator|!=
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_WR
operator|)
condition|)
name|CHN_LOCK
argument_list|(
operator|*
name|wrch
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* unlock specified channels */
end_comment

begin_function
specifier|static
name|void
name|relchns
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|u_int32_t
name|prio
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
operator|&&
name|wrch
operator|!=
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_WR
operator|)
condition|)
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
name|rdch
operator|!=
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_RD
operator|)
condition|)
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|pcm_inprog
argument_list|(
name|d
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|u_int32_t
name|fmt
decl_stmt|;
name|int
name|devtype
decl_stmt|;
name|int
name|rdref
decl_stmt|;
name|int
name|error
decl_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|devtype
operator|=
name|PCMDEV
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
comment|/* decide default format */
switch|switch
condition|(
name|devtype
condition|)
block|{
case|case
name|SND_DEV_DSP16
case|:
name|fmt
operator|=
name|AFMT_S16_LE
expr_stmt|;
break|break;
case|case
name|SND_DEV_DSP
case|:
name|fmt
operator|=
name|AFMT_U8
expr_stmt|;
break|break;
case|case
name|SND_DEV_AUDIO
case|:
name|fmt
operator|=
name|AFMT_MU_LAW
expr_stmt|;
break|break;
case|case
name|SND_DEV_NORESET
case|:
name|fmt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SND_DEV_DSPREC
case|:
name|fmt
operator|=
name|AFMT_U8
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|FWRITE
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"impossible devtype %d"
argument_list|,
name|devtype
argument_list|)
expr_stmt|;
block|}
name|rdref
operator|=
literal|0
expr_stmt|;
comment|/* lock snddev so nobody else can monkey with it */
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|rdch
operator|=
name|i_dev
operator|->
name|si_drv1
expr_stmt|;
name|wrch
operator|=
name|i_dev
operator|->
name|si_drv2
expr_stmt|;
if|if
condition|(
operator|(
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|&
name|SD_F_SIMPLEX
operator|)
operator|&&
operator|(
name|rdch
operator|||
name|wrch
operator|)
condition|)
block|{
comment|/* we're a simplex device and already open, no go */
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|FREAD
operator|)
operator|&&
name|rdch
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|&&
name|wrch
operator|)
condition|)
block|{
comment|/* 		 * device already open in one or both directions that 		 * the opener wants; we can't handle this. 		 */
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
comment|/* 	 * if we get here, the open request is valid- either: 	 *   * we were previously not open 	 *   * we were open for play xor record and the opener wants 	 *     the non-open direction 	 */
if|if
condition|(
name|flags
operator|&
name|FREAD
condition|)
block|{
comment|/* open for read */
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|devtype
operator|==
name|SND_DEV_DSPREC
condition|)
name|rdch
operator|=
name|pcm_chnalloc
argument_list|(
name|d
argument_list|,
name|PCMDIR_REC
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|PCMCHAN
argument_list|(
name|i_dev
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rdch
operator|=
name|pcm_chnalloc
argument_list|(
name|d
argument_list|,
name|PCMDIR_REC
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rdch
condition|)
block|{
comment|/* no channel available, exit */
return|return
name|EBUSY
return|;
block|}
comment|/* got a channel, already locked for us */
if|if
condition|(
name|chn_reset
argument_list|(
name|rdch
argument_list|,
name|fmt
argument_list|)
operator|||
operator|(
name|fmt
operator|&&
name|chn_setspeed
argument_list|(
name|rdch
argument_list|,
name|DSP_DEFAULT_SPEED
argument_list|)
operator|)
condition|)
block|{
name|pcm_chnrelease
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|i_dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
name|pcm_chnref
argument_list|(
name|rdch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|rdref
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Record channel created, ref'ed and unlocked 		 */
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
block|{
comment|/* open for write */
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|wrch
operator|=
name|pcm_chnalloc
argument_list|(
name|d
argument_list|,
name|PCMDIR_PLAY
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|wrch
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* XXX Right return code? */
elseif|else
if|if
condition|(
name|chn_reset
argument_list|(
name|wrch
argument_list|,
name|fmt
argument_list|)
operator|||
operator|(
name|fmt
operator|&&
name|chn_setspeed
argument_list|(
name|wrch
argument_list|,
name|DSP_DEFAULT_SPEED
argument_list|)
operator|)
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|wrch
condition|)
block|{
comment|/* 		     * Free play channel 		     */
name|pcm_chnrelease
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|i_dev
operator|->
name|si_drv2
operator|=
name|NULL
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdref
condition|)
block|{
comment|/* 		     * Lock, deref and release previously created record channel 		     */
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|pcm_chnref
argument_list|(
name|rdch
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pcm_chnrelease
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|i_dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
name|pcm_chnref
argument_list|(
name|wrch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|i_dev
operator|->
name|si_drv1
operator|=
name|rdch
expr_stmt|;
name|i_dev
operator|->
name|si_drv2
operator|=
name|wrch
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|int
name|refs
decl_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|rdch
operator|=
name|i_dev
operator|->
name|si_drv1
expr_stmt|;
name|wrch
operator|=
name|i_dev
operator|->
name|si_drv2
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|refs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|refs
operator|+=
name|pcm_chnref
argument_list|(
name|rdch
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|refs
operator|+=
name|pcm_chnref
argument_list|(
name|wrch
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there are no more references, release the channels. 	 */
if|if
condition|(
operator|(
name|rdch
operator|||
name|wrch
operator|)
operator|&&
name|refs
operator|==
literal|0
condition|)
block|{
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
condition|)
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|i_dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
name|i_dev
operator|->
name|si_drv2
operator|=
name|NULL
expr_stmt|;
name|dsp_set_flags
argument_list|(
name|i_dev
argument_list|,
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|&
operator|~
name|SD_F_TRANSIENT
argument_list|)
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_abort
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
comment|/* won't sleep */
name|rdch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_RUNNING
operator||
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
expr_stmt|;
name|chn_reset
argument_list|(
name|rdch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcm_chnrelease
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* 			 * XXX: Maybe the right behaviour is to abort on non_block. 			 * It seems that mplayer flushes the audio queue by quickly 			 * closing and re-opening.  In FBSD, there's a long pause 			 * while the audio queue flushes that I presume isn't there in 			 * linux. 			 */
name|chn_flush
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* may sleep */
name|wrch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_RUNNING
operator||
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
expr_stmt|;
name|chn_reset
argument_list|(
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcm_chnrelease
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|SD_F_PRIO_RD
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rdch
argument_list|,
operator|(
literal|"dsp_read: nonexistant channel"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_BUSY
argument_list|,
operator|(
literal|"dsp_read: nonbusy channel"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|->
name|flags
operator|&
operator|(
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_RUNNING
operator|)
condition|)
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_RUNNING
expr_stmt|;
name|ret
operator|=
name|chn_read
argument_list|(
name|rdch
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wrch
argument_list|,
operator|(
literal|"dsp_write: nonexistant channel"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_BUSY
argument_list|,
operator|(
literal|"dsp_write: nonbusy channel"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
operator|->
name|flags
operator|&
operator|(
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_RUNNING
operator|)
condition|)
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_RUNNING
expr_stmt|;
name|ret
operator|=
name|chn_write
argument_list|(
name|wrch
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|chn
decl_stmt|,
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|int
name|kill
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
modifier|*
name|arg_i
init|=
operator|(
name|int
operator|*
operator|)
name|arg
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* 	 * this is an evil hack to allow broken apps to perform mixer ioctls 	 * on dsp devices. 	 */
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IOCGROUP
argument_list|(
name|cmd
argument_list|)
operator|==
literal|'M'
condition|)
return|return
name|mixer_ioctl
argument_list|(
name|d
operator|->
name|mixer_dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
return|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
operator|&&
operator|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_DEAD
operator|)
condition|)
name|kill
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
operator|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_DEAD
operator|)
condition|)
name|kill
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|kill
operator|==
literal|3
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|kill
operator|&
literal|1
condition|)
name|wrch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kill
operator|&
literal|2
condition|)
name|rdch
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
ifdef|#
directive|ifdef
name|OLDPCM_IOCTL
comment|/*      	 * we start with the new ioctl interface.      	 */
case|case
name|AIONWRITE
case|:
comment|/* how many bytes can write ? */
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* 		if (wrch&& wrch->bufhard.dl) 			while (chn_wrfeed(wrch) == 0); */
operator|*
name|arg_i
operator|=
name|wrch
condition|?
name|sndbuf_getfree
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
else|:
literal|0
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
break|break;
case|case
name|AIOSSIZE
case|:
comment|/* set the current blocksize */
block|{
name|struct
name|snd_size
modifier|*
name|p
init|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
decl_stmt|;
name|p
operator|->
name|play_size
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rec_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|wrch
argument_list|,
literal|2
argument_list|,
name|p
operator|->
name|play_size
argument_list|)
expr_stmt|;
name|p
operator|->
name|play_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|rdch
argument_list|,
literal|2
argument_list|,
name|p
operator|->
name|rec_size
argument_list|)
expr_stmt|;
name|p
operator|->
name|rec_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AIOGSIZE
case|:
comment|/* get the current blocksize */
block|{
name|struct
name|snd_size
modifier|*
name|p
init|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|p
operator|->
name|play_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|p
operator|->
name|rec_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AIOSFMT
case|:
case|case
name|AIOGFMT
case|:
block|{
name|snd_chan_param
modifier|*
name|p
init|=
operator|(
name|snd_chan_param
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|AIOSFMT
operator|&&
operator|(
operator|(
name|p
operator|->
name|play_format
operator|!=
literal|0
operator|&&
name|p
operator|->
name|play_rate
operator|==
literal|0
operator|)
operator|||
operator|(
name|p
operator|->
name|rec_format
operator|!=
literal|0
operator|&&
name|p
operator|->
name|rec_rate
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|AIOSFMT
operator|&&
name|p
operator|->
name|play_format
operator|!=
literal|0
condition|)
block|{
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
name|p
operator|->
name|play_format
argument_list|)
expr_stmt|;
name|chn_setspeed
argument_list|(
name|wrch
argument_list|,
name|p
operator|->
name|play_rate
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|play_rate
operator|=
name|wrch
operator|->
name|speed
expr_stmt|;
name|p
operator|->
name|play_format
operator|=
name|wrch
operator|->
name|format
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|play_rate
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|play_format
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|AIOSFMT
operator|&&
name|p
operator|->
name|rec_format
operator|!=
literal|0
condition|)
block|{
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
name|p
operator|->
name|rec_format
argument_list|)
expr_stmt|;
name|chn_setspeed
argument_list|(
name|rdch
argument_list|,
name|p
operator|->
name|rec_rate
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|rec_rate
operator|=
name|rdch
operator|->
name|speed
expr_stmt|;
name|p
operator|->
name|rec_format
operator|=
name|rdch
operator|->
name|format
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|rec_rate
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rec_format
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AIOGCAP
case|:
comment|/* get capabilities */
block|{
name|snd_capabilities
modifier|*
name|p
init|=
operator|(
name|snd_capabilities
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|pcmchan_caps
modifier|*
name|pcaps
init|=
name|NULL
decl_stmt|,
modifier|*
name|rcaps
init|=
name|NULL
decl_stmt|;
name|struct
name|cdev
modifier|*
name|pdev
decl_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|rcaps
operator|=
name|chn_getcaps
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|pcaps
operator|=
name|chn_getcaps
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|rate_min
operator|=
name|max
argument_list|(
name|rcaps
condition|?
name|rcaps
operator|->
name|minspeed
else|:
literal|0
argument_list|,
name|pcaps
condition|?
name|pcaps
operator|->
name|minspeed
else|:
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|rate_max
operator|=
name|min
argument_list|(
name|rcaps
condition|?
name|rcaps
operator|->
name|maxspeed
else|:
literal|1000000
argument_list|,
name|pcaps
condition|?
name|pcaps
operator|->
name|maxspeed
else|:
literal|1000000
argument_list|)
expr_stmt|;
name|p
operator|->
name|bufsize
operator|=
name|min
argument_list|(
name|rdch
condition|?
name|sndbuf_getsize
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
else|:
literal|1000000
argument_list|,
name|wrch
condition|?
name|sndbuf_getsize
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
else|:
literal|1000000
argument_list|)
expr_stmt|;
comment|/* XXX bad on sb16 */
name|p
operator|->
name|formats
operator|=
operator|(
name|rdch
condition|?
name|chn_getformats
argument_list|(
name|rdch
argument_list|)
else|:
literal|0xffffffff
operator|)
operator|&
operator|(
name|wrch
condition|?
name|chn_getformats
argument_list|(
name|wrch
argument_list|)
else|:
literal|0xffffffff
operator|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
name|wrch
condition|)
name|p
operator|->
name|formats
operator||=
operator|(
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|&
name|SD_F_SIMPLEX
operator|)
condition|?
literal|0
else|:
name|AFMT_FULLDUPLEX
expr_stmt|;
name|pdev
operator|=
name|d
operator|->
name|mixer_dev
expr_stmt|;
name|p
operator|->
name|mixers
operator|=
literal|1
expr_stmt|;
comment|/* default: one mixer */
name|p
operator|->
name|inputs
operator|=
name|pdev
operator|->
name|si_drv1
condition|?
name|mix_getdevs
argument_list|(
name|pdev
operator|->
name|si_drv1
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|p
operator|->
name|right
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AIOSTOP
case|:
if|if
condition|(
operator|*
name|arg_i
operator|==
name|AIOSYNC_PLAY
operator|&&
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn_abort
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|arg_i
operator|==
name|AIOSYNC_CAPTURE
operator|&&
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn_abort
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"AIOSTOP: bad channel 0x%x\n"
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|AIOSYNC
case|:
name|printf
argument_list|(
literal|"AIOSYNC chan 0x%03lx pos %lu unimplemented\n"
argument_list|,
operator|(
operator|(
name|snd_sync_parm
operator|*
operator|)
name|arg
operator|)
operator|->
name|chan
argument_list|,
operator|(
operator|(
name|snd_sync_parm
operator|*
operator|)
name|arg
operator|)
operator|->
name|pos
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* 	 * here follow the standard ioctls (filio.h etc.) 	 */
case|case
name|FIONREAD
case|:
comment|/* get # bytes to read */
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
comment|/*			if (rdch&& rdch->bufhard.dl) 				while (chn_rdfeed(rdch) == 0); */
operator|*
name|arg_i
operator|=
name|sndbuf_getready
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FIOASYNC
case|:
comment|/*set/clear async i/o */
name|DEB
argument_list|(
argument|printf(
literal|"FIOASYNC\n"
argument|) ;
argument_list|)
break|break;
case|case
name|SNDCTL_DSP_NONBLOCK
case|:
case|case
name|FIONBIO
case|:
comment|/* set/clear non-blocking i/o */
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg_i
condition|)
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
else|else
name|rdch
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_NBIO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg_i
condition|)
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
else|else
name|wrch
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_NBIO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Finally, here is the linux-compatible ioctl interface 	 */
define|#
directive|define
name|THE_REAL_SNDCTL_DSP_GETBLKSIZE
value|_IOWR('P', 4, int)
case|case
name|THE_REAL_SNDCTL_DSP_GETBLKSIZE
case|:
case|case
name|SNDCTL_DSP_GETBLKSIZE
case|:
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|sndbuf_getblksz
argument_list|(
name|chn
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
break|break ;
case|case
name|SNDCTL_DSP_SETBLKSIZE
case|:
name|RANGE
argument_list|(
operator|*
name|arg_i
argument_list|,
literal|16
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|wrch
argument_list|,
literal|2
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|rdch
argument_list|,
literal|2
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_RESET
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp reset\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_abort
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_resetbuf
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_abort
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_resetbuf
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SYNC
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp sync\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* chn_sync may sleep */
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_sync
argument_list|(
name|wrch
argument_list|,
name|sndbuf_getsize
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
operator|-
literal|4
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SPEED
case|:
comment|/* chn_setspeed may sleep */
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setspeed
argument_list|(
name|wrch
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wrch
operator|->
name|speed
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setspeed
argument_list|(
name|rdch
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
name|rdch
operator|->
name|speed
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
name|SOUND_PCM_READ_RATE
case|:
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn
operator|->
name|speed
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_STEREO
case|:
name|tmp
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|arg_i
operator|=
operator|(
operator|*
name|arg_i
operator|)
condition|?
name|AFMT_STEREO
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
operator|(
name|wrch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|wrch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
operator|(
name|rdch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
operator|-
literal|1
condition|)
name|tmp
operator|=
operator|(
name|rdch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
name|SOUND_PCM_WRITE_CHANNELS
case|:
comment|/*	case SNDCTL_DSP_CHANNELS: ( == SOUND_PCM_WRITE_CHANNELS) */
if|if
condition|(
operator|*
name|arg_i
operator|!=
literal|0
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
operator|*
name|arg_i
operator|=
operator|(
operator|*
name|arg_i
operator|!=
literal|1
operator|)
condition|?
name|AFMT_STEREO
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
operator|(
name|wrch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|wrch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
operator|(
name|rdch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
operator|(
name|rdch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
operator|(
name|chn
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SOUND_PCM_READ_CHANNELS
case|:
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
operator|(
name|chn
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_GETFMTS
case|:
comment|/* returns a mask of supported fmts */
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn_getformats
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
break|break ;
case|case
name|SNDCTL_DSP_SETFMT
case|:
comment|/* sets _one_ format */
if|if
condition|(
operator|(
operator|*
name|arg_i
operator|!=
name|AFMT_QUERY
operator|)
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
operator|(
operator|*
name|arg_i
operator|)
operator||
operator|(
name|wrch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wrch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
operator|(
operator|*
name|arg_i
operator|)
operator||
operator|(
name|rdch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
name|rdch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SETFRAGMENT
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"SNDCTL_DSP_SETFRAGMENT 0x%08x\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|u_int32_t
name|fragln
init|=
operator|(
operator|*
name|arg_i
operator|)
operator|&
literal|0x0000ffff
decl_stmt|;
name|u_int32_t
name|maxfrags
init|=
operator|(
operator|(
operator|*
name|arg_i
operator|)
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
decl_stmt|;
name|u_int32_t
name|fragsz
decl_stmt|;
name|u_int32_t
name|r_maxfrags
decl_stmt|,
name|r_fragsz
decl_stmt|;
name|RANGE
argument_list|(
name|fragln
argument_list|,
literal|4
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|fragsz
operator|=
literal|1
operator|<<
name|fragln
expr_stmt|;
if|if
condition|(
name|maxfrags
operator|==
literal|0
condition|)
name|maxfrags
operator|=
name|CHN_2NDBUFMAXSIZE
operator|/
name|fragsz
expr_stmt|;
if|if
condition|(
name|maxfrags
operator|<
literal|2
condition|)
name|maxfrags
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|maxfrags
operator|*
name|fragsz
operator|>
name|CHN_2NDBUFMAXSIZE
condition|)
name|maxfrags
operator|=
name|CHN_2NDBUFMAXSIZE
operator|/
name|fragsz
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"SNDCTL_DSP_SETFRAGMENT %d frags, %d sz\n"
argument_list|,
name|maxfrags
argument_list|,
name|fragsz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setblocksize
argument_list|(
name|rdch
argument_list|,
name|maxfrags
argument_list|,
name|fragsz
argument_list|)
expr_stmt|;
name|r_maxfrags
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|r_fragsz
operator|=
name|sndbuf_getblksz
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r_maxfrags
operator|=
name|maxfrags
expr_stmt|;
name|r_fragsz
operator|=
name|fragsz
expr_stmt|;
block|}
if|if
condition|(
name|wrch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setblocksize
argument_list|(
name|wrch
argument_list|,
name|maxfrags
argument_list|,
name|fragsz
argument_list|)
expr_stmt|;
name|maxfrags
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|fragsz
operator|=
name|sndbuf_getblksz
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use whatever came from the read channel */
name|maxfrags
operator|=
name|r_maxfrags
expr_stmt|;
name|fragsz
operator|=
name|r_fragsz
expr_stmt|;
block|}
name|fragln
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fragsz
operator|>
literal|1
condition|)
block|{
name|fragln
operator|++
expr_stmt|;
name|fragsz
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
operator|(
name|maxfrags
operator|<<
literal|16
operator|)
operator||
name|fragln
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETISPACE
case|:
comment|/* return the size of data available in the input queue */
block|{
name|audio_buf_info
modifier|*
name|a
init|=
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|rdch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|a
operator|->
name|bytes
operator|=
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragments
operator|=
name|a
operator|->
name|bytes
operator|/
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragstotal
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragsize
operator|=
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SNDCTL_DSP_GETOSPACE
case|:
comment|/* return space available in the output queue */
block|{
name|audio_buf_info
modifier|*
name|a
init|=
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|wrch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* XXX abusive DMA update: chn_wrupdate(wrch); */
name|a
operator|->
name|bytes
operator|=
name|sndbuf_getfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragments
operator|=
name|a
operator|->
name|bytes
operator|/
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragstotal
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragsize
operator|=
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SNDCTL_DSP_GETIPTR
case|:
block|{
name|count_info
modifier|*
name|a
init|=
operator|(
name|count_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|rdch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
comment|/* XXX abusive DMA update: chn_rdupdate(rdch); */
name|a
operator|->
name|bytes
operator|=
name|sndbuf_gettotal
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
operator|-
name|rdch
operator|->
name|blocks
expr_stmt|;
name|a
operator|->
name|ptr
operator|=
name|sndbuf_getreadyptr
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|rdch
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETOPTR
case|:
block|{
name|count_info
modifier|*
name|a
init|=
operator|(
name|count_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|wrch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* XXX abusive DMA update: chn_wrupdate(wrch); */
name|a
operator|->
name|bytes
operator|=
name|sndbuf_gettotal
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
operator|-
name|wrch
operator|->
name|blocks
expr_stmt|;
name|a
operator|->
name|ptr
operator|=
name|sndbuf_getreadyptr
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETCAPS
case|:
operator|*
name|arg_i
operator|=
name|DSP_CAP_REALTIME
operator||
name|DSP_CAP_MMAP
operator||
name|DSP_CAP_TRIGGER
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
name|wrch
operator|&&
operator|!
operator|(
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|&
name|SD_F_SIMPLEX
operator|)
condition|)
operator|*
name|arg_i
operator||=
name|DSP_CAP_DUPLEX
expr_stmt|;
break|break;
case|case
name|SOUND_PCM_READ_BITS
case|:
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
if|if
condition|(
name|chn
operator|->
name|format
operator|&
name|AFMT_8BIT
condition|)
operator|*
name|arg_i
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|chn
operator|->
name|format
operator|&
name|AFMT_16BIT
condition|)
operator|*
name|arg_i
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|chn
operator|->
name|format
operator|&
name|AFMT_24BIT
condition|)
operator|*
name|arg_i
operator|=
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
name|chn
operator|->
name|format
operator|&
name|AFMT_32BIT
condition|)
operator|*
name|arg_i
operator|=
literal|32
expr_stmt|;
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_SETTRIGGER
case|:
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|rdch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_TRIGGERED
operator||
name|CHN_F_NOTRIGGER
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg_i
operator|&
name|PCM_ENABLE_INPUT
condition|)
name|chn_start
argument_list|(
name|rdch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_NOTRIGGER
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_TRIGGERED
operator||
name|CHN_F_NOTRIGGER
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg_i
operator|&
name|PCM_ENABLE_OUTPUT
condition|)
name|chn_start
argument_list|(
name|wrch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_NOTRIGGER
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETTRIGGER
case|:
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
condition|)
operator|*
name|arg_i
operator||=
name|PCM_ENABLE_OUTPUT
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
condition|)
operator|*
name|arg_i
operator||=
name|PCM_ENABLE_INPUT
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETODELAY
case|:
if|if
condition|(
name|wrch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|b
init|=
name|wrch
operator|->
name|bufhard
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|wrch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* XXX abusive DMA update: chn_wrupdate(wrch); */
operator|*
name|arg_i
operator|=
name|sndbuf_getready
argument_list|(
name|b
argument_list|)
operator|+
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_POST
case|:
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_NOTRIGGER
expr_stmt|;
name|chn_start
argument_list|(
name|wrch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SETDUPLEX
case|:
comment|/* 		 * switch to full-duplex mode if card is in half-duplex 		 * mode and is able to work in full-duplex mode 		 */
if|if
condition|(
name|rdch
operator|&&
name|wrch
operator|&&
operator|(
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|&
name|SD_F_SIMPLEX
operator|)
condition|)
name|dsp_set_flags
argument_list|(
name|i_dev
argument_list|,
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|^
name|SD_F_SIMPLEX
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_MAPINBUF
case|:
case|case
name|SNDCTL_DSP_MAPOUTBUF
case|:
case|case
name|SNDCTL_DSP_SETSYNCRO
case|:
comment|/* undocumented */
case|case
name|SNDCTL_DSP_SUBDIVIDE
case|:
case|case
name|SOUND_PCM_WRITE_FILTER
case|:
case|case
name|SOUND_PCM_READ_FILTER
case|:
comment|/* dunno what these do, don't sound important */
default|default:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"default ioctl fn 0x%08lx fail\n"
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|wrch
init|=
name|NULL
decl_stmt|,
modifier|*
name|rdch
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|e
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|e
operator|=
operator|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|ret
operator||=
name|chn_poll
argument_list|(
name|wrch
argument_list|,
name|e
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|e
operator|=
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|ret
operator||=
name|chn_poll
argument_list|(
name|rdch
argument_list|,
name|e
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_mmap
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|wrch
init|=
name|NULL
decl_stmt|,
modifier|*
name|rdch
init|=
name|NULL
decl_stmt|,
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|-
literal|1
return|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * XXX the linux api uses the nprot to select read/write buffer 	 * our vm system doesn't allow this, so force write buffer 	 */
block|if (wrch&& (nprot& PROT_WRITE)) { 		c = wrch; 	} else if (rdch&& (nprot& PROT_READ)) { 		c = rdch; 	} else { 		return -1; 	}
else|#
directive|else
name|c
operator|=
name|wrch
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|offset
operator|>=
name|sndbuf_getsize
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|)
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
operator|)
condition|)
name|c
operator|->
name|flags
operator||=
name|CHN_F_MAPPED
expr_stmt|;
operator|*
name|paddr
operator|=
name|vtophys
argument_list|(
name|sndbuf_getbufofs
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USING_DEVFS
end_ifdef

begin_comment
comment|/*  * Clone logic is this:  * x E X = {dsp, dspW, audio}  * x -> x${sysctl("hw.snd.unit")}  * xN->  *    for i N = 1 to channels of device N  *    	if xN.i isn't busy, return its dev_t  */
end_comment

begin_function
specifier|static
name|void
name|dsp_clone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|cdev
modifier|*
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|cdev
modifier|*
name|pdev
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|pcm_dev
decl_stmt|;
name|struct
name|snddev_channel
modifier|*
name|pcm_chan
decl_stmt|;
name|int
name|i
decl_stmt|,
name|unit
decl_stmt|,
name|devtype
decl_stmt|;
name|int
name|devtypes
index|[
literal|3
index|]
init|=
block|{
name|SND_DEV_DSP
block|,
name|SND_DEV_DSP16
block|,
name|SND_DEV_AUDIO
block|}
decl_stmt|;
name|char
modifier|*
name|devnames
index|[
literal|3
index|]
init|=
block|{
literal|"dsp"
block|,
literal|"dspW"
block|,
literal|"audio"
block|}
decl_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
name|pcm_devclass
operator|==
name|NULL
condition|)
return|return;
name|devtype
operator|=
literal|0
expr_stmt|;
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|3
operator|)
operator|&&
operator|(
name|unit
operator|==
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|devtype
operator|=
name|devtypes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|devnames
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unit
operator|=
name|snd_unit
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dev_stdclone
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|devnames
index|[
name|i
index|]
argument_list|,
operator|&
name|unit
argument_list|)
operator|!=
literal|1
condition|)
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unit
operator|==
operator|-
literal|1
operator|||
name|unit
operator|>=
name|devclass_get_maxunit
argument_list|(
name|pcm_devclass
argument_list|)
condition|)
return|return;
name|pcm_dev
operator|=
name|devclass_get_softc
argument_list|(
name|pcm_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcm_dev
operator|==
name|NULL
condition|)
return|return;
name|SLIST_FOREACH
argument_list|(
argument|pcm_chan
argument_list|,
argument|&pcm_dev->channels
argument_list|,
argument|link
argument_list|)
block|{
switch|switch
condition|(
name|devtype
condition|)
block|{
case|case
name|SND_DEV_DSP
case|:
name|pdev
operator|=
name|pcm_chan
operator|->
name|dsp_devt
expr_stmt|;
break|break;
case|case
name|SND_DEV_DSP16
case|:
name|pdev
operator|=
name|pcm_chan
operator|->
name|dspW_devt
expr_stmt|;
break|break;
case|case
name|SND_DEV_AUDIO
case|:
name|pdev
operator|=
name|pcm_chan
operator|->
name|audio_devt
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown devtype %d"
argument_list|,
name|devtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pdev
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pdev
operator|->
name|si_drv1
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|pdev
operator|->
name|si_drv2
operator|==
name|NULL
operator|)
condition|)
block|{
operator|*
name|dev
operator|=
name|pdev
expr_stmt|;
name|dev_ref
argument_list|(
operator|*
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_sysinit
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|dsp_ehtag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_clone
argument_list|,
name|dsp_clone
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_sysuninit
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|dsp_ehtag
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|dev_clone
argument_list|,
name|dsp_ehtag
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|dsp_sysinit
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|dsp_sysinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|dsp_sysuninit
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|dsp_sysuninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

