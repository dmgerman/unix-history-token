begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Cameron Grant<cg@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|OLDPCM_IOCTL
end_define

begin_decl_stmt
specifier|static
name|d_open_t
name|dsp_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|dsp_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|dsp_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|dsp_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|dsp_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|dsp_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|dsp_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cdevsw
name|dsp_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|dsp_open
block|,
operator|.
name|d_close
operator|=
name|dsp_close
block|,
operator|.
name|d_read
operator|=
name|dsp_read
block|,
operator|.
name|d_write
operator|=
name|dsp_write
block|,
operator|.
name|d_ioctl
operator|=
name|dsp_ioctl
block|,
operator|.
name|d_poll
operator|=
name|dsp_poll
block|,
operator|.
name|d_mmap
operator|=
name|dsp_mmap
block|,
operator|.
name|d_name
operator|=
literal|"dsp"
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USING_DEVFS
end_ifdef

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|dsp_ehtag
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|dsp_oss_syncgroup
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_syncgroup
modifier|*
name|group
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_syncstart
parameter_list|(
name|int
name|sg_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_policy
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|int
name|policy
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|OSSV4_EXPERIMENT
end_ifdef

begin_function_decl
specifier|static
name|int
name|dsp_oss_cookedmode
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|int
name|enabled
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_getchnorder
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|unsigned
name|long
name|long
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_setchnorder
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|unsigned
name|long
name|long
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_getlabel
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_label_t
modifier|*
name|label
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_setlabel
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_label_t
modifier|*
name|label
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_getsong
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_longname_t
modifier|*
name|song
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_setsong
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_longname_t
modifier|*
name|song
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_setname
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_longname_t
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|snddev_info
modifier|*
name|dsp_get_info
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|PCMUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|devclass_get_maxunit
argument_list|(
name|pcm_devclass
argument_list|)
condition|)
return|return
name|NULL
return|;
name|d
operator|=
name|devclass_get_softc
argument_list|(
name|pcm_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|dsp_get_flags
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|device_t
name|bdev
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|PCMUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|devclass_get_maxunit
argument_list|(
name|pcm_devclass
argument_list|)
condition|)
return|return
literal|0xffffffff
return|;
name|bdev
operator|=
name|devclass_get_device
argument_list|(
name|pcm_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|pcm_getflags
argument_list|(
name|bdev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_set_flags
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
block|{
name|device_t
name|bdev
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|PCMUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|devclass_get_maxunit
argument_list|(
name|pcm_devclass
argument_list|)
condition|)
return|return;
name|bdev
operator|=
name|devclass_get_device
argument_list|(
name|pcm_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|pcm_setflags
argument_list|(
name|bdev
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return the channels associated with an open device instance.  * set the priority if the device is simplex and one direction (only) is  * specified.  * lock channels specified.  */
end_comment

begin_function
specifier|static
name|int
name|getchns
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|pcm_channel
modifier|*
modifier|*
name|rdch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
modifier|*
name|wrch
parameter_list|,
name|u_int32_t
name|prio
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|flags
operator|=
name|dsp_get_flags
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pcm_inprog
argument_list|(
name|d
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
name|SD_F_PRIO_SET
operator|)
operator|!=
name|SD_F_PRIO_SET
argument_list|, \
operator|(
literal|"getchns: read and write both prioritised"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SD_F_PRIO_SET
operator|)
operator|==
literal|0
operator|&&
operator|(
name|prio
operator|!=
operator|(
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
operator|)
operator|)
condition|)
block|{
name|flags
operator||=
name|prio
operator|&
operator|(
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
operator|)
expr_stmt|;
name|dsp_set_flags
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
operator|*
name|rdch
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
operator|*
name|wrch
operator|=
name|dev
operator|->
name|si_drv2
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SD_F_SIMPLEX
operator|)
operator|&&
operator|(
name|flags
operator|&
name|SD_F_PRIO_SET
operator|)
condition|)
block|{
if|if
condition|(
name|prio
condition|)
block|{
if|if
condition|(
operator|*
name|rdch
operator|&&
name|flags
operator|&
name|SD_F_PRIO_WR
condition|)
block|{
name|dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
operator|*
name|rdch
operator|=
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|wrch
operator|&&
name|flags
operator|&
name|SD_F_PRIO_RD
condition|)
block|{
name|dev
operator|->
name|si_drv2
operator|=
name|NULL
expr_stmt|;
operator|*
name|wrch
operator|=
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
operator|->
name|flags
operator||=
name|CHN_F_BUSY
expr_stmt|;
block|}
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rdch
operator|&&
operator|*
name|rdch
operator|!=
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_RD
operator|)
condition|)
name|CHN_LOCK
argument_list|(
operator|*
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|wrch
operator|&&
operator|*
name|wrch
operator|!=
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_WR
operator|)
condition|)
name|CHN_LOCK
argument_list|(
operator|*
name|wrch
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* unlock specified channels */
end_comment

begin_function
specifier|static
name|void
name|relchns
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|u_int32_t
name|prio
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
operator|&&
name|wrch
operator|!=
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_WR
operator|)
condition|)
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
name|rdch
operator|!=
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_RD
operator|)
condition|)
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|pcm_inprog
argument_list|(
name|d
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|u_int32_t
name|fmt
decl_stmt|;
name|int
name|devtype
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|chnum
decl_stmt|;
if|if
condition|(
name|i_dev
operator|==
name|NULL
operator|||
name|td
operator|==
name|NULL
condition|)
return|return
name|ENODEV
return|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|devtype
operator|=
name|PCMDEV
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|chnum
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* decide default format */
switch|switch
condition|(
name|devtype
condition|)
block|{
case|case
name|SND_DEV_DSP16
case|:
name|fmt
operator|=
name|AFMT_S16_LE
expr_stmt|;
break|break;
case|case
name|SND_DEV_DSP
case|:
name|fmt
operator|=
name|AFMT_U8
expr_stmt|;
break|break;
case|case
name|SND_DEV_AUDIO
case|:
name|fmt
operator|=
name|AFMT_MU_LAW
expr_stmt|;
break|break;
case|case
name|SND_DEV_NORESET
case|:
name|fmt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SND_DEV_DSPHW
case|:
comment|/* 		 * HW *specific* access without channel numbering confusion 		 * caused by "first come first served" by dsp_clone(). 		 */
name|fmt
operator|=
name|AFMT_U8
expr_stmt|;
name|chnum
operator|=
name|PCMCHAN
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"impossible devtype %d"
argument_list|,
name|devtype
argument_list|)
expr_stmt|;
block|}
comment|/* lock snddev so nobody else can monkey with it */
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|rdch
operator|=
name|i_dev
operator|->
name|si_drv1
expr_stmt|;
name|wrch
operator|=
name|i_dev
operator|->
name|si_drv2
expr_stmt|;
if|if
condition|(
name|rdch
operator|||
name|wrch
operator|||
operator|(
operator|(
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|&
name|SD_F_SIMPLEX
operator|)
operator|&&
operator|(
name|flags
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
operator|)
operator|==
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
operator|)
condition|)
block|{
comment|/* simplex or not, better safe than sorry. */
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
comment|/* 	 * if we get here, the open request is valid- either: 	 *   * we were previously not open 	 *   * we were open for play xor record and the opener wants 	 *     the non-open direction 	 */
if|if
condition|(
name|flags
operator|&
name|FREAD
condition|)
block|{
comment|/* open for read */
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|error
operator|=
name|pcm_chnalloc
argument_list|(
name|d
argument_list|,
operator|&
name|rdch
argument_list|,
name|PCMDIR_REC
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|chnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EBUSY
operator|&&
name|chnum
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|flags
operator|&
name|FWRITE
operator|)
condition|)
name|error
operator|=
name|pcm_chnalloc
argument_list|(
name|d
argument_list|,
operator|&
name|rdch
argument_list|,
name|PCMDIR_REC
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|chn_reset
argument_list|(
name|rdch
argument_list|,
name|fmt
argument_list|)
operator|||
operator|(
name|fmt
operator|&&
name|chn_setspeed
argument_list|(
name|rdch
argument_list|,
name|DSP_DEFAULT_SPEED
argument_list|)
operator|)
operator|)
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rdch
condition|)
name|pcm_chnrelease
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
name|pcm_chnref
argument_list|(
name|rdch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
block|{
comment|/* open for write */
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|error
operator|=
name|pcm_chnalloc
argument_list|(
name|d
argument_list|,
operator|&
name|wrch
argument_list|,
name|PCMDIR_PLAY
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|chnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EBUSY
operator|&&
name|chnum
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|flags
operator|&
name|FREAD
operator|)
condition|)
name|error
operator|=
name|pcm_chnalloc
argument_list|(
name|d
argument_list|,
operator|&
name|wrch
argument_list|,
name|PCMDIR_PLAY
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|chn_reset
argument_list|(
name|wrch
argument_list|,
name|fmt
argument_list|)
operator|||
operator|(
name|fmt
operator|&&
name|chn_setspeed
argument_list|(
name|wrch
argument_list|,
name|DSP_DEFAULT_SPEED
argument_list|)
operator|)
operator|)
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|wrch
condition|)
name|pcm_chnrelease
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
comment|/* 		     * Lock, deref and release previously created record channel 		     */
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|pcm_chnref
argument_list|(
name|rdch
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pcm_chnrelease
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
name|pcm_chnref
argument_list|(
name|wrch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|i_dev
operator|->
name|si_drv1
operator|=
name|rdch
expr_stmt|;
name|i_dev
operator|->
name|si_drv2
operator|=
name|wrch
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|int
name|refs
decl_stmt|,
name|sg_ids
index|[
literal|2
index|]
decl_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|rdch
operator|=
name|i_dev
operator|->
name|si_drv1
expr_stmt|;
name|wrch
operator|=
name|i_dev
operator|->
name|si_drv2
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* 	 * Free_unr() may sleep, so store released syncgroup IDs until after 	 * all locks are released. 	 */
name|sg_ids
index|[
literal|0
index|]
operator|=
name|sg_ids
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdch
operator|||
name|wrch
condition|)
block|{
name|refs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
comment|/* 			 * The channel itself need not be locked because: 			 *   a)  Adding a channel to a syncgroup happens only in dsp_ioctl(), 			 *       which cannot run concurrently to dsp_close(). 			 *   b)  The syncmember pointer (sm) is protected by the global 			 *       syncgroup list lock. 			 *   c)  A channel can't just disappear, invalidating pointers, 			 *       unless it's closed/dereferenced first. 			 */
name|PCM_SG_LOCK
argument_list|()
expr_stmt|;
name|sg_ids
index|[
literal|0
index|]
operator|=
name|chn_syncdestroy
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|PCM_SG_UNLOCK
argument_list|()
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|refs
operator|+=
name|pcm_chnref
argument_list|(
name|rdch
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|chn_abort
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
comment|/* won't sleep */
name|rdch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_RUNNING
operator||
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
expr_stmt|;
name|chn_reset
argument_list|(
name|rdch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcm_chnrelease
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
comment|/* 			 * Please see block above. 			 */
name|PCM_SG_LOCK
argument_list|()
expr_stmt|;
name|sg_ids
index|[
literal|1
index|]
operator|=
name|chn_syncdestroy
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|PCM_SG_UNLOCK
argument_list|()
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|refs
operator|+=
name|pcm_chnref
argument_list|(
name|wrch
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|chn_flush
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* may sleep */
name|wrch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_RUNNING
operator||
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
expr_stmt|;
name|chn_reset
argument_list|(
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcm_chnrelease
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
name|i_dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
name|i_dev
operator|->
name|si_drv2
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * If there are no more references, release the channels. 		 */
if|if
condition|(
name|refs
operator|==
literal|0
operator|&&
name|i_dev
operator|->
name|si_drv1
operator|==
name|NULL
operator|&&
name|i_dev
operator|->
name|si_drv2
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
condition|)
name|pcm_getfakechan
argument_list|(
name|d
argument_list|)
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* What is this?!? */
name|dsp_set_flags
argument_list|(
name|i_dev
argument_list|,
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|&
operator|~
name|SD_F_TRANSIENT
argument_list|)
expr_stmt|;
block|}
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sg_ids
index|[
literal|0
index|]
condition|)
name|free_unr
argument_list|(
name|pcmsg_unrhdr
argument_list|,
name|sg_ids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_ids
index|[
literal|1
index|]
condition|)
name|free_unr
argument_list|(
name|pcmsg_unrhdr
argument_list|,
name|sg_ids
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|SD_F_PRIO_RD
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rdch
argument_list|,
operator|(
literal|"dsp_read: nonexistant channel"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_BUSY
argument_list|,
operator|(
literal|"dsp_read: nonbusy channel"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|->
name|flags
operator|&
operator|(
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_RUNNING
operator|)
condition|)
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_RUNNING
expr_stmt|;
name|ret
operator|=
name|chn_read
argument_list|(
name|rdch
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wrch
argument_list|,
operator|(
literal|"dsp_write: nonexistant channel"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_BUSY
argument_list|,
operator|(
literal|"dsp_write: nonbusy channel"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
operator|->
name|flags
operator|&
operator|(
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_RUNNING
operator|)
condition|)
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_RUNNING
expr_stmt|;
comment|/* 	 * Chn_write() must give up channel lock in order to copy bytes from 	 * userland, so up the "in progress" counter to make sure someone 	 * else doesn't come along and muss up the buffer. 	 */
operator|++
name|wrch
operator|->
name|inprog
expr_stmt|;
name|ret
operator|=
name|chn_write
argument_list|(
name|wrch
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|--
name|wrch
operator|->
name|inprog
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|wrch
operator|->
name|cv
argument_list|)
expr_stmt|;
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|chn
decl_stmt|,
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|int
name|kill
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
modifier|*
name|arg_i
init|=
operator|(
name|int
operator|*
operator|)
name|arg
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|xcmd
decl_stmt|;
name|xcmd
operator|=
literal|0
expr_stmt|;
comment|/* 	 * this is an evil hack to allow broken apps to perform mixer ioctls 	 * on dsp devices. 	 */
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IOCGROUP
argument_list|(
name|cmd
argument_list|)
operator|==
literal|'M'
condition|)
block|{
comment|/* 		 * This is at least, a bug to bug compatible with OSS. 		 */
if|if
condition|(
name|d
operator|->
name|mixer_dev
operator|!=
name|NULL
condition|)
return|return
name|mixer_ioctl
argument_list|(
name|d
operator|->
name|mixer_dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
operator|-
literal|1
argument_list|,
name|td
argument_list|)
return|;
else|else
return|return
name|EBADF
return|;
block|}
comment|/* 	 * Certain ioctls may be made on any type of device (audio, mixer, 	 * and MIDI).  Handle those special cases here. 	 */
if|if
condition|(
name|IOCGROUP
argument_list|(
name|cmd
argument_list|)
operator|==
literal|'X'
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_SYSINFO
case|:
name|sound_oss_sysinfo
argument_list|(
operator|(
name|oss_sysinfo
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_AUDIOINFO
case|:
name|ret
operator|=
name|dsp_oss_audioinfo
argument_list|(
name|i_dev
argument_list|,
operator|(
name|oss_audioinfo
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_MIXERINFO
case|:
name|ret
operator|=
name|mixer_oss_mixerinfo
argument_list|(
name|i_dev
argument_list|,
operator|(
name|oss_mixerinfo
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
operator|&&
operator|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_DEAD
operator|)
condition|)
name|kill
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
operator|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_DEAD
operator|)
condition|)
name|kill
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|kill
operator|==
literal|3
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|kill
operator|&
literal|1
condition|)
name|wrch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kill
operator|&
literal|2
condition|)
name|rdch
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
ifdef|#
directive|ifdef
name|OLDPCM_IOCTL
comment|/*      	 * we start with the new ioctl interface.      	 */
case|case
name|AIONWRITE
case|:
comment|/* how many bytes can write ? */
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* 		if (wrch&& wrch->bufhard.dl) 			while (chn_wrfeed(wrch) == 0); */
operator|*
name|arg_i
operator|=
name|sndbuf_getfree
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|AIOSSIZE
case|:
comment|/* set the current blocksize */
block|{
name|struct
name|snd_size
modifier|*
name|p
init|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
decl_stmt|;
name|p
operator|->
name|play_size
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rec_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|wrch
argument_list|,
literal|2
argument_list|,
name|p
operator|->
name|play_size
argument_list|)
expr_stmt|;
name|p
operator|->
name|play_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|rdch
argument_list|,
literal|2
argument_list|,
name|p
operator|->
name|rec_size
argument_list|)
expr_stmt|;
name|p
operator|->
name|rec_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AIOGSIZE
case|:
comment|/* get the current blocksize */
block|{
name|struct
name|snd_size
modifier|*
name|p
init|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|p
operator|->
name|play_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|p
operator|->
name|rec_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AIOSFMT
case|:
case|case
name|AIOGFMT
case|:
block|{
name|snd_chan_param
modifier|*
name|p
init|=
operator|(
name|snd_chan_param
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|AIOSFMT
operator|&&
operator|(
operator|(
name|p
operator|->
name|play_format
operator|!=
literal|0
operator|&&
name|p
operator|->
name|play_rate
operator|==
literal|0
operator|)
operator|||
operator|(
name|p
operator|->
name|rec_format
operator|!=
literal|0
operator|&&
name|p
operator|->
name|rec_rate
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|AIOSFMT
operator|&&
name|p
operator|->
name|play_format
operator|!=
literal|0
condition|)
block|{
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
name|p
operator|->
name|play_format
argument_list|)
expr_stmt|;
name|chn_setspeed
argument_list|(
name|wrch
argument_list|,
name|p
operator|->
name|play_rate
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|play_rate
operator|=
name|wrch
operator|->
name|speed
expr_stmt|;
name|p
operator|->
name|play_format
operator|=
name|wrch
operator|->
name|format
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|play_rate
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|play_format
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|AIOSFMT
operator|&&
name|p
operator|->
name|rec_format
operator|!=
literal|0
condition|)
block|{
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
name|p
operator|->
name|rec_format
argument_list|)
expr_stmt|;
name|chn_setspeed
argument_list|(
name|rdch
argument_list|,
name|p
operator|->
name|rec_rate
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|rec_rate
operator|=
name|rdch
operator|->
name|speed
expr_stmt|;
name|p
operator|->
name|rec_format
operator|=
name|rdch
operator|->
name|format
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|rec_rate
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rec_format
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AIOGCAP
case|:
comment|/* get capabilities */
block|{
name|snd_capabilities
modifier|*
name|p
init|=
operator|(
name|snd_capabilities
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|pcmchan_caps
modifier|*
name|pcaps
init|=
name|NULL
decl_stmt|,
modifier|*
name|rcaps
init|=
name|NULL
decl_stmt|;
name|struct
name|cdev
modifier|*
name|pdev
decl_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|rcaps
operator|=
name|chn_getcaps
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|pcaps
operator|=
name|chn_getcaps
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|rate_min
operator|=
name|max
argument_list|(
name|rcaps
condition|?
name|rcaps
operator|->
name|minspeed
else|:
literal|0
argument_list|,
name|pcaps
condition|?
name|pcaps
operator|->
name|minspeed
else|:
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|rate_max
operator|=
name|min
argument_list|(
name|rcaps
condition|?
name|rcaps
operator|->
name|maxspeed
else|:
literal|1000000
argument_list|,
name|pcaps
condition|?
name|pcaps
operator|->
name|maxspeed
else|:
literal|1000000
argument_list|)
expr_stmt|;
name|p
operator|->
name|bufsize
operator|=
name|min
argument_list|(
name|rdch
condition|?
name|sndbuf_getsize
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
else|:
literal|1000000
argument_list|,
name|wrch
condition|?
name|sndbuf_getsize
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
else|:
literal|1000000
argument_list|)
expr_stmt|;
comment|/* XXX bad on sb16 */
name|p
operator|->
name|formats
operator|=
operator|(
name|rdch
condition|?
name|chn_getformats
argument_list|(
name|rdch
argument_list|)
else|:
literal|0xffffffff
operator|)
operator|&
operator|(
name|wrch
condition|?
name|chn_getformats
argument_list|(
name|wrch
argument_list|)
else|:
literal|0xffffffff
operator|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
name|wrch
condition|)
name|p
operator|->
name|formats
operator||=
operator|(
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|&
name|SD_F_SIMPLEX
operator|)
condition|?
literal|0
else|:
name|AFMT_FULLDUPLEX
expr_stmt|;
name|pdev
operator|=
name|d
operator|->
name|mixer_dev
expr_stmt|;
name|p
operator|->
name|mixers
operator|=
literal|1
expr_stmt|;
comment|/* default: one mixer */
name|p
operator|->
name|inputs
operator|=
name|pdev
operator|->
name|si_drv1
condition|?
name|mix_getdevs
argument_list|(
name|pdev
operator|->
name|si_drv1
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|p
operator|->
name|right
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AIOSTOP
case|:
if|if
condition|(
operator|*
name|arg_i
operator|==
name|AIOSYNC_PLAY
operator|&&
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn_abort
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|arg_i
operator|==
name|AIOSYNC_CAPTURE
operator|&&
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn_abort
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"AIOSTOP: bad channel 0x%x\n"
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|AIOSYNC
case|:
name|printf
argument_list|(
literal|"AIOSYNC chan 0x%03lx pos %lu unimplemented\n"
argument_list|,
operator|(
operator|(
name|snd_sync_parm
operator|*
operator|)
name|arg
operator|)
operator|->
name|chan
argument_list|,
operator|(
operator|(
name|snd_sync_parm
operator|*
operator|)
name|arg
operator|)
operator|->
name|pos
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* 	 * here follow the standard ioctls (filio.h etc.) 	 */
case|case
name|FIONREAD
case|:
comment|/* get # bytes to read */
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
comment|/*			if (rdch&& rdch->bufhard.dl) 				while (chn_rdfeed(rdch) == 0); */
operator|*
name|arg_i
operator|=
name|sndbuf_getready
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|FIOASYNC
case|:
comment|/*set/clear async i/o */
name|DEB
argument_list|(
argument|printf(
literal|"FIOASYNC\n"
argument|) ;
argument_list|)
break|break;
case|case
name|SNDCTL_DSP_NONBLOCK
case|:
comment|/* set non-blocking i/o */
case|case
name|FIONBIO
case|:
comment|/* set/clear non-blocking i/o */
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|SNDCTL_DSP_NONBLOCK
operator|||
operator|*
name|arg_i
condition|)
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
else|else
name|rdch
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_NBIO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|SNDCTL_DSP_NONBLOCK
operator|||
operator|*
name|arg_i
condition|)
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
else|else
name|wrch
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_NBIO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Finally, here is the linux-compatible ioctl interface 	 */
define|#
directive|define
name|THE_REAL_SNDCTL_DSP_GETBLKSIZE
value|_IOWR('P', 4, int)
case|case
name|THE_REAL_SNDCTL_DSP_GETBLKSIZE
case|:
case|case
name|SNDCTL_DSP_GETBLKSIZE
case|:
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|sndbuf_getblksz
argument_list|(
name|chn
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break ;
case|case
name|SNDCTL_DSP_SETBLKSIZE
case|:
name|RANGE
argument_list|(
operator|*
name|arg_i
argument_list|,
literal|16
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|wrch
argument_list|,
literal|2
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|rdch
argument_list|,
literal|2
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_RESET
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp reset\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_abort
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_resetbuf
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_abort
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_resetbuf
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SYNC
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp sync\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* chn_sync may sleep */
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_sync
argument_list|(
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SPEED
case|:
comment|/* chn_setspeed may sleep */
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setspeed
argument_list|(
name|wrch
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wrch
operator|->
name|speed
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setspeed
argument_list|(
name|rdch
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
name|rdch
operator|->
name|speed
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
name|SOUND_PCM_READ_RATE
case|:
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn
operator|->
name|speed
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_STEREO
case|:
name|tmp
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|arg_i
operator|=
operator|(
operator|*
name|arg_i
operator|)
condition|?
name|AFMT_STEREO
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
operator|(
name|wrch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|wrch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
operator|(
name|rdch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
operator|-
literal|1
condition|)
name|tmp
operator|=
operator|(
name|rdch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
name|SOUND_PCM_WRITE_CHANNELS
case|:
comment|/*	case SNDCTL_DSP_CHANNELS: ( == SOUND_PCM_WRITE_CHANNELS) */
if|if
condition|(
operator|*
name|arg_i
operator|!=
literal|0
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
operator|*
name|arg_i
operator|=
operator|(
operator|*
name|arg_i
operator|!=
literal|1
operator|)
condition|?
name|AFMT_STEREO
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
operator|(
name|wrch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|wrch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
operator|(
name|rdch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
operator|(
name|rdch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
operator|(
name|chn
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SOUND_PCM_READ_CHANNELS
case|:
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
operator|(
name|chn
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETFMTS
case|:
comment|/* returns a mask of supported fmts */
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn_getformats
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break ;
case|case
name|SNDCTL_DSP_SETFMT
case|:
comment|/* sets _one_ format */
if|if
condition|(
operator|(
operator|*
name|arg_i
operator|!=
name|AFMT_QUERY
operator|)
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
operator|(
operator|*
name|arg_i
operator|)
operator||
operator|(
name|wrch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wrch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
operator|(
operator|*
name|arg_i
operator|)
operator||
operator|(
name|rdch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
name|rdch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SETFRAGMENT
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"SNDCTL_DSP_SETFRAGMENT 0x%08x\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|u_int32_t
name|fragln
init|=
operator|(
operator|*
name|arg_i
operator|)
operator|&
literal|0x0000ffff
decl_stmt|;
name|u_int32_t
name|maxfrags
init|=
operator|(
operator|(
operator|*
name|arg_i
operator|)
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
decl_stmt|;
name|u_int32_t
name|fragsz
decl_stmt|;
name|u_int32_t
name|r_maxfrags
decl_stmt|,
name|r_fragsz
decl_stmt|;
name|RANGE
argument_list|(
name|fragln
argument_list|,
literal|4
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|fragsz
operator|=
literal|1
operator|<<
name|fragln
expr_stmt|;
if|if
condition|(
name|maxfrags
operator|==
literal|0
condition|)
name|maxfrags
operator|=
name|CHN_2NDBUFMAXSIZE
operator|/
name|fragsz
expr_stmt|;
if|if
condition|(
name|maxfrags
operator|<
literal|2
condition|)
name|maxfrags
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|maxfrags
operator|*
name|fragsz
operator|>
name|CHN_2NDBUFMAXSIZE
condition|)
name|maxfrags
operator|=
name|CHN_2NDBUFMAXSIZE
operator|/
name|fragsz
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"SNDCTL_DSP_SETFRAGMENT %d frags, %d sz\n"
argument_list|,
name|maxfrags
argument_list|,
name|fragsz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setblocksize
argument_list|(
name|rdch
argument_list|,
name|maxfrags
argument_list|,
name|fragsz
argument_list|)
expr_stmt|;
name|r_maxfrags
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|r_fragsz
operator|=
name|sndbuf_getblksz
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r_maxfrags
operator|=
name|maxfrags
expr_stmt|;
name|r_fragsz
operator|=
name|fragsz
expr_stmt|;
block|}
if|if
condition|(
name|wrch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setblocksize
argument_list|(
name|wrch
argument_list|,
name|maxfrags
argument_list|,
name|fragsz
argument_list|)
expr_stmt|;
name|maxfrags
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|fragsz
operator|=
name|sndbuf_getblksz
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use whatever came from the read channel */
name|maxfrags
operator|=
name|r_maxfrags
expr_stmt|;
name|fragsz
operator|=
name|r_fragsz
expr_stmt|;
block|}
name|fragln
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fragsz
operator|>
literal|1
condition|)
block|{
name|fragln
operator|++
expr_stmt|;
name|fragsz
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
operator|(
name|maxfrags
operator|<<
literal|16
operator|)
operator||
name|fragln
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETISPACE
case|:
comment|/* return the size of data available in the input queue */
block|{
name|audio_buf_info
modifier|*
name|a
init|=
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|rdch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|a
operator|->
name|bytes
operator|=
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragments
operator|=
name|a
operator|->
name|bytes
operator|/
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragstotal
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragsize
operator|=
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SNDCTL_DSP_GETOSPACE
case|:
comment|/* return space available in the output queue */
block|{
name|audio_buf_info
modifier|*
name|a
init|=
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|wrch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* XXX abusive DMA update: chn_wrupdate(wrch); */
name|a
operator|->
name|bytes
operator|=
name|sndbuf_getfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragments
operator|=
name|a
operator|->
name|bytes
operator|/
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragstotal
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragsize
operator|=
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SNDCTL_DSP_GETIPTR
case|:
block|{
name|count_info
modifier|*
name|a
init|=
operator|(
name|count_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|rdch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
comment|/* XXX abusive DMA update: chn_rdupdate(rdch); */
name|a
operator|->
name|bytes
operator|=
name|sndbuf_gettotal
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
operator|-
name|rdch
operator|->
name|blocks
expr_stmt|;
name|a
operator|->
name|ptr
operator|=
name|sndbuf_getreadyptr
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|rdch
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETOPTR
case|:
block|{
name|count_info
modifier|*
name|a
init|=
operator|(
name|count_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|wrch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* XXX abusive DMA update: chn_wrupdate(wrch); */
name|a
operator|->
name|bytes
operator|=
name|sndbuf_gettotal
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
operator|-
name|wrch
operator|->
name|blocks
expr_stmt|;
name|a
operator|->
name|ptr
operator|=
name|sndbuf_getreadyptr
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETCAPS
case|:
operator|*
name|arg_i
operator|=
name|DSP_CAP_REALTIME
operator||
name|DSP_CAP_MMAP
operator||
name|DSP_CAP_TRIGGER
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
name|wrch
operator|&&
operator|!
operator|(
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|&
name|SD_F_SIMPLEX
operator|)
condition|)
operator|*
name|arg_i
operator||=
name|DSP_CAP_DUPLEX
expr_stmt|;
break|break;
case|case
name|SOUND_PCM_READ_BITS
case|:
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
if|if
condition|(
name|chn
operator|->
name|format
operator|&
name|AFMT_8BIT
condition|)
operator|*
name|arg_i
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|chn
operator|->
name|format
operator|&
name|AFMT_16BIT
condition|)
operator|*
name|arg_i
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|chn
operator|->
name|format
operator|&
name|AFMT_24BIT
condition|)
operator|*
name|arg_i
operator|=
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
name|chn
operator|->
name|format
operator|&
name|AFMT_32BIT
condition|)
operator|*
name|arg_i
operator|=
literal|32
expr_stmt|;
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SETTRIGGER
case|:
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|rdch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_TRIGGERED
operator||
name|CHN_F_NOTRIGGER
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg_i
operator|&
name|PCM_ENABLE_INPUT
condition|)
name|chn_start
argument_list|(
name|rdch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_NOTRIGGER
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_TRIGGERED
operator||
name|CHN_F_NOTRIGGER
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg_i
operator|&
name|PCM_ENABLE_OUTPUT
condition|)
name|chn_start
argument_list|(
name|wrch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_NOTRIGGER
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETTRIGGER
case|:
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
condition|)
operator|*
name|arg_i
operator||=
name|PCM_ENABLE_OUTPUT
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
condition|)
operator|*
name|arg_i
operator||=
name|PCM_ENABLE_INPUT
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETODELAY
case|:
if|if
condition|(
name|wrch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|wrch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* XXX abusive DMA update: chn_wrupdate(wrch); */
operator|*
name|arg_i
operator|=
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_POST
case|:
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_NOTRIGGER
expr_stmt|;
name|chn_start
argument_list|(
name|wrch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SETDUPLEX
case|:
comment|/* 		 * switch to full-duplex mode if card is in half-duplex 		 * mode and is able to work in full-duplex mode 		 */
if|if
condition|(
name|rdch
operator|&&
name|wrch
operator|&&
operator|(
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|&
name|SD_F_SIMPLEX
operator|)
condition|)
name|dsp_set_flags
argument_list|(
name|i_dev
argument_list|,
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|^
name|SD_F_SIMPLEX
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * The following four ioctls are simple wrappers around mixer_ioctl 	 * with no further processing.  xcmd is short for "translated 	 * command". 	 */
case|case
name|SNDCTL_DSP_GETRECVOL
case|:
if|if
condition|(
name|xcmd
operator|==
literal|0
condition|)
name|xcmd
operator|=
name|SOUND_MIXER_READ_RECLEV
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SNDCTL_DSP_SETRECVOL
case|:
if|if
condition|(
name|xcmd
operator|==
literal|0
condition|)
name|xcmd
operator|=
name|SOUND_MIXER_WRITE_RECLEV
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SNDCTL_DSP_GETPLAYVOL
case|:
if|if
condition|(
name|xcmd
operator|==
literal|0
condition|)
name|xcmd
operator|=
name|SOUND_MIXER_READ_PCM
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SNDCTL_DSP_SETPLAYVOL
case|:
if|if
condition|(
name|xcmd
operator|==
literal|0
condition|)
name|xcmd
operator|=
name|SOUND_MIXER_WRITE_PCM
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mixer_dev
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|mixer_ioctl
argument_list|(
name|d
operator|->
name|mixer_dev
argument_list|,
name|xcmd
argument_list|,
name|arg
argument_list|,
operator|-
literal|1
argument_list|,
name|td
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|ENOTSUP
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_GET_RECSRC_NAMES
case|:
case|case
name|SNDCTL_DSP_GET_RECSRC
case|:
case|case
name|SNDCTL_DSP_SET_RECSRC
case|:
if|if
condition|(
name|d
operator|->
name|mixer_dev
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|mixer_ioctl
argument_list|(
name|d
operator|->
name|mixer_dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
operator|-
literal|1
argument_list|,
name|td
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|ENOTSUP
expr_stmt|;
break|break;
comment|/* 	 * The following 3 ioctls aren't very useful at the moment.  For 	 * now, only a single channel is associated with a cdev (/dev/dspN 	 * instance), so there's only a single output routing to use (i.e., 	 * the wrch bound to this cdev). 	 */
case|case
name|SNDCTL_DSP_GET_PLAYTGT_NAMES
case|:
block|{
name|oss_mixer_enuminfo
modifier|*
name|ei
decl_stmt|;
name|ei
operator|=
operator|(
name|oss_mixer_enuminfo
operator|*
operator|)
name|arg
expr_stmt|;
name|ei
operator|->
name|dev
operator|=
literal|0
expr_stmt|;
name|ei
operator|->
name|ctrl
operator|=
literal|0
expr_stmt|;
name|ei
operator|->
name|version
operator|=
literal|0
expr_stmt|;
comment|/* static for now */
name|ei
operator|->
name|strindex
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
operator|!=
name|NULL
condition|)
block|{
name|ei
operator|->
name|nvalues
operator|=
literal|1
expr_stmt|;
name|strlcpy
argument_list|(
name|ei
operator|->
name|strings
argument_list|,
name|wrch
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ei
operator|->
name|strings
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ei
operator|->
name|nvalues
operator|=
literal|0
expr_stmt|;
name|ei
operator|->
name|strings
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SNDCTL_DSP_GET_PLAYTGT
case|:
case|case
name|SNDCTL_DSP_SET_PLAYTGT
case|:
comment|/* yes, they are the same for now */
comment|/* 		 * Re: SET_PLAYTGT 		 *   OSSv4: "The value that was accepted by the device will 		 *   be returned back in the variable pointed by the 		 *   argument." 		 */
if|if
condition|(
name|wrch
operator|!=
name|NULL
condition|)
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_SILENCE
case|:
comment|/* 	 * Flush the software (pre-feed) buffer, but try to minimize playback 	 * interruption.  (I.e., record unplayed samples with intent to 	 * restore by SNDCTL_DSP_SKIP.) Intended for application "pause" 	 * functionality. 	 */
if|if
condition|(
name|wrch
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
while|while
condition|(
name|wrch
operator|->
name|inprog
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|wrch
operator|->
name|cv
argument_list|,
name|wrch
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bs
operator|=
name|wrch
operator|->
name|bufsoft
expr_stmt|;
if|if
condition|(
operator|(
name|bs
operator|->
name|shadbuf
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|bs
operator|->
name|sl
operator|=
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|sndbuf_dispose
argument_list|(
name|bs
argument_list|,
name|bs
operator|->
name|shadbuf
argument_list|,
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
argument_list|)
expr_stmt|;
name|sndbuf_fillsilence
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|chn_start
argument_list|(
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SKIP
case|:
comment|/* 	 * OSSv4 docs: "This ioctl call discards all unplayed samples in the 	 * playback buffer by moving the current write position immediately 	 * before the point where the device is currently reading the samples." 	 */
if|if
condition|(
name|wrch
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
while|while
condition|(
name|wrch
operator|->
name|inprog
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|wrch
operator|->
name|cv
argument_list|,
name|wrch
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bs
operator|=
name|wrch
operator|->
name|bufsoft
expr_stmt|;
if|if
condition|(
operator|(
name|bs
operator|->
name|shadbuf
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|bs
operator|->
name|sl
operator|>
literal|0
operator|)
condition|)
block|{
name|sndbuf_softreset
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|sndbuf_acquire
argument_list|(
name|bs
argument_list|,
name|bs
operator|->
name|shadbuf
argument_list|,
name|bs
operator|->
name|sl
argument_list|)
expr_stmt|;
name|bs
operator|->
name|sl
operator|=
literal|0
expr_stmt|;
name|chn_start
argument_list|(
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_CURRENT_OPTR
case|:
case|case
name|SNDCTL_DSP_CURRENT_IPTR
case|:
comment|/** 	 * @note Changing formats resets the buffer counters, which differs 	 * 	 from the 4Front drivers.  However, I don't expect this to be 	 * 	 much of a problem. 	 * 	 * @note In a test where @c CURRENT_OPTR is called immediately after write 	 * 	 returns, this driver is about 32K samples behind whereas 	 * 	 4Front's is about 8K samples behind.  Should determine source 	 * 	 of discrepancy, even if only out of curiosity. 	 * 	 * @todo Actually test SNDCTL_DSP_CURRENT_IPTR. 	 */
name|chn
operator|=
operator|(
name|cmd
operator|==
name|SNDCTL_DSP_CURRENT_OPTR
operator|)
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
decl_stmt|;
comment|/* int tmp; */
name|oss_count_t
modifier|*
name|oc
init|=
operator|(
name|oss_count_t
operator|*
operator|)
name|arg
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|bs
operator|=
name|chn
operator|->
name|bufsoft
expr_stmt|;
if|#
directive|if
literal|0
block|tmp = (sndbuf_getsize(b) + chn_getptr(chn) - sndbuf_gethwptr(b)) % sndbuf_getsize(b); 			oc->samples = (sndbuf_gettotal(b) + tmp) / sndbuf_getbps(b); 			oc->fifo_samples = (sndbuf_getready(b) - tmp) / sndbuf_getbps(b);
else|#
directive|else
name|oc
operator|->
name|samples
operator|=
name|sndbuf_gettotal
argument_list|(
name|bs
argument_list|)
operator|/
name|sndbuf_getbps
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|oc
operator|->
name|fifo_samples
operator|=
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
operator|/
name|sndbuf_getbps
argument_list|(
name|bs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_HALT_OUTPUT
case|:
case|case
name|SNDCTL_DSP_HALT_INPUT
case|:
name|chn
operator|=
operator|(
name|cmd
operator|==
name|SNDCTL_DSP_HALT_OUTPUT
operator|)
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|chn_abort
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_LOW_WATER
case|:
comment|/* 	 * Set the number of bytes required to attract attention by 	 * select/poll. 	 */
if|if
condition|(
name|wrch
operator|!=
name|NULL
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|lw
operator|=
operator|(
operator|*
name|arg_i
operator|>
literal|1
operator|)
condition|?
operator|*
name|arg_i
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|!=
name|NULL
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|rdch
operator|->
name|lw
operator|=
operator|(
operator|*
name|arg_i
operator|>
literal|1
operator|)
condition|?
operator|*
name|arg_i
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETERROR
case|:
comment|/* 	 * OSSv4 docs:  "All errors and counters will automatically be 	 * cleared to zeroes after the call so each call will return only 	 * the errors that occurred after the previous invocation. ... The 	 * play_underruns and rec_overrun fields are the only usefull fields 	 * returned by OSS 4.0." 	 */
block|{
name|audio_errinfo
modifier|*
name|ei
init|=
operator|(
name|audio_errinfo
operator|*
operator|)
name|arg
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ei
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ei
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
operator|!=
name|NULL
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ei
operator|->
name|play_underruns
operator|=
name|wrch
operator|->
name|xruns
expr_stmt|;
name|wrch
operator|->
name|xruns
operator|=
literal|0
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|!=
name|NULL
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ei
operator|->
name|rec_overruns
operator|=
name|rdch
operator|->
name|xruns
expr_stmt|;
name|rdch
operator|->
name|xruns
operator|=
literal|0
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SNDCTL_DSP_SYNCGROUP
case|:
name|ret
operator|=
name|dsp_oss_syncgroup
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|oss_syncgroup
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_SYNCSTART
case|:
name|ret
operator|=
name|dsp_oss_syncstart
argument_list|(
operator|*
name|arg_i
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_POLICY
case|:
name|ret
operator|=
name|dsp_oss_policy
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OSSV4_EXPERIMENT
comment|/* 	 * XXX The following ioctls are not yet supported and just return 	 * EINVAL. 	 */
case|case
name|SNDCTL_DSP_GETOPEAKS
case|:
case|case
name|SNDCTL_DSP_GETIPEAKS
case|:
name|chn
operator|=
operator|(
name|cmd
operator|==
name|SNDCTL_DSP_GETOPEAKS
operator|)
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|oss_peaks_t
modifier|*
name|op
init|=
operator|(
name|oss_peaks_t
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|lpeak
decl_stmt|,
name|rpeak
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_getpeaks
argument_list|(
name|chn
argument_list|,
operator|&
name|lpeak
argument_list|,
operator|&
name|rpeak
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
operator|(
operator|*
name|op
operator|)
index|[
literal|0
index|]
operator|=
name|lpeak
expr_stmt|;
operator|(
operator|*
name|op
operator|)
index|[
literal|1
index|]
operator|=
name|rpeak
expr_stmt|;
block|}
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_COOKEDMODE
case|:
name|ret
operator|=
name|dsp_oss_cookedmode
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_GET_CHNORDER
case|:
name|ret
operator|=
name|dsp_oss_getchnorder
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_SET_CHNORDER
case|:
name|ret
operator|=
name|dsp_oss_setchnorder
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_GETLABEL
case|:
name|ret
operator|=
name|dsp_oss_getlabel
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|oss_label_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SETLABEL
case|:
name|ret
operator|=
name|dsp_oss_setlabel
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|oss_label_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_GETSONG
case|:
name|ret
operator|=
name|dsp_oss_getsong
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|oss_longname_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SETSONG
case|:
name|ret
operator|=
name|dsp_oss_setsong
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|oss_longname_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SETNAME
case|:
name|ret
operator|=
name|dsp_oss_setname
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|oss_longname_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/** 	 * @note The SNDCTL_CARDINFO ioctl was omitted per 4Front developer 	 * documentation.  "The usability of this call is very limited. It's 	 * provided only for completeness of the API. OSS API doesn't have 	 * any concept of card. Any information returned by this ioctl calld 	 * is reserved exclusively for the utility programs included in the 	 * OSS package. Applications should not try to use for this 	 * information in any ways." 	 */
block|case SNDCTL_CARDINFO: 		ret = EINVAL; 		break;
comment|/** 	 * @note The S/PDIF interface ioctls, @c SNDCTL_DSP_READCTL and 	 * @c SNDCTL_DSP_WRITECTL have been omitted at the suggestion of 	 * 4Front Technologies. 	 */
block|case SNDCTL_DSP_READCTL: 	case SNDCTL_DSP_WRITECTL: 		ret = EINVAL; 		break;
endif|#
directive|endif
comment|/* !0 (explicitly omitted ioctls) */
endif|#
directive|endif
comment|/* !OSSV4_EXPERIMENT */
case|case
name|SNDCTL_DSP_MAPINBUF
case|:
case|case
name|SNDCTL_DSP_MAPOUTBUF
case|:
case|case
name|SNDCTL_DSP_SETSYNCRO
case|:
comment|/* undocumented */
case|case
name|SNDCTL_DSP_SUBDIVIDE
case|:
case|case
name|SOUND_PCM_WRITE_FILTER
case|:
case|case
name|SOUND_PCM_READ_FILTER
case|:
comment|/* dunno what these do, don't sound important */
default|default:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"default ioctl fn 0x%08lx fail\n"
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|wrch
init|=
name|NULL
decl_stmt|,
modifier|*
name|rdch
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|e
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|e
operator|=
operator|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|ret
operator||=
name|chn_poll
argument_list|(
name|wrch
argument_list|,
name|e
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|e
operator|=
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|ret
operator||=
name|chn_poll
argument_list|(
name|rdch
argument_list|,
name|e
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_mmap
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|wrch
init|=
name|NULL
decl_stmt|,
modifier|*
name|rdch
init|=
name|NULL
decl_stmt|,
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|-
literal|1
return|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * XXX the linux api uses the nprot to select read/write buffer 	 * our vm system doesn't allow this, so force write buffer 	 */
block|if (wrch&& (nprot& PROT_WRITE)) { 		c = wrch; 	} else if (rdch&& (nprot& PROT_READ)) { 		c = rdch; 	} else { 		return -1; 	}
else|#
directive|else
name|c
operator|=
name|wrch
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|offset
operator|>=
name|sndbuf_getsize
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|)
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
operator|)
condition|)
name|c
operator|->
name|flags
operator||=
name|CHN_F_MAPPED
expr_stmt|;
operator|*
name|paddr
operator|=
name|vtophys
argument_list|(
name|sndbuf_getbufofs
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USING_DEVFS
end_ifdef

begin_comment
comment|/*  * Clone logic is this:  * x E X = {dsp, dspW, audio}  * x -> x${sysctl("hw.snd.unit")}  * xN->  *    for i N = 1 to channels of device N  *    	if xN.i isn't busy, return its dev_t  */
end_comment

begin_function
specifier|static
name|void
name|dsp_clone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|cdev
modifier|*
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|cdev
modifier|*
name|pdev
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|pcm_dev
decl_stmt|;
name|struct
name|snddev_channel
modifier|*
name|pcm_chan
decl_stmt|;
name|int
name|i
decl_stmt|,
name|unit
decl_stmt|,
name|devtype
decl_stmt|;
specifier|static
name|int
name|devtypes
index|[
literal|3
index|]
init|=
block|{
name|SND_DEV_DSP
block|,
name|SND_DEV_DSP16
block|,
name|SND_DEV_AUDIO
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|devnames
index|[
literal|3
index|]
init|=
block|{
literal|"dsp"
block|,
literal|"dspW"
block|,
literal|"audio"
block|}
decl_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
name|pcm_devclass
operator|==
name|NULL
condition|)
return|return;
name|devtype
operator|=
literal|0
expr_stmt|;
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|3
operator|)
operator|&&
operator|(
name|unit
operator|==
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|devtype
operator|=
name|devtypes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|devnames
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unit
operator|=
name|snd_unit
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dev_stdclone
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|devnames
index|[
name|i
index|]
argument_list|,
operator|&
name|unit
argument_list|)
operator|!=
literal|1
condition|)
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unit
operator|==
operator|-
literal|1
operator|||
name|unit
operator|>=
name|devclass_get_maxunit
argument_list|(
name|pcm_devclass
argument_list|)
condition|)
return|return;
name|pcm_dev
operator|=
name|devclass_get_softc
argument_list|(
name|pcm_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcm_dev
operator|==
name|NULL
condition|)
return|return;
name|SLIST_FOREACH
argument_list|(
argument|pcm_chan
argument_list|,
argument|&pcm_dev->channels
argument_list|,
argument|link
argument_list|)
block|{
switch|switch
condition|(
name|devtype
condition|)
block|{
case|case
name|SND_DEV_DSP
case|:
name|pdev
operator|=
name|pcm_chan
operator|->
name|dsp_devt
expr_stmt|;
break|break;
case|case
name|SND_DEV_DSP16
case|:
name|pdev
operator|=
name|pcm_chan
operator|->
name|dspW_devt
expr_stmt|;
break|break;
case|case
name|SND_DEV_AUDIO
case|:
name|pdev
operator|=
name|pcm_chan
operator|->
name|audio_devt
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown devtype %d"
argument_list|,
name|devtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pdev
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pdev
operator|->
name|si_drv1
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|pdev
operator|->
name|si_drv2
operator|==
name|NULL
operator|)
condition|)
block|{
operator|*
name|dev
operator|=
name|pdev
expr_stmt|;
name|dev_ref
argument_list|(
operator|*
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_sysinit
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|dsp_ehtag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_clone
argument_list|,
name|dsp_clone
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_sysuninit
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|dsp_ehtag
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|dev_clone
argument_list|,
name|dsp_ehtag
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|dsp_sysinit
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|dsp_sysinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|dsp_sysuninit
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|dsp_sysuninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @brief Handler for SNDCTL_AUDIOINFO.  *  * Gathers information about the audio device specified in ai->dev.  If  * ai->dev == -1, then this function gathers information about the current  * device.  If the call comes in on a non-audio device and ai->dev == -1,  * return EINVAL.  *  * This routine is supposed to go practically straight to the hardware,  * getting capabilities directly from the sound card driver, side-stepping  * the intermediate channel interface.  *  * Note, however, that the usefulness of this command is significantly  * decreased when requesting info about any device other than the one serving  * the request. While each snddev_channel refers to a specific device node,  * the converse is *not* true.  Currently, when a sound device node is opened,  * the sound subsystem scans for an available audio channel (or channels, if  * opened in read+write) and then assigns them to the si_drv[12] private  * data fields.  As a result, any information returned linking a channel to  * a specific character device isn't necessarily accurate.  *  * @note  * Calling threads must not hold any snddev_info or pcm_channel locks.  *   * @param dev		device on which the ioctl was issued  * @param ai		ioctl request data container  *  * @retval 0		success  * @retval EINVAL	ai->dev specifies an invalid device  *  * @todo Verify correctness of Doxygen tags.  ;)  */
end_comment

begin_function
name|int
name|dsp_oss_audioinfo
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|oss_audioinfo
modifier|*
name|ai
parameter_list|)
block|{
name|struct
name|snddev_channel
modifier|*
name|sce
decl_stmt|;
name|struct
name|pcmchan_caps
modifier|*
name|caps
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|ch
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|cdev
modifier|*
name|t_cdev
decl_stmt|;
name|uint32_t
name|fmts
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nchan
decl_stmt|,
name|ret
decl_stmt|,
modifier|*
name|rates
decl_stmt|,
name|minch
decl_stmt|,
name|maxch
decl_stmt|;
comment|/* 	 * If probing the device that received the ioctl, make sure it's a 	 * DSP device.  (Users may use this ioctl with /dev/mixer and 	 * /dev/midi.) 	 */
if|if
condition|(
operator|(
name|ai
operator|->
name|dev
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|i_dev
operator|->
name|si_devsw
operator|!=
operator|&
name|dsp_cdevsw
operator|)
condition|)
return|return
name|EINVAL
return|;
name|ch
operator|=
name|NULL
expr_stmt|;
name|t_cdev
operator|=
name|NULL
expr_stmt|;
name|nchan
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Search for the requested audio device (channel).  Start by 	 * iterating over pcm devices. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devclass_get_maxunit
argument_list|(
name|pcm_devclass
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
name|devclass_get_softc
argument_list|(
name|pcm_devclass
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
continue|continue;
comment|/* See the note in function docblock */
name|mtx_assert
argument_list|(
name|d
operator|->
name|lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|pcm_inprog
argument_list|(
name|d
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|sce
argument_list|,
argument|&d->channels
argument_list|,
argument|link
argument_list|)
block|{
name|ch
operator|=
name|sce
operator|->
name|channel
expr_stmt|;
name|mtx_assert
argument_list|(
name|ch
operator|->
name|lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|dev
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|==
name|i_dev
operator|->
name|si_drv1
operator|)
operator|||
comment|/* record ch */
operator|(
name|ch
operator|==
name|i_dev
operator|->
name|si_drv2
operator|)
condition|)
block|{
comment|/* playback ch */
name|t_cdev
operator|=
name|i_dev
expr_stmt|;
goto|goto
name|dspfound
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|ai
operator|->
name|dev
operator|==
name|nchan
condition|)
block|{
name|t_cdev
operator|=
name|sce
operator|->
name|dsp_devt
expr_stmt|;
goto|goto
name|dspfound
goto|;
block|}
name|CHN_UNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
operator|++
name|nchan
expr_stmt|;
block|}
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pcm_inprog
argument_list|(
name|d
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Exhausted the search -- nothing is locked, so return. */
return|return
name|EINVAL
return|;
name|dspfound
label|:
comment|/* Should've found the device, but something isn't right */
if|if
condition|(
name|t_cdev
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * At this point, the following synchronization stuff has happened: 	 *   - a specific PCM device is locked and its "in progress 	 *     operations" counter has been incremented, so be sure to unlock 	 *     and decrement when exiting; 	 *   - a specific audio channel has been locked, so be sure to unlock 	 *     when exiting; 	 */
name|caps
operator|=
name|chn_getcaps
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* 	 * With all handles collected, zero out the user's container and 	 * begin filling in its fields. 	 */
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ai
argument_list|,
sizeof|sizeof
argument_list|(
name|oss_audioinfo
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|dev
operator|=
name|nchan
expr_stmt|;
name|strlcpy
argument_list|(
name|ai
operator|->
name|name
argument_list|,
name|ch
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ai
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|flags
operator|&
name|CHN_F_BUSY
operator|)
operator|==
literal|0
condition|)
name|ai
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
else|else
name|ai
operator|->
name|busy
operator|=
operator|(
name|ch
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|OPEN_WRITE
else|:
name|OPEN_READ
expr_stmt|;
comment|/** 	 * @note 	 * @c cmd - OSSv4 docs: "Only supported under Linux at this moment." 	 * 	Cop-out, I know, but I'll save running around in the process 	 * 	table for later.  Is there a risk of leaking information? 	 */
name|ai
operator|->
name|pid
operator|=
name|ch
operator|->
name|pid
expr_stmt|;
comment|/* 	 * These flags stolen from SNDCTL_DSP_GETCAPS handler.  Note, however, 	 * that a single channel operates in only one direction, so 	 * DSP_CAP_DUPLEX is out. 	 */
comment|/** 	 * @todo @c SNDCTL_AUDIOINFO::caps - Make drivers keep these in 	 * 	 pcmchan::caps? 	 */
name|ai
operator|->
name|caps
operator|=
name|DSP_CAP_REALTIME
operator||
name|DSP_CAP_MMAP
operator||
name|DSP_CAP_TRIGGER
expr_stmt|;
comment|/* 	 * Collect formats supported @b natively by the device.  Also 	 * determine min/max channels.  (I.e., mono, stereo, or both?) 	 * 	 * If any channel is stereo, maxch = 2; 	 * if all channels are stereo, minch = 2, too; 	 * if any channel is mono, minch = 1; 	 * and if all channels are mono, maxch = 1. 	 */
name|minch
operator|=
literal|0
expr_stmt|;
name|maxch
operator|=
literal|0
expr_stmt|;
name|fmts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|caps
operator|->
name|fmtlist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|fmts
operator||=
name|caps
operator|->
name|fmtlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|caps
operator|->
name|fmtlist
index|[
name|i
index|]
operator|&
name|AFMT_STEREO
condition|)
block|{
name|minch
operator|=
operator|(
name|minch
operator|==
literal|0
operator|)
condition|?
literal|2
else|:
name|minch
expr_stmt|;
name|maxch
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|minch
operator|=
literal|1
expr_stmt|;
name|maxch
operator|=
operator|(
name|maxch
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|maxch
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ch
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
name|ai
operator|->
name|oformats
operator|=
name|fmts
expr_stmt|;
else|else
name|ai
operator|->
name|iformats
operator|=
name|fmts
expr_stmt|;
comment|/** 	 * @note 	 * @c magic - OSSv4 docs: "Reserved for internal use by OSS." 	 * 	 * @par 	 * @c card_number - OSSv4 docs: "Number of the sound card where this 	 * 	device belongs or -1 if this information is not available. 	 * 	Applications should normally not use this field for any 	 * 	purpose." 	 */
name|ai
operator|->
name|card_number
operator|=
operator|-
literal|1
expr_stmt|;
comment|/** 	 * @todo @c song_name - depends first on SNDCTL_[GS]ETSONG 	 * @todo @c label - depends on SNDCTL_[GS]ETLABEL 	 * @todo @c port_number - routing information? 	 */
name|ai
operator|->
name|port_number
operator|=
operator|-
literal|1
expr_stmt|;
name|ai
operator|->
name|mixer_dev
operator|=
operator|(
name|d
operator|->
name|mixer_dev
operator|!=
name|NULL
operator|)
condition|?
name|PCMUNIT
argument_list|(
name|d
operator|->
name|mixer_dev
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
comment|/** 	 * @note 	 * @c real_device - OSSv4 docs:  "Obsolete." 	 */
name|ai
operator|->
name|real_device
operator|=
operator|-
literal|1
expr_stmt|;
name|strlcpy
argument_list|(
name|ai
operator|->
name|devnode
argument_list|,
name|t_cdev
operator|->
name|si_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ai
operator|->
name|devnode
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|enabled
operator|=
name|device_is_attached
argument_list|(
name|d
operator|->
name|dev
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/** 	 * @note 	 * @c flags - OSSv4 docs: "Reserved for future use." 	 * 	 * @note 	 * @c binding - OSSv4 docs: "Reserved for future use." 	 * 	 * @todo @c handle - haven't decided how to generate this yet; bus, 	 * 	vendor, device IDs? 	 */
name|ai
operator|->
name|min_rate
operator|=
name|caps
operator|->
name|minspeed
expr_stmt|;
name|ai
operator|->
name|max_rate
operator|=
name|caps
operator|->
name|maxspeed
expr_stmt|;
name|ai
operator|->
name|min_channels
operator|=
name|minch
expr_stmt|;
name|ai
operator|->
name|max_channels
operator|=
name|maxch
expr_stmt|;
name|ai
operator|->
name|nrates
operator|=
name|chn_getrates
argument_list|(
name|ch
argument_list|,
operator|&
name|rates
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|nrates
operator|>
name|OSS_MAX_SAMPLE_RATES
condition|)
name|ai
operator|->
name|nrates
operator|=
name|OSS_MAX_SAMPLE_RATES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ai
operator|->
name|nrates
condition|;
name|i
operator|++
control|)
name|ai
operator|->
name|rates
index|[
name|i
index|]
operator|=
name|rates
index|[
name|i
index|]
expr_stmt|;
name|out
label|:
name|CHN_UNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pcm_inprog
argument_list|(
name|d
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Assigns a PCM channel to a sync group.  *  * Sync groups are used to enable audio operations on multiple devices  * simultaneously.  They may be used with any number of devices and may  * span across applications.  Devices are added to groups with  * the SNDCTL_DSP_SYNCGROUP ioctl, and operations are triggered with the  * SNDCTL_DSP_SYNCSTART ioctl.  *  * If the @c id field of the @c group parameter is set to zero, then a new  * sync group is created.  Otherwise, wrch and rdch (if set) are added to  * the group specified.  *  * @todo As far as memory allocation, should we assume that things are  * 	 okay and allocate with M_WAITOK before acquiring channel locks,  * 	 freeing later if not?  *  * @param wrch	output channel associated w/ device (if any)  * @param rdch	input channel associated w/ device (if any)  * @param group Sync group parameters  *  * @retval 0		success  * @retval non-zero	error to be propagated upstream  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_syncgroup
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_syncgroup
modifier|*
name|group
parameter_list|)
block|{
name|struct
name|pcmchan_syncmember
modifier|*
name|smrd
decl_stmt|,
modifier|*
name|smwr
decl_stmt|;
name|struct
name|pcmchan_syncgroup
modifier|*
name|sg
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|sg_ids
index|[
literal|3
index|]
decl_stmt|;
name|smrd
operator|=
name|NULL
expr_stmt|;
name|smwr
operator|=
name|NULL
expr_stmt|;
name|sg
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Free_unr() may sleep, so store released syncgroup IDs until after 	 * all locks are released. 	 */
name|sg_ids
index|[
literal|0
index|]
operator|=
name|sg_ids
index|[
literal|1
index|]
operator|=
name|sg_ids
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|PCM_SG_LOCK
argument_list|()
expr_stmt|;
comment|/* 	 * - Insert channel(s) into group's member list. 	 * - Set CHN_F_NOTRIGGER on channel(s). 	 * - Stop channel(s).   	 */
comment|/* 	 * If device's channels are already mapped to a group, unmap them. 	 */
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|sg_ids
index|[
literal|0
index|]
operator|=
name|chn_syncdestroy
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|sg_ids
index|[
literal|1
index|]
operator|=
name|chn_syncdestroy
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Verify that mode matches character device properites. 	 *  - Bail if PCM_ENABLE_OUTPUT&& wrch == NULL. 	 *  - Bail if PCM_ENABLE_INPUT&& rdch == NULL. 	 */
if|if
condition|(
operator|(
operator|(
name|wrch
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|group
operator|->
name|mode
operator|&
name|PCM_ENABLE_OUTPUT
operator|)
operator|)
operator|||
operator|(
operator|(
name|rdch
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|group
operator|->
name|mode
operator|&
name|PCM_ENABLE_INPUT
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * An id of zero indicates the user wants to create a new 	 * syncgroup. 	 */
if|if
condition|(
name|group
operator|->
name|id
operator|==
literal|0
condition|)
block|{
name|sg
operator|=
operator|(
expr|struct
name|pcmchan_syncgroup
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg
operator|!=
name|NULL
condition|)
block|{
name|SLIST_INIT
argument_list|(
operator|&
name|sg
operator|->
name|members
argument_list|)
expr_stmt|;
name|sg
operator|->
name|id
operator|=
name|alloc_unr
argument_list|(
name|pcmsg_unrhdr
argument_list|)
expr_stmt|;
name|group
operator|->
name|id
operator|=
name|sg
operator|->
name|id
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|snd_pcm_syncgroups
argument_list|,
name|sg
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
name|SLIST_FOREACH
argument_list|(
argument|sg
argument_list|,
argument|&snd_pcm_syncgroups
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|sg
operator|->
name|id
operator|==
name|group
operator|->
name|id
condition|)
break|break;
block|}
if|if
condition|(
name|sg
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* Couldn't create or find a syncgroup.  Fail. */
if|if
condition|(
name|sg
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Allocate a syncmember, assign it and a channel together, and 	 * insert into syncgroup. 	 */
if|if
condition|(
name|group
operator|->
name|mode
operator|&
name|PCM_ENABLE_INPUT
condition|)
block|{
name|smrd
operator|=
operator|(
expr|struct
name|pcmchan_syncmember
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|smrd
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|smrd
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sg
operator|->
name|members
argument_list|,
name|smrd
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|smrd
operator|->
name|parent
operator|=
name|sg
expr_stmt|;
name|smrd
operator|->
name|ch
operator|=
name|rdch
expr_stmt|;
name|chn_abort
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_NOTRIGGER
expr_stmt|;
name|rdch
operator|->
name|sm
operator|=
name|smrd
expr_stmt|;
block|}
if|if
condition|(
name|group
operator|->
name|mode
operator|&
name|PCM_ENABLE_OUTPUT
condition|)
block|{
name|smwr
operator|=
operator|(
expr|struct
name|pcmchan_syncmember
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|smwr
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|smwr
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sg
operator|->
name|members
argument_list|,
name|smwr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|smwr
operator|->
name|parent
operator|=
name|sg
expr_stmt|;
name|smwr
operator|->
name|ch
operator|=
name|wrch
expr_stmt|;
name|chn_abort
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_NOTRIGGER
expr_stmt|;
name|wrch
operator|->
name|sm
operator|=
name|smwr
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|smrd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|smrd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sg
operator|!=
name|NULL
operator|)
operator|&&
name|SLIST_EMPTY
argument_list|(
operator|&
name|sg
operator|->
name|members
argument_list|)
condition|)
block|{
name|sg_ids
index|[
literal|2
index|]
operator|=
name|sg
operator|->
name|id
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|snd_pcm_syncgroups
argument_list|,
name|sg
argument_list|,
name|pcmchan_syncgroup
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sg
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
name|wrch
operator|->
name|sm
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
name|rdch
operator|->
name|sm
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|PCM_SG_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sg_ids
index|[
literal|0
index|]
condition|)
name|free_unr
argument_list|(
name|pcmsg_unrhdr
argument_list|,
name|sg_ids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_ids
index|[
literal|1
index|]
condition|)
name|free_unr
argument_list|(
name|pcmsg_unrhdr
argument_list|,
name|sg_ids
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_ids
index|[
literal|2
index|]
condition|)
name|free_unr
argument_list|(
name|pcmsg_unrhdr
argument_list|,
name|sg_ids
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Launch a sync group into action  *  * Sync groups are established via SNDCTL_DSP_SYNCGROUP.  This function  * iterates over all members, triggering them along the way.  *  * @note Caller must not hold any channel locks.  *  * @param sg_id	sync group identifier  *  * @retval 0	success  * @retval non-zero	error worthy of propagating upstream to user  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_syncstart
parameter_list|(
name|int
name|sg_id
parameter_list|)
block|{
name|struct
name|pcmchan_syncmember
modifier|*
name|sm
decl_stmt|,
modifier|*
name|sm_tmp
decl_stmt|;
name|struct
name|pcmchan_syncgroup
modifier|*
name|sg
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|needlocks
decl_stmt|;
comment|/* Get the synclists lock */
name|PCM_SG_LOCK
argument_list|()
expr_stmt|;
do|do
block|{
name|ret
operator|=
literal|0
expr_stmt|;
name|needlocks
operator|=
literal|0
expr_stmt|;
comment|/* Search for syncgroup by ID */
name|SLIST_FOREACH
argument_list|(
argument|sg
argument_list|,
argument|&snd_pcm_syncgroups
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|sg
operator|->
name|id
operator|==
name|sg_id
condition|)
break|break;
block|}
comment|/* Return EINVAL if not found */
if|if
condition|(
name|sg
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Any removals resulting in an empty group should've handled this */
name|KASSERT
argument_list|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|sg
operator|->
name|members
argument_list|)
argument_list|,
operator|(
literal|"found empty syncgroup"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Attempt to lock all member channels - if any are already 		 * locked, unlock those acquired, sleep for a bit, and try 		 * again. 		 */
name|SLIST_FOREACH
argument_list|(
argument|sm
argument_list|,
argument|&sg->members
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|CHN_TRYLOCK
argument_list|(
name|sm
operator|->
name|ch
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|timo
init|=
name|hz
operator|*
literal|5
operator|/
literal|1000
decl_stmt|;
if|if
condition|(
name|timo
operator|<
literal|1
condition|)
name|timo
operator|=
literal|1
expr_stmt|;
comment|/* Release all locked channels so far, retry */
name|SLIST_FOREACH
argument_list|(
argument|sm_tmp
argument_list|,
argument|&sg->members
argument_list|,
argument|link
argument_list|)
block|{
comment|/* sm is the member already locked */
if|if
condition|(
name|sm
operator|==
name|sm_tmp
condition|)
break|break;
name|CHN_UNLOCK
argument_list|(
name|sm_tmp
operator|->
name|ch
argument_list|)
expr_stmt|;
block|}
comment|/** @todo Is PRIBIO correct/ */
name|ret
operator|=
name|msleep
argument_list|(
name|sm
argument_list|,
operator|&
name|snd_pcm_syncgroups_mtx
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmsgrp"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
condition|)
break|break;
name|needlocks
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* Assumes ret == EAGAIN... */
block|}
block|}
block|}
do|while
condition|(
name|needlocks
operator|&&
name|ret
operator|==
literal|0
condition|)
do|;
comment|/* Proceed only if no errors encountered. */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* Launch channels */
while|while
condition|(
operator|(
name|sm
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sg
operator|->
name|members
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sg
operator|->
name|members
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|c
operator|=
name|sm
operator|->
name|ch
expr_stmt|;
name|c
operator|->
name|sm
operator|=
name|NULL
expr_stmt|;
name|chn_start
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_NOTRIGGER
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|SLIST_REMOVE
argument_list|(
operator|&
name|snd_pcm_syncgroups
argument_list|,
name|sg
argument_list|,
name|pcmchan_syncgroup
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sg
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|PCM_SG_UNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Free_unr() may sleep, so be sure to give up the syncgroup lock 	 * first. 	 */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|free_unr
argument_list|(
name|pcmsg_unrhdr
argument_list|,
name|sg_id
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Handler for SNDCTL_DSP_POLICY  *  * The SNDCTL_DSP_POLICY ioctl is a simpler interface to control fragment  * size and count like with SNDCTL_DSP_SETFRAGMENT.  Instead of the user  * specifying those two parameters, s/he simply selects a number from 0..10  * which corresponds to a buffer size.  Smaller numbers request smaller  * buffers with lower latencies (at greater overhead from more frequent  * interrupts), while greater numbers behave in the opposite manner.  *  * The 4Front spec states that a value of 5 should be the default.  However,  * this implementation deviates slightly by using a linear scale without  * consulting drivers.  I.e., even though drivers may have different default  * buffer sizes, a policy argument of 5 will have the same result across  * all drivers.  *  * See http://manuals.opensound.com/developer/SNDCTL_DSP_POLICY.html for  * more information.  *  * @todo When SNDCTL_DSP_COOKEDMODE is supported, it'll be necessary to  * 	 work with hardware drivers directly.  *  * @note PCM channel arguments must not be locked by caller.  *  * @param wrch	Pointer to opened playback channel (optional; may be NULL)  * @param rdch	" recording channel (optional; may be NULL)  * @param policy Integer from [0:10]  *  * @retval 0	constant (for now)  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_policy
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|int
name|policy
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|policy
operator|<
name|CHN_POLICY_MIN
operator|||
name|policy
operator|>
name|CHN_POLICY_MAX
condition|)
return|return
name|EIO
return|;
comment|/* Default: success */
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setlatency
argument_list|(
name|rdch
argument_list|,
name|policy
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setlatency
argument_list|(
name|wrch
argument_list|,
name|policy
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
name|ret
operator|=
name|EIO
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OSSV4_EXPERIMENT
end_ifdef

begin_comment
comment|/**  * @brief Enable or disable "cooked" mode  *  * This is a handler for @c SNDCTL_DSP_COOKEDMODE.  When in cooked mode, which  * is the default, the sound system handles rate and format conversions  * automatically (ex: user writing 11025Hz/8 bit/unsigned but card only  * operates with 44100Hz/16bit/signed samples).  *  * Disabling cooked mode is intended for applications wanting to mmap()  * a sound card's buffer space directly, bypassing the FreeBSD 2-stage  * feeder architecture, presumably to gain as much control over audio  * hardware as possible.  *  * See @c http://manuals.opensound.com/developer/SNDCTL_DSP_COOKEDMODE.html  * for more details.  *  * @note Currently, this function is just a stub that always returns EINVAL.  *  * @todo Figure out how to and actually implement this.  *  * @param wrch		playback channel (optional; may be NULL)  * @param rdch		recording channel (optional; may be NULL)  * @param enabled	0 = raw mode, 1 = cooked mode  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_cookedmode
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Retrieve channel interleaving order  *  * This is the handler for @c SNDCTL_DSP_GET_CHNORDER.  *  * See @c http://manuals.opensound.com/developer/SNDCTL_DSP_GET_CHNORDER.html  * for more details.  *  * @note As the ioctl definition is still under construction, FreeBSD  * 	 does not currently support SNDCTL_DSP_GET_CHNORDER.  *  * @param wrch	playback channel (optional; may be NULL)  * @param rdch	recording channel (optional; may be NULL)  * @param map	channel map (result will be stored there)  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_getchnorder
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|unsigned
name|long
name|long
modifier|*
name|map
parameter_list|)
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Specify channel interleaving order  *  * This is the handler for @c SNDCTL_DSP_SET_CHNORDER.  *  * @note As the ioctl definition is still under construction, FreeBSD  * 	 does not currently support @c SNDCTL_DSP_SET_CHNORDER.  *  * @param wrch	playback channel (optional; may be NULL)  * @param rdch	recording channel (optional; may be NULL)  * @param map	channel map  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_setchnorder
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|unsigned
name|long
name|long
modifier|*
name|map
parameter_list|)
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Retrieve an audio device's label  *  * This is a handler for the @c SNDCTL_GETLABEL ioctl.  *  * See @c http://manuals.opensound.com/developer/SNDCTL_GETLABEL.html  * for more details.  *  * From Hannu@4Front:  "For example ossxmix (just like some HW mixer  * consoles) can show variable "labels" for certain controls. By default  * the application name (say quake) is shown as the label but  * applications may change the labels themselves."  *  * @note As the ioctl definition is still under construction, FreeBSD  * 	 does not currently support @c SNDCTL_GETLABEL.  *  * @param wrch	playback channel (optional; may be NULL)  * @param rdch	recording channel (optional; may be NULL)  * @param label	label gets copied here  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_getlabel
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_label_t
modifier|*
name|label
parameter_list|)
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Specify an audio device's label  *  * This is a handler for the @c SNDCTL_SETLABEL ioctl.  Please see the  * comments for @c dsp_oss_getlabel immediately above.  *  * See @c http://manuals.opensound.com/developer/SNDCTL_GETLABEL.html  * for more details.  *  * @note As the ioctl definition is still under construction, FreeBSD  * 	 does not currently support SNDCTL_SETLABEL.  *  * @param wrch	playback channel (optional; may be NULL)  * @param rdch	recording channel (optional; may be NULL)  * @param label	label gets copied from here  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_setlabel
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_label_t
modifier|*
name|label
parameter_list|)
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Retrieve name of currently played song  *  * This is a handler for the @c SNDCTL_GETSONG ioctl.  Audio players could  * tell the system the name of the currently playing song, which would be  * visible in @c /dev/sndstat.  *  * See @c http://manuals.opensound.com/developer/SNDCTL_GETSONG.html  * for more details.  *  * @note As the ioctl definition is still under construction, FreeBSD  * 	 does not currently support SNDCTL_GETSONG.  *  * @param wrch	playback channel (optional; may be NULL)  * @param rdch	recording channel (optional; may be NULL)  * @param song	song name gets copied here  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_getsong
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_longname_t
modifier|*
name|song
parameter_list|)
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Retrieve name of currently played song  *  * This is a handler for the @c SNDCTL_SETSONG ioctl.  Audio players could  * tell the system the name of the currently playing song, which would be  * visible in @c /dev/sndstat.  *  * See @c http://manuals.opensound.com/developer/SNDCTL_SETSONG.html  * for more details.  *  * @note As the ioctl definition is still under construction, FreeBSD  * 	 does not currently support SNDCTL_SETSONG.  *  * @param wrch	playback channel (optional; may be NULL)  * @param rdch	recording channel (optional; may be NULL)  * @param song	song name gets copied from here  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_setsong
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_longname_t
modifier|*
name|song
parameter_list|)
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Rename a device  *  * This is a handler for the @c SNDCTL_SETNAME ioctl.  *  * See @c http://manuals.opensound.com/developer/SNDCTL_SETNAME.html for  * more details.  *  * From Hannu@4Front:  "This call is used to change the device name  * reported in /dev/sndstat and ossinfo. So instead of  using some generic  * 'OSS loopback audio (MIDI) driver' the device may be given a meaningfull  * name depending on the current context (for example 'OSS virtual wave table  * synth' or 'VoIP link to London')."  *  * @note As the ioctl definition is still under construction, FreeBSD  * 	 does not currently support SNDCTL_SETNAME.  *  * @param wrch	playback channel (optional; may be NULL)  * @param rdch	recording channel (optional; may be NULL)  * @param name	new device name gets copied from here  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_setname
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_longname_t
modifier|*
name|name
parameter_list|)
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OSSV4_EXPERIMENT */
end_comment

end_unit

