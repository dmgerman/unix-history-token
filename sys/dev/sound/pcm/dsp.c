begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999 Cameron Grant<gandalf@vilnya.demon.co.uk>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_define
define|#
directive|define
name|OLDPCM_IOCTL
end_define

begin_decl_stmt
specifier|static
name|d_open_t
name|dsp_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|dsp_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|dsp_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|dsp_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|dsp_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|dsp_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|dsp_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|dsp_cdevsw
init|=
block|{
comment|/* open */
name|dsp_open
block|,
comment|/* close */
name|dsp_close
block|,
comment|/* read */
name|dsp_read
block|,
comment|/* write */
name|dsp_write
block|,
comment|/* ioctl */
name|dsp_ioctl
block|,
comment|/* poll */
name|dsp_poll
block|,
comment|/* mmap */
name|dsp_mmap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"dsp"
block|,
comment|/* maj */
name|SND_CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|dsp_ehtag
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|snddev_info
modifier|*
name|dsp_get_info
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|PCMUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|devclass_get_maxunit
argument_list|(
name|pcm_devclass
argument_list|)
condition|)
return|return
name|NULL
return|;
name|d
operator|=
name|devclass_get_softc
argument_list|(
name|pcm_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/*  * return the channels channels associated with an open device instance.  * set the priority if the device is simplex and one direction (only) is  * specified.  * lock channels specified.  */
end_comment

begin_function
specifier|static
name|int
name|getchns
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|pcm_channel
modifier|*
modifier|*
name|rdch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
modifier|*
name|wrch
parameter_list|,
name|u_int32_t
name|prio
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|snd_mtxlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
name|d
operator|->
name|inprog
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|d
operator|->
name|flags
operator|&
name|SD_F_PRIO_SET
operator|)
operator|!=
name|SD_F_PRIO_SET
argument_list|, \
operator|(
literal|"getchns: read and write both prioritised"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|SD_F_PRIO_SET
operator|)
operator|==
literal|0
operator|&&
operator|(
name|prio
operator|!=
operator|(
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
operator|)
operator|)
condition|)
name|d
operator|->
name|flags
operator||=
name|prio
operator|&
operator|(
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
operator|)
expr_stmt|;
operator|*
name|rdch
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
operator|*
name|wrch
operator|=
name|dev
operator|->
name|si_drv2
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|SD_F_SIMPLEX
operator|)
operator|&&
operator|(
name|d
operator|->
name|flags
operator|&
name|SD_F_PRIO_SET
operator|)
condition|)
block|{
if|if
condition|(
name|prio
condition|)
block|{
if|if
condition|(
operator|*
name|rdch
operator|&&
name|d
operator|->
name|flags
operator|&
name|SD_F_PRIO_WR
condition|)
block|{
name|dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
operator|*
name|rdch
operator|=
name|d
operator|->
name|fakechan
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|wrch
operator|&&
name|d
operator|->
name|flags
operator|&
name|SD_F_PRIO_RD
condition|)
block|{
name|dev
operator|->
name|si_drv2
operator|=
name|NULL
expr_stmt|;
operator|*
name|wrch
operator|=
name|d
operator|->
name|fakechan
expr_stmt|;
block|}
block|}
name|d
operator|->
name|fakechan
operator|->
name|flags
operator||=
name|CHN_F_BUSY
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|rdch
operator|&&
operator|*
name|rdch
operator|!=
name|d
operator|->
name|fakechan
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_RD
operator|)
condition|)
name|CHN_LOCK
argument_list|(
operator|*
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|wrch
operator|&&
operator|*
name|wrch
operator|!=
name|d
operator|->
name|fakechan
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_WR
operator|)
condition|)
name|CHN_LOCK
argument_list|(
operator|*
name|wrch
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* unlock specified channels */
end_comment

begin_function
specifier|static
name|void
name|relchns
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|u_int32_t
name|prio
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
operator|&&
name|wrch
operator|!=
name|d
operator|->
name|fakechan
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_WR
operator|)
condition|)
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
name|rdch
operator|!=
name|d
operator|->
name|fakechan
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_RD
operator|)
condition|)
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|snd_mtxlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
name|d
operator|->
name|inprog
operator|--
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_open
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|u_int32_t
name|fmt
decl_stmt|;
name|int
name|devtype
decl_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|devtype
operator|=
name|PCMDEV
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
comment|/* decide default format */
switch|switch
condition|(
name|devtype
condition|)
block|{
case|case
name|SND_DEV_DSP16
case|:
name|fmt
operator|=
name|AFMT_S16_LE
expr_stmt|;
break|break;
case|case
name|SND_DEV_DSP
case|:
name|fmt
operator|=
name|AFMT_U8
expr_stmt|;
break|break;
case|case
name|SND_DEV_AUDIO
case|:
name|fmt
operator|=
name|AFMT_MU_LAW
expr_stmt|;
break|break;
case|case
name|SND_DEV_NORESET
case|:
name|fmt
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"impossible devtype %d"
argument_list|,
name|devtype
argument_list|)
expr_stmt|;
block|}
comment|/* lock snddev so nobody else can monkey with it */
name|snd_mtxlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|SD_F_SIMPLEX
operator|)
operator|&&
operator|(
name|i_dev
operator|->
name|si_drv1
operator|||
name|i_dev
operator|->
name|si_drv2
operator|)
condition|)
block|{
comment|/* simplex device, already open, exit */
name|snd_mtxunlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
comment|/*  if we get here, the open request is valid */
name|rdch
operator|=
name|i_dev
operator|->
name|si_drv1
expr_stmt|;
name|wrch
operator|=
name|i_dev
operator|->
name|si_drv2
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FREAD
condition|)
block|{
comment|/* open for read */
if|if
condition|(
name|rdch
operator|==
name|NULL
condition|)
block|{
comment|/* not already open, try to get a channel */
name|rdch
operator|=
name|pcm_chnalloc
argument_list|(
name|d
argument_list|,
name|PCMDIR_REC
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rdch
condition|)
block|{
comment|/* no channel available, exit */
name|snd_mtxunlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
comment|/* got a channel, already locked for us */
block|}
else|else
block|{
comment|/* already open for read, exit */
name|snd_mtxunlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
block|{
comment|/* open for write */
if|if
condition|(
name|wrch
operator|==
name|NULL
condition|)
block|{
comment|/* not already open, try to get a channel */
name|wrch
operator|=
name|pcm_chnalloc
argument_list|(
name|d
argument_list|,
name|PCMDIR_PLAY
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wrch
condition|)
block|{
comment|/* no channel available */
if|if
condition|(
name|rdch
operator|&&
operator|(
name|flags
operator|&
name|FREAD
operator|)
condition|)
block|{
comment|/* just opened a read channel, release it */
name|pcm_chnrelease
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
comment|/* exit */
name|snd_mtxunlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
comment|/* got a channel, already locked for us */
block|}
else|else
block|{
comment|/* already open for write */
if|if
condition|(
name|rdch
operator|&&
operator|(
name|flags
operator|&
name|FREAD
operator|)
condition|)
block|{
comment|/* just opened a read channel, release it */
name|pcm_chnrelease
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
comment|/* exit */
name|snd_mtxunlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
block|}
name|i_dev
operator|->
name|si_drv1
operator|=
name|rdch
expr_stmt|;
name|i_dev
operator|->
name|si_drv2
operator|=
name|wrch
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* finished with snddev, new channels still locked */
comment|/* bump refcounts, reset and unlock any channels that we just opened */
if|if
condition|(
name|rdch
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|FREAD
condition|)
block|{
name|chn_reset
argument_list|(
name|rdch
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
block|}
else|else
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|pcm_chnref
argument_list|(
name|rdch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
block|{
name|chn_reset
argument_list|(
name|wrch
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
block|}
else|else
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|pcm_chnref
argument_list|(
name|wrch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_close
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|int
name|exit
decl_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|snd_mtxlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
name|rdch
operator|=
name|i_dev
operator|->
name|si_drv1
expr_stmt|;
name|wrch
operator|=
name|i_dev
operator|->
name|si_drv2
expr_stmt|;
name|exit
operator|=
literal|0
expr_stmt|;
comment|/* decrement refcount for each channel, exit if nonzero */
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcm_chnref
argument_list|(
name|rdch
argument_list|,
operator|-
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|exit
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcm_chnref
argument_list|(
name|wrch
argument_list|,
operator|-
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|exit
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exit
condition|)
block|{
name|snd_mtxunlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* both refcounts are zero, abort and release */
if|if
condition|(
name|d
operator|->
name|fakechan
condition|)
name|d
operator|->
name|fakechan
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|i_dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
name|i_dev
operator|->
name|si_drv2
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|flags
operator|&=
operator|~
name|SD_F_TRANSIENT
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|chn_abort
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
comment|/* won't sleep */
name|rdch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_RUNNING
operator||
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
expr_stmt|;
name|chn_reset
argument_list|(
name|rdch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcm_chnrelease
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|chn_flush
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* may sleep */
name|wrch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_RUNNING
operator||
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
expr_stmt|;
name|chn_reset
argument_list|(
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcm_chnrelease
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_read
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|SD_F_PRIO_RD
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rdch
argument_list|,
operator|(
literal|"dsp_read: nonexistant channel"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_BUSY
argument_list|,
operator|(
literal|"dsp_read: nonbusy channel"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|->
name|flags
operator|&
operator|(
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_RUNNING
operator|)
condition|)
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_RUNNING
expr_stmt|;
name|ret
operator|=
name|chn_read
argument_list|(
name|rdch
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_write
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wrch
argument_list|,
operator|(
literal|"dsp_write: nonexistant channel"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_BUSY
argument_list|,
operator|(
literal|"dsp_write: nonbusy channel"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
operator|->
name|flags
operator|&
operator|(
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_RUNNING
operator|)
condition|)
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_RUNNING
expr_stmt|;
name|ret
operator|=
name|chn_write
argument_list|(
name|wrch
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_ioctl
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|wrch
decl_stmt|,
modifier|*
name|rdch
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|int
name|kill
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
modifier|*
name|arg_i
init|=
operator|(
name|int
operator|*
operator|)
name|arg
decl_stmt|,
name|tmp
decl_stmt|;
name|u_long
name|s
decl_stmt|;
comment|/* 	 * this is an evil hack to allow broken apps to perform mixer ioctls 	 * on dsp devices. 	 */
if|if
condition|(
name|IOCGROUP
argument_list|(
name|cmd
argument_list|)
operator|==
literal|'M'
condition|)
block|{
name|dev_t
name|pdev
decl_stmt|;
name|pdev
operator|=
name|makedev
argument_list|(
name|SND_CDEV_MAJOR
argument_list|,
name|PCMMKMINOR
argument_list|(
name|PCMUNIT
argument_list|(
name|i_dev
argument_list|)
argument_list|,
name|SND_DEV_CTL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mixer_ioctl
argument_list|(
name|pdev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
return|;
block|}
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
operator|&&
operator|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_DEAD
operator|)
condition|)
name|kill
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
operator|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_DEAD
operator|)
condition|)
name|kill
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|kill
operator|==
literal|3
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|kill
operator|&
literal|1
condition|)
name|wrch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kill
operator|&
literal|2
condition|)
name|rdch
operator|=
name|NULL
expr_stmt|;
comment|/*      	 * all routines are called with int. blocked. Make sure that      	 * ints are re-enabled when calling slow or blocking functions!      	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
ifdef|#
directive|ifdef
name|OLDPCM_IOCTL
comment|/*      	 * we start with the new ioctl interface.      	 */
case|case
name|AIONWRITE
case|:
comment|/* how many bytes can write ? */
comment|/* 		if (wrch&& wrch->bufhard.dl) 			while (chn_wrfeed(wrch) == 0); */
operator|*
name|arg_i
operator|=
name|wrch
condition|?
name|sndbuf_getfree
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|AIOSSIZE
case|:
comment|/* set the current blocksize */
block|{
name|struct
name|snd_size
modifier|*
name|p
init|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
decl_stmt|;
name|p
operator|->
name|play_size
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rec_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|wrch
argument_list|,
literal|2
argument_list|,
name|p
operator|->
name|play_size
argument_list|)
expr_stmt|;
name|p
operator|->
name|play_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|rdch
argument_list|,
literal|2
argument_list|,
name|p
operator|->
name|rec_size
argument_list|)
expr_stmt|;
name|p
operator|->
name|rec_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AIOGSIZE
case|:
comment|/* get the current blocksize */
block|{
name|struct
name|snd_size
modifier|*
name|p
init|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|wrch
condition|)
name|p
operator|->
name|play_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
name|p
operator|->
name|rec_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AIOSFMT
case|:
block|{
name|snd_chan_param
modifier|*
name|p
init|=
operator|(
name|snd_chan_param
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
name|p
operator|->
name|play_format
argument_list|)
expr_stmt|;
name|chn_setspeed
argument_list|(
name|wrch
argument_list|,
name|p
operator|->
name|play_rate
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
name|p
operator|->
name|rec_format
argument_list|)
expr_stmt|;
name|chn_setspeed
argument_list|(
name|rdch
argument_list|,
name|p
operator|->
name|rec_rate
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* FALLTHROUGH */
case|case
name|AIOGFMT
case|:
block|{
name|snd_chan_param
modifier|*
name|p
init|=
operator|(
name|snd_chan_param
operator|*
operator|)
name|arg
decl_stmt|;
name|p
operator|->
name|play_rate
operator|=
name|wrch
condition|?
name|wrch
operator|->
name|speed
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rec_rate
operator|=
name|rdch
condition|?
name|rdch
operator|->
name|speed
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|play_format
operator|=
name|wrch
condition|?
name|wrch
operator|->
name|format
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|rec_format
operator|=
name|rdch
condition|?
name|rdch
operator|->
name|format
else|:
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|AIOGCAP
case|:
comment|/* get capabilities */
block|{
name|snd_capabilities
modifier|*
name|p
init|=
operator|(
name|snd_capabilities
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|pcmchan_caps
modifier|*
name|pcaps
init|=
name|NULL
decl_stmt|,
modifier|*
name|rcaps
init|=
name|NULL
decl_stmt|;
name|dev_t
name|pdev
decl_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|rcaps
operator|=
name|chn_getcaps
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|pcaps
operator|=
name|chn_getcaps
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|rate_min
operator|=
name|max
argument_list|(
name|rcaps
condition|?
name|rcaps
operator|->
name|minspeed
else|:
literal|0
argument_list|,
name|pcaps
condition|?
name|pcaps
operator|->
name|minspeed
else|:
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|rate_max
operator|=
name|min
argument_list|(
name|rcaps
condition|?
name|rcaps
operator|->
name|maxspeed
else|:
literal|1000000
argument_list|,
name|pcaps
condition|?
name|pcaps
operator|->
name|maxspeed
else|:
literal|1000000
argument_list|)
expr_stmt|;
name|p
operator|->
name|bufsize
operator|=
name|min
argument_list|(
name|rdch
condition|?
name|sndbuf_getsize
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
else|:
literal|1000000
argument_list|,
name|wrch
condition|?
name|sndbuf_getsize
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
else|:
literal|1000000
argument_list|)
expr_stmt|;
comment|/* XXX bad on sb16 */
name|p
operator|->
name|formats
operator|=
operator|(
name|rdch
condition|?
name|chn_getformats
argument_list|(
name|rdch
argument_list|)
else|:
literal|0xffffffff
operator|)
operator|&
operator|(
name|wrch
condition|?
name|chn_getformats
argument_list|(
name|wrch
argument_list|)
else|:
literal|0xffffffff
operator|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
name|wrch
condition|)
name|p
operator|->
name|formats
operator||=
operator|(
name|d
operator|->
name|flags
operator|&
name|SD_F_SIMPLEX
operator|)
condition|?
literal|0
else|:
name|AFMT_FULLDUPLEX
expr_stmt|;
name|pdev
operator|=
name|makedev
argument_list|(
name|SND_CDEV_MAJOR
argument_list|,
name|PCMMKMINOR
argument_list|(
name|device_get_unit
argument_list|(
name|d
operator|->
name|dev
argument_list|)
argument_list|,
name|SND_DEV_CTL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|mixers
operator|=
literal|1
expr_stmt|;
comment|/* default: one mixer */
name|p
operator|->
name|inputs
operator|=
name|pdev
operator|->
name|si_drv1
condition|?
name|mix_getdevs
argument_list|(
name|pdev
operator|->
name|si_drv1
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|p
operator|->
name|right
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AIOSTOP
case|:
if|if
condition|(
operator|*
name|arg_i
operator|==
name|AIOSYNC_PLAY
operator|&&
name|wrch
condition|)
operator|*
name|arg_i
operator|=
name|chn_abort
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|arg_i
operator|==
name|AIOSYNC_CAPTURE
operator|&&
name|rdch
condition|)
operator|*
name|arg_i
operator|=
name|chn_abort
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"AIOSTOP: bad channel 0x%x\n"
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|AIOSYNC
case|:
name|printf
argument_list|(
literal|"AIOSYNC chan 0x%03lx pos %lu unimplemented\n"
argument_list|,
operator|(
operator|(
name|snd_sync_parm
operator|*
operator|)
name|arg
operator|)
operator|->
name|chan
argument_list|,
operator|(
operator|(
name|snd_sync_parm
operator|*
operator|)
name|arg
operator|)
operator|->
name|pos
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* 	 * here follow the standard ioctls (filio.h etc.) 	 */
case|case
name|FIONREAD
case|:
comment|/* get # bytes to read */
comment|/*		if (rdch&& rdch->bufhard.dl) 			while (chn_rdfeed(rdch) == 0); */
operator|*
name|arg_i
operator|=
name|rdch
condition|?
name|sndbuf_getready
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|FIOASYNC
case|:
comment|/*set/clear async i/o */
name|DEB
argument_list|(
argument|printf(
literal|"FIOASYNC\n"
argument|) ;
argument_list|)
break|break;
case|case
name|SNDCTL_DSP_NONBLOCK
case|:
case|case
name|FIONBIO
case|:
comment|/* set/clear non-blocking i/o */
if|if
condition|(
name|rdch
condition|)
name|rdch
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_NBIO
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
name|wrch
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_NBIO
expr_stmt|;
if|if
condition|(
operator|*
name|arg_i
condition|)
block|{
if|if
condition|(
name|rdch
condition|)
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
block|}
break|break;
comment|/* 	 * Finally, here is the linux-compatible ioctl interface 	 */
define|#
directive|define
name|THE_REAL_SNDCTL_DSP_GETBLKSIZE
value|_IOWR('P', 4, int)
case|case
name|THE_REAL_SNDCTL_DSP_GETBLKSIZE
case|:
case|case
name|SNDCTL_DSP_GETBLKSIZE
case|:
if|if
condition|(
name|wrch
condition|)
operator|*
name|arg_i
operator|=
name|sndbuf_getblksz
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rdch
condition|)
operator|*
name|arg_i
operator|=
name|sndbuf_getblksz
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
else|else
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
break|break ;
case|case
name|SNDCTL_DSP_SETBLKSIZE
case|:
name|RANGE
argument_list|(
operator|*
name|arg_i
argument_list|,
literal|16
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|wrch
argument_list|,
literal|2
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|rdch
argument_list|,
literal|2
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_RESET
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp reset\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
name|chn_abort
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
name|chn_abort
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_SYNC
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp sync\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* chn_sync may sleep */
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_sync
argument_list|(
name|wrch
argument_list|,
name|sndbuf_getsize
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
operator|-
literal|4
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SPEED
case|:
comment|/* chn_setspeed may sleep */
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setspeed
argument_list|(
name|wrch
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wrch
operator|->
name|speed
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setspeed
argument_list|(
name|rdch
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
name|rdch
operator|->
name|speed
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
name|SOUND_PCM_READ_RATE
case|:
operator|*
name|arg_i
operator|=
name|wrch
condition|?
name|wrch
operator|->
name|speed
else|:
name|rdch
operator|->
name|speed
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_STEREO
case|:
name|tmp
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|arg_i
operator|=
operator|(
operator|*
name|arg_i
operator|)
condition|?
name|AFMT_STEREO
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
operator|(
name|wrch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|wrch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
operator|(
name|rdch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
operator|-
literal|1
condition|)
name|tmp
operator|=
operator|(
name|rdch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
name|SOUND_PCM_WRITE_CHANNELS
case|:
comment|/*	case SNDCTL_DSP_CHANNELS: ( == SOUND_PCM_WRITE_CHANNELS) */
if|if
condition|(
operator|*
name|arg_i
operator|==
literal|1
operator|||
operator|*
name|arg_i
operator|==
literal|2
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
operator|*
name|arg_i
operator|=
operator|(
operator|*
name|arg_i
operator|==
literal|2
operator|)
condition|?
name|AFMT_STEREO
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
operator|(
name|wrch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|wrch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
operator|(
name|rdch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
operator|(
name|rdch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
block|}
else|else
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SOUND_PCM_READ_CHANNELS
case|:
operator|*
name|arg_i
operator|=
operator|(
operator|(
name|wrch
condition|?
name|wrch
operator|->
name|format
else|:
name|rdch
operator|->
name|format
operator|)
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_GETFMTS
case|:
comment|/* returns a mask of supported fmts */
operator|*
name|arg_i
operator|=
name|wrch
condition|?
name|chn_getformats
argument_list|(
name|wrch
argument_list|)
else|:
name|chn_getformats
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
break|break ;
case|case
name|SNDCTL_DSP_SETFMT
case|:
comment|/* sets _one_ format */
comment|/* XXX locking */
if|if
condition|(
operator|(
operator|*
name|arg_i
operator|!=
name|AFMT_QUERY
operator|)
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
operator|(
operator|*
name|arg_i
operator|)
operator||
operator|(
name|wrch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wrch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
operator|(
operator|*
name|arg_i
operator|)
operator||
operator|(
name|rdch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
name|rdch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
block|}
else|else
operator|*
name|arg_i
operator|=
operator|(
name|wrch
condition|?
name|wrch
operator|->
name|format
else|:
name|rdch
operator|->
name|format
operator|)
operator|&
operator|~
name|AFMT_STEREO
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_SETFRAGMENT
case|:
comment|/* XXX locking */
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"SNDCTL_DSP_SETFRAGMENT 0x%08x\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|u_int32_t
name|fragln
init|=
operator|(
operator|*
name|arg_i
operator|)
operator|&
literal|0x0000ffff
decl_stmt|;
name|u_int32_t
name|maxfrags
init|=
operator|(
operator|(
operator|*
name|arg_i
operator|)
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
decl_stmt|;
name|u_int32_t
name|fragsz
decl_stmt|;
name|RANGE
argument_list|(
name|fragln
argument_list|,
literal|4
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|fragsz
operator|=
literal|1
operator|<<
name|fragln
expr_stmt|;
if|if
condition|(
name|maxfrags
operator|==
literal|0
condition|)
name|maxfrags
operator|=
name|CHN_2NDBUFMAXSIZE
operator|/
name|fragsz
expr_stmt|;
if|if
condition|(
name|maxfrags
operator|<
literal|2
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|maxfrags
operator|*
name|fragsz
operator|>
name|CHN_2NDBUFMAXSIZE
condition|)
name|maxfrags
operator|=
name|CHN_2NDBUFMAXSIZE
operator|/
name|fragsz
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"SNDCTL_DSP_SETFRAGMENT %d frags, %d sz\n"
argument_list|,
name|maxfrags
argument_list|,
name|fragsz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setblocksize
argument_list|(
name|rdch
argument_list|,
name|maxfrags
argument_list|,
name|fragsz
argument_list|)
expr_stmt|;
name|maxfrags
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|fragsz
operator|=
name|sndbuf_getblksz
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setblocksize
argument_list|(
name|wrch
argument_list|,
name|maxfrags
argument_list|,
name|fragsz
argument_list|)
expr_stmt|;
name|maxfrags
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|fragsz
operator|=
name|sndbuf_getblksz
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
name|fragln
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fragsz
operator|>
literal|1
condition|)
block|{
name|fragln
operator|++
expr_stmt|;
name|fragsz
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
operator|(
name|maxfrags
operator|<<
literal|16
operator|)
operator||
name|fragln
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETISPACE
case|:
comment|/* XXX Space for reading? Makes no sense... */
comment|/* return the size of data available in the input queue */
block|{
name|audio_buf_info
modifier|*
name|a
init|=
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|rdch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_rdupdate
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|a
operator|->
name|bytes
operator|=
name|sndbuf_getfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragments
operator|=
name|a
operator|->
name|bytes
operator|/
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragstotal
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragsize
operator|=
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SNDCTL_DSP_GETOSPACE
case|:
comment|/* return space available in the output queue */
block|{
name|audio_buf_info
modifier|*
name|a
init|=
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|wrch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_wrupdate
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|a
operator|->
name|bytes
operator|=
name|sndbuf_getfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragments
operator|=
name|a
operator|->
name|bytes
operator|/
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragstotal
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragsize
operator|=
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SNDCTL_DSP_GETIPTR
case|:
block|{
name|count_info
modifier|*
name|a
init|=
operator|(
name|count_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|rdch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_rdupdate
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|a
operator|->
name|bytes
operator|=
name|sndbuf_gettotal
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
operator|-
name|rdch
operator|->
name|blocks
expr_stmt|;
name|a
operator|->
name|ptr
operator|=
name|sndbuf_getreadyptr
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|rdch
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETOPTR
case|:
block|{
name|count_info
modifier|*
name|a
init|=
operator|(
name|count_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|wrch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_wrupdate
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|a
operator|->
name|bytes
operator|=
name|sndbuf_gettotal
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
operator|-
name|wrch
operator|->
name|blocks
expr_stmt|;
name|a
operator|->
name|ptr
operator|=
name|sndbuf_getreadyptr
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETCAPS
case|:
operator|*
name|arg_i
operator|=
name|DSP_CAP_REALTIME
operator||
name|DSP_CAP_MMAP
operator||
name|DSP_CAP_TRIGGER
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
name|wrch
operator|&&
operator|!
operator|(
name|d
operator|->
name|flags
operator|&
name|SD_F_SIMPLEX
operator|)
condition|)
operator|*
name|arg_i
operator||=
name|DSP_CAP_DUPLEX
expr_stmt|;
break|break;
case|case
name|SOUND_PCM_READ_BITS
case|:
operator|*
name|arg_i
operator|=
operator|(
operator|(
name|wrch
condition|?
name|wrch
operator|->
name|format
else|:
name|rdch
operator|->
name|format
operator|)
operator|&
name|AFMT_16BIT
operator|)
condition|?
literal|16
else|:
literal|8
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_SETTRIGGER
case|:
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|rdch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_TRIGGERED
operator||
name|CHN_F_NOTRIGGER
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg_i
operator|&
name|PCM_ENABLE_INPUT
condition|)
block|{
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_TRIGGERED
expr_stmt|;
name|chn_start
argument_list|(
name|rdch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_NOTRIGGER
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_TRIGGERED
operator||
name|CHN_F_NOTRIGGER
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg_i
operator|&
name|PCM_ENABLE_OUTPUT
condition|)
block|{
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_TRIGGERED
expr_stmt|;
name|chn_start
argument_list|(
name|wrch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_NOTRIGGER
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETTRIGGER
case|:
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
operator|&&
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
condition|)
operator|*
name|arg_i
operator||=
name|PCM_ENABLE_OUTPUT
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
condition|)
operator|*
name|arg_i
operator||=
name|PCM_ENABLE_INPUT
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_GETODELAY
case|:
if|if
condition|(
name|wrch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|b
init|=
name|wrch
operator|->
name|bufhard
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|wrch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_wrupdate
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|sndbuf_getready
argument_list|(
name|b
argument_list|)
operator|+
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_POST
case|:
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_NOTRIGGER
expr_stmt|;
name|chn_start
argument_list|(
name|wrch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_MAPINBUF
case|:
case|case
name|SNDCTL_DSP_MAPOUTBUF
case|:
case|case
name|SNDCTL_DSP_SETSYNCRO
case|:
comment|/* undocumented */
case|case
name|SNDCTL_DSP_SUBDIVIDE
case|:
case|case
name|SOUND_PCM_WRITE_FILTER
case|:
case|case
name|SOUND_PCM_READ_FILTER
case|:
comment|/* dunno what these do, don't sound important */
default|default:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"default ioctl chan%d fn 0x%08lx fail\n"
argument_list|,
name|chan
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_poll
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|e
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|wrch
init|=
name|NULL
decl_stmt|,
modifier|*
name|rdch
init|=
name|NULL
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|e
operator|=
operator|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|ret
operator||=
name|chn_poll
argument_list|(
name|wrch
argument_list|,
name|e
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|e
operator|=
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|ret
operator||=
name|chn_poll
argument_list|(
name|rdch
argument_list|,
name|e
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_mmap
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|wrch
init|=
name|NULL
decl_stmt|,
modifier|*
name|rdch
init|=
name|NULL
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|-
literal|1
return|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * XXX the linux api uses the nprot to select read/write buffer 	 * our vm system doesn't allow this, so force write buffer 	 */
block|if (wrch&& (nprot& PROT_WRITE)) 		c = wrch; 	else if (rdch&& (nprot& PROT_READ)) 		c = rdch; 	else 		return -1;
else|#
directive|else
name|c
operator|=
name|wrch
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|c
operator|->
name|flags
operator||=
name|CHN_F_MAPPED
expr_stmt|;
name|ret
operator|=
name|atop
argument_list|(
name|vtophys
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|sndbuf_getbuf
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|)
operator|)
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|dsp_register
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|make_dev
argument_list|(
operator|&
name|dsp_cdevsw
argument_list|,
name|PCMMKMINOR
argument_list|(
name|unit
argument_list|,
name|SND_DEV_DSP
argument_list|,
name|channel
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"dsp%d.%d"
argument_list|,
name|unit
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|dsp_cdevsw
argument_list|,
name|PCMMKMINOR
argument_list|(
name|unit
argument_list|,
name|SND_DEV_DSP16
argument_list|,
name|channel
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"dspW%d.%d"
argument_list|,
name|unit
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|dsp_cdevsw
argument_list|,
name|PCMMKMINOR
argument_list|(
name|unit
argument_list|,
name|SND_DEV_AUDIO
argument_list|,
name|channel
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"audio%d.%d"
argument_list|,
name|unit
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dsp_unregister
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|dev_t
name|pdev
decl_stmt|;
name|pdev
operator|=
name|makedev
argument_list|(
name|SND_CDEV_MAJOR
argument_list|,
name|PCMMKMINOR
argument_list|(
name|unit
argument_list|,
name|SND_DEV_DSP
argument_list|,
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pdev
operator|=
name|makedev
argument_list|(
name|SND_CDEV_MAJOR
argument_list|,
name|PCMMKMINOR
argument_list|(
name|unit
argument_list|,
name|SND_DEV_DSP16
argument_list|,
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pdev
operator|=
name|makedev
argument_list|(
name|SND_CDEV_MAJOR
argument_list|,
name|PCMMKMINOR
argument_list|(
name|unit
argument_list|,
name|SND_DEV_AUDIO
argument_list|,
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_clone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|dev_t
modifier|*
name|dev
parameter_list|)
block|{
name|dev_t
name|pdev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cont
decl_stmt|,
name|unit
decl_stmt|,
name|devtype
decl_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NODEV
condition|)
return|return;
if|if
condition|(
name|pcm_devclass
operator|==
name|NULL
condition|)
return|return;
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
name|devtype
operator|=
name|SND_DEV_DSP
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"dsp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unit
operator|=
name|snd_unit
expr_stmt|;
goto|goto
name|gotit
goto|;
block|}
elseif|else
if|if
condition|(
name|dev_stdclone
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
literal|"dsp"
argument_list|,
operator|&
name|unit
argument_list|)
operator|==
literal|1
condition|)
goto|goto
name|gotit
goto|;
name|devtype
operator|=
name|SND_DEV_DSP16
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"dspW"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unit
operator|=
name|snd_unit
expr_stmt|;
goto|goto
name|gotit
goto|;
block|}
elseif|else
if|if
condition|(
name|dev_stdclone
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
literal|"dspW"
argument_list|,
operator|&
name|unit
argument_list|)
operator|==
literal|1
condition|)
goto|goto
name|gotit
goto|;
name|devtype
operator|=
name|SND_DEV_AUDIO
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"audio"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unit
operator|=
name|snd_unit
expr_stmt|;
goto|goto
name|gotit
goto|;
block|}
elseif|else
if|if
condition|(
name|dev_stdclone
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
literal|"audio"
argument_list|,
operator|&
name|unit
argument_list|)
operator|==
literal|1
condition|)
goto|goto
name|gotit
goto|;
return|return;
name|gotit
label|:
if|if
condition|(
name|unit
operator|==
operator|-
literal|1
operator|||
name|unit
operator|>=
name|devclass_get_maxunit
argument_list|(
name|pcm_devclass
argument_list|)
condition|)
return|return;
name|cont
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cont
condition|;
name|i
operator|++
control|)
block|{
name|pdev
operator|=
name|makedev
argument_list|(
name|SND_CDEV_MAJOR
argument_list|,
name|PCMMKMINOR
argument_list|(
name|unit
argument_list|,
name|devtype
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdev
operator|->
name|si_flags
operator|&
name|SI_NAMED
condition|)
block|{
if|if
condition|(
operator|(
name|pdev
operator|->
name|si_drv1
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|pdev
operator|->
name|si_drv2
operator|==
name|NULL
operator|)
condition|)
block|{
operator|*
name|dev
operator|=
name|pdev
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|cont
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_sysinit
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|dsp_ehtag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_clone
argument_list|,
name|dsp_clone
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_sysuninit
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|dsp_ehtag
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|dev_clone
argument_list|,
name|dsp_ehtag
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|dsp_sysinit
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|dsp_sysinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|dsp_sysuninit
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|dsp_sysuninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

