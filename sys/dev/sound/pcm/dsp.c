begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Cameron Grant<cg@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|dsp_mmap_allow_prot_exec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|compat_linux_mmap
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|dsp_mmap_allow_prot_exec
argument_list|,
literal|0
argument_list|,
literal|"linux mmap compatibility"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|dsp_cdevinfo
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|int
name|busy
decl_stmt|,
name|simplex
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|dsp_cdevinfo
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PCM_RDCH
parameter_list|(
name|x
parameter_list|)
value|(((struct dsp_cdevinfo *)(x)->si_drv1)->rdch)
end_define

begin_define
define|#
directive|define
name|PCM_WRCH
parameter_list|(
name|x
parameter_list|)
value|(((struct dsp_cdevinfo *)(x)->si_drv1)->wrch)
end_define

begin_define
define|#
directive|define
name|PCM_SIMPLEX
parameter_list|(
name|x
parameter_list|)
value|(((struct dsp_cdevinfo *)(x)->si_drv1)->simplex)
end_define

begin_define
define|#
directive|define
name|DSP_CDEVINFO_CACHESIZE
value|8
end_define

begin_define
define|#
directive|define
name|DSP_REGISTERED
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(PCM_REGISTERED(x)&&			\ 				 (y) != NULL&& (y)->si_drv1 != NULL)
end_define

begin_define
define|#
directive|define
name|OLDPCM_IOCTL
end_define

begin_decl_stmt
specifier|static
name|d_open_t
name|dsp_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|dsp_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|dsp_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|dsp_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|dsp_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|dsp_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|dsp_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cdevsw
name|dsp_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|dsp_open
block|,
operator|.
name|d_close
operator|=
name|dsp_close
block|,
operator|.
name|d_read
operator|=
name|dsp_read
block|,
operator|.
name|d_write
operator|=
name|dsp_write
block|,
operator|.
name|d_ioctl
operator|=
name|dsp_ioctl
block|,
operator|.
name|d_poll
operator|=
name|dsp_poll
block|,
operator|.
name|d_mmap
operator|=
name|dsp_mmap
block|,
operator|.
name|d_name
operator|=
literal|"dsp"
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USING_DEVFS
end_ifdef

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|dsp_ehtag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dsp_umax
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dsp_cmax
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|dsp_oss_syncgroup
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_syncgroup
modifier|*
name|group
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_syncstart
parameter_list|(
name|int
name|sg_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_policy
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|int
name|policy
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|OSSV4_EXPERIMENT
end_ifdef

begin_function_decl
specifier|static
name|int
name|dsp_oss_cookedmode
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|int
name|enabled
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_getchnorder
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|unsigned
name|long
name|long
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_setchnorder
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|unsigned
name|long
name|long
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_getlabel
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_label_t
modifier|*
name|label
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_setlabel
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_label_t
modifier|*
name|label
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_getsong
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_longname_t
modifier|*
name|song
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_setsong
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_longname_t
modifier|*
name|song
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_oss_setname
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_longname_t
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|snddev_info
modifier|*
name|dsp_get_info
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
return|return
operator|(
name|devclass_get_softc
argument_list|(
name|pcm_devclass
argument_list|,
name|PCMUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|dsp_get_flags
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|device_t
name|bdev
decl_stmt|;
name|bdev
operator|=
name|devclass_get_device
argument_list|(
name|pcm_devclass
argument_list|,
name|PCMUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|bdev
operator|!=
name|NULL
operator|)
condition|?
name|pcm_getflags
argument_list|(
name|bdev
argument_list|)
else|:
literal|0xffffffff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_set_flags
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|device_t
name|bdev
decl_stmt|;
name|bdev
operator|=
name|devclass_get_device
argument_list|(
name|pcm_devclass
argument_list|,
name|PCMUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdev
operator|!=
name|NULL
condition|)
name|pcm_setflags
argument_list|(
name|bdev
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return the channels associated with an open device instance.  * lock channels specified.  */
end_comment

begin_function
specifier|static
name|int
name|getchns
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|pcm_channel
modifier|*
modifier|*
name|rdch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
modifier|*
name|wrch
parameter_list|,
name|uint32_t
name|prio
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|ch
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
if|if
condition|(
name|PCM_SIMPLEX
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|d
operator|=
name|dsp_get_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCM_REGISTERED
argument_list|(
name|d
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_WAIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_ACQUIRE
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* 		 * Note: order is important - 		 *       pcm flags -> prio query flags -> wild guess 		 */
name|ch
operator|=
name|NULL
expr_stmt|;
name|flags
operator|=
name|dsp_get_flags
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SD_F_PRIO_WR
condition|)
block|{
name|ch
operator|=
name|PCM_RDCH
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|PCM_RDCH
argument_list|(
name|dev
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SD_F_PRIO_RD
condition|)
block|{
name|ch
operator|=
name|PCM_WRCH
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|PCM_WRCH
argument_list|(
name|dev
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prio
operator|&
name|SD_F_PRIO_WR
condition|)
block|{
name|ch
operator|=
name|PCM_RDCH
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|PCM_RDCH
argument_list|(
name|dev
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|flags
operator||=
name|SD_F_PRIO_WR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prio
operator|&
name|SD_F_PRIO_RD
condition|)
block|{
name|ch
operator|=
name|PCM_WRCH
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|PCM_WRCH
argument_list|(
name|dev
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|flags
operator||=
name|SD_F_PRIO_RD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PCM_WRCH
argument_list|(
name|dev
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ch
operator|=
name|PCM_RDCH
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|PCM_RDCH
argument_list|(
name|dev
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|flags
operator||=
name|SD_F_PRIO_WR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PCM_RDCH
argument_list|(
name|dev
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ch
operator|=
name|PCM_WRCH
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|PCM_WRCH
argument_list|(
name|dev
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|flags
operator||=
name|SD_F_PRIO_RD
expr_stmt|;
block|}
name|PCM_SIMPLEX
argument_list|(
name|dev
argument_list|)
operator|=
literal|0
expr_stmt|;
name|dsp_set_flags
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
name|NULL
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|pcm_chnref
argument_list|(
name|ch
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pcm_chnrelease
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|PCM_RELEASE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
operator|*
name|rdch
operator|=
name|PCM_RDCH
argument_list|(
name|dev
argument_list|)
expr_stmt|;
operator|*
name|wrch
operator|=
name|PCM_WRCH
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rdch
operator|!=
name|NULL
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_RD
operator|)
condition|)
name|CHN_LOCK
argument_list|(
operator|*
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|wrch
operator|!=
name|NULL
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_WR
operator|)
condition|)
name|CHN_LOCK
argument_list|(
operator|*
name|wrch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* unlock specified channels */
end_comment

begin_function
specifier|static
name|void
name|relchns
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|uint32_t
name|prio
parameter_list|)
block|{
if|if
condition|(
name|wrch
operator|!=
name|NULL
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_WR
operator|)
condition|)
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|!=
name|NULL
operator|&&
operator|(
name|prio
operator|&
name|SD_F_PRIO_RD
operator|)
condition|)
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_cdevinfo_alloc
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|dsp_cdevinfo
modifier|*
name|cdi
decl_stmt|;
name|int
name|simplex
decl_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|PCM_REGISTERED
argument_list|(
name|d
argument_list|)
operator|&&
name|dev
operator|!=
name|NULL
operator|&&
name|dev
operator|->
name|si_drv1
operator|==
name|NULL
operator|&&
name|rdch
operator|!=
name|wrch
argument_list|,
operator|(
literal|"bogus %s(), what are you trying to accomplish here?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PCM_BUSYASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
name|d
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|simplex
operator|=
operator|(
name|dsp_get_flags
argument_list|(
name|dev
argument_list|)
operator|&
name|SD_F_SIMPLEX
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 	 * Scan for free instance entry and put it into the end of list. 	 * Create new one if necessary. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|cdi
argument_list|,
argument|&d->dsp_cdevinfo_pool
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|cdi
operator|->
name|busy
operator|!=
literal|0
condition|)
break|break;
name|cdi
operator|->
name|rdch
operator|=
name|rdch
expr_stmt|;
name|cdi
operator|->
name|wrch
operator|=
name|wrch
expr_stmt|;
name|cdi
operator|->
name|simplex
operator|=
name|simplex
expr_stmt|;
name|cdi
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|d
operator|->
name|dsp_cdevinfo_pool
argument_list|,
name|cdi
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|d
operator|->
name|dsp_cdevinfo_pool
argument_list|,
name|cdi
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|cdi
expr_stmt|;
return|return;
block|}
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|cdi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cdi
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|cdi
operator|->
name|rdch
operator|=
name|rdch
expr_stmt|;
name|cdi
operator|->
name|wrch
operator|=
name|wrch
expr_stmt|;
name|cdi
operator|->
name|simplex
operator|=
name|simplex
expr_stmt|;
name|cdi
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|d
operator|->
name|dsp_cdevinfo_pool
argument_list|,
name|cdi
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|cdi
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_cdevinfo_free
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|dsp_cdevinfo
modifier|*
name|cdi
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|PCM_REGISTERED
argument_list|(
name|d
argument_list|)
operator|&&
name|dev
operator|!=
name|NULL
operator|&&
name|dev
operator|->
name|si_drv1
operator|!=
name|NULL
operator|&&
name|PCM_RDCH
argument_list|(
name|dev
argument_list|)
operator|==
name|NULL
operator|&&
name|PCM_WRCH
argument_list|(
name|dev
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"bogus %s(), what are you trying to accomplish here?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|PCM_BUSYASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
name|d
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|cdi
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
name|cdi
operator|->
name|rdch
operator|=
name|NULL
expr_stmt|;
name|cdi
operator|->
name|wrch
operator|=
name|NULL
expr_stmt|;
name|cdi
operator|->
name|simplex
operator|=
literal|0
expr_stmt|;
name|cdi
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Once it is free, move it back to the beginning of list for 	 * faster new entry allocation. 	 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|d
operator|->
name|dsp_cdevinfo_pool
argument_list|,
name|cdi
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|d
operator|->
name|dsp_cdevinfo_pool
argument_list|,
name|cdi
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * Scan the list, cache free entries up to DSP_CDEVINFO_CACHESIZE. 	 * Reset simplex flags. 	 */
name|flags
operator|=
name|dsp_get_flags
argument_list|(
name|dev
argument_list|)
operator|&
operator|~
name|SD_F_PRIO_SET
expr_stmt|;
name|i
operator|=
name|DSP_CDEVINFO_CACHESIZE
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|cdi
argument_list|,
argument|&d->dsp_cdevinfo_pool
argument_list|,
argument|link
argument_list|,
argument|tmp
argument_list|)
block|{
if|if
condition|(
name|cdi
operator|->
name|busy
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cdi
operator|->
name|simplex
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cdi
operator|->
name|rdch
operator|!=
name|NULL
condition|)
name|flags
operator||=
name|SD_F_PRIO_RD
expr_stmt|;
if|if
condition|(
name|cdi
operator|->
name|wrch
operator|!=
name|NULL
condition|)
name|flags
operator||=
name|SD_F_PRIO_WR
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|d
operator|->
name|dsp_cdevinfo_pool
argument_list|,
name|cdi
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cdi
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
else|else
name|i
operator|--
expr_stmt|;
block|}
block|}
name|dsp_set_flags
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsp_cdevinfo_init
parameter_list|(
name|struct
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|dsp_cdevinfo
modifier|*
name|cdi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|d
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snddev_info"
operator|)
argument_list|)
expr_stmt|;
name|PCM_BUSYASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
name|d
operator|->
name|lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|d
operator|->
name|dsp_cdevinfo_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DSP_CDEVINFO_CACHESIZE
condition|;
name|i
operator|++
control|)
block|{
name|cdi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cdi
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|d
operator|->
name|dsp_cdevinfo_pool
argument_list|,
name|cdi
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dsp_cdevinfo_flush
parameter_list|(
name|struct
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|dsp_cdevinfo
modifier|*
name|cdi
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|KASSERT
argument_list|(
name|d
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snddev_info"
operator|)
argument_list|)
expr_stmt|;
name|PCM_BUSYASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
name|d
operator|->
name|lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|cdi
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|d
operator|->
name|dsp_cdevinfo_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|cdi
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
name|TAILQ_NEXT
argument_list|(
name|cdi
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cdi
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cdi
operator|=
name|tmp
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|d
operator|->
name|dsp_cdevinfo_pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* duplex / simplex cdev type */
end_comment

begin_enum
enum|enum
block|{
name|DSP_CDEV_TYPE_RDONLY
block|,
comment|/* simplex read-only (record)   */
name|DSP_CDEV_TYPE_WRONLY
block|,
comment|/* simplex write-only (play)    */
name|DSP_CDEV_TYPE_RDWR
block|,
comment|/* duplex read, write, or both  */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|DSP_F_VALID
parameter_list|(
name|x
parameter_list|)
value|((x)& (FREAD | FWRITE))
end_define

begin_define
define|#
directive|define
name|DSP_F_DUPLEX
parameter_list|(
name|x
parameter_list|)
value|(((x)& (FREAD | FWRITE)) == (FREAD | FWRITE))
end_define

begin_define
define|#
directive|define
name|DSP_F_SIMPLEX
parameter_list|(
name|x
parameter_list|)
value|(!DSP_F_DUPLEX(x))
end_define

begin_define
define|#
directive|define
name|DSP_F_READ
parameter_list|(
name|x
parameter_list|)
value|((x)& FREAD)
end_define

begin_define
define|#
directive|define
name|DSP_F_WRITE
parameter_list|(
name|x
parameter_list|)
value|((x)& FWRITE)
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|sep
decl_stmt|;
name|int
name|use_sep
decl_stmt|;
name|int
name|hw
decl_stmt|;
name|int
name|max
decl_stmt|;
name|uint32_t
name|fmt
decl_stmt|,
name|spd
decl_stmt|;
name|int
name|query
decl_stmt|;
block|}
name|dsp_cdevs
index|[]
init|=
block|{
block|{
name|SND_DEV_DSP
block|,
literal|"dsp"
block|,
literal|"."
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|AFMT_U8
block|,
name|DSP_DEFAULT_SPEED
block|,
name|DSP_CDEV_TYPE_RDWR
block|}
block|,
block|{
name|SND_DEV_AUDIO
block|,
literal|"audio"
block|,
literal|"."
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|AFMT_MU_LAW
block|,
name|DSP_DEFAULT_SPEED
block|,
name|DSP_CDEV_TYPE_RDWR
block|}
block|,
block|{
name|SND_DEV_DSP16
block|,
literal|"dspW"
block|,
literal|"."
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|AFMT_S16_LE
block|,
name|DSP_DEFAULT_SPEED
block|,
name|DSP_CDEV_TYPE_RDWR
block|}
block|,
block|{
name|SND_DEV_DSPHW_PLAY
block|,
literal|"dsp"
block|,
literal|".p"
block|,
literal|1
block|,
literal|1
block|,
name|SND_MAXHWCHAN
block|,
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
block|,
literal|48000
block|,
name|DSP_CDEV_TYPE_WRONLY
block|}
block|,
block|{
name|SND_DEV_DSPHW_VPLAY
block|,
literal|"dsp"
block|,
literal|".vp"
block|,
literal|1
block|,
literal|1
block|,
name|SND_MAXVCHANS
block|,
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
block|,
literal|48000
block|,
name|DSP_CDEV_TYPE_WRONLY
block|}
block|,
block|{
name|SND_DEV_DSPHW_REC
block|,
literal|"dsp"
block|,
literal|".r"
block|,
literal|1
block|,
literal|1
block|,
name|SND_MAXHWCHAN
block|,
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
block|,
literal|48000
block|,
name|DSP_CDEV_TYPE_RDONLY
block|}
block|,
block|{
name|SND_DEV_DSPHW_VREC
block|,
literal|"dsp"
block|,
literal|".vr"
block|,
literal|1
block|,
literal|1
block|,
name|SND_MAXVCHANS
block|,
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
block|,
literal|48000
block|,
name|DSP_CDEV_TYPE_RDONLY
block|}
block|,
block|{
name|SND_DEV_DSPHW_CD
block|,
literal|"dspcd"
block|,
literal|"."
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
block|,
literal|44100
block|,
name|DSP_CDEV_TYPE_RDWR
block|}
block|,
block|{
name|SND_DEV_DSP_MMAP
block|,
literal|"dsp_mmap"
block|,
literal|"."
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
block|,
literal|48000
block|,
name|DSP_CDEV_TYPE_RDWR
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|DSP_FIXUP_ERROR
parameter_list|()
value|do {				\ 	prio = dsp_get_flags(i_dev);					\ 	if (!DSP_F_VALID(flags))					\ 		error = EINVAL;						\ 	if (!DSP_F_DUPLEX(flags)&&					\ 	    ((DSP_F_READ(flags)&& d->reccount == 0) ||			\ 	    (DSP_F_WRITE(flags)&& d->playcount == 0)))			\ 		error = ENOTSUP;					\ 	else if (!DSP_F_DUPLEX(flags)&& (prio& SD_F_SIMPLEX)&&	\ 	    ((DSP_F_READ(flags)&& (prio& SD_F_PRIO_WR)) ||		\ 	    (DSP_F_WRITE(flags)&& (prio& SD_F_PRIO_RD))))		\ 		error = EBUSY;						\ 	else if (DSP_REGISTERED(d, i_dev))				\ 		error = EBUSY;						\ } while(0)
end_define

begin_function
specifier|static
name|int
name|dsp_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|uint32_t
name|fmt
decl_stmt|,
name|spd
decl_stmt|,
name|prio
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|rderror
decl_stmt|,
name|wrerror
decl_stmt|,
name|devtype
decl_stmt|,
name|wdevunit
decl_stmt|,
name|rdevunit
decl_stmt|;
comment|/* Kind of impossible.. */
if|if
condition|(
name|i_dev
operator|==
name|NULL
operator|||
name|td
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCM_REGISTERED
argument_list|(
name|d
argument_list|)
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|PCM_GIANT_ENTER
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* Lock snddev so nobody else can monkey with it. */
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_WAIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* 	 * Try to acquire cloned device before someone else pick it. 	 * ENODEV means this is not a cloned droids. 	 */
name|error
operator|=
name|snd_clone_acquire
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ENODEV
operator|)
condition|)
block|{
name|DSP_FIXUP_ERROR
argument_list|()
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_GIANT_EXIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|DSP_FIXUP_ERROR
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snd_clone_release
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_GIANT_EXIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * That is just enough. Acquire and unlock pcm lock so 	 * the other will just have to wait until we finish doing 	 * everything. 	 */
name|PCM_ACQUIRE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|devtype
operator|=
name|PCMDEV
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|wdevunit
operator|=
operator|-
literal|1
expr_stmt|;
name|rdevunit
operator|=
operator|-
literal|1
expr_stmt|;
name|fmt
operator|=
literal|0
expr_stmt|;
name|spd
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|dsp_cdevs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dsp_cdevs
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|devtype
operator|!=
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|type
condition|)
continue|continue;
if|if
condition|(
name|DSP_F_SIMPLEX
argument_list|(
name|flags
argument_list|)
operator|&&
operator|(
operator|(
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|query
operator|==
name|DSP_CDEV_TYPE_WRONLY
operator|&&
name|DSP_F_READ
argument_list|(
name|flags
argument_list|)
operator|)
operator|||
operator|(
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|query
operator|==
name|DSP_CDEV_TYPE_RDONLY
operator|&&
name|DSP_F_WRITE
argument_list|(
name|flags
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 			 * simplex, opposite direction? Please be gone.. 			 */
operator|(
name|void
operator|)
name|snd_clone_release
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_GIANT_EXIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
if|if
condition|(
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|query
operator|==
name|DSP_CDEV_TYPE_WRONLY
condition|)
name|wdevunit
operator|=
name|dev2unit
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|query
operator|==
name|DSP_CDEV_TYPE_RDONLY
condition|)
name|rdevunit
operator|=
name|dev2unit
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|fmt
expr_stmt|;
name|spd
operator|=
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|spd
expr_stmt|;
break|break;
block|}
comment|/* No matching devtype? */
if|if
condition|(
name|fmt
operator|==
literal|0
operator|||
name|spd
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"impossible devtype %d"
argument_list|,
name|devtype
argument_list|)
expr_stmt|;
name|rdch
operator|=
name|NULL
expr_stmt|;
name|wrch
operator|=
name|NULL
expr_stmt|;
name|rderror
operator|=
literal|0
expr_stmt|;
name|wrerror
operator|=
literal|0
expr_stmt|;
comment|/* 	 * if we get here, the open request is valid- either: 	 *   * we were previously not open 	 *   * we were open for play xor record and the opener wants 	 *     the non-open direction 	 */
if|if
condition|(
name|DSP_F_READ
argument_list|(
name|flags
argument_list|)
condition|)
block|{
comment|/* open for read */
name|rderror
operator|=
name|pcm_chnalloc
argument_list|(
name|d
argument_list|,
operator|&
name|rdch
argument_list|,
name|PCMDIR_REC
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|rdevunit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rderror
operator|==
literal|0
operator|&&
operator|(
name|chn_reset
argument_list|(
name|rdch
argument_list|,
name|fmt
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|chn_setspeed
argument_list|(
name|rdch
argument_list|,
name|spd
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
name|rderror
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
name|rderror
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rdch
operator|!=
name|NULL
condition|)
name|pcm_chnrelease
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DSP_F_DUPLEX
argument_list|(
name|flags
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|snd_clone_release
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_GIANT_EXIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|rderror
operator|)
return|;
block|}
name|rdch
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
name|pcm_chnref
argument_list|(
name|rdch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DSP_F_WRITE
argument_list|(
name|flags
argument_list|)
condition|)
block|{
comment|/* open for write */
name|wrerror
operator|=
name|pcm_chnalloc
argument_list|(
name|d
argument_list|,
operator|&
name|wrch
argument_list|,
name|PCMDIR_PLAY
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|wdevunit
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrerror
operator|==
literal|0
operator|&&
operator|(
name|chn_reset
argument_list|(
name|wrch
argument_list|,
name|fmt
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|chn_setspeed
argument_list|(
name|wrch
argument_list|,
name|spd
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
name|wrerror
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
name|wrerror
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|wrch
operator|!=
name|NULL
condition|)
name|pcm_chnrelease
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DSP_F_DUPLEX
argument_list|(
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|rdch
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * Lock, deref and release previously 					 * created record channel 					 */
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|pcm_chnref
argument_list|(
name|rdch
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pcm_chnrelease
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snd_clone_release
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_GIANT_EXIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|wrerror
operator|)
return|;
block|}
name|wrch
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
name|pcm_chnref
argument_list|(
name|wrch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rdch
operator|==
name|NULL
operator|&&
name|wrch
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snd_clone_release
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_GIANT_EXIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|wrerror
operator|!=
literal|0
operator|)
condition|?
name|wrerror
else|:
name|rderror
operator|)
return|;
block|}
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* 	 * We're done. Allocate channels information for this cdev. 	 */
name|dsp_cdevinfo_alloc
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|)
expr_stmt|;
comment|/* 	 * Increase clone refcount for its automatic garbage collector. 	 */
operator|(
name|void
operator|)
name|snd_clone_ref
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|PCM_RELEASE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_GIANT_LEAVE
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|int
name|sg_ids
decl_stmt|,
name|refs
decl_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DSP_REGISTERED
argument_list|(
name|d
argument_list|,
name|i_dev
argument_list|)
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|PCM_GIANT_ENTER
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_WAIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|rdch
operator|=
name|PCM_RDCH
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|wrch
operator|=
name|PCM_WRCH
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|||
name|wrch
condition|)
block|{
name|PCM_ACQUIRE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|refs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
comment|/* 			 * The channel itself need not be locked because: 			 *   a)  Adding a channel to a syncgroup happens only in dsp_ioctl(), 			 *       which cannot run concurrently to dsp_close(). 			 *   b)  The syncmember pointer (sm) is protected by the global 			 *       syncgroup list lock. 			 *   c)  A channel can't just disappear, invalidating pointers, 			 *       unless it's closed/dereferenced first. 			 */
name|PCM_SG_LOCK
argument_list|()
expr_stmt|;
name|sg_ids
operator|=
name|chn_syncdestroy
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|PCM_SG_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sg_ids
operator|!=
literal|0
condition|)
name|free_unr
argument_list|(
name|pcmsg_unrhdr
argument_list|,
name|sg_ids
argument_list|)
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|refs
operator|+=
name|pcm_chnref
argument_list|(
name|rdch
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|chn_abort
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
comment|/* won't sleep */
name|rdch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_RUNNING
operator||
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
expr_stmt|;
name|chn_reset
argument_list|(
name|rdch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcm_chnrelease
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|PCM_RDCH
argument_list|(
name|i_dev
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
comment|/* 			 * Please see block above. 			 */
name|PCM_SG_LOCK
argument_list|()
expr_stmt|;
name|sg_ids
operator|=
name|chn_syncdestroy
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|PCM_SG_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sg_ids
operator|!=
literal|0
condition|)
name|free_unr
argument_list|(
name|pcmsg_unrhdr
argument_list|,
name|sg_ids
argument_list|)
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|refs
operator|+=
name|pcm_chnref
argument_list|(
name|wrch
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|chn_flush
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* may sleep */
name|wrch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_RUNNING
operator||
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
expr_stmt|;
name|chn_reset
argument_list|(
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcm_chnrelease
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|PCM_WRCH
argument_list|(
name|i_dev
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* 		 * If there are no more references, release the channels. 		 */
if|if
condition|(
name|refs
operator|==
literal|0
operator|&&
name|PCM_RDCH
argument_list|(
name|i_dev
argument_list|)
operator|==
name|NULL
operator|&&
name|PCM_WRCH
argument_list|(
name|i_dev
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|dsp_cdevinfo_free
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
comment|/* 			 * Release clone busy state and unref it 			 * so the automatic garbage collector will 			 * get the hint and do the remaining cleanup 			 * process. 			 */
operator|(
name|void
operator|)
name|snd_clone_release
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snd_clone_unref
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
block|}
name|PCM_RELEASE
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_GIANT_LEAVE
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|dsp_io_ops
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
modifier|*
name|ch
decl_stmt|,
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|int
function_decl|(
modifier|*
name|chn_io
function_decl|)
parameter_list|(
name|struct
name|pcm_channel
modifier|*
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|)
function_decl|;
name|int
name|prio
decl_stmt|,
name|ret
decl_stmt|;
name|pid_t
name|runpid
decl_stmt|;
name|KASSERT
argument_list|(
name|i_dev
operator|!=
name|NULL
operator|&&
name|buf
operator|!=
name|NULL
operator|&&
operator|(
name|buf
operator|->
name|uio_rw
operator|==
name|UIO_READ
operator|||
name|buf
operator|->
name|uio_rw
operator|==
name|UIO_WRITE
operator|)
argument_list|,
operator|(
literal|"%s(): io train wreck!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DSP_REGISTERED
argument_list|(
name|d
argument_list|,
name|i_dev
argument_list|)
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|PCM_GIANT_ENTER
argument_list|(
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
operator|->
name|uio_rw
condition|)
block|{
case|case
name|UIO_READ
case|:
name|prio
operator|=
name|SD_F_PRIO_RD
expr_stmt|;
name|ch
operator|=
operator|&
name|rdch
expr_stmt|;
name|chn_io
operator|=
name|chn_read
expr_stmt|;
break|break;
case|case
name|UIO_WRITE
case|:
name|prio
operator|=
name|SD_F_PRIO_WR
expr_stmt|;
name|ch
operator|=
operator|&
name|wrch
expr_stmt|;
name|chn_io
operator|=
name|chn_write
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"invalid/corrupted uio direction: %d"
argument_list|,
name|buf
operator|->
name|uio_rw
argument_list|)
expr_stmt|;
break|break;
block|}
name|rdch
operator|=
name|NULL
expr_stmt|;
name|wrch
operator|=
name|NULL
expr_stmt|;
name|runpid
operator|=
name|buf
operator|->
name|uio_td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|prio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ch
operator|==
name|NULL
operator|||
operator|!
operator|(
operator|(
operator|*
name|ch
operator|)
operator|->
name|flags
operator|&
name|CHN_F_BUSY
operator|)
condition|)
block|{
name|PCM_GIANT_EXIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
operator|*
name|ch
operator|)
operator|->
name|flags
operator|&
operator|(
name|CHN_F_MAPPED
operator||
name|CHN_F_DEAD
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
operator|*
name|ch
operator|)
operator|->
name|flags
operator|&
name|CHN_F_RUNNING
operator|)
operator|&&
operator|(
operator|*
name|ch
operator|)
operator|->
name|pid
operator|!=
name|runpid
operator|)
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|prio
argument_list|)
expr_stmt|;
name|PCM_GIANT_EXIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|ch
operator|)
operator|->
name|flags
operator|&
name|CHN_F_RUNNING
operator|)
condition|)
block|{
operator|(
operator|*
name|ch
operator|)
operator|->
name|flags
operator||=
name|CHN_F_RUNNING
expr_stmt|;
operator|(
operator|*
name|ch
operator|)
operator|->
name|pid
operator|=
name|runpid
expr_stmt|;
block|}
comment|/* 	 * chn_read/write must give up channel lock in order to copy bytes 	 * from/to userland, so up the "in progress" counter to make sure 	 * someone else doesn't come along and muss up the buffer. 	 */
operator|++
operator|(
operator|*
name|ch
operator|)
operator|->
name|inprog
expr_stmt|;
name|ret
operator|=
name|chn_io
argument_list|(
operator|*
name|ch
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|--
operator|(
operator|*
name|ch
operator|)
operator|->
name|inprog
expr_stmt|;
name|CHN_BROADCAST
argument_list|(
operator|&
operator|(
operator|*
name|ch
operator|)
operator|->
name|cv
argument_list|)
expr_stmt|;
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|prio
argument_list|)
expr_stmt|;
name|PCM_GIANT_LEAVE
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
return|return
operator|(
name|dsp_io_ops
argument_list|(
name|i_dev
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
return|return
operator|(
name|dsp_io_ops
argument_list|(
name|i_dev
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|pcm_channel
modifier|*
name|chn
decl_stmt|,
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|wrch
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|int
modifier|*
name|arg_i
decl_stmt|,
name|ret
decl_stmt|,
name|kill
decl_stmt|,
name|tmp
decl_stmt|,
name|xcmd
decl_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DSP_REGISTERED
argument_list|(
name|d
argument_list|,
name|i_dev
argument_list|)
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|PCM_GIANT_ENTER
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|arg_i
operator|=
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|xcmd
operator|=
literal|0
expr_stmt|;
comment|/* 	 * this is an evil hack to allow broken apps to perform mixer ioctls 	 * on dsp devices. 	 */
if|if
condition|(
name|IOCGROUP
argument_list|(
name|cmd
argument_list|)
operator|==
literal|'M'
condition|)
block|{
comment|/* 		 * This is at least, a bug to bug compatible with OSS. 		 */
if|if
condition|(
name|d
operator|->
name|mixer_dev
operator|!=
name|NULL
condition|)
block|{
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mixer_ioctl_cmd
argument_list|(
name|d
operator|->
name|mixer_dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
operator|-
literal|1
argument_list|,
name|td
argument_list|,
name|MIXER_CMD_DIRECT
argument_list|)
expr_stmt|;
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EBADF
expr_stmt|;
name|PCM_GIANT_EXIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * Certain ioctls may be made on any type of device (audio, mixer, 	 * and MIDI).  Handle those special cases here. 	 */
if|if
condition|(
name|IOCGROUP
argument_list|(
name|cmd
argument_list|)
operator|==
literal|'X'
condition|)
block|{
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_SYSINFO
case|:
name|sound_oss_sysinfo
argument_list|(
operator|(
name|oss_sysinfo
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_AUDIOINFO
case|:
name|ret
operator|=
name|dsp_oss_audioinfo
argument_list|(
name|i_dev
argument_list|,
operator|(
name|oss_audioinfo
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_MIXERINFO
case|:
name|ret
operator|=
name|mixer_oss_mixerinfo
argument_list|(
name|i_dev
argument_list|,
operator|(
name|oss_mixerinfo
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_GIANT_EXIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
operator|&&
operator|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_DEAD
operator|)
condition|)
name|kill
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
operator|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_DEAD
operator|)
condition|)
name|kill
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|kill
operator|==
literal|3
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PCM_GIANT_EXIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|kill
operator|&
literal|1
condition|)
name|wrch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kill
operator|&
literal|2
condition|)
name|rdch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|wrch
operator|==
name|NULL
operator|&&
name|rdch
operator|==
name|NULL
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PCM_GIANT_EXIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
ifdef|#
directive|ifdef
name|OLDPCM_IOCTL
comment|/*      	 * we start with the new ioctl interface.      	 */
case|case
name|AIONWRITE
case|:
comment|/* how many bytes can write ? */
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* 		if (wrch&& wrch->bufhard.dl) 			while (chn_wrfeed(wrch) == 0); */
operator|*
name|arg_i
operator|=
name|sndbuf_getfree
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|AIOSSIZE
case|:
comment|/* set the current blocksize */
block|{
name|struct
name|snd_size
modifier|*
name|p
init|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
decl_stmt|;
name|p
operator|->
name|play_size
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rec_size
operator|=
literal|0
expr_stmt|;
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|wrch
argument_list|,
literal|2
argument_list|,
name|p
operator|->
name|play_size
argument_list|)
expr_stmt|;
name|p
operator|->
name|play_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|rdch
argument_list|,
literal|2
argument_list|,
name|p
operator|->
name|rec_size
argument_list|)
expr_stmt|;
name|p
operator|->
name|rec_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AIOGSIZE
case|:
comment|/* get the current blocksize */
block|{
name|struct
name|snd_size
modifier|*
name|p
init|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|p
operator|->
name|play_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|p
operator|->
name|rec_size
operator|=
name|sndbuf_getblksz
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AIOSFMT
case|:
case|case
name|AIOGFMT
case|:
block|{
name|snd_chan_param
modifier|*
name|p
init|=
operator|(
name|snd_chan_param
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|AIOSFMT
operator|&&
operator|(
operator|(
name|p
operator|->
name|play_format
operator|!=
literal|0
operator|&&
name|p
operator|->
name|play_rate
operator|==
literal|0
operator|)
operator|||
operator|(
name|p
operator|->
name|rec_format
operator|!=
literal|0
operator|&&
name|p
operator|->
name|rec_rate
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|AIOSFMT
operator|&&
name|p
operator|->
name|play_format
operator|!=
literal|0
condition|)
block|{
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
name|p
operator|->
name|play_format
argument_list|)
expr_stmt|;
name|chn_setspeed
argument_list|(
name|wrch
argument_list|,
name|p
operator|->
name|play_rate
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|play_rate
operator|=
name|wrch
operator|->
name|speed
expr_stmt|;
name|p
operator|->
name|play_format
operator|=
name|wrch
operator|->
name|format
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|play_rate
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|play_format
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|AIOSFMT
operator|&&
name|p
operator|->
name|rec_format
operator|!=
literal|0
condition|)
block|{
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
name|p
operator|->
name|rec_format
argument_list|)
expr_stmt|;
name|chn_setspeed
argument_list|(
name|rdch
argument_list|,
name|p
operator|->
name|rec_rate
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|rec_rate
operator|=
name|rdch
operator|->
name|speed
expr_stmt|;
name|p
operator|->
name|rec_format
operator|=
name|rdch
operator|->
name|format
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|rec_rate
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rec_format
operator|=
literal|0
expr_stmt|;
block|}
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AIOGCAP
case|:
comment|/* get capabilities */
block|{
name|snd_capabilities
modifier|*
name|p
init|=
operator|(
name|snd_capabilities
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|pcmchan_caps
modifier|*
name|pcaps
init|=
name|NULL
decl_stmt|,
modifier|*
name|rcaps
init|=
name|NULL
decl_stmt|;
name|struct
name|cdev
modifier|*
name|pdev
decl_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|rcaps
operator|=
name|chn_getcaps
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|pcaps
operator|=
name|chn_getcaps
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|rate_min
operator|=
name|max
argument_list|(
name|rcaps
condition|?
name|rcaps
operator|->
name|minspeed
else|:
literal|0
argument_list|,
name|pcaps
condition|?
name|pcaps
operator|->
name|minspeed
else|:
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|rate_max
operator|=
name|min
argument_list|(
name|rcaps
condition|?
name|rcaps
operator|->
name|maxspeed
else|:
literal|1000000
argument_list|,
name|pcaps
condition|?
name|pcaps
operator|->
name|maxspeed
else|:
literal|1000000
argument_list|)
expr_stmt|;
name|p
operator|->
name|bufsize
operator|=
name|min
argument_list|(
name|rdch
condition|?
name|sndbuf_getsize
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
else|:
literal|1000000
argument_list|,
name|wrch
condition|?
name|sndbuf_getsize
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
else|:
literal|1000000
argument_list|)
expr_stmt|;
comment|/* XXX bad on sb16 */
name|p
operator|->
name|formats
operator|=
operator|(
name|rdch
condition|?
name|chn_getformats
argument_list|(
name|rdch
argument_list|)
else|:
literal|0xffffffff
operator|)
operator|&
operator|(
name|wrch
condition|?
name|chn_getformats
argument_list|(
name|wrch
argument_list|)
else|:
literal|0xffffffff
operator|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
name|wrch
condition|)
name|p
operator|->
name|formats
operator||=
operator|(
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|&
name|SD_F_SIMPLEX
operator|)
condition|?
literal|0
else|:
name|AFMT_FULLDUPLEX
expr_stmt|;
name|pdev
operator|=
name|d
operator|->
name|mixer_dev
expr_stmt|;
name|p
operator|->
name|mixers
operator|=
literal|1
expr_stmt|;
comment|/* default: one mixer */
name|p
operator|->
name|inputs
operator|=
name|pdev
operator|->
name|si_drv1
condition|?
name|mix_getdevs
argument_list|(
name|pdev
operator|->
name|si_drv1
argument_list|)
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|p
operator|->
name|right
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AIOSTOP
case|:
if|if
condition|(
operator|*
name|arg_i
operator|==
name|AIOSYNC_PLAY
operator|&&
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn_abort
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|arg_i
operator|==
name|AIOSYNC_CAPTURE
operator|&&
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn_abort
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"AIOSTOP: bad channel 0x%x\n"
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|AIOSYNC
case|:
name|printf
argument_list|(
literal|"AIOSYNC chan 0x%03lx pos %lu unimplemented\n"
argument_list|,
operator|(
operator|(
name|snd_sync_parm
operator|*
operator|)
name|arg
operator|)
operator|->
name|chan
argument_list|,
operator|(
operator|(
name|snd_sync_parm
operator|*
operator|)
name|arg
operator|)
operator|->
name|pos
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* 	 * here follow the standard ioctls (filio.h etc.) 	 */
case|case
name|FIONREAD
case|:
comment|/* get # bytes to read */
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
comment|/*			if (rdch&& rdch->bufhard.dl) 				while (chn_rdfeed(rdch) == 0); */
operator|*
name|arg_i
operator|=
name|sndbuf_getready
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|FIOASYNC
case|:
comment|/*set/clear async i/o */
name|DEB
argument_list|(
argument|printf(
literal|"FIOASYNC\n"
argument|) ;
argument_list|)
break|break;
case|case
name|SNDCTL_DSP_NONBLOCK
case|:
comment|/* set non-blocking i/o */
case|case
name|FIONBIO
case|:
comment|/* set/clear non-blocking i/o */
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|SNDCTL_DSP_NONBLOCK
operator|||
operator|*
name|arg_i
condition|)
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
else|else
name|rdch
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_NBIO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|SNDCTL_DSP_NONBLOCK
operator|||
operator|*
name|arg_i
condition|)
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_NBIO
expr_stmt|;
else|else
name|wrch
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_NBIO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Finally, here is the linux-compatible ioctl interface 	 */
define|#
directive|define
name|THE_REAL_SNDCTL_DSP_GETBLKSIZE
value|_IOWR('P', 4, int)
case|case
name|THE_REAL_SNDCTL_DSP_GETBLKSIZE
case|:
case|case
name|SNDCTL_DSP_GETBLKSIZE
case|:
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|sndbuf_getblksz
argument_list|(
name|chn
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SETBLKSIZE
case|:
name|RANGE
argument_list|(
operator|*
name|arg_i
argument_list|,
literal|16
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|wrch
argument_list|,
literal|2
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|rdch
argument_list|,
literal|2
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_RESET
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp reset\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_abort
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_resetbuf
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_abort
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|chn_resetbuf
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SYNC
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp sync\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* chn_sync may sleep */
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|chn_sync
argument_list|(
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SPEED
case|:
comment|/* chn_setspeed may sleep */
name|tmp
operator|=
literal|0
expr_stmt|;
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setspeed
argument_list|(
name|wrch
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wrch
operator|->
name|speed
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setspeed
argument_list|(
name|rdch
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
name|rdch
operator|->
name|speed
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
name|SOUND_PCM_READ_RATE
case|:
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn
operator|->
name|speed
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_STEREO
case|:
name|tmp
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|arg_i
operator|=
operator|(
operator|*
name|arg_i
operator|)
condition|?
name|AFMT_STEREO
else|:
literal|0
expr_stmt|;
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
operator|(
name|wrch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|wrch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
operator|(
name|rdch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
operator|-
literal|1
condition|)
name|tmp
operator|=
operator|(
name|rdch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
name|SOUND_PCM_WRITE_CHANNELS
case|:
comment|/*	case SNDCTL_DSP_CHANNELS: ( == SOUND_PCM_WRITE_CHANNELS) */
if|if
condition|(
operator|*
name|arg_i
operator|!=
literal|0
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
operator|*
name|arg_i
operator|=
operator|(
operator|*
name|arg_i
operator|!=
literal|1
operator|)
condition|?
name|AFMT_STEREO
else|:
literal|0
expr_stmt|;
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
operator|(
name|wrch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|wrch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
operator|(
name|rdch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator||
operator|*
name|arg_i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
operator|(
name|rdch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
operator|(
name|chn
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SOUND_PCM_READ_CHANNELS
case|:
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
operator|(
name|chn
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETFMTS
case|:
comment|/* returns a mask of supported fmts */
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn_getformats
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SETFMT
case|:
comment|/* sets _one_ format */
if|if
condition|(
operator|(
operator|*
name|arg_i
operator|!=
name|AFMT_QUERY
operator|)
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|wrch
argument_list|,
operator|(
operator|*
name|arg_i
operator|)
operator||
operator|(
name|wrch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wrch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setformat
argument_list|(
name|rdch
argument_list|,
operator|(
operator|*
name|arg_i
operator|)
operator||
operator|(
name|rdch
operator|->
name|format
operator|&
name|AFMT_STEREO
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
name|rdch
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|chn
operator|->
name|format
operator|&
operator|~
name|AFMT_STEREO
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SETFRAGMENT
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"SNDCTL_DSP_SETFRAGMENT 0x%08x\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|uint32_t
name|fragln
init|=
operator|(
operator|*
name|arg_i
operator|)
operator|&
literal|0x0000ffff
decl_stmt|;
name|uint32_t
name|maxfrags
init|=
operator|(
operator|(
operator|*
name|arg_i
operator|)
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
decl_stmt|;
name|uint32_t
name|fragsz
decl_stmt|;
name|uint32_t
name|r_maxfrags
decl_stmt|,
name|r_fragsz
decl_stmt|;
name|RANGE
argument_list|(
name|fragln
argument_list|,
literal|4
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|fragsz
operator|=
literal|1
operator|<<
name|fragln
expr_stmt|;
if|if
condition|(
name|maxfrags
operator|==
literal|0
condition|)
name|maxfrags
operator|=
name|CHN_2NDBUFMAXSIZE
operator|/
name|fragsz
expr_stmt|;
if|if
condition|(
name|maxfrags
operator|<
literal|2
condition|)
name|maxfrags
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|maxfrags
operator|*
name|fragsz
operator|>
name|CHN_2NDBUFMAXSIZE
condition|)
name|maxfrags
operator|=
name|CHN_2NDBUFMAXSIZE
operator|/
name|fragsz
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"SNDCTL_DSP_SETFRAGMENT %d frags, %d sz\n"
argument_list|,
name|maxfrags
argument_list|,
name|fragsz
argument_list|)
argument_list|)
expr_stmt|;
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setblocksize
argument_list|(
name|rdch
argument_list|,
name|maxfrags
argument_list|,
name|fragsz
argument_list|)
expr_stmt|;
name|r_maxfrags
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|r_fragsz
operator|=
name|sndbuf_getblksz
argument_list|(
name|rdch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r_maxfrags
operator|=
name|maxfrags
expr_stmt|;
name|r_fragsz
operator|=
name|fragsz
expr_stmt|;
block|}
if|if
condition|(
name|wrch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setblocksize
argument_list|(
name|wrch
argument_list|,
name|maxfrags
argument_list|,
name|fragsz
argument_list|)
expr_stmt|;
name|maxfrags
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|fragsz
operator|=
name|sndbuf_getblksz
argument_list|(
name|wrch
operator|->
name|bufsoft
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use whatever came from the read channel */
name|maxfrags
operator|=
name|r_maxfrags
expr_stmt|;
name|fragsz
operator|=
name|r_fragsz
expr_stmt|;
block|}
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|fragln
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fragsz
operator|>
literal|1
condition|)
block|{
name|fragln
operator|++
expr_stmt|;
name|fragsz
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|arg_i
operator|=
operator|(
name|maxfrags
operator|<<
literal|16
operator|)
operator||
name|fragln
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETISPACE
case|:
comment|/* return the size of data available in the input queue */
block|{
name|audio_buf_info
modifier|*
name|a
init|=
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|rdch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|a
operator|->
name|bytes
operator|=
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragments
operator|=
name|a
operator|->
name|bytes
operator|/
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragstotal
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragsize
operator|=
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETOSPACE
case|:
comment|/* return space available in the output queue */
block|{
name|audio_buf_info
modifier|*
name|a
init|=
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|wrch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* XXX abusive DMA update: chn_wrupdate(wrch); */
name|a
operator|->
name|bytes
operator|=
name|sndbuf_getfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragments
operator|=
name|a
operator|->
name|bytes
operator|/
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragstotal
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|fragsize
operator|=
name|sndbuf_getblksz
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETIPTR
case|:
block|{
name|count_info
modifier|*
name|a
init|=
operator|(
name|count_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|rdch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
comment|/* XXX abusive DMA update: chn_rdupdate(rdch); */
name|a
operator|->
name|bytes
operator|=
name|sndbuf_gettotal
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
operator|-
name|rdch
operator|->
name|blocks
expr_stmt|;
name|a
operator|->
name|ptr
operator|=
name|sndbuf_getreadyptr
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|rdch
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETOPTR
case|:
block|{
name|count_info
modifier|*
name|a
init|=
operator|(
name|count_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|wrch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* XXX abusive DMA update: chn_wrupdate(wrch); */
name|a
operator|->
name|bytes
operator|=
name|sndbuf_gettotal
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|a
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
operator|-
name|wrch
operator|->
name|blocks
expr_stmt|;
name|a
operator|->
name|ptr
operator|=
name|sndbuf_getreadyptr
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|blocks
operator|=
name|sndbuf_getblocks
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETCAPS
case|:
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|*
name|arg_i
operator|=
name|DSP_CAP_REALTIME
operator||
name|DSP_CAP_MMAP
operator||
name|DSP_CAP_TRIGGER
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
name|wrch
operator|&&
operator|!
operator|(
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|&
name|SD_F_SIMPLEX
operator|)
condition|)
operator|*
name|arg_i
operator||=
name|DSP_CAP_DUPLEX
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOUND_PCM_READ_BITS
case|:
name|chn
operator|=
name|wrch
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
if|if
condition|(
name|chn
operator|->
name|format
operator|&
name|AFMT_8BIT
condition|)
operator|*
name|arg_i
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|chn
operator|->
name|format
operator|&
name|AFMT_16BIT
condition|)
operator|*
name|arg_i
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|chn
operator|->
name|format
operator|&
name|AFMT_24BIT
condition|)
operator|*
name|arg_i
operator|=
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
name|chn
operator|->
name|format
operator|&
name|AFMT_32BIT
condition|)
operator|*
name|arg_i
operator|=
literal|32
expr_stmt|;
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SETTRIGGER
case|:
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|rdch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_TRIGGERED
operator||
name|CHN_F_NOTRIGGER
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg_i
operator|&
name|PCM_ENABLE_INPUT
condition|)
name|chn_start
argument_list|(
name|rdch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_NOTRIGGER
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CHN_F_TRIGGERED
operator||
name|CHN_F_NOTRIGGER
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg_i
operator|&
name|PCM_ENABLE_OUTPUT
condition|)
name|chn_start
argument_list|(
name|wrch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_NOTRIGGER
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETTRIGGER
case|:
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
condition|)
operator|*
name|arg_i
operator||=
name|PCM_ENABLE_OUTPUT
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
condition|)
operator|*
name|arg_i
operator||=
name|PCM_ENABLE_INPUT
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETODELAY
case|:
if|if
condition|(
name|wrch
condition|)
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
init|=
name|wrch
operator|->
name|bufsoft
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
comment|/* XXX abusive DMA update: chn_wrupdate(wrch); */
operator|*
name|arg_i
operator|=
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_POST
case|:
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_NOTRIGGER
expr_stmt|;
name|chn_start
argument_list|(
name|wrch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SETDUPLEX
case|:
comment|/* 		 * switch to full-duplex mode if card is in half-duplex 		 * mode and is able to work in full-duplex mode 		 */
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
operator|&&
name|wrch
operator|&&
operator|(
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|&
name|SD_F_SIMPLEX
operator|)
condition|)
name|dsp_set_flags
argument_list|(
name|i_dev
argument_list|,
name|dsp_get_flags
argument_list|(
name|i_dev
argument_list|)
operator|^
name|SD_F_SIMPLEX
argument_list|)
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * The following four ioctls are simple wrappers around mixer_ioctl 	 * with no further processing.  xcmd is short for "translated 	 * command". 	 */
case|case
name|SNDCTL_DSP_GETRECVOL
case|:
if|if
condition|(
name|xcmd
operator|==
literal|0
condition|)
name|xcmd
operator|=
name|SOUND_MIXER_READ_RECLEV
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SNDCTL_DSP_SETRECVOL
case|:
if|if
condition|(
name|xcmd
operator|==
literal|0
condition|)
name|xcmd
operator|=
name|SOUND_MIXER_WRITE_RECLEV
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SNDCTL_DSP_GETPLAYVOL
case|:
if|if
condition|(
name|xcmd
operator|==
literal|0
condition|)
name|xcmd
operator|=
name|SOUND_MIXER_READ_PCM
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SNDCTL_DSP_SETPLAYVOL
case|:
if|if
condition|(
name|xcmd
operator|==
literal|0
condition|)
name|xcmd
operator|=
name|SOUND_MIXER_WRITE_PCM
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mixer_dev
operator|!=
name|NULL
condition|)
block|{
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mixer_ioctl_cmd
argument_list|(
name|d
operator|->
name|mixer_dev
argument_list|,
name|xcmd
argument_list|,
name|arg
argument_list|,
operator|-
literal|1
argument_list|,
name|td
argument_list|,
name|MIXER_CMD_DIRECT
argument_list|)
expr_stmt|;
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|ENOTSUP
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_GET_RECSRC_NAMES
case|:
case|case
name|SNDCTL_DSP_GET_RECSRC
case|:
case|case
name|SNDCTL_DSP_SET_RECSRC
case|:
if|if
condition|(
name|d
operator|->
name|mixer_dev
operator|!=
name|NULL
condition|)
block|{
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mixer_ioctl_cmd
argument_list|(
name|d
operator|->
name|mixer_dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
operator|-
literal|1
argument_list|,
name|td
argument_list|,
name|MIXER_CMD_DIRECT
argument_list|)
expr_stmt|;
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|ENOTSUP
expr_stmt|;
break|break;
comment|/* 	 * The following 3 ioctls aren't very useful at the moment.  For 	 * now, only a single channel is associated with a cdev (/dev/dspN 	 * instance), so there's only a single output routing to use (i.e., 	 * the wrch bound to this cdev). 	 */
case|case
name|SNDCTL_DSP_GET_PLAYTGT_NAMES
case|:
block|{
name|oss_mixer_enuminfo
modifier|*
name|ei
decl_stmt|;
name|ei
operator|=
operator|(
name|oss_mixer_enuminfo
operator|*
operator|)
name|arg
expr_stmt|;
name|ei
operator|->
name|dev
operator|=
literal|0
expr_stmt|;
name|ei
operator|->
name|ctrl
operator|=
literal|0
expr_stmt|;
name|ei
operator|->
name|version
operator|=
literal|0
expr_stmt|;
comment|/* static for now */
name|ei
operator|->
name|strindex
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wrch
operator|!=
name|NULL
condition|)
block|{
name|ei
operator|->
name|nvalues
operator|=
literal|1
expr_stmt|;
name|strlcpy
argument_list|(
name|ei
operator|->
name|strings
argument_list|,
name|wrch
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ei
operator|->
name|strings
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ei
operator|->
name|nvalues
operator|=
literal|0
expr_stmt|;
name|ei
operator|->
name|strings
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SNDCTL_DSP_GET_PLAYTGT
case|:
case|case
name|SNDCTL_DSP_SET_PLAYTGT
case|:
comment|/* yes, they are the same for now */
comment|/* 		 * Re: SET_PLAYTGT 		 *   OSSv4: "The value that was accepted by the device will 		 *   be returned back in the variable pointed by the 		 *   argument." 		 */
if|if
condition|(
name|wrch
operator|!=
name|NULL
condition|)
operator|*
name|arg_i
operator|=
literal|0
expr_stmt|;
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_SILENCE
case|:
comment|/* 	 * Flush the software (pre-feed) buffer, but try to minimize playback 	 * interruption.  (I.e., record unplayed samples with intent to 	 * restore by SNDCTL_DSP_SKIP.) Intended for application "pause" 	 * functionality. 	 */
if|if
condition|(
name|wrch
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
while|while
condition|(
name|wrch
operator|->
name|inprog
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|wrch
operator|->
name|cv
argument_list|,
name|wrch
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bs
operator|=
name|wrch
operator|->
name|bufsoft
expr_stmt|;
if|if
condition|(
operator|(
name|bs
operator|->
name|shadbuf
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|bs
operator|->
name|sl
operator|=
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|sndbuf_dispose
argument_list|(
name|bs
argument_list|,
name|bs
operator|->
name|shadbuf
argument_list|,
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
argument_list|)
expr_stmt|;
name|sndbuf_fillsilence
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|chn_start
argument_list|(
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_SKIP
case|:
comment|/* 	 * OSSv4 docs: "This ioctl call discards all unplayed samples in the 	 * playback buffer by moving the current write position immediately 	 * before the point where the device is currently reading the samples." 	 */
if|if
condition|(
name|wrch
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
while|while
condition|(
name|wrch
operator|->
name|inprog
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|wrch
operator|->
name|cv
argument_list|,
name|wrch
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bs
operator|=
name|wrch
operator|->
name|bufsoft
expr_stmt|;
if|if
condition|(
operator|(
name|bs
operator|->
name|shadbuf
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|bs
operator|->
name|sl
operator|>
literal|0
operator|)
condition|)
block|{
name|sndbuf_softreset
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|sndbuf_acquire
argument_list|(
name|bs
argument_list|,
name|bs
operator|->
name|shadbuf
argument_list|,
name|bs
operator|->
name|sl
argument_list|)
expr_stmt|;
name|bs
operator|->
name|sl
operator|=
literal|0
expr_stmt|;
name|chn_start
argument_list|(
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_CURRENT_OPTR
case|:
case|case
name|SNDCTL_DSP_CURRENT_IPTR
case|:
comment|/** 	 * @note Changing formats resets the buffer counters, which differs 	 * 	 from the 4Front drivers.  However, I don't expect this to be 	 * 	 much of a problem. 	 * 	 * @note In a test where @c CURRENT_OPTR is called immediately after write 	 * 	 returns, this driver is about 32K samples behind whereas 	 * 	 4Front's is about 8K samples behind.  Should determine source 	 * 	 of discrepancy, even if only out of curiosity. 	 * 	 * @todo Actually test SNDCTL_DSP_CURRENT_IPTR. 	 */
name|chn
operator|=
operator|(
name|cmd
operator|==
name|SNDCTL_DSP_CURRENT_OPTR
operator|)
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|struct
name|snd_dbuf
modifier|*
name|bs
decl_stmt|;
comment|/* int tmp; */
name|oss_count_t
modifier|*
name|oc
init|=
operator|(
name|oss_count_t
operator|*
operator|)
name|arg
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|bs
operator|=
name|chn
operator|->
name|bufsoft
expr_stmt|;
if|#
directive|if
literal|0
block|tmp = (sndbuf_getsize(b) + chn_getptr(chn) - sndbuf_gethwptr(b)) % sndbuf_getsize(b); 			oc->samples = (sndbuf_gettotal(b) + tmp) / sndbuf_getbps(b); 			oc->fifo_samples = (sndbuf_getready(b) - tmp) / sndbuf_getbps(b);
else|#
directive|else
name|oc
operator|->
name|samples
operator|=
name|sndbuf_gettotal
argument_list|(
name|bs
argument_list|)
operator|/
name|sndbuf_getbps
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|oc
operator|->
name|fifo_samples
operator|=
name|sndbuf_getready
argument_list|(
name|bs
argument_list|)
operator|/
name|sndbuf_getbps
argument_list|(
name|bs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_HALT_OUTPUT
case|:
case|case
name|SNDCTL_DSP_HALT_INPUT
case|:
name|chn
operator|=
operator|(
name|cmd
operator|==
name|SNDCTL_DSP_HALT_OUTPUT
operator|)
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|chn_abort
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_LOW_WATER
case|:
comment|/* 	 * Set the number of bytes required to attract attention by 	 * select/poll. 	 */
if|if
condition|(
name|wrch
operator|!=
name|NULL
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|lw
operator|=
operator|(
operator|*
name|arg_i
operator|>
literal|1
operator|)
condition|?
operator|*
name|arg_i
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|!=
name|NULL
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|rdch
operator|->
name|lw
operator|=
operator|(
operator|*
name|arg_i
operator|>
literal|1
operator|)
condition|?
operator|*
name|arg_i
else|:
literal|1
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_DSP_GETERROR
case|:
comment|/* 	 * OSSv4 docs:  "All errors and counters will automatically be 	 * cleared to zeroes after the call so each call will return only 	 * the errors that occurred after the previous invocation. ... The 	 * play_underruns and rec_overrun fields are the only usefull fields 	 * returned by OSS 4.0." 	 */
block|{
name|audio_errinfo
modifier|*
name|ei
init|=
operator|(
name|audio_errinfo
operator|*
operator|)
name|arg
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ei
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ei
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
operator|!=
name|NULL
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ei
operator|->
name|play_underruns
operator|=
name|wrch
operator|->
name|xruns
expr_stmt|;
name|wrch
operator|->
name|xruns
operator|=
literal|0
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|!=
name|NULL
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ei
operator|->
name|rec_overruns
operator|=
name|rdch
operator|->
name|xruns
expr_stmt|;
name|rdch
operator|->
name|xruns
operator|=
literal|0
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SNDCTL_DSP_SYNCGROUP
case|:
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dsp_oss_syncgroup
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|oss_syncgroup
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_SYNCSTART
case|:
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dsp_oss_syncstart
argument_list|(
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_POLICY
case|:
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dsp_oss_policy
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OSSV4_EXPERIMENT
comment|/* 	 * XXX The following ioctls are not yet supported and just return 	 * EINVAL. 	 */
case|case
name|SNDCTL_DSP_GETOPEAKS
case|:
case|case
name|SNDCTL_DSP_GETIPEAKS
case|:
name|chn
operator|=
operator|(
name|cmd
operator|==
name|SNDCTL_DSP_GETOPEAKS
operator|)
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|chn
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|oss_peaks_t
modifier|*
name|op
init|=
operator|(
name|oss_peaks_t
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|lpeak
decl_stmt|,
name|rpeak
decl_stmt|;
name|CHN_LOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_getpeaks
argument_list|(
name|chn
argument_list|,
operator|&
name|lpeak
argument_list|,
operator|&
name|rpeak
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
operator|(
operator|*
name|op
operator|)
index|[
literal|0
index|]
operator|=
name|lpeak
expr_stmt|;
operator|(
operator|*
name|op
operator|)
index|[
literal|1
index|]
operator|=
name|rpeak
expr_stmt|;
block|}
name|CHN_UNLOCK
argument_list|(
name|chn
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * XXX Once implemented, revisit this for proper cv protection 	 *     (if necessary). 	 */
case|case
name|SNDCTL_DSP_COOKEDMODE
case|:
name|ret
operator|=
name|dsp_oss_cookedmode
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|*
name|arg_i
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_GET_CHNORDER
case|:
name|ret
operator|=
name|dsp_oss_getchnorder
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_SET_CHNORDER
case|:
name|ret
operator|=
name|dsp_oss_setchnorder
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_GETLABEL
case|:
name|ret
operator|=
name|dsp_oss_getlabel
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|oss_label_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SETLABEL
case|:
name|ret
operator|=
name|dsp_oss_setlabel
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|oss_label_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_GETSONG
case|:
name|ret
operator|=
name|dsp_oss_getsong
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|oss_longname_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SETSONG
case|:
name|ret
operator|=
name|dsp_oss_setsong
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|oss_longname_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SETNAME
case|:
name|ret
operator|=
name|dsp_oss_setname
argument_list|(
name|wrch
argument_list|,
name|rdch
argument_list|,
operator|(
name|oss_longname_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/** 	 * @note The SNDCTL_CARDINFO ioctl was omitted per 4Front developer 	 * documentation.  "The usability of this call is very limited. It's 	 * provided only for completeness of the API. OSS API doesn't have 	 * any concept of card. Any information returned by this ioctl calld 	 * is reserved exclusively for the utility programs included in the 	 * OSS package. Applications should not try to use for this 	 * information in any ways." 	 */
block|case SNDCTL_CARDINFO: 		ret = EINVAL; 		break;
comment|/** 	 * @note The S/PDIF interface ioctls, @c SNDCTL_DSP_READCTL and 	 * @c SNDCTL_DSP_WRITECTL have been omitted at the suggestion of 	 * 4Front Technologies. 	 */
block|case SNDCTL_DSP_READCTL: 	case SNDCTL_DSP_WRITECTL: 		ret = EINVAL; 		break;
endif|#
directive|endif
comment|/* !0 (explicitly omitted ioctls) */
endif|#
directive|endif
comment|/* !OSSV4_EXPERIMENT */
case|case
name|SNDCTL_DSP_MAPINBUF
case|:
case|case
name|SNDCTL_DSP_MAPOUTBUF
case|:
case|case
name|SNDCTL_DSP_SETSYNCRO
case|:
comment|/* undocumented */
case|case
name|SNDCTL_DSP_SUBDIVIDE
case|:
case|case
name|SOUND_PCM_WRITE_FILTER
case|:
case|case
name|SOUND_PCM_READ_FILTER
case|:
comment|/* dunno what these do, don't sound important */
default|default:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"default ioctl fn 0x%08lx fail\n"
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PCM_GIANT_LEAVE
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|wrch
decl_stmt|,
modifier|*
name|rdch
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|e
decl_stmt|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DSP_REGISTERED
argument_list|(
name|d
argument_list|,
name|i_dev
argument_list|)
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|PCM_GIANT_ENTER
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|wrch
operator|=
name|NULL
expr_stmt|;
name|rdch
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrch
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_DEAD
operator|)
condition|)
block|{
name|e
operator|=
operator|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|ret
operator||=
name|chn_poll
argument_list|(
name|wrch
argument_list|,
name|e
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_DEAD
operator|)
condition|)
block|{
name|e
operator|=
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|ret
operator||=
name|chn_poll
argument_list|(
name|rdch
argument_list|,
name|e
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
name|PCM_GIANT_LEAVE
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsp_mmap
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|wrch
decl_stmt|,
modifier|*
name|rdch
decl_stmt|,
modifier|*
name|c
decl_stmt|;
comment|/* 	 * Reject PROT_EXEC by default. It just doesn't makes sense. 	 * Unfortunately, we have to give up this one due to linux_mmap 	 * changes. 	 * 	 * http://lists.freebsd.org/pipermail/freebsd-emulation/2007-June/003698.html 	 * 	 */
if|if
condition|(
operator|(
name|nprot
operator|&
name|PROT_EXEC
operator|)
operator|&&
name|dsp_mmap_allow_prot_exec
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|d
operator|=
name|dsp_get_info
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DSP_REGISTERED
argument_list|(
name|d
argument_list|,
name|i_dev
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|PCM_GIANT_ENTER
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|getchns
argument_list|(
name|i_dev
argument_list|,
operator|&
name|rdch
argument_list|,
operator|&
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
comment|/* 	 * XXX The linux api uses the nprot to select read/write buffer 	 *     our vm system doesn't allow this, so force write buffer. 	 * 	 *     This is just a quack to fool full-duplex mmap, so that at 	 *     least playback _or_ recording works. If you really got the 	 *     urge to make _both_ work at the same time, avoid O_RDWR. 	 *     Just open each direction separately and mmap() it. 	 * 	 *     Failure is not an option due to INVARIANTS check within 	 *     device_pager.c, which means, we have to give up one over 	 *     another. 	 */
name|c
operator|=
operator|(
name|wrch
operator|!=
name|NULL
operator|)
condition|?
name|wrch
else|:
name|rdch
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MMAP_INVALID
operator|)
operator|||
name|offset
operator|>=
name|sndbuf_getsize
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|)
operator|||
operator|(
name|wrch
operator|!=
name|NULL
operator|&&
operator|(
name|wrch
operator|->
name|flags
operator|&
name|CHN_F_MMAP_INVALID
operator|)
operator|)
operator|||
operator|(
name|rdch
operator|!=
name|NULL
operator|&&
operator|(
name|rdch
operator|->
name|flags
operator|&
name|CHN_F_MMAP_INVALID
operator|)
operator|)
condition|)
block|{
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
name|PCM_GIANT_EXIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* XXX full-duplex quack. */
if|if
condition|(
name|wrch
operator|!=
name|NULL
condition|)
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_MAPPED
expr_stmt|;
if|if
condition|(
name|rdch
operator|!=
name|NULL
condition|)
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_MAPPED
expr_stmt|;
operator|*
name|paddr
operator|=
name|vtophys
argument_list|(
name|sndbuf_getbufofs
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|relchns
argument_list|(
name|i_dev
argument_list|,
name|rdch
argument_list|,
name|wrch
argument_list|,
name|SD_F_PRIO_RD
operator||
name|SD_F_PRIO_WR
argument_list|)
expr_stmt|;
name|PCM_GIANT_LEAVE
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USING_DEVFS
end_ifdef

begin_comment
comment|/* So much for dev_stdclone() */
end_comment

begin_function
specifier|static
name|int
name|dsp_stdclone
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|namep
parameter_list|,
name|char
modifier|*
name|sep
parameter_list|,
name|int
name|use_sep
parameter_list|,
name|int
modifier|*
name|u
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|name
argument_list|,
name|namep
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|name
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|len
operator|=
name|strlen
argument_list|(
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'0'
operator|&&
operator|!
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|bcmp
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|sep
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
for|for
control|(
operator|*
name|u
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
name|name
argument_list|)
operator|!=
literal|0
condition|;
name|name
operator|++
control|)
block|{
operator|*
name|u
operator|*=
literal|10
expr_stmt|;
operator|*
name|u
operator|+=
operator|*
name|name
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|u
operator|>
name|dsp_umax
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|(
name|use_sep
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|ENODEV
operator|)
return|;
if|if
condition|(
name|bcmp
argument_list|(
name|name
argument_list|,
name|sep
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
operator|||
name|isdigit
argument_list|(
name|name
index|[
name|len
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|name
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'0'
operator|&&
name|name
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
for|for
control|(
operator|*
name|c
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
name|name
argument_list|)
operator|!=
literal|0
condition|;
name|name
operator|++
control|)
block|{
operator|*
name|c
operator|*=
literal|10
expr_stmt|;
operator|*
name|c
operator|+=
operator|*
name|name
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|>
name|dsp_cmax
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|name
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_clone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|600034
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
endif|#
directive|endif
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|cdev
modifier|*
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|snd_clone_entry
modifier|*
name|ce
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|unit
decl_stmt|,
name|udcmask
decl_stmt|,
name|cunit
decl_stmt|,
name|devtype
decl_stmt|,
name|devhw
decl_stmt|,
name|devcmax
decl_stmt|,
name|tumax
decl_stmt|;
name|char
modifier|*
name|devname
decl_stmt|,
modifier|*
name|devsep
decl_stmt|;
name|KASSERT
argument_list|(
name|dsp_umax
operator|>=
literal|0
operator|&&
name|dsp_cmax
operator|>=
literal|0
argument_list|,
operator|(
literal|"Uninitialized unit!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NULL
condition|)
return|return;
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
name|cunit
operator|=
operator|-
literal|1
expr_stmt|;
name|devtype
operator|=
operator|-
literal|1
expr_stmt|;
name|devhw
operator|=
literal|0
expr_stmt|;
name|devcmax
operator|=
operator|-
literal|1
expr_stmt|;
name|tumax
operator|=
operator|-
literal|1
expr_stmt|;
name|devname
operator|=
name|NULL
expr_stmt|;
name|devsep
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|unit
operator|==
operator|-
literal|1
operator|&&
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|dsp_cdevs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dsp_cdevs
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|devtype
operator|=
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
name|devname
operator|=
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|devsep
operator|=
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|sep
expr_stmt|;
name|devhw
operator|=
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|hw
expr_stmt|;
name|devcmax
operator|=
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|max
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|devname
argument_list|)
operator|==
literal|0
condition|)
name|unit
operator|=
name|snd_unit
expr_stmt|;
elseif|else
if|if
condition|(
name|dsp_stdclone
argument_list|(
name|name
argument_list|,
name|devname
argument_list|,
name|devsep
argument_list|,
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|use_sep
argument_list|,
operator|&
name|unit
argument_list|,
operator|&
name|cunit
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
name|cunit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|d
operator|=
name|devclass_get_softc
argument_list|(
name|pcm_devclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCM_REGISTERED
argument_list|(
name|d
argument_list|)
operator|||
name|d
operator|->
name|clones
operator|==
name|NULL
condition|)
return|return;
comment|/* XXX Need Giant magic entry ??? */
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|snd_clone_disabled
argument_list|(
name|d
operator|->
name|clones
argument_list|)
condition|)
block|{
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
name|PCM_WAIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_ACQUIRE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|udcmask
operator|=
name|snd_u2unit
argument_list|(
name|unit
argument_list|)
operator||
name|snd_d2unit
argument_list|(
name|devtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|devhw
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|devcmax
operator|<=
name|dsp_cmax
argument_list|,
operator|(
literal|"overflow: devcmax=%d, dsp_cmax=%d"
operator|,
name|devcmax
operator|,
name|dsp_cmax
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cunit
operator|>
name|devcmax
condition|)
block|{
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
name|udcmask
operator||=
name|snd_c2unit
argument_list|(
name|cunit
argument_list|)
expr_stmt|;
name|CHN_FOREACH
argument_list|(
argument|c
argument_list|,
argument|d
argument_list|,
argument|channels.pcm
argument_list|)
block|{
name|CHN_LOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|unit
operator|!=
name|udcmask
condition|)
block|{
name|CHN_UNLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|CHN_UNLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|udcmask
operator|&=
operator|~
name|snd_c2unit
argument_list|(
name|cunit
argument_list|)
expr_stmt|;
comment|/* 			 * Temporarily increase clone maxunit to overcome 			 * vchan flexibility. 			 * 			 * # sysctl dev.pcm.0.play.vchans=256 			 * dev.pcm.0.play.vchans: 1 -> 256 			 * # cat /dev/zero> /dev/dsp0.vp255& 			 * [1] 17296 			 * # sysctl dev.pcm.0.play.vchans=0 			 * dev.pcm.0.play.vchans: 256 -> 1 			 * # fg 			 * [1]  + running    cat /dev/zero> /dev/dsp0.vp255 			 * ^C 			 * # cat /dev/zero> /dev/dsp0.vp255 			 * zsh: operation not supported: /dev/dsp0.vp255 			 */
name|tumax
operator|=
name|snd_clone_getmaxunit
argument_list|(
name|d
operator|->
name|clones
argument_list|)
expr_stmt|;
if|if
condition|(
name|cunit
operator|>
name|tumax
condition|)
name|snd_clone_setmaxunit
argument_list|(
name|d
operator|->
name|clones
argument_list|,
name|cunit
argument_list|)
expr_stmt|;
else|else
name|tumax
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|dsp_clone_alloc
goto|;
block|}
comment|/* 		 * Ok, so we're requesting unallocated vchan, but still 		 * within maximum vchan limit. 		 */
if|if
condition|(
operator|(
operator|(
name|devtype
operator|==
name|SND_DEV_DSPHW_VPLAY
operator|&&
name|d
operator|->
name|pvchancount
operator|>
literal|0
operator|)
operator|||
operator|(
name|devtype
operator|==
name|SND_DEV_DSPHW_VREC
operator|&&
name|d
operator|->
name|rvchancount
operator|>
literal|0
operator|)
operator|)
operator|&&
name|cunit
operator|<
name|snd_maxautovchans
condition|)
block|{
name|udcmask
operator|&=
operator|~
name|snd_c2unit
argument_list|(
name|cunit
argument_list|)
expr_stmt|;
name|tumax
operator|=
name|snd_clone_getmaxunit
argument_list|(
name|d
operator|->
name|clones
argument_list|)
expr_stmt|;
if|if
condition|(
name|cunit
operator|>
name|tumax
condition|)
name|snd_clone_setmaxunit
argument_list|(
name|d
operator|->
name|clones
argument_list|,
name|cunit
argument_list|)
expr_stmt|;
else|else
name|tumax
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|dsp_clone_alloc
goto|;
block|}
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
name|dsp_clone_alloc
label|:
name|ce
operator|=
name|snd_clone_alloc
argument_list|(
name|d
operator|->
name|clones
argument_list|,
name|dev
argument_list|,
operator|&
name|cunit
argument_list|,
name|udcmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|tumax
operator|!=
operator|-
literal|1
condition|)
name|snd_clone_setmaxunit
argument_list|(
name|d
operator|->
name|clones
argument_list|,
name|tumax
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|!=
name|NULL
condition|)
block|{
name|udcmask
operator||=
name|snd_c2unit
argument_list|(
name|cunit
argument_list|)
expr_stmt|;
operator|*
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|dsp_cdevsw
argument_list|,
name|unit2minor
argument_list|(
name|udcmask
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"%s%d%s%d"
argument_list|,
name|devname
argument_list|,
name|unit
argument_list|,
name|devsep
argument_list|,
name|cunit
argument_list|)
expr_stmt|;
name|snd_clone_register
argument_list|(
name|ce
argument_list|,
operator|*
name|dev
argument_list|)
expr_stmt|;
block|}
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NULL
condition|)
name|dev_ref
argument_list|(
operator|*
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_sysinit
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|dsp_ehtag
operator|!=
name|NULL
condition|)
return|return;
comment|/* initialize unit numbering */
name|snd_unit_init
argument_list|()
expr_stmt|;
name|dsp_umax
operator|=
name|PCMMAXUNIT
expr_stmt|;
name|dsp_cmax
operator|=
name|PCMMAXCHAN
expr_stmt|;
name|dsp_ehtag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_clone
argument_list|,
name|dsp_clone
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsp_sysuninit
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|dsp_ehtag
operator|==
name|NULL
condition|)
return|return;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|dev_clone
argument_list|,
name|dsp_ehtag
argument_list|)
expr_stmt|;
name|dsp_ehtag
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|dsp_sysinit
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|dsp_sysinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|dsp_sysuninit
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|dsp_sysuninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|dsp_unit2name
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|dtype
decl_stmt|;
name|KASSERT
argument_list|(
name|buf
operator|!=
name|NULL
operator|&&
name|len
operator|!=
literal|0
argument_list|,
operator|(
literal|"bogus buf=%p len=%ju"
operator|,
name|buf
operator|,
operator|(
name|uintmax_t
operator|)
name|len
operator|)
argument_list|)
expr_stmt|;
name|dtype
operator|=
name|snd_unit2d
argument_list|(
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|dsp_cdevs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dsp_cdevs
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dtype
operator|!=
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|type
condition|)
continue|continue;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s%d%s%d"
argument_list|,
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|snd_unit2u
argument_list|(
name|unit
argument_list|)
argument_list|,
name|dsp_cdevs
index|[
name|i
index|]
operator|.
name|sep
argument_list|,
name|snd_unit2c
argument_list|(
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Handler for SNDCTL_AUDIOINFO.  *  * Gathers information about the audio device specified in ai->dev.  If  * ai->dev == -1, then this function gathers information about the current  * device.  If the call comes in on a non-audio device and ai->dev == -1,  * return EINVAL.  *  * This routine is supposed to go practically straight to the hardware,  * getting capabilities directly from the sound card driver, side-stepping  * the intermediate channel interface.  *  * Note, however, that the usefulness of this command is significantly  * decreased when requesting info about any device other than the one serving  * the request. While each snddev_channel refers to a specific device node,  * the converse is *not* true.  Currently, when a sound device node is opened,  * the sound subsystem scans for an available audio channel (or channels, if  * opened in read+write) and then assigns them to the si_drv[12] private  * data fields.  As a result, any information returned linking a channel to  * a specific character device isn't necessarily accurate.  *  * @note  * Calling threads must not hold any snddev_info or pcm_channel locks.  *   * @param dev		device on which the ioctl was issued  * @param ai		ioctl request data container  *  * @retval 0		success  * @retval EINVAL	ai->dev specifies an invalid device  *  * @todo Verify correctness of Doxygen tags.  ;)  */
end_comment

begin_function
name|int
name|dsp_oss_audioinfo
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|oss_audioinfo
modifier|*
name|ai
parameter_list|)
block|{
name|struct
name|pcmchan_caps
modifier|*
name|caps
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|ch
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|uint32_t
name|fmts
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nchan
decl_stmt|,
modifier|*
name|rates
decl_stmt|,
name|minch
decl_stmt|,
name|maxch
decl_stmt|;
name|char
modifier|*
name|devname
decl_stmt|,
name|buf
index|[
name|CHN_NAMELEN
index|]
decl_stmt|;
comment|/* 	 * If probing the device that received the ioctl, make sure it's a 	 * DSP device.  (Users may use this ioctl with /dev/mixer and 	 * /dev/midi.) 	 */
if|if
condition|(
name|ai
operator|->
name|dev
operator|==
operator|-
literal|1
operator|&&
name|i_dev
operator|->
name|si_devsw
operator|!=
operator|&
name|dsp_cdevsw
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ch
operator|=
name|NULL
expr_stmt|;
name|devname
operator|=
name|NULL
expr_stmt|;
name|nchan
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Search for the requested audio device (channel).  Start by 	 * iterating over pcm devices. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pcm_devclass
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|devclass_get_maxunit
argument_list|(
name|pcm_devclass
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
name|devclass_get_softc
argument_list|(
name|pcm_devclass
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCM_REGISTERED
argument_list|(
name|d
argument_list|)
condition|)
continue|continue;
comment|/* XXX Need Giant magic entry ??? */
comment|/* See the note in function docblock */
name|mtx_assert
argument_list|(
name|d
operator|->
name|lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|pcm_lock
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CHN_FOREACH
argument_list|(
argument|ch
argument_list|,
argument|d
argument_list|,
argument|channels.pcm
argument_list|)
block|{
name|mtx_assert
argument_list|(
name|ch
operator|->
name|lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|CHN_LOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|dev
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|DSP_REGISTERED
argument_list|(
name|d
argument_list|,
name|i_dev
argument_list|)
operator|&&
operator|(
name|ch
operator|==
name|PCM_RDCH
argument_list|(
name|i_dev
argument_list|)
operator|||
comment|/* record ch */
name|ch
operator|==
name|PCM_WRCH
argument_list|(
name|i_dev
argument_list|)
operator|)
condition|)
block|{
comment|/* playback ch */
name|devname
operator|=
name|dsp_unit2name
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|ch
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ai
operator|->
name|dev
operator|==
name|nchan
condition|)
block|{
name|devname
operator|=
name|dsp_unit2name
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|ch
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devname
operator|!=
name|NULL
condition|)
break|break;
name|CHN_UNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
operator|++
name|nchan
expr_stmt|;
block|}
if|if
condition|(
name|devname
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * At this point, the following synchronization stuff 			 * has happened: 			 * - a specific PCM device is locked. 			 * - a specific audio channel has been locked, so be 			 *   sure to unlock when exiting; 			 */
name|caps
operator|=
name|chn_getcaps
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* 			 * With all handles collected, zero out the user's 			 * container and begin filling in its fields. 			 */
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ai
argument_list|,
sizeof|sizeof
argument_list|(
name|oss_audioinfo
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|dev
operator|=
name|nchan
expr_stmt|;
name|strlcpy
argument_list|(
name|ai
operator|->
name|name
argument_list|,
name|ch
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ai
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|flags
operator|&
name|CHN_F_BUSY
operator|)
operator|==
literal|0
condition|)
name|ai
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
else|else
name|ai
operator|->
name|busy
operator|=
operator|(
name|ch
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|OPEN_WRITE
else|:
name|OPEN_READ
expr_stmt|;
comment|/** 			 * @note 			 * @c cmd - OSSv4 docs: "Only supported under Linux at 			 *    this moment." Cop-out, I know, but I'll save 			 *    running around in the process table for later. 			 *    Is there a risk of leaking information? 			 */
name|ai
operator|->
name|pid
operator|=
name|ch
operator|->
name|pid
expr_stmt|;
comment|/* 			 * These flags stolen from SNDCTL_DSP_GETCAPS handler. 			 * Note, however, that a single channel operates in 			 * only one direction, so DSP_CAP_DUPLEX is out. 			 */
comment|/** 			 * @todo @c SNDCTL_AUDIOINFO::caps - Make drivers keep 			 *       these in pcmchan::caps? 			 */
name|ai
operator|->
name|caps
operator|=
name|DSP_CAP_REALTIME
operator||
name|DSP_CAP_MMAP
operator||
name|DSP_CAP_TRIGGER
expr_stmt|;
comment|/* 			 * Collect formats supported @b natively by the 			 * device.  Also determine min/max channels.  (I.e., 			 * mono, stereo, or both?) 			 * 			 * If any channel is stereo, maxch = 2; 			 * if all channels are stereo, minch = 2, too; 			 * if any channel is mono, minch = 1; 			 * and if all channels are mono, maxch = 1. 			 */
name|minch
operator|=
literal|0
expr_stmt|;
name|maxch
operator|=
literal|0
expr_stmt|;
name|fmts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|caps
operator|->
name|fmtlist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|fmts
operator||=
name|caps
operator|->
name|fmtlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|caps
operator|->
name|fmtlist
index|[
name|i
index|]
operator|&
name|AFMT_STEREO
condition|)
block|{
name|minch
operator|=
operator|(
name|minch
operator|==
literal|0
operator|)
condition|?
literal|2
else|:
name|minch
expr_stmt|;
name|maxch
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|minch
operator|=
literal|1
expr_stmt|;
name|maxch
operator|=
operator|(
name|maxch
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|maxch
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ch
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
name|ai
operator|->
name|oformats
operator|=
name|fmts
expr_stmt|;
else|else
name|ai
operator|->
name|iformats
operator|=
name|fmts
expr_stmt|;
comment|/** 			 * @note 			 * @c magic - OSSv4 docs: "Reserved for internal use 			 *    by OSS." 			 * 			 * @par 			 * @c card_number - OSSv4 docs: "Number of the sound 			 *    card where this device belongs or -1 if this 			 *    information is not available.  Applications 			 *    should normally not use this field for any 			 *    purpose." 			 */
name|ai
operator|->
name|card_number
operator|=
operator|-
literal|1
expr_stmt|;
comment|/** 			 * @todo @c song_name - depends first on 			 *          SNDCTL_[GS]ETSONG @todo @c label - depends 			 *          on SNDCTL_[GS]ETLABEL 			 * @todo @c port_number - routing information? 			 */
name|ai
operator|->
name|port_number
operator|=
operator|-
literal|1
expr_stmt|;
name|ai
operator|->
name|mixer_dev
operator|=
operator|(
name|d
operator|->
name|mixer_dev
operator|!=
name|NULL
operator|)
condition|?
name|PCMUNIT
argument_list|(
name|d
operator|->
name|mixer_dev
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
comment|/** 			 * @note 			 * @c real_device - OSSv4 docs:  "Obsolete." 			 */
name|ai
operator|->
name|real_device
operator|=
operator|-
literal|1
expr_stmt|;
name|strlcpy
argument_list|(
name|ai
operator|->
name|devnode
argument_list|,
name|devname
argument_list|,
sizeof|sizeof
argument_list|(
name|ai
operator|->
name|devnode
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|enabled
operator|=
name|device_is_attached
argument_list|(
name|d
operator|->
name|dev
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/** 			 * @note 			 * @c flags - OSSv4 docs: "Reserved for future use." 			 * 			 * @note 			 * @c binding - OSSv4 docs: "Reserved for future use." 			 * 			 * @todo @c handle - haven't decided how to generate 			 *       this yet; bus, vendor, device IDs? 			 */
name|ai
operator|->
name|min_rate
operator|=
name|caps
operator|->
name|minspeed
expr_stmt|;
name|ai
operator|->
name|max_rate
operator|=
name|caps
operator|->
name|maxspeed
expr_stmt|;
name|ai
operator|->
name|min_channels
operator|=
name|minch
expr_stmt|;
name|ai
operator|->
name|max_channels
operator|=
name|maxch
expr_stmt|;
name|ai
operator|->
name|nrates
operator|=
name|chn_getrates
argument_list|(
name|ch
argument_list|,
operator|&
name|rates
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|nrates
operator|>
name|OSS_MAX_SAMPLE_RATES
condition|)
name|ai
operator|->
name|nrates
operator|=
name|OSS_MAX_SAMPLE_RATES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ai
operator|->
name|nrates
condition|;
name|i
operator|++
control|)
name|ai
operator|->
name|rates
index|[
name|i
index|]
operator|=
name|rates
index|[
name|i
index|]
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|pcm_unlock
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|devname
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Exhausted the search -- nothing is locked, so return. */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Assigns a PCM channel to a sync group.  *  * Sync groups are used to enable audio operations on multiple devices  * simultaneously.  They may be used with any number of devices and may  * span across applications.  Devices are added to groups with  * the SNDCTL_DSP_SYNCGROUP ioctl, and operations are triggered with the  * SNDCTL_DSP_SYNCSTART ioctl.  *  * If the @c id field of the @c group parameter is set to zero, then a new  * sync group is created.  Otherwise, wrch and rdch (if set) are added to  * the group specified.  *  * @todo As far as memory allocation, should we assume that things are  * 	 okay and allocate with M_WAITOK before acquiring channel locks,  * 	 freeing later if not?  *  * @param wrch	output channel associated w/ device (if any)  * @param rdch	input channel associated w/ device (if any)  * @param group Sync group parameters  *  * @retval 0		success  * @retval non-zero	error to be propagated upstream  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_syncgroup
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_syncgroup
modifier|*
name|group
parameter_list|)
block|{
name|struct
name|pcmchan_syncmember
modifier|*
name|smrd
decl_stmt|,
modifier|*
name|smwr
decl_stmt|;
name|struct
name|pcmchan_syncgroup
modifier|*
name|sg
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|sg_ids
index|[
literal|3
index|]
decl_stmt|;
name|smrd
operator|=
name|NULL
expr_stmt|;
name|smwr
operator|=
name|NULL
expr_stmt|;
name|sg
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Free_unr() may sleep, so store released syncgroup IDs until after 	 * all locks are released. 	 */
name|sg_ids
index|[
literal|0
index|]
operator|=
name|sg_ids
index|[
literal|1
index|]
operator|=
name|sg_ids
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|PCM_SG_LOCK
argument_list|()
expr_stmt|;
comment|/* 	 * - Insert channel(s) into group's member list. 	 * - Set CHN_F_NOTRIGGER on channel(s). 	 * - Stop channel(s).   	 */
comment|/* 	 * If device's channels are already mapped to a group, unmap them. 	 */
if|if
condition|(
name|wrch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|sg_ids
index|[
literal|0
index|]
operator|=
name|chn_syncdestroy
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|sg_ids
index|[
literal|1
index|]
operator|=
name|chn_syncdestroy
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Verify that mode matches character device properites. 	 *  - Bail if PCM_ENABLE_OUTPUT&& wrch == NULL. 	 *  - Bail if PCM_ENABLE_INPUT&& rdch == NULL. 	 */
if|if
condition|(
operator|(
operator|(
name|wrch
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|group
operator|->
name|mode
operator|&
name|PCM_ENABLE_OUTPUT
operator|)
operator|)
operator|||
operator|(
operator|(
name|rdch
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|group
operator|->
name|mode
operator|&
name|PCM_ENABLE_INPUT
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * An id of zero indicates the user wants to create a new 	 * syncgroup. 	 */
if|if
condition|(
name|group
operator|->
name|id
operator|==
literal|0
condition|)
block|{
name|sg
operator|=
operator|(
expr|struct
name|pcmchan_syncgroup
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg
operator|!=
name|NULL
condition|)
block|{
name|SLIST_INIT
argument_list|(
operator|&
name|sg
operator|->
name|members
argument_list|)
expr_stmt|;
name|sg
operator|->
name|id
operator|=
name|alloc_unr
argument_list|(
name|pcmsg_unrhdr
argument_list|)
expr_stmt|;
name|group
operator|->
name|id
operator|=
name|sg
operator|->
name|id
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|snd_pcm_syncgroups
argument_list|,
name|sg
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
name|SLIST_FOREACH
argument_list|(
argument|sg
argument_list|,
argument|&snd_pcm_syncgroups
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|sg
operator|->
name|id
operator|==
name|group
operator|->
name|id
condition|)
break|break;
block|}
if|if
condition|(
name|sg
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* Couldn't create or find a syncgroup.  Fail. */
if|if
condition|(
name|sg
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Allocate a syncmember, assign it and a channel together, and 	 * insert into syncgroup. 	 */
if|if
condition|(
name|group
operator|->
name|mode
operator|&
name|PCM_ENABLE_INPUT
condition|)
block|{
name|smrd
operator|=
operator|(
expr|struct
name|pcmchan_syncmember
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|smrd
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|smrd
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sg
operator|->
name|members
argument_list|,
name|smrd
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|smrd
operator|->
name|parent
operator|=
name|sg
expr_stmt|;
name|smrd
operator|->
name|ch
operator|=
name|rdch
expr_stmt|;
name|chn_abort
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|rdch
operator|->
name|flags
operator||=
name|CHN_F_NOTRIGGER
expr_stmt|;
name|rdch
operator|->
name|sm
operator|=
name|smrd
expr_stmt|;
block|}
if|if
condition|(
name|group
operator|->
name|mode
operator|&
name|PCM_ENABLE_OUTPUT
condition|)
block|{
name|smwr
operator|=
operator|(
expr|struct
name|pcmchan_syncmember
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|smwr
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|smwr
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sg
operator|->
name|members
argument_list|,
name|smwr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|smwr
operator|->
name|parent
operator|=
name|sg
expr_stmt|;
name|smwr
operator|->
name|ch
operator|=
name|wrch
expr_stmt|;
name|chn_abort
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|wrch
operator|->
name|flags
operator||=
name|CHN_F_NOTRIGGER
expr_stmt|;
name|wrch
operator|->
name|sm
operator|=
name|smwr
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|smrd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|smrd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sg
operator|!=
name|NULL
operator|)
operator|&&
name|SLIST_EMPTY
argument_list|(
operator|&
name|sg
operator|->
name|members
argument_list|)
condition|)
block|{
name|sg_ids
index|[
literal|2
index|]
operator|=
name|sg
operator|->
name|id
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|snd_pcm_syncgroups
argument_list|,
name|sg
argument_list|,
name|pcmchan_syncgroup
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sg
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
name|wrch
operator|->
name|sm
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
name|rdch
operator|->
name|sm
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|wrch
condition|)
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|PCM_SG_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sg_ids
index|[
literal|0
index|]
condition|)
name|free_unr
argument_list|(
name|pcmsg_unrhdr
argument_list|,
name|sg_ids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_ids
index|[
literal|1
index|]
condition|)
name|free_unr
argument_list|(
name|pcmsg_unrhdr
argument_list|,
name|sg_ids
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_ids
index|[
literal|2
index|]
condition|)
name|free_unr
argument_list|(
name|pcmsg_unrhdr
argument_list|,
name|sg_ids
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Launch a sync group into action  *  * Sync groups are established via SNDCTL_DSP_SYNCGROUP.  This function  * iterates over all members, triggering them along the way.  *  * @note Caller must not hold any channel locks.  *  * @param sg_id	sync group identifier  *  * @retval 0	success  * @retval non-zero	error worthy of propagating upstream to user  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_syncstart
parameter_list|(
name|int
name|sg_id
parameter_list|)
block|{
name|struct
name|pcmchan_syncmember
modifier|*
name|sm
decl_stmt|,
modifier|*
name|sm_tmp
decl_stmt|;
name|struct
name|pcmchan_syncgroup
modifier|*
name|sg
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|needlocks
decl_stmt|;
comment|/* Get the synclists lock */
name|PCM_SG_LOCK
argument_list|()
expr_stmt|;
do|do
block|{
name|ret
operator|=
literal|0
expr_stmt|;
name|needlocks
operator|=
literal|0
expr_stmt|;
comment|/* Search for syncgroup by ID */
name|SLIST_FOREACH
argument_list|(
argument|sg
argument_list|,
argument|&snd_pcm_syncgroups
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|sg
operator|->
name|id
operator|==
name|sg_id
condition|)
break|break;
block|}
comment|/* Return EINVAL if not found */
if|if
condition|(
name|sg
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Any removals resulting in an empty group should've handled this */
name|KASSERT
argument_list|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|sg
operator|->
name|members
argument_list|)
argument_list|,
operator|(
literal|"found empty syncgroup"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Attempt to lock all member channels - if any are already 		 * locked, unlock those acquired, sleep for a bit, and try 		 * again. 		 */
name|SLIST_FOREACH
argument_list|(
argument|sm
argument_list|,
argument|&sg->members
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|CHN_TRYLOCK
argument_list|(
name|sm
operator|->
name|ch
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|timo
init|=
name|hz
operator|*
literal|5
operator|/
literal|1000
decl_stmt|;
if|if
condition|(
name|timo
operator|<
literal|1
condition|)
name|timo
operator|=
literal|1
expr_stmt|;
comment|/* Release all locked channels so far, retry */
name|SLIST_FOREACH
argument_list|(
argument|sm_tmp
argument_list|,
argument|&sg->members
argument_list|,
argument|link
argument_list|)
block|{
comment|/* sm is the member already locked */
if|if
condition|(
name|sm
operator|==
name|sm_tmp
condition|)
break|break;
name|CHN_UNLOCK
argument_list|(
name|sm_tmp
operator|->
name|ch
argument_list|)
expr_stmt|;
block|}
comment|/** @todo Is PRIBIO correct/ */
name|ret
operator|=
name|msleep
argument_list|(
name|sm
argument_list|,
operator|&
name|snd_pcm_syncgroups_mtx
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmsg"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
condition|)
break|break;
name|needlocks
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* Assumes ret == EAGAIN... */
block|}
block|}
block|}
do|while
condition|(
name|needlocks
operator|&&
name|ret
operator|==
literal|0
condition|)
do|;
comment|/* Proceed only if no errors encountered. */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* Launch channels */
while|while
condition|(
operator|(
name|sm
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sg
operator|->
name|members
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sg
operator|->
name|members
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|c
operator|=
name|sm
operator|->
name|ch
expr_stmt|;
name|c
operator|->
name|sm
operator|=
name|NULL
expr_stmt|;
name|chn_start
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_NOTRIGGER
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|SLIST_REMOVE
argument_list|(
operator|&
name|snd_pcm_syncgroups
argument_list|,
name|sg
argument_list|,
name|pcmchan_syncgroup
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sg
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|PCM_SG_UNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Free_unr() may sleep, so be sure to give up the syncgroup lock 	 * first. 	 */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|free_unr
argument_list|(
name|pcmsg_unrhdr
argument_list|,
name|sg_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Handler for SNDCTL_DSP_POLICY  *  * The SNDCTL_DSP_POLICY ioctl is a simpler interface to control fragment  * size and count like with SNDCTL_DSP_SETFRAGMENT.  Instead of the user  * specifying those two parameters, s/he simply selects a number from 0..10  * which corresponds to a buffer size.  Smaller numbers request smaller  * buffers with lower latencies (at greater overhead from more frequent  * interrupts), while greater numbers behave in the opposite manner.  *  * The 4Front spec states that a value of 5 should be the default.  However,  * this implementation deviates slightly by using a linear scale without  * consulting drivers.  I.e., even though drivers may have different default  * buffer sizes, a policy argument of 5 will have the same result across  * all drivers.  *  * See http://manuals.opensound.com/developer/SNDCTL_DSP_POLICY.html for  * more information.  *  * @todo When SNDCTL_DSP_COOKEDMODE is supported, it'll be necessary to  * 	 work with hardware drivers directly.  *  * @note PCM channel arguments must not be locked by caller.  *  * @param wrch	Pointer to opened playback channel (optional; may be NULL)  * @param rdch	" recording channel (optional; may be NULL)  * @param policy Integer from [0:10]  *  * @retval 0	constant (for now)  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_policy
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|int
name|policy
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|policy
operator|<
name|CHN_POLICY_MIN
operator|||
name|policy
operator|>
name|CHN_POLICY_MAX
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Default: success */
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdch
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setlatency
argument_list|(
name|rdch
argument_list|,
name|policy
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|rdch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrch
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|CHN_LOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_setlatency
argument_list|(
name|wrch
argument_list|,
name|policy
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|wrch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
name|ret
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OSSV4_EXPERIMENT
end_ifdef

begin_comment
comment|/**  * @brief Enable or disable "cooked" mode  *  * This is a handler for @c SNDCTL_DSP_COOKEDMODE.  When in cooked mode, which  * is the default, the sound system handles rate and format conversions  * automatically (ex: user writing 11025Hz/8 bit/unsigned but card only  * operates with 44100Hz/16bit/signed samples).  *  * Disabling cooked mode is intended for applications wanting to mmap()  * a sound card's buffer space directly, bypassing the FreeBSD 2-stage  * feeder architecture, presumably to gain as much control over audio  * hardware as possible.  *  * See @c http://manuals.opensound.com/developer/SNDCTL_DSP_COOKEDMODE.html  * for more details.  *  * @note Currently, this function is just a stub that always returns EINVAL.  *  * @todo Figure out how to and actually implement this.  *  * @param wrch		playback channel (optional; may be NULL)  * @param rdch		recording channel (optional; may be NULL)  * @param enabled	0 = raw mode, 1 = cooked mode  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_cookedmode
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Retrieve channel interleaving order  *  * This is the handler for @c SNDCTL_DSP_GET_CHNORDER.  *  * See @c http://manuals.opensound.com/developer/SNDCTL_DSP_GET_CHNORDER.html  * for more details.  *  * @note As the ioctl definition is still under construction, FreeBSD  * 	 does not currently support SNDCTL_DSP_GET_CHNORDER.  *  * @param wrch	playback channel (optional; may be NULL)  * @param rdch	recording channel (optional; may be NULL)  * @param map	channel map (result will be stored there)  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_getchnorder
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|unsigned
name|long
name|long
modifier|*
name|map
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Specify channel interleaving order  *  * This is the handler for @c SNDCTL_DSP_SET_CHNORDER.  *  * @note As the ioctl definition is still under construction, FreeBSD  * 	 does not currently support @c SNDCTL_DSP_SET_CHNORDER.  *  * @param wrch	playback channel (optional; may be NULL)  * @param rdch	recording channel (optional; may be NULL)  * @param map	channel map  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_setchnorder
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|unsigned
name|long
name|long
modifier|*
name|map
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Retrieve an audio device's label  *  * This is a handler for the @c SNDCTL_GETLABEL ioctl.  *  * See @c http://manuals.opensound.com/developer/SNDCTL_GETLABEL.html  * for more details.  *  * From Hannu@4Front:  "For example ossxmix (just like some HW mixer  * consoles) can show variable "labels" for certain controls. By default  * the application name (say quake) is shown as the label but  * applications may change the labels themselves."  *  * @note As the ioctl definition is still under construction, FreeBSD  * 	 does not currently support @c SNDCTL_GETLABEL.  *  * @param wrch	playback channel (optional; may be NULL)  * @param rdch	recording channel (optional; may be NULL)  * @param label	label gets copied here  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_getlabel
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_label_t
modifier|*
name|label
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Specify an audio device's label  *  * This is a handler for the @c SNDCTL_SETLABEL ioctl.  Please see the  * comments for @c dsp_oss_getlabel immediately above.  *  * See @c http://manuals.opensound.com/developer/SNDCTL_GETLABEL.html  * for more details.  *  * @note As the ioctl definition is still under construction, FreeBSD  * 	 does not currently support SNDCTL_SETLABEL.  *  * @param wrch	playback channel (optional; may be NULL)  * @param rdch	recording channel (optional; may be NULL)  * @param label	label gets copied from here  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_setlabel
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_label_t
modifier|*
name|label
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Retrieve name of currently played song  *  * This is a handler for the @c SNDCTL_GETSONG ioctl.  Audio players could  * tell the system the name of the currently playing song, which would be  * visible in @c /dev/sndstat.  *  * See @c http://manuals.opensound.com/developer/SNDCTL_GETSONG.html  * for more details.  *  * @note As the ioctl definition is still under construction, FreeBSD  * 	 does not currently support SNDCTL_GETSONG.  *  * @param wrch	playback channel (optional; may be NULL)  * @param rdch	recording channel (optional; may be NULL)  * @param song	song name gets copied here  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_getsong
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_longname_t
modifier|*
name|song
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Retrieve name of currently played song  *  * This is a handler for the @c SNDCTL_SETSONG ioctl.  Audio players could  * tell the system the name of the currently playing song, which would be  * visible in @c /dev/sndstat.  *  * See @c http://manuals.opensound.com/developer/SNDCTL_SETSONG.html  * for more details.  *  * @note As the ioctl definition is still under construction, FreeBSD  * 	 does not currently support SNDCTL_SETSONG.  *  * @param wrch	playback channel (optional; may be NULL)  * @param rdch	recording channel (optional; may be NULL)  * @param song	song name gets copied from here  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_setsong
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_longname_t
modifier|*
name|song
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief Rename a device  *  * This is a handler for the @c SNDCTL_SETNAME ioctl.  *  * See @c http://manuals.opensound.com/developer/SNDCTL_SETNAME.html for  * more details.  *  * From Hannu@4Front:  "This call is used to change the device name  * reported in /dev/sndstat and ossinfo. So instead of  using some generic  * 'OSS loopback audio (MIDI) driver' the device may be given a meaningfull  * name depending on the current context (for example 'OSS virtual wave table  * synth' or 'VoIP link to London')."  *  * @note As the ioctl definition is still under construction, FreeBSD  * 	 does not currently support SNDCTL_SETNAME.  *  * @param wrch	playback channel (optional; may be NULL)  * @param rdch	recording channel (optional; may be NULL)  * @param name	new device name gets copied from here  *  * @retval EINVAL	Operation not yet supported.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_oss_setname
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|wrch
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|rdch
parameter_list|,
name|oss_longname_t
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !OSSV4_EXPERIMENT */
end_comment

end_unit

