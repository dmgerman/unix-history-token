begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Cameron Grant<cg@FreeBSD.org>  * Copyright (c) 2003 Orion Hodson<orion@FreeBSD.org>  * Copyright (c) 2005 Ariff Abdullah<ariff@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * 2006-02-21:  * ==========  *  * Major cleanup and overhaul to remove much redundant codes.  * Highlights:  *	1) Support for signed / unsigned 16, 24 and 32 bit,  *	   big / little endian,  *	2) Unlimited channels.  *  * 2005-06-11:  * ==========  *  * *New* and rewritten soft sample rate converter supporting arbitrary sample  * rates, fine grained scaling/coefficients and a unified up/down stereo  * converter. Most of the disclaimers from orion's notes also applies  * here, regarding linear interpolation deficiencies and pre/post  * anti-aliasing filtering issues. This version comes with a much simpler and  * tighter interface, although it works almost exactly like the older one.  *  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *                                                                         *  * This new implementation is fully dedicated in memory of Cameron Grant,  *  * the creator of the magnificent, highly addictive feeder infrastructure. *  *                                                                         *  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  * Orion's notes:  * =============  *  * This rate conversion code uses linear interpolation without any  * pre- or post- interpolation filtering to combat aliasing.  This  * greatly limits the sound quality and should be addressed at some  * stage in the future.  *   * Since this accuracy of interpolation is sensitive and examination  * of the algorithm output is harder from the kernel, the code is  * designed to be compiled in the kernel and in a userland test  * harness.  This is done by selectively including and excluding code  * with several portions based on whether _KERNEL is defined.  It's a  * little ugly, but exceedingly useful.  The testsuite and its  * revisions can be found at:  *		http://people.freebsd.org/~orion/files/feedrate/  *  * Special thanks to Ken Marx for exposing flaws in the code and for  * testing revisions.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|"feeder_if.h"
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|RATE_ASSERT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
end_define

begin_comment
comment|/* KASSERT(x,y) */
end_comment

begin_define
define|#
directive|define
name|RATE_TEST
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
end_define

begin_comment
comment|/* if (!(x)) printf y */
end_comment

begin_define
define|#
directive|define
name|RATE_TRACE
parameter_list|(
name|x
modifier|...
parameter_list|)
end_define

begin_comment
comment|/* printf(x) */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_RATEFEEDER
argument_list|,
literal|"ratefeed"
argument_list|,
literal|"pcm rate feeder"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Don't overflow 32bit integer, since everything is done  * within 32bit arithmetic.  */
end_comment

begin_define
define|#
directive|define
name|RATE_FACTOR_MIN
value|1
end_define

begin_define
define|#
directive|define
name|RATE_FACTOR_MAX
value|PCM_S24_MAX
end_define

begin_define
define|#
directive|define
name|RATE_FACTOR_SAFE
parameter_list|(
name|val
parameter_list|)
value|(!((val)< RATE_FACTOR_MIN || \ 						(val)> RATE_FACTOR_MAX))
end_define

begin_struct_decl
struct_decl|struct
name|feed_rate_info
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|uint32_t
function_decl|(
modifier|*
name|feed_rate_converter
function_decl|)
parameter_list|(
name|struct
name|feed_rate_info
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|feed_rate_info
block|{
name|uint32_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
comment|/* rounded source / destination rates */
name|uint32_t
name|rsrc
decl_stmt|,
name|rdst
decl_stmt|;
comment|/* original source / destination rates */
name|uint32_t
name|gx
decl_stmt|,
name|gy
decl_stmt|;
comment|/* interpolation / decimation ratio */
name|uint32_t
name|alpha
decl_stmt|;
comment|/* interpolation distance */
name|uint32_t
name|pos
decl_stmt|,
name|bpos
decl_stmt|;
comment|/* current sample / buffer positions */
name|uint32_t
name|bufsz
decl_stmt|;
comment|/* total buffer size limit */
name|uint32_t
name|bufsz_init
decl_stmt|;
comment|/* allocated buffer size */
name|uint32_t
name|channels
decl_stmt|;
comment|/* total channels */
name|uint32_t
name|bps
decl_stmt|;
comment|/* bytes-per-sample */
name|uint32_t
name|stray
decl_stmt|;
comment|/* stray bytes */
name|uint8_t
modifier|*
name|buffer
decl_stmt|;
name|feed_rate_converter
name|convert
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|feeder_rate_min
init|=
name|FEEDRATE_RATEMIN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|feeder_rate_max
init|=
name|FEEDRATE_RATEMAX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|feeder_rate_round
init|=
name|FEEDRATE_ROUNDHZ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.snd.feeder_rate_min"
argument_list|,
operator|&
name|feeder_rate_min
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.snd.feeder_rate_max"
argument_list|,
operator|&
name|feeder_rate_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.snd.feeder_rate_round"
argument_list|,
operator|&
name|feeder_rate_round
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_hw_snd_feeder_rate_min
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|feeder_rate_min
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|RATE_FACTOR_SAFE
argument_list|(
name|val
argument_list|)
operator|&&
name|val
operator|<
name|feeder_rate_max
condition|)
name|feeder_rate_min
operator|=
name|val
expr_stmt|;
else|else
name|err
operator|=
name|EINVAL
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|feeder_rate_min
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_hw_snd_feeder_rate_min
argument_list|,
literal|"I"
argument_list|,
literal|"minimum allowable rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_hw_snd_feeder_rate_max
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|feeder_rate_max
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|RATE_FACTOR_SAFE
argument_list|(
name|val
argument_list|)
operator|&&
name|val
operator|>
name|feeder_rate_min
condition|)
name|feeder_rate_max
operator|=
name|val
expr_stmt|;
else|else
name|err
operator|=
name|EINVAL
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|feeder_rate_max
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_hw_snd_feeder_rate_max
argument_list|,
literal|"I"
argument_list|,
literal|"maximum allowable rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_hw_snd_feeder_rate_round
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|feeder_rate_round
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
name|FEEDRATE_ROUNDHZ_MIN
operator|||
name|val
operator|>
name|FEEDRATE_ROUNDHZ_MAX
condition|)
name|err
operator|=
name|EINVAL
expr_stmt|;
else|else
name|feeder_rate_round
operator|=
name|val
operator|-
operator|(
name|val
operator|%
name|FEEDRATE_ROUNDHZ
operator|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|feeder_rate_round
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_hw_snd_feeder_rate_round
argument_list|,
literal|"I"
argument_list|,
literal|"sample rate converter rounding threshold"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|FEEDER_RATE_CONVERT
parameter_list|(
name|FMTBIT
parameter_list|,
name|RATE_INTCAST
parameter_list|,
name|SIGN
parameter_list|,
name|SIGNS
parameter_list|,
name|ENDIAN
parameter_list|,
name|ENDIANS
parameter_list|)
define|\
value|static uint32_t									\ feed_convert_##SIGNS##FMTBIT##ENDIANS(struct feed_rate_info *info,		\ 						uint8_t *dst, uint32_t max)	\ {										\ 	uint32_t ret, smpsz, bps, ch, pos, bpos, gx, gy, alpha, distance;	\ 	int32_t x, y;								\ 	int i;									\ 	uint8_t *src, *sx, *sy;							\ 										\ 	ret = 0;								\ 	alpha = info->alpha;							\ 	gx = info->gx;								\ 	gy = info->gy;								\ 	pos = info->pos;							\ 	bpos = info->bpos;							\ 	src = info->buffer + pos;						\ 	ch = info->channels;							\ 	bps = info->bps;							\ 	smpsz = bps * ch;							\ 	for (;;) {								\ 		if (alpha< gx) {						\ 			alpha += gy;						\ 			pos += smpsz;						\ 			if (pos == bpos)					\ 				break;						\ 			src += smpsz;						\ 		} else {							\ 			alpha -= gx;						\ 			distance = (alpha<< PCM_FXSHIFT) / gy;			\ 			sx = src - smpsz;					\ 			sy = src;						\ 			i = ch;							\ 			do {							\ 				x = PCM_READ_##SIGN##FMTBIT##_##ENDIAN(sx);	\ 				y = PCM_READ_##SIGN##FMTBIT##_##ENDIAN(sy);	\ 				x = (((RATE_INTCAST)x * distance) +		\ 				    ((RATE_INTCAST)y * ((1<< PCM_FXSHIFT) -	\ 				    distance)))>> PCM_FXSHIFT;			\ 				PCM_WRITE_##SIGN##FMTBIT##_##ENDIAN(dst, x);	\ 				dst += bps;					\ 				sx += bps;					\ 				sy += bps;					\ 				ret += bps;					\ 			} while (--i);						\ 			if (ret == max)						\ 				break;						\ 		}								\ 	}									\ 	info->alpha = alpha;							\ 	info->pos = pos;							\ 	return ret;								\ }
end_define

begin_macro
name|FEEDER_RATE_CONVERT
argument_list|(
literal|8
argument_list|,
argument|int32_t
argument_list|,
argument|S
argument_list|,
argument|s
argument_list|,
argument|NE
argument_list|,
argument|ne
argument_list|)
end_macro

begin_macro
name|FEEDER_RATE_CONVERT
argument_list|(
literal|16
argument_list|,
argument|int32_t
argument_list|,
argument|S
argument_list|,
argument|s
argument_list|,
argument|LE
argument_list|,
argument|le
argument_list|)
end_macro

begin_macro
name|FEEDER_RATE_CONVERT
argument_list|(
literal|24
argument_list|,
argument|int32_t
argument_list|,
argument|S
argument_list|,
argument|s
argument_list|,
argument|LE
argument_list|,
argument|le
argument_list|)
end_macro

begin_macro
name|FEEDER_RATE_CONVERT
argument_list|(
literal|32
argument_list|,
argument|intpcm_t
argument_list|,
argument|S
argument_list|,
argument|s
argument_list|,
argument|LE
argument_list|,
argument|le
argument_list|)
end_macro

begin_macro
name|FEEDER_RATE_CONVERT
argument_list|(
literal|16
argument_list|,
argument|int32_t
argument_list|,
argument|S
argument_list|,
argument|s
argument_list|,
argument|BE
argument_list|,
argument|be
argument_list|)
end_macro

begin_macro
name|FEEDER_RATE_CONVERT
argument_list|(
literal|24
argument_list|,
argument|int32_t
argument_list|,
argument|S
argument_list|,
argument|s
argument_list|,
argument|BE
argument_list|,
argument|be
argument_list|)
end_macro

begin_macro
name|FEEDER_RATE_CONVERT
argument_list|(
literal|32
argument_list|,
argument|intpcm_t
argument_list|,
argument|S
argument_list|,
argument|s
argument_list|,
argument|BE
argument_list|,
argument|be
argument_list|)
end_macro

begin_comment
comment|/* unsigned */
end_comment

begin_macro
name|FEEDER_RATE_CONVERT
argument_list|(
literal|8
argument_list|,
argument|int32_t
argument_list|,
argument|U
argument_list|,
argument|u
argument_list|,
argument|NE
argument_list|,
argument|ne
argument_list|)
end_macro

begin_macro
name|FEEDER_RATE_CONVERT
argument_list|(
literal|16
argument_list|,
argument|int32_t
argument_list|,
argument|U
argument_list|,
argument|u
argument_list|,
argument|LE
argument_list|,
argument|le
argument_list|)
end_macro

begin_macro
name|FEEDER_RATE_CONVERT
argument_list|(
literal|24
argument_list|,
argument|int32_t
argument_list|,
argument|U
argument_list|,
argument|u
argument_list|,
argument|LE
argument_list|,
argument|le
argument_list|)
end_macro

begin_macro
name|FEEDER_RATE_CONVERT
argument_list|(
literal|32
argument_list|,
argument|intpcm_t
argument_list|,
argument|U
argument_list|,
argument|u
argument_list|,
argument|LE
argument_list|,
argument|le
argument_list|)
end_macro

begin_macro
name|FEEDER_RATE_CONVERT
argument_list|(
literal|16
argument_list|,
argument|int32_t
argument_list|,
argument|U
argument_list|,
argument|u
argument_list|,
argument|BE
argument_list|,
argument|be
argument_list|)
end_macro

begin_macro
name|FEEDER_RATE_CONVERT
argument_list|(
literal|24
argument_list|,
argument|int32_t
argument_list|,
argument|U
argument_list|,
argument|u
argument_list|,
argument|BE
argument_list|,
argument|be
argument_list|)
end_macro

begin_macro
name|FEEDER_RATE_CONVERT
argument_list|(
literal|32
argument_list|,
argument|intpcm_t
argument_list|,
argument|U
argument_list|,
argument|u
argument_list|,
argument|BE
argument_list|,
argument|be
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|feed_speed_ratio
parameter_list|(
name|uint32_t
name|src
parameter_list|,
name|uint32_t
name|dst
parameter_list|,
name|uint32_t
modifier|*
name|gx
parameter_list|,
name|uint32_t
modifier|*
name|gy
parameter_list|)
block|{
name|uint32_t
name|w
decl_stmt|,
name|x
init|=
name|src
decl_stmt|,
name|y
init|=
name|dst
decl_stmt|;
while|while
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
name|w
operator|=
name|x
operator|%
name|y
expr_stmt|;
name|x
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|w
expr_stmt|;
block|}
operator|*
name|gx
operator|=
name|src
operator|/
name|x
expr_stmt|;
operator|*
name|gy
operator|=
name|dst
operator|/
name|x
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|feed_rate_reset
parameter_list|(
name|struct
name|feed_rate_info
modifier|*
name|info
parameter_list|)
block|{
name|info
operator|->
name|src
operator|=
name|info
operator|->
name|rsrc
operator|-
operator|(
name|info
operator|->
name|rsrc
operator|%
operator|(
operator|(
name|feeder_rate_round
operator|>
literal|0
operator|)
condition|?
name|feeder_rate_round
else|:
literal|1
operator|)
operator|)
expr_stmt|;
name|info
operator|->
name|dst
operator|=
name|info
operator|->
name|rdst
operator|-
operator|(
name|info
operator|->
name|rdst
operator|%
operator|(
operator|(
name|feeder_rate_round
operator|>
literal|0
operator|)
condition|?
name|feeder_rate_round
else|:
literal|1
operator|)
operator|)
expr_stmt|;
name|info
operator|->
name|gx
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|gy
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|alpha
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|channels
operator|=
literal|2
expr_stmt|;
name|info
operator|->
name|bps
operator|=
literal|2
expr_stmt|;
name|info
operator|->
name|convert
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|bufsz
operator|=
name|info
operator|->
name|bufsz_init
expr_stmt|;
name|info
operator|->
name|pos
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|bpos
operator|=
literal|8
expr_stmt|;
name|info
operator|->
name|stray
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|feed_rate_setup
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|feed_rate_info
modifier|*
name|info
init|=
name|f
operator|->
name|data
decl_stmt|;
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|format
decl_stmt|;
comment|/* pcm / audio format */
name|uint32_t
name|bps
decl_stmt|;
comment|/* bytes-per-sample, regardless of 					   total channels */
name|feed_rate_converter
name|convert
decl_stmt|;
block|}
name|convtbl
index|[]
init|=
block|{
block|{
name|AFMT_S8
block|,
name|PCM_8_BPS
block|,
name|feed_convert_s8ne
block|}
block|,
block|{
name|AFMT_S16_LE
block|,
name|PCM_16_BPS
block|,
name|feed_convert_s16le
block|}
block|,
block|{
name|AFMT_S24_LE
block|,
name|PCM_24_BPS
block|,
name|feed_convert_s24le
block|}
block|,
block|{
name|AFMT_S32_LE
block|,
name|PCM_32_BPS
block|,
name|feed_convert_s32le
block|}
block|,
block|{
name|AFMT_S16_BE
block|,
name|PCM_16_BPS
block|,
name|feed_convert_s16be
block|}
block|,
block|{
name|AFMT_S24_BE
block|,
name|PCM_24_BPS
block|,
name|feed_convert_s24be
block|}
block|,
block|{
name|AFMT_S32_BE
block|,
name|PCM_32_BPS
block|,
name|feed_convert_s32be
block|}
block|,
comment|/* unsigned */
block|{
name|AFMT_U8
block|,
name|PCM_8_BPS
block|,
name|feed_convert_u8ne
block|}
block|,
block|{
name|AFMT_U16_LE
block|,
name|PCM_16_BPS
block|,
name|feed_convert_u16le
block|}
block|,
block|{
name|AFMT_U24_LE
block|,
name|PCM_24_BPS
block|,
name|feed_convert_u24le
block|}
block|,
block|{
name|AFMT_U32_LE
block|,
name|PCM_32_BPS
block|,
name|feed_convert_u32le
block|}
block|,
block|{
name|AFMT_U16_BE
block|,
name|PCM_16_BPS
block|,
name|feed_convert_u16be
block|}
block|,
block|{
name|AFMT_U24_BE
block|,
name|PCM_24_BPS
block|,
name|feed_convert_u24be
block|}
block|,
block|{
name|AFMT_U32_BE
block|,
name|PCM_32_BPS
block|,
name|feed_convert_u32be
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|, 	}
struct|;
name|uint32_t
name|i
decl_stmt|;
name|feed_rate_reset
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|src
operator|!=
name|info
operator|->
name|dst
condition|)
name|feed_speed_ratio
argument_list|(
name|info
operator|->
name|src
argument_list|,
name|info
operator|->
name|dst
argument_list|,
operator|&
name|info
operator|->
name|gx
argument_list|,
operator|&
name|info
operator|->
name|gy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|RATE_FACTOR_SAFE
argument_list|(
name|info
operator|->
name|gx
argument_list|)
operator|&&
name|RATE_FACTOR_SAFE
argument_list|(
name|info
operator|->
name|gy
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|convtbl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|convtbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|convtbl
index|[
name|i
index|]
operator|.
name|format
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|f
operator|->
name|desc
operator|->
name|out
operator|&
operator|~
name|AFMT_STEREO
operator|)
operator|==
name|convtbl
index|[
name|i
index|]
operator|.
name|format
condition|)
block|{
name|info
operator|->
name|bps
operator|=
name|convtbl
index|[
name|i
index|]
operator|.
name|bps
expr_stmt|;
name|info
operator|->
name|convert
operator|=
name|convtbl
index|[
name|i
index|]
operator|.
name|convert
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * No need to interpolate/decimate, just do plain copy. 	 */
if|if
condition|(
name|info
operator|->
name|gx
operator|==
name|info
operator|->
name|gy
condition|)
name|info
operator|->
name|convert
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|channels
operator|=
operator|(
name|f
operator|->
name|desc
operator|->
name|out
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|info
operator|->
name|pos
operator|=
name|info
operator|->
name|bps
operator|*
name|info
operator|->
name|channels
expr_stmt|;
name|info
operator|->
name|bpos
operator|=
name|info
operator|->
name|pos
operator|<<
literal|1
expr_stmt|;
name|info
operator|->
name|bufsz
operator|-=
name|info
operator|->
name|bufsz
operator|%
name|info
operator|->
name|pos
expr_stmt|;
name|memset
argument_list|(
name|info
operator|->
name|buffer
argument_list|,
name|sndbuf_zerodata
argument_list|(
name|f
operator|->
name|desc
operator|->
name|out
argument_list|)
argument_list|,
name|info
operator|->
name|bpos
argument_list|)
expr_stmt|;
name|RATE_TRACE
argument_list|(
literal|"%s: %u (%u) -> %u (%u) [%u/%u] , "
literal|"format=0x%08x, channels=%u, bufsz=%u\n"
argument_list|,
name|__func__
argument_list|,
name|info
operator|->
name|src
argument_list|,
name|info
operator|->
name|rsrc
argument_list|,
name|info
operator|->
name|dst
argument_list|,
name|info
operator|->
name|rdst
argument_list|,
name|info
operator|->
name|gx
argument_list|,
name|info
operator|->
name|gy
argument_list|,
name|f
operator|->
name|desc
operator|->
name|out
argument_list|,
name|info
operator|->
name|channels
argument_list|,
name|info
operator|->
name|bufsz
operator|-
name|info
operator|->
name|pos
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|feed_rate_set
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|,
name|int
name|what
parameter_list|,
name|int32_t
name|value
parameter_list|)
block|{
name|struct
name|feed_rate_info
modifier|*
name|info
init|=
name|f
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|value
operator|<
name|feeder_rate_min
operator|||
name|value
operator|>
name|feeder_rate_max
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|FEEDRATE_SRC
case|:
name|info
operator|->
name|rsrc
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|FEEDRATE_DST
case|:
name|info
operator|->
name|rdst
operator|=
name|value
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
name|feed_rate_setup
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|feed_rate_get
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|,
name|int
name|what
parameter_list|)
block|{
name|struct
name|feed_rate_info
modifier|*
name|info
init|=
name|f
operator|->
name|data
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|FEEDRATE_SRC
case|:
return|return
name|info
operator|->
name|rsrc
return|;
case|case
name|FEEDRATE_DST
case|:
return|return
name|info
operator|->
name|rdst
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|feed_rate_init
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|feed_rate_info
modifier|*
name|info
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|desc
operator|->
name|out
operator|!=
name|f
operator|->
name|desc
operator|->
name|in
condition|)
return|return
name|EINVAL
return|;
name|info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|,
name|M_RATEFEEDER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
comment|/* 	 * bufsz = sample from last cycle + conversion space 	 */
name|info
operator|->
name|bufsz_init
operator|=
literal|8
operator|+
name|feeder_buffersize
expr_stmt|;
name|info
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|info
operator|->
name|buffer
argument_list|)
operator|*
name|info
operator|->
name|bufsz_init
argument_list|,
name|M_RATEFEEDER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|info
argument_list|,
name|M_RATEFEEDER
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|info
operator|->
name|rsrc
operator|=
name|DSP_DEFAULT_SPEED
expr_stmt|;
name|info
operator|->
name|rdst
operator|=
name|DSP_DEFAULT_SPEED
expr_stmt|;
name|f
operator|->
name|data
operator|=
name|info
expr_stmt|;
return|return
name|feed_rate_setup
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|feed_rate_free
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|feed_rate_info
modifier|*
name|info
init|=
name|f
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|info
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|buffer
condition|)
name|free
argument_list|(
name|info
operator|->
name|buffer
argument_list|,
name|M_RATEFEEDER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|,
name|M_RATEFEEDER
argument_list|)
expr_stmt|;
block|}
name|f
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|feed_rate
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|uint8_t
modifier|*
name|b
parameter_list|,
name|uint32_t
name|count
parameter_list|,
name|void
modifier|*
name|source
parameter_list|)
block|{
name|struct
name|feed_rate_info
modifier|*
name|info
init|=
name|f
operator|->
name|data
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|smpsz
decl_stmt|;
name|int32_t
name|fetch
decl_stmt|,
name|slot
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|convert
operator|==
name|NULL
condition|)
return|return
name|FEEDER_FEED
argument_list|(
name|f
operator|->
name|source
argument_list|,
name|c
argument_list|,
name|b
argument_list|,
name|count
argument_list|,
name|source
argument_list|)
return|;
comment|/* 	 * This loop has been optimized to generalize both up / down 	 * sampling without causing missing samples or excessive buffer 	 * feeding. The tricky part is to calculate *precise* (slot) value 	 * needed for the entire conversion space since we are bound to 	 * return and fill up the buffer according to the requested 'count'. 	 * Too much feeding will cause the extra buffer stay within temporary 	 * circular buffer forever and always manifest itself as a truncated 	 * sound during end of playback / recording. Too few, and we end up 	 * with possible underruns and waste of cpu cycles. 	 * 	 * 'Stray' management exist to combat with possible unaligned 	 * buffering by the caller. 	 */
name|smpsz
operator|=
name|info
operator|->
name|bps
operator|*
name|info
operator|->
name|channels
expr_stmt|;
name|RATE_TEST
argument_list|(
name|count
operator|>=
name|smpsz
operator|&&
operator|(
name|count
operator|%
name|smpsz
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Count size not sample integral (%d)\n"
operator|,
name|__func__
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|smpsz
condition|)
return|return
literal|0
return|;
name|count
operator|-=
name|count
operator|%
name|smpsz
expr_stmt|;
comment|/* 	 * This slot count formula will stay here for the next million years 	 * to come. This is the key of our circular buffering precision. 	 */
name|slot
operator|=
operator|(
operator|(
operator|(
name|info
operator|->
name|gx
operator|*
operator|(
name|count
operator|/
name|smpsz
operator|)
operator|)
operator|+
name|info
operator|->
name|gy
operator|-
name|info
operator|->
name|alpha
operator|-
literal|1
operator|)
operator|/
name|info
operator|->
name|gy
operator|)
operator|*
name|smpsz
expr_stmt|;
name|RATE_TEST
argument_list|(
operator|(
name|slot
operator|%
name|smpsz
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Slot count not sample integral (%d)\n"
operator|,
name|__func__
operator|,
name|slot
operator|)
argument_list|)
expr_stmt|;
name|RATE_TEST
argument_list|(
name|info
operator|->
name|stray
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: [1] Stray bytes: %u\n"
operator|,
name|__func__
operator|,
name|info
operator|->
name|stray
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|pos
operator|!=
name|smpsz
operator|&&
name|info
operator|->
name|bpos
operator|-
name|info
operator|->
name|pos
operator|==
name|smpsz
operator|&&
name|info
operator|->
name|bpos
operator|+
name|slot
operator|>
name|info
operator|->
name|bufsz
condition|)
block|{
comment|/* 		 * Copy last unit sample and its previous to 		 * beginning of buffer. 		 */
name|bcopy
argument_list|(
name|info
operator|->
name|buffer
operator|+
name|info
operator|->
name|pos
operator|-
name|smpsz
argument_list|,
name|info
operator|->
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
operator|->
name|buffer
argument_list|)
operator|*
operator|(
name|smpsz
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|pos
operator|=
name|smpsz
expr_stmt|;
name|info
operator|->
name|bpos
operator|=
name|smpsz
operator|<<
literal|1
expr_stmt|;
block|}
name|RATE_ASSERT
argument_list|(
name|slot
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: Negative Slot: %d\n"
operator|,
name|__func__
operator|,
name|slot
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|fetch
operator|=
name|info
operator|->
name|bufsz
operator|-
name|info
operator|->
name|bpos
expr_stmt|;
name|fetch
operator|-=
name|info
operator|->
name|stray
expr_stmt|;
name|RATE_ASSERT
argument_list|(
name|fetch
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: [1] Buffer overrun: %d> %d\n"
operator|,
name|__func__
operator|,
name|info
operator|->
name|bpos
operator|,
name|info
operator|->
name|bufsz
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|<
name|fetch
condition|)
name|fetch
operator|=
name|slot
expr_stmt|;
if|if
condition|(
name|fetch
operator|>
literal|0
condition|)
block|{
name|RATE_ASSERT
argument_list|(
call|(
name|int32_t
call|)
argument_list|(
name|info
operator|->
name|bpos
operator|-
name|info
operator|->
name|stray
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|info
operator|->
name|bpos
operator|-
name|info
operator|->
name|stray
operator|)
operator|<
name|info
operator|->
name|bufsz
argument_list|,
operator|(
literal|"%s: DANGER - BUFFER OVERRUN! bufsz=%d, pos=%d\n"
operator|,
name|__func__
operator|,
name|info
operator|->
name|bufsz
operator|,
name|info
operator|->
name|bpos
operator|-
name|info
operator|->
name|stray
operator|)
argument_list|)
expr_stmt|;
name|fetch
operator|=
name|FEEDER_FEED
argument_list|(
name|f
operator|->
name|source
argument_list|,
name|c
argument_list|,
name|info
operator|->
name|buffer
operator|+
name|info
operator|->
name|bpos
operator|-
name|info
operator|->
name|stray
argument_list|,
name|fetch
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|info
operator|->
name|stray
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fetch
operator|==
literal|0
condition|)
break|break;
name|RATE_TEST
argument_list|(
operator|(
name|fetch
operator|%
name|smpsz
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Fetch size not sample integral (%d)\n"
operator|,
name|__func__
operator|,
name|fetch
operator|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|stray
operator|+=
name|fetch
operator|%
name|smpsz
expr_stmt|;
name|RATE_TEST
argument_list|(
name|info
operator|->
name|stray
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Stray bytes detected (%d)\n"
operator|,
name|__func__
operator|,
name|info
operator|->
name|stray
operator|)
argument_list|)
expr_stmt|;
name|fetch
operator|-=
name|fetch
operator|%
name|smpsz
expr_stmt|;
name|info
operator|->
name|bpos
operator|+=
name|fetch
expr_stmt|;
name|slot
operator|-=
name|fetch
expr_stmt|;
name|RATE_ASSERT
argument_list|(
name|slot
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: Negative Slot: %d\n"
operator|,
name|__func__
operator|,
name|slot
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|info
operator|->
name|bpos
operator|==
name|info
operator|->
name|bufsz
condition|)
break|break;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|info
operator|->
name|pos
operator|==
name|info
operator|->
name|bpos
condition|)
block|{
name|RATE_TEST
argument_list|(
name|info
operator|->
name|pos
operator|==
name|smpsz
argument_list|,
operator|(
literal|"%s: EOF while in progress\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|RATE_ASSERT
argument_list|(
name|info
operator|->
name|pos
operator|<=
name|info
operator|->
name|bpos
argument_list|,
operator|(
literal|"%s: [2] Buffer overrun: %d> %d\n"
operator|,
name|__func__
operator|,
name|info
operator|->
name|pos
operator|,
name|info
operator|->
name|bpos
operator|)
argument_list|)
expr_stmt|;
name|RATE_ASSERT
argument_list|(
name|info
operator|->
name|pos
operator|<
name|info
operator|->
name|bpos
argument_list|,
operator|(
literal|"%s: Zero buffer!\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|RATE_ASSERT
argument_list|(
operator|(
operator|(
name|info
operator|->
name|bpos
operator|-
name|info
operator|->
name|pos
operator|)
operator|%
name|smpsz
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Buffer not sample integral (%d)\n"
operator|,
name|__func__
operator|,
name|info
operator|->
name|bpos
operator|-
name|info
operator|->
name|pos
operator|)
argument_list|)
expr_stmt|;
name|i
operator|+=
name|info
operator|->
name|convert
argument_list|(
name|info
argument_list|,
name|b
operator|+
name|i
argument_list|,
name|count
operator|-
name|i
argument_list|)
expr_stmt|;
name|RATE_ASSERT
argument_list|(
name|info
operator|->
name|pos
operator|<=
name|info
operator|->
name|bpos
argument_list|,
operator|(
literal|"%s: [3] Buffer overrun: %d> %d\n"
operator|,
name|__func__
operator|,
name|info
operator|->
name|pos
operator|,
name|info
operator|->
name|bpos
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|pos
operator|==
name|info
operator|->
name|bpos
condition|)
block|{
comment|/* 			 * End of buffer cycle. Copy last unit sample 			 * to beginning of buffer so next cycle can 			 * interpolate using it. 			 */
name|RATE_TEST
argument_list|(
name|info
operator|->
name|stray
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: [2] Stray bytes: %u\n"
operator|,
name|__func__
operator|,
name|info
operator|->
name|stray
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|info
operator|->
name|buffer
operator|+
name|info
operator|->
name|pos
operator|-
name|smpsz
argument_list|,
name|info
operator|->
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
operator|->
name|buffer
argument_list|)
operator|*
name|smpsz
argument_list|)
expr_stmt|;
name|info
operator|->
name|bpos
operator|=
name|smpsz
expr_stmt|;
name|info
operator|->
name|pos
operator|=
name|smpsz
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|count
condition|)
break|break;
block|}
name|RATE_TEST
argument_list|(
operator|(
name|slot
operator|==
literal|0
operator|&&
name|count
operator|==
name|i
operator|)
operator|||
operator|(
name|slot
operator|>
literal|0
operator|&&
name|count
operator|>
name|i
operator|&&
name|info
operator|->
name|pos
operator|==
name|info
operator|->
name|bpos
operator|&&
name|info
operator|->
name|pos
operator|==
name|smpsz
operator|)
argument_list|,
operator|(
literal|"%s: Inconsistent slot/count! "
literal|"Count Expect: %u , Got: %u, Slot Left: %d\n"
operator|,
name|__func__
operator|,
name|count
operator|,
name|i
operator|,
name|slot
operator|)
argument_list|)
expr_stmt|;
name|RATE_TEST
argument_list|(
name|info
operator|->
name|stray
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: [3] Stray bytes: %u\n"
operator|,
name|__func__
operator|,
name|info
operator|->
name|stray
operator|)
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|pcm_feederdesc
name|feeder_rate_desc
index|[]
init|=
block|{
block|{
name|FEEDER_RATE
block|,
name|AFMT_S8
block|,
name|AFMT_S8
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_S16_LE
block|,
name|AFMT_S16_LE
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_S24_LE
block|,
name|AFMT_S24_LE
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_S32_LE
block|,
name|AFMT_S32_LE
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_S16_BE
block|,
name|AFMT_S16_BE
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_S24_BE
block|,
name|AFMT_S24_BE
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_S32_BE
block|,
name|AFMT_S32_BE
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_S8
operator||
name|AFMT_STEREO
block|,
name|AFMT_S8
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
block|,
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_S24_LE
operator||
name|AFMT_STEREO
block|,
name|AFMT_S24_LE
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_S32_LE
operator||
name|AFMT_STEREO
block|,
name|AFMT_S32_LE
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_S16_BE
operator||
name|AFMT_STEREO
block|,
name|AFMT_S16_BE
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_S24_BE
operator||
name|AFMT_STEREO
block|,
name|AFMT_S24_BE
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_S32_BE
operator||
name|AFMT_STEREO
block|,
name|AFMT_S32_BE
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
comment|/* unsigned */
block|{
name|FEEDER_RATE
block|,
name|AFMT_U8
block|,
name|AFMT_U8
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_U16_LE
block|,
name|AFMT_U16_LE
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_U24_LE
block|,
name|AFMT_U24_LE
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_U32_LE
block|,
name|AFMT_U32_LE
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_U16_BE
block|,
name|AFMT_U16_BE
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_U24_BE
block|,
name|AFMT_U24_BE
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_U32_BE
block|,
name|AFMT_U32_BE
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_U8
operator||
name|AFMT_STEREO
block|,
name|AFMT_U8
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_U16_LE
operator||
name|AFMT_STEREO
block|,
name|AFMT_U16_LE
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_U24_LE
operator||
name|AFMT_STEREO
block|,
name|AFMT_U24_LE
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_U32_LE
operator||
name|AFMT_STEREO
block|,
name|AFMT_U32_LE
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_U16_BE
operator||
name|AFMT_STEREO
block|,
name|AFMT_U16_BE
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_U24_BE
operator||
name|AFMT_STEREO
block|,
name|AFMT_U24_BE
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
block|{
name|FEEDER_RATE
block|,
name|AFMT_U32_BE
operator||
name|AFMT_STEREO
block|,
name|AFMT_U32_BE
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kobj_method_t
name|feeder_rate_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|feeder_init
argument_list|,
name|feed_rate_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|feeder_free
argument_list|,
name|feed_rate_free
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|feeder_set
argument_list|,
name|feed_rate_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|feeder_get
argument_list|,
name|feed_rate_get
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|feeder_feed
argument_list|,
name|feed_rate
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|FEEDER_DECLARE
argument_list|(
name|feeder_rate
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

