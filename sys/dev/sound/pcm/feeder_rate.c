begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2009 Ariff Abdullah<ariff@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * feeder_rate: (Codename: Z Resampler), which means any effort to create  *              future replacement for this resampler are simply absurd unless  *              the world decide to add new alphabet after Z.  *  * FreeBSD bandlimited sinc interpolator, technically based on  * "Digital Audio Resampling" by Julius O. Smith III  *  - http://ccrma.stanford.edu/~jos/resample/  *  * The Good:  * + all out fixed point integer operations, no soft-float or anything like  *   that.  * + classic polyphase converters with high quality coefficient's polynomial  *   interpolators.  * + fast, faster, or the fastest of its kind.  * + compile time configurable.  * + etc etc..  *  * The Bad:  * - The z, z_, and Z_ . Due to mental block (or maybe just 0x7a69), I  *   couldn't think of anything simpler than that (feeder_rate_xxx is just  *   too long). Expect possible clashes with other zitizens (any?).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_snd.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/pcm.h>
end_include

begin_include
include|#
directive|include
file|"feeder_if.h"
end_include

begin_define
define|#
directive|define
name|SND_USE_FXDIV
end_define

begin_include
include|#
directive|include
file|"snd_fxdiv_gen.h"
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"feeder_rate_gen.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|SND_DIAGNOSTIC
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|Z_DIAGNOSTIC
end_undef

begin_define
define|#
directive|define
name|Z_DIAGNOSTIC
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_elif

begin_undef
undef|#
directive|undef
name|Z_DIAGNOSTIC
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Z_QUALITY_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|Z_QUALITY_DEFAULT
value|Z_QUALITY_LINEAR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Z_RESERVOIR
value|2048
end_define

begin_define
define|#
directive|define
name|Z_RESERVOIR_MAX
value|131072
end_define

begin_define
define|#
directive|define
name|Z_SINC_MAX
value|0x3fffff
end_define

begin_define
define|#
directive|define
name|Z_SINC_DOWNMAX
value|48
end_define

begin_comment
comment|/* 384000 / 8000 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_define
define|#
directive|define
name|Z_POLYPHASE_MAX
value|183040
end_define

begin_comment
comment|/* 286 taps, 640 phases */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Z_POLYPHASE_MAX
value|1464320
end_define

begin_comment
comment|/* 286 taps, 5120 phases */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Z_RATE_DEFAULT
value|48000
end_define

begin_define
define|#
directive|define
name|Z_RATE_MIN
value|FEEDRATE_RATEMIN
end_define

begin_define
define|#
directive|define
name|Z_RATE_MAX
value|FEEDRATE_RATEMAX
end_define

begin_define
define|#
directive|define
name|Z_ROUNDHZ
value|FEEDRATE_ROUNDHZ
end_define

begin_define
define|#
directive|define
name|Z_ROUNDHZ_MIN
value|FEEDRATE_ROUNDHZ_MIN
end_define

begin_define
define|#
directive|define
name|Z_ROUNDHZ_MAX
value|FEEDRATE_ROUNDHZ_MAX
end_define

begin_define
define|#
directive|define
name|Z_RATE_SRC
value|FEEDRATE_SRC
end_define

begin_define
define|#
directive|define
name|Z_RATE_DST
value|FEEDRATE_DST
end_define

begin_define
define|#
directive|define
name|Z_RATE_QUALITY
value|FEEDRATE_QUALITY
end_define

begin_define
define|#
directive|define
name|Z_RATE_CHANNELS
value|FEEDRATE_CHANNELS
end_define

begin_define
define|#
directive|define
name|Z_PARANOID
value|1
end_define

begin_define
define|#
directive|define
name|Z_MULTIFORMAT
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_undef
undef|#
directive|undef
name|Z_USE_ALPHADRIFT
end_undef

begin_define
define|#
directive|define
name|Z_USE_ALPHADRIFT
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Z_FACTOR_MIN
value|1
end_define

begin_define
define|#
directive|define
name|Z_FACTOR_MAX
value|Z_MASK
end_define

begin_define
define|#
directive|define
name|Z_FACTOR_SAFE
parameter_list|(
name|v
parameter_list|)
value|(!((v)< Z_FACTOR_MIN || (v)> Z_FACTOR_MAX))
end_define

begin_struct_decl
struct_decl|struct
name|z_info
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|z_resampler_t
function_decl|)
parameter_list|(
name|struct
name|z_info
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|z_info
block|{
name|int32_t
name|rsrc
decl_stmt|,
name|rdst
decl_stmt|;
comment|/* original source / destination rates */
name|int32_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
comment|/* rounded source / destination rates */
name|int32_t
name|channels
decl_stmt|;
comment|/* total channels */
name|int32_t
name|bps
decl_stmt|;
comment|/* bytes-per-sample */
name|int32_t
name|quality
decl_stmt|;
comment|/* resampling quality */
name|int32_t
name|z_gx
decl_stmt|,
name|z_gy
decl_stmt|;
comment|/* interpolation / decimation ratio */
name|int32_t
name|z_alpha
decl_stmt|;
comment|/* output sample time phase / drift */
name|uint8_t
modifier|*
name|z_delay
decl_stmt|;
comment|/* FIR delay line / linear buffer */
name|int32_t
modifier|*
name|z_coeff
decl_stmt|;
comment|/* FIR coefficients */
name|int32_t
modifier|*
name|z_dcoeff
decl_stmt|;
comment|/* FIR coefficients differences */
name|int32_t
modifier|*
name|z_pcoeff
decl_stmt|;
comment|/* FIR polyphase coefficients */
name|int32_t
name|z_scale
decl_stmt|;
comment|/* output scaling */
name|int32_t
name|z_dx
decl_stmt|;
comment|/* input sample drift increment */
name|int32_t
name|z_dy
decl_stmt|;
comment|/* output sample drift increment */
ifdef|#
directive|ifdef
name|Z_USE_ALPHADRIFT
name|int32_t
name|z_alphadrift
decl_stmt|;
comment|/* alpha drift rate */
name|int32_t
name|z_startdrift
decl_stmt|;
comment|/* buffer start position drift rate */
endif|#
directive|endif
name|int32_t
name|z_mask
decl_stmt|;
comment|/* delay line full length mask */
name|int32_t
name|z_size
decl_stmt|;
comment|/* half width of FIR taps */
name|int32_t
name|z_full
decl_stmt|;
comment|/* full size of delay line */
name|int32_t
name|z_alloc
decl_stmt|;
comment|/* largest allocated full size of delay line */
name|int32_t
name|z_start
decl_stmt|;
comment|/* buffer processing start position */
name|int32_t
name|z_pos
decl_stmt|;
comment|/* current position for the next feed */
ifdef|#
directive|ifdef
name|Z_DIAGNOSTIC
name|uint32_t
name|z_cycle
decl_stmt|;
comment|/* output cycle, purely for statistical */
endif|#
directive|endif
name|int32_t
name|z_maxfeed
decl_stmt|;
comment|/* maximum feed to avoid 32bit overflow */
name|z_resampler_t
name|z_resample
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|feeder_rate_min
init|=
name|Z_RATE_MIN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|feeder_rate_max
init|=
name|Z_RATE_MAX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|feeder_rate_round
init|=
name|Z_ROUNDHZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|feeder_rate_quality
init|=
name|Z_QUALITY_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|feeder_rate_polyphase_max
init|=
name|Z_POLYPHASE_MAX
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|feeder_rate_presets
index|[]
init|=
name|FEEDER_RATE_PRESETS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|feeder_rate_presets
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|feeder_rate_presets
argument_list|,
literal|0
argument_list|,
literal|"compile-time rate presets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.snd.feeder_rate_min"
argument_list|,
operator|&
name|feeder_rate_min
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.snd.feeder_rate_max"
argument_list|,
operator|&
name|feeder_rate_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.snd.feeder_rate_round"
argument_list|,
operator|&
name|feeder_rate_round
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.snd.feeder_rate_quality"
argument_list|,
operator|&
name|feeder_rate_quality
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|feeder_rate_polyphase_max
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|feeder_rate_polyphase_max
argument_list|,
literal|0
argument_list|,
literal|"maximum allowable polyphase entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_hw_snd_feeder_rate_min
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|feeder_rate_min
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|||
name|val
operator|==
name|feeder_rate_min
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|Z_FACTOR_SAFE
argument_list|(
name|val
argument_list|)
operator|&&
name|val
operator|<
name|feeder_rate_max
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|feeder_rate_min
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|feeder_rate_min
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_hw_snd_feeder_rate_min
argument_list|,
literal|"I"
argument_list|,
literal|"minimum allowable rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_hw_snd_feeder_rate_max
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|feeder_rate_max
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|||
name|val
operator|==
name|feeder_rate_max
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|Z_FACTOR_SAFE
argument_list|(
name|val
argument_list|)
operator|&&
name|val
operator|>
name|feeder_rate_min
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|feeder_rate_max
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|feeder_rate_max
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_hw_snd_feeder_rate_max
argument_list|,
literal|"I"
argument_list|,
literal|"maximum allowable rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_hw_snd_feeder_rate_round
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|feeder_rate_round
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|||
name|val
operator|==
name|feeder_rate_round
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|val
operator|<
name|Z_ROUNDHZ_MIN
operator|||
name|val
operator|>
name|Z_ROUNDHZ_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|feeder_rate_round
operator|=
name|val
operator|-
operator|(
name|val
operator|%
name|Z_ROUNDHZ
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|feeder_rate_round
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_hw_snd_feeder_rate_round
argument_list|,
literal|"I"
argument_list|,
literal|"sample rate converter rounding threshold"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_hw_snd_feeder_rate_quality
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|c
decl_stmt|;
name|struct
name|pcm_feeder
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|feeder_rate_quality
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|||
name|val
operator|==
name|feeder_rate_quality
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|val
operator|<
name|Z_QUALITY_MIN
operator|||
name|val
operator|>
name|Z_QUALITY_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|feeder_rate_quality
operator|=
name|val
expr_stmt|;
comment|/* 	 * Traverse all available channels on each device and try to 	 * set resampler quality if and only if it is exist as 	 * part of feeder chains and the channel is idle. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pcm_devclass
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|devclass_get_maxunit
argument_list|(
name|pcm_devclass
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
name|devclass_get_softc
argument_list|(
name|pcm_devclass
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCM_REGISTERED
argument_list|(
name|d
argument_list|)
condition|)
continue|continue;
name|PCM_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_WAIT
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_ACQUIRE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CHN_FOREACH
argument_list|(
argument|c
argument_list|,
argument|d
argument_list|,
argument|channels.pcm
argument_list|)
block|{
name|CHN_LOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|f
operator|=
name|chn_findfeeder
argument_list|(
name|c
argument_list|,
name|FEEDER_RATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|f
operator|->
name|data
operator|==
name|NULL
operator|||
name|CHN_STARTED
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|CHN_UNLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|FEEDER_SET
argument_list|(
name|f
argument_list|,
name|FEEDRATE_QUALITY
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CHN_UNLOCK
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|PCM_RELEASE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PCM_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|feeder_rate_quality
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_hw_snd_feeder_rate_quality
argument_list|,
literal|"I"
argument_list|,
literal|"sample rate converter quality ("
name|__XSTRING
argument_list|(
name|Z_QUALITY_MIN
argument_list|)
literal|"=low .. "
name|__XSTRING
argument_list|(
name|Z_QUALITY_MAX
argument_list|)
literal|"=high)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_comment
comment|/*  * Resampler type.  */
end_comment

begin_define
define|#
directive|define
name|Z_IS_ZOH
parameter_list|(
name|i
parameter_list|)
value|((i)->quality == Z_QUALITY_ZOH)
end_define

begin_define
define|#
directive|define
name|Z_IS_LINEAR
parameter_list|(
name|i
parameter_list|)
value|((i)->quality == Z_QUALITY_LINEAR)
end_define

begin_define
define|#
directive|define
name|Z_IS_SINC
parameter_list|(
name|i
parameter_list|)
value|((i)->quality> Z_QUALITY_LINEAR)
end_define

begin_comment
comment|/*  * Macroses for accurate sample time drift calculations.  *  * gy2gx : given the amount of output, return the _exact_ required amount of  *         input.  * gx2gy : given the amount of input, return the _maximum_ amount of output  *         that will be generated.  * drift : given the amount of input and output, return the elapsed  *         sample-time.  */
end_comment

begin_define
define|#
directive|define
name|_Z_GCAST
parameter_list|(
name|x
parameter_list|)
value|((uint64_t)(x))
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUCLIKE_ASM
argument_list|)
operator|&&
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_comment
comment|/*  * This is where i386 being beaten to a pulp. Fortunately this function is  * rarely being called and if it is, it will decide the best (hopefully)  * fastest way to do the division. If we can ensure that everything is dword  * aligned, letting the compiler to call udivdi3 to do the division can be  * faster compared to this.  *  * amd64 is the clear winner here, no question about it.  */
end_comment

begin_function
specifier|static
name|__inline
name|uint32_t
name|Z_DIV
parameter_list|(
name|uint64_t
name|v
parameter_list|,
name|uint32_t
name|d
parameter_list|)
block|{
name|uint32_t
name|hi
decl_stmt|,
name|lo
decl_stmt|,
name|quo
decl_stmt|,
name|rem
decl_stmt|;
name|hi
operator|=
name|v
operator|>>
literal|32
expr_stmt|;
name|lo
operator|=
name|v
operator|&
literal|0xffffffff
expr_stmt|;
comment|/* 	 * As much as we can, try to avoid long division like a plague. 	 */
if|if
condition|(
name|hi
operator|==
literal|0
condition|)
name|quo
operator|=
name|lo
operator|/
name|d
expr_stmt|;
else|else
asm|__asm("divl %2"
block|:
literal|"=a"
operator|(
name|quo
operator|)
operator|,
literal|"=d"
operator|(
name|rem
operator|)
operator|:
literal|"r"
operator|(
name|d
operator|)
operator|,
literal|"0"
operator|(
name|lo
operator|)
operator|,
literal|"1"
operator|(
name|hi
operator|)
block|)
function|;
end_function

begin_return
return|return
operator|(
name|quo
operator|)
return|;
end_return

begin_else
unit|}
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Z_DIV
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) / (y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_Z_GY2GX
parameter_list|(
name|i
parameter_list|,
name|a
parameter_list|,
name|v
parameter_list|)
define|\
value|Z_DIV(((_Z_GCAST((i)->z_gx) * (v)) + ((i)->z_gy - (a) - 1)),	\ 	(i)->z_gy)
end_define

begin_define
define|#
directive|define
name|_Z_GX2GY
parameter_list|(
name|i
parameter_list|,
name|a
parameter_list|,
name|v
parameter_list|)
define|\
value|Z_DIV(((_Z_GCAST((i)->z_gy) * (v)) + (a)), (i)->z_gx)
end_define

begin_define
define|#
directive|define
name|_Z_DRIFT
parameter_list|(
name|i
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|((_Z_GCAST((i)->z_gy) * (x)) - (_Z_GCAST((i)->z_gx) * (y)))
end_define

begin_define
define|#
directive|define
name|z_gy2gx
parameter_list|(
name|i
parameter_list|,
name|v
parameter_list|)
value|_Z_GY2GX(i, (i)->z_alpha, v)
end_define

begin_define
define|#
directive|define
name|z_gx2gy
parameter_list|(
name|i
parameter_list|,
name|v
parameter_list|)
value|_Z_GX2GY(i, (i)->z_alpha, v)
end_define

begin_define
define|#
directive|define
name|z_drift
parameter_list|(
name|i
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|_Z_DRIFT(i, x, y)
end_define

begin_comment
comment|/*  * Macroses for SINC coefficients table manipulations.. whatever.  */
end_comment

begin_define
define|#
directive|define
name|Z_SINC_COEFF_IDX
parameter_list|(
name|i
parameter_list|)
value|((i)->quality - Z_QUALITY_LINEAR - 1)
end_define

begin_define
define|#
directive|define
name|Z_SINC_LEN
parameter_list|(
name|i
parameter_list|)
define|\
value|((int32_t)(((uint64_t)z_coeff_tab[Z_SINC_COEFF_IDX(i)].len<<	\ 	    Z_SHIFT) / (i)->z_dy))
end_define

begin_define
define|#
directive|define
name|Z_SINC_BASE_LEN
parameter_list|(
name|i
parameter_list|)
define|\
value|((z_coeff_tab[Z_SINC_COEFF_IDX(i)].len - 1)>> (Z_DRIFT_SHIFT - 1))
end_define

begin_comment
comment|/*  * Macroses for linear delay buffer operations. Alignment is not  * really necessary since we're not using true circular buffer, but it  * will help us guard against possible trespasser. To be honest,  * the linear block operations does not need guarding at all due to  * accurate drifting!  */
end_comment

begin_define
define|#
directive|define
name|z_align
parameter_list|(
name|i
parameter_list|,
name|v
parameter_list|)
value|((v)& (i)->z_mask)
end_define

begin_define
define|#
directive|define
name|z_next
parameter_list|(
name|i
parameter_list|,
name|o
parameter_list|,
name|v
parameter_list|)
value|z_align(i, (o) + (v))
end_define

begin_define
define|#
directive|define
name|z_prev
parameter_list|(
name|i
parameter_list|,
name|o
parameter_list|,
name|v
parameter_list|)
value|z_align(i, (o) - (v))
end_define

begin_define
define|#
directive|define
name|z_fetched
parameter_list|(
name|i
parameter_list|)
value|(z_align(i, (i)->z_pos - (i)->z_start) - 1)
end_define

begin_define
define|#
directive|define
name|z_free
parameter_list|(
name|i
parameter_list|)
value|((i)->z_full - (i)->z_pos)
end_define

begin_comment
comment|/*  * Macroses for Bla Bla .. :)  */
end_comment

begin_define
define|#
directive|define
name|z_copy
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|sz
parameter_list|)
value|(void)memcpy(dst, src, sz)
end_define

begin_define
define|#
directive|define
name|z_feed
parameter_list|(
modifier|...
parameter_list|)
value|FEEDER_FEED(__VA_ARGS__)
end_define

begin_function
unit|static
name|__inline
name|uint32_t
name|z_min
parameter_list|(
name|uint32_t
name|x
parameter_list|,
name|uint32_t
name|y
parameter_list|)
block|{
return|return
operator|(
operator|(
name|x
operator|<
name|y
operator|)
condition|?
name|x
else|:
name|y
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|z_gcd
parameter_list|(
name|int32_t
name|x
parameter_list|,
name|int32_t
name|y
parameter_list|)
block|{
name|int32_t
name|w
decl_stmt|;
while|while
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
name|w
operator|=
name|x
operator|%
name|y
expr_stmt|;
name|x
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|w
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|z_roundpow2
parameter_list|(
name|int32_t
name|v
parameter_list|)
block|{
name|int32_t
name|i
decl_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Let it overflow at will.. 	 */
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|i
operator|<
name|v
condition|)
name|i
operator|<<=
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Zero Order Hold, the worst of the worst, an insult against quality,  * but super fast.  */
end_comment

begin_function
specifier|static
name|void
name|z_feed_zoh
parameter_list|(
name|struct
name|z_info
modifier|*
name|info
parameter_list|,
name|uint8_t
modifier|*
name|dst
parameter_list|)
block|{
if|#
directive|if
literal|0
block|z_copy(info->z_delay + 	    (info->z_start * info->channels * info->bps), dst, 	    info->channels * info->bps);
else|#
directive|else
name|uint32_t
name|cnt
decl_stmt|;
name|uint8_t
modifier|*
name|src
decl_stmt|;
name|cnt
operator|=
name|info
operator|->
name|channels
operator|*
name|info
operator|->
name|bps
expr_stmt|;
name|src
operator|=
name|info
operator|->
name|z_delay
operator|+
operator|(
name|info
operator|->
name|z_start
operator|*
name|cnt
operator|)
expr_stmt|;
comment|/* 	 * This is a bit faster than doing bcopy() since we're dealing 	 * with possible unaligned samples. 	 */
do|do
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|cnt
operator|!=
literal|0
condition|)
do|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Linear Interpolation. This at least sounds better (perceptually) and fast,  * but without any proper filtering which means aliasing still exist and  * could become worst with a right sample. Interpolation centered within  * Z_LINEAR_ONE between the present and previous sample and everything is  * done with simple 32bit scaling arithmetic.  */
end_comment

begin_define
define|#
directive|define
name|Z_DECLARE_LINEAR
parameter_list|(
name|SIGN
parameter_list|,
name|BIT
parameter_list|,
name|ENDIAN
parameter_list|)
define|\
value|static void									\ z_feed_linear_##SIGN##BIT##ENDIAN(struct z_info *info, uint8_t *dst)		\ {										\ 	int32_t z;								\ 	intpcm_t x, y;								\ 	uint32_t ch;								\ 	uint8_t *sx, *sy;							\ 										\ 	z = ((uint32_t)info->z_alpha * info->z_dx)>> Z_LINEAR_UNSHIFT;		\ 										\ 	sx = info->z_delay + (info->z_start * info->channels *			\ 	    PCM_##BIT##_BPS);							\ 	sy = sx - (info->channels * PCM_##BIT##_BPS);				\ 										\ 	ch = info->channels;							\ 										\ 	do {									\ 		x = _PCM_READ_##SIGN##BIT##_##ENDIAN(sx);			\ 		y = _PCM_READ_##SIGN##BIT##_##ENDIAN(sy);			\ 		x = Z_LINEAR_INTERPOLATE_##BIT(z, x, y);			\ 		_PCM_WRITE_##SIGN##BIT##_##ENDIAN(dst, x);			\ 		sx += PCM_##BIT##_BPS;						\ 		sy += PCM_##BIT##_BPS;						\ 		dst += PCM_##BIT##_BPS;						\ 	} while (--ch != 0);							\ }
end_define

begin_comment
comment|/*  * Userland clipping diagnostic check, not enabled in kernel compilation.  * While doing sinc interpolation, unrealistic samples like full scale sine  * wav will clip, but for other things this will not make any noise at all.  * Everybody should learn how to normalized perceived loudness of their own  * music/sounds/samples (hint: ReplayGain).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|Z_DIAGNOSTIC
end_ifdef

begin_define
define|#
directive|define
name|Z_CLIP_CHECK
parameter_list|(
name|v
parameter_list|,
name|BIT
parameter_list|)
value|do {					\ 	if ((v)> PCM_S##BIT##_MAX) {					\ 		fprintf(stderr, "Overflow: v=%jd, max=%jd\n",		\ 		    (intmax_t)(v), (intmax_t)PCM_S##BIT##_MAX);		\ 	} else if ((v)< PCM_S##BIT##_MIN) {				\ 		fprintf(stderr, "Underflow: v=%jd, min=%jd\n",		\ 		    (intmax_t)(v), (intmax_t)PCM_S##BIT##_MIN);		\ 	}								\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Z_CLIP_CHECK
parameter_list|(
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Z_CLAMP
parameter_list|(
name|v
parameter_list|,
name|BIT
parameter_list|)
define|\
value|(((v)> PCM_S##BIT##_MAX) ? PCM_S##BIT##_MAX :			\ 	(((v)< PCM_S##BIT##_MIN) ? PCM_S##BIT##_MIN : (v)))
end_define

begin_comment
comment|/*  * Sine Cardinal (SINC) Interpolation. Scaling is done in 64 bit, so  * there's no point to hold the plate any longer. All samples will be  * shifted to a full 32 bit, scaled and restored during write for  * maximum dynamic range (only for downsampling).  */
end_comment

begin_define
define|#
directive|define
name|_Z_SINC_ACCUMULATE
parameter_list|(
name|SIGN
parameter_list|,
name|BIT
parameter_list|,
name|ENDIAN
parameter_list|,
name|adv
parameter_list|)
define|\
value|c += z>> Z_SHIFT;						\ 	z&= Z_MASK;							\ 	coeff = Z_COEFF_INTERPOLATE(z, z_coeff[c], z_dcoeff[c]);	\ 	x = _PCM_READ_##SIGN##BIT##_##ENDIAN(p);			\ 	v += Z_NORM_##BIT((intpcm64_t)x * coeff);			\ 	z += info->z_dy;						\ 	p adv##= info->channels * PCM_##BIT##_BPS
end_define

begin_comment
comment|/*   * XXX GCC4 optimization is such a !@#$%, need manual unrolling.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|4
end_if

begin_define
define|#
directive|define
name|Z_SINC_ACCUMULATE
parameter_list|(
modifier|...
parameter_list|)
value|do {					\ 	_Z_SINC_ACCUMULATE(__VA_ARGS__);				\ 	_Z_SINC_ACCUMULATE(__VA_ARGS__);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|Z_SINC_ACCUMULATE_DECR
value|2
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Z_SINC_ACCUMULATE
parameter_list|(
modifier|...
parameter_list|)
value|do {					\ 	_Z_SINC_ACCUMULATE(__VA_ARGS__);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|Z_SINC_ACCUMULATE_DECR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Z_DECLARE_SINC
parameter_list|(
name|SIGN
parameter_list|,
name|BIT
parameter_list|,
name|ENDIAN
parameter_list|)
define|\
value|static void									\ z_feed_sinc_##SIGN##BIT##ENDIAN(struct z_info *info, uint8_t *dst)		\ {										\ 	intpcm64_t v;								\ 	intpcm_t x;								\ 	uint8_t *p;								\ 	int32_t coeff, z, *z_coeff, *z_dcoeff;					\ 	uint32_t c, center, ch, i;						\ 										\ 	z_coeff = info->z_coeff;						\ 	z_dcoeff = info->z_dcoeff;						\ 	center = z_prev(info, info->z_start, info->z_size);			\ 	ch = info->channels * PCM_##BIT##_BPS;					\ 	dst += ch;								\ 										\ 	do {									\ 		dst -= PCM_##BIT##_BPS;						\ 		ch -= PCM_##BIT##_BPS;						\ 		v = 0;								\ 		z = info->z_alpha * info->z_dx;					\ 		c = 0;								\ 		p = info->z_delay + (z_next(info, center, 1) *			\ 		    info->channels * PCM_##BIT##_BPS) + ch;			\ 		for (i = info->z_size; i != 0; i -= Z_SINC_ACCUMULATE_DECR) 	\ 			Z_SINC_ACCUMULATE(SIGN, BIT, ENDIAN, +);		\ 		z = info->z_dy - (info->z_alpha * info->z_dx);			\ 		c = 0;								\ 		p = info->z_delay + (center * info->channels *			\ 		    PCM_##BIT##_BPS) + ch;					\ 		for (i = info->z_size; i != 0; i -= Z_SINC_ACCUMULATE_DECR) 	\ 			Z_SINC_ACCUMULATE(SIGN, BIT, ENDIAN, -);		\ 		if (info->z_scale != Z_ONE)					\ 			v = Z_SCALE_##BIT(v, info->z_scale);			\ 		else								\ 			v>>= Z_COEFF_SHIFT - Z_GUARD_BIT_##BIT;		\ 		Z_CLIP_CHECK(v, BIT);						\ 		_PCM_WRITE_##SIGN##BIT##_##ENDIAN(dst, Z_CLAMP(v, BIT));	\ 	} while (ch != 0);							\ }
end_define

begin_define
define|#
directive|define
name|Z_DECLARE_SINC_POLYPHASE
parameter_list|(
name|SIGN
parameter_list|,
name|BIT
parameter_list|,
name|ENDIAN
parameter_list|)
define|\
value|static void									\ z_feed_sinc_polyphase_##SIGN##BIT##ENDIAN(struct z_info *info, uint8_t *dst)	\ {										\ 	intpcm64_t v;								\ 	intpcm_t x;								\ 	uint8_t *p;								\ 	int32_t ch, i, start, *z_pcoeff;					\ 										\ 	ch = info->channels * PCM_##BIT##_BPS;					\ 	dst += ch;								\ 	start = z_prev(info, info->z_start, (info->z_size<< 1) - 1) * ch;	\ 										\ 	do {									\ 		dst -= PCM_##BIT##_BPS;						\ 		ch -= PCM_##BIT##_BPS;						\ 		v = 0;								\ 		p = info->z_delay + start + ch;					\ 		z_pcoeff = info->z_pcoeff +					\ 		    ((info->z_alpha * info->z_size)<< 1);			\ 		for (i = info->z_size; i != 0; i--) {				\ 			x = _PCM_READ_##SIGN##BIT##_##ENDIAN(p);		\ 			v += Z_NORM_##BIT((intpcm64_t)x * *z_pcoeff);		\ 			z_pcoeff++;						\ 			p += info->channels * PCM_##BIT##_BPS;			\ 			x = _PCM_READ_##SIGN##BIT##_##ENDIAN(p);		\ 			v += Z_NORM_##BIT((intpcm64_t)x * *z_pcoeff);		\ 			z_pcoeff++;						\ 			p += info->channels * PCM_##BIT##_BPS;			\ 		}								\ 		if (info->z_scale != Z_ONE)					\ 			v = Z_SCALE_##BIT(v, info->z_scale);			\ 		else								\ 			v>>= Z_COEFF_SHIFT - Z_GUARD_BIT_##BIT;		\ 		Z_CLIP_CHECK(v, BIT);						\ 		_PCM_WRITE_##SIGN##BIT##_##ENDIAN(dst, Z_CLAMP(v, BIT));	\ 	} while (ch != 0);							\ }
end_define

begin_define
define|#
directive|define
name|Z_DECLARE
parameter_list|(
name|SIGN
parameter_list|,
name|BIT
parameter_list|,
name|ENDIAN
parameter_list|)
define|\
value|Z_DECLARE_LINEAR(SIGN, BIT, ENDIAN)				\ 	Z_DECLARE_SINC(SIGN, BIT, ENDIAN)				\ 	Z_DECLARE_SINC_POLYPHASE(SIGN, BIT, ENDIAN)
end_define

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
operator|||
name|defined
argument_list|(
name|SND_FEEDER_MULTIFORMAT
argument_list|)
end_if

begin_macro
name|Z_DECLARE
argument_list|(
argument|S
argument_list|,
literal|16
argument_list|,
argument|LE
argument_list|)
end_macro

begin_macro
name|Z_DECLARE
argument_list|(
argument|S
argument_list|,
literal|32
argument_list|,
argument|LE
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|||
name|defined
argument_list|(
name|SND_FEEDER_MULTIFORMAT
argument_list|)
end_if

begin_macro
name|Z_DECLARE
argument_list|(
argument|S
argument_list|,
literal|16
argument_list|,
argument|BE
argument_list|)
end_macro

begin_macro
name|Z_DECLARE
argument_list|(
argument|S
argument_list|,
literal|32
argument_list|,
argument|BE
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SND_FEEDER_MULTIFORMAT
end_ifdef

begin_macro
name|Z_DECLARE
argument_list|(
argument|S
argument_list|,
literal|8
argument_list|,
argument|NE
argument_list|)
end_macro

begin_macro
name|Z_DECLARE
argument_list|(
argument|S
argument_list|,
literal|24
argument_list|,
argument|LE
argument_list|)
end_macro

begin_macro
name|Z_DECLARE
argument_list|(
argument|S
argument_list|,
literal|24
argument_list|,
argument|BE
argument_list|)
end_macro

begin_macro
name|Z_DECLARE
argument_list|(
argument|U
argument_list|,
literal|8
argument_list|,
argument|NE
argument_list|)
end_macro

begin_macro
name|Z_DECLARE
argument_list|(
argument|U
argument_list|,
literal|16
argument_list|,
argument|LE
argument_list|)
end_macro

begin_macro
name|Z_DECLARE
argument_list|(
argument|U
argument_list|,
literal|24
argument_list|,
argument|LE
argument_list|)
end_macro

begin_macro
name|Z_DECLARE
argument_list|(
argument|U
argument_list|,
literal|32
argument_list|,
argument|LE
argument_list|)
end_macro

begin_macro
name|Z_DECLARE
argument_list|(
argument|U
argument_list|,
literal|16
argument_list|,
argument|BE
argument_list|)
end_macro

begin_macro
name|Z_DECLARE
argument_list|(
argument|U
argument_list|,
literal|24
argument_list|,
argument|BE
argument_list|)
end_macro

begin_expr_stmt
name|Z_DECLARE
argument_list|(
name|U
argument_list|,
literal|32
argument_list|,
name|BE
argument_list|)
endif|#
directive|endif
expr|enum
block|{
name|Z_RESAMPLER_ZOH
block|,
name|Z_RESAMPLER_LINEAR
block|,
name|Z_RESAMPLER_SINC
block|,
name|Z_RESAMPLER_SINC_POLYPHASE
block|,
name|Z_RESAMPLER_LAST
block|}
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|Z_RESAMPLER_IDX
parameter_list|(
name|i
parameter_list|)
define|\
value|(Z_IS_SINC(i) ? Z_RESAMPLER_SINC : (i)->quality)
end_define

begin_define
define|#
directive|define
name|Z_RESAMPLER_ENTRY
parameter_list|(
name|SIGN
parameter_list|,
name|BIT
parameter_list|,
name|ENDIAN
parameter_list|)
define|\
value|{									\ 	    AFMT_##SIGN##BIT##_##ENDIAN,					\ 	    {									\ 		[Z_RESAMPLER_ZOH]    = z_feed_zoh,				\ 		[Z_RESAMPLER_LINEAR] = z_feed_linear_##SIGN##BIT##ENDIAN,	\ 		[Z_RESAMPLER_SINC]   = z_feed_sinc_##SIGN##BIT##ENDIAN,		\ 		[Z_RESAMPLER_SINC_POLYPHASE]   =				\ 		    z_feed_sinc_polyphase_##SIGN##BIT##ENDIAN			\ 	    }									\ 	}
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|format
decl_stmt|;
name|z_resampler_t
name|resampler
index|[
name|Z_RESAMPLER_LAST
index|]
decl_stmt|;
block|}
name|z_resampler_tab
index|[]
init|=
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
operator|||
name|defined
argument_list|(
name|SND_FEEDER_MULTIFORMAT
argument_list|)
name|Z_RESAMPLER_ENTRY
argument_list|(
name|S
argument_list|,
literal|16
argument_list|,
name|LE
argument_list|)
block|,
name|Z_RESAMPLER_ENTRY
argument_list|(
name|S
argument_list|,
literal|32
argument_list|,
name|LE
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|||
name|defined
argument_list|(
name|SND_FEEDER_MULTIFORMAT
argument_list|)
name|Z_RESAMPLER_ENTRY
argument_list|(
name|S
argument_list|,
literal|16
argument_list|,
name|BE
argument_list|)
block|,
name|Z_RESAMPLER_ENTRY
argument_list|(
name|S
argument_list|,
literal|32
argument_list|,
name|BE
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SND_FEEDER_MULTIFORMAT
name|Z_RESAMPLER_ENTRY
argument_list|(
name|S
argument_list|,
literal|8
argument_list|,
name|NE
argument_list|)
block|,
name|Z_RESAMPLER_ENTRY
argument_list|(
name|S
argument_list|,
literal|24
argument_list|,
name|LE
argument_list|)
block|,
name|Z_RESAMPLER_ENTRY
argument_list|(
name|S
argument_list|,
literal|24
argument_list|,
name|BE
argument_list|)
block|,
name|Z_RESAMPLER_ENTRY
argument_list|(
name|U
argument_list|,
literal|8
argument_list|,
name|NE
argument_list|)
block|,
name|Z_RESAMPLER_ENTRY
argument_list|(
name|U
argument_list|,
literal|16
argument_list|,
name|LE
argument_list|)
block|,
name|Z_RESAMPLER_ENTRY
argument_list|(
name|U
argument_list|,
literal|24
argument_list|,
name|LE
argument_list|)
block|,
name|Z_RESAMPLER_ENTRY
argument_list|(
name|U
argument_list|,
literal|32
argument_list|,
name|LE
argument_list|)
block|,
name|Z_RESAMPLER_ENTRY
argument_list|(
name|U
argument_list|,
literal|16
argument_list|,
name|BE
argument_list|)
block|,
name|Z_RESAMPLER_ENTRY
argument_list|(
name|U
argument_list|,
literal|24
argument_list|,
name|BE
argument_list|)
block|,
name|Z_RESAMPLER_ENTRY
argument_list|(
name|U
argument_list|,
literal|32
argument_list|,
name|BE
argument_list|)
block|,
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|Z_RESAMPLER_TAB_SIZE
define|\
value|((int32_t)(sizeof(z_resampler_tab) / sizeof(z_resampler_tab[0])))
end_define

begin_function
specifier|static
name|void
name|z_resampler_reset
parameter_list|(
name|struct
name|z_info
modifier|*
name|info
parameter_list|)
block|{
name|info
operator|->
name|src
operator|=
name|info
operator|->
name|rsrc
operator|-
operator|(
name|info
operator|->
name|rsrc
operator|%
operator|(
operator|(
name|feeder_rate_round
operator|>
literal|0
operator|&&
name|info
operator|->
name|rsrc
operator|>
name|feeder_rate_round
operator|)
condition|?
name|feeder_rate_round
else|:
literal|1
operator|)
operator|)
expr_stmt|;
name|info
operator|->
name|dst
operator|=
name|info
operator|->
name|rdst
operator|-
operator|(
name|info
operator|->
name|rdst
operator|%
operator|(
operator|(
name|feeder_rate_round
operator|>
literal|0
operator|&&
name|info
operator|->
name|rdst
operator|>
name|feeder_rate_round
operator|)
condition|?
name|feeder_rate_round
else|:
literal|1
operator|)
operator|)
expr_stmt|;
name|info
operator|->
name|z_gx
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|z_gy
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|z_alpha
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|z_resample
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|z_size
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|z_coeff
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|z_dcoeff
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|z_pcoeff
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|info
operator|->
name|z_pcoeff
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|info
operator|->
name|z_pcoeff
operator|=
name|NULL
expr_stmt|;
block|}
name|info
operator|->
name|z_scale
operator|=
name|Z_ONE
expr_stmt|;
name|info
operator|->
name|z_dx
operator|=
name|Z_FULL_ONE
expr_stmt|;
name|info
operator|->
name|z_dy
operator|=
name|Z_FULL_ONE
expr_stmt|;
ifdef|#
directive|ifdef
name|Z_DIAGNOSTIC
name|info
operator|->
name|z_cycle
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|info
operator|->
name|quality
operator|<
name|Z_QUALITY_MIN
condition|)
name|info
operator|->
name|quality
operator|=
name|Z_QUALITY_MIN
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|quality
operator|>
name|Z_QUALITY_MAX
condition|)
name|info
operator|->
name|quality
operator|=
name|Z_QUALITY_MAX
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|Z_PARANOID
end_ifdef

begin_function
specifier|static
name|int32_t
name|z_resampler_sinc_len
parameter_list|(
name|struct
name|z_info
modifier|*
name|info
parameter_list|)
block|{
name|int32_t
name|c
decl_stmt|,
name|z
decl_stmt|,
name|len
decl_stmt|,
name|lmax
decl_stmt|;
if|if
condition|(
operator|!
name|Z_IS_SINC
argument_list|(
name|info
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * A rather careful (or useless) way to calculate filter length. 	 * Z_SINC_LEN() itself is accurate enough to do its job. Extra 	 * sanity checking is not going to hurt though.. 	 */
name|c
operator|=
literal|0
expr_stmt|;
name|z
operator|=
name|info
operator|->
name|z_dy
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|lmax
operator|=
name|z_coeff_tab
index|[
name|Z_SINC_COEFF_IDX
argument_list|(
name|info
argument_list|)
index|]
operator|.
name|len
expr_stmt|;
do|do
block|{
name|c
operator|+=
name|z
operator|>>
name|Z_SHIFT
expr_stmt|;
name|z
operator|&=
name|Z_MASK
expr_stmt|;
name|z
operator|+=
name|info
operator|->
name|z_dy
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|<
name|lmax
operator|&&
operator|++
name|len
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|len
operator|!=
name|Z_SINC_LEN
argument_list|(
name|info
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|printf
argument_list|(
literal|"%s(): sinc l=%d != Z_SINC_LEN=%d\n"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|,
name|Z_SINC_LEN
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s(): sinc l=%d != Z_SINC_LEN=%d\n"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|,
name|Z_SINC_LEN
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|z_resampler_sinc_len
parameter_list|(
name|i
parameter_list|)
value|(Z_IS_SINC(i) ? Z_SINC_LEN(i) : 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Z_POLYPHASE_COEFF_SHIFT
value|0
end_define

begin_comment
comment|/*  * Pick suitable polynomial interpolators based on filter oversampled ratio  * (2 ^ Z_DRIFT_SHIFT).  */
end_comment

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|Z_COEFF_INTERP_ZOH
argument_list|)
operator|||
name|defined
argument_list|(
name|Z_COEFF_INTERP_LINEAR
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|Z_COEFF_INTERP_QUADRATIC
argument_list|)
operator|||
name|defined
argument_list|(
name|Z_COEFF_INTERP_HERMITE
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|Z_COEFF_INTER_BSPLINE
argument_list|)
operator|||
name|defined
argument_list|(
name|Z_COEFF_INTERP_OPT32X
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|Z_COEFF_INTERP_OPT16X
argument_list|)
operator|||
name|defined
argument_list|(
name|Z_COEFF_INTERP_OPT8X
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|Z_COEFF_INTERP_OPT4X
argument_list|)
operator|||
name|defined
argument_list|(
name|Z_COEFF_INTERP_OPT2X
argument_list|)
operator|)
end_if

begin_if
if|#
directive|if
name|Z_DRIFT_SHIFT
operator|>=
literal|6
end_if

begin_define
define|#
directive|define
name|Z_COEFF_INTERP_BSPLINE
value|1
end_define

begin_elif
elif|#
directive|elif
name|Z_DRIFT_SHIFT
operator|>=
literal|5
end_elif

begin_define
define|#
directive|define
name|Z_COEFF_INTERP_OPT32X
value|1
end_define

begin_elif
elif|#
directive|elif
name|Z_DRIFT_SHIFT
operator|==
literal|4
end_elif

begin_define
define|#
directive|define
name|Z_COEFF_INTERP_OPT16X
value|1
end_define

begin_elif
elif|#
directive|elif
name|Z_DRIFT_SHIFT
operator|==
literal|3
end_elif

begin_define
define|#
directive|define
name|Z_COEFF_INTERP_OPT8X
value|1
end_define

begin_elif
elif|#
directive|elif
name|Z_DRIFT_SHIFT
operator|==
literal|2
end_elif

begin_define
define|#
directive|define
name|Z_COEFF_INTERP_OPT4X
value|1
end_define

begin_elif
elif|#
directive|elif
name|Z_DRIFT_SHIFT
operator|==
literal|1
end_elif

begin_define
define|#
directive|define
name|Z_COEFF_INTERP_OPT2X
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Z_DRIFT_SHIFT screwed!"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * In classic polyphase mode, the actual coefficients for each phases need to  * be calculated based on default prototype filters. For highly oversampled  * filter, linear or quadradatic interpolator should be enough. Anything less  * than that require 'special' interpolators to reduce interpolation errors.  *  * "Polynomial Interpolators for High-Quality Resampling of Oversampled Audio"  *    by Olli Niemitalo  *    - http://www.student.oulu.fi/~oniemita/dsp/deip.pdf  *  */
end_comment

begin_function
specifier|static
name|int32_t
name|z_coeff_interpolate
parameter_list|(
name|int32_t
name|z
parameter_list|,
name|int32_t
modifier|*
name|z_coeff
parameter_list|)
block|{
name|int32_t
name|coeff
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Z_COEFF_INTERP_ZOH
argument_list|)
comment|/* 1-point, 0th-order (Zero Order Hold) */
name|z
operator|=
name|z
expr_stmt|;
name|coeff
operator|=
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Z_COEFF_INTERP_LINEAR
argument_list|)
name|int32_t
name|zl0
decl_stmt|,
name|zl1
decl_stmt|;
comment|/* 2-point, 1st-order Linear */
name|zl0
operator|=
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
name|zl1
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|-
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
name|coeff
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
name|int64_t
operator|)
name|zl1
operator|*
name|z
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zl0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Z_COEFF_INTERP_QUADRATIC
argument_list|)
name|int32_t
name|zq0
decl_stmt|,
name|zq1
decl_stmt|,
name|zq2
decl_stmt|;
comment|/* 3-point, 2nd-order Quadratic */
name|zq0
operator|=
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
name|zq1
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|zq2
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|+
name|z_coeff
index|[
operator|-
literal|1
index|]
operator|-
operator|(
name|z_coeff
index|[
literal|0
index|]
operator|<<
literal|1
operator|)
expr_stmt|;
name|coeff
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|int64_t
operator|)
name|zq2
operator|*
name|z
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zq1
operator|)
operator|*
name|z
argument_list|,
name|Z_SHIFT
operator|+
literal|1
argument_list|)
operator|+
name|zq0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Z_COEFF_INTERP_HERMITE
argument_list|)
name|int32_t
name|zh0
decl_stmt|,
name|zh1
decl_stmt|,
name|zh2
decl_stmt|,
name|zh3
decl_stmt|;
comment|/* 4-point, 3rd-order Hermite */
name|zh0
operator|=
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
name|zh1
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|zh2
operator|=
operator|(
name|z_coeff
index|[
operator|-
literal|1
index|]
operator|<<
literal|1
operator|)
operator|-
operator|(
name|z_coeff
index|[
literal|0
index|]
operator|*
literal|5
operator|)
operator|+
operator|(
name|z_coeff
index|[
literal|1
index|]
operator|<<
literal|2
operator|)
operator|-
name|z_coeff
index|[
literal|2
index|]
expr_stmt|;
name|zh3
operator|=
name|z_coeff
index|[
literal|2
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|1
index|]
operator|+
operator|(
operator|(
name|z_coeff
index|[
literal|0
index|]
operator|-
name|z_coeff
index|[
literal|1
index|]
operator|)
operator|*
literal|3
operator|)
expr_stmt|;
name|coeff
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|int64_t
operator|)
name|zh3
operator|*
name|z
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zh2
operator|)
operator|*
name|z
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zh1
operator|)
operator|*
name|z
argument_list|,
name|Z_SHIFT
operator|+
literal|1
argument_list|)
operator|+
name|zh0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Z_COEFF_INTERP_BSPLINE
argument_list|)
name|int32_t
name|zb0
decl_stmt|,
name|zb1
decl_stmt|,
name|zb2
decl_stmt|,
name|zb3
decl_stmt|;
comment|/* 4-point, 3rd-order B-Spline */
name|zb0
operator|=
name|Z_RSHIFT
argument_list|(
literal|0x15555555LL
operator|*
operator|(
operator|(
operator|(
name|int64_t
operator|)
name|z_coeff
index|[
literal|0
index|]
operator|<<
literal|2
operator|)
operator|+
name|z_coeff
index|[
operator|-
literal|1
index|]
operator|+
name|z_coeff
index|[
literal|1
index|]
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zb1
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|zb2
operator|=
name|z_coeff
index|[
operator|-
literal|1
index|]
operator|+
name|z_coeff
index|[
literal|1
index|]
operator|-
operator|(
name|z_coeff
index|[
literal|0
index|]
operator|<<
literal|1
operator|)
expr_stmt|;
name|zb3
operator|=
name|Z_RSHIFT
argument_list|(
literal|0x15555555LL
operator|*
operator|(
operator|(
operator|(
name|z_coeff
index|[
literal|0
index|]
operator|-
name|z_coeff
index|[
literal|1
index|]
operator|)
operator|*
literal|3
operator|)
operator|+
name|z_coeff
index|[
literal|2
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|1
index|]
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|coeff
operator|=
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|int64_t
operator|)
name|zb3
operator|*
name|z
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zb2
operator|)
operator|*
name|z
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zb1
operator|)
operator|*
name|z
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zb0
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Z_COEFF_INTERP_OPT32X
argument_list|)
name|int32_t
name|zoz
decl_stmt|,
name|zoe1
decl_stmt|,
name|zoe2
decl_stmt|,
name|zoe3
decl_stmt|,
name|zoo1
decl_stmt|,
name|zoo2
decl_stmt|,
name|zoo3
decl_stmt|;
name|int32_t
name|zoc0
decl_stmt|,
name|zoc1
decl_stmt|,
name|zoc2
decl_stmt|,
name|zoc3
decl_stmt|,
name|zoc4
decl_stmt|,
name|zoc5
decl_stmt|;
comment|/* 6-point, 5th-order Optimal 32x */
name|zoz
operator|=
name|z
operator|-
operator|(
name|Z_ONE
operator|>>
literal|1
operator|)
expr_stmt|;
name|zoe1
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|+
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
name|zoe2
operator|=
name|z_coeff
index|[
literal|2
index|]
operator|+
name|z_coeff
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|zoe3
operator|=
name|z_coeff
index|[
literal|3
index|]
operator|+
name|z_coeff
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|zoo1
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|-
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
name|zoo2
operator|=
name|z_coeff
index|[
literal|2
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|zoo3
operator|=
name|z_coeff
index|[
literal|3
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|zoc0
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x1ac2260dLL
operator|*
name|zoe1
operator|)
operator|+
operator|(
literal|0x0526cdcaLL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x00170c29LL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc1
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x14f8a49aLL
operator|*
name|zoo1
operator|)
operator|+
operator|(
literal|0x0d6d1109LL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x008cd4dcLL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc2
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
operator|-
literal|0x0d3e94a4LL
operator|*
name|zoe1
operator|)
operator|+
operator|(
literal|0x0bddded4LL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x0160b5d0LL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc3
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
operator|-
literal|0x0de10cc4LL
operator|*
name|zoo1
operator|)
operator|+
operator|(
literal|0x019b2a7dLL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x01cfe914LL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc4
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x02aa12d7LL
operator|*
name|zoe1
operator|)
operator|+
operator|(
operator|-
literal|0x03ff1bb3LL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x015508ddLL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc5
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x051d29e5LL
operator|*
name|zoo1
operator|)
operator|+
operator|(
operator|-
literal|0x028e7647LL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x0082d81aLL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|coeff
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|int64_t
operator|)
name|zoc5
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc4
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc3
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc2
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc1
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Z_COEFF_INTERP_OPT16X
argument_list|)
name|int32_t
name|zoz
decl_stmt|,
name|zoe1
decl_stmt|,
name|zoe2
decl_stmt|,
name|zoe3
decl_stmt|,
name|zoo1
decl_stmt|,
name|zoo2
decl_stmt|,
name|zoo3
decl_stmt|;
name|int32_t
name|zoc0
decl_stmt|,
name|zoc1
decl_stmt|,
name|zoc2
decl_stmt|,
name|zoc3
decl_stmt|,
name|zoc4
decl_stmt|,
name|zoc5
decl_stmt|;
comment|/* 6-point, 5th-order Optimal 16x */
name|zoz
operator|=
name|z
operator|-
operator|(
name|Z_ONE
operator|>>
literal|1
operator|)
expr_stmt|;
name|zoe1
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|+
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
name|zoe2
operator|=
name|z_coeff
index|[
literal|2
index|]
operator|+
name|z_coeff
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|zoe3
operator|=
name|z_coeff
index|[
literal|3
index|]
operator|+
name|z_coeff
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|zoo1
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|-
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
name|zoo2
operator|=
name|z_coeff
index|[
literal|2
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|zoo3
operator|=
name|z_coeff
index|[
literal|3
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|zoc0
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x1ac2260dLL
operator|*
name|zoe1
operator|)
operator|+
operator|(
literal|0x0526cdcaLL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x00170c29LL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc1
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x14f8a49aLL
operator|*
name|zoo1
operator|)
operator|+
operator|(
literal|0x0d6d1109LL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x008cd4dcLL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc2
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
operator|-
literal|0x0d3e94a4LL
operator|*
name|zoe1
operator|)
operator|+
operator|(
literal|0x0bddded4LL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x0160b5d0LL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc3
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
operator|-
literal|0x0de10cc4LL
operator|*
name|zoo1
operator|)
operator|+
operator|(
literal|0x019b2a7dLL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x01cfe914LL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc4
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x02aa12d7LL
operator|*
name|zoe1
operator|)
operator|+
operator|(
operator|-
literal|0x03ff1bb3LL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x015508ddLL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc5
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x051d29e5LL
operator|*
name|zoo1
operator|)
operator|+
operator|(
operator|-
literal|0x028e7647LL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x0082d81aLL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|coeff
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|int64_t
operator|)
name|zoc5
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc4
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc3
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc2
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc1
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Z_COEFF_INTERP_OPT8X
argument_list|)
name|int32_t
name|zoz
decl_stmt|,
name|zoe1
decl_stmt|,
name|zoe2
decl_stmt|,
name|zoe3
decl_stmt|,
name|zoo1
decl_stmt|,
name|zoo2
decl_stmt|,
name|zoo3
decl_stmt|;
name|int32_t
name|zoc0
decl_stmt|,
name|zoc1
decl_stmt|,
name|zoc2
decl_stmt|,
name|zoc3
decl_stmt|,
name|zoc4
decl_stmt|,
name|zoc5
decl_stmt|;
comment|/* 6-point, 5th-order Optimal 8x */
name|zoz
operator|=
name|z
operator|-
operator|(
name|Z_ONE
operator|>>
literal|1
operator|)
expr_stmt|;
name|zoe1
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|+
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
name|zoe2
operator|=
name|z_coeff
index|[
literal|2
index|]
operator|+
name|z_coeff
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|zoe3
operator|=
name|z_coeff
index|[
literal|3
index|]
operator|+
name|z_coeff
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|zoo1
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|-
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
name|zoo2
operator|=
name|z_coeff
index|[
literal|2
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|zoo3
operator|=
name|z_coeff
index|[
literal|3
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|zoc0
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x1aa9b47dLL
operator|*
name|zoe1
operator|)
operator|+
operator|(
literal|0x053d9944LL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x0018b23fLL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc1
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x14a104d1LL
operator|*
name|zoo1
operator|)
operator|+
operator|(
literal|0x0d7d2504LL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x0094b599LL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc2
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
operator|-
literal|0x0d22530bLL
operator|*
name|zoe1
operator|)
operator|+
operator|(
literal|0x0bb37a2cLL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x016ed8e0LL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc3
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
operator|-
literal|0x0d744b1cLL
operator|*
name|zoo1
operator|)
operator|+
operator|(
literal|0x01649591LL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x01dae93aLL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc4
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x02a7ee1bLL
operator|*
name|zoe1
operator|)
operator|+
operator|(
operator|-
literal|0x03fbdb24LL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x0153ed07LL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc5
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x04cf9b6cLL
operator|*
name|zoo1
operator|)
operator|+
operator|(
operator|-
literal|0x0266b378LL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x007a7c26LL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|coeff
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|int64_t
operator|)
name|zoc5
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc4
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc3
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc2
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc1
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Z_COEFF_INTERP_OPT4X
argument_list|)
name|int32_t
name|zoz
decl_stmt|,
name|zoe1
decl_stmt|,
name|zoe2
decl_stmt|,
name|zoe3
decl_stmt|,
name|zoo1
decl_stmt|,
name|zoo2
decl_stmt|,
name|zoo3
decl_stmt|;
name|int32_t
name|zoc0
decl_stmt|,
name|zoc1
decl_stmt|,
name|zoc2
decl_stmt|,
name|zoc3
decl_stmt|,
name|zoc4
decl_stmt|,
name|zoc5
decl_stmt|;
comment|/* 6-point, 5th-order Optimal 4x */
name|zoz
operator|=
name|z
operator|-
operator|(
name|Z_ONE
operator|>>
literal|1
operator|)
expr_stmt|;
name|zoe1
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|+
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
name|zoe2
operator|=
name|z_coeff
index|[
literal|2
index|]
operator|+
name|z_coeff
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|zoe3
operator|=
name|z_coeff
index|[
literal|3
index|]
operator|+
name|z_coeff
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|zoo1
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|-
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
name|zoo2
operator|=
name|z_coeff
index|[
literal|2
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|zoo3
operator|=
name|z_coeff
index|[
literal|3
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|zoc0
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x1a8eda43LL
operator|*
name|zoe1
operator|)
operator|+
operator|(
literal|0x0556ee38LL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x001a3784LL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc1
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x143d863eLL
operator|*
name|zoo1
operator|)
operator|+
operator|(
literal|0x0d910e36LL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x009ca889LL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc2
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
operator|-
literal|0x0d026821LL
operator|*
name|zoe1
operator|)
operator|+
operator|(
literal|0x0b837773LL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x017ef0c6LL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc3
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
operator|-
literal|0x0cef1502LL
operator|*
name|zoo1
operator|)
operator|+
operator|(
literal|0x01207a8eLL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x01e936dbLL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc4
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x029fe643LL
operator|*
name|zoe1
operator|)
operator|+
operator|(
operator|-
literal|0x03ef3fc8LL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x014f5923LL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc5
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x043a9d08LL
operator|*
name|zoo1
operator|)
operator|+
operator|(
operator|-
literal|0x02154febLL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x00670dbdLL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|coeff
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|int64_t
operator|)
name|zoc5
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc4
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc3
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc2
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc1
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Z_COEFF_INTERP_OPT2X
argument_list|)
name|int32_t
name|zoz
decl_stmt|,
name|zoe1
decl_stmt|,
name|zoe2
decl_stmt|,
name|zoe3
decl_stmt|,
name|zoo1
decl_stmt|,
name|zoo2
decl_stmt|,
name|zoo3
decl_stmt|;
name|int32_t
name|zoc0
decl_stmt|,
name|zoc1
decl_stmt|,
name|zoc2
decl_stmt|,
name|zoc3
decl_stmt|,
name|zoc4
decl_stmt|,
name|zoc5
decl_stmt|;
comment|/* 6-point, 5th-order Optimal 2x */
name|zoz
operator|=
name|z
operator|-
operator|(
name|Z_ONE
operator|>>
literal|1
operator|)
expr_stmt|;
name|zoe1
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|+
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
name|zoe2
operator|=
name|z_coeff
index|[
literal|2
index|]
operator|+
name|z_coeff
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|zoe3
operator|=
name|z_coeff
index|[
literal|3
index|]
operator|+
name|z_coeff
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|zoo1
operator|=
name|z_coeff
index|[
literal|1
index|]
operator|-
name|z_coeff
index|[
literal|0
index|]
expr_stmt|;
name|zoo2
operator|=
name|z_coeff
index|[
literal|2
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|zoo3
operator|=
name|z_coeff
index|[
literal|3
index|]
operator|-
name|z_coeff
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|zoc0
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x19edb6fdLL
operator|*
name|zoe1
operator|)
operator|+
operator|(
literal|0x05ebd062LL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x00267881LL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc1
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x1223af76LL
operator|*
name|zoo1
operator|)
operator|+
operator|(
literal|0x0de3dd6bLL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x00d683cdLL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc2
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
operator|-
literal|0x0c3ee068LL
operator|*
name|zoe1
operator|)
operator|+
operator|(
literal|0x0a5c3769LL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x01e2aceaLL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc3
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
operator|-
literal|0x0a8ab614LL
operator|*
name|zoo1
operator|)
operator|+
operator|(
operator|-
literal|0x0019522eLL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x022cefc7LL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc4
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x0276187dLL
operator|*
name|zoe1
operator|)
operator|+
operator|(
operator|-
literal|0x03a801e8LL
operator|*
name|zoe2
operator|)
operator|+
operator|(
literal|0x0131d935LL
operator|*
name|zoe3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|zoc5
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
literal|0x02c373f5LL
operator|*
name|zoo1
operator|)
operator|+
operator|(
operator|-
literal|0x01275f83LL
operator|*
name|zoo2
operator|)
operator|+
operator|(
literal|0x0018ee79LL
operator|*
name|zoo3
operator|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|coeff
operator|=
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|Z_RSHIFT
argument_list|(
operator|(
name|int64_t
operator|)
name|zoc5
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc4
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc3
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc2
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc1
operator|)
operator|*
name|zoz
argument_list|,
name|Z_SHIFT
argument_list|)
operator|+
name|zoc0
expr_stmt|;
else|#
directive|else
error|#
directive|error
literal|"Interpolation type screwed!"
endif|#
directive|endif
if|#
directive|if
name|Z_POLYPHASE_COEFF_SHIFT
operator|>
literal|0
name|coeff
operator|=
name|Z_RSHIFT
argument_list|(
name|coeff
argument_list|,
name|Z_POLYPHASE_COEFF_SHIFT
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|coeff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|z_resampler_build_polyphase
parameter_list|(
name|struct
name|z_info
modifier|*
name|info
parameter_list|)
block|{
name|int32_t
name|alpha
decl_stmt|,
name|c
decl_stmt|,
name|i
decl_stmt|,
name|z
decl_stmt|,
name|idx
decl_stmt|;
comment|/* Let this be here first. */
if|if
condition|(
name|info
operator|->
name|z_pcoeff
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|info
operator|->
name|z_pcoeff
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|info
operator|->
name|z_pcoeff
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|feeder_rate_polyphase_max
operator|<
literal|1
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|int64_t
operator|)
name|info
operator|->
name|z_size
operator|*
name|info
operator|->
name|z_gy
operator|*
literal|2
operator|)
operator|>
name|feeder_rate_polyphase_max
condition|)
block|{
ifndef|#
directive|ifndef
name|_KERNEL
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Polyphase entries exceed: [%d/%d] %jd> %d\n"
argument_list|,
name|info
operator|->
name|z_gx
argument_list|,
name|info
operator|->
name|z_gy
argument_list|,
operator|(
name|intmax_t
operator|)
name|info
operator|->
name|z_size
operator|*
name|info
operator|->
name|z_gy
operator|*
literal|2
argument_list|,
name|feeder_rate_polyphase_max
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
name|info
operator|->
name|z_pcoeff
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|*
name|info
operator|->
name|z_size
operator|*
name|info
operator|->
name|z_gy
operator|*
literal|2
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|z_pcoeff
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|alpha
operator|=
literal|0
init|;
name|alpha
operator|<
name|info
operator|->
name|z_gy
condition|;
name|alpha
operator|++
control|)
block|{
name|z
operator|=
name|alpha
operator|*
name|info
operator|->
name|z_dx
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|info
operator|->
name|z_size
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|c
operator|+=
name|z
operator|>>
name|Z_SHIFT
expr_stmt|;
name|z
operator|&=
name|Z_MASK
expr_stmt|;
name|idx
operator|=
operator|(
name|alpha
operator|*
name|info
operator|->
name|z_size
operator|*
literal|2
operator|)
operator|+
operator|(
name|info
operator|->
name|z_size
operator|*
literal|2
operator|)
operator|-
name|i
expr_stmt|;
name|info
operator|->
name|z_pcoeff
index|[
name|idx
index|]
operator|=
name|z_coeff_interpolate
argument_list|(
name|z
argument_list|,
name|info
operator|->
name|z_coeff
operator|+
name|c
argument_list|)
expr_stmt|;
name|z
operator|+=
name|info
operator|->
name|z_dy
expr_stmt|;
block|}
name|z
operator|=
name|info
operator|->
name|z_dy
operator|-
operator|(
name|alpha
operator|*
name|info
operator|->
name|z_dx
operator|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|info
operator|->
name|z_size
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|c
operator|+=
name|z
operator|>>
name|Z_SHIFT
expr_stmt|;
name|z
operator|&=
name|Z_MASK
expr_stmt|;
name|idx
operator|=
operator|(
name|alpha
operator|*
name|info
operator|->
name|z_size
operator|*
literal|2
operator|)
operator|+
name|i
operator|-
literal|1
expr_stmt|;
name|info
operator|->
name|z_pcoeff
index|[
name|idx
index|]
operator|=
name|z_coeff_interpolate
argument_list|(
name|z
argument_list|,
name|info
operator|->
name|z_coeff
operator|+
name|c
argument_list|)
expr_stmt|;
name|z
operator|+=
name|info
operator|->
name|z_dy
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|_KERNEL
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Polyphase: [%d/%d] %d entries\n"
argument_list|,
name|info
operator|->
name|z_gx
argument_list|,
name|info
operator|->
name|z_gy
argument_list|,
name|info
operator|->
name|z_size
operator|*
name|info
operator|->
name|z_gy
operator|*
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|z_resampler_setup
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|z_info
modifier|*
name|info
decl_stmt|;
name|int64_t
name|gy2gx_max
decl_stmt|,
name|gx2gy_max
decl_stmt|;
name|uint32_t
name|format
decl_stmt|;
name|int32_t
name|align
decl_stmt|,
name|i
decl_stmt|,
name|z_scale
decl_stmt|;
name|int
name|adaptive
decl_stmt|;
name|info
operator|=
name|f
operator|->
name|data
expr_stmt|;
name|z_resampler_reset
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|src
operator|==
name|info
operator|->
name|dst
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Shrink by greatest common divisor. */
name|i
operator|=
name|z_gcd
argument_list|(
name|info
operator|->
name|src
argument_list|,
name|info
operator|->
name|dst
argument_list|)
expr_stmt|;
name|info
operator|->
name|z_gx
operator|=
name|info
operator|->
name|src
operator|/
name|i
expr_stmt|;
name|info
operator|->
name|z_gy
operator|=
name|info
operator|->
name|dst
operator|/
name|i
expr_stmt|;
comment|/* Too big, or too small. Bail out. */
if|if
condition|(
operator|!
operator|(
name|Z_FACTOR_SAFE
argument_list|(
name|info
operator|->
name|z_gx
argument_list|)
operator|&&
name|Z_FACTOR_SAFE
argument_list|(
name|info
operator|->
name|z_gy
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|format
operator|=
name|f
operator|->
name|desc
operator|->
name|in
expr_stmt|;
name|adaptive
operator|=
literal|0
expr_stmt|;
name|z_scale
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Setup everything: filter length, conversion factor, etc. 	 */
if|if
condition|(
name|Z_IS_SINC
argument_list|(
name|info
argument_list|)
condition|)
block|{
comment|/* 		 * Downsampling, or upsampling scaling factor. As long as the 		 * factor can be represented by a fraction of 1<< Z_SHIFT, 		 * we're pretty much in business. Scaling is not needed for 		 * upsampling, so we just slap Z_ONE there. 		 */
if|if
condition|(
name|info
operator|->
name|z_gx
operator|>
name|info
operator|->
name|z_gy
condition|)
comment|/* 			 * If the downsampling ratio is beyond sanity, 			 * enable semi-adaptive mode. Although handling 			 * extreme ratio is possible, the result of the 			 * conversion is just pointless, unworthy, 			 * nonsensical noises, etc. 			 */
if|if
condition|(
operator|(
name|info
operator|->
name|z_gx
operator|/
name|info
operator|->
name|z_gy
operator|)
operator|>
name|Z_SINC_DOWNMAX
condition|)
name|z_scale
operator|=
name|Z_ONE
operator|/
name|Z_SINC_DOWNMAX
expr_stmt|;
else|else
name|z_scale
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|info
operator|->
name|z_gy
operator|<<
name|Z_SHIFT
operator|)
operator|/
name|info
operator|->
name|z_gx
expr_stmt|;
else|else
name|z_scale
operator|=
name|Z_ONE
expr_stmt|;
comment|/* 		 * This is actually impossible, unless anything above 		 * overflow. 		 */
if|if
condition|(
name|z_scale
operator|<
literal|1
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
comment|/* 		 * Calculate sample time/coefficients index drift. It is 		 * a constant for upsampling, but downsampling require 		 * heavy duty filtering with possible too long filters. 		 * If anything goes wrong, revisit again and enable 		 * adaptive mode. 		 */
name|z_setup_adaptive_sinc
label|:
if|if
condition|(
name|info
operator|->
name|z_pcoeff
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|info
operator|->
name|z_pcoeff
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|info
operator|->
name|z_pcoeff
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|adaptive
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|z_dy
operator|=
name|z_scale
operator|<<
name|Z_DRIFT_SHIFT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|z_dy
operator|<
literal|1
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
name|info
operator|->
name|z_scale
operator|=
name|z_scale
expr_stmt|;
block|}
else|else
block|{
name|info
operator|->
name|z_dy
operator|=
name|Z_FULL_ONE
expr_stmt|;
name|info
operator|->
name|z_scale
operator|=
name|Z_ONE
expr_stmt|;
block|}
if|#
directive|if
literal|0
define|#
directive|define
name|Z_SCALE_DIV
value|10000
define|#
directive|define
name|Z_SCALE_LIMIT
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|)
define|\
value|((((uint64_t)(s) * (v)) + (Z_SCALE_DIV>> 1)) / Z_SCALE_DIV)
block|info->z_scale = Z_SCALE_LIMIT(info->z_scale, 9780);
endif|#
directive|endif
comment|/* Smallest drift increment. */
name|info
operator|->
name|z_dx
operator|=
name|info
operator|->
name|z_dy
operator|/
name|info
operator|->
name|z_gy
expr_stmt|;
comment|/* 		 * Overflow or underflow. Try adaptive, let it continue and 		 * retry. 		 */
if|if
condition|(
name|info
operator|->
name|z_dx
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|adaptive
operator|==
literal|0
condition|)
block|{
name|adaptive
operator|=
literal|1
expr_stmt|;
goto|goto
name|z_setup_adaptive_sinc
goto|;
block|}
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
comment|/* 		 * Round back output drift. 		 */
name|info
operator|->
name|z_dy
operator|=
name|info
operator|->
name|z_dx
operator|*
name|info
operator|->
name|z_gy
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Z_COEFF_TAB_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Z_SINC_COEFF_IDX
argument_list|(
name|info
argument_list|)
operator|!=
name|i
condition|)
continue|continue;
comment|/* 			 * Calculate required filter length and guard 			 * against possible abusive result. Note that 			 * this represents only 1/2 of the entire filter 			 * length. 			 */
name|info
operator|->
name|z_size
operator|=
name|z_resampler_sinc_len
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* 			 * Multiple of 2 rounding, for better accumulator 			 * performance. 			 */
name|info
operator|->
name|z_size
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|z_size
operator|<
literal|2
operator|||
name|info
operator|->
name|z_size
operator|>
name|Z_SINC_MAX
condition|)
block|{
if|if
condition|(
name|adaptive
operator|==
literal|0
condition|)
block|{
name|adaptive
operator|=
literal|1
expr_stmt|;
goto|goto
name|z_setup_adaptive_sinc
goto|;
block|}
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
name|info
operator|->
name|z_coeff
operator|=
name|z_coeff_tab
index|[
name|i
index|]
operator|.
name|coeff
operator|+
name|Z_COEFF_OFFSET
expr_stmt|;
name|info
operator|->
name|z_dcoeff
operator|=
name|z_coeff_tab
index|[
name|i
index|]
operator|.
name|dcoeff
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|info
operator|->
name|z_coeff
operator|==
name|NULL
operator|||
name|info
operator|->
name|z_dcoeff
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|Z_IS_LINEAR
argument_list|(
name|info
argument_list|)
condition|)
block|{
comment|/* 		 * Don't put much effort if we're doing linear interpolation. 		 * Just center the interpolation distance within Z_LINEAR_ONE, 		 * and be happy about it. 		 */
name|info
operator|->
name|z_dx
operator|=
name|Z_LINEAR_FULL_ONE
operator|/
name|info
operator|->
name|z_gy
expr_stmt|;
block|}
comment|/* 	 * We're safe for now, lets continue.. Look for our resampler 	 * depending on configured format and quality. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Z_RESAMPLER_TAB_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ridx
decl_stmt|;
if|if
condition|(
name|AFMT_ENCODING
argument_list|(
name|format
argument_list|)
operator|!=
name|z_resampler_tab
index|[
name|i
index|]
operator|.
name|format
condition|)
continue|continue;
if|if
condition|(
name|Z_IS_SINC
argument_list|(
name|info
argument_list|)
operator|&&
name|adaptive
operator|==
literal|0
operator|&&
name|z_resampler_build_polyphase
argument_list|(
name|info
argument_list|)
operator|==
literal|0
condition|)
name|ridx
operator|=
name|Z_RESAMPLER_SINC_POLYPHASE
expr_stmt|;
else|else
name|ridx
operator|=
name|Z_RESAMPLER_IDX
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|info
operator|->
name|z_resample
operator|=
name|z_resampler_tab
index|[
name|i
index|]
operator|.
name|resampler
index|[
name|ridx
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|info
operator|->
name|z_resample
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|info
operator|->
name|bps
operator|=
name|AFMT_BPS
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|align
operator|=
name|info
operator|->
name|channels
operator|*
name|info
operator|->
name|bps
expr_stmt|;
comment|/* 	 * Calculate largest value that can be fed into z_gy2gx() and 	 * z_gx2gy() without causing (signed) 32bit overflow. z_gy2gx() will 	 * be called early during feeding process to determine how much input 	 * samples that is required to generate requested output, while 	 * z_gx2gy() will be called just before samples filtering / 	 * accumulation process based on available samples that has been 	 * calculated using z_gx2gy(). 	 * 	 * Now that is damn confusing, I guess ;-) . 	 */
name|gy2gx_max
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|info
operator|->
name|z_gy
operator|*
name|INT32_MAX
operator|)
operator|-
name|info
operator|->
name|z_gy
operator|+
literal|1
operator|)
operator|/
name|info
operator|->
name|z_gx
expr_stmt|;
if|if
condition|(
operator|(
name|gy2gx_max
operator|*
name|align
operator|)
operator|>
name|SND_FXDIV_MAX
condition|)
name|gy2gx_max
operator|=
name|SND_FXDIV_MAX
operator|/
name|align
expr_stmt|;
if|if
condition|(
name|gy2gx_max
operator|<
literal|1
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
name|gx2gy_max
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|info
operator|->
name|z_gx
operator|*
name|INT32_MAX
operator|)
operator|-
name|info
operator|->
name|z_gy
operator|)
operator|/
name|info
operator|->
name|z_gy
expr_stmt|;
if|if
condition|(
name|gx2gy_max
operator|>
name|INT32_MAX
condition|)
name|gx2gy_max
operator|=
name|INT32_MAX
expr_stmt|;
if|if
condition|(
name|gx2gy_max
operator|<
literal|1
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
comment|/* 	 * Ensure that z_gy2gx() at its largest possible calculated value 	 * (alpha = 0) will not cause overflow further late during z_gx2gy() 	 * stage. 	 */
if|if
condition|(
name|z_gy2gx
argument_list|(
name|info
argument_list|,
name|gy2gx_max
argument_list|)
operator|>
name|_Z_GCAST
argument_list|(
name|gx2gy_max
argument_list|)
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
name|info
operator|->
name|z_maxfeed
operator|=
name|gy2gx_max
operator|*
name|align
expr_stmt|;
ifdef|#
directive|ifdef
name|Z_USE_ALPHADRIFT
name|info
operator|->
name|z_startdrift
operator|=
name|z_gy2gx
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|z_alphadrift
operator|=
name|z_drift
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|z_startdrift
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|z_gy2gx
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|z_full
operator|=
name|z_roundpow2
argument_list|(
operator|(
name|info
operator|->
name|z_size
operator|<<
literal|1
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Too big to be true, and overflowing left and right like mad .. 	 */
if|if
condition|(
operator|(
name|info
operator|->
name|z_full
operator|*
name|align
operator|)
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|adaptive
operator|==
literal|0
operator|&&
name|Z_IS_SINC
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|adaptive
operator|=
literal|1
expr_stmt|;
goto|goto
name|z_setup_adaptive_sinc
goto|;
block|}
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
comment|/* 	 * Increase full buffer size if its too small to reduce cyclic 	 * buffer shifting in main conversion/feeder loop. 	 */
while|while
condition|(
name|info
operator|->
name|z_full
operator|<
name|Z_RESERVOIR_MAX
operator|&&
operator|(
name|info
operator|->
name|z_full
operator|-
operator|(
name|info
operator|->
name|z_size
operator|<<
literal|1
operator|)
operator|)
operator|<
name|Z_RESERVOIR
condition|)
name|info
operator|->
name|z_full
operator|<<=
literal|1
expr_stmt|;
comment|/* Initialize buffer position. */
name|info
operator|->
name|z_mask
operator|=
name|info
operator|->
name|z_full
operator|-
literal|1
expr_stmt|;
name|info
operator|->
name|z_start
operator|=
name|z_prev
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|z_size
operator|<<
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|z_pos
operator|=
name|z_next
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|z_start
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate or reuse delay line buffer, whichever makes sense. 	 */
name|i
operator|=
name|info
operator|->
name|z_full
operator|*
name|align
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
if|if
condition|(
name|info
operator|->
name|z_delay
operator|==
name|NULL
operator|||
name|info
operator|->
name|z_alloc
operator|<
name|i
operator|||
name|i
operator|<=
operator|(
name|info
operator|->
name|z_alloc
operator|>>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|z_delay
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|info
operator|->
name|z_delay
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|info
operator|->
name|z_delay
operator|=
name|malloc
argument_list|(
name|i
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|z_delay
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|info
operator|->
name|z_alloc
operator|=
name|i
expr_stmt|;
block|}
comment|/* 	 * Zero out head of buffer to avoid pops and clicks. 	 */
name|memset
argument_list|(
name|info
operator|->
name|z_delay
argument_list|,
name|sndbuf_zerodata
argument_list|(
name|f
operator|->
name|desc
operator|->
name|out
argument_list|)
argument_list|,
name|info
operator|->
name|z_pos
operator|*
name|align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Z_DIAGNOSTIC
comment|/* 	 * XXX Debuging mess !@#$%^ 	 */
define|#
directive|define
name|dumpz
parameter_list|(
name|x
parameter_list|)
value|fprintf(stderr, "\t%12s = %10u : %-11d\n",	\ 			    "z_"__STRING(x), (uint32_t)info->z_##x,	\ 			    (int32_t)info->z_##x)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s():\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tchannels=%d, bps=%d, format=0x%08x, quality=%d\n"
argument_list|,
name|info
operator|->
name|channels
argument_list|,
name|info
operator|->
name|bps
argument_list|,
name|format
argument_list|,
name|info
operator|->
name|quality
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%d (%d) -> %d (%d), "
argument_list|,
name|info
operator|->
name|src
argument_list|,
name|info
operator|->
name|rsrc
argument_list|,
name|info
operator|->
name|dst
argument_list|,
name|info
operator|->
name|rdst
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%d/%d]\n"
argument_list|,
name|info
operator|->
name|z_gx
argument_list|,
name|info
operator|->
name|z_gy
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tminreq=%d, "
argument_list|,
name|z_gy2gx
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adaptive
operator|!=
literal|0
condition|)
name|z_scale
operator|=
name|Z_ONE
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"factor=0x%08x/0x%08x (%f)\n"
argument_list|,
name|z_scale
argument_list|,
name|Z_ONE
argument_list|,
operator|(
name|double
operator|)
name|z_scale
operator|/
name|Z_ONE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tbase_length=%d, "
argument_list|,
name|Z_SINC_BASE_LEN
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"adaptive=%s\n"
argument_list|,
operator|(
name|adaptive
operator|!=
literal|0
operator|)
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|)
expr_stmt|;
name|dumpz
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|dumpz
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|z_alloc
operator|<
literal|1024
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%15s%10d Bytes\n"
argument_list|,
literal|""
argument_list|,
name|info
operator|->
name|z_alloc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|z_alloc
operator|<
operator|(
literal|1024
operator|<<
literal|10
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%15s%10d KBytes\n"
argument_list|,
literal|""
argument_list|,
name|info
operator|->
name|z_alloc
operator|>>
literal|10
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|z_alloc
operator|<
operator|(
literal|1024
operator|<<
literal|20
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%15s%10d MBytes\n"
argument_list|,
literal|""
argument_list|,
name|info
operator|->
name|z_alloc
operator|>>
literal|20
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%15s%10d GBytes\n"
argument_list|,
literal|""
argument_list|,
name|info
operator|->
name|z_alloc
operator|>>
literal|30
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%12s   %10d (min output samples)\n"
argument_list|,
literal|""
argument_list|,
operator|(
name|int32_t
operator|)
name|z_gx2gy
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|z_full
operator|-
operator|(
name|info
operator|->
name|z_size
operator|<<
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%12s   %10d (min allocated output samples)\n"
argument_list|,
literal|""
argument_list|,
operator|(
name|int32_t
operator|)
name|z_gx2gy
argument_list|(
name|info
argument_list|,
operator|(
name|info
operator|->
name|z_alloc
operator|/
name|align
operator|)
operator|-
operator|(
name|info
operator|->
name|z_size
operator|<<
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%12s = %10d\n"
argument_list|,
literal|"z_gy2gx()"
argument_list|,
operator|(
name|int32_t
operator|)
name|z_gy2gx
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%12s = %10d -> z_gy2gx() -> %d\n"
argument_list|,
literal|"Max"
argument_list|,
operator|(
name|int32_t
operator|)
name|gy2gx_max
argument_list|,
operator|(
name|int32_t
operator|)
name|z_gy2gx
argument_list|(
name|info
argument_list|,
name|gy2gx_max
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%12s = %10d\n"
argument_list|,
literal|"z_gx2gy()"
argument_list|,
operator|(
name|int32_t
operator|)
name|z_gx2gy
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%12s = %10d -> z_gx2gy() -> %d\n"
argument_list|,
literal|"Max"
argument_list|,
operator|(
name|int32_t
operator|)
name|gx2gy_max
argument_list|,
operator|(
name|int32_t
operator|)
name|z_gx2gy
argument_list|(
name|info
argument_list|,
name|gx2gy_max
argument_list|)
argument_list|)
expr_stmt|;
name|dumpz
argument_list|(
name|maxfeed
argument_list|)
expr_stmt|;
name|dumpz
argument_list|(
name|full
argument_list|)
expr_stmt|;
name|dumpz
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|dumpz
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|dumpz
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%12s   %10f\n"
argument_list|,
literal|""
argument_list|,
operator|(
name|double
operator|)
name|info
operator|->
name|z_scale
operator|/
name|Z_ONE
argument_list|)
expr_stmt|;
name|dumpz
argument_list|(
name|dx
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%12s   %10f\n"
argument_list|,
literal|""
argument_list|,
operator|(
name|double
operator|)
name|info
operator|->
name|z_dx
operator|/
name|info
operator|->
name|z_dy
argument_list|)
expr_stmt|;
name|dumpz
argument_list|(
name|dy
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%12s   %10d (drift step)\n"
argument_list|,
literal|""
argument_list|,
name|info
operator|->
name|z_dy
operator|>>
name|Z_SHIFT
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%12s   %10d (scaling differences)\n"
argument_list|,
literal|""
argument_list|,
operator|(
name|z_scale
operator|<<
name|Z_DRIFT_SHIFT
operator|)
operator|-
name|info
operator|->
name|z_dy
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%12s = %u bytes\n"
argument_list|,
literal|"intpcm32_t"
argument_list|,
sizeof|sizeof
argument_list|(
name|intpcm32_t
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%12s = 0x%08x, smallest=%.16lf\n"
argument_list|,
literal|"Z_ONE"
argument_list|,
name|Z_ONE
argument_list|,
operator|(
name|double
operator|)
literal|1.0
operator|/
operator|(
name|double
operator|)
name|Z_ONE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|z_resampler_set
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|,
name|int
name|what
parameter_list|,
name|int32_t
name|value
parameter_list|)
block|{
name|struct
name|z_info
modifier|*
name|info
decl_stmt|;
name|int32_t
name|oquality
decl_stmt|;
name|info
operator|=
name|f
operator|->
name|data
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|Z_RATE_SRC
case|:
if|if
condition|(
name|value
operator|<
name|feeder_rate_min
operator|||
name|value
operator|>
name|feeder_rate_max
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
if|if
condition|(
name|value
operator|==
name|info
operator|->
name|rsrc
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|info
operator|->
name|rsrc
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Z_RATE_DST
case|:
if|if
condition|(
name|value
operator|<
name|feeder_rate_min
operator|||
name|value
operator|>
name|feeder_rate_max
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
if|if
condition|(
name|value
operator|==
name|info
operator|->
name|rdst
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|info
operator|->
name|rdst
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|Z_RATE_QUALITY
case|:
if|if
condition|(
name|value
operator|<
name|Z_QUALITY_MIN
operator|||
name|value
operator|>
name|Z_QUALITY_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|value
operator|==
name|info
operator|->
name|quality
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * If we failed to set the requested quality, restore 		 * the old one. We cannot afford leaving it broken since 		 * passive feeder chains like vchans never reinitialize 		 * itself. 		 */
name|oquality
operator|=
name|info
operator|->
name|quality
expr_stmt|;
name|info
operator|->
name|quality
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|z_resampler_setup
argument_list|(
name|f
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|info
operator|->
name|quality
operator|=
name|oquality
expr_stmt|;
break|break;
case|case
name|Z_RATE_CHANNELS
case|:
if|if
condition|(
name|value
operator|<
name|SND_CHN_MIN
operator|||
name|value
operator|>
name|SND_CHN_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|value
operator|==
name|info
operator|->
name|channels
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|info
operator|->
name|channels
operator|=
name|value
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|z_resampler_setup
argument_list|(
name|f
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|z_resampler_get
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|,
name|int
name|what
parameter_list|)
block|{
name|struct
name|z_info
modifier|*
name|info
decl_stmt|;
name|info
operator|=
name|f
operator|->
name|data
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|Z_RATE_SRC
case|:
return|return
operator|(
name|info
operator|->
name|rsrc
operator|)
return|;
break|break;
case|case
name|Z_RATE_DST
case|:
return|return
operator|(
name|info
operator|->
name|rdst
operator|)
return|;
break|break;
case|case
name|Z_RATE_QUALITY
case|:
return|return
operator|(
name|info
operator|->
name|quality
operator|)
return|;
break|break;
case|case
name|Z_RATE_CHANNELS
case|:
return|return
operator|(
name|info
operator|->
name|channels
operator|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|z_resampler_init
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|z_info
modifier|*
name|info
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|desc
operator|->
name|in
operator|!=
name|f
operator|->
name|desc
operator|->
name|out
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|info
operator|->
name|rsrc
operator|=
name|Z_RATE_DEFAULT
expr_stmt|;
name|info
operator|->
name|rdst
operator|=
name|Z_RATE_DEFAULT
expr_stmt|;
name|info
operator|->
name|quality
operator|=
name|feeder_rate_quality
expr_stmt|;
name|info
operator|->
name|channels
operator|=
name|AFMT_CHANNEL
argument_list|(
name|f
operator|->
name|desc
operator|->
name|in
argument_list|)
expr_stmt|;
name|f
operator|->
name|data
operator|=
name|info
expr_stmt|;
name|ret
operator|=
name|z_resampler_setup
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|z_pcoeff
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|info
operator|->
name|z_pcoeff
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|z_delay
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|info
operator|->
name|z_delay
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|f
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|z_resampler_free
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|z_info
modifier|*
name|info
decl_stmt|;
name|info
operator|=
name|f
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|z_pcoeff
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|info
operator|->
name|z_pcoeff
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|z_delay
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|info
operator|->
name|z_delay
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|f
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|z_resampler_feed_internal
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|uint8_t
modifier|*
name|b
parameter_list|,
name|uint32_t
name|count
parameter_list|,
name|void
modifier|*
name|source
parameter_list|)
block|{
name|struct
name|z_info
modifier|*
name|info
decl_stmt|;
name|int32_t
name|alphadrift
decl_stmt|,
name|startdrift
decl_stmt|,
name|reqout
decl_stmt|,
name|ocount
decl_stmt|,
name|reqin
decl_stmt|,
name|align
decl_stmt|;
name|int32_t
name|fetch
decl_stmt|,
name|fetched
decl_stmt|,
name|start
decl_stmt|,
name|cp
decl_stmt|;
name|uint8_t
modifier|*
name|dst
decl_stmt|;
name|info
operator|=
name|f
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|z_resample
operator|==
name|NULL
condition|)
return|return
operator|(
name|z_feed
argument_list|(
name|f
operator|->
name|source
argument_list|,
name|c
argument_list|,
name|b
argument_list|,
name|count
argument_list|,
name|source
argument_list|)
operator|)
return|;
comment|/* 	 * Calculate sample size alignment and amount of sample output. 	 * We will do everything in sample domain, but at the end we 	 * will jump back to byte domain. 	 */
name|align
operator|=
name|info
operator|->
name|channels
operator|*
name|info
operator|->
name|bps
expr_stmt|;
name|ocount
operator|=
name|SND_FXDIV
argument_list|(
name|count
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocount
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Calculate amount of input samples that is needed to generate 	 * exact amount of output. 	 */
name|reqin
operator|=
name|z_gy2gx
argument_list|(
name|info
argument_list|,
name|ocount
argument_list|)
operator|-
name|z_fetched
argument_list|(
name|info
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Z_USE_ALPHADRIFT
name|startdrift
operator|=
name|info
operator|->
name|z_startdrift
expr_stmt|;
name|alphadrift
operator|=
name|info
operator|->
name|z_alphadrift
expr_stmt|;
else|#
directive|else
name|startdrift
operator|=
name|_Z_GY2GX
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|alphadrift
operator|=
name|z_drift
argument_list|(
name|info
argument_list|,
name|startdrift
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dst
operator|=
name|b
expr_stmt|;
do|do
block|{
if|if
condition|(
name|reqin
operator|!=
literal|0
condition|)
block|{
name|fetch
operator|=
name|z_min
argument_list|(
name|z_free
argument_list|(
name|info
argument_list|)
argument_list|,
name|reqin
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch
operator|==
literal|0
condition|)
block|{
comment|/* 				 * No more free spaces, so wind enough 				 * samples back to the head of delay line 				 * in byte domain. 				 */
name|fetched
operator|=
name|z_fetched
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|start
operator|=
name|z_prev
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|z_start
argument_list|,
operator|(
name|info
operator|->
name|z_size
operator|<<
literal|1
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|info
operator|->
name|z_size
operator|<<
literal|1
operator|)
operator|+
name|fetched
expr_stmt|;
name|z_copy
argument_list|(
name|info
operator|->
name|z_delay
operator|+
operator|(
name|start
operator|*
name|align
operator|)
argument_list|,
name|info
operator|->
name|z_delay
argument_list|,
name|cp
operator|*
name|align
argument_list|)
expr_stmt|;
name|info
operator|->
name|z_start
operator|=
name|z_prev
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|z_size
operator|<<
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|z_pos
operator|=
name|z_next
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|z_start
argument_list|,
name|fetched
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fetch
operator|=
name|z_min
argument_list|(
name|z_free
argument_list|(
name|info
argument_list|)
argument_list|,
name|reqin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Z_DIAGNOSTIC
if|if
condition|(
literal|1
condition|)
block|{
specifier|static
name|uint32_t
name|kk
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Buffer Move: "
literal|"start=%d fetched=%d cp=%d "
literal|"cycle=%u [%u]\r"
argument_list|,
name|start
argument_list|,
name|fetched
argument_list|,
name|cp
argument_list|,
name|info
operator|->
name|z_cycle
argument_list|,
operator|++
name|kk
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|z_cycle
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|fetch
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Fetch in byte domain and jump back 				 * to sample domain. 				 */
name|fetched
operator|=
name|SND_FXDIV
argument_list|(
name|z_feed
argument_list|(
name|f
operator|->
name|source
argument_list|,
name|c
argument_list|,
name|info
operator|->
name|z_delay
operator|+
operator|(
name|info
operator|->
name|z_pos
operator|*
name|align
operator|)
argument_list|,
name|fetch
operator|*
name|align
argument_list|,
name|source
argument_list|)
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* 				 * Prepare to convert fetched buffer, 				 * or mark us done if we cannot fulfill 				 * the request. 				 */
name|reqin
operator|-=
name|fetched
expr_stmt|;
name|info
operator|->
name|z_pos
operator|+=
name|fetched
expr_stmt|;
if|if
condition|(
name|fetched
operator|!=
name|fetch
condition|)
name|reqin
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|reqout
operator|=
name|z_min
argument_list|(
name|z_gx2gy
argument_list|(
name|info
argument_list|,
name|z_fetched
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|,
name|ocount
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqout
operator|!=
literal|0
condition|)
block|{
name|ocount
operator|-=
name|reqout
expr_stmt|;
comment|/* 			 * Drift.. drift.. drift.. 			 * 			 * Notice that there are 2 methods of doing the drift 			 * operations: The former is much cleaner (in a sense 			 * of mathematical readings of my eyes), but slower 			 * due to integer division in z_gy2gx(). Nevertheless, 			 * both should give the same exact accurate drifting 			 * results, so the later is favourable. 			 */
do|do
block|{
name|info
operator|->
name|z_resample
argument_list|(
name|info
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|startdrift = z_gy2gx(info, 1); 				alphadrift = z_drift(info, startdrift, 1); 				info->z_start += startdrift; 				info->z_alpha += alphadrift;
else|#
directive|else
name|info
operator|->
name|z_alpha
operator|+=
name|alphadrift
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|z_alpha
operator|<
name|info
operator|->
name|z_gy
condition|)
name|info
operator|->
name|z_start
operator|+=
name|startdrift
expr_stmt|;
else|else
block|{
name|info
operator|->
name|z_start
operator|+=
name|startdrift
operator|-
literal|1
expr_stmt|;
name|info
operator|->
name|z_alpha
operator|-=
name|info
operator|->
name|z_gy
expr_stmt|;
block|}
endif|#
directive|endif
name|dst
operator|+=
name|align
expr_stmt|;
ifdef|#
directive|ifdef
name|Z_DIAGNOSTIC
name|info
operator|->
name|z_cycle
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
operator|--
name|reqout
operator|!=
literal|0
condition|)
do|;
block|}
block|}
do|while
condition|(
name|reqin
operator|!=
literal|0
operator|&&
name|ocount
operator|!=
literal|0
condition|)
do|;
comment|/* 	 * Back to byte domain.. 	 */
return|return
operator|(
name|dst
operator|-
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|z_resampler_feed
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|uint8_t
modifier|*
name|b
parameter_list|,
name|uint32_t
name|count
parameter_list|,
name|void
modifier|*
name|source
parameter_list|)
block|{
name|uint32_t
name|feed
decl_stmt|,
name|maxfeed
decl_stmt|,
name|left
decl_stmt|;
comment|/* 	 * Split count to smaller chunks to avoid possible 32bit overflow. 	 */
name|maxfeed
operator|=
operator|(
operator|(
expr|struct
name|z_info
operator|*
operator|)
operator|(
name|f
operator|->
name|data
operator|)
operator|)
operator|->
name|z_maxfeed
expr_stmt|;
name|left
operator|=
name|count
expr_stmt|;
do|do
block|{
name|feed
operator|=
name|z_resampler_feed_internal
argument_list|(
name|f
argument_list|,
name|c
argument_list|,
name|b
argument_list|,
name|z_min
argument_list|(
name|maxfeed
argument_list|,
name|left
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|b
operator|+=
name|feed
expr_stmt|;
name|left
operator|-=
name|feed
expr_stmt|;
block|}
do|while
condition|(
name|left
operator|!=
literal|0
operator|&&
name|feed
operator|!=
literal|0
condition|)
do|;
return|return
operator|(
name|count
operator|-
name|left
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|pcm_feederdesc
name|feeder_rate_desc
index|[]
init|=
block|{
block|{
name|FEEDER_RATE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kobj_method_t
name|feeder_rate_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|feeder_init
argument_list|,
name|z_resampler_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|feeder_free
argument_list|,
name|z_resampler_free
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|feeder_set
argument_list|,
name|z_resampler_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|feeder_get
argument_list|,
name|z_resampler_get
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|feeder_feed
argument_list|,
name|z_resampler_feed
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|FEEDER_DECLARE
argument_list|(
name|feeder_rate
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

