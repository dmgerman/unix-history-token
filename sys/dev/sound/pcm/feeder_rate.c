begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Cameron Grant<cg@FreeBSD.org>  * Copyright (c) 2003 Orion Hodson<orion@FreeBSD.org>  * Copyright (c) 2005 Ariff Abdullah<ariff@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * 2005-06-11:  * ==========  *  * *New* and rewritten soft sample rate converter supporting arbitary sample  * rate, fine grained scalling/coefficients and unified up/down stereo  * converter. Most of disclaimers from orion's previous version also applied  * here, regarding with linear interpolation deficiencies, pre/post  * anti-aliasing filtering issues. This version comes with much simpler and  * tighter interface, although it works almost exactly like the older one.  *  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *                                                                         *  * This new implementation is fully dedicated in memory of Cameron Grant,  *  * the creator of magnificent, highly addictive feeder infrastructure.     *  *                                                                         *  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  * Orion's notes:  * =============  *  * This rate conversion code uses linear interpolation without any  * pre- or post- interpolation filtering to combat aliasing.  This  * greatly limits the sound quality and should be addressed at some  * stage in the future.  *   * Since this accuracy of interpolation is sensitive and examination  * of the algorithm output is harder from the kernel, th code is  * designed to be compiled in the kernel and in a userland test  * harness.  This is done by selectively including and excluding code  * with several portions based on whether _KERNEL is defined.  It's a  * little ugly, but exceedingly useful.  The testsuite and its  * revisions can be found at:  *		http://people.freebsd.org/~orion/files/feedrate/  *  * Special thanks to Ken Marx for exposing flaws in the code and for  * testing revisions.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|"feeder_if.h"
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|RATE_ASSERT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
end_define

begin_comment
comment|/* KASSERT(x,y) */
end_comment

begin_define
define|#
directive|define
name|RATE_TEST
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
end_define

begin_comment
comment|/* if (!(x)) printf y */
end_comment

begin_define
define|#
directive|define
name|RATE_TRACE
parameter_list|(
name|x
modifier|...
parameter_list|)
end_define

begin_comment
comment|/* printf(x) */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_RATEFEEDER
argument_list|,
literal|"ratefeed"
argument_list|,
literal|"pcm rate feeder"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|FEEDBUFSZ
value|8192
end_define

begin_define
define|#
directive|define
name|ROUNDHZ
value|25
end_define

begin_define
define|#
directive|define
name|RATEMIN
value|4000
end_define

begin_comment
comment|/* 8000 * 138 or 11025 * 100 . This is insane, indeed! */
end_comment

begin_define
define|#
directive|define
name|RATEMAX
value|1102500
end_define

begin_define
define|#
directive|define
name|MINGAIN
value|92
end_define

begin_define
define|#
directive|define
name|MAXGAIN
value|96
end_define

begin_define
define|#
directive|define
name|FEEDRATE_CONVERT_64
value|0
end_define

begin_define
define|#
directive|define
name|FEEDRATE_CONVERT_SCALE64
value|1
end_define

begin_define
define|#
directive|define
name|FEEDRATE_CONVERT_SCALE32
value|2
end_define

begin_define
define|#
directive|define
name|FEEDRATE_CONVERT_PLAIN
value|3
end_define

begin_define
define|#
directive|define
name|FEEDRATE_CONVERT_FIXED
value|4
end_define

begin_define
define|#
directive|define
name|FEEDRATE_CONVERT_OPTIMAL
value|5
end_define

begin_define
define|#
directive|define
name|FEEDRATE_CONVERT_WORST
value|6
end_define

begin_define
define|#
directive|define
name|FEEDRATE_64_MAXROLL
value|32
end_define

begin_define
define|#
directive|define
name|FEEDRATE_32_MAXROLL
value|16
end_define

begin_struct
struct|struct
name|feed_rate_info
block|{
name|uint32_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
comment|/* rounded source / destination rates */
name|uint32_t
name|rsrc
decl_stmt|,
name|rdst
decl_stmt|;
comment|/* original source / destination rates */
name|uint32_t
name|gx
decl_stmt|,
name|gy
decl_stmt|;
comment|/* interpolation / decimation ratio */
name|uint32_t
name|alpha
decl_stmt|;
comment|/* interpolation distance */
name|uint32_t
name|pos
decl_stmt|,
name|bpos
decl_stmt|;
comment|/* current sample / buffer positions */
name|uint32_t
name|bufsz
decl_stmt|;
comment|/* total buffer size */
name|int32_t
name|scale
decl_stmt|,
name|roll
decl_stmt|;
comment|/* scale / roll factor */
name|int16_t
modifier|*
name|buffer
decl_stmt|;
name|uint32_t
function_decl|(
modifier|*
name|convert
function_decl|)
parameter_list|(
name|struct
name|feed_rate_info
modifier|*
parameter_list|,
name|int16_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|uint32_t
name|feed_convert_64
parameter_list|(
name|struct
name|feed_rate_info
modifier|*
parameter_list|,
name|int16_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|feed_convert_scale64
parameter_list|(
name|struct
name|feed_rate_info
modifier|*
parameter_list|,
name|int16_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|feed_convert_scale32
parameter_list|(
name|struct
name|feed_rate_info
modifier|*
parameter_list|,
name|int16_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|feed_convert_plain
parameter_list|(
name|struct
name|feed_rate_info
modifier|*
parameter_list|,
name|int16_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|feeder_rate_ratemin
init|=
name|RATEMIN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|feeder_rate_ratemax
init|=
name|RATEMAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * See 'Feeder Scaling Type' below..  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|feeder_rate_scaling
init|=
name|FEEDRATE_CONVERT_OPTIMAL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|feeder_rate_buffersize
init|=
name|FEEDBUFSZ
operator|&
operator|~
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * sysctls.. I love sysctls..  */
end_comment

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.snd.feeder_rate_ratemin"
argument_list|,
operator|&
name|feeder_rate_ratemin
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.snd.feeder_rate_ratemax"
argument_list|,
operator|&
name|feeder_rate_ratemin
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.snd.feeder_rate_scaling"
argument_list|,
operator|&
name|feeder_rate_scaling
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.snd.feeder_rate_buffersize"
argument_list|,
operator|&
name|feeder_rate_buffersize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_hw_snd_feeder_rate_ratemin
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|feeder_rate_ratemin
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|1
operator|||
name|val
operator|>=
name|feeder_rate_ratemax
condition|)
name|err
operator|=
name|EINVAL
expr_stmt|;
else|else
name|feeder_rate_ratemin
operator|=
name|val
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|feeder_rate_ratemin
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_hw_snd_feeder_rate_ratemin
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_hw_snd_feeder_rate_ratemax
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|feeder_rate_ratemax
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<=
name|feeder_rate_ratemin
operator|||
name|val
operator|>
literal|0x7fffff
condition|)
name|err
operator|=
name|EINVAL
expr_stmt|;
else|else
name|feeder_rate_ratemax
operator|=
name|val
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|feeder_rate_ratemax
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_hw_snd_feeder_rate_ratemax
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_hw_snd_feeder_rate_scaling
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|feeder_rate_scaling
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* 	 *      Feeder Scaling Type 	 *      =================== 	 * 	 *	1. Plain 64bit (high precision) 	 *	2. 64bit scaling (high precision, CPU friendly, but can 	 *	   cause gain up/down). 	 *	3. 32bit scaling (somehow can cause hz roundup, gain 	 *	   up/down). 	 *	4. Plain copy (default if src == dst. Except if src == dst, 	 *	   this is the worst / silly conversion method!). 	 * 	 *	Sysctl options:- 	 * 	 *	0 - Plain 64bit - no fallback. 	 *	1 - 64bit scaling - no fallback. 	 *	2 - 32bit scaling - no fallback. 	 *	3 - Plain copy - no fallback. 	 *	4 - Fixed rate. Means that, choose optimal conversion method 	 *	    without causing hz roundup. 	 *	    32bit scaling (as long as hz roundup does not occur), 	 *	    64bit scaling, Plain 64bit. 	 *	5 - Optimal / CPU friendly (DEFAULT). 	 *	    32bit scaling, 64bit scaling, Plain 64bit 	 *	6 - Optimal to worst, no 64bit arithmetic involved. 	 *	    32bit scaling, Plain copy. 	 */
if|if
condition|(
name|val
operator|<
name|FEEDRATE_CONVERT_64
operator|||
name|val
operator|>
name|FEEDRATE_CONVERT_WORST
condition|)
name|err
operator|=
name|EINVAL
expr_stmt|;
else|else
name|feeder_rate_scaling
operator|=
name|val
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|feeder_rate_scaling
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_hw_snd_feeder_rate_scaling
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_hw_snd_feeder_rate_buffersize
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|feeder_rate_buffersize
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* 	 * Don't waste too much kernel space 	 */
if|if
condition|(
name|val
operator|<
literal|2
operator|||
name|val
operator|>
literal|65536
condition|)
name|err
operator|=
name|EINVAL
expr_stmt|;
else|else
name|feeder_rate_buffersize
operator|=
name|val
operator|&
operator|~
literal|1
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|feeder_rate_buffersize
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_hw_snd_feeder_rate_buffersize
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|feed_speed_ratio
parameter_list|(
name|uint32_t
name|x
parameter_list|,
name|uint32_t
name|y
parameter_list|,
name|uint32_t
modifier|*
name|gx
parameter_list|,
name|uint32_t
modifier|*
name|gy
parameter_list|)
block|{
name|uint32_t
name|w
decl_stmt|,
name|src
init|=
name|x
decl_stmt|,
name|dst
init|=
name|y
decl_stmt|;
while|while
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
name|w
operator|=
name|x
operator|%
name|y
expr_stmt|;
name|x
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|w
expr_stmt|;
block|}
operator|*
name|gx
operator|=
name|src
operator|/
name|x
expr_stmt|;
operator|*
name|gy
operator|=
name|dst
operator|/
name|x
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|feed_scale_roll
parameter_list|(
name|uint32_t
name|dst
parameter_list|,
name|int32_t
modifier|*
name|scale
parameter_list|,
name|int32_t
modifier|*
name|roll
parameter_list|,
name|int32_t
name|max
parameter_list|)
block|{
name|int64_t
name|k
decl_stmt|,
name|tscale
decl_stmt|;
name|int32_t
name|j
decl_stmt|,
name|troll
decl_stmt|;
operator|*
name|scale
operator|=
operator|*
name|roll
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|MAXGAIN
init|;
name|j
operator|>=
name|MINGAIN
condition|;
name|j
operator|-=
literal|3
control|)
block|{
for|for
control|(
name|troll
operator|=
literal|0
init|;
name|troll
operator|<
name|max
condition|;
name|troll
operator|++
control|)
block|{
name|tscale
operator|=
operator|(
literal|1
operator|<<
name|troll
operator|)
operator|/
name|dst
expr_stmt|;
name|k
operator|=
operator|(
name|tscale
operator|*
name|dst
operator|*
literal|100
operator|)
operator|>>
name|troll
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|j
operator|&&
name|k
operator|<=
literal|100
condition|)
block|{
operator|*
name|scale
operator|=
name|tscale
expr_stmt|;
operator|*
name|roll
operator|=
name|troll
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|feed_get_best_coef
parameter_list|(
name|uint32_t
modifier|*
name|src
parameter_list|,
name|uint32_t
modifier|*
name|dst
parameter_list|,
name|uint32_t
modifier|*
name|gx
parameter_list|,
name|uint32_t
modifier|*
name|gy
parameter_list|,
name|int32_t
modifier|*
name|scale
parameter_list|,
name|int32_t
modifier|*
name|roll
parameter_list|)
block|{
name|uint32_t
name|tsrc
decl_stmt|,
name|tdst
decl_stmt|,
name|sscale
decl_stmt|,
name|dscale
decl_stmt|;
name|int32_t
name|tscale
decl_stmt|,
name|troll
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|hzmin
decl_stmt|,
name|hzmax
decl_stmt|;
operator|*
name|scale
operator|=
operator|*
name|roll
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|hzmin
operator|=
operator|(
name|ROUNDHZ
operator|*
name|i
operator|)
operator|+
literal|1
expr_stmt|;
name|hzmax
operator|=
name|hzmin
operator|+
name|ROUNDHZ
expr_stmt|;
for|for
control|(
name|j
operator|=
name|hzmin
init|;
name|j
operator|<
name|hzmax
condition|;
name|j
operator|++
control|)
block|{
name|tsrc
operator|=
operator|*
name|src
operator|-
operator|(
operator|*
name|src
operator|%
name|j
operator|)
expr_stmt|;
name|tdst
operator|=
operator|*
name|dst
expr_stmt|;
if|if
condition|(
name|tsrc
operator|<
literal|1
operator|||
name|tdst
operator|<
literal|1
condition|)
goto|goto
name|coef_failed
goto|;
name|feed_speed_ratio
argument_list|(
name|tsrc
argument_list|,
name|tdst
argument_list|,
operator|&
name|sscale
argument_list|,
operator|&
name|dscale
argument_list|)
expr_stmt|;
name|feed_scale_roll
argument_list|(
name|dscale
argument_list|,
operator|&
name|tscale
argument_list|,
operator|&
name|troll
argument_list|,
name|FEEDRATE_32_MAXROLL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tscale
operator|!=
operator|-
literal|1
operator|&&
name|troll
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|src
operator|=
name|tsrc
expr_stmt|;
operator|*
name|gx
operator|=
name|sscale
expr_stmt|;
operator|*
name|gy
operator|=
name|dscale
expr_stmt|;
operator|*
name|scale
operator|=
name|tscale
expr_stmt|;
operator|*
name|roll
operator|=
name|troll
expr_stmt|;
return|return
name|j
return|;
block|}
block|}
for|for
control|(
name|j
operator|=
name|hzmin
init|;
name|j
operator|<
name|hzmax
condition|;
name|j
operator|++
control|)
block|{
name|tsrc
operator|=
operator|*
name|src
operator|-
operator|(
operator|*
name|src
operator|%
name|j
operator|)
expr_stmt|;
name|tdst
operator|=
operator|*
name|dst
operator|-
operator|(
operator|*
name|dst
operator|%
name|j
operator|)
expr_stmt|;
if|if
condition|(
name|tsrc
operator|<
literal|1
operator|||
name|tdst
operator|<
literal|1
condition|)
goto|goto
name|coef_failed
goto|;
name|feed_speed_ratio
argument_list|(
name|tsrc
argument_list|,
name|tdst
argument_list|,
operator|&
name|sscale
argument_list|,
operator|&
name|dscale
argument_list|)
expr_stmt|;
name|feed_scale_roll
argument_list|(
name|dscale
argument_list|,
operator|&
name|tscale
argument_list|,
operator|&
name|troll
argument_list|,
name|FEEDRATE_32_MAXROLL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tscale
operator|!=
operator|-
literal|1
operator|&&
name|troll
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|src
operator|=
name|tsrc
expr_stmt|;
operator|*
name|dst
operator|=
name|tdst
expr_stmt|;
operator|*
name|gx
operator|=
name|sscale
expr_stmt|;
operator|*
name|gy
operator|=
name|dscale
expr_stmt|;
operator|*
name|scale
operator|=
name|tscale
expr_stmt|;
operator|*
name|roll
operator|=
name|troll
expr_stmt|;
return|return
name|j
return|;
block|}
block|}
for|for
control|(
name|j
operator|=
name|hzmin
init|;
name|j
operator|<
name|hzmax
condition|;
name|j
operator|++
control|)
block|{
name|tsrc
operator|=
operator|*
name|src
expr_stmt|;
name|tdst
operator|=
operator|*
name|dst
operator|-
operator|(
operator|*
name|dst
operator|%
name|j
operator|)
expr_stmt|;
if|if
condition|(
name|tsrc
operator|<
literal|1
operator|||
name|tdst
operator|<
literal|1
condition|)
goto|goto
name|coef_failed
goto|;
name|feed_speed_ratio
argument_list|(
name|tsrc
argument_list|,
name|tdst
argument_list|,
operator|&
name|sscale
argument_list|,
operator|&
name|dscale
argument_list|)
expr_stmt|;
name|feed_scale_roll
argument_list|(
name|dscale
argument_list|,
operator|&
name|tscale
argument_list|,
operator|&
name|troll
argument_list|,
name|FEEDRATE_32_MAXROLL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tscale
operator|!=
operator|-
literal|1
operator|&&
name|troll
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|src
operator|=
name|tsrc
expr_stmt|;
operator|*
name|dst
operator|=
name|tdst
expr_stmt|;
operator|*
name|gx
operator|=
name|sscale
expr_stmt|;
operator|*
name|gy
operator|=
name|dscale
expr_stmt|;
operator|*
name|scale
operator|=
name|tscale
expr_stmt|;
operator|*
name|roll
operator|=
name|troll
expr_stmt|;
return|return
name|j
return|;
block|}
block|}
block|}
name|coef_failed
label|:
name|feed_speed_ratio
argument_list|(
operator|*
name|src
argument_list|,
operator|*
name|dst
argument_list|,
name|gx
argument_list|,
name|gy
argument_list|)
expr_stmt|;
name|feed_scale_roll
argument_list|(
operator|*
name|gy
argument_list|,
name|scale
argument_list|,
name|roll
argument_list|,
name|FEEDRATE_32_MAXROLL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|feed_rate_reset
parameter_list|(
name|struct
name|feed_rate_info
modifier|*
name|info
parameter_list|)
block|{
name|info
operator|->
name|scale
operator|=
operator|-
literal|1
expr_stmt|;
name|info
operator|->
name|roll
operator|=
operator|-
literal|1
expr_stmt|;
name|info
operator|->
name|src
operator|=
name|info
operator|->
name|rsrc
expr_stmt|;
name|info
operator|->
name|dst
operator|=
name|info
operator|->
name|rdst
expr_stmt|;
name|info
operator|->
name|gx
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|gy
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|feed_rate_setup
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|feed_rate_info
modifier|*
name|info
init|=
name|f
operator|->
name|data
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|info
operator|->
name|pos
operator|=
literal|2
expr_stmt|;
name|info
operator|->
name|bpos
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|alpha
operator|=
literal|0
expr_stmt|;
name|feed_rate_reset
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|src
operator|==
name|info
operator|->
name|dst
condition|)
block|{
comment|/* 		 * No conversion ever needed. Just do plain copy. 		 */
name|info
operator|->
name|convert
operator|=
name|feed_convert_plain
expr_stmt|;
name|info
operator|->
name|gx
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|gy
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|feeder_rate_scaling
condition|)
block|{
case|case
name|FEEDRATE_CONVERT_64
case|:
name|feed_speed_ratio
argument_list|(
name|info
operator|->
name|src
argument_list|,
name|info
operator|->
name|dst
argument_list|,
operator|&
name|info
operator|->
name|gx
argument_list|,
operator|&
name|info
operator|->
name|gy
argument_list|)
expr_stmt|;
name|info
operator|->
name|convert
operator|=
name|feed_convert_64
expr_stmt|;
break|break;
case|case
name|FEEDRATE_CONVERT_SCALE64
case|:
name|feed_speed_ratio
argument_list|(
name|info
operator|->
name|src
argument_list|,
name|info
operator|->
name|dst
argument_list|,
operator|&
name|info
operator|->
name|gx
argument_list|,
operator|&
name|info
operator|->
name|gy
argument_list|)
expr_stmt|;
name|feed_scale_roll
argument_list|(
name|info
operator|->
name|gy
argument_list|,
operator|&
name|info
operator|->
name|scale
argument_list|,
operator|&
name|info
operator|->
name|roll
argument_list|,
name|FEEDRATE_64_MAXROLL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|scale
operator|==
operator|-
literal|1
operator|||
name|info
operator|->
name|roll
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|info
operator|->
name|convert
operator|=
name|feed_convert_scale64
expr_stmt|;
break|break;
case|case
name|FEEDRATE_CONVERT_SCALE32
case|:
name|r
operator|=
name|feed_get_best_coef
argument_list|(
operator|&
name|info
operator|->
name|src
argument_list|,
operator|&
name|info
operator|->
name|dst
argument_list|,
operator|&
name|info
operator|->
name|gx
argument_list|,
operator|&
name|info
operator|->
name|gy
argument_list|,
operator|&
name|info
operator|->
name|scale
argument_list|,
operator|&
name|info
operator|->
name|roll
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|info
operator|->
name|convert
operator|=
name|feed_convert_scale32
expr_stmt|;
break|break;
case|case
name|FEEDRATE_CONVERT_PLAIN
case|:
name|feed_speed_ratio
argument_list|(
name|info
operator|->
name|src
argument_list|,
name|info
operator|->
name|dst
argument_list|,
operator|&
name|info
operator|->
name|gx
argument_list|,
operator|&
name|info
operator|->
name|gy
argument_list|)
expr_stmt|;
name|info
operator|->
name|convert
operator|=
name|feed_convert_plain
expr_stmt|;
break|break;
case|case
name|FEEDRATE_CONVERT_FIXED
case|:
name|r
operator|=
name|feed_get_best_coef
argument_list|(
operator|&
name|info
operator|->
name|src
argument_list|,
operator|&
name|info
operator|->
name|dst
argument_list|,
operator|&
name|info
operator|->
name|gx
argument_list|,
operator|&
name|info
operator|->
name|gy
argument_list|,
operator|&
name|info
operator|->
name|scale
argument_list|,
operator|&
name|info
operator|->
name|roll
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
operator|&&
name|info
operator|->
name|src
operator|==
name|info
operator|->
name|rsrc
operator|&&
name|info
operator|->
name|dst
operator|==
name|info
operator|->
name|rdst
condition|)
name|info
operator|->
name|convert
operator|=
name|feed_convert_scale32
expr_stmt|;
else|else
block|{
comment|/* Fallback */
name|feed_rate_reset
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|feed_speed_ratio
argument_list|(
name|info
operator|->
name|src
argument_list|,
name|info
operator|->
name|dst
argument_list|,
operator|&
name|info
operator|->
name|gx
argument_list|,
operator|&
name|info
operator|->
name|gy
argument_list|)
expr_stmt|;
name|feed_scale_roll
argument_list|(
name|info
operator|->
name|gy
argument_list|,
operator|&
name|info
operator|->
name|scale
argument_list|,
operator|&
name|info
operator|->
name|roll
argument_list|,
name|FEEDRATE_64_MAXROLL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|scale
operator|!=
operator|-
literal|1
operator|&&
name|info
operator|->
name|roll
operator|!=
operator|-
literal|1
condition|)
name|info
operator|->
name|convert
operator|=
name|feed_convert_scale64
expr_stmt|;
else|else
name|info
operator|->
name|convert
operator|=
name|feed_convert_64
expr_stmt|;
block|}
break|break;
case|case
name|FEEDRATE_CONVERT_OPTIMAL
case|:
name|r
operator|=
name|feed_get_best_coef
argument_list|(
operator|&
name|info
operator|->
name|src
argument_list|,
operator|&
name|info
operator|->
name|dst
argument_list|,
operator|&
name|info
operator|->
name|gx
argument_list|,
operator|&
name|info
operator|->
name|gy
argument_list|,
operator|&
name|info
operator|->
name|scale
argument_list|,
operator|&
name|info
operator|->
name|roll
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|info
operator|->
name|convert
operator|=
name|feed_convert_scale32
expr_stmt|;
else|else
block|{
comment|/* Fallback */
name|feed_rate_reset
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|feed_speed_ratio
argument_list|(
name|info
operator|->
name|src
argument_list|,
name|info
operator|->
name|dst
argument_list|,
operator|&
name|info
operator|->
name|gx
argument_list|,
operator|&
name|info
operator|->
name|gy
argument_list|)
expr_stmt|;
name|feed_scale_roll
argument_list|(
name|info
operator|->
name|gy
argument_list|,
operator|&
name|info
operator|->
name|scale
argument_list|,
operator|&
name|info
operator|->
name|roll
argument_list|,
name|FEEDRATE_64_MAXROLL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|scale
operator|!=
operator|-
literal|1
operator|&&
name|info
operator|->
name|roll
operator|!=
operator|-
literal|1
condition|)
name|info
operator|->
name|convert
operator|=
name|feed_convert_scale64
expr_stmt|;
else|else
name|info
operator|->
name|convert
operator|=
name|feed_convert_64
expr_stmt|;
block|}
break|break;
case|case
name|FEEDRATE_CONVERT_WORST
case|:
name|r
operator|=
name|feed_get_best_coef
argument_list|(
operator|&
name|info
operator|->
name|src
argument_list|,
operator|&
name|info
operator|->
name|dst
argument_list|,
operator|&
name|info
operator|->
name|gx
argument_list|,
operator|&
name|info
operator|->
name|gy
argument_list|,
operator|&
name|info
operator|->
name|scale
argument_list|,
operator|&
name|info
operator|->
name|roll
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|info
operator|->
name|convert
operator|=
name|feed_convert_scale32
expr_stmt|;
else|else
block|{
comment|/* Fallback */
name|feed_rate_reset
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|feed_speed_ratio
argument_list|(
name|info
operator|->
name|src
argument_list|,
name|info
operator|->
name|dst
argument_list|,
operator|&
name|info
operator|->
name|gx
argument_list|,
operator|&
name|info
operator|->
name|gy
argument_list|)
expr_stmt|;
name|info
operator|->
name|convert
operator|=
name|feed_convert_plain
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|-
literal|1
return|;
break|break;
block|}
comment|/* No way! */
if|if
condition|(
name|info
operator|->
name|gx
operator|==
literal|0
operator|||
name|info
operator|->
name|gy
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 		 * No need to interpolate/decimate, just do plain copy. 		 * This probably caused by Hz roundup. 		 */
if|if
condition|(
name|info
operator|->
name|gx
operator|==
name|info
operator|->
name|gy
condition|)
name|info
operator|->
name|convert
operator|=
name|feed_convert_plain
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|feed_rate_set
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|,
name|int
name|what
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|struct
name|feed_rate_info
modifier|*
name|info
init|=
name|f
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|value
operator|<
name|feeder_rate_ratemin
operator|||
name|value
operator|>
name|feeder_rate_ratemax
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|FEEDRATE_SRC
case|:
name|info
operator|->
name|rsrc
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|FEEDRATE_DST
case|:
name|info
operator|->
name|rdst
operator|=
name|value
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
name|feed_rate_setup
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|feed_rate_get
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|,
name|int
name|what
parameter_list|)
block|{
name|struct
name|feed_rate_info
modifier|*
name|info
init|=
name|f
operator|->
name|data
decl_stmt|;
comment|/* 	 * Return *real* src/dst rate. 	 */
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|FEEDRATE_SRC
case|:
return|return
name|info
operator|->
name|rsrc
return|;
case|case
name|FEEDRATE_DST
case|:
return|return
name|info
operator|->
name|rdst
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|feed_rate_init
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|feed_rate_info
modifier|*
name|info
decl_stmt|;
name|info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|,
name|M_RATEFEEDER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
comment|/* 	 * bufsz = sample from last cycle + conversion space 	 */
name|info
operator|->
name|bufsz
operator|=
literal|2
operator|+
name|feeder_rate_buffersize
expr_stmt|;
name|info
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|info
operator|->
name|buffer
argument_list|)
operator|*
name|info
operator|->
name|bufsz
argument_list|,
name|M_RATEFEEDER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|info
argument_list|,
name|M_RATEFEEDER
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|info
operator|->
name|rsrc
operator|=
name|DSP_DEFAULT_SPEED
expr_stmt|;
name|info
operator|->
name|rdst
operator|=
name|DSP_DEFAULT_SPEED
expr_stmt|;
name|f
operator|->
name|data
operator|=
name|info
expr_stmt|;
return|return
name|feed_rate_setup
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|feed_rate_free
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|feed_rate_info
modifier|*
name|info
init|=
name|f
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|info
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|buffer
condition|)
name|free
argument_list|(
name|info
operator|->
name|buffer
argument_list|,
name|M_RATEFEEDER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|,
name|M_RATEFEEDER
argument_list|)
expr_stmt|;
block|}
name|f
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|feed_convert_64
parameter_list|(
name|struct
name|feed_rate_info
modifier|*
name|info
parameter_list|,
name|int16_t
modifier|*
name|dst
parameter_list|,
name|uint32_t
name|max
parameter_list|)
block|{
name|int64_t
name|x
decl_stmt|,
name|alpha
decl_stmt|,
name|distance
decl_stmt|;
name|uint32_t
name|ret
decl_stmt|;
name|int32_t
name|pos
decl_stmt|,
name|bpos
decl_stmt|,
name|gx
decl_stmt|,
name|gy
decl_stmt|;
name|int16_t
modifier|*
name|src
decl_stmt|;
comment|/* 	 * Plain, straight forward 64bit arith. No bit-magic applied here. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
name|alpha
operator|=
name|info
operator|->
name|alpha
expr_stmt|;
name|gx
operator|=
name|info
operator|->
name|gx
expr_stmt|;
name|gy
operator|=
name|info
operator|->
name|gy
expr_stmt|;
name|pos
operator|=
name|info
operator|->
name|pos
expr_stmt|;
name|bpos
operator|=
name|info
operator|->
name|bpos
expr_stmt|;
name|src
operator|=
name|info
operator|->
name|buffer
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|alpha
operator|<
name|gx
condition|)
block|{
name|alpha
operator|+=
name|gy
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|bpos
condition|)
break|break;
block|}
else|else
block|{
name|alpha
operator|-=
name|gx
expr_stmt|;
name|distance
operator|=
name|gy
operator|-
name|alpha
expr_stmt|;
name|x
operator|=
operator|(
name|alpha
operator|*
name|src
index|[
name|pos
operator|-
literal|2
index|]
operator|)
operator|+
operator|(
name|distance
operator|*
name|src
index|[
name|pos
index|]
operator|)
expr_stmt|;
name|dst
index|[
name|ret
operator|++
index|]
operator|=
name|x
operator|/
name|gy
expr_stmt|;
name|x
operator|=
operator|(
name|alpha
operator|*
name|src
index|[
name|pos
operator|-
literal|1
index|]
operator|)
operator|+
operator|(
name|distance
operator|*
name|src
index|[
name|pos
operator|+
literal|1
index|]
operator|)
expr_stmt|;
name|dst
index|[
name|ret
operator|++
index|]
operator|=
name|x
operator|/
name|gy
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|max
condition|)
break|break;
block|}
block|}
name|info
operator|->
name|alpha
operator|=
name|alpha
expr_stmt|;
name|info
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|feed_convert_scale64
parameter_list|(
name|struct
name|feed_rate_info
modifier|*
name|info
parameter_list|,
name|int16_t
modifier|*
name|dst
parameter_list|,
name|uint32_t
name|max
parameter_list|)
block|{
name|int64_t
name|x
decl_stmt|,
name|alpha
decl_stmt|,
name|distance
decl_stmt|;
name|uint32_t
name|ret
decl_stmt|;
name|int32_t
name|pos
decl_stmt|,
name|bpos
decl_stmt|,
name|gx
decl_stmt|,
name|gy
decl_stmt|,
name|roll
decl_stmt|;
name|int16_t
modifier|*
name|src
decl_stmt|;
comment|/* 	 * 64bit scaling. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
name|roll
operator|=
name|info
operator|->
name|roll
expr_stmt|;
name|alpha
operator|=
name|info
operator|->
name|alpha
operator|*
name|info
operator|->
name|scale
expr_stmt|;
name|gx
operator|=
name|info
operator|->
name|gx
operator|*
name|info
operator|->
name|scale
expr_stmt|;
name|gy
operator|=
name|info
operator|->
name|gy
operator|*
name|info
operator|->
name|scale
expr_stmt|;
name|pos
operator|=
name|info
operator|->
name|pos
expr_stmt|;
name|bpos
operator|=
name|info
operator|->
name|bpos
expr_stmt|;
name|src
operator|=
name|info
operator|->
name|buffer
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|alpha
operator|<
name|gx
condition|)
block|{
name|alpha
operator|+=
name|gy
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|bpos
condition|)
break|break;
block|}
else|else
block|{
name|alpha
operator|-=
name|gx
expr_stmt|;
name|distance
operator|=
name|gy
operator|-
name|alpha
expr_stmt|;
name|x
operator|=
operator|(
name|alpha
operator|*
name|src
index|[
name|pos
operator|-
literal|2
index|]
operator|)
operator|+
operator|(
name|distance
operator|*
name|src
index|[
name|pos
index|]
operator|)
expr_stmt|;
name|dst
index|[
name|ret
operator|++
index|]
operator|=
name|x
operator|>>
name|roll
expr_stmt|;
name|x
operator|=
operator|(
name|alpha
operator|*
name|src
index|[
name|pos
operator|-
literal|1
index|]
operator|)
operator|+
operator|(
name|distance
operator|*
name|src
index|[
name|pos
operator|+
literal|1
index|]
operator|)
expr_stmt|;
name|dst
index|[
name|ret
operator|++
index|]
operator|=
name|x
operator|>>
name|roll
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|max
condition|)
break|break;
block|}
block|}
name|info
operator|->
name|alpha
operator|=
name|alpha
operator|/
name|info
operator|->
name|scale
expr_stmt|;
name|info
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|feed_convert_scale32
parameter_list|(
name|struct
name|feed_rate_info
modifier|*
name|info
parameter_list|,
name|int16_t
modifier|*
name|dst
parameter_list|,
name|uint32_t
name|max
parameter_list|)
block|{
name|uint32_t
name|ret
decl_stmt|;
name|int32_t
name|x
decl_stmt|,
name|pos
decl_stmt|,
name|bpos
decl_stmt|,
name|gx
decl_stmt|,
name|gy
decl_stmt|,
name|alpha
decl_stmt|,
name|roll
decl_stmt|,
name|distance
decl_stmt|;
name|int16_t
modifier|*
name|src
decl_stmt|;
comment|/* 	 * 32bit scaling. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
name|roll
operator|=
name|info
operator|->
name|roll
expr_stmt|;
name|alpha
operator|=
name|info
operator|->
name|alpha
operator|*
name|info
operator|->
name|scale
expr_stmt|;
name|gx
operator|=
name|info
operator|->
name|gx
operator|*
name|info
operator|->
name|scale
expr_stmt|;
name|gy
operator|=
name|info
operator|->
name|gy
operator|*
name|info
operator|->
name|scale
expr_stmt|;
name|pos
operator|=
name|info
operator|->
name|pos
expr_stmt|;
name|bpos
operator|=
name|info
operator|->
name|bpos
expr_stmt|;
name|src
operator|=
name|info
operator|->
name|buffer
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|alpha
operator|<
name|gx
condition|)
block|{
name|alpha
operator|+=
name|gy
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|bpos
condition|)
break|break;
block|}
else|else
block|{
name|alpha
operator|-=
name|gx
expr_stmt|;
name|distance
operator|=
name|gy
operator|-
name|alpha
expr_stmt|;
name|x
operator|=
operator|(
name|alpha
operator|*
name|src
index|[
name|pos
operator|-
literal|2
index|]
operator|)
operator|+
operator|(
name|distance
operator|*
name|src
index|[
name|pos
index|]
operator|)
expr_stmt|;
name|dst
index|[
name|ret
operator|++
index|]
operator|=
name|x
operator|>>
name|roll
expr_stmt|;
name|x
operator|=
operator|(
name|alpha
operator|*
name|src
index|[
name|pos
operator|-
literal|1
index|]
operator|)
operator|+
operator|(
name|distance
operator|*
name|src
index|[
name|pos
operator|+
literal|1
index|]
operator|)
expr_stmt|;
name|dst
index|[
name|ret
operator|++
index|]
operator|=
name|x
operator|>>
name|roll
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|max
condition|)
break|break;
block|}
block|}
name|info
operator|->
name|alpha
operator|=
name|alpha
operator|/
name|info
operator|->
name|scale
expr_stmt|;
name|info
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|feed_convert_plain
parameter_list|(
name|struct
name|feed_rate_info
modifier|*
name|info
parameter_list|,
name|int16_t
modifier|*
name|dst
parameter_list|,
name|uint32_t
name|max
parameter_list|)
block|{
name|uint32_t
name|ret
decl_stmt|;
name|int32_t
name|pos
decl_stmt|,
name|bpos
decl_stmt|,
name|gx
decl_stmt|,
name|gy
decl_stmt|,
name|alpha
decl_stmt|;
name|int16_t
modifier|*
name|src
decl_stmt|;
comment|/* 	 * Plain copy. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
name|gx
operator|=
name|info
operator|->
name|gx
expr_stmt|;
name|gy
operator|=
name|info
operator|->
name|gy
expr_stmt|;
name|alpha
operator|=
name|info
operator|->
name|alpha
expr_stmt|;
name|pos
operator|=
name|info
operator|->
name|pos
expr_stmt|;
name|bpos
operator|=
name|info
operator|->
name|bpos
expr_stmt|;
name|src
operator|=
name|info
operator|->
name|buffer
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|alpha
operator|<
name|gx
condition|)
block|{
name|alpha
operator|+=
name|gy
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|bpos
condition|)
break|break;
block|}
else|else
block|{
name|alpha
operator|-=
name|gx
expr_stmt|;
name|dst
index|[
name|ret
operator|++
index|]
operator|=
name|src
index|[
name|pos
index|]
expr_stmt|;
name|dst
index|[
name|ret
operator|++
index|]
operator|=
name|src
index|[
name|pos
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|max
condition|)
break|break;
block|}
block|}
name|info
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
name|info
operator|->
name|alpha
operator|=
name|alpha
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|feed_rate
parameter_list|(
name|struct
name|pcm_feeder
modifier|*
name|f
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|uint8_t
modifier|*
name|b
parameter_list|,
name|uint32_t
name|count
parameter_list|,
name|void
modifier|*
name|source
parameter_list|)
block|{
name|struct
name|feed_rate_info
modifier|*
name|info
init|=
name|f
operator|->
name|data
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|int32_t
name|fetch
decl_stmt|,
name|slot
decl_stmt|;
name|int16_t
modifier|*
name|dst
init|=
operator|(
name|int16_t
operator|*
operator|)
name|b
decl_stmt|;
comment|/* 	 * This loop has been optimized to generalize both up / down 	 * sampling without causing missing samples or excessive buffer 	 * feeding. 	 */
name|RATE_TEST
argument_list|(
name|count
operator|>=
literal|4
operator|&&
operator|(
name|count
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Count size not byte integral (%d)\n"
operator|,
name|__func__
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|4
condition|)
return|return
literal|0
return|;
name|count
operator|>>=
literal|1
expr_stmt|;
name|count
operator|&=
operator|~
literal|1
expr_stmt|;
name|slot
operator|=
operator|(
operator|(
operator|(
name|info
operator|->
name|gx
operator|*
operator|(
name|count
operator|>>
literal|1
operator|)
operator|)
operator|+
name|info
operator|->
name|gy
operator|-
name|info
operator|->
name|alpha
operator|-
literal|1
operator|)
operator|/
name|info
operator|->
name|gy
operator|)
operator|<<
literal|1
expr_stmt|;
name|RATE_TEST
argument_list|(
operator|(
name|slot
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Slot count not sample integral (%d)\n"
operator|,
name|__func__
operator|,
name|slot
operator|)
argument_list|)
expr_stmt|;
name|slot
operator|&=
operator|~
literal|1
expr_stmt|;
comment|/* 	 * Optimize buffer feeding aggresively to ensure calculated slot 	 * can be fitted nicely into available buffer free space, hence 	 * avoiding multiple feeding. 	 */
if|if
condition|(
name|info
operator|->
name|pos
operator|!=
literal|2
operator|&&
name|info
operator|->
name|bpos
operator|-
name|info
operator|->
name|pos
operator|==
literal|2
operator|&&
name|info
operator|->
name|bpos
operator|+
name|slot
operator|>
name|info
operator|->
name|bufsz
condition|)
block|{
comment|/* 		 * Copy last unit sample and its previous to 		 * beginning of buffer. 		 */
name|info
operator|->
name|buffer
index|[
literal|0
index|]
operator|=
name|info
operator|->
name|buffer
index|[
name|info
operator|->
name|pos
operator|-
literal|2
index|]
expr_stmt|;
name|info
operator|->
name|buffer
index|[
literal|1
index|]
operator|=
name|info
operator|->
name|buffer
index|[
name|info
operator|->
name|pos
operator|-
literal|1
index|]
expr_stmt|;
name|info
operator|->
name|buffer
index|[
literal|2
index|]
operator|=
name|info
operator|->
name|buffer
index|[
name|info
operator|->
name|pos
index|]
expr_stmt|;
name|info
operator|->
name|buffer
index|[
literal|3
index|]
operator|=
name|info
operator|->
name|buffer
index|[
name|info
operator|->
name|pos
operator|+
literal|1
index|]
expr_stmt|;
name|info
operator|->
name|pos
operator|=
literal|2
expr_stmt|;
name|info
operator|->
name|bpos
operator|=
literal|4
expr_stmt|;
block|}
name|RATE_ASSERT
argument_list|(
name|slot
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: Negative Slot: %d\n"
operator|,
name|__func__
operator|,
name|slot
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|fetch
operator|=
name|info
operator|->
name|bufsz
operator|-
name|info
operator|->
name|bpos
expr_stmt|;
name|RATE_ASSERT
argument_list|(
name|fetch
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: [1] Buffer overrun: %d> %d\n"
operator|,
name|__func__
operator|,
name|info
operator|->
name|bpos
operator|,
name|info
operator|->
name|bufsz
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|<
name|fetch
condition|)
name|fetch
operator|=
name|slot
expr_stmt|;
name|fetch
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|fetch
operator|>
literal|0
condition|)
block|{
name|RATE_TEST
argument_list|(
operator|(
name|fetch
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Fetch size not sample integral (%d)\n"
operator|,
name|__func__
operator|,
name|fetch
operator|)
argument_list|)
expr_stmt|;
name|fetch
operator|=
name|FEEDER_FEED
argument_list|(
name|f
operator|->
name|source
argument_list|,
name|c
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|info
operator|->
name|buffer
operator|+
name|info
operator|->
name|bpos
operator|)
argument_list|,
name|fetch
operator|<<
literal|1
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch
operator|==
literal|0
condition|)
break|break;
name|RATE_TEST
argument_list|(
operator|(
name|fetch
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Fetch size not byte integral (%d)\n"
operator|,
name|__func__
operator|,
name|fetch
operator|)
argument_list|)
expr_stmt|;
name|fetch
operator|>>=
literal|1
expr_stmt|;
name|fetch
operator|&=
operator|~
literal|1
expr_stmt|;
name|info
operator|->
name|bpos
operator|+=
name|fetch
expr_stmt|;
name|slot
operator|-=
name|fetch
expr_stmt|;
name|RATE_ASSERT
argument_list|(
name|slot
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: Negative Slot: %d\n"
operator|,
name|__func__
operator|,
name|slot
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|info
operator|->
name|bpos
operator|==
name|info
operator|->
name|bufsz
condition|)
break|break;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|info
operator|->
name|pos
operator|==
name|info
operator|->
name|bpos
condition|)
block|{
name|RATE_TEST
argument_list|(
name|info
operator|->
name|pos
operator|==
literal|2
argument_list|,
operator|(
literal|"%s: EOF while in progress\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|RATE_ASSERT
argument_list|(
name|info
operator|->
name|pos
operator|<=
name|info
operator|->
name|bpos
argument_list|,
operator|(
literal|"%s: [2] Buffer overrun: %d> %d\n"
operator|,
name|__func__
operator|,
name|info
operator|->
name|pos
operator|,
name|info
operator|->
name|bpos
operator|)
argument_list|)
expr_stmt|;
name|RATE_ASSERT
argument_list|(
name|info
operator|->
name|pos
operator|<
name|info
operator|->
name|bpos
argument_list|,
operator|(
literal|"%s: Zero buffer!\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|RATE_ASSERT
argument_list|(
operator|(
operator|(
name|info
operator|->
name|bpos
operator|-
name|info
operator|->
name|pos
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Buffer not sample integral (%d)\n"
operator|,
name|__func__
operator|,
name|info
operator|->
name|bpos
operator|-
name|info
operator|->
name|pos
operator|)
argument_list|)
expr_stmt|;
name|i
operator|+=
name|info
operator|->
name|convert
argument_list|(
name|info
argument_list|,
name|dst
operator|+
name|i
argument_list|,
name|count
operator|-
name|i
argument_list|)
expr_stmt|;
name|RATE_ASSERT
argument_list|(
name|info
operator|->
name|pos
operator|<=
name|info
operator|->
name|bpos
argument_list|,
operator|(
literal|"%s: [3] Buffer overrun: %d> %d\n"
operator|,
name|__func__
operator|,
name|info
operator|->
name|pos
operator|,
name|info
operator|->
name|bpos
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|pos
operator|==
name|info
operator|->
name|bpos
condition|)
block|{
comment|/* 			 * End of buffer cycle. Copy last unit sample 			 * to beginning of buffer so next cycle can 			 * interpolate using it. 			 */
name|info
operator|->
name|buffer
index|[
literal|0
index|]
operator|=
name|info
operator|->
name|buffer
index|[
name|info
operator|->
name|pos
operator|-
literal|2
index|]
expr_stmt|;
name|info
operator|->
name|buffer
index|[
literal|1
index|]
operator|=
name|info
operator|->
name|buffer
index|[
name|info
operator|->
name|pos
operator|-
literal|1
index|]
expr_stmt|;
name|info
operator|->
name|bpos
operator|=
literal|2
expr_stmt|;
name|info
operator|->
name|pos
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|count
condition|)
break|break;
block|}
name|RATE_TEST
argument_list|(
name|count
operator|==
name|i
argument_list|,
operator|(
literal|"Expect: %u , Got: %u\n"
operator|,
name|count
operator|<<
literal|1
operator|,
name|i
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|i
operator|<<
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|pcm_feederdesc
name|feeder_rate_desc
index|[]
init|=
block|{
block|{
name|FEEDER_RATE
block|,
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
block|,
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kobj_method_t
name|feeder_rate_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|feeder_init
argument_list|,
name|feed_rate_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|feeder_free
argument_list|,
name|feed_rate_free
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|feeder_set
argument_list|,
name|feed_rate_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|feeder_get
argument_list|,
name|feed_rate_get
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|feeder_feed
argument_list|,
name|feed_rate
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|FEEDER_DECLARE
argument_list|(
name|feeder_rate
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

