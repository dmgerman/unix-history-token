begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2009 Ariff Abdullah<ariff@FreeBSD.org>  * Copyright (c) 2001 Cameron Grant<cg@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_snd.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/pcm.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/version.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SS_TYPE_MODULE
value|0
end_define

begin_define
define|#
directive|define
name|SS_TYPE_PCM
value|1
end_define

begin_define
define|#
directive|define
name|SS_TYPE_MIDI
value|2
end_define

begin_define
define|#
directive|define
name|SS_TYPE_SEQUENCER
value|3
end_define

begin_decl_stmt
specifier|static
name|d_open_t
name|sndstat_open
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sndstat_close
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_read_t
name|sndstat_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|sndstat_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|sndstat_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|sndstat_open
block|,
operator|.
name|d_read
operator|=
name|sndstat_read
block|,
operator|.
name|d_write
operator|=
name|sndstat_write
block|,
operator|.
name|d_name
operator|=
literal|"sndstat"
block|,
operator|.
name|d_flags
operator|=
name|D_TRACKCLOSE
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|sndstat_entry
block|{
name|TAILQ_ENTRY
argument_list|(
argument|sndstat_entry
argument_list|)
name|link
expr_stmt|;
name|device_t
name|dev
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|sndstat_handler
name|handler
decl_stmt|;
name|int
name|type
decl_stmt|,
name|unit
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sndstat_file
block|{
name|TAILQ_ENTRY
argument_list|(
argument|sndstat_file
argument_list|)
name|entry
expr_stmt|;
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|int
name|out_offset
decl_stmt|;
name|int
name|in_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|sx
name|sndstat_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|sndstat_dev
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SNDSTAT_LOCK
parameter_list|()
value|sx_xlock(&sndstat_lock)
end_define

begin_define
define|#
directive|define
name|SNDSTAT_UNLOCK
parameter_list|()
value|sx_xunlock(&sndstat_lock)
end_define

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|sndstat_entry
argument_list|)
name|sndstat_devlist
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|sndstat_devlist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|sndstat_file
argument_list|)
name|sndstat_filelist
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|sndstat_filelist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|snd_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|sndstat_prepare
parameter_list|(
name|struct
name|sndstat_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|sysctl_hw_sndverbose
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|verbose
decl_stmt|;
name|verbose
operator|=
name|snd_verbose
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|verbose
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|verbose
operator|<
literal|0
operator|||
name|verbose
operator|>
literal|4
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|snd_verbose
operator|=
name|verbose
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RWTUN
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_hw_sndverbose
argument_list|,
literal|"I"
argument_list|,
literal|"verbosity level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sndstat_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sndstat_file
modifier|*
name|pf
decl_stmt|;
name|pf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pf
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|SNDSTAT_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sbuf_new
argument_list|(
operator|&
name|pf
operator|->
name|sbuf
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|SNDSTAT_UNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|pf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sndstat_filelist
argument_list|,
name|pf
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|SNDSTAT_UNLOCK
argument_list|()
expr_stmt|;
name|devfs_set_cdevpriv
argument_list|(
name|pf
argument_list|,
operator|&
name|sndstat_close
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sndstat_close
parameter_list|(
name|void
modifier|*
name|sndstat_file
parameter_list|)
block|{
name|struct
name|sndstat_file
modifier|*
name|pf
init|=
operator|(
expr|struct
name|sndstat_file
operator|*
operator|)
name|sndstat_file
decl_stmt|;
name|SNDSTAT_LOCK
argument_list|()
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|pf
operator|->
name|sbuf
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sndstat_filelist
argument_list|,
name|pf
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|SNDSTAT_UNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|pf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sndstat_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|sndstat_file
modifier|*
name|pf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|len
decl_stmt|;
name|err
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* skip zero-length reads */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|SNDSTAT_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|out_offset
operator|!=
literal|0
condition|)
block|{
comment|/* don't allow both reading and writing */
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|pf
operator|->
name|in_offset
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|sndstat_prepare
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<=
literal|0
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|len
operator|=
name|sbuf_len
argument_list|(
operator|&
name|pf
operator|->
name|sbuf
argument_list|)
operator|-
name|pf
operator|->
name|in_offset
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|buf
operator|->
name|uio_resid
condition|)
name|len
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|err
operator|=
name|uiomove
argument_list|(
name|sbuf_data
argument_list|(
operator|&
name|pf
operator|->
name|sbuf
argument_list|)
operator|+
name|pf
operator|->
name|in_offset
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|pf
operator|->
name|in_offset
operator|+=
name|len
expr_stmt|;
name|done
label|:
name|SNDSTAT_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sndstat_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|sndstat_file
modifier|*
name|pf
decl_stmt|;
name|uint8_t
name|temp
index|[
literal|64
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|len
decl_stmt|;
name|err
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* skip zero-length writes */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* don't allow writing more than 64Kbytes */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|>
literal|65536
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|SNDSTAT_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|in_offset
operator|!=
literal|0
condition|)
block|{
comment|/* don't allow both reading and writing */
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
comment|/* only remember the last write - allows for updates */
name|sbuf_clear
argument_list|(
operator|&
name|pf
operator|->
name|sbuf
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|buf
operator|->
name|uio_resid
condition|)
name|len
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|err
operator|=
name|uiomove
argument_list|(
name|temp
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
else|else
block|{
break|break;
block|}
if|if
condition|(
name|sbuf_bcat
argument_list|(
operator|&
name|pf
operator|->
name|sbuf
argument_list|,
name|temp
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
block|}
name|sbuf_finish
argument_list|(
operator|&
name|pf
operator|->
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|pf
operator|->
name|out_offset
operator|=
name|sbuf_len
argument_list|(
operator|&
name|pf
operator|->
name|sbuf
argument_list|)
expr_stmt|;
else|else
name|pf
operator|->
name|out_offset
operator|=
literal|0
expr_stmt|;
block|}
name|SNDSTAT_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_function
name|int
name|sndstat_register
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|sndstat_handler
name|handler
parameter_list|)
block|{
name|struct
name|sndstat_entry
modifier|*
name|ent
decl_stmt|;
name|struct
name|sndstat_entry
modifier|*
name|pre
decl_stmt|;
specifier|const
name|char
modifier|*
name|devtype
decl_stmt|;
name|int
name|type
decl_stmt|,
name|unit
decl_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|devtype
operator|=
name|device_get_name
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|devtype
argument_list|,
literal|"pcm"
argument_list|)
condition|)
name|type
operator|=
name|SS_TYPE_PCM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|devtype
argument_list|,
literal|"midi"
argument_list|)
condition|)
name|type
operator|=
name|SS_TYPE_MIDI
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|devtype
argument_list|,
literal|"sequencer"
argument_list|)
condition|)
name|type
operator|=
name|SS_TYPE_SEQUENCER
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
block|{
name|type
operator|=
name|SS_TYPE_MODULE
expr_stmt|;
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|ent
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ent
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ent
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|ent
operator|->
name|str
operator|=
name|str
expr_stmt|;
name|ent
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|ent
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|ent
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|SNDSTAT_LOCK
argument_list|()
expr_stmt|;
comment|/* sorted list insertion */
name|TAILQ_FOREACH
argument_list|(
argument|pre
argument_list|,
argument|&sndstat_devlist
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|pre
operator|->
name|unit
operator|>
name|unit
condition|)
break|break;
elseif|else
if|if
condition|(
name|pre
operator|->
name|unit
operator|<
name|unit
condition|)
continue|continue;
if|if
condition|(
name|pre
operator|->
name|type
operator|>
name|type
condition|)
break|break;
elseif|else
if|if
condition|(
name|pre
operator|->
name|type
operator|<
name|unit
condition|)
continue|continue;
block|}
if|if
condition|(
name|pre
operator|==
name|NULL
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sndstat_devlist
argument_list|,
name|ent
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|pre
argument_list|,
name|ent
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|SNDSTAT_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sndstat_registerfile
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
operator|(
name|sndstat_register
argument_list|(
name|NULL
argument_list|,
name|str
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sndstat_unregister
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sndstat_entry
modifier|*
name|ent
decl_stmt|;
name|int
name|error
init|=
name|ENXIO
decl_stmt|;
name|SNDSTAT_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ent
argument_list|,
argument|&sndstat_devlist
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|ent
operator|->
name|dev
operator|==
name|dev
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sndstat_devlist
argument_list|,
name|ent
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|SNDSTAT_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sndstat_unregisterfile
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|sndstat_entry
modifier|*
name|ent
decl_stmt|;
name|int
name|error
init|=
name|ENXIO
decl_stmt|;
name|SNDSTAT_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ent
argument_list|,
argument|&sndstat_devlist
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|ent
operator|->
name|dev
operator|==
name|NULL
operator|&&
name|ent
operator|->
name|str
operator|==
name|str
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sndstat_devlist
argument_list|,
name|ent
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|SNDSTAT_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|sndstat_prepare
parameter_list|(
name|struct
name|sndstat_file
modifier|*
name|pf_self
parameter_list|)
block|{
name|struct
name|sbuf
modifier|*
name|s
init|=
operator|&
name|pf_self
operator|->
name|sbuf
decl_stmt|;
name|struct
name|sndstat_entry
modifier|*
name|ent
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|sndstat_file
modifier|*
name|pf
decl_stmt|;
name|int
name|k
decl_stmt|;
comment|/* make sure buffer is reset */
name|sbuf_clear
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|snd_verbose
operator|>
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"FreeBSD Audio Driver (%ubit %d/%s)\n"
argument_list|,
operator|(
name|u_int
operator|)
sizeof|sizeof
argument_list|(
name|intpcm32_t
argument_list|)
operator|<<
literal|3
argument_list|,
name|SND_DRV_VERSION
argument_list|,
name|MACHINE_ARCH
argument_list|)
expr_stmt|;
block|}
comment|/* generate list of installed devices */
name|k
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ent
argument_list|,
argument|&sndstat_devlist
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|ent
operator|->
name|dev
operator|==
name|NULL
condition|)
continue|continue;
name|d
operator|=
name|device_get_softc
argument_list|(
name|ent
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCM_REGISTERED
argument_list|(
name|d
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|k
operator|++
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"Installed devices:\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"%s:"
argument_list|,
name|device_get_nameunit
argument_list|(
name|ent
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"<%s>"
argument_list|,
name|device_get_desc
argument_list|(
name|ent
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|snd_verbose
operator|>
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|" %s"
argument_list|,
name|ent
operator|->
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|handler
condition|)
block|{
comment|/* XXX Need Giant magic entry ??? */
name|PCM_ACQUIRE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ent
operator|->
name|handler
argument_list|(
name|s
argument_list|,
name|ent
operator|->
name|dev
argument_list|,
name|snd_verbose
argument_list|)
expr_stmt|;
name|PCM_RELEASE_QUICK
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"No devices installed.\n"
argument_list|)
expr_stmt|;
comment|/* append any input from userspace */
name|k
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pf
argument_list|,
argument|&sndstat_filelist
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|pf
operator|==
name|pf_self
condition|)
continue|continue;
if|if
condition|(
name|pf
operator|->
name|out_offset
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|k
operator|++
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"Installed devices from userspace:\n"
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|s
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|pf
operator|->
name|sbuf
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|pf
operator|->
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"No devices installed from userspace.\n"
argument_list|)
expr_stmt|;
comment|/* append any file versions */
if|if
condition|(
name|snd_verbose
operator|>=
literal|3
condition|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ent
argument_list|,
argument|&sndstat_devlist
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|ent
operator|->
name|dev
operator|==
name|NULL
operator|&&
name|ent
operator|->
name|str
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|k
operator|++
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"\nFile Versions:\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"%s\n"
argument_list|,
name|ent
operator|->
name|str
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"\nNo file versions.\n"
argument_list|)
expr_stmt|;
block|}
name|sbuf_finish
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|sbuf_len
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sndstat_sysinit
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|sx_init
argument_list|(
operator|&
name|sndstat_lock
argument_list|,
literal|"sndstat lock"
argument_list|)
expr_stmt|;
name|sndstat_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|sndstat_cdevsw
argument_list|,
name|SND_DEV_STATUS
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0644
argument_list|,
literal|"sndstat"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|sndstat_sysinit
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|sndstat_sysinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|sndstat_sysuninit
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|sndstat_dev
operator|!=
name|NULL
condition|)
block|{
comment|/* destroy_dev() will wait for all references to go away */
name|destroy_dev
argument_list|(
name|sndstat_dev
argument_list|)
expr_stmt|;
block|}
name|sx_destroy
argument_list|(
operator|&
name|sndstat_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|sndstat_sysuninit
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|sndstat_sysuninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

