begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999 Cameron Grant<gandalf@vilnya.demon.co.uk>  * Portions Copyright by Luigi Rizzo - 1997-99  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_define
define|#
directive|define
name|MIN_CHUNK_SIZE
value|256
end_define

begin_comment
comment|/* for uiomove etc. */
end_comment

begin_define
define|#
directive|define
name|DMA_ALIGN_THRESHOLD
value|4
end_define

begin_define
define|#
directive|define
name|DMA_ALIGN_MASK
value|(~(DMA_ALIGN_THRESHOLD - 1))
end_define

begin_define
define|#
directive|define
name|ISA_DMA
parameter_list|(
name|b
parameter_list|)
value|(((b)->chan>= 0&& (b)->chan != 4&& (b)->chan< 8))
end_define

begin_define
define|#
directive|define
name|CANCHANGE
parameter_list|(
name|c
parameter_list|)
value|(!(c)->buffer.dl)
end_define

begin_comment
comment|/* #define DEB(x) x */
end_comment

begin_function_decl
specifier|static
name|void
name|chn_clearbuf
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chn_dmaupdate
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chn_wrintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chn_rdintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * SOUND OUTPUT  We use a circular buffer to store samples directed to the DAC. The buffer is split into two variable-size regions, each identified by an offset in the buffer (rp,fp) and a length (rl,fl):        0          rp,rl        fp,fl    bufsize       |__________>____________>________| 	  FREE   d   READY    w FREE    READY: data written from the process and ready to be sent to the DAC;   FREE: free part of the buffer.  Both regions can wrap around the end of the buffer.  At initialization, READY is empty, FREE takes all the available space, and dma is idle.  dl contains the length of the current DMA transfer, dl=0 means that the dma is idle.  The two boundaries (rp,fp) in the buffers are advanced by DMA [d] and write() [w] operations. The first portion of the READY region is used for DMA transfers. The transfer is started at rp and with chunks of length dl. During DMA operations, dsp_wr_dmaupdate() updates rp, rl and fl tracking the ISA DMA engine as the transfer makes progress. When a new block is written, fp advances and rl,fl are updated accordingly.  The code works as follows: the user write routine dsp_write_body() fills up the READY region with new data (reclaiming space from the FREE region) and starts the write DMA engine if inactive.  When a DMA transfer is complete, an interrupt causes dsp_wrintr() to be called which extends the FREE region and possibly starts the next transfer.  In some cases, the code tries to track the current status of DMA operations by calling dsp_wr_dmaupdate() which changes rp, rl and fl.  The sistem tries to make all DMA transfers use the same size, play_blocksize or rec_blocksize. The size is either selected by the user, or computed by the system to correspond to about .25s of audio. The blocksize must be within a range which is currently:  	min(5ms, 40 bytes) ... 1/2 buffer size.  When there aren't enough data (write) or space (read), a transfer is started with a reduced size.  To reduce problems in case of overruns, the routine which fills up the buffer should initialize (e.g. by repeating the last value) a reasonably long area after the last block so that no noise is produced on overruns.    *   */
end_comment

begin_comment
comment|/* XXX  this is broken: in the event a bounce buffer is used, data never  * gets copied in or out of the real buffer.  fix requires mods to isa_dma.c  * and possibly fixes to other autodma mode clients  */
end_comment

begin_function
specifier|static
name|void
name|chn_isadmabounce
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|ISA_DMA
argument_list|(
operator|&
name|c
operator|->
name|buffer
argument_list|)
condition|)
block|{
comment|/* tell isa_dma to bounce data in/out */
block|}
else|else
name|KASSERT
argument_list|(
literal|1
argument_list|,
operator|(
literal|"chn_isadmabounce called on invalid channel"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|chn_polltrigger
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|unsigned
name|lim
init|=
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_HAS_SIZE
operator|)
condition|?
name|c
operator|->
name|blocksize2nd
else|:
literal|1
decl_stmt|;
name|int
name|trig
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|trig
operator|=
operator|(
operator|(
name|bs
operator|->
name|int_count
operator|>
name|bs
operator|->
name|prev_int_count
operator|)
operator|||
name|bs
operator|->
name|first_poll
operator|)
expr_stmt|;
else|else
name|trig
operator|=
operator|(
operator|(
operator|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|bs
operator|->
name|rl
else|:
name|bs
operator|->
name|fl
operator|)
operator|<
name|lim
operator|)
expr_stmt|;
return|return
name|trig
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chn_pollreset
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|bs
operator|->
name|prev_int_count
operator|=
name|bs
operator|->
name|int_count
expr_stmt|;
name|bs
operator|->
name|first_poll
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * chn_dmadone() updates pointers and wakes up any process waiting  * on a select(). Must be called at spltty().  */
end_comment

begin_function
specifier|static
name|void
name|chn_dmadone
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISA_DMA
argument_list|(
name|b
argument_list|)
condition|)
name|chn_isadmabounce
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* sync bounce buffer */
name|b
operator|->
name|int_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chn_dmawakeup() wakes up any process sleeping. Separated from  * chn_dmadone() so that wakeup occurs only when feed from a  * secondary buffer to a DMA buffer takes place. Must be called  * at spltty().  */
end_comment

begin_function
specifier|static
name|void
name|chn_dmawakeup
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|wakeup
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chn_dmaupdate() tracks the status of a dma transfer,  * updating pointers. It must be called at spltty().  *  * NOTE: when we are using auto dma in the device, rl might become  * negative.  */
end_comment

begin_macro
name|DEB
argument_list|(
argument|static int chn_updatecount=
literal|0
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|chn_dmaupdate
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|hwptr
decl_stmt|;
name|DEB
argument_list|(
argument|int b_rl=b->rl; int b_fl=b->fl; int b_rp=b->rp; int b_fp=b->fp
argument_list|)
empty_stmt|;
name|hwptr
operator|=
name|chn_getptr
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|delta
operator|=
operator|(
name|b
operator|->
name|bufsize
operator|+
name|hwptr
operator|-
name|b
operator|->
name|rp
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|rp
operator|=
name|hwptr
expr_stmt|;
name|b
operator|->
name|rl
operator|-=
name|delta
expr_stmt|;
name|b
operator|->
name|fl
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|rl
operator|<
literal|0
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"OUCH!(%d) rl %d(%d) delta %d bufsize %d hwptr %d rp %d(%d)\n"
argument_list|,
name|chn_updatecount
operator|++
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b_rl
argument_list|,
name|delta
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|hwptr
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b_rp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|delta
operator|=
operator|(
name|b
operator|->
name|bufsize
operator|+
name|hwptr
operator|-
name|b
operator|->
name|fp
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|fp
operator|=
name|hwptr
expr_stmt|;
name|b
operator|->
name|rl
operator|+=
name|delta
expr_stmt|;
name|b
operator|->
name|fl
operator|-=
name|delta
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|fl
operator|<
literal|0
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"OUCH!(%d) fl %d(%d) delta %d bufsize %d hwptr %d fp %d(%d)\n"
argument_list|,
name|chn_updatecount
operator|++
argument_list|,
name|b
operator|->
name|fl
argument_list|,
name|b_fl
argument_list|,
name|delta
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|hwptr
argument_list|,
name|b
operator|->
name|fp
argument_list|,
name|b_fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|->
name|total
operator|+=
name|delta
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check channel for underflow occured. Reset DMA buffer in case of  * underflow, so that new data can go into the buffer. It must be  * called at spltty().  */
end_comment

begin_function
name|void
name|chn_checkunderflow
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|underflow
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"Clear underflow condition\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * The DMA keeps running even after underflow occurs. 		 * Hence the value returned by chn_getptr() here soon 		 * gets a lag when we get back to chn_write(). Although 		 * there are no easy and precise methods to figure out 		 * the lag, a quarter of b->bufsize would be a fair 		 * choice, provided that a DMA interrupt generates upon 		 * each transfer of a half b->bufsize. 		 */
name|b
operator|->
name|rp
operator|=
name|chn_getptr
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|b
operator|->
name|fp
operator|=
operator|(
name|b
operator|->
name|rp
operator|+
name|b
operator|->
name|bufsize
operator|/
literal|4
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|rl
operator|=
name|b
operator|->
name|bufsize
operator|/
literal|4
expr_stmt|;
name|b
operator|->
name|fl
operator|=
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|rl
expr_stmt|;
name|b
operator|->
name|underflow
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Feeds new data to the write dma buffer. Can be called in the bottom half.  * Hence must be called at spltty.  */
end_comment

begin_function
name|int
name|chn_wrfeed
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|a
decl_stmt|,
name|l
decl_stmt|,
name|lacc
decl_stmt|;
comment|/* ensure we always have a whole number of samples */
name|a
operator|=
operator|(
literal|1
operator|<<
name|c
operator|->
name|align
operator|)
operator|-
literal|1
expr_stmt|;
name|lacc
operator|=
literal|0
expr_stmt|;
comment|/* Don't allow write unaligned data */
while|while
condition|(
name|bs
operator|->
name|rl
operator|>
name|a
operator|&&
name|b
operator|->
name|fl
operator|>
name|a
condition|)
block|{
comment|/* ensure we always have a whole number of samples */
name|l
operator|=
name|min
argument_list|(
name|min
argument_list|(
name|bs
operator|->
name|rl
argument_list|,
name|bs
operator|->
name|bufsize
operator|-
name|bs
operator|->
name|rp
argument_list|)
argument_list|,
name|min
argument_list|(
name|b
operator|->
name|fl
argument_list|,
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|fp
argument_list|)
argument_list|)
operator|&
operator|~
name|a
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
name|lacc
return|;
comment|/* Move the samples, update the markers and pointers. */
name|bcopy
argument_list|(
name|bs
operator|->
name|buf
operator|+
name|bs
operator|->
name|rp
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|fp
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|bs
operator|->
name|fl
operator|+=
name|l
expr_stmt|;
name|bs
operator|->
name|rl
operator|-=
name|l
expr_stmt|;
name|bs
operator|->
name|rp
operator|=
operator|(
name|bs
operator|->
name|rp
operator|+
name|l
operator|)
operator|%
name|bs
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|rl
operator|+=
name|l
expr_stmt|;
name|b
operator|->
name|fl
operator|-=
name|l
expr_stmt|;
name|b
operator|->
name|fp
operator|=
operator|(
name|b
operator|->
name|fp
operator|+
name|l
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
comment|/* Clear the new space in the secondary buffer. */
name|chn_clearbuf
argument_list|(
name|c
argument_list|,
name|bs
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Accumulate the total bytes of the moved samples. */
name|lacc
operator|+=
name|l
expr_stmt|;
comment|/* A feed to the DMA buffer is equivalent to an interrupt. */
name|bs
operator|->
name|int_count
operator|++
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|sel
operator|.
name|si_pid
operator|&&
name|chn_polltrigger
argument_list|(
name|c
argument_list|)
condition|)
name|selwakeup
argument_list|(
operator|&
name|bs
operator|->
name|sel
argument_list|)
expr_stmt|;
block|}
return|return
name|lacc
return|;
block|}
end_function

begin_comment
comment|/* Feeds new data to the secondary write buffer. */
end_comment

begin_function
specifier|static
name|int
name|chn_wrfeed2nd
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|l
decl_stmt|,
name|w
decl_stmt|,
name|wacc
decl_stmt|;
comment|/* The DMA buffer may have some space. */
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* ensure we always have a whole number of samples */
name|wacc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|bs
operator|->
name|fl
operator|>
literal|0
condition|)
block|{
comment|/* 		 * The size of the data to move here does not have to be 		 * aligned. We take care of it upon moving the data to a 		 * DMA buffer. 		 */
name|l
operator|=
name|min
argument_list|(
name|bs
operator|->
name|fl
argument_list|,
name|bs
operator|->
name|bufsize
operator|-
name|bs
operator|->
name|fp
argument_list|)
expr_stmt|;
comment|/* Move the samples, update the markers and pointers. */
name|w
operator|=
name|c
operator|->
name|feeder
operator|->
name|feed
argument_list|(
name|c
operator|->
name|feeder
argument_list|,
name|c
argument_list|,
name|bs
operator|->
name|buf
operator|+
name|bs
operator|->
name|fp
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"no feed"
argument_list|)
expr_stmt|;
name|bs
operator|->
name|rl
operator|+=
name|w
expr_stmt|;
name|bs
operator|->
name|fl
operator|-=
name|w
expr_stmt|;
name|bs
operator|->
name|fp
operator|=
operator|(
name|bs
operator|->
name|fp
operator|+
name|w
operator|)
operator|%
name|bs
operator|->
name|bufsize
expr_stmt|;
comment|/* Accumulate the total bytes of the moved samples. */
name|bs
operator|->
name|total
operator|+=
name|w
expr_stmt|;
name|wacc
operator|+=
name|w
expr_stmt|;
comment|/* If any pcm data gets moved, push it to the DMA buffer. */
if|if
condition|(
name|w
operator|>
literal|0
condition|)
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
block|}
return|return
name|wacc
return|;
block|}
end_function

begin_comment
comment|/*  * Write interrupt routine. Can be called from other places (e.g.  * to start a paused transfer), but with interrupts disabled.  */
end_comment

begin_function
specifier|static
name|void
name|chn_wrintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|int
name|start
decl_stmt|,
name|dl
decl_stmt|,
name|l
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|underflow
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
operator|)
condition|)
block|{
comment|/*		printf("underflow return\n"); */
return|return;
comment|/* nothing new happened */
block|}
if|if
condition|(
name|b
operator|->
name|dl
condition|)
name|chn_dmadone
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * start another dma operation only if have ready data in the buffer, 	 * there is no pending abort, have a full-duplex device, or have a 	 * half duplex device and there is no pending op on the other side. 	 * 	 * Force transfers to be aligned to a boundary of 4, which is 	 * needed when doing stereo and 16-bit. 	 */
comment|/* 	 * Prepare new space of at least c->blocksize in the DMA 	 * buffer for mmap. 	 */
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
operator|&&
name|b
operator|->
name|fl
operator|<
name|c
operator|->
name|blocksize
condition|)
block|{
name|dl
operator|=
name|c
operator|->
name|blocksize
operator|-
name|b
operator|->
name|fl
expr_stmt|;
name|b
operator|->
name|fl
operator|+=
name|dl
expr_stmt|;
name|b
operator|->
name|rl
operator|-=
name|dl
expr_stmt|;
name|b
operator|->
name|rp
operator|=
operator|(
name|b
operator|->
name|rp
operator|+
name|dl
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
name|chn_clearbuf
argument_list|(
name|c
argument_list|,
name|b
argument_list|,
name|dl
argument_list|)
expr_stmt|;
block|}
comment|/* Check underflow and update the pointers. */
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * Fill up the DMA buffer, followed by waking up the top half. 	 * If some of the pcm data in uio are still left, the top half 	 * goes to sleep by itself. 	 */
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
name|chn_dmawakeup
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|start
operator|=
name|c
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
expr_stmt|;
else|else
block|{
comment|/*		printf("%d>= %d&& !(%x& %x)\n", b->rl, DMA_ALIGN_THRESHOLD, c->flags, CHN_F_ABORTING | CHN_F_CLOSING); */
name|start
operator|=
operator|(
name|b
operator|->
name|rl
operator|>=
name|DMA_ALIGN_THRESHOLD
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
operator|(
name|CHN_F_ABORTING
operator||
name|CHN_F_CLOSING
operator|)
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|start
condition|)
block|{
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|l
operator|=
name|c
operator|->
name|blocksize
expr_stmt|;
else|else
name|l
operator|=
name|min
argument_list|(
name|b
operator|->
name|rl
argument_list|,
name|c
operator|->
name|blocksize
argument_list|)
operator|&
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* 	 	 * check if we need to reprogram the DMA on the sound card. 	 	 * This happens if the size has changed from zero 	 	 */
if|if
condition|(
name|b
operator|->
name|dl
operator|==
literal|0
condition|)
block|{
comment|/* Start DMA operation */
name|b
operator|->
name|dl
operator|=
name|c
operator|->
name|blocksize
expr_stmt|;
comment|/* record new transfer size */
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_START
argument_list|)
expr_stmt|;
block|}
comment|/*  		 * Emulate writing by DMA, i.e. transfer the pcm data from  		 * the emulated-DMA buffer to the device itself.  		 */
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_EMLDMAWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
operator|!=
name|l
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"near underflow %d, %d, %d\n"
argument_list|,
name|l
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * we are near to underflow condition, so to prevent 			 * audio 'clicks' clear next b->fl bytes 			 */
name|chn_clearbuf
argument_list|(
name|c
argument_list|,
name|b
argument_list|,
name|b
operator|->
name|fl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* cannot start a new dma transfer */
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"underflow, flags 0x%08x rp %d rl %d\n"
argument_list|,
name|c
operator|->
name|flags
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b
operator|->
name|rl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
comment|/* DMA was active */
name|b
operator|->
name|underflow
operator|=
literal|1
expr_stmt|;
comment|/* set underflow flag */
name|chn_clearbuf
argument_list|(
name|c
argument_list|,
name|b
argument_list|,
name|b
operator|->
name|bufsize
argument_list|)
expr_stmt|;
comment|/* and clear all DMA buffer */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * user write routine  *  * advance the boundary between READY and FREE, fill the space with  * uiomove(), and possibly start DMA. Do the above until the transfer  * is complete.  *  * To minimize latency in case a pending DMA transfer is about to end,  * we do the transfer in pieces of increasing sizes, extending the  * READY area at every checkpoint. In the (necessary) assumption that  * memory bandwidth is larger than the rate at which the dma consumes  * data, we reduce the latency to something proportional to the length  * of the first piece, while keeping the overhead low and being able  * to feed the DMA with large blocks.  */
end_comment

begin_function
name|int
name|chn_write
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|timeout
decl_stmt|,
name|res
decl_stmt|,
name|newsize
decl_stmt|;
name|long
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_WRITING
condition|)
block|{
comment|/* This shouldn't happen and is actually silly 		 * - will never wake up, just timeout; why not sleep on b? 		 */
name|tsleep
argument_list|(
operator|&
name|s
argument_list|,
name|PZERO
argument_list|,
literal|"pcmwrW"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|c
operator|->
name|flags
operator||=
name|CHN_F_WRITING
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_ABORTING
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* 	 * XXX Certain applications attempt to write larger size 	 * of pcm data than c->blocksize2nd without blocking, 	 * resulting partial write. Expand the block size so that 	 * the write operation avoids blocking. 	 */
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_NBIO
operator|)
operator|&&
name|buf
operator|->
name|uio_resid
operator|>
name|c
operator|->
name|blocksize2nd
condition|)
block|{
for|for
control|(
name|newsize
operator|=
literal|1
init|;
name|newsize
operator|<
name|min
argument_list|(
name|buf
operator|->
name|uio_resid
argument_list|,
name|CHN_2NDBUFWHOLESIZE
argument_list|)
condition|;
name|newsize
operator|<<=
literal|1
control|)
empty_stmt|;
name|chn_setblocksize
argument_list|(
name|c
argument_list|,
name|newsize
operator|*
name|c
operator|->
name|fragments
argument_list|)
expr_stmt|;
name|c
operator|->
name|blocksize2nd
operator|=
name|newsize
expr_stmt|;
name|c
operator|->
name|fragments
operator|=
name|bs
operator|->
name|bufsize
operator|/
name|c
operator|->
name|blocksize2nd
expr_stmt|;
block|}
comment|/* Store the initial size in the uio. */
name|res
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
comment|/* 	 * Fill up the secondary and DMA buffer. 	 * chn_wrfeed*() takes care of the alignment. 	 */
comment|/* Check for underflow before writing into the buffers. */
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_wrfeed2nd
argument_list|(
name|c
argument_list|,
name|buf
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* Start playing if not yet. */
if|if
condition|(
operator|(
name|bs
operator|->
name|rl
operator|||
name|b
operator|->
name|rl
operator|)
operator|&&
operator|!
name|b
operator|->
name|dl
condition|)
block|{
name|chn_wrintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_NBIO
condition|)
block|{
comment|/* If no pcm data was written on nonblocking, return EAGAIN. */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
name|res
condition|)
name|ret
operator|=
name|EAGAIN
expr_stmt|;
block|}
else|else
block|{
comment|/* Wait until all samples are played in blocking mode. */
while|while
condition|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
comment|/* Check for underflow before writing into the buffers. */
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Fill up the buffers with new pcm data. */
while|while
condition|(
name|chn_wrfeed2nd
argument_list|(
name|c
argument_list|,
name|buf
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* Start playing if necessary. */
if|if
condition|(
operator|(
name|bs
operator|->
name|rl
operator|||
name|b
operator|->
name|rl
operator|)
operator|&&
operator|!
name|b
operator|->
name|dl
condition|)
name|chn_wrintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Have we finished to feed the secondary buffer? */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
literal|0
condition|)
break|break;
comment|/* Wait for new free space to write new pcm samples. */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
operator|=
operator|(
name|buf
operator|->
name|uio_resid
operator|>=
name|b
operator|->
name|dl
operator|)
condition|?
name|hz
operator|/
literal|20
else|:
literal|1
expr_stmt|;
name|ret
operator|=
name|tsleep
argument_list|(
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmwr"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* if (ret == EINTR) chn_abort(c); */
if|if
condition|(
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
condition|)
break|break;
block|}
block|}
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_WRITING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * SOUND INPUT  *  The input part is similar to the output one, with a circular buffer split in two regions, and boundaries advancing because of read() calls [r] or dma operation [d].  At initialization, as for the write routine, READY is empty, and FREE takes all the space.        0          rp,rl        fp,fl    bufsize       |__________>____________>________| 	  FREE   r   READY    d  FREE  Operation is as follows: upon user read (dsp_read_body()) a DMA read is started if not already active (marked by b->dl> 0), then as soon as data are available in the READY region they are transferred to the user buffer, thus advancing the boundary between FREE and READY. Upon interrupts, caused by a completion of a DMA transfer, the READY region is extended and possibly a new transfer is started.  When necessary, dsp_rd_dmaupdate() is called to advance fp (and update rl,fl accordingly). Upon user reads, rp is advanced and rl,fl are updated accordingly.  The rules to choose the size of the new DMA area are similar to the other case, with a preferred constant transfer size equal to rec_blocksize, and fallback to smaller sizes if no space is available.   */
end_comment

begin_comment
comment|/*  * Feed new data from the read buffer. Can be called in the bottom half.  * Hence must be called at spltty.  */
end_comment

begin_function
name|int
name|chn_rdfeed
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|l
decl_stmt|,
name|lacc
decl_stmt|;
comment|/* ensure we always have a whole number of samples */
name|lacc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bs
operator|->
name|fl
operator|>=
name|DMA_ALIGN_THRESHOLD
operator|&&
name|b
operator|->
name|rl
operator|>=
name|DMA_ALIGN_THRESHOLD
condition|)
block|{
name|l
operator|=
name|min
argument_list|(
name|min
argument_list|(
name|bs
operator|->
name|fl
argument_list|,
name|bs
operator|->
name|bufsize
operator|-
name|bs
operator|->
name|fp
argument_list|)
argument_list|,
name|min
argument_list|(
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|rp
argument_list|)
argument_list|)
operator|&
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* Move the samples, update the markers and pointers. */
name|bcopy
argument_list|(
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|rp
argument_list|,
name|bs
operator|->
name|buf
operator|+
name|bs
operator|->
name|fp
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|bs
operator|->
name|fl
operator|-=
name|l
expr_stmt|;
name|bs
operator|->
name|rl
operator|+=
name|l
expr_stmt|;
name|bs
operator|->
name|fp
operator|=
operator|(
name|bs
operator|->
name|fp
operator|+
name|l
operator|)
operator|%
name|bs
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|rl
operator|-=
name|l
expr_stmt|;
name|b
operator|->
name|fl
operator|+=
name|l
expr_stmt|;
name|b
operator|->
name|rp
operator|=
operator|(
name|b
operator|->
name|rp
operator|+
name|l
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
comment|/* Clear the new space in the DMA buffer. */
name|chn_clearbuf
argument_list|(
name|c
argument_list|,
name|b
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Accumulate the total bytes of the moved samples. */
name|lacc
operator|+=
name|l
expr_stmt|;
comment|/* A feed from the DMA buffer is equivalent to an interrupt. */
name|bs
operator|->
name|int_count
operator|++
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|sel
operator|.
name|si_pid
operator|&&
name|chn_polltrigger
argument_list|(
name|c
argument_list|)
condition|)
name|selwakeup
argument_list|(
operator|&
name|bs
operator|->
name|sel
argument_list|)
expr_stmt|;
block|}
return|return
name|lacc
return|;
block|}
end_function

begin_comment
comment|/* Feeds new data from the secondary read buffer. */
end_comment

begin_function
specifier|static
name|int
name|chn_rdfeed2nd
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|l
decl_stmt|,
name|w
decl_stmt|,
name|wacc
decl_stmt|;
comment|/* The DMA buffer may have pcm data. */
while|while
condition|(
name|chn_rdfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* ensure we always have a whole number of samples */
name|wacc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|bs
operator|->
name|rl
operator|>
literal|0
condition|)
block|{
comment|/* 		 * The size of the data to move here does not have to be 		 * aligned. We take care of it upon moving the data to a 		 * DMA buffer. 		 */
name|l
operator|=
name|min
argument_list|(
name|bs
operator|->
name|rl
argument_list|,
name|bs
operator|->
name|bufsize
operator|-
name|bs
operator|->
name|rp
argument_list|)
expr_stmt|;
comment|/* Move the samples, update the markers and pointers. */
name|w
operator|=
name|c
operator|->
name|feeder
operator|->
name|feed
argument_list|(
name|c
operator|->
name|feeder
argument_list|,
name|c
argument_list|,
name|bs
operator|->
name|buf
operator|+
name|bs
operator|->
name|rp
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"no feed"
argument_list|)
expr_stmt|;
name|bs
operator|->
name|fl
operator|+=
name|w
expr_stmt|;
name|bs
operator|->
name|rl
operator|-=
name|w
expr_stmt|;
name|bs
operator|->
name|rp
operator|=
operator|(
name|bs
operator|->
name|rp
operator|+
name|w
operator|)
operator|%
name|bs
operator|->
name|bufsize
expr_stmt|;
comment|/* Clear the new space in the secondary buffer. */
name|chn_clearbuf
argument_list|(
name|c
argument_list|,
name|bs
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Accumulate the total bytes of the moved samples. */
name|bs
operator|->
name|total
operator|+=
name|w
expr_stmt|;
name|wacc
operator|+=
name|w
expr_stmt|;
comment|/* If any pcm data gets moved, suck up the DMA buffer. */
if|if
condition|(
name|w
operator|>
literal|0
condition|)
while|while
condition|(
name|chn_rdfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
block|}
return|return
name|wacc
return|;
block|}
end_function

begin_comment
comment|/* read interrupt routine. Must be called with interrupts blocked. */
end_comment

begin_function
specifier|static
name|void
name|chn_rdintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|start
decl_stmt|,
name|dl
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
name|chn_dmadone
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"rdintr: start dl %d, rp:rl %d:%d, fp:fl %d:%d\n"
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|fp
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restart if have enough free space to absorb overruns */
comment|/* 	 * Prepare new space of at least c->blocksize in the secondary 	 * buffer for mmap. 	 */
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
operator|&&
name|bs
operator|->
name|fl
operator|<
name|c
operator|->
name|blocksize
condition|)
block|{
name|dl
operator|=
name|c
operator|->
name|blocksize
operator|-
name|bs
operator|->
name|fl
expr_stmt|;
name|bs
operator|->
name|fl
operator|+=
name|dl
expr_stmt|;
name|bs
operator|->
name|rl
operator|-=
name|dl
expr_stmt|;
name|bs
operator|->
name|rp
operator|=
operator|(
name|bs
operator|->
name|rp
operator|+
name|dl
operator|)
operator|%
name|bs
operator|->
name|bufsize
expr_stmt|;
name|chn_clearbuf
argument_list|(
name|c
argument_list|,
name|bs
argument_list|,
name|dl
argument_list|)
expr_stmt|;
block|}
comment|/* Update the pointers. */
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * Suck up the DMA buffer, followed by waking up the top half. 	 * If some of the pcm data in the secondary buffer are still left, 	 * the top half goes to sleep by itself. 	 */
while|while
condition|(
name|chn_rdfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
name|chn_dmawakeup
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|start
operator|=
name|c
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
expr_stmt|;
else|else
name|start
operator|=
operator|(
name|b
operator|->
name|fl
operator|>
literal|0x200
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_ABORTING
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
block|{
name|int
name|l
init|=
name|min
argument_list|(
name|b
operator|->
name|fl
operator|-
literal|0x100
argument_list|,
name|c
operator|->
name|blocksize
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|l
operator|=
name|c
operator|->
name|blocksize
expr_stmt|;
name|l
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* realign sizes */
name|DEB
argument_list|(
argument|printf(
literal|"rdintr: dl %d -> %d\n"
argument|, b->dl, l);
argument_list|)
if|if
condition|(
name|l
operator|!=
name|b
operator|->
name|dl
condition|)
block|{
comment|/* size has changed. Stop and restart */
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_STOP
argument_list|)
expr_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|b
operator|->
name|fl
operator|-
literal|0x100
argument_list|,
name|c
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|l
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* realign sizes */
block|}
name|b
operator|->
name|dl
operator|=
name|l
expr_stmt|;
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_START
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
comment|/* was active */
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_STOP
argument_list|)
expr_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * body of user-read routine  *  * Start DMA if not active; wait for READY not empty.  * Transfer data from READY region using uiomove(), advance boundary  * between FREE and READY. Repeat until transfer is complete.  *  * To avoid excessive latency in freeing up space for the DMA  * engine, transfers are done in blocks of increasing size, so that  * the latency is proportional to the size of the smallest block, but  * we have a low overhead and are able to feed the dma engine with  * large blocks.  *  * NOTE: in the current version, read will not return more than  * blocksize bytes at once (unless more are already available), to  * avoid that requests using very large buffers block for too long.  */
end_comment

begin_function
name|int
name|chn_read
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|timeout
decl_stmt|,
name|limit
decl_stmt|,
name|res
decl_stmt|;
name|long
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_READING
condition|)
block|{
comment|/* This shouldn't happen and is actually silly */
name|tsleep
argument_list|(
operator|&
name|s
argument_list|,
name|PZERO
argument_list|,
literal|"pcmrdR"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* Store the initial size in the uio. */
name|res
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_READING
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_ABORTING
expr_stmt|;
name|limit
operator|=
name|buf
operator|->
name|uio_resid
operator|-
name|c
operator|->
name|blocksize
expr_stmt|;
if|if
condition|(
name|limit
operator|<
literal|0
condition|)
name|limit
operator|=
literal|0
expr_stmt|;
comment|/* Update the pointers and suck up the DMA and secondary buffers. */
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_rdfeed2nd
argument_list|(
name|c
argument_list|,
name|buf
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* Start capturing if not yet. */
if|if
condition|(
operator|(
operator|!
name|bs
operator|->
name|rl
operator|||
operator|!
name|b
operator|->
name|rl
operator|)
operator|&&
operator|!
name|b
operator|->
name|dl
condition|)
name|chn_rdintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_NBIO
operator|)
condition|)
block|{
comment|/* Wait until all samples are captured. */
while|while
condition|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
comment|/* Suck up the DMA and secondary buffers. */
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_rdfeed2nd
argument_list|(
name|c
argument_list|,
name|buf
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* Start capturing if necessary. */
if|if
condition|(
operator|(
operator|!
name|bs
operator|->
name|rl
operator|||
operator|!
name|b
operator|->
name|rl
operator|)
operator|&&
operator|!
name|b
operator|->
name|dl
condition|)
name|chn_rdintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Have we finished to feed the uio? */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
literal|0
condition|)
break|break;
comment|/* Wait for new pcm samples. */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
operator|=
operator|(
name|buf
operator|->
name|uio_resid
operator|-
name|limit
operator|>=
name|b
operator|->
name|dl
operator|)
condition|?
name|hz
operator|/
literal|20
else|:
literal|1
expr_stmt|;
name|ret
operator|=
name|tsleep
argument_list|(
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmrd"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
condition|)
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
condition|)
break|break;
block|}
block|}
else|else
block|{
comment|/* If no pcm data was read on nonblocking, return EAGAIN. */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
name|res
condition|)
name|ret
operator|=
name|EAGAIN
expr_stmt|;
block|}
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_READING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|chn_intr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
name|chn_wrintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|chn_rdintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|chn_dma_setmap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|(
name|snd_dbuf
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"pcm: setmap %lx, %lx; "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%p -> %lx\n"
argument_list|,
name|b
operator|->
name|buf
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vtophys
argument_list|(
name|b
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate memory for DMA buffer. If the device do not perform DMA transfer,  * the drvier can call malloc(9) by its own.  */
end_comment

begin_function
name|int
name|chn_allocbuf
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|bus_dma_tag_t
name|parent_dmat
parameter_list|)
block|{
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|parent_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|b
operator|->
name|buf
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|b
operator|->
name|dmamap
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|parent_dmat
argument_list|,
name|b
operator|->
name|dmamap
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|chn_dma_setmap
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|chn_clearbuf
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
name|data
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* rely on length& DMA_ALIGN_MASK == 0 */
name|length
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|hwfmt
operator|&
name|AFMT_SIGNED
condition|)
name|data
operator|=
literal|0x00
expr_stmt|;
else|else
name|data
operator|=
literal|0x80
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|hwfmt
operator|&
name|AFMT_16BIT
condition|)
name|data
operator|<<=
literal|8
expr_stmt|;
else|else
name|data
operator||=
name|data
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|hwfmt
operator|&
name|AFMT_BIGENDIAN
condition|)
name|data
operator|=
operator|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
operator|)
operator||
operator|(
operator|(
name|data
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|b
operator|->
name|fp
operator|,
name|p
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|fp
operator|)
init|;
name|i
operator|<
name|b
operator|->
name|bufsize
operator|&&
name|length
condition|;
name|i
operator|+=
literal|2
operator|,
name|length
operator|-=
literal|2
control|)
operator|*
name|p
operator|++
operator|=
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|b
operator|->
name|buf
init|;
name|i
operator|<
name|b
operator|->
name|bufsize
operator|&&
name|length
condition|;
name|i
operator|+=
literal|2
operator|,
name|length
operator|-=
literal|2
control|)
operator|*
name|p
operator|++
operator|=
name|data
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|chn_resetbuf
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|c
operator|->
name|smegcnt
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|sample_size
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|sample_size
operator|<<=
operator|(
name|c
operator|->
name|hwfmt
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|b
operator|->
name|sample_size
operator|<<=
operator|(
name|c
operator|->
name|hwfmt
operator|&
name|AFMT_16BIT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|b
operator|->
name|rp
operator|=
name|b
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|dl
operator|=
name|b
operator|->
name|rl
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|fl
operator|=
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|prev_total
operator|=
name|b
operator|->
name|total
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|prev_int_count
operator|=
name|b
operator|->
name|int_count
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|first_poll
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|underflow
operator|=
literal|0
expr_stmt|;
name|chn_clearbuf
argument_list|(
name|c
argument_list|,
name|b
argument_list|,
name|b
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|bs
operator|->
name|rp
operator|=
name|bs
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|dl
operator|=
name|bs
operator|->
name|rl
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|fl
operator|=
name|bs
operator|->
name|bufsize
expr_stmt|;
name|bs
operator|->
name|prev_total
operator|=
name|bs
operator|->
name|total
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|prev_int_count
operator|=
name|b
operator|->
name|int_count
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|first_poll
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|underflow
operator|=
literal|0
expr_stmt|;
name|chn_clearbuf
argument_list|(
name|c
argument_list|,
name|bs
argument_list|,
name|bs
operator|->
name|bufsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|buf_isadma
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|int
name|go
parameter_list|)
block|{
if|if
condition|(
name|ISA_DMA
argument_list|(
name|b
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"buf 0x%p ISA DMA started\n"
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|isa_dmastart
argument_list|(
name|b
operator|->
name|dir
operator||
name|B_RAW
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_STOP
case|:
case|case
name|PCMTRIG_ABORT
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"buf 0x%p ISA DMA stopped\n"
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|isa_dmastop
argument_list|(
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
name|isa_dmadone
argument_list|(
name|b
operator|->
name|dir
operator||
name|B_RAW
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|KASSERT
argument_list|(
literal|1
argument_list|,
operator|(
literal|"buf_isadma called on invalid channel"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|buf_isadmaptr
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|ISA_DMA
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|b
operator|->
name|dl
condition|?
name|isa_dmastatus
argument_list|(
name|b
operator|->
name|chan
argument_list|)
else|:
name|b
operator|->
name|bufsize
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
return|return
name|b
operator|->
name|bufsize
operator|-
name|i
return|;
block|}
else|else
name|KASSERT
argument_list|(
literal|1
argument_list|,
operator|(
literal|"buf_isadmaptr called on invalid channel"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * chn_sync waits until the space in the given channel goes above  * a threshold. The threshold is checked against fl or rl respectively.  * Assume that the condition can become true, do not check here...  */
end_comment

begin_function
name|int
name|chn_sync
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|threshold
parameter_list|)
block|{
name|u_long
name|s
decl_stmt|,
name|rdy
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
name|rdy
operator|=
operator|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|bs
operator|->
name|fl
else|:
name|bs
operator|->
name|rl
expr_stmt|;
if|if
condition|(
name|rdy
operator|<=
name|threshold
condition|)
block|{
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmsyn"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ERESTART
operator|||
name|ret
operator|==
name|EINTR
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_sync: tsleep returns %d\n"
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_poll
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|ev
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|u_long
name|s
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
block|{
comment|/* Fill up the DMA buffer. */
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|dl
condition|)
name|chn_wrintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Suck up the DMA buffer. */
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_rdfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|dl
condition|)
name|chn_rdintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chn_polltrigger
argument_list|(
name|c
argument_list|)
operator|&&
name|chn_pollreset
argument_list|(
name|c
argument_list|)
condition|)
name|ret
operator|=
name|ev
expr_stmt|;
else|else
block|{
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|bs
operator|->
name|sel
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * chn_abort is a non-blocking function which aborts a pending  * DMA transfer and flushes the buffers.  * It returns the number of bytes that have not been transferred.  */
end_comment

begin_function
name|int
name|chn_abort
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|missing
init|=
literal|0
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|dl
condition|)
return|return
literal|0
return|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_ABORTING
expr_stmt|;
while|while
condition|(
operator|!
name|b
operator|->
name|underflow
operator|&&
operator|(
name|b
operator|->
name|dl
operator|>
literal|0
operator|)
operator|&&
operator|(
name|cnt
operator|<
literal|20
operator|)
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
argument_list|,
literal|"pcmabr"
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_ABORT
argument_list|)
expr_stmt|;
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|missing
operator|=
name|bs
operator|->
name|rl
expr_stmt|;
return|return
name|missing
return|;
block|}
end_function

begin_comment
comment|/*  * this routine tries to flush the dma transfer. It is called  * on a close. We immediately abort any read DMA  * operation, and then wait for the play buffer to drain.  */
end_comment

begin_function
name|int
name|chn_flush
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|count
init|=
literal|50
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_flush c->flags 0x%08x\n"
argument_list|,
name|c
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_CLOSING
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_REC
condition|)
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
while|while
condition|(
operator|!
name|b
operator|->
name|underflow
operator|&&
operator|(
name|count
operator|--
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* still pending output data. */
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmflu"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_flush: now rl = %d, fl = %d\n"
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_flush: tsleep returns %d\n"
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_flush: timeout flushing dbuf_out, cnt 0x%x flags 0x%x\n"
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|c
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_CLOSING
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_reset
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
name|CHN_F_RESET
expr_stmt|;
name|chn_resetbuf
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_reinit
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_INIT
operator|)
operator|&&
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|chn_setformat
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|format
argument_list|)
expr_stmt|;
name|chn_setspeed
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|speed
argument_list|)
expr_stmt|;
name|chn_setvolume
argument_list|(
name|c
argument_list|,
operator|(
name|c
operator|->
name|volume
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|c
operator|->
name|volume
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_INIT
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_init
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
comment|/* Initialize the hardware and DMA buffer first. */
name|c
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|feeder
operator|=
operator|&
name|feeder_root
expr_stmt|;
name|c
operator|->
name|buffer
operator|.
name|chan
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|devinfo
operator|=
name|c
operator|->
name|init
argument_list|(
name|devinfo
argument_list|,
operator|&
name|c
operator|->
name|buffer
argument_list|,
name|c
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|devinfo
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"c->init() failed"
argument_list|)
expr_stmt|;
name|chn_setdir
argument_list|(
name|c
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* And the secondary buffer. */
name|c
operator|->
name|blocksize2nd
operator|=
name|CHN_2NDBUFBLKSIZE
expr_stmt|;
name|c
operator|->
name|fragments
operator|=
name|CHN_2NDBUFBLKNUM
expr_stmt|;
name|bs
operator|->
name|bufsize
operator|=
name|c
operator|->
name|blocksize2nd
operator|*
name|c
operator|->
name|fragments
expr_stmt|;
name|bs
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|bs
operator|->
name|bufsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|buf
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|bzero
argument_list|(
name|bs
operator|->
name|buf
argument_list|,
name|bs
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|bs
operator|->
name|rl
operator|=
name|bs
operator|->
name|rp
operator|=
name|bs
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|fl
operator|=
name|bs
operator|->
name|bufsize
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setdir
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|c
operator|->
name|direction
operator|=
name|dir
expr_stmt|;
name|r
operator|=
name|c
operator|->
name|setdir
argument_list|(
name|c
operator|->
name|devinfo
argument_list|,
name|c
operator|->
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|&&
name|ISA_DMA
argument_list|(
operator|&
name|c
operator|->
name|buffer
argument_list|)
condition|)
name|c
operator|->
name|buffer
operator|.
name|dir
operator|=
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|B_WRITE
else|:
name|B_READ
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|chn_setvolume
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|)
block|{
comment|/* could add a feeder for volume changing if channel returns -1 */
if|if
condition|(
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|c
operator|->
name|volume
operator|=
operator|(
name|left
operator|<<
literal|8
operator|)
operator||
name|right
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setspeed
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|speed
parameter_list|)
block|{
comment|/* could add a feeder for rate conversion */
if|if
condition|(
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|->
name|speed
operator|=
name|c
operator|->
name|setspeed
argument_list|(
name|c
operator|->
name|devinfo
argument_list|,
name|speed
argument_list|)
expr_stmt|;
return|return
name|c
operator|->
name|speed
return|;
block|}
name|c
operator|->
name|speed
operator|=
name|speed
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setformat
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|u_int32_t
name|fmt
parameter_list|)
block|{
if|if
condition|(
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|->
name|hwfmt
operator|=
name|c
operator|->
name|format
operator|=
name|fmt
expr_stmt|;
name|c
operator|->
name|hwfmt
operator|=
name|chn_feedchain
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|chn_resetbuf
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|setformat
argument_list|(
name|c
operator|->
name|devinfo
argument_list|,
name|c
operator|->
name|hwfmt
argument_list|)
expr_stmt|;
return|return
name|fmt
return|;
block|}
name|c
operator|->
name|format
operator|=
name|fmt
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The seconday buffer is modified only during interrupt.  * Hence the size of the secondary buffer can be changed  * at any time as long as an interrupt is disabled.  */
end_comment

begin_function
name|int
name|chn_setblocksize
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|blksz
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|u_int8_t
modifier|*
name|tmpbuf
decl_stmt|;
name|int
name|s
decl_stmt|,
name|tmpbuf_fl
decl_stmt|,
name|tmpbuf_fp
decl_stmt|,
name|l
decl_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_HAS_SIZE
expr_stmt|;
if|if
condition|(
name|blksz
operator|>=
literal|2
condition|)
name|c
operator|->
name|flags
operator||=
name|CHN_F_HAS_SIZE
expr_stmt|;
if|if
condition|(
name|blksz
operator|<
literal|0
condition|)
name|blksz
operator|=
operator|-
name|blksz
expr_stmt|;
if|if
condition|(
name|blksz
operator|<
literal|2
condition|)
name|blksz
operator|=
name|c
operator|->
name|buffer
operator|.
name|sample_size
operator|*
operator|(
name|c
operator|->
name|speed
operator|>>
literal|2
operator|)
expr_stmt|;
comment|/* XXX How small can the lower bound be? */
name|RANGE
argument_list|(
name|blksz
argument_list|,
literal|64
argument_list|,
name|CHN_2NDBUFWHOLESIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a temporary buffer. It holds the pcm data 	 * until the size of the secondary buffer gets changed. 	 * bs->buf is not affected, so mmap should work fine. 	 */
name|tmpbuf
operator|=
name|malloc
argument_list|(
name|blksz
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpbuf
operator|==
name|NULL
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_setblocksize: out of memory."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bzero
argument_list|(
name|tmpbuf
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|tmpbuf_fl
operator|=
name|blksz
expr_stmt|;
name|tmpbuf_fp
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|bs
operator|->
name|rl
operator|>
literal|0
operator|&&
name|tmpbuf_fl
operator|>
literal|0
condition|)
block|{
name|l
operator|=
name|min
argument_list|(
name|min
argument_list|(
name|bs
operator|->
name|rl
argument_list|,
name|bs
operator|->
name|bufsize
operator|-
name|bs
operator|->
name|rp
argument_list|)
argument_list|,
name|tmpbuf_fl
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bs
operator|->
name|buf
operator|+
name|bs
operator|->
name|rp
argument_list|,
name|tmpbuf
operator|+
name|tmpbuf_fp
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|tmpbuf_fl
operator|-=
name|l
expr_stmt|;
name|tmpbuf_fp
operator|=
operator|(
name|tmpbuf_fp
operator|+
name|l
operator|)
operator|%
name|blksz
expr_stmt|;
name|bs
operator|->
name|rl
operator|-=
name|l
expr_stmt|;
name|bs
operator|->
name|fl
operator|+=
name|l
expr_stmt|;
name|bs
operator|->
name|rp
operator|=
operator|(
name|bs
operator|->
name|rp
operator|+
name|l
operator|)
operator|%
name|bs
operator|->
name|bufsize
expr_stmt|;
block|}
comment|/* Change the size of the seconary buffer. */
name|bs
operator|->
name|bufsize
operator|=
name|blksz
expr_stmt|;
name|c
operator|->
name|fragments
operator|=
name|CHN_2NDBUFBLKNUM
expr_stmt|;
name|c
operator|->
name|blocksize2nd
operator|=
name|bs
operator|->
name|bufsize
operator|/
name|c
operator|->
name|fragments
expr_stmt|;
comment|/* Clear the secondary buffer and restore the pcm data. */
name|bzero
argument_list|(
name|bs
operator|->
name|buf
argument_list|,
name|bs
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|bs
operator|->
name|rl
operator|=
name|bs
operator|->
name|bufsize
operator|-
name|tmpbuf_fl
expr_stmt|;
name|bs
operator|->
name|rp
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|fl
operator|=
name|tmpbuf_fl
expr_stmt|;
name|bs
operator|->
name|fp
operator|=
name|tmpbuf_fp
expr_stmt|;
name|bcopy
argument_list|(
name|tmpbuf
argument_list|,
name|bs
operator|->
name|buf
argument_list|,
name|bs
operator|->
name|rl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|c
operator|->
name|blocksize2nd
return|;
block|}
end_function

begin_function
name|int
name|chn_trigger
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|go
parameter_list|)
block|{
return|return
name|c
operator|->
name|trigger
argument_list|(
name|c
operator|->
name|devinfo
argument_list|,
name|go
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|chn_getptr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|hwptr
decl_stmt|;
name|int
name|a
init|=
operator|(
literal|1
operator|<<
name|c
operator|->
name|align
operator|)
operator|-
literal|1
decl_stmt|;
name|hwptr
operator|=
name|c
operator|->
name|getptr
argument_list|(
name|c
operator|->
name|devinfo
argument_list|)
expr_stmt|;
comment|/* don't allow unaligned values in the hwa ptr */
name|hwptr
operator|&=
operator|~
name|a
expr_stmt|;
comment|/* Apply channel align mask */
name|hwptr
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* Apply DMA align mask */
return|return
name|hwptr
return|;
block|}
end_function

begin_function
name|pcmchan_caps
modifier|*
name|chn_getcaps
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
return|return
name|c
operator|->
name|getcaps
argument_list|(
name|c
operator|->
name|devinfo
argument_list|)
return|;
block|}
end_function

end_unit

