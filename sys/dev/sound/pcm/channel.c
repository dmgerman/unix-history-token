begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999 Cameron Grant<gandalf@vilnya.demon.co.uk>  * Portions Copyright by Luigi Rizzo - 1997-99  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_define
define|#
directive|define
name|MIN_CHUNK_SIZE
value|256
end_define

begin_comment
comment|/* for uiomove etc. */
end_comment

begin_define
define|#
directive|define
name|DMA_ALIGN_THRESHOLD
value|4
end_define

begin_define
define|#
directive|define
name|DMA_ALIGN_MASK
value|(~(DMA_ALIGN_THRESHOLD - 1))
end_define

begin_define
define|#
directive|define
name|ISA_DMA
parameter_list|(
name|b
parameter_list|)
value|(((b)->chan>= 0&& (b)->chan != 4&& (b)->chan< 8))
end_define

begin_define
define|#
directive|define
name|CANCHANGE
parameter_list|(
name|c
parameter_list|)
value|(!(c)->buffer.dl)
end_define

begin_define
define|#
directive|define
name|ROUND
parameter_list|(
name|x
parameter_list|)
value|((x)& DMA_ALIGN_MASK)
end_define

begin_comment
comment|/* #define DEB(x) x */
end_comment

begin_function_decl
specifier|static
name|void
name|buf_clear
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|u_int32_t
name|fmt
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chn_dmaupdate
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chn_wrintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chn_rdintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|chn_start
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * SOUND OUTPUT  We use a circular buffer to store samples directed to the DAC. The buffer is split into two variable-size regions, each identified by an offset in the buffer (rp,fp) and a length (rl,fl):        0          rp,rl        fp,fl    bufsize       |__________>____________>________| 	  FREE   d   READY    w FREE    READY: data written from the process and ready to be sent to the DAC;   FREE: free part of the buffer.  Both regions can wrap around the end of the buffer.  At initialization, READY is empty, FREE takes all the available space, and dma is idle.  dl contains the length of the current DMA transfer, dl=0 means that the dma is idle.  The two boundaries (rp,fp) in the buffers are advanced by DMA [d] and write() [w] operations. The first portion of the READY region is used for DMA transfers. The transfer is started at rp and with chunks of length dl. During DMA operations, dsp_wr_dmaupdate() updates rp, rl and fl tracking the ISA DMA engine as the transfer makes progress. When a new block is written, fp advances and rl,fl are updated accordingly.  The code works as follows: the user write routine dsp_write_body() fills up the READY region with new data (reclaiming space from the FREE region) and starts the write DMA engine if inactive.  When a DMA transfer is complete, an interrupt causes dsp_wrintr() to be called which extends the FREE region and possibly starts the next transfer.  In some cases, the code tries to track the current status of DMA operations by calling dsp_wr_dmaupdate() which changes rp, rl and fl.  The system tries to make all DMA transfers use the same size, play_blocksize or rec_blocksize. The size is either selected by the user, or computed by the system to correspond to about .25s of audio. The blocksize must be within a range which is currently:  	min(5ms, 40 bytes) ... 1/2 buffer size.  When there aren't enough data (write) or space (read), a transfer is started with a reduced size.  To reduce problems in case of overruns, the routine which fills up the buffer should initialize (e.g. by repeating the last value) a reasonably long area after the last block so that no noise is produced on overruns.    *   */
end_comment

begin_comment
comment|/* XXX  this is broken: in the event a bounce buffer is used, data never  * gets copied in or out of the real buffer.  fix requires mods to isa_dma.c  * and possibly fixes to other autodma mode clients  */
end_comment

begin_function
specifier|static
name|void
name|chn_isadmabounce
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|ISA_DMA
argument_list|(
operator|&
name|c
operator|->
name|buffer
argument_list|)
condition|)
block|{
comment|/* tell isa_dma to bounce data in/out */
block|}
else|else
name|KASSERT
argument_list|(
literal|1
argument_list|,
operator|(
literal|"chn_isadmabounce called on invalid channel"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|chn_polltrigger
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|unsigned
name|lim
init|=
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_HAS_SIZE
operator|)
condition|?
name|bs
operator|->
name|blksz
else|:
literal|0
decl_stmt|;
name|int
name|trig
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|trig
operator|=
operator|(
operator|(
name|bs
operator|->
name|int_count
operator|>
name|bs
operator|->
name|prev_int_count
operator|)
operator|||
name|bs
operator|->
name|prev_int_count
operator|==
literal|0
operator|)
expr_stmt|;
else|else
name|trig
operator|=
operator|(
operator|(
operator|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|bs
operator|->
name|fl
else|:
name|bs
operator|->
name|rl
operator|)
operator|>
name|lim
operator|)
expr_stmt|;
return|return
name|trig
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chn_pollreset
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|bs
operator|->
name|prev_int_count
operator|=
name|bs
operator|->
name|int_count
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * chn_dmadone() updates pointers and wakes up any process waiting  * on a select(). Must be called at spltty().  */
end_comment

begin_function
specifier|static
name|void
name|chn_dmadone
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISA_DMA
argument_list|(
name|b
argument_list|)
condition|)
name|chn_isadmabounce
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* sync bounce buffer */
name|b
operator|->
name|int_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chn_dmawakeup() wakes up any process sleeping. Separated from  * chn_dmadone() so that wakeup occurs only when feed from a  * secondary buffer to a DMA buffer takes place. Must be called  * at spltty().  */
end_comment

begin_function
specifier|static
name|void
name|chn_dmawakeup
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|wakeup
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chn_dmaupdate() tracks the status of a dma transfer,  * updating pointers. It must be called at spltty().  *  * NOTE: when we are using auto dma in the device, rl might become  * negative.  */
end_comment

begin_macro
name|DEB
argument_list|(
argument|static int chn_updatecount=
literal|0
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|chn_dmaupdate
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|hwptr
decl_stmt|;
name|DEB
argument_list|(
argument|int b_rl=b->rl; int b_fl=b->fl; int b_rp=b->rp; int b_fp=b->fp
argument_list|)
empty_stmt|;
name|hwptr
operator|=
name|chn_getptr
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|delta
operator|=
operator|(
name|b
operator|->
name|bufsize
operator|+
name|hwptr
operator|-
name|b
operator|->
name|rp
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|rp
operator|=
name|hwptr
expr_stmt|;
name|b
operator|->
name|rl
operator|-=
name|delta
expr_stmt|;
name|b
operator|->
name|fl
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|rl
operator|<
literal|0
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"OUCH!(%d) rl %d(%d) delta %d bufsize %d hwptr %d rp %d(%d)\n"
argument_list|,
name|chn_updatecount
operator|++
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b_rl
argument_list|,
name|delta
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|hwptr
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b_rp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|delta
operator|=
operator|(
name|b
operator|->
name|bufsize
operator|+
name|hwptr
operator|-
name|b
operator|->
name|fp
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|fp
operator|=
name|hwptr
expr_stmt|;
name|b
operator|->
name|rl
operator|+=
name|delta
expr_stmt|;
name|b
operator|->
name|fl
operator|-=
name|delta
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|fl
operator|<
literal|0
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"OUCH!(%d) fl %d(%d) delta %d bufsize %d hwptr %d fp %d(%d)\n"
argument_list|,
name|chn_updatecount
operator|++
argument_list|,
name|b
operator|->
name|fl
argument_list|,
name|b_fl
argument_list|,
name|delta
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|hwptr
argument_list|,
name|b
operator|->
name|fp
argument_list|,
name|b_fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|->
name|total
operator|+=
name|delta
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check channel for underflow occured. Reset DMA buffer in case of  * underflow, so that new data can go into the buffer. It must be  * called at spltty().  */
end_comment

begin_function
name|void
name|chn_checkunderflow
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|underflow
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"Clear underflow condition\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * The DMA keeps running even after underflow occurs. 		 * Hence the value returned by chn_getptr() here soon 		 * gets a lag when we get back to chn_write(). Although 		 * there are no easy and precise methods to figure out 		 * the lag, a quarter of b->bufsize would be a fair 		 * choice, provided that a DMA interrupt generates upon 		 * each transfer of a half b->bufsize. 		 */
name|b
operator|->
name|rp
operator|=
name|chn_getptr
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|b
operator|->
name|fp
operator|=
operator|(
name|b
operator|->
name|rp
operator|+
name|b
operator|->
name|bufsize
operator|/
literal|4
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|rl
operator|=
name|b
operator|->
name|bufsize
operator|/
literal|4
expr_stmt|;
name|b
operator|->
name|fl
operator|=
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|rl
expr_stmt|;
name|b
operator|->
name|underflow
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* chn_dmaupdate(c); */
block|}
block|}
end_function

begin_comment
comment|/*  * Feeds new data to the write dma buffer. Can be called in the bottom half.  * Hence must be called at spltty.  */
end_comment

begin_function
name|int
name|chn_wrfeed
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|a
decl_stmt|,
name|l
decl_stmt|,
name|lacc
decl_stmt|;
comment|/* ensure we always have a whole number of samples */
name|a
operator|=
operator|(
literal|1
operator|<<
name|c
operator|->
name|align
operator|)
operator|-
literal|1
expr_stmt|;
name|lacc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
block|{
name|bs
operator|->
name|rl
operator|=
name|min
argument_list|(
name|b
operator|->
name|blksz
argument_list|,
name|b
operator|->
name|fl
argument_list|)
expr_stmt|;
name|bs
operator|->
name|fl
operator|=
literal|0
expr_stmt|;
name|a
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	printf("b: [rl: %d, rp %d, fl %d, fp %d]; bs: [rl: %d, rp %d, fl %d, fp %d]\n", 		b->rl, b->rp, b->fl, b->fp, bs->rl, bs->rp, bs->fl, bs->fp); 	*/
comment|/* Don't allow write unaligned data */
while|while
condition|(
name|bs
operator|->
name|rl
operator|>
name|a
operator|&&
name|b
operator|->
name|fl
operator|>
name|a
condition|)
block|{
comment|/* ensure we always have a whole number of samples */
name|l
operator|=
name|min
argument_list|(
name|min
argument_list|(
name|bs
operator|->
name|rl
argument_list|,
name|bs
operator|->
name|bufsize
operator|-
name|bs
operator|->
name|rp
argument_list|)
argument_list|,
name|min
argument_list|(
name|b
operator|->
name|fl
argument_list|,
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|fp
argument_list|)
argument_list|)
operator|&
operator|~
name|a
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
name|lacc
return|;
comment|/* Move the samples, update the markers and pointers. */
name|bcopy
argument_list|(
name|bs
operator|->
name|buf
operator|+
name|bs
operator|->
name|rp
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|fp
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|bs
operator|->
name|fl
operator|+=
name|l
expr_stmt|;
name|bs
operator|->
name|rl
operator|-=
name|l
expr_stmt|;
name|bs
operator|->
name|rp
operator|=
operator|(
name|bs
operator|->
name|rp
operator|+
name|l
operator|)
operator|%
name|bs
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|rl
operator|+=
name|l
expr_stmt|;
name|b
operator|->
name|fl
operator|-=
name|l
expr_stmt|;
name|b
operator|->
name|fp
operator|=
operator|(
name|b
operator|->
name|fp
operator|+
name|l
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
comment|/* Clear the new space in the secondary buffer. */
name|buf_clear
argument_list|(
name|bs
argument_list|,
name|bs
operator|->
name|fmt
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Accumulate the total bytes of the moved samples. */
name|lacc
operator|+=
name|l
expr_stmt|;
comment|/* A feed to the DMA buffer is equivalent to an interrupt. */
name|bs
operator|->
name|total
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
block|{
if|if
condition|(
name|bs
operator|->
name|total
operator|-
name|bs
operator|->
name|prev_total
operator|>=
name|bs
operator|->
name|blksz
condition|)
block|{
name|bs
operator|->
name|prev_total
operator|=
name|bs
operator|->
name|total
expr_stmt|;
name|bs
operator|->
name|int_count
operator|++
expr_stmt|;
name|c
operator|->
name|blocks
operator|++
expr_stmt|;
block|}
block|}
else|else
name|bs
operator|->
name|int_count
operator|++
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|sel
operator|.
name|si_pid
operator|&&
name|chn_polltrigger
argument_list|(
name|c
argument_list|)
condition|)
name|selwakeup
argument_list|(
operator|&
name|bs
operator|->
name|sel
argument_list|)
expr_stmt|;
block|}
return|return
name|lacc
return|;
block|}
end_function

begin_comment
comment|/* Feeds new data to the secondary write buffer. */
end_comment

begin_function
specifier|static
name|int
name|chn_wrfeed2nd
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|l
decl_stmt|,
name|w
decl_stmt|,
name|wacc
decl_stmt|;
comment|/* The DMA buffer may have some space. */
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* ensure we always have a whole number of samples */
name|wacc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|bs
operator|->
name|fl
operator|>
literal|0
condition|)
block|{
comment|/* 		 * The size of the data to move here does not have to be 		 * aligned. We take care of it upon moving the data to a 		 * DMA buffer. 		 */
name|l
operator|=
name|min
argument_list|(
name|bs
operator|->
name|fl
argument_list|,
name|bs
operator|->
name|bufsize
operator|-
name|bs
operator|->
name|fp
argument_list|)
expr_stmt|;
comment|/* Move the samples, update the markers and pointers. */
name|w
operator|=
name|c
operator|->
name|feeder
operator|->
name|feed
argument_list|(
name|c
operator|->
name|feeder
argument_list|,
name|c
argument_list|,
name|bs
operator|->
name|buf
operator|+
name|bs
operator|->
name|fp
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"no feed"
argument_list|)
expr_stmt|;
name|bs
operator|->
name|rl
operator|+=
name|w
expr_stmt|;
name|bs
operator|->
name|fl
operator|-=
name|w
expr_stmt|;
name|bs
operator|->
name|fp
operator|=
operator|(
name|bs
operator|->
name|fp
operator|+
name|w
operator|)
operator|%
name|bs
operator|->
name|bufsize
expr_stmt|;
comment|/* Accumulate the total bytes of the moved samples. */
name|wacc
operator|+=
name|w
expr_stmt|;
comment|/* If any pcm data gets moved, push it to the DMA buffer. */
if|if
condition|(
name|w
operator|>
literal|0
condition|)
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
block|}
return|return
name|wacc
return|;
block|}
end_function

begin_comment
comment|/*  * Write interrupt routine. Can be called from other places (e.g.  * to start a paused transfer), but with interrupts disabled.  */
end_comment

begin_function
specifier|static
name|void
name|chn_wrintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|underflow
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
operator|)
condition|)
block|{
comment|/*		printf("underflow return\n"); */
return|return;
comment|/* nothing new happened */
block|}
if|if
condition|(
name|b
operator|->
name|dl
condition|)
name|chn_dmadone
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * start another dma operation only if have ready data in the buffer, 	 * there is no pending abort, have a full-duplex device, or have a 	 * half duplex device and there is no pending op on the other side. 	 * 	 * Force transfers to be aligned to a boundary of 4, which is 	 * needed when doing stereo and 16-bit. 	 */
comment|/* Check underflow and update the pointers. */
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * Fill up the DMA buffer, followed by waking up the top half. 	 * If some of the pcm data in uio are still left, the top half 	 * goes to sleep by itself. 	 */
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
name|buf_clear
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|fmt
argument_list|,
name|b
operator|->
name|fl
argument_list|)
expr_stmt|;
block|}
name|chn_dmawakeup
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
condition|)
block|{
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 	 * check if we need to reprogram the DMA on the sound card. 	 	 * This happens if the size has changed from zero 	 	 */
if|if
condition|(
name|b
operator|->
name|dl
operator|==
literal|0
condition|)
block|{
comment|/* Start DMA operation */
name|b
operator|->
name|dl
operator|=
name|b
operator|->
name|blksz
expr_stmt|;
comment|/* record new transfer size */
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_START
argument_list|)
expr_stmt|;
block|}
comment|/*  		 * Emulate writing by DMA, i.e. transfer the pcm data from  		 * the emulated-DMA buffer to the device itself.  		 */
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_EMLDMAWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|rl
operator|<
name|b
operator|->
name|dl
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"near underflow (%d< %d), %d\n"
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * we are near to underflow condition, so to prevent 			 * audio 'clicks' clear next b->fl bytes 			 */
name|buf_clear
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|fmt
argument_list|,
name|b
operator|->
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|rl
operator|<
name|DMA_ALIGN_THRESHOLD
condition|)
name|b
operator|->
name|underflow
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* cannot start a new dma transfer */
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"underflow, flags 0x%08x rp %d rl %d\n"
argument_list|,
name|c
operator|->
name|flags
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b
operator|->
name|rl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
comment|/* DMA was active */
name|b
operator|->
name|underflow
operator|=
literal|1
expr_stmt|;
comment|/* set underflow flag */
name|buf_clear
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|fmt
argument_list|,
name|b
operator|->
name|bufsize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * user write routine  *  * advance the boundary between READY and FREE, fill the space with  * uiomove(), and possibly start DMA. Do the above until the transfer  * is complete.  *  * To minimize latency in case a pending DMA transfer is about to end,  * we do the transfer in pieces of increasing sizes, extending the  * READY area at every checkpoint. In the (necessary) assumption that  * memory bandwidth is larger than the rate at which the dma consumes  * data, we reduce the latency to something proportional to the length  * of the first piece, while keeping the overhead low and being able  * to feed the DMA with large blocks.  */
end_comment

begin_function
name|int
name|chn_write
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|timeout
decl_stmt|,
name|res
decl_stmt|,
name|newsize
decl_stmt|;
name|long
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_WRITING
condition|)
block|{
comment|/* This shouldn't happen and is actually silly 		 * - will never wake up, just timeout; why not sleep on b? 		 */
name|tsleep
argument_list|(
operator|&
name|s
argument_list|,
name|PZERO
argument_list|,
literal|"pcmwrW"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|c
operator|->
name|flags
operator||=
name|CHN_F_WRITING
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_ABORTING
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* 	 * XXX Certain applications attempt to write larger size 	 * of pcm data than c->blocksize2nd without blocking, 	 * resulting partial write. Expand the block size so that 	 * the write operation avoids blocking. 	 */
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_NBIO
operator|)
operator|&&
name|buf
operator|->
name|uio_resid
operator|>
name|bs
operator|->
name|blksz
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"pcm warning: broken app, nbio and tried to write %d bytes with fragsz %d\n"
argument_list|,
name|buf
operator|->
name|uio_resid
argument_list|,
name|bs
operator|->
name|blksz
argument_list|)
argument_list|)
expr_stmt|;
name|newsize
operator|=
literal|16
expr_stmt|;
while|while
condition|(
name|newsize
operator|<
name|min
argument_list|(
name|buf
operator|->
name|uio_resid
argument_list|,
name|CHN_2NDBUFMAXSIZE
operator|/
literal|2
argument_list|)
condition|)
name|newsize
operator|<<=
literal|1
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|c
argument_list|,
name|bs
operator|->
name|blkcnt
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"pcm warning: frags reset to %d x %d\n"
argument_list|,
name|bs
operator|->
name|blkcnt
argument_list|,
name|bs
operator|->
name|blksz
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Store the initial size in the uio. */
name|res
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
comment|/* 	 * Fill up the secondary and DMA buffer. 	 * chn_wrfeed*() takes care of the alignment. 	 */
comment|/* Check for underflow before writing into the buffers. */
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_wrfeed2nd
argument_list|(
name|c
argument_list|,
name|buf
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_NBIO
operator|)
operator|&&
operator|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
operator|)
condition|)
name|ret
operator|=
name|EAGAIN
expr_stmt|;
comment|/* Start playing if not yet. */
if|if
condition|(
operator|!
name|b
operator|->
name|dl
condition|)
name|chn_start
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* Wait until all samples are played in blocking mode. */
while|while
condition|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
comment|/* Check for underflow before writing into the buffers. */
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Fill up the buffers with new pcm data. */
while|while
condition|(
name|chn_wrfeed2nd
argument_list|(
name|c
argument_list|,
name|buf
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* Have we finished to feed the secondary buffer? */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
literal|0
condition|)
break|break;
comment|/* Wait for new free space to write new pcm samples. */
comment|/* splx(s); */
name|timeout
operator|=
literal|1
expr_stmt|;
comment|/*(buf->uio_resid>= b->dl)? hz / 20 : 1; */
name|ret
operator|=
name|tsleep
argument_list|(
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmwr"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|/* s = spltty(); */
comment|/* if (ret == EINTR) chn_abort(c); */
if|if
condition|(
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
condition|)
break|break;
block|}
block|}
else|else
name|ret
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_WRITING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * SOUND INPUT  *  The input part is similar to the output one, with a circular buffer split in two regions, and boundaries advancing because of read() calls [r] or dma operation [d].  At initialization, as for the write routine, READY is empty, and FREE takes all the space.        0          rp,rl        fp,fl    bufsize       |__________>____________>________| 	  FREE   r   READY    d  FREE  Operation is as follows: upon user read (dsp_read_body()) a DMA read is started if not already active (marked by b->dl> 0), then as soon as data are available in the READY region they are transferred to the user buffer, thus advancing the boundary between FREE and READY. Upon interrupts, caused by a completion of a DMA transfer, the READY region is extended and possibly a new transfer is started.  When necessary, dsp_rd_dmaupdate() is called to advance fp (and update rl,fl accordingly). Upon user reads, rp is advanced and rl,fl are updated accordingly.  The rules to choose the size of the new DMA area are similar to the other case, with a preferred constant transfer size equal to rec_blocksize, and fallback to smaller sizes if no space is available.   */
end_comment

begin_function
specifier|static
name|int
name|chn_rddump
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|printf
argument_list|(
literal|"overrun, dumping %d bytes\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|b
operator|->
name|rl
operator|-=
name|cnt
expr_stmt|;
name|b
operator|->
name|fl
operator|+=
name|cnt
expr_stmt|;
name|b
operator|->
name|rp
operator|=
operator|(
name|b
operator|->
name|rp
operator|+
name|cnt
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function

begin_comment
comment|/*  * Feed new data from the read buffer. Can be called in the bottom half.  * Hence must be called at spltty.  */
end_comment

begin_function
name|int
name|chn_rdfeed
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|l
decl_stmt|,
name|lacc
decl_stmt|;
comment|/* 	printf("b: [rl: %d, rp %d, fl %d, fp %d]; bs: [rl: %d, rp %d, fl %d, fp %d]\n", 		b->rl, b->rp, b->fl, b->fp, bs->rl, bs->rp, bs->fl, bs->fp); 	 */
comment|/* ensure we always have a whole number of samples */
name|lacc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bs
operator|->
name|fl
operator|>=
name|DMA_ALIGN_THRESHOLD
operator|&&
name|b
operator|->
name|rl
operator|>=
name|DMA_ALIGN_THRESHOLD
condition|)
block|{
name|l
operator|=
name|min
argument_list|(
name|min
argument_list|(
name|bs
operator|->
name|fl
argument_list|,
name|bs
operator|->
name|bufsize
operator|-
name|bs
operator|->
name|fp
argument_list|)
argument_list|,
name|min
argument_list|(
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|rp
argument_list|)
argument_list|)
operator|&
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* Move the samples, update the markers and pointers. */
name|bcopy
argument_list|(
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|rp
argument_list|,
name|bs
operator|->
name|buf
operator|+
name|bs
operator|->
name|fp
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|bs
operator|->
name|fl
operator|-=
name|l
expr_stmt|;
name|bs
operator|->
name|rl
operator|+=
name|l
expr_stmt|;
name|bs
operator|->
name|fp
operator|=
operator|(
name|bs
operator|->
name|fp
operator|+
name|l
operator|)
operator|%
name|bs
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|rl
operator|-=
name|l
expr_stmt|;
name|b
operator|->
name|fl
operator|+=
name|l
expr_stmt|;
name|b
operator|->
name|rp
operator|=
operator|(
name|b
operator|->
name|rp
operator|+
name|l
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
comment|/* Accumulate the total bytes of the moved samples. */
name|lacc
operator|+=
name|l
expr_stmt|;
comment|/* A feed from the DMA buffer is equivalent to an interrupt. */
name|bs
operator|->
name|int_count
operator|++
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|sel
operator|.
name|si_pid
operator|&&
name|chn_polltrigger
argument_list|(
name|c
argument_list|)
condition|)
name|selwakeup
argument_list|(
operator|&
name|bs
operator|->
name|sel
argument_list|)
expr_stmt|;
block|}
return|return
name|lacc
return|;
block|}
end_function

begin_comment
comment|/* Feeds new data from the secondary read buffer. */
end_comment

begin_function
specifier|static
name|int
name|chn_rdfeed2nd
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|l
decl_stmt|,
name|w
decl_stmt|,
name|wacc
decl_stmt|;
comment|/* ensure we always have a whole number of samples */
name|wacc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
operator|)
operator|&&
operator|(
name|bs
operator|->
name|rl
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* The DMA buffer may have pcm data. */
comment|/* while (chn_rdfeed(c)> 0); */
comment|/* 		 * The size of the data to move here does not have to be 		 * aligned. We take care of it upon moving the data to a 		 * DMA buffer. 		 */
name|l
operator|=
name|min
argument_list|(
name|bs
operator|->
name|rl
argument_list|,
name|bs
operator|->
name|bufsize
operator|-
name|bs
operator|->
name|rp
argument_list|)
expr_stmt|;
comment|/* Move the samples, update the markers and pointers. */
name|w
operator|=
name|c
operator|->
name|feeder
operator|->
name|feed
argument_list|(
name|c
operator|->
name|feeder
argument_list|,
name|c
argument_list|,
name|bs
operator|->
name|buf
operator|+
name|bs
operator|->
name|rp
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"no feed"
argument_list|)
expr_stmt|;
name|bs
operator|->
name|fl
operator|+=
name|w
expr_stmt|;
name|bs
operator|->
name|rl
operator|-=
name|w
expr_stmt|;
name|bs
operator|->
name|rp
operator|=
operator|(
name|bs
operator|->
name|rp
operator|+
name|w
operator|)
operator|%
name|bs
operator|->
name|bufsize
expr_stmt|;
comment|/* Clear the new space in the secondary buffer. */
name|buf_clear
argument_list|(
name|bs
argument_list|,
name|bs
operator|->
name|fmt
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Accumulate the total bytes of the moved samples. */
name|bs
operator|->
name|total
operator|+=
name|w
expr_stmt|;
name|wacc
operator|+=
name|w
expr_stmt|;
block|}
return|return
name|wacc
return|;
block|}
end_function

begin_comment
comment|/* read interrupt routine. Must be called with interrupts blocked. */
end_comment

begin_function
specifier|static
name|void
name|chn_rdintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
name|chn_dmadone
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"rdintr: start dl %d, rp:rl %d:%d, fp:fl %d:%d\n"
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|fp
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the pointers. */
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * Suck up the DMA buffer, followed by waking up the top half. 	 * If some of the pcm data in the secondary buffer are still left, 	 * the top half goes to sleep by itself. 	 */
while|while
condition|(
name|chn_rdfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
name|chn_dmawakeup
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|fl
operator|<
name|b
operator|->
name|dl
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"near overflow (%d< %d), %d\n"
argument_list|,
name|b
operator|->
name|fl
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|b
operator|->
name|rl
argument_list|)
argument_list|)
expr_stmt|;
name|chn_rddump
argument_list|(
name|c
argument_list|,
name|b
operator|->
name|blksz
operator|-
name|b
operator|->
name|fl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
condition|)
block|{
comment|/* 	 	 * check if we need to reprogram the DMA on the sound card. 	 	 * This happens if the size has changed from zero 	 	 */
if|if
condition|(
name|b
operator|->
name|dl
operator|==
literal|0
condition|)
block|{
comment|/* Start DMA operation */
name|b
operator|->
name|dl
operator|=
name|b
operator|->
name|blksz
expr_stmt|;
comment|/* record new transfer size */
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_START
argument_list|)
expr_stmt|;
block|}
comment|/*  		 * Emulate writing by DMA, i.e. transfer the pcm data from  		 * the emulated-DMA buffer to the device itself.  		 */
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_EMLDMARD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
comment|/* was active */
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_STOP
argument_list|)
expr_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * body of user-read routine  *  * Start DMA if not active; wait for READY not empty.  * Transfer data from READY region using uiomove(), advance boundary  * between FREE and READY. Repeat until transfer is complete.  *  * To avoid excessive latency in freeing up space for the DMA  * engine, transfers are done in blocks of increasing size, so that  * the latency is proportional to the size of the smallest block, but  * we have a low overhead and are able to feed the dma engine with  * large blocks.  *  * NOTE: in the current version, read will not return more than  * blocksize bytes at once (unless more are already available), to  * avoid that requests using very large buffers block for too long.  */
end_comment

begin_function
name|int
name|chn_read
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|timeout
decl_stmt|,
name|limit
decl_stmt|,
name|res
decl_stmt|;
name|long
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_READING
condition|)
block|{
comment|/* This shouldn't happen and is actually silly */
name|tsleep
argument_list|(
operator|&
name|s
argument_list|,
name|PZERO
argument_list|,
literal|"pcmrdR"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* Store the initial size in the uio. */
name|res
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_READING
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_ABORTING
expr_stmt|;
comment|/* suck up the DMA and secondary buffers. */
while|while
condition|(
name|chn_rdfeed2nd
argument_list|(
name|c
argument_list|,
name|buf
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
literal|0
condition|)
goto|goto
name|skip
goto|;
name|limit
operator|=
name|res
operator|-
name|b
operator|->
name|blksz
expr_stmt|;
if|if
condition|(
name|limit
operator|<
literal|0
condition|)
name|limit
operator|=
literal|0
expr_stmt|;
comment|/* Start capturing if not yet. */
if|if
condition|(
operator|(
operator|!
name|bs
operator|->
name|rl
operator|||
operator|!
name|b
operator|->
name|rl
operator|)
operator|&&
operator|!
name|b
operator|->
name|dl
condition|)
name|chn_start
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_NBIO
operator|)
condition|)
block|{
comment|/* Wait until all samples are captured. */
while|while
condition|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
comment|/* Suck up the DMA and secondary buffers. */
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_rdfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
while|while
condition|(
name|chn_rdfeed2nd
argument_list|(
name|c
argument_list|,
name|buf
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* Have we finished to feed the uio? */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
literal|0
condition|)
break|break;
comment|/* Wait for new pcm samples. */
comment|/* splx(s); */
name|timeout
operator|=
operator|(
name|buf
operator|->
name|uio_resid
operator|-
name|limit
operator|>=
name|b
operator|->
name|dl
operator|)
condition|?
name|hz
operator|/
literal|20
else|:
literal|1
expr_stmt|;
name|ret
operator|=
name|tsleep
argument_list|(
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmrd"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* s = spltty(); */
comment|/* if (ret == EINTR) chn_abort(c); */
if|if
condition|(
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
condition|)
break|break;
block|}
block|}
else|else
block|{
comment|/* If no pcm data was read on nonblocking, return EAGAIN. */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
name|res
condition|)
name|ret
operator|=
name|EAGAIN
expr_stmt|;
block|}
name|skip
label|:
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_READING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|chn_intr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_INIT
condition|)
name|chn_reinit
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
name|chn_wrintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|chn_rdintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|chn_start
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|u_int32_t
name|r
decl_stmt|,
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
operator|==
literal|0
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
operator|(
name|CHN_F_MAPPED
operator||
name|CHN_F_NOTRIGGER
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
block|{
comment|/* Fill up the DMA buffer. */
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|b
operator|->
name|rl
operator|>=
name|b
operator|->
name|blksz
condition|)
name|r
operator|=
name|CHN_F_TRIGGERED
expr_stmt|;
block|}
else|else
block|{
comment|/* Suck up the DMA buffer. */
while|while
condition|(
name|chn_rdfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|b
operator|->
name|fl
operator|>=
name|b
operator|->
name|blksz
condition|)
name|r
operator|=
name|CHN_F_TRIGGERED
expr_stmt|;
block|}
name|c
operator|->
name|flags
operator||=
name|r
expr_stmt|;
name|chn_intr
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|chn_dma_setmap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|(
name|snd_dbuf
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"pcm: setmap %lx, %lx; "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%p -> %lx\n"
argument_list|,
name|b
operator|->
name|buf
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vtophys
argument_list|(
name|b
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate memory for DMA buffer. If the device do not perform DMA transfer,  * the drvier can call malloc(9) by its own.  */
end_comment

begin_function
name|int
name|chn_allocbuf
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|bus_dma_tag_t
name|parent_dmat
parameter_list|)
block|{
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|parent_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|b
operator|->
name|buf
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|b
operator|->
name|dmamap
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|parent_dmat
argument_list|,
name|b
operator|->
name|dmamap
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|chn_dma_setmap
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|buf_clear
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|u_int32_t
name|fmt
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
name|data
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|fmt
operator|&
name|AFMT_SIGNED
condition|)
name|data
operator|=
literal|0x00
expr_stmt|;
else|else
name|data
operator|=
literal|0x80
expr_stmt|;
if|if
condition|(
name|fmt
operator|&
name|AFMT_16BIT
condition|)
name|data
operator|<<=
literal|8
expr_stmt|;
else|else
name|data
operator||=
name|data
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|fmt
operator|&
name|AFMT_BIGENDIAN
condition|)
name|data
operator|=
operator|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
operator|)
operator||
operator|(
operator|(
name|data
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
expr_stmt|;
name|i
operator|=
name|b
operator|->
name|fp
expr_stmt|;
name|p
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|fp
operator|)
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|1
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|data
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|b
operator|->
name|bufsize
condition|)
block|{
name|p
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|b
operator|->
name|buf
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|length
operator|==
literal|1
condition|)
operator|*
operator|(
name|b
operator|->
name|buf
operator|+
name|i
operator|)
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
name|void
name|chn_resetbuf
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|c
operator|->
name|blocks
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|rp
operator|=
name|b
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|dl
operator|=
name|b
operator|->
name|rl
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|fl
operator|=
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|prev_total
operator|=
name|b
operator|->
name|total
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|prev_int_count
operator|=
name|b
operator|->
name|int_count
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|underflow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|buf
operator|&&
name|b
operator|->
name|bufsize
operator|>
literal|0
condition|)
name|buf_clear
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|fmt
argument_list|,
name|b
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|bs
operator|->
name|rp
operator|=
name|bs
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|dl
operator|=
name|bs
operator|->
name|rl
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|fl
operator|=
name|bs
operator|->
name|bufsize
expr_stmt|;
name|bs
operator|->
name|prev_total
operator|=
name|bs
operator|->
name|total
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|prev_int_count
operator|=
name|bs
operator|->
name|int_count
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|underflow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|buf
operator|&&
name|bs
operator|->
name|bufsize
operator|>
literal|0
condition|)
name|buf_clear
argument_list|(
name|bs
argument_list|,
name|bs
operator|->
name|fmt
argument_list|,
name|bs
operator|->
name|bufsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|buf_isadma
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|int
name|go
parameter_list|)
block|{
if|if
condition|(
name|ISA_DMA
argument_list|(
name|b
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"buf 0x%p ISA DMA started\n"
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|isa_dmastart
argument_list|(
name|b
operator|->
name|dir
operator||
name|ISADMA_RAW
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_STOP
case|:
case|case
name|PCMTRIG_ABORT
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"buf 0x%p ISA DMA stopped\n"
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|isa_dmastop
argument_list|(
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
name|isa_dmadone
argument_list|(
name|b
operator|->
name|dir
operator||
name|ISADMA_RAW
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|KASSERT
argument_list|(
literal|1
argument_list|,
operator|(
literal|"buf_isadma called on invalid channel"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|buf_isadmaptr
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|ISA_DMA
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|b
operator|->
name|dl
condition|?
name|isa_dmastatus
argument_list|(
name|b
operator|->
name|chan
argument_list|)
else|:
name|b
operator|->
name|bufsize
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
return|return
name|b
operator|->
name|bufsize
operator|-
name|i
return|;
block|}
else|else
name|KASSERT
argument_list|(
literal|1
argument_list|,
operator|(
literal|"buf_isadmaptr called on invalid channel"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * chn_sync waits until the space in the given channel goes above  * a threshold. The threshold is checked against fl or rl respectively.  * Assume that the condition can become true, do not check here...  */
end_comment

begin_function
name|int
name|chn_sync
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|threshold
parameter_list|)
block|{
name|u_long
name|s
decl_stmt|,
name|rdy
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
name|rdy
operator|=
operator|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|bs
operator|->
name|fl
else|:
name|bs
operator|->
name|rl
expr_stmt|;
if|if
condition|(
name|rdy
operator|<=
name|threshold
condition|)
block|{
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmsyn"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ERESTART
operator|||
name|ret
operator|==
name|EINTR
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_sync: tsleep returns %d\n"
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_poll
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|ev
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|u_long
name|s
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
block|{
comment|/* Fill up the DMA buffer. */
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
block|}
else|else
block|{
comment|/* Suck up the DMA buffer. */
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_rdfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
block|}
if|if
condition|(
operator|!
name|b
operator|->
name|dl
condition|)
name|chn_start
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chn_polltrigger
argument_list|(
name|c
argument_list|)
operator|&&
name|chn_pollreset
argument_list|(
name|c
argument_list|)
condition|)
name|ret
operator|=
name|ev
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|bs
operator|->
name|sel
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * chn_abort is a non-blocking function which aborts a pending  * DMA transfer and flushes the buffers.  * It returns the number of bytes that have not been transferred.  */
end_comment

begin_function
name|int
name|chn_abort
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|missing
init|=
literal|0
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|dl
condition|)
return|return
literal|0
return|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_ABORTING
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_TRIGGERED
expr_stmt|;
name|cnt
operator|=
literal|10
expr_stmt|;
while|while
condition|(
operator|!
name|b
operator|->
name|underflow
operator|&&
operator|(
name|cnt
operator|--
operator|>
literal|0
operator|)
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmabr"
argument_list|,
name|hz
operator|/
literal|50
argument_list|)
expr_stmt|;
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_ABORT
argument_list|)
expr_stmt|;
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|missing
operator|=
name|bs
operator|->
name|rl
operator|+
name|b
operator|->
name|rl
expr_stmt|;
return|return
name|missing
return|;
block|}
end_function

begin_comment
comment|/*  * this routine tries to flush the dma transfer. It is called  * on a close. We immediately abort any read DMA  * operation, and then wait for the play buffer to drain.  */
end_comment

begin_function
name|int
name|chn_flush
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|count
decl_stmt|,
name|s
decl_stmt|,
name|resid
decl_stmt|,
name|resid_p
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_flush c->flags 0x%08x\n"
argument_list|,
name|c
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_CLOSING
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_REC
condition|)
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
name|resid_p
operator|=
name|resid
operator|=
name|b
operator|->
name|rl
operator|+
name|bs
operator|->
name|rl
expr_stmt|;
name|count
operator|=
literal|10
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|resid
operator|>
literal|0
operator|)
operator|&&
operator|!
name|b
operator|->
name|underflow
condition|)
block|{
comment|/* still pending output data. */
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmflu"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_flush: tsleep returns %d\n"
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_flush: now rl = %d, fl = %d\n"
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
name|resid
operator|=
name|b
operator|->
name|rl
operator|+
name|bs
operator|->
name|rl
expr_stmt|;
if|if
condition|(
name|resid
operator|>=
name|resid_p
condition|)
name|count
operator|--
expr_stmt|;
name|resid_p
operator|=
name|resid
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_flush: timeout flushing dbuf_out, cnt 0x%x flags 0x%x\n"
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|c
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
operator|&&
name|b
operator|->
name|dl
condition|)
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_CLOSING
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_reset
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|u_int32_t
name|fmt
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
name|CHN_F_RESET
expr_stmt|;
name|r
operator|=
name|chn_setblocksize
argument_list|(
name|c
argument_list|,
name|CHN_2NDBUFBLKNUM
argument_list|,
name|CHN_2NDBUFBLKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
if|if
condition|(
name|fmt
condition|)
block|{
name|r
operator|=
name|chn_setformat
argument_list|(
name|c
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|r
operator|=
name|chn_setspeed
argument_list|(
name|c
argument_list|,
name|DSP_DEFAULT_SPEED
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|r
operator|=
name|chn_setvolume
argument_list|(
name|c
argument_list|,
literal|100
argument_list|,
literal|100
argument_list|)
expr_stmt|;
block|}
name|chn_resetbuf
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* c->flags |= CHN_F_INIT; */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_reinit
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_INIT
operator|)
operator|&&
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|chn_setformat
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|format
argument_list|)
expr_stmt|;
name|chn_setspeed
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|speed
argument_list|)
expr_stmt|;
name|chn_setvolume
argument_list|(
name|c
argument_list|,
operator|(
name|c
operator|->
name|volume
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|c
operator|->
name|volume
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_INIT
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_init
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
comment|/* Initialize the hardware and DMA buffer first. */
name|c
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|feeder
operator|=
operator|&
name|feeder_root
expr_stmt|;
name|c
operator|->
name|buffer
operator|.
name|chan
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|devinfo
operator|=
name|c
operator|->
name|init
argument_list|(
name|devinfo
argument_list|,
operator|&
name|c
operator|->
name|buffer
argument_list|,
name|c
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|devinfo
operator|==
name|NULL
operator|||
name|c
operator|->
name|buffer
operator|.
name|bufsize
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|chn_setdir
argument_list|(
name|c
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* And the secondary buffer. */
name|bs
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|bs
operator|->
name|bufsize
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setdir
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|c
operator|->
name|direction
operator|=
name|dir
expr_stmt|;
name|r
operator|=
name|c
operator|->
name|setdir
argument_list|(
name|c
operator|->
name|devinfo
argument_list|,
name|c
operator|->
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|&&
name|ISA_DMA
argument_list|(
operator|&
name|c
operator|->
name|buffer
argument_list|)
condition|)
name|c
operator|->
name|buffer
operator|.
name|dir
operator|=
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|ISADMA_WRITE
else|:
name|ISADMA_READ
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|chn_setvolume
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|)
block|{
comment|/* could add a feeder for volume changing if channel returns -1 */
if|if
condition|(
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|->
name|volume
operator|=
operator|(
name|left
operator|<<
literal|8
operator|)
operator||
name|right
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|->
name|volume
operator|=
operator|(
name|left
operator|<<
literal|8
operator|)
operator||
name|right
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setspeed
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|speed
parameter_list|)
block|{
if|if
condition|(
name|speed
operator|<=
literal|0
condition|)
return|return
name|EINVAL
return|;
comment|/* could add a feeder for rate conversion */
if|if
condition|(
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|->
name|speed
operator|=
name|c
operator|->
name|setspeed
argument_list|(
name|c
operator|->
name|devinfo
argument_list|,
name|speed
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|->
name|speed
operator|=
name|speed
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setformat
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|u_int32_t
name|fmt
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|u_int32_t
name|hwfmt
decl_stmt|;
if|if
condition|(
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|->
name|format
operator|=
name|fmt
expr_stmt|;
name|hwfmt
operator|=
name|chn_feedchain
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
operator|)
operator|&&
name|c
operator|->
name|format
operator|!=
name|hwfmt
condition|)
return|return
name|EINVAL
return|;
name|b
operator|->
name|fmt
operator|=
name|hwfmt
expr_stmt|;
name|bs
operator|->
name|fmt
operator|=
name|hwfmt
expr_stmt|;
name|chn_resetbuf
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|setformat
argument_list|(
name|c
operator|->
name|devinfo
argument_list|,
name|hwfmt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|->
name|format
operator|=
name|fmt
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setblocksize
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|blkcnt
parameter_list|,
name|int
name|blksz
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|s
decl_stmt|,
name|ss
decl_stmt|,
name|bufsz
decl_stmt|;
if|if
condition|(
name|bs
operator|->
name|blkcnt
operator|==
name|blkcnt
operator|&&
name|bs
operator|->
name|blksz
operator|==
name|blksz
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_setblocksize: can't work on mapped channel"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_HAS_SIZE
expr_stmt|;
name|ss
operator|=
literal|1
expr_stmt|;
name|ss
operator|<<=
operator|(
name|bs
operator|->
name|fmt
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ss
operator|<<=
operator|(
name|bs
operator|->
name|fmt
operator|&
name|AFMT_16BIT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|blksz
operator|>=
literal|2
condition|)
name|c
operator|->
name|flags
operator||=
name|CHN_F_HAS_SIZE
expr_stmt|;
comment|/* let us specify blksz without setting CHN_F_HAS_SIZE */
if|if
condition|(
name|blksz
operator|<
literal|0
condition|)
name|blksz
operator|=
operator|-
name|blksz
expr_stmt|;
comment|/* default to blksz = ~0.25s */
if|if
condition|(
name|blksz
operator|<
literal|16
condition|)
name|blksz
operator|=
operator|(
name|ss
operator|*
name|c
operator|->
name|speed
operator|)
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|blksz
operator|>
name|CHN_2NDBUFMAXSIZE
operator|/
literal|2
condition|)
name|blksz
operator|=
name|CHN_2NDBUFMAXSIZE
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|blkcnt
operator|<
literal|2
condition|)
name|blkcnt
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|blkcnt
operator|*
name|blksz
operator|>
name|CHN_2NDBUFMAXSIZE
condition|)
name|blkcnt
operator|=
name|CHN_2NDBUFMAXSIZE
operator|/
name|blksz
expr_stmt|;
name|bufsz
operator|=
name|blkcnt
operator|*
name|blksz
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bs
operator|->
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bs
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|bufsz
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_setblocksize: out of memory."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
name|bs
operator|->
name|bufsize
operator|=
name|bufsz
expr_stmt|;
name|bs
operator|->
name|rl
operator|=
name|bs
operator|->
name|rp
operator|=
name|bs
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|fl
operator|=
name|bs
operator|->
name|bufsize
expr_stmt|;
name|buf_clear
argument_list|(
name|bs
argument_list|,
name|bs
operator|->
name|fmt
argument_list|,
name|bs
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|bs
operator|->
name|blkcnt
operator|=
name|blkcnt
expr_stmt|;
name|bs
operator|->
name|blksz
operator|=
name|blksz
expr_stmt|;
name|RANGE
argument_list|(
name|blksz
argument_list|,
literal|16
argument_list|,
name|b
operator|->
name|bufsize
operator|/
literal|2
argument_list|)
expr_stmt|;
name|b
operator|->
name|blksz
operator|=
name|c
operator|->
name|setblocksize
argument_list|(
name|c
operator|->
name|devinfo
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_trigger
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|go
parameter_list|)
block|{
return|return
name|c
operator|->
name|trigger
argument_list|(
name|c
operator|->
name|devinfo
argument_list|,
name|go
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|chn_getptr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|hwptr
decl_stmt|;
name|int
name|a
init|=
operator|(
literal|1
operator|<<
name|c
operator|->
name|align
operator|)
operator|-
literal|1
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|hwptr
operator|=
name|b
operator|->
name|dl
condition|?
name|c
operator|->
name|getptr
argument_list|(
name|c
operator|->
name|devinfo
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* don't allow unaligned values in the hwa ptr */
name|hwptr
operator|&=
operator|~
name|a
expr_stmt|;
comment|/* Apply channel align mask */
name|hwptr
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* Apply DMA align mask */
return|return
name|hwptr
return|;
block|}
end_function

begin_function
name|pcmchan_caps
modifier|*
name|chn_getcaps
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
return|return
name|c
operator|->
name|getcaps
argument_list|(
name|c
operator|->
name|devinfo
argument_list|)
return|;
block|}
end_function

end_unit

