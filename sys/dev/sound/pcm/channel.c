begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999 Cameron Grant<gandalf@vilnya.demon.co.uk>  * Portions Copyright by Luigi Rizzo - 1997-99  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_define
define|#
directive|define
name|MIN_CHUNK_SIZE
value|256
end_define

begin_comment
comment|/* for uiomove etc. */
end_comment

begin_define
define|#
directive|define
name|DMA_ALIGN_THRESHOLD
value|4
end_define

begin_define
define|#
directive|define
name|DMA_ALIGN_MASK
value|(~(DMA_ALIGN_THRESHOLD - 1))
end_define

begin_define
define|#
directive|define
name|ISA_DMA
parameter_list|(
name|b
parameter_list|)
value|(((b)->chan>= 0&& (b)->chan != 4&& (b)->chan< 8))
end_define

begin_define
define|#
directive|define
name|CANCHANGE
parameter_list|(
name|c
parameter_list|)
value|(!(c)->buffer.dl)
end_define

begin_function_decl
specifier|static
name|void
name|chn_stintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * SOUND OUTPUT  We use a circular buffer to store samples directed to the DAC. The buffer is split into two variable-size regions, each identified by an offset in the buffer (rp,fp) and a length (rl,fl):        0          rp,rl        fp,fl    bufsize       |__________>____________>________| 	  FREE   d   READY    w FREE    READY: data written from the process and ready to be sent to the DAC;   FREE: free part of the buffer.  Both regions can wrap around the end of the buffer.  At initialization, READY is empty, FREE takes all the available space, and dma is idle.  dl contains the length of the current DMA transfer, dl=0 means that the dma is idle.  The two boundaries (rp,fp) in the buffers are advanced by DMA [d] and write() [w] operations. The first portion of the READY region is used for DMA transfers. The transfer is started at rp and with chunks of length dl. During DMA operations, dsp_wr_dmaupdate() updates rp, rl and fl tracking the ISA DMA engine as the transfer makes progress. When a new block is written, fp advances and rl,fl are updated accordingly.  The code works as follows: the user write routine dsp_write_body() fills up the READY region with new data (reclaiming space from the FREE region) and starts the write DMA engine if inactive.  When a DMA transfer is complete, an interrupt causes dsp_wrintr() to be called which extends the FREE region and possibly starts the next transfer.  In some cases, the code tries to track the current status of DMA operations by calling dsp_wr_dmaupdate() which changes rp, rl and fl.  The sistem tries to make all DMA transfers use the same size, play_blocksize or rec_blocksize. The size is either selected by the user, or computed by the system to correspond to about .25s of audio. The blocksize must be within a range which is currently:  	min(5ms, 40 bytes) ... 1/2 buffer size.  When there aren't enough data (write) or space (read), a transfer is started with a reduced size.  To reduce problems in case of overruns, the routine which fills up the buffer should initialize (e.g. by repeating the last value) a reasonably long area after the last block so that no noise is produced on overruns.    *   */
end_comment

begin_comment
comment|/* XXX  this is broken: in the event a bounce buffer is used, data never  * gets copied in or out of the real buffer.  fix requires mods to isa_dma.c  * and possibly fixes to other autodma mode clients  */
end_comment

begin_function
specifier|static
name|void
name|chn_isadmabounce
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|ISA_DMA
argument_list|(
operator|&
name|c
operator|->
name|buffer
argument_list|)
condition|)
block|{
comment|/* tell isa_dma to bounce data in/out */
block|}
else|else
name|panic
argument_list|(
literal|"chn_isadmabounce called on invalid channel"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|chn_polltrigger
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|unsigned
name|lim
init|=
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_HAS_SIZE
operator|)
condition|?
name|c
operator|->
name|blocksize
else|:
literal|1
decl_stmt|;
name|int
name|trig
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|trig
operator|=
operator|(
operator|(
name|b
operator|->
name|int_count
operator|>
name|b
operator|->
name|prev_int_count
operator|)
operator|||
name|b
operator|->
name|first_poll
operator|)
expr_stmt|;
else|else
name|trig
operator|=
operator|(
operator|(
operator|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|b
operator|->
name|fl
else|:
name|b
operator|->
name|rl
operator|)
operator|>=
name|lim
operator|)
expr_stmt|;
return|return
name|trig
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chn_pollreset
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|b
operator|->
name|prev_int_count
operator|=
name|b
operator|->
name|int_count
expr_stmt|;
name|b
operator|->
name|first_poll
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * chn_dmadone() updates pointers and wakes up any process sleeping  * or waiting on a select().  * Must be called at spltty().  */
end_comment

begin_function
specifier|static
name|void
name|chn_dmadone
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISA_DMA
argument_list|(
name|b
argument_list|)
condition|)
name|chn_isadmabounce
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* sync bounce buffer */
name|wakeup
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|int_count
operator|++
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|sel
operator|.
name|si_pid
operator|&&
name|chn_polltrigger
argument_list|(
name|c
argument_list|)
condition|)
name|selwakeup
argument_list|(
operator|&
name|b
operator|->
name|sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chn_dmaupdate() tracks the status of a dma transfer,  * updating pointers. It must be called at spltty().  *  * NOTE: when we are using auto dma in the device, rl might become  * negative.  */
end_comment

begin_function
name|void
name|chn_dmaupdate
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|hwptr
init|=
name|chn_getptr
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|delta
operator|=
operator|(
name|b
operator|->
name|bufsize
operator|+
name|hwptr
operator|-
name|b
operator|->
name|rp
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|rp
operator|=
name|hwptr
expr_stmt|;
name|b
operator|->
name|rl
operator|-=
name|delta
expr_stmt|;
name|b
operator|->
name|fl
operator|+=
name|delta
expr_stmt|;
block|}
else|else
block|{
name|delta
operator|=
operator|(
name|b
operator|->
name|bufsize
operator|+
name|hwptr
operator|-
name|b
operator|->
name|fp
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|fp
operator|=
name|hwptr
expr_stmt|;
name|b
operator|->
name|rl
operator|+=
name|delta
expr_stmt|;
name|b
operator|->
name|fl
operator|-=
name|delta
expr_stmt|;
block|}
name|b
operator|->
name|total
operator|+=
name|delta
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write interrupt routine. Can be called from other places (e.g.  * to start a paused transfer), but with interrupts disabled.  */
end_comment

begin_function
specifier|static
name|void
name|chn_wrintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|int
name|start
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
name|chn_dmadone
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/*      	* start another dma operation only if have ready data in the buffer,      	* there is no pending abort, have a full-duplex device, or have a      	* half duplex device and there is no pending op on the other side.      	*      	* Force transfers to be aligned to a boundary of 4, which is      	* needed when doing stereo and 16-bit.      	*/
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|start
operator|=
name|c
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
expr_stmt|;
else|else
name|start
operator|=
operator|(
name|b
operator|->
name|rl
operator|>=
name|DMA_ALIGN_THRESHOLD
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_ABORTING
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
block|{
name|int
name|l
decl_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|b
operator|->
name|rl
argument_list|,
name|c
operator|->
name|blocksize
argument_list|)
operator|&
name|DMA_ALIGN_MASK
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|l
operator|=
name|c
operator|->
name|blocksize
expr_stmt|;
comment|/* 	 	* check if we need to reprogram the DMA on the sound card. 	 	* This happens if the size has changed _and_ the new size 	 	* is smaller, or it matches the blocksize. 	 	* 	 	* 0<= l<= blocksize 	 	* 0<= dl<= blocksize 	 	* reprog if (dl == 0 || l != dl) 	 	* was: 		* l != b->dl&& (b->dl == 0 || l< b->dl || l == c->blocksize) 	 	*/
if|if
condition|(
name|b
operator|->
name|dl
operator|==
literal|0
operator|||
name|l
operator|!=
name|b
operator|->
name|dl
condition|)
block|{
comment|/* size has changed. Stop and restart */
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"wrintr: bsz %d -> %d, rp %d rl %d\n"
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|l
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b
operator|->
name|rl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_STOP
argument_list|)
expr_stmt|;
name|b
operator|->
name|dl
operator|=
name|l
expr_stmt|;
comment|/* record new transfer size */
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_START
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* cannot start a new dma transfer */
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"cannot start wr-dma flags 0x%08x rp %d rl %d\n"
argument_list|,
name|c
operator|->
name|flags
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b
operator|->
name|rl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
comment|/* was active */
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_STOP
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (c->flags& CHN_F_WRITING) 				DEB(printf("got wrint while reloading\n")); 	    		else if (b->rl<= 0)
comment|/* XXX added 980110 lr */
block|chn_resetbuf(c);
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * user write routine  *  * advance the boundary between READY and FREE, fill the space with  * uiomove(), and possibly start DMA. Do the above until the transfer  * is complete.  *  * To minimize latency in case a pending DMA transfer is about to end,  * we do the transfer in pieces of increasing sizes, extending the  * READY area at every checkpoint. In the (necessary) assumption that  * memory bandwidth is larger than the rate at which the dma consumes  * data, we reduce the latency to something proportional to the length  * of the first piece, while keeping the overhead low and being able  * to feed the DMA with large blocks.  */
end_comment

begin_function
name|int
name|chn_write
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|a
decl_stmt|,
name|l
decl_stmt|,
name|w
decl_stmt|,
name|timeout
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|long
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_WRITING
condition|)
block|{
comment|/* This shouldn't happen and is actually silly 		 * - will never wake up, just timeout; why not sleep on b? 		 */
name|tsleep
argument_list|(
operator|&
name|s
argument_list|,
name|PZERO
argument_list|,
literal|"pcmwrW"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|a
operator|=
operator|(
literal|1
operator|<<
name|c
operator|->
name|align
operator|)
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_WRITING
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|->
name|smegcnt
operator|+
name|buf
operator|->
name|uio_resid
operator|)
operator|>
name|a
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|fl
operator|<
name|DMA_ALIGN_THRESHOLD
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_NBIO
condition|)
break|break;
name|timeout
operator|=
operator|(
name|buf
operator|->
name|uio_resid
operator|>=
name|b
operator|->
name|dl
operator|)
condition|?
name|hz
else|:
literal|1
expr_stmt|;
name|ret
operator|=
name|tsleep
argument_list|(
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmwr"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
condition|)
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
condition|)
break|break;
name|ret
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* ensure we always have a whole number of samples */
name|l
operator|=
name|min
argument_list|(
name|b
operator|->
name|fl
argument_list|,
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|fp
argument_list|)
operator|&
operator|~
name|a
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
break|break;
name|w
operator|=
name|c
operator|->
name|feeder
operator|->
name|feed
argument_list|(
name|c
operator|->
name|feeder
argument_list|,
name|c
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|fp
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"no feed"
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|b
operator|->
name|rl
operator|+=
name|w
expr_stmt|;
name|b
operator|->
name|fl
operator|-=
name|w
expr_stmt|;
name|b
operator|->
name|fp
operator|=
operator|(
name|b
operator|->
name|fp
operator|+
name|w
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|rl
operator|&&
operator|!
name|b
operator|->
name|dl
condition|)
name|chn_stintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
operator|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
operator|)
condition|)
block|{
name|l
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|smegcnt
operator|+
name|l
operator|)
operator|>=
name|SMEGBUFSZ
condition|)
name|panic
argument_list|(
literal|"resid overflow %d"
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|uiomove
argument_list|(
name|c
operator|->
name|smegbuf
operator|+
name|c
operator|->
name|smegcnt
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|c
operator|->
name|smegcnt
operator|+=
name|l
expr_stmt|;
block|}
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_WRITING
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * SOUND INPUT  *  The input part is similar to the output one, with a circular buffer split in two regions, and boundaries advancing because of read() calls [r] or dma operation [d].  At initialization, as for the write routine, READY is empty, and FREE takes all the space.        0          rp,rl        fp,fl    bufsize       |__________>____________>________| 	  FREE   r   READY    d  FREE  Operation is as follows: upon user read (dsp_read_body()) a DMA read is started if not already active (marked by b->dl> 0), then as soon as data are available in the READY region they are transferred to the user buffer, thus advancing the boundary between FREE and READY. Upon interrupts, caused by a completion of a DMA transfer, the READY region is extended and possibly a new transfer is started.  When necessary, dsp_rd_dmaupdate() is called to advance fp (and update rl,fl accordingly). Upon user reads, rp is advanced and rl,fl are updated accordingly.  The rules to choose the size of the new DMA area are similar to the other case, with a preferred constant transfer size equal to rec_blocksize, and fallback to smaller sizes if no space is available.   */
end_comment

begin_comment
comment|/* read interrupt routine. Must be called with interrupts blocked. */
end_comment

begin_function
specifier|static
name|void
name|chn_rdintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|int
name|start
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
name|chn_dmadone
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"rdintr: start dl %d, rp:rl %d:%d, fp:fl %d:%d\n"
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|fp
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restart if have enough free space to absorb overruns */
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|start
operator|=
name|c
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
expr_stmt|;
else|else
name|start
operator|=
operator|(
name|b
operator|->
name|fl
operator|>
literal|0x200
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_ABORTING
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
block|{
name|int
name|l
init|=
name|min
argument_list|(
name|b
operator|->
name|fl
operator|-
literal|0x100
argument_list|,
name|c
operator|->
name|blocksize
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|l
operator|=
name|c
operator|->
name|blocksize
expr_stmt|;
name|l
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* realign sizes */
name|DEB
argument_list|(
argument|printf(
literal|"rdintr: dl %d -> %d\n"
argument|, b->dl, l);
argument_list|)
if|if
condition|(
name|l
operator|!=
name|b
operator|->
name|dl
condition|)
block|{
comment|/* size has changed. Stop and restart */
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_STOP
argument_list|)
expr_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|b
operator|->
name|fl
operator|-
literal|0x100
argument_list|,
name|c
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|l
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* realign sizes */
block|}
name|b
operator|->
name|dl
operator|=
name|l
expr_stmt|;
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_START
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
comment|/* was active */
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_STOP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * body of user-read routine  *  * Start DMA if not active; wait for READY not empty.  * Transfer data from READY region using uiomove(), advance boundary  * between FREE and READY. Repeat until transfer is complete.  *  * To avoid excessive latency in freeing up space for the DMA  * engine, transfers are done in blocks of increasing size, so that  * the latency is proportional to the size of the smallest block, but  * we have a low overhead and are able to feed the dma engine with  * large blocks.  *  * NOTE: in the current version, read will not return more than  * blocksize bytes at once (unless more are already available), to  * avoid that requests using very large buffers block for too long.  */
end_comment

begin_function
name|int
name|chn_read
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|w
decl_stmt|,
name|l
decl_stmt|,
name|timeout
decl_stmt|,
name|limit
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|long
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_READING
condition|)
block|{
comment|/* This shouldn't happen and is actually silly */
name|tsleep
argument_list|(
operator|&
name|s
argument_list|,
name|PZERO
argument_list|,
literal|"pcmrdR"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|b
operator|->
name|rl
operator|&
operator|!
name|b
operator|->
name|dl
condition|)
name|chn_stintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_READING
expr_stmt|;
name|limit
operator|=
name|buf
operator|->
name|uio_resid
operator|-
name|c
operator|->
name|blocksize
expr_stmt|;
if|if
condition|(
name|limit
operator|<
literal|0
condition|)
name|limit
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf
operator|->
name|uio_resid
operator|>
name|limit
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|rl
operator|<
name|DMA_ALIGN_THRESHOLD
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_NBIO
condition|)
break|break;
name|timeout
operator|=
operator|(
name|buf
operator|->
name|uio_resid
operator|-
name|limit
operator|>=
name|b
operator|->
name|dl
operator|)
condition|?
name|hz
else|:
literal|1
expr_stmt|;
name|ret
operator|=
name|tsleep
argument_list|(
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmrd"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
condition|)
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
condition|)
break|break;
name|ret
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* ensure we always have a whole number of samples */
name|l
operator|=
name|min
argument_list|(
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|rp
argument_list|)
operator|&
name|DMA_ALIGN_MASK
expr_stmt|;
name|w
operator|=
name|c
operator|->
name|feeder
operator|->
name|feed
argument_list|(
name|c
operator|->
name|feeder
argument_list|,
name|c
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|rp
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|b
operator|->
name|rl
operator|-=
name|w
expr_stmt|;
name|b
operator|->
name|fl
operator|+=
name|w
expr_stmt|;
name|b
operator|->
name|rp
operator|=
operator|(
name|b
operator|->
name|rp
operator|+
name|w
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_READING
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|chn_intr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
comment|/*	if (!c->buffer.dl) chn_reinit(c); */
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
name|chn_wrintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|chn_rdintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|chn_stintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|u_long
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|chn_intr
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|chn_dma_setmap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|(
name|snd_dbuf
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"pcm: setmap %lx, %lx; "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%p -> %lx\n"
argument_list|,
name|b
operator|->
name|buf
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vtophys
argument_list|(
name|b
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|chn_allocbuf
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|bus_dma_tag_t
name|parent_dmat
parameter_list|)
block|{
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|parent_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|b
operator|->
name|buf
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|b
operator|->
name|dmamap
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|parent_dmat
argument_list|,
name|b
operator|->
name|dmamap
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|chn_dma_setmap
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|chn_resetbuf
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|u_int16_t
name|data
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|u_int32_t
name|i
decl_stmt|;
name|c
operator|->
name|smegcnt
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|buffer
operator|.
name|sample_size
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|buffer
operator|.
name|sample_size
operator|<<=
operator|(
name|c
operator|->
name|hwfmt
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|c
operator|->
name|buffer
operator|.
name|sample_size
operator|<<=
operator|(
name|c
operator|->
name|hwfmt
operator|&
name|AFMT_16BIT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* rely on bufsize& 3 == 0 */
if|if
condition|(
name|c
operator|->
name|hwfmt
operator|&
name|AFMT_SIGNED
condition|)
name|data
operator|=
literal|0x00
expr_stmt|;
else|else
name|data
operator|=
literal|0x80
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|hwfmt
operator|&
name|AFMT_16BIT
condition|)
name|data
operator|<<=
literal|8
expr_stmt|;
else|else
name|data
operator||=
name|data
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|hwfmt
operator|&
name|AFMT_BIGENDIAN
condition|)
name|data
operator|=
operator|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
operator|)
operator||
operator|(
operator|(
name|data
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|b
operator|->
name|buf
init|;
name|i
operator|<
name|b
operator|->
name|bufsize
condition|;
name|i
operator|+=
literal|2
control|)
operator|*
name|p
operator|++
operator|=
name|data
expr_stmt|;
name|b
operator|->
name|rp
operator|=
name|b
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|dl
operator|=
name|b
operator|->
name|rl
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|prev_total
operator|=
name|b
operator|->
name|total
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|prev_int_count
operator|=
name|b
operator|->
name|int_count
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|first_poll
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|fl
operator|=
name|b
operator|->
name|bufsize
expr_stmt|;
block|}
end_function

begin_function
name|void
name|buf_isadma
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|int
name|go
parameter_list|)
block|{
if|if
condition|(
name|ISA_DMA
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
name|go
operator|==
name|PCMTRIG_START
condition|)
name|isa_dmastart
argument_list|(
name|b
operator|->
name|dir
operator||
name|B_RAW
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
else|else
block|{
name|isa_dmastop
argument_list|(
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
name|isa_dmadone
argument_list|(
name|b
operator|->
name|dir
operator||
name|B_RAW
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|panic
argument_list|(
literal|"buf_isadma called on invalid channel"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|buf_isadmaptr
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|ISA_DMA
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|b
operator|->
name|dl
condition|?
name|isa_dmastatus
argument_list|(
name|b
operator|->
name|chan
argument_list|)
else|:
name|b
operator|->
name|bufsize
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
return|return
name|b
operator|->
name|bufsize
operator|-
name|i
return|;
block|}
else|else
name|panic
argument_list|(
literal|"buf_isadmaptr called on invalid channel"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * snd_sync waits until the space in the given channel goes above  * a threshold. The threshold is checked against fl or rl respectively.  * Assume that the condition can become true, do not check here...  */
end_comment

begin_function
name|int
name|chn_sync
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|threshold
parameter_list|)
block|{
name|u_long
name|s
decl_stmt|,
name|rdy
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rdy
operator|=
operator|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|b
operator|->
name|fl
else|:
name|b
operator|->
name|rl
expr_stmt|;
if|if
condition|(
name|rdy
operator|<=
name|threshold
condition|)
block|{
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmsyn"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ERESTART
operator|||
name|ret
operator|==
name|EINTR
condition|)
block|{
name|printf
argument_list|(
literal|"tsleep returns %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_poll
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|ev
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|u_long
name|s
init|=
name|spltty
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|chn_polltrigger
argument_list|(
name|c
argument_list|)
operator|&&
name|chn_pollreset
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|ev
return|;
else|else
block|{
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|b
operator|->
name|sel
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * chn_abort is a non-blocking function which aborts a pending  * DMA transfer and flushes the buffers.  * It returns the number of bytes that have not been transferred.  */
end_comment

begin_function
name|int
name|chn_abort
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|long
name|s
decl_stmt|;
name|int
name|missing
init|=
literal|0
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
operator|(
operator|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|CHN_F_WRITING
else|:
name|CHN_F_READING
operator|)
expr_stmt|;
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_ABORT
argument_list|)
expr_stmt|;
name|chn_dmadone
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|missing
operator|=
name|b
operator|->
name|rl
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|missing
return|;
block|}
end_function

begin_comment
comment|/*  * this routine tries to flush the dma transfer. It is called  * on a close. We immediately abort any read DMA  * operation, and then wait for the play buffer to drain.  */
end_comment

begin_function
name|int
name|chn_flush
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|count
init|=
literal|10
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"snd_flush c->flags 0x%08x\n"
argument_list|,
name|c
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_CLOSING
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|!=
name|PCMDIR_PLAY
condition|)
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|b
operator|->
name|dl
condition|)
block|{
comment|/* still pending output data. */
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmflu"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"snd_sync: now rl : fl  %d : %d\n"
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
condition|)
block|{
name|printf
argument_list|(
literal|"tsleep returns %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ret
operator|&&
operator|--
name|count
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"timeout flushing dbuf_out, cnt 0x%x flags 0x%x\n"
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|c
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_CLOSING
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_reset
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
name|CHN_F_RESET
expr_stmt|;
name|chn_resetbuf
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_reinit
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_INIT
operator|)
operator|&&
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|chn_setformat
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|format
argument_list|)
expr_stmt|;
name|chn_setspeed
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|speed
argument_list|)
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|chn_setvolume
argument_list|(
name|c
argument_list|,
operator|(
name|c
operator|->
name|volume
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|c
operator|->
name|volume
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_INIT
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_init
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|c
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|feeder
operator|=
operator|&
name|feeder_root
expr_stmt|;
name|c
operator|->
name|buffer
operator|.
name|chan
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|devinfo
operator|=
name|c
operator|->
name|init
argument_list|(
name|devinfo
argument_list|,
operator|&
name|c
operator|->
name|buffer
argument_list|,
name|c
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|chn_setdir
argument_list|(
name|c
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setdir
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|c
operator|->
name|direction
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|ISA_DMA
argument_list|(
operator|&
name|c
operator|->
name|buffer
argument_list|)
condition|)
name|c
operator|->
name|buffer
operator|.
name|dir
operator|=
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|B_WRITE
else|:
name|B_READ
expr_stmt|;
return|return
name|c
operator|->
name|setdir
argument_list|(
name|c
operator|->
name|devinfo
argument_list|,
name|c
operator|->
name|direction
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|chn_setvolume
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|)
block|{
comment|/* could add a feeder for volume changing if channel returns -1 */
if|if
condition|(
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|c
operator|->
name|volume
operator|=
operator|(
name|left
operator|<<
literal|8
operator|)
operator||
name|right
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setspeed
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|speed
parameter_list|)
block|{
comment|/* could add a feeder for rate conversion */
if|if
condition|(
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|->
name|speed
operator|=
name|c
operator|->
name|setspeed
argument_list|(
name|c
operator|->
name|devinfo
argument_list|,
name|speed
argument_list|)
expr_stmt|;
return|return
name|c
operator|->
name|speed
return|;
block|}
name|c
operator|->
name|speed
operator|=
name|speed
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setformat
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|u_int32_t
name|fmt
parameter_list|)
block|{
if|if
condition|(
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|->
name|hwfmt
operator|=
name|c
operator|->
name|format
operator|=
name|fmt
expr_stmt|;
name|c
operator|->
name|hwfmt
operator|=
name|chn_feedchain
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|chn_resetbuf
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|setformat
argument_list|(
name|c
operator|->
name|devinfo
argument_list|,
name|c
operator|->
name|hwfmt
argument_list|)
expr_stmt|;
return|return
name|fmt
return|;
block|}
name|c
operator|->
name|format
operator|=
name|fmt
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setblocksize
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|blksz
parameter_list|)
block|{
if|if
condition|(
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_HAS_SIZE
expr_stmt|;
if|if
condition|(
name|blksz
operator|>=
literal|2
condition|)
name|c
operator|->
name|flags
operator||=
name|CHN_F_HAS_SIZE
expr_stmt|;
if|if
condition|(
name|blksz
operator|<
literal|0
condition|)
name|blksz
operator|=
operator|-
name|blksz
expr_stmt|;
if|if
condition|(
name|blksz
operator|<
literal|2
condition|)
name|blksz
operator|=
operator|(
name|c
operator|->
name|buffer
operator|.
name|sample_size
operator|*
name|c
operator|->
name|speed
operator|)
operator|>>
literal|2
expr_stmt|;
name|RANGE
argument_list|(
name|blksz
argument_list|,
literal|1024
argument_list|,
name|c
operator|->
name|buffer
operator|.
name|bufsize
operator|/
literal|4
argument_list|)
expr_stmt|;
name|blksz
operator|&=
operator|~
literal|3
expr_stmt|;
name|c
operator|->
name|blocksize
operator|=
name|c
operator|->
name|setblocksize
argument_list|(
name|c
operator|->
name|devinfo
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
return|return
name|c
operator|->
name|blocksize
return|;
block|}
name|c
operator|->
name|blocksize
operator|=
name|blksz
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_trigger
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|go
parameter_list|)
block|{
return|return
name|c
operator|->
name|trigger
argument_list|(
name|c
operator|->
name|devinfo
argument_list|,
name|go
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|chn_getptr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
return|return
name|c
operator|->
name|getptr
argument_list|(
name|c
operator|->
name|devinfo
argument_list|)
return|;
block|}
end_function

begin_function
name|pcmchan_caps
modifier|*
name|chn_getcaps
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
return|return
name|c
operator|->
name|getcaps
argument_list|(
name|c
operator|->
name|devinfo
argument_list|)
return|;
block|}
end_function

end_unit

