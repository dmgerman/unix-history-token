begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999 Cameron Grant<gandalf@vilnya.demon.co.uk>  * Portions Copyright by Luigi Rizzo - 1997-99  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|"feeder_if.h"
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CHANNEL
argument_list|,
literal|"channel"
argument_list|,
literal|"pcm channel"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MIN_CHUNK_SIZE
value|256
end_define

begin_comment
comment|/* for uiomove etc. */
end_comment

begin_define
define|#
directive|define
name|DMA_ALIGN_THRESHOLD
value|4
end_define

begin_define
define|#
directive|define
name|DMA_ALIGN_MASK
value|(~(DMA_ALIGN_THRESHOLD - 1))
end_define

begin_define
define|#
directive|define
name|CANCHANGE
parameter_list|(
name|c
parameter_list|)
value|(!(c)->buffer.dl)
end_define

begin_define
define|#
directive|define
name|ROUND
parameter_list|(
name|x
parameter_list|)
value|((x)& DMA_ALIGN_MASK)
end_define

begin_comment
comment|/* #define DEB(x) x */
end_comment

begin_function_decl
specifier|static
name|void
name|chn_dmaupdate
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chn_wrintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chn_rdintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chn_buildfeeder
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * SOUND OUTPUT  We use a circular buffer to store samples directed to the DAC. The buffer is split into two variable-size regions, each identified by an offset in the buffer (rp,fp) and a length (rl,fl):        0          rp,rl        fp,fl    bufsize       |__________>____________>________| 	  FREE   d   READY    w FREE    READY: data written from the process and ready to be sent to the DAC;   FREE: free part of the buffer.  Both regions can wrap around the end of the buffer.  At initialization, READY is empty, FREE takes all the available space, and dma is idle.  dl contains the length of the current DMA transfer, dl=0 means that the dma is idle.  The two boundaries (rp,fp) in the buffers are advanced by DMA [d] and write() [w] operations. The first portion of the READY region is used for DMA transfers. The transfer is started at rp and with chunks of length dl. During DMA operations, dsp_wr_dmaupdate() updates rp, rl and fl tracking the ISA DMA engine as the transfer makes progress. When a new block is written, fp advances and rl,fl are updated accordingly.  The code works as follows: the user write routine dsp_write_body() fills up the READY region with new data (reclaiming space from the FREE region) and starts the write DMA engine if inactive.  When a DMA transfer is complete, an interrupt causes dsp_wrintr() to be called which extends the FREE region and possibly starts the next transfer.  In some cases, the code tries to track the current status of DMA operations by calling dsp_wr_dmaupdate() which changes rp, rl and fl.  The system tries to make all DMA transfers use the same size, play_blocksize or rec_blocksize. The size is either selected by the user, or computed by the system to correspond to about .25s of audio. The blocksize must be within a range which is currently:  	min(5ms, 40 bytes) ... 1/2 buffer size.  When there aren't enough data (write) or space (read), a transfer is started with a reduced size.  To reduce problems in case of overruns, the routine which fills up the buffer should initialize (e.g. by repeating the last value) a reasonably long area after the last block so that no noise is produced on overruns.    *   */
end_comment

begin_comment
comment|/* XXX  this is broken: in the event a bounce buffer is used, data never  * gets copied in or out of the real buffer.  fix requires mods to isa_dma.c  * and possibly fixes to other autodma mode clients  */
end_comment

begin_function
specifier|static
name|int
name|chn_polltrigger
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|unsigned
name|lim
init|=
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_HAS_SIZE
operator|)
condition|?
name|bs
operator|->
name|blksz
else|:
literal|0
decl_stmt|;
name|int
name|trig
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|trig
operator|=
operator|(
operator|(
name|bs
operator|->
name|int_count
operator|>
name|bs
operator|->
name|prev_int_count
operator|)
operator|||
name|bs
operator|->
name|prev_int_count
operator|==
literal|0
operator|)
expr_stmt|;
else|else
name|trig
operator|=
operator|(
operator|(
operator|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|bs
operator|->
name|fl
else|:
name|bs
operator|->
name|rl
operator|)
operator|>
name|lim
operator|)
expr_stmt|;
return|return
name|trig
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chn_pollreset
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|bs
operator|->
name|prev_int_count
operator|=
name|bs
operator|->
name|int_count
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * chn_dmadone() updates pointers and wakes up any process waiting  * on a select(). Must be called at spltty().  */
end_comment

begin_function
specifier|static
name|void
name|chn_dmadone
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISA_DMA
argument_list|(
name|b
argument_list|)
condition|)
name|sndbuf_isadmabounce
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* sync bounce buffer */
name|b
operator|->
name|int_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chn_dmawakeup() wakes up any process sleeping. Separated from  * chn_dmadone() so that wakeup occurs only when feed from a  * secondary buffer to a DMA buffer takes place. Must be called  * at spltty().  */
end_comment

begin_function
specifier|static
name|void
name|chn_dmawakeup
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|wakeup
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chn_dmaupdate() tracks the status of a dma transfer,  * updating pointers. It must be called at spltty().  *  * NOTE: when we are using auto dma in the device, rl might become  * negative.  */
end_comment

begin_macro
name|DEB
argument_list|(
argument|static int chn_updatecount=
literal|0
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|chn_dmaupdate
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|hwptr
decl_stmt|;
name|DEB
argument_list|(
argument|int b_rl=b->rl; int b_fl=b->fl; int b_rp=b->rp; int b_fp=b->fp
argument_list|)
empty_stmt|;
name|hwptr
operator|=
name|chn_getptr
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|delta
operator|=
operator|(
name|b
operator|->
name|bufsize
operator|+
name|hwptr
operator|-
name|b
operator|->
name|hp
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
operator|(
operator|(
name|b
operator|->
name|bufsize
operator|*
literal|15
operator|)
operator|/
literal|16
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
operator|(
name|CHN_F_CLOSING
operator||
name|CHN_F_ABORTING
operator|)
operator|)
condition|)
name|device_printf
argument_list|(
name|c
operator|->
name|parent
operator|->
name|dev
argument_list|,
literal|"hwptr went backwards %d -> %d\n"
argument_list|,
name|b
operator|->
name|hp
argument_list|,
name|hwptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|delta
operator|=
operator|(
name|b
operator|->
name|bufsize
operator|+
name|hwptr
operator|-
name|b
operator|->
name|rp
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|rp
operator|=
name|hwptr
expr_stmt|;
name|b
operator|->
name|rl
operator|-=
name|delta
expr_stmt|;
name|b
operator|->
name|fl
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|rl
operator|<
literal|0
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"OUCH!(%d) rl %d(%d) delta %d bufsize %d hwptr %d rp %d(%d)\n"
argument_list|,
name|chn_updatecount
operator|++
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b_rl
argument_list|,
name|delta
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|hwptr
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b_rp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|delta
operator|=
operator|(
name|b
operator|->
name|bufsize
operator|+
name|hwptr
operator|-
name|b
operator|->
name|fp
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|fp
operator|=
name|hwptr
expr_stmt|;
name|b
operator|->
name|rl
operator|+=
name|delta
expr_stmt|;
name|b
operator|->
name|fl
operator|-=
name|delta
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|fl
operator|<
literal|0
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"OUCH!(%d) fl %d(%d) delta %d bufsize %d hwptr %d fp %d(%d)\n"
argument_list|,
name|chn_updatecount
operator|++
argument_list|,
name|b
operator|->
name|fl
argument_list|,
name|b_fl
argument_list|,
name|delta
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|hwptr
argument_list|,
name|b
operator|->
name|fp
argument_list|,
name|b_fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|->
name|hp
operator|=
name|hwptr
expr_stmt|;
name|b
operator|->
name|total
operator|+=
name|delta
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check channel for underflow occured. Reset DMA buffer in case of  * underflow, so that new data can go into the buffer. It must be  * called at spltty().  */
end_comment

begin_function
name|void
name|chn_checkunderflow
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|underflow
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"Clear underflow condition\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * The DMA keeps running even after underflow occurs. 		 * Hence the value returned by chn_getptr() here soon 		 * gets a lag when we get back to chn_write(). Although 		 * there are no easy and precise methods to figure out 		 * the lag, a quarter of b->bufsize would be a fair 		 * choice, provided that a DMA interrupt generates upon 		 * each transfer of a half b->bufsize. 		 */
name|b
operator|->
name|rp
operator|=
name|chn_getptr
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|b
operator|->
name|fp
operator|=
operator|(
name|b
operator|->
name|rp
operator|+
name|b
operator|->
name|bufsize
operator|/
literal|4
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|rl
operator|=
name|b
operator|->
name|bufsize
operator|/
literal|4
expr_stmt|;
name|b
operator|->
name|fl
operator|=
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|rl
expr_stmt|;
name|b
operator|->
name|underflow
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Feeds new data to the write dma buffer. Can be called in the bottom half.  * Hence must be called at spltty.  */
end_comment

begin_function
name|int
name|chn_wrfeed
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|a
decl_stmt|,
name|l
decl_stmt|,
name|lacc
decl_stmt|;
comment|/* ensure we always have a whole number of samples */
name|a
operator|=
operator|(
literal|1
operator|<<
name|c
operator|->
name|align
operator|)
operator|-
literal|1
expr_stmt|;
name|lacc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
block|{
name|bs
operator|->
name|rl
operator|=
name|min
argument_list|(
name|b
operator|->
name|blksz
argument_list|,
name|b
operator|->
name|fl
argument_list|)
expr_stmt|;
name|bs
operator|->
name|fl
operator|=
literal|0
expr_stmt|;
name|a
operator|=
literal|0
expr_stmt|;
block|}
name|DEB
argument_list|(
argument|if (c->flags& CHN_F_CLOSING) 		printf(
literal|"b: [rl: %d, rp %d, fl %d, fp %d]; bs: [rl: %d, rp %d, fl %d, fp %d]\n"
argument|, 			b->rl, b->rp, b->fl, b->fp, bs->rl, bs->rp, bs->fl, bs->fp)
argument_list|)
empty_stmt|;
comment|/* Don't allow write unaligned data */
while|while
condition|(
name|bs
operator|->
name|rl
operator|>
name|a
operator|&&
name|b
operator|->
name|fl
operator|>
name|a
condition|)
block|{
comment|/* ensure we always have a whole number of samples */
name|l
operator|=
name|min
argument_list|(
name|min
argument_list|(
name|bs
operator|->
name|rl
argument_list|,
name|bs
operator|->
name|bufsize
operator|-
name|bs
operator|->
name|rp
argument_list|)
argument_list|,
name|min
argument_list|(
name|b
operator|->
name|fl
argument_list|,
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|fp
argument_list|)
argument_list|)
operator|&
operator|~
name|a
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
name|lacc
return|;
comment|/* Move the samples, update the markers and pointers. */
name|bcopy
argument_list|(
name|bs
operator|->
name|buf
operator|+
name|bs
operator|->
name|rp
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|fp
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|bs
operator|->
name|fl
operator|+=
name|l
expr_stmt|;
name|bs
operator|->
name|rl
operator|-=
name|l
expr_stmt|;
name|bs
operator|->
name|rp
operator|=
operator|(
name|bs
operator|->
name|rp
operator|+
name|l
operator|)
operator|%
name|bs
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|rl
operator|+=
name|l
expr_stmt|;
name|b
operator|->
name|fl
operator|-=
name|l
expr_stmt|;
name|b
operator|->
name|fp
operator|=
operator|(
name|b
operator|->
name|fp
operator|+
name|l
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
comment|/* Clear the new space in the secondary buffer. */
name|sndbuf_clear
argument_list|(
name|bs
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Accumulate the total bytes of the moved samples. */
name|lacc
operator|+=
name|l
expr_stmt|;
comment|/* A feed to the DMA buffer is equivalent to an interrupt. */
name|bs
operator|->
name|total
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
block|{
if|if
condition|(
name|bs
operator|->
name|total
operator|-
name|bs
operator|->
name|prev_total
operator|>=
name|bs
operator|->
name|blksz
condition|)
block|{
name|bs
operator|->
name|prev_total
operator|=
name|bs
operator|->
name|total
expr_stmt|;
name|bs
operator|->
name|int_count
operator|++
expr_stmt|;
name|c
operator|->
name|blocks
operator|++
expr_stmt|;
block|}
block|}
else|else
name|bs
operator|->
name|int_count
operator|++
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|sel
operator|.
name|si_pid
operator|&&
name|chn_polltrigger
argument_list|(
name|c
argument_list|)
condition|)
name|selwakeup
argument_list|(
operator|&
name|bs
operator|->
name|sel
argument_list|)
expr_stmt|;
block|}
return|return
name|lacc
return|;
block|}
end_function

begin_comment
comment|/* Feeds new data to the secondary write buffer. */
end_comment

begin_function
specifier|static
name|int
name|chn_wrfeed2nd
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|l
decl_stmt|,
name|w
decl_stmt|,
name|wacc
decl_stmt|,
name|hl
decl_stmt|;
name|u_int8_t
name|hackbuf
index|[
literal|64
index|]
decl_stmt|;
comment|/* The DMA buffer may have some space. */
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* ensure we always have a whole number of samples */
name|wacc
operator|=
literal|0
expr_stmt|;
name|hl
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|bs
operator|->
name|fl
operator|>
literal|64
condition|)
block|{
comment|/* 		 * The size of the data to move here does not have to be 		 * aligned. We take care of it upon moving the data to a 		 * DMA buffer. 		 */
name|l
operator|=
name|min
argument_list|(
name|bs
operator|->
name|fl
argument_list|,
name|bs
operator|->
name|bufsize
operator|-
name|bs
operator|->
name|fp
argument_list|)
expr_stmt|;
comment|/* Move the samples, update the markers and pointers. */
if|if
condition|(
name|l
operator|<
literal|64
condition|)
block|{
name|w
operator|=
name|FEEDER_FEED
argument_list|(
name|c
operator|->
name|feeder
argument_list|,
name|c
argument_list|,
name|hackbuf
argument_list|,
literal|64
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|w
argument_list|,
name|bs
operator|->
name|bufsize
operator|-
name|bs
operator|->
name|fp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hackbuf
argument_list|,
name|bs
operator|->
name|buf
operator|+
name|bs
operator|->
name|fp
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|>
name|l
condition|)
name|bcopy
argument_list|(
name|hackbuf
operator|+
name|l
argument_list|,
name|bs
operator|->
name|buf
argument_list|,
name|w
operator|-
name|l
argument_list|)
expr_stmt|;
block|}
else|else
name|w
operator|=
name|FEEDER_FEED
argument_list|(
name|c
operator|->
name|feeder
argument_list|,
name|c
argument_list|,
name|bs
operator|->
name|buf
operator|+
name|bs
operator|->
name|fp
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"no feed"
argument_list|)
expr_stmt|;
name|bs
operator|->
name|rl
operator|+=
name|w
expr_stmt|;
name|bs
operator|->
name|fl
operator|-=
name|w
expr_stmt|;
name|bs
operator|->
name|fp
operator|=
operator|(
name|bs
operator|->
name|fp
operator|+
name|w
operator|)
operator|%
name|bs
operator|->
name|bufsize
expr_stmt|;
comment|/* Accumulate the total bytes of the moved samples. */
name|wacc
operator|+=
name|w
expr_stmt|;
comment|/* If any pcm data gets moved, push it to the DMA buffer. */
if|if
condition|(
name|w
operator|>
literal|0
condition|)
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
block|}
return|return
name|wacc
return|;
block|}
end_function

begin_comment
comment|/*  * Write interrupt routine. Can be called from other places (e.g.  * to start a paused transfer), but with interrupts disabled.  */
end_comment

begin_function
specifier|static
name|void
name|chn_wrintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|underflow
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
operator|)
condition|)
block|{
comment|/*		printf("underflow return\n"); */
return|return;
comment|/* nothing new happened */
block|}
if|if
condition|(
name|b
operator|->
name|dl
condition|)
name|chn_dmadone
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * start another dma operation only if have ready data in the buffer, 	 * there is no pending abort, have a full-duplex device, or have a 	 * half duplex device and there is no pending op on the other side. 	 * 	 * Force transfers to be aligned to a boundary of 4, which is 	 * needed when doing stereo and 16-bit. 	 */
comment|/* Check underflow and update the pointers. */
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * Fill up the DMA buffer, followed by waking up the top half. 	 * If some of the pcm data in uio are still left, the top half 	 * goes to sleep by itself. 	 */
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
condition|)
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
name|sndbuf_clear
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|fl
argument_list|)
expr_stmt|;
block|}
name|chn_dmawakeup
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
condition|)
block|{
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 	 * check if we need to reprogram the DMA on the sound card. 	 	 * This happens if the size has changed from zero 	 	 */
if|if
condition|(
name|b
operator|->
name|dl
operator|==
literal|0
condition|)
block|{
comment|/* Start DMA operation */
name|b
operator|->
name|dl
operator|=
name|b
operator|->
name|blksz
expr_stmt|;
comment|/* record new transfer size */
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_START
argument_list|)
expr_stmt|;
block|}
comment|/*  		 * Emulate writing by DMA, i.e. transfer the pcm data from  		 * the emulated-DMA buffer to the device itself.  		 */
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_EMLDMAWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|rl
operator|<
name|b
operator|->
name|dl
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"near underflow (%d< %d), %d\n"
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * we are near to underflow condition, so to prevent 			 * audio 'clicks' clear next b->fl bytes 			 */
name|sndbuf_clear
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|rl
operator|<
name|DMA_ALIGN_THRESHOLD
condition|)
name|b
operator|->
name|underflow
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* cannot start a new dma transfer */
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"underflow, flags 0x%08x rp %d rl %d\n"
argument_list|,
name|c
operator|->
name|flags
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b
operator|->
name|rl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
comment|/* DMA was active */
name|b
operator|->
name|underflow
operator|=
literal|1
expr_stmt|;
comment|/* set underflow flag */
name|sndbuf_clear
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|bufsize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * user write routine  *  * advance the boundary between READY and FREE, fill the space with  * uiomove(), and possibly start DMA. Do the above until the transfer  * is complete.  *  * To minimize latency in case a pending DMA transfer is about to end,  * we do the transfer in pieces of increasing sizes, extending the  * READY area at every checkpoint. In the (necessary) assumption that  * memory bandwidth is larger than the rate at which the dma consumes  * data, we reduce the latency to something proportional to the length  * of the first piece, while keeping the overhead low and being able  * to feed the DMA with large blocks.  */
end_comment

begin_function
name|int
name|chn_write
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|timeout
decl_stmt|,
name|res
decl_stmt|,
name|newsize
decl_stmt|,
name|count
decl_stmt|;
name|long
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_WRITING
condition|)
block|{
comment|/* This shouldn't happen and is actually silly 		 * - will never wake up, just timeout; why not sleep on b? 		 */
name|tsleep
argument_list|(
operator|&
name|s
argument_list|,
name|PZERO
argument_list|,
literal|"pcmwrW"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|c
operator|->
name|flags
operator||=
name|CHN_F_WRITING
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_ABORTING
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* 	 * XXX Certain applications attempt to write larger size 	 * of pcm data than c->blocksize2nd without blocking, 	 * resulting partial write. Expand the block size so that 	 * the write operation avoids blocking. 	 */
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_NBIO
operator|)
operator|&&
name|buf
operator|->
name|uio_resid
operator|>
name|bs
operator|->
name|blksz
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"pcm warning: broken app, nbio and tried to write %d bytes with fragsz %d\n"
argument_list|,
name|buf
operator|->
name|uio_resid
argument_list|,
name|bs
operator|->
name|blksz
argument_list|)
argument_list|)
expr_stmt|;
name|newsize
operator|=
literal|16
expr_stmt|;
while|while
condition|(
name|newsize
operator|<
name|min
argument_list|(
name|buf
operator|->
name|uio_resid
argument_list|,
name|CHN_2NDBUFMAXSIZE
operator|/
literal|2
argument_list|)
condition|)
name|newsize
operator|<<=
literal|1
expr_stmt|;
name|chn_setblocksize
argument_list|(
name|c
argument_list|,
name|bs
operator|->
name|blkcnt
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"pcm warning: frags reset to %d x %d\n"
argument_list|,
name|bs
operator|->
name|blkcnt
argument_list|,
name|bs
operator|->
name|blksz
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill up the secondary and DMA buffer. 	 * chn_wrfeed*() takes care of the alignment. 	 */
comment|/* Check for underflow before writing into the buffers. */
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_wrfeed2nd
argument_list|(
name|c
argument_list|,
name|buf
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_NBIO
operator|)
operator|&&
operator|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
operator|)
condition|)
name|ret
operator|=
name|EAGAIN
expr_stmt|;
comment|/* Start playing if not yet. */
if|if
condition|(
operator|!
name|b
operator|->
name|dl
condition|)
name|chn_start
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|count
operator|=
name|hz
expr_stmt|;
comment|/* Wait until all samples are played in blocking mode. */
while|while
condition|(
operator|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
operator|)
operator|&&
operator|(
name|count
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Check for underflow before writing into the buffers. */
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Fill up the buffers with new pcm data. */
name|res
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
while|while
condition|(
name|chn_wrfeed2nd
argument_list|(
name|c
argument_list|,
name|buf
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|<
name|res
condition|)
name|count
operator|=
name|hz
expr_stmt|;
else|else
name|count
operator|--
expr_stmt|;
comment|/* Have we finished to feed the secondary buffer? */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
literal|0
condition|)
break|break;
comment|/* Wait for new free space to write new pcm samples. */
comment|/* splx(s); */
name|timeout
operator|=
literal|1
expr_stmt|;
comment|/*(buf->uio_resid>= b->dl)? hz / 20 : 1; */
name|ret
operator|=
name|tsleep
argument_list|(
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmwr"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|/* s = spltty(); */
comment|/* if (ret == EINTR) chn_abort(c); */
if|if
condition|(
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
condition|)
break|break;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|c
operator|->
name|flags
operator||=
name|CHN_F_DEAD
expr_stmt|;
name|device_printf
argument_list|(
name|c
operator|->
name|parent
operator|->
name|dev
argument_list|,
literal|"play interrupt timeout, channel dead\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ret
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_WRITING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * SOUND INPUT  *  The input part is similar to the output one, with a circular buffer split in two regions, and boundaries advancing because of read() calls [r] or dma operation [d].  At initialization, as for the write routine, READY is empty, and FREE takes all the space.        0          rp,rl        fp,fl    bufsize       |__________>____________>________| 	  FREE   r   READY    d  FREE  Operation is as follows: upon user read (dsp_read_body()) a DMA read is started if not already active (marked by b->dl> 0), then as soon as data are available in the READY region they are transferred to the user buffer, thus advancing the boundary between FREE and READY. Upon interrupts, caused by a completion of a DMA transfer, the READY region is extended and possibly a new transfer is started.  When necessary, dsp_rd_dmaupdate() is called to advance fp (and update rl,fl accordingly). Upon user reads, rp is advanced and rl,fl are updated accordingly.  The rules to choose the size of the new DMA area are similar to the other case, with a preferred constant transfer size equal to rec_blocksize, and fallback to smaller sizes if no space is available.   */
end_comment

begin_function
specifier|static
name|int
name|chn_rddump
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|int
name|maxover
decl_stmt|,
name|ss
decl_stmt|;
name|ss
operator|=
literal|1
expr_stmt|;
name|ss
operator|<<=
operator|(
name|b
operator|->
name|fmt
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ss
operator|<<=
operator|(
name|b
operator|->
name|fmt
operator|&
name|AFMT_16BIT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|maxover
operator|=
name|c
operator|->
name|speed
operator|*
name|ss
expr_stmt|;
name|b
operator|->
name|overrun
operator|+=
name|cnt
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|overrun
operator|>
name|maxover
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|parent
operator|->
name|dev
argument_list|,
literal|"record overrun, dumping %d bytes\n"
argument_list|,
name|b
operator|->
name|overrun
argument_list|)
expr_stmt|;
name|b
operator|->
name|overrun
operator|=
literal|0
expr_stmt|;
block|}
name|b
operator|->
name|rl
operator|-=
name|cnt
expr_stmt|;
name|b
operator|->
name|fl
operator|+=
name|cnt
expr_stmt|;
name|b
operator|->
name|rp
operator|=
operator|(
name|b
operator|->
name|rp
operator|+
name|cnt
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function

begin_comment
comment|/*  * Feed new data from the read buffer. Can be called in the bottom half.  * Hence must be called at spltty.  */
end_comment

begin_function
name|int
name|chn_rdfeed
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|l
decl_stmt|,
name|lacc
decl_stmt|;
comment|/* 	printf("b: [rl: %d, rp %d, fl %d, fp %d]; bs: [rl: %d, rp %d, fl %d, fp %d]\n", 		b->rl, b->rp, b->fl, b->fp, bs->rl, bs->rp, bs->fl, bs->fp); 	 */
comment|/* ensure we always have a whole number of samples */
name|lacc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bs
operator|->
name|fl
operator|>=
name|DMA_ALIGN_THRESHOLD
operator|&&
name|b
operator|->
name|rl
operator|>=
name|DMA_ALIGN_THRESHOLD
condition|)
block|{
name|l
operator|=
name|min
argument_list|(
name|min
argument_list|(
name|bs
operator|->
name|fl
argument_list|,
name|bs
operator|->
name|bufsize
operator|-
name|bs
operator|->
name|fp
argument_list|)
argument_list|,
name|min
argument_list|(
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|rp
argument_list|)
argument_list|)
operator|&
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* Move the samples, update the markers and pointers. */
name|bcopy
argument_list|(
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|rp
argument_list|,
name|bs
operator|->
name|buf
operator|+
name|bs
operator|->
name|fp
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|bs
operator|->
name|fl
operator|-=
name|l
expr_stmt|;
name|bs
operator|->
name|rl
operator|+=
name|l
expr_stmt|;
name|bs
operator|->
name|fp
operator|=
operator|(
name|bs
operator|->
name|fp
operator|+
name|l
operator|)
operator|%
name|bs
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|rl
operator|-=
name|l
expr_stmt|;
name|b
operator|->
name|fl
operator|+=
name|l
expr_stmt|;
name|b
operator|->
name|rp
operator|=
operator|(
name|b
operator|->
name|rp
operator|+
name|l
operator|)
operator|%
name|b
operator|->
name|bufsize
expr_stmt|;
comment|/* Accumulate the total bytes of the moved samples. */
name|lacc
operator|+=
name|l
expr_stmt|;
comment|/* A feed from the DMA buffer is equivalent to an interrupt. */
name|bs
operator|->
name|int_count
operator|++
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|sel
operator|.
name|si_pid
operator|&&
name|chn_polltrigger
argument_list|(
name|c
argument_list|)
condition|)
name|selwakeup
argument_list|(
operator|&
name|bs
operator|->
name|sel
argument_list|)
expr_stmt|;
block|}
return|return
name|lacc
return|;
block|}
end_function

begin_comment
comment|/* Feeds new data from the secondary read buffer. */
end_comment

begin_function
specifier|static
name|int
name|chn_rdfeed2nd
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|l
decl_stmt|,
name|w
decl_stmt|,
name|wacc
decl_stmt|;
comment|/* ensure we always have a whole number of samples */
name|wacc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
operator|)
operator|&&
operator|(
name|bs
operator|->
name|rl
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* The DMA buffer may have pcm data. */
comment|/* while (chn_rdfeed(c)> 0); */
comment|/* 		 * The size of the data to move here does not have to be 		 * aligned. We take care of it upon moving the data to a 		 * DMA buffer. 		 */
name|l
operator|=
name|min
argument_list|(
name|bs
operator|->
name|rl
argument_list|,
name|bs
operator|->
name|bufsize
operator|-
name|bs
operator|->
name|rp
argument_list|)
expr_stmt|;
comment|/* Move the samples, update the markers and pointers. */
name|w
operator|=
name|FEEDER_FEED
argument_list|(
name|c
operator|->
name|feeder
argument_list|,
name|c
argument_list|,
name|bs
operator|->
name|buf
operator|+
name|bs
operator|->
name|rp
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"no feed"
argument_list|)
expr_stmt|;
name|bs
operator|->
name|fl
operator|+=
name|w
expr_stmt|;
name|bs
operator|->
name|rl
operator|-=
name|w
expr_stmt|;
name|bs
operator|->
name|rp
operator|=
operator|(
name|bs
operator|->
name|rp
operator|+
name|w
operator|)
operator|%
name|bs
operator|->
name|bufsize
expr_stmt|;
comment|/* Clear the new space in the secondary buffer. */
name|sndbuf_clear
argument_list|(
name|bs
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Accumulate the total bytes of the moved samples. */
name|bs
operator|->
name|total
operator|+=
name|w
expr_stmt|;
name|wacc
operator|+=
name|w
expr_stmt|;
block|}
return|return
name|wacc
return|;
block|}
end_function

begin_comment
comment|/* read interrupt routine. Must be called with interrupts blocked. */
end_comment

begin_function
specifier|static
name|void
name|chn_rdintr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
name|chn_dmadone
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"rdintr: start dl %d, rp:rl %d:%d, fp:fl %d:%d\n"
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|fp
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the pointers. */
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 	 * Suck up the DMA buffer, followed by waking up the top half. 	 * If some of the pcm data in the secondary buffer are still left, 	 * the top half goes to sleep by itself. 	 */
while|while
condition|(
name|chn_rdfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
name|chn_dmawakeup
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|fl
operator|<
name|b
operator|->
name|dl
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"near overflow (%d< %d), %d\n"
argument_list|,
name|b
operator|->
name|fl
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|b
operator|->
name|rl
argument_list|)
argument_list|)
expr_stmt|;
name|chn_rddump
argument_list|(
name|c
argument_list|,
name|b
operator|->
name|blksz
operator|-
name|b
operator|->
name|fl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
condition|)
block|{
comment|/* 	 	 * check if we need to reprogram the DMA on the sound card. 	 	 * This happens if the size has changed from zero 	 	 */
if|if
condition|(
name|b
operator|->
name|dl
operator|==
literal|0
condition|)
block|{
comment|/* Start DMA operation */
name|b
operator|->
name|dl
operator|=
name|b
operator|->
name|blksz
expr_stmt|;
comment|/* record new transfer size */
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_START
argument_list|)
expr_stmt|;
block|}
comment|/*  		 * Emulate writing by DMA, i.e. transfer the pcm data from  		 * the emulated-DMA buffer to the device itself.  		 */
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_EMLDMARD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
comment|/* was active */
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_STOP
argument_list|)
expr_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * body of user-read routine  *  * Start DMA if not active; wait for READY not empty.  * Transfer data from READY region using uiomove(), advance boundary  * between FREE and READY. Repeat until transfer is complete.  *  * To avoid excessive latency in freeing up space for the DMA  * engine, transfers are done in blocks of increasing size, so that  * the latency is proportional to the size of the smallest block, but  * we have a low overhead and are able to feed the dma engine with  * large blocks.  *  * NOTE: in the current version, read will not return more than  * blocksize bytes at once (unless more are already available), to  * avoid that requests using very large buffers block for too long.  */
end_comment

begin_function
name|int
name|chn_read
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|timeout
decl_stmt|,
name|limit
decl_stmt|,
name|res
decl_stmt|,
name|count
decl_stmt|;
name|long
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_READING
condition|)
block|{
comment|/* This shouldn't happen and is actually silly */
name|tsleep
argument_list|(
operator|&
name|s
argument_list|,
name|PZERO
argument_list|,
literal|"pcmrdR"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* Store the initial size in the uio. */
name|res
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_READING
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_ABORTING
expr_stmt|;
comment|/* suck up the DMA and secondary buffers. */
while|while
condition|(
name|chn_rdfeed2nd
argument_list|(
name|c
argument_list|,
name|buf
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
literal|0
condition|)
goto|goto
name|skip
goto|;
name|limit
operator|=
name|res
operator|-
name|b
operator|->
name|blksz
expr_stmt|;
if|if
condition|(
name|limit
operator|<
literal|0
condition|)
name|limit
operator|=
literal|0
expr_stmt|;
comment|/* Start capturing if not yet. */
if|if
condition|(
operator|(
operator|!
name|bs
operator|->
name|rl
operator|||
operator|!
name|b
operator|->
name|rl
operator|)
operator|&&
operator|!
name|b
operator|->
name|dl
condition|)
name|chn_start
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_NBIO
operator|)
condition|)
block|{
name|count
operator|=
name|hz
expr_stmt|;
comment|/* Wait until all samples are captured. */
while|while
condition|(
operator|(
name|buf
operator|->
name|uio_resid
operator|>
literal|0
operator|)
operator|&&
operator|(
name|count
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Suck up the DMA and secondary buffers. */
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|res
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
while|while
condition|(
name|chn_rdfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
while|while
condition|(
name|chn_rdfeed2nd
argument_list|(
name|c
argument_list|,
name|buf
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|<
name|res
condition|)
name|count
operator|=
name|hz
expr_stmt|;
else|else
name|count
operator|--
expr_stmt|;
comment|/* Have we finished to feed the uio? */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
literal|0
condition|)
break|break;
comment|/* Wait for new pcm samples. */
comment|/* splx(s); */
name|timeout
operator|=
operator|(
name|buf
operator|->
name|uio_resid
operator|-
name|limit
operator|>=
name|b
operator|->
name|dl
operator|)
condition|?
name|hz
operator|/
literal|20
else|:
literal|1
expr_stmt|;
name|ret
operator|=
name|tsleep
argument_list|(
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmrd"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* s = spltty(); */
comment|/* if (ret == EINTR) chn_abort(c); */
if|if
condition|(
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
condition|)
break|break;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|c
operator|->
name|flags
operator||=
name|CHN_F_DEAD
expr_stmt|;
name|device_printf
argument_list|(
name|c
operator|->
name|parent
operator|->
name|dev
argument_list|,
literal|"record interrupt timeout, channel dead\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If no pcm data was read on nonblocking, return EAGAIN. */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
name|res
condition|)
name|ret
operator|=
name|EAGAIN
expr_stmt|;
block|}
name|skip
label|:
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_READING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|chn_intr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_INIT
condition|)
name|chn_reinit
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
name|chn_wrintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|chn_rdintr
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|chn_start
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|u_int32_t
name|r
decl_stmt|,
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
operator|==
literal|0
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_NOTRIGGER
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
operator|)
condition|)
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* Fill up the DMA buffer. */
if|if
condition|(
name|force
operator|||
operator|(
name|b
operator|->
name|rl
operator|>=
name|b
operator|->
name|blksz
operator|)
condition|)
name|r
operator|=
name|CHN_F_TRIGGERED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
operator|)
condition|)
while|while
condition|(
name|chn_rdfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* Suck up the DMA buffer. */
if|if
condition|(
name|force
operator|||
operator|(
name|b
operator|->
name|fl
operator|>=
name|b
operator|->
name|blksz
operator|)
condition|)
name|r
operator|=
name|CHN_F_TRIGGERED
expr_stmt|;
block|}
name|c
operator|->
name|flags
operator||=
name|r
expr_stmt|;
name|chn_intr
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|chn_resetbuf
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|c
operator|->
name|blocks
operator|=
literal|0
expr_stmt|;
name|sndbuf_reset
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|sndbuf_reset
argument_list|(
name|bs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chn_sync waits until the space in the given channel goes above  * a threshold. The threshold is checked against fl or rl respectively.  * Assume that the condition can become true, do not check here...  */
end_comment

begin_function
name|int
name|chn_sync
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|threshold
parameter_list|)
block|{
name|u_long
name|s
decl_stmt|,
name|rdy
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
name|rdy
operator|=
operator|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|bs
operator|->
name|fl
else|:
name|bs
operator|->
name|rl
expr_stmt|;
if|if
condition|(
name|rdy
operator|<=
name|threshold
condition|)
block|{
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmsyn"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ERESTART
operator|||
name|ret
operator|==
name|EINTR
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_sync: tsleep returns %d\n"
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_poll
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|ev
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|u_long
name|s
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
block|{
comment|/* Fill up the DMA buffer. */
name|chn_checkunderflow
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_wrfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
block|}
else|else
block|{
comment|/* Suck up the DMA buffer. */
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_rdfeed
argument_list|(
name|c
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
block|}
if|if
condition|(
operator|!
name|b
operator|->
name|dl
condition|)
name|chn_start
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chn_polltrigger
argument_list|(
name|c
argument_list|)
operator|&&
name|chn_pollreset
argument_list|(
name|c
argument_list|)
condition|)
name|ret
operator|=
name|ev
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|bs
operator|->
name|sel
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * chn_abort is a non-blocking function which aborts a pending  * DMA transfer and flushes the buffers.  * It returns the number of bytes that have not been transferred.  */
end_comment

begin_function
name|int
name|chn_abort
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|missing
init|=
literal|0
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|dl
condition|)
return|return
literal|0
return|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_ABORTING
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_TRIGGERED
expr_stmt|;
name|cnt
operator|=
literal|10
expr_stmt|;
while|while
condition|(
operator|!
name|b
operator|->
name|underflow
operator|&&
operator|(
name|cnt
operator|--
operator|>
literal|0
operator|)
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmabr"
argument_list|,
name|hz
operator|/
literal|50
argument_list|)
expr_stmt|;
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_ABORT
argument_list|)
expr_stmt|;
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|missing
operator|=
name|bs
operator|->
name|rl
operator|+
name|b
operator|->
name|rl
expr_stmt|;
return|return
name|missing
return|;
block|}
end_function

begin_comment
comment|/*  * this routine tries to flush the dma transfer. It is called  * on a close. We immediately abort any read DMA  * operation, and then wait for the play buffer to drain.  */
end_comment

begin_function
name|int
name|chn_flush
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|count
decl_stmt|,
name|s
decl_stmt|,
name|resid
decl_stmt|,
name|resid_p
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_flush c->flags 0x%08x\n"
argument_list|,
name|c
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|dl
condition|)
return|return
literal|0
return|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_CLOSING
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_REC
condition|)
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|resid
operator|=
name|b
operator|->
name|rl
operator|+
name|bs
operator|->
name|rl
expr_stmt|;
name|resid_p
operator|=
name|resid
expr_stmt|;
name|count
operator|=
literal|10
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|resid
operator|>
literal|0
operator|)
operator|&&
operator|!
name|b
operator|->
name|underflow
condition|)
block|{
comment|/* still pending output data. */
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"pcmflu"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_flush: tsleep returns %d\n"
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|chn_dmaupdate
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_flush: now rl = %d, fl = %d, resid = %d\n"
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|fl
argument_list|,
name|resid
argument_list|)
argument_list|)
expr_stmt|;
name|resid
operator|=
name|b
operator|->
name|rl
operator|+
name|bs
operator|->
name|rl
expr_stmt|;
if|if
condition|(
name|resid
operator|>=
name|resid_p
condition|)
name|count
operator|--
expr_stmt|;
name|resid_p
operator|=
name|resid
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_flush: timeout flushing dbuf_out, cnt 0x%x flags 0x%x\n"
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|c
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_CLOSING
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fmtvalid
parameter_list|(
name|u_int32_t
name|fmt
parameter_list|,
name|u_int32_t
modifier|*
name|fmtlist
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fmtlist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmt
operator|==
name|fmtlist
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_reset
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|u_int32_t
name|fmt
parameter_list|)
block|{
name|int
name|hwspd
decl_stmt|,
name|r
init|=
literal|0
decl_stmt|;
name|chn_abort
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
name|CHN_F_RESET
expr_stmt|;
name|CHANNEL_RESET
argument_list|(
name|c
operator|->
name|methods
argument_list|,
name|c
operator|->
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
condition|)
block|{
name|hwspd
operator|=
name|DSP_DEFAULT_SPEED
expr_stmt|;
name|RANGE
argument_list|(
name|hwspd
argument_list|,
name|chn_getcaps
argument_list|(
name|c
argument_list|)
operator|->
name|minspeed
argument_list|,
name|chn_getcaps
argument_list|(
name|c
argument_list|)
operator|->
name|maxspeed
argument_list|)
expr_stmt|;
name|c
operator|->
name|speed
operator|=
name|hwspd
expr_stmt|;
name|r
operator|=
name|chn_setformat
argument_list|(
name|c
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|r
operator|=
name|chn_setspeed
argument_list|(
name|c
argument_list|,
name|hwspd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|r
operator|=
name|chn_setvolume
argument_list|(
name|c
argument_list|,
literal|100
argument_list|,
literal|100
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|chn_setblocksize
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|chn_resetbuf
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|CHANNEL_RESETDONE
argument_list|(
name|c
operator|->
name|methods
argument_list|,
name|c
operator|->
name|devinfo
argument_list|)
expr_stmt|;
comment|/* c->flags |= CHN_F_INIT; */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_reinit
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_INIT
operator|)
operator|&&
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|chn_setformat
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|format
argument_list|)
expr_stmt|;
name|chn_setspeed
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|speed
argument_list|)
expr_stmt|;
name|chn_setvolume
argument_list|(
name|c
argument_list|,
operator|(
name|c
operator|->
name|volume
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|c
operator|->
name|volume
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_INIT
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_init
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|feeder_class
modifier|*
name|fc
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
comment|/* Initialize the hardware and DMA buffer first. */
name|c
operator|->
name|feeder
operator|=
name|NULL
expr_stmt|;
name|fc
operator|=
name|feeder_getclass
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|chn_addfeeder
argument_list|(
name|c
argument_list|,
name|fc
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|c
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|feederflags
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|buffer
operator|.
name|chan
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|devinfo
operator|=
name|CHANNEL_INIT
argument_list|(
name|c
operator|->
name|methods
argument_list|,
name|devinfo
argument_list|,
operator|&
name|c
operator|->
name|buffer
argument_list|,
name|c
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|devinfo
operator|==
name|NULL
condition|)
return|return
name|ENODEV
return|;
if|if
condition|(
name|c
operator|->
name|buffer
operator|.
name|bufsize
operator|==
literal|0
condition|)
return|return
name|ENOMEM
return|;
name|chn_setdir
argument_list|(
name|c
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* And the secondary buffer. */
name|bs
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|sndbuf_setfmt
argument_list|(
name|b
argument_list|,
name|AFMT_U8
argument_list|)
expr_stmt|;
name|sndbuf_setfmt
argument_list|(
name|bs
argument_list|,
name|AFMT_U8
argument_list|)
expr_stmt|;
name|bs
operator|->
name|bufsize
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_kill
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_TRIGGERED
condition|)
name|chn_trigger
argument_list|(
name|c
argument_list|,
name|PCMTRIG_ABORT
argument_list|)
expr_stmt|;
while|while
condition|(
name|chn_removefeeder
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|CHANNEL_FREE
argument_list|(
name|c
operator|->
name|methods
argument_list|,
name|c
operator|->
name|devinfo
argument_list|)
condition|)
name|sndbuf_free
argument_list|(
operator|&
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_DEAD
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setdir
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|c
operator|->
name|direction
operator|=
name|dir
expr_stmt|;
name|r
operator|=
name|CHANNEL_SETDIR
argument_list|(
name|c
operator|->
name|methods
argument_list|,
name|c
operator|->
name|devinfo
argument_list|,
name|c
operator|->
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|&&
name|ISA_DMA
argument_list|(
operator|&
name|c
operator|->
name|buffer
argument_list|)
condition|)
name|c
operator|->
name|buffer
operator|.
name|dir
operator|=
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|ISADMA_WRITE
else|:
name|ISADMA_READ
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|chn_setvolume
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|)
block|{
comment|/* could add a feeder for volume changing if channel returns -1 */
if|if
condition|(
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|->
name|volume
operator|=
operator|(
name|left
operator|<<
literal|8
operator|)
operator||
name|right
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|->
name|volume
operator|=
operator|(
name|left
operator|<<
literal|8
operator|)
operator||
name|right
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setspeed
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|speed
parameter_list|)
block|{
name|pcm_feeder
modifier|*
name|f
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|r
decl_stmt|,
name|delta
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"want speed %d, "
argument_list|,
name|speed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|<=
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|->
name|speed
operator|=
name|speed
expr_stmt|;
name|b
operator|->
name|spd
operator|=
name|speed
expr_stmt|;
name|bs
operator|->
name|spd
operator|=
name|speed
expr_stmt|;
name|RANGE
argument_list|(
name|b
operator|->
name|spd
argument_list|,
name|chn_getcaps
argument_list|(
name|c
argument_list|)
operator|->
name|minspeed
argument_list|,
name|chn_getcaps
argument_list|(
name|c
argument_list|)
operator|->
name|maxspeed
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"try speed %d, "
argument_list|,
name|b
operator|->
name|spd
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|spd
operator|=
name|CHANNEL_SETSPEED
argument_list|(
name|c
operator|->
name|methods
argument_list|,
name|c
operator|->
name|devinfo
argument_list|,
name|b
operator|->
name|spd
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"got speed %d, "
argument_list|,
name|b
operator|->
name|spd
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|b
operator|->
name|spd
operator|-
name|bs
operator|->
name|spd
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
name|c
operator|->
name|feederflags
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|FEEDER_RATE
operator|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|500
condition|)
name|c
operator|->
name|feederflags
operator||=
literal|1
operator|<<
name|FEEDER_RATE
expr_stmt|;
else|else
name|bs
operator|->
name|spd
operator|=
name|b
operator|->
name|spd
expr_stmt|;
name|r
operator|=
name|chn_buildfeeder
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"r = %d\n"
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|r
operator|=
name|chn_setblocksize
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|feederflags
operator|&
operator|(
literal|1
operator|<<
name|FEEDER_RATE
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|f
operator|=
name|chn_findfeeder
argument_list|(
name|c
argument_list|,
name|FEEDER_RATE
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"feedrate = %p\n"
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|r
operator|=
name|FEEDER_SET
argument_list|(
name|f
argument_list|,
name|FEEDRATE_SRC
argument_list|,
name|bs
operator|->
name|spd
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"feeder_set(FEEDRATE_SRC, %d) = %d\n"
argument_list|,
name|bs
operator|->
name|spd
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|r
operator|=
name|FEEDER_SET
argument_list|(
name|f
argument_list|,
name|FEEDRATE_DST
argument_list|,
name|b
operator|->
name|spd
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"feeder_set(FEEDRATE_DST, %d) = %d\n"
argument_list|,
name|b
operator|->
name|spd
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
return|return
literal|0
return|;
block|}
name|c
operator|->
name|speed
operator|=
name|speed
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setformat
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|u_int32_t
name|fmt
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|r
decl_stmt|;
name|u_int32_t
name|hwfmt
decl_stmt|;
if|if
condition|(
name|CANCHANGE
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"want format %d\n"
argument_list|,
name|fmt
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|format
operator|=
name|fmt
expr_stmt|;
name|hwfmt
operator|=
name|c
operator|->
name|format
expr_stmt|;
name|c
operator|->
name|feederflags
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|FEEDER_FMT
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|fmtvalid
argument_list|(
name|hwfmt
argument_list|,
name|chn_getcaps
argument_list|(
name|c
argument_list|)
operator|->
name|fmtlist
argument_list|)
condition|)
name|c
operator|->
name|feederflags
operator||=
literal|1
operator|<<
name|FEEDER_FMT
expr_stmt|;
name|r
operator|=
name|chn_buildfeeder
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|hwfmt
operator|=
name|c
operator|->
name|feeder
operator|->
name|desc
operator|->
name|out
expr_stmt|;
name|sndbuf_setfmt
argument_list|(
name|b
argument_list|,
name|hwfmt
argument_list|)
expr_stmt|;
name|sndbuf_setfmt
argument_list|(
name|bs
argument_list|,
name|hwfmt
argument_list|)
expr_stmt|;
name|chn_resetbuf
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|CHANNEL_SETFORMAT
argument_list|(
name|c
operator|->
name|methods
argument_list|,
name|c
operator|->
name|devinfo
argument_list|,
name|hwfmt
argument_list|)
expr_stmt|;
return|return
name|chn_setspeed
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|speed
argument_list|)
return|;
block|}
name|c
operator|->
name|format
operator|=
name|fmt
expr_stmt|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_INIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_setblocksize
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|blkcnt
parameter_list|,
name|int
name|blksz
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|snd_dbuf
modifier|*
name|bs
init|=
operator|&
name|c
operator|->
name|buffer2nd
decl_stmt|;
name|int
name|s
decl_stmt|,
name|bufsz
decl_stmt|,
name|irqhz
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|CANCHANGE
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|blksz
operator|==
literal|0
operator|||
name|blksz
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|blksz
operator|==
operator|-
literal|1
condition|)
name|c
operator|->
name|flags
operator|&=
operator|~
name|CHN_F_HAS_SIZE
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_HAS_SIZE
condition|)
return|return
literal|0
return|;
name|blksz
operator|=
operator|(
name|bs
operator|->
name|bps
operator|*
name|bs
operator|->
name|spd
operator|)
operator|/
name|CHN_DEFAULT_HZ
expr_stmt|;
name|tmp
operator|=
literal|32
expr_stmt|;
while|while
condition|(
name|tmp
operator|<=
name|blksz
condition|)
name|tmp
operator|<<=
literal|1
expr_stmt|;
name|tmp
operator|>>=
literal|1
expr_stmt|;
name|blksz
operator|=
name|tmp
expr_stmt|;
name|RANGE
argument_list|(
name|blksz
argument_list|,
literal|16
argument_list|,
name|CHN_2NDBUFMAXSIZE
operator|/
literal|2
argument_list|)
expr_stmt|;
name|RANGE
argument_list|(
name|blkcnt
argument_list|,
literal|2
argument_list|,
name|CHN_2NDBUFMAXSIZE
operator|/
name|blksz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|blksz
operator|<
literal|16
operator|)
operator|||
operator|(
name|blkcnt
operator|<
literal|2
operator|)
operator|||
operator|(
name|blkcnt
operator|*
name|blksz
operator|>
name|CHN_2NDBUFMAXSIZE
operator|)
condition|)
return|return
name|EINVAL
return|;
name|c
operator|->
name|flags
operator||=
name|CHN_F_HAS_SIZE
expr_stmt|;
block|}
name|bufsz
operator|=
name|blkcnt
operator|*
name|blksz
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bs
operator|->
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bs
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|bufsz
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"chn_setblocksize: out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
name|bs
operator|->
name|bufsize
operator|=
name|bufsz
expr_stmt|;
name|bs
operator|->
name|blkcnt
operator|=
name|blkcnt
expr_stmt|;
name|bs
operator|->
name|blksz
operator|=
name|blksz
expr_stmt|;
comment|/* adjust for different hw format/speed */
name|irqhz
operator|=
operator|(
name|bs
operator|->
name|bps
operator|*
name|bs
operator|->
name|spd
operator|)
operator|/
name|bs
operator|->
name|blksz
expr_stmt|;
if|if
condition|(
name|irqhz
operator|<
literal|16
condition|)
name|irqhz
operator|=
literal|16
expr_stmt|;
name|b
operator|->
name|blksz
operator|=
operator|(
name|b
operator|->
name|bps
operator|*
name|b
operator|->
name|spd
operator|)
operator|/
name|irqhz
expr_stmt|;
comment|/* round down to 2^x */
name|blksz
operator|=
literal|32
expr_stmt|;
while|while
condition|(
name|blksz
operator|<=
name|b
operator|->
name|blksz
condition|)
name|blksz
operator|<<=
literal|1
expr_stmt|;
name|blksz
operator|>>=
literal|1
expr_stmt|;
comment|/* round down to fit hw buffer size */
name|RANGE
argument_list|(
name|blksz
argument_list|,
literal|16
argument_list|,
name|b
operator|->
name|maxsize
operator|/
literal|2
argument_list|)
expr_stmt|;
name|b
operator|->
name|blksz
operator|=
name|CHANNEL_SETBLOCKSIZE
argument_list|(
name|c
operator|->
name|methods
argument_list|,
name|c
operator|->
name|devinfo
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|chn_resetbuf
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|chn_trigger
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|go
parameter_list|)
block|{
return|return
name|CHANNEL_TRIGGER
argument_list|(
name|c
operator|->
name|methods
argument_list|,
name|c
operator|->
name|devinfo
argument_list|,
name|go
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|chn_getptr
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|hwptr
decl_stmt|;
name|int
name|a
init|=
operator|(
literal|1
operator|<<
name|c
operator|->
name|align
operator|)
operator|-
literal|1
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
name|c
operator|->
name|buffer
decl_stmt|;
name|hwptr
operator|=
name|b
operator|->
name|dl
condition|?
name|CHANNEL_GETPTR
argument_list|(
name|c
operator|->
name|methods
argument_list|,
name|c
operator|->
name|devinfo
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* don't allow unaligned values in the hwa ptr */
name|hwptr
operator|&=
operator|~
name|a
expr_stmt|;
comment|/* Apply channel align mask */
name|hwptr
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* Apply DMA align mask */
return|return
name|hwptr
return|;
block|}
end_function

begin_function
name|pcmchan_caps
modifier|*
name|chn_getcaps
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
return|return
name|CHANNEL_GETCAPS
argument_list|(
name|c
operator|->
name|methods
argument_list|,
name|c
operator|->
name|devinfo
argument_list|)
return|;
block|}
end_function

begin_function
name|u_int32_t
name|chn_getformats
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|fmtlist
decl_stmt|,
name|fmts
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fmtlist
operator|=
name|chn_getcaps
argument_list|(
name|c
argument_list|)
operator|->
name|fmtlist
expr_stmt|;
name|fmts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fmtlist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fmts
operator||=
name|fmtlist
index|[
name|i
index|]
expr_stmt|;
return|return
name|fmts
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chn_buildfeeder
parameter_list|(
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|feeder_class
modifier|*
name|fc
decl_stmt|;
name|struct
name|pcm_feederdesc
name|desc
decl_stmt|;
name|u_int32_t
name|tmp
index|[
literal|2
index|]
decl_stmt|,
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|type
decl_stmt|,
name|flags
decl_stmt|;
while|while
condition|(
name|chn_removefeeder
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
name|KASSERT
argument_list|(
operator|(
name|c
operator|->
name|feeder
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"feeder chain not empty"
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|align
operator|=
literal|0
expr_stmt|;
name|fc
operator|=
name|feeder_getclass
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|chn_addfeeder
argument_list|(
name|c
argument_list|,
name|fc
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|c
operator|->
name|feeder
operator|->
name|desc
operator|->
name|out
operator|=
name|c
operator|->
name|format
expr_stmt|;
name|flags
operator|=
name|c
operator|->
name|feederflags
expr_stmt|;
name|src
operator|=
name|c
operator|->
name|feeder
operator|->
name|desc
operator|->
name|out
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_MAPPED
operator|)
operator|&&
operator|(
name|flags
operator|!=
literal|0
operator|)
condition|)
return|return
name|EINVAL
return|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"not mapped, flags %x, "
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|type
operator|=
name|FEEDER_RATE
init|;
name|type
operator|<=
name|FEEDER_LAST
condition|;
name|type
operator|++
control|)
block|{
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
name|type
operator|)
condition|)
block|{
name|desc
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|desc
operator|.
name|in
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|out
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"find feeder type %d, "
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|=
name|feeder_getclass
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"got %p\n"
argument_list|,
name|fc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|dst
operator|=
name|fc
operator|->
name|desc
operator|->
name|in
expr_stmt|;
if|if
condition|(
name|src
operator|!=
name|dst
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"build fmtchain from %x to %x: "
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
name|dst
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chn_fmtchain
argument_list|(
name|c
argument_list|,
name|tmp
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"ok\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chn_addfeeder
argument_list|(
name|c
argument_list|,
name|fc
argument_list|,
name|fc
operator|->
name|desc
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|src
operator|=
name|fc
operator|->
name|desc
operator|->
name|out
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"added feeder %p, output %x\n"
argument_list|,
name|fc
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
literal|0
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|type
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fmtvalid
argument_list|(
name|src
argument_list|,
name|chn_getcaps
argument_list|(
name|c
argument_list|)
operator|->
name|fmtlist
argument_list|)
condition|)
block|{
if|if
condition|(
name|chn_fmtchain
argument_list|(
name|c
argument_list|,
name|chn_getcaps
argument_list|(
name|c
argument_list|)
operator|->
name|fmtlist
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"built fmtchain from %x to %x\n"
argument_list|,
name|src
argument_list|,
name|c
operator|->
name|feeder
operator|->
name|desc
operator|->
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|FEEDER_FMT
operator|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

