begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Cameron Grant<cg@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/ac97.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/ac97_patch.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"mixer_if.h"
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_AC97
argument_list|,
literal|"ac97"
argument_list|,
literal|"ac97 codec"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ac97mixtable_entry
block|{
name|int
name|reg
range|:
literal|8
decl_stmt|;
comment|/* register index		*/
comment|/* reg< 0 if inverted polarity	*/
name|unsigned
name|bits
range|:
literal|4
decl_stmt|;
comment|/* width of control field	*/
name|unsigned
name|ofs
range|:
literal|4
decl_stmt|;
comment|/* offset (only if stereo=0)	*/
name|unsigned
name|stereo
range|:
literal|1
decl_stmt|;
comment|/* set for stereo controls	*/
name|unsigned
name|mute
range|:
literal|1
decl_stmt|;
comment|/* bit15 is MUTE		*/
name|unsigned
name|recidx
range|:
literal|4
decl_stmt|;
comment|/* index in rec mux		*/
name|unsigned
name|mask
range|:
literal|1
decl_stmt|;
comment|/* use only masked bits		*/
name|unsigned
name|enable
range|:
literal|1
decl_stmt|;
comment|/* entry is enabled		*/
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AC97_NAMELEN
value|16
end_define

begin_struct
struct|struct
name|ac97_info
block|{
name|kobj_t
name|methods
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|void
modifier|*
name|devinfo
decl_stmt|;
name|u_int32_t
name|id
decl_stmt|;
name|unsigned
name|count
decl_stmt|,
name|caps
decl_stmt|,
name|se
decl_stmt|,
name|extcaps
decl_stmt|,
name|extid
decl_stmt|,
name|extstat
decl_stmt|,
name|noext
range|:
literal|1
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|struct
name|ac97mixtable_entry
name|mix
index|[
literal|32
index|]
decl_stmt|;
name|char
name|name
index|[
name|AC97_NAMELEN
index|]
decl_stmt|;
name|struct
name|mtx
modifier|*
name|lock
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ac97_vendorid
block|{
name|u_int32_t
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ac97_codecid
block|{
name|u_int32_t
name|id
decl_stmt|;
name|u_int8_t
name|stepmask
decl_stmt|;
name|u_int8_t
name|noext
range|:
literal|1
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|ac97_patch
name|patch
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ac97mixtable_entry
name|ac97mixtable_default
index|[
literal|32
index|]
init|=
block|{
comment|/*	[offset]			reg	     bits of st mu re mk en */
index|[
name|SOUND_MIXER_VOLUME
index|]
operator|=
block|{
name|AC97_MIX_MASTER
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|6
block|,
literal|0
block|,
literal|1
block|}
block|,
index|[
name|SOUND_MIXER_OGAIN
index|]
operator|=
block|{
name|AC97_MIX_AUXOUT
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_PHONEOUT
index|]
operator|=
block|{
name|AC97_MIX_MONO
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|7
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_BASS
index|]
operator|=
block|{
name|AC97_MIX_TONE
block|,
literal|4
block|,
literal|8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_TREBLE
index|]
operator|=
block|{
name|AC97_MIX_TONE
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_PCM
index|]
operator|=
block|{
name|AC97_MIX_PCM
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
index|[
name|SOUND_MIXER_SPEAKER
index|]
operator|=
block|{
name|AC97_MIX_BEEP
block|,
literal|4
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_LINE
index|]
operator|=
block|{
name|AC97_MIX_LINE
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|}
block|,
index|[
name|SOUND_MIXER_PHONEIN
index|]
operator|=
block|{
name|AC97_MIX_PHONE
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|8
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_MIC
index|]
operator|=
block|{
name|AC97_MIX_MIC
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* use igain for the mic 20dB boost */
index|[
name|SOUND_MIXER_IGAIN
index|]
operator|=
block|{
operator|-
name|AC97_MIX_MIC
block|,
literal|1
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
index|[
name|SOUND_MIXER_CD
index|]
operator|=
block|{
name|AC97_MIX_CD
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|}
block|,
index|[
name|SOUND_MIXER_LINE1
index|]
operator|=
block|{
name|AC97_MIX_AUX
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_VIDEO
index|]
operator|=
block|{
name|AC97_MIX_VIDEO
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_RECLEV
index|]
operator|=
block|{
operator|-
name|AC97_MIX_RGAIN
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ac97_vendorid
name|ac97vendorid
index|[]
init|=
block|{
block|{
literal|0x41445300
block|,
literal|"Analog Devices"
block|}
block|,
block|{
literal|0x414b4d00
block|,
literal|"Asahi Kasei"
block|}
block|,
block|{
literal|0x414c4300
block|,
literal|"Realtek"
block|}
block|,
block|{
literal|0x414c4700
block|,
literal|"Avance Logic"
block|}
block|,
block|{
literal|0x43525900
block|,
literal|"Cirrus Logic"
block|}
block|,
block|{
literal|0x434d4900
block|,
literal|"C-Media Electronics"
block|}
block|,
block|{
literal|0x43585400
block|,
literal|"Conexant"
block|}
block|,
block|{
literal|0x44543000
block|,
literal|"Diamond Technology"
block|}
block|,
block|{
literal|0x454d4300
block|,
literal|"eMicro"
block|}
block|,
block|{
literal|0x45838300
block|,
literal|"ESS Technology"
block|}
block|,
block|{
literal|0x48525300
block|,
literal|"Intersil"
block|}
block|,
block|{
literal|0x49434500
block|,
literal|"ICEnsemble"
block|}
block|,
block|{
literal|0x49544500
block|,
literal|"ITE, Inc."
block|}
block|,
block|{
literal|0x4e534300
block|,
literal|"National Semiconductor"
block|}
block|,
block|{
literal|0x50534300
block|,
literal|"Philips Semiconductor"
block|}
block|,
block|{
literal|0x83847600
block|,
literal|"SigmaTel"
block|}
block|,
block|{
literal|0x53494c00
block|,
literal|"Silicon Laboratories"
block|}
block|,
block|{
literal|0x54524100
block|,
literal|"TriTech"
block|}
block|,
block|{
literal|0x54584e00
block|,
literal|"Texas Instruments"
block|}
block|,
block|{
literal|0x56494100
block|,
literal|"VIA Technologies"
block|}
block|,
block|{
literal|0x57454300
block|,
literal|"Winbond"
block|}
block|,
block|{
literal|0x574d4c00
block|,
literal|"Wolfson"
block|}
block|,
block|{
literal|0x594d4800
block|,
literal|"Yamaha"
block|}
block|,
comment|/*  	 * XXX This is a fluke, really! The real vendor 	 * should be SigmaTel, not this! This should be 	 * removed someday! 	 */
block|{
literal|0x01408300
block|,
literal|"Creative"
block|}
block|,
block|{
literal|0x00000000
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ac97_codecid
name|ac97codecid
index|[]
init|=
block|{
block|{
literal|0x41445303
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AD1819"
block|,
literal|0
block|}
block|,
block|{
literal|0x41445340
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AD1881"
block|,
literal|0
block|}
block|,
block|{
literal|0x41445348
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AD1881A"
block|,
literal|0
block|}
block|,
block|{
literal|0x41445360
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AD1885"
block|,
literal|0
block|}
block|,
block|{
literal|0x41445361
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AD1886"
block|,
name|ad1886_patch
block|}
block|,
block|{
literal|0x41445362
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AD1887"
block|,
literal|0
block|}
block|,
block|{
literal|0x41445363
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AD1886A"
block|,
literal|0
block|}
block|,
block|{
literal|0x41445368
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AD1888"
block|,
name|ad198x_patch
block|}
block|,
block|{
literal|0x41445370
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AD1980"
block|,
name|ad198x_patch
block|}
block|,
block|{
literal|0x41445372
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AD1981A"
block|,
literal|0
block|}
block|,
block|{
literal|0x41445374
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AD1981B"
block|,
name|ad1981b_patch
block|}
block|,
block|{
literal|0x41445375
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AD1985"
block|,
name|ad198x_patch
block|}
block|,
block|{
literal|0x41445378
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AD1986"
block|,
name|ad198x_patch
block|}
block|,
block|{
literal|0x414b4d00
block|,
literal|0x00
block|,
literal|1
block|,
literal|"AK4540"
block|,
literal|0
block|}
block|,
block|{
literal|0x414b4d01
block|,
literal|0x00
block|,
literal|1
block|,
literal|"AK4542"
block|,
literal|0
block|}
block|,
block|{
literal|0x414b4d02
block|,
literal|0x00
block|,
literal|1
block|,
literal|"AK4543"
block|,
literal|0
block|}
block|,
block|{
literal|0x414b4d06
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AK4544A"
block|,
literal|0
block|}
block|,
block|{
literal|0x454b4d07
block|,
literal|0x00
block|,
literal|0
block|,
literal|"AK4545"
block|,
literal|0
block|}
block|,
block|{
literal|0x414c4320
block|,
literal|0x0f
block|,
literal|0
block|,
literal|"ALC100"
block|,
literal|0
block|}
block|,
block|{
literal|0x414c4730
block|,
literal|0x0f
block|,
literal|0
block|,
literal|"ALC101"
block|,
literal|0
block|}
block|,
block|{
literal|0x414c4710
block|,
literal|0x0f
block|,
literal|0
block|,
literal|"ALC200"
block|,
literal|0
block|}
block|,
block|{
literal|0x414c4740
block|,
literal|0x0f
block|,
literal|0
block|,
literal|"ALC202"
block|,
literal|0
block|}
block|,
block|{
literal|0x414c4720
block|,
literal|0x0f
block|,
literal|0
block|,
literal|"ALC650"
block|,
literal|0
block|}
block|,
block|{
literal|0x414c4752
block|,
literal|0x0f
block|,
literal|0
block|,
literal|"ALC250"
block|,
literal|0
block|}
block|,
block|{
literal|0x414c4760
block|,
literal|0x0f
block|,
literal|0
block|,
literal|"ALC655"
block|,
literal|0
block|}
block|,
block|{
literal|0x414c4770
block|,
literal|0x0f
block|,
literal|0
block|,
literal|"ALC203"
block|,
literal|0
block|}
block|,
block|{
literal|0x414c4780
block|,
literal|0x0f
block|,
literal|0
block|,
literal|"ALC658"
block|,
literal|0
block|}
block|,
block|{
literal|0x414c4790
block|,
literal|0x0f
block|,
literal|0
block|,
literal|"ALC850"
block|,
literal|0
block|}
block|,
block|{
literal|0x43525900
block|,
literal|0x07
block|,
literal|0
block|,
literal|"CS4297"
block|,
literal|0
block|}
block|,
block|{
literal|0x43525910
block|,
literal|0x07
block|,
literal|0
block|,
literal|"CS4297A"
block|,
literal|0
block|}
block|,
block|{
literal|0x43525920
block|,
literal|0x07
block|,
literal|0
block|,
literal|"CS4294/98"
block|,
literal|0
block|}
block|,
block|{
literal|0x4352592d
block|,
literal|0x07
block|,
literal|0
block|,
literal|"CS4294"
block|,
literal|0
block|}
block|,
block|{
literal|0x43525930
block|,
literal|0x07
block|,
literal|0
block|,
literal|"CS4299"
block|,
literal|0
block|}
block|,
block|{
literal|0x43525940
block|,
literal|0x07
block|,
literal|0
block|,
literal|"CS4201"
block|,
literal|0
block|}
block|,
block|{
literal|0x43525958
block|,
literal|0x07
block|,
literal|0
block|,
literal|"CS4205"
block|,
literal|0
block|}
block|,
block|{
literal|0x43525960
block|,
literal|0x07
block|,
literal|0
block|,
literal|"CS4291A"
block|,
literal|0
block|}
block|,
block|{
literal|0x434d4961
block|,
literal|0x00
block|,
literal|0
block|,
literal|"CMI9739"
block|,
name|cmi9739_patch
block|}
block|,
block|{
literal|0x434d4941
block|,
literal|0x00
block|,
literal|0
block|,
literal|"CMI9738"
block|,
literal|0
block|}
block|,
block|{
literal|0x434d4978
block|,
literal|0x00
block|,
literal|0
block|,
literal|"CMI9761"
block|,
literal|0
block|}
block|,
block|{
literal|0x434d4982
block|,
literal|0x00
block|,
literal|0
block|,
literal|"CMI9761"
block|,
literal|0
block|}
block|,
block|{
literal|0x434d4983
block|,
literal|0x00
block|,
literal|0
block|,
literal|"CMI9761"
block|,
literal|0
block|}
block|,
block|{
literal|0x43585421
block|,
literal|0x00
block|,
literal|0
block|,
literal|"HSD11246"
block|,
literal|0
block|}
block|,
block|{
literal|0x43585428
block|,
literal|0x07
block|,
literal|0
block|,
literal|"CX20468"
block|,
literal|0
block|}
block|,
block|{
literal|0x43585430
block|,
literal|0x00
block|,
literal|0
block|,
literal|"CX20468-21"
block|,
literal|0
block|}
block|,
block|{
literal|0x44543000
block|,
literal|0x00
block|,
literal|0
block|,
literal|"DT0398"
block|,
literal|0
block|}
block|,
block|{
literal|0x454d4323
block|,
literal|0x00
block|,
literal|0
block|,
literal|"EM28023"
block|,
literal|0
block|}
block|,
block|{
literal|0x454d4328
block|,
literal|0x00
block|,
literal|0
block|,
literal|"EM28028"
block|,
literal|0
block|}
block|,
block|{
literal|0x45838308
block|,
literal|0x00
block|,
literal|0
block|,
literal|"ES1988"
block|,
literal|0
block|}
block|,
comment|/* Formerly ES1921(?) */
block|{
literal|0x48525300
block|,
literal|0x00
block|,
literal|0
block|,
literal|"HMP9701"
block|,
literal|0
block|}
block|,
block|{
literal|0x49434501
block|,
literal|0x00
block|,
literal|0
block|,
literal|"ICE1230"
block|,
literal|0
block|}
block|,
block|{
literal|0x49434511
block|,
literal|0x00
block|,
literal|0
block|,
literal|"ICE1232"
block|,
literal|0
block|}
block|,
block|{
literal|0x49434514
block|,
literal|0x00
block|,
literal|0
block|,
literal|"ICE1232A"
block|,
literal|0
block|}
block|,
block|{
literal|0x49434551
block|,
literal|0x03
block|,
literal|0
block|,
literal|"VT1616"
block|,
literal|0
block|}
block|,
comment|/* Via badged ICE */
block|{
literal|0x49544520
block|,
literal|0x00
block|,
literal|0
block|,
literal|"ITE2226E"
block|,
literal|0
block|}
block|,
block|{
literal|0x49544560
block|,
literal|0x07
block|,
literal|0
block|,
literal|"ITE2646E"
block|,
literal|0
block|}
block|,
comment|/* XXX: patch needed */
block|{
literal|0x4e534340
block|,
literal|0x00
block|,
literal|0
block|,
literal|"LM4540"
block|,
literal|0
block|}
block|,
comment|/* Spec blank on revid */
block|{
literal|0x4e534343
block|,
literal|0x00
block|,
literal|0
block|,
literal|"LM4543"
block|,
literal|0
block|}
block|,
comment|/* Ditto */
block|{
literal|0x4e534346
block|,
literal|0x00
block|,
literal|0
block|,
literal|"LM4546A"
block|,
literal|0
block|}
block|,
block|{
literal|0x4e534348
block|,
literal|0x00
block|,
literal|0
block|,
literal|"LM4548A"
block|,
literal|0
block|}
block|,
block|{
literal|0x4e534331
block|,
literal|0x00
block|,
literal|0
block|,
literal|"LM4549"
block|,
literal|0
block|}
block|,
block|{
literal|0x4e534349
block|,
literal|0x00
block|,
literal|0
block|,
literal|"LM4549A"
block|,
literal|0
block|}
block|,
block|{
literal|0x4e534350
block|,
literal|0x00
block|,
literal|0
block|,
literal|"LM4550"
block|,
literal|0
block|}
block|,
block|{
literal|0x50534301
block|,
literal|0x00
block|,
literal|0
block|,
literal|"UCB1510"
block|,
literal|0
block|}
block|,
block|{
literal|0x50534304
block|,
literal|0x00
block|,
literal|0
block|,
literal|"UCB1400"
block|,
literal|0
block|}
block|,
block|{
literal|0x83847600
block|,
literal|0x00
block|,
literal|0
block|,
literal|"STAC9700/83/84"
block|,
literal|0
block|}
block|,
block|{
literal|0x83847604
block|,
literal|0x00
block|,
literal|0
block|,
literal|"STAC9701/03/04/05"
block|,
literal|0
block|}
block|,
block|{
literal|0x83847605
block|,
literal|0x00
block|,
literal|0
block|,
literal|"STAC9704"
block|,
literal|0
block|}
block|,
block|{
literal|0x83847608
block|,
literal|0x00
block|,
literal|0
block|,
literal|"STAC9708/11"
block|,
literal|0
block|}
block|,
block|{
literal|0x83847609
block|,
literal|0x00
block|,
literal|0
block|,
literal|"STAC9721/23"
block|,
literal|0
block|}
block|,
block|{
literal|0x83847644
block|,
literal|0x00
block|,
literal|0
block|,
literal|"STAC9744/45"
block|,
literal|0
block|}
block|,
block|{
literal|0x83847650
block|,
literal|0x00
block|,
literal|0
block|,
literal|"STAC9750/51"
block|,
literal|0
block|}
block|,
block|{
literal|0x83847652
block|,
literal|0x00
block|,
literal|0
block|,
literal|"STAC9752/53"
block|,
literal|0
block|}
block|,
block|{
literal|0x83847656
block|,
literal|0x00
block|,
literal|0
block|,
literal|"STAC9756/57"
block|,
literal|0
block|}
block|,
block|{
literal|0x83847658
block|,
literal|0x00
block|,
literal|0
block|,
literal|"STAC9758/59"
block|,
literal|0
block|}
block|,
block|{
literal|0x83847660
block|,
literal|0x00
block|,
literal|0
block|,
literal|"STAC9760/61"
block|,
literal|0
block|}
block|,
comment|/* Extrapolated */
block|{
literal|0x83847662
block|,
literal|0x00
block|,
literal|0
block|,
literal|"STAC9762/63"
block|,
literal|0
block|}
block|,
comment|/* Extrapolated */
block|{
literal|0x83847666
block|,
literal|0x00
block|,
literal|0
block|,
literal|"STAC9766/67"
block|,
literal|0
block|}
block|,
block|{
literal|0x53494c22
block|,
literal|0x00
block|,
literal|0
block|,
literal|"Si3036"
block|,
literal|0
block|}
block|,
block|{
literal|0x53494c23
block|,
literal|0x00
block|,
literal|0
block|,
literal|"Si3038"
block|,
literal|0
block|}
block|,
block|{
literal|0x54524103
block|,
literal|0x00
block|,
literal|0
block|,
literal|"TR28023"
block|,
literal|0
block|}
block|,
comment|/* Extrapolated */
block|{
literal|0x54524106
block|,
literal|0x00
block|,
literal|0
block|,
literal|"TR28026"
block|,
literal|0
block|}
block|,
block|{
literal|0x54524108
block|,
literal|0x00
block|,
literal|0
block|,
literal|"TR28028"
block|,
literal|0
block|}
block|,
block|{
literal|0x54524123
block|,
literal|0x00
block|,
literal|0
block|,
literal|"TR28602"
block|,
literal|0
block|}
block|,
block|{
literal|0x54524e03
block|,
literal|0x07
block|,
literal|0
block|,
literal|"TLV320AIC27"
block|,
literal|0
block|}
block|,
block|{
literal|0x54584e20
block|,
literal|0x00
block|,
literal|0
block|,
literal|"TLC320AD90"
block|,
literal|0
block|}
block|,
block|{
literal|0x56494161
block|,
literal|0x00
block|,
literal|0
block|,
literal|"VIA1612A"
block|,
literal|0
block|}
block|,
block|{
literal|0x56494170
block|,
literal|0x00
block|,
literal|0
block|,
literal|"VIA1617A"
block|,
literal|0
block|}
block|,
block|{
literal|0x574d4c00
block|,
literal|0x00
block|,
literal|0
block|,
literal|"WM9701A"
block|,
literal|0
block|}
block|,
block|{
literal|0x574d4c03
block|,
literal|0x00
block|,
literal|0
block|,
literal|"WM9703/4/7/8"
block|,
literal|0
block|}
block|,
block|{
literal|0x574d4c04
block|,
literal|0x00
block|,
literal|0
block|,
literal|"WM9704Q"
block|,
literal|0
block|}
block|,
block|{
literal|0x574d4c05
block|,
literal|0x00
block|,
literal|0
block|,
literal|"WM9705/10"
block|,
literal|0
block|}
block|,
block|{
literal|0x574d4d09
block|,
literal|0x00
block|,
literal|0
block|,
literal|"WM9709"
block|,
literal|0
block|}
block|,
block|{
literal|0x574d4c12
block|,
literal|0x00
block|,
literal|0
block|,
literal|"WM9711/12"
block|,
literal|0
block|}
block|,
comment|/* XXX: patch needed */
block|{
literal|0x57454301
block|,
literal|0x00
block|,
literal|0
block|,
literal|"W83971D"
block|,
literal|0
block|}
block|,
block|{
literal|0x594d4800
block|,
literal|0x00
block|,
literal|0
block|,
literal|"YMF743"
block|,
literal|0
block|}
block|,
block|{
literal|0x594d4802
block|,
literal|0x00
block|,
literal|0
block|,
literal|"YMF752"
block|,
literal|0
block|}
block|,
block|{
literal|0x594d4803
block|,
literal|0x00
block|,
literal|0
block|,
literal|"YMF753"
block|,
literal|0
block|}
block|,
comment|/*  	 * XXX This is a fluke, really! The real codec 	 * should be STAC9704, not this! This should be 	 * removed someday! 	 */
block|{
literal|0x01408384
block|,
literal|0x00
block|,
literal|0
block|,
literal|"EV1938"
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ac97enhancement
index|[]
init|=
block|{
literal|"no 3D Stereo Enhancement"
block|,
literal|"Analog Devices Phat Stereo"
block|,
literal|"Creative Stereo Enhancement"
block|,
literal|"National Semi 3D Stereo Enhancement"
block|,
literal|"Yamaha Ymersion"
block|,
literal|"BBE 3D Stereo Enhancement"
block|,
literal|"Crystal Semi 3D Stereo Enhancement"
block|,
literal|"Qsound QXpander"
block|,
literal|"Spatializer 3D Stereo Enhancement"
block|,
literal|"SRS 3D Stereo Enhancement"
block|,
literal|"Platform Tech 3D Stereo Enhancement"
block|,
literal|"AKM 3D Audio"
block|,
literal|"Aureal Stereo Enhancement"
block|,
literal|"Aztech 3D Enhancement"
block|,
literal|"Binaura 3D Audio Enhancement"
block|,
literal|"ESS Technology Stereo Enhancement"
block|,
literal|"Harman International VMAx"
block|,
literal|"Nvidea 3D Stereo Enhancement"
block|,
literal|"Philips Incredible Sound"
block|,
literal|"Texas Instruments 3D Stereo Enhancement"
block|,
literal|"VLSI Technology 3D Stereo Enhancement"
block|,
literal|"TriTech 3D Stereo Enhancement"
block|,
literal|"Realtek 3D Stereo Enhancement"
block|,
literal|"Samsung 3D Stereo Enhancement"
block|,
literal|"Wolfson Microelectronics 3D Enhancement"
block|,
literal|"Delta Integration 3D Enhancement"
block|,
literal|"SigmaTel 3D Enhancement"
block|,
literal|"Reserved 27"
block|,
literal|"Rockwell 3D Stereo Enhancement"
block|,
literal|"Reserved 29"
block|,
literal|"Reserved 30"
block|,
literal|"Reserved 31"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ac97feature
index|[]
init|=
block|{
literal|"mic channel"
block|,
literal|"reserved"
block|,
literal|"tone"
block|,
literal|"simulated stereo"
block|,
literal|"headphone"
block|,
literal|"bass boost"
block|,
literal|"18 bit DAC"
block|,
literal|"20 bit DAC"
block|,
literal|"18 bit ADC"
block|,
literal|"20 bit ADC"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ac97extfeature
index|[]
init|=
block|{
literal|"variable rate PCM"
block|,
literal|"double rate PCM"
block|,
literal|"reserved 1"
block|,
literal|"variable rate mic"
block|,
literal|"reserved 2"
block|,
literal|"reserved 3"
block|,
literal|"center DAC"
block|,
literal|"surround DAC"
block|,
literal|"LFE DAC"
block|,
literal|"AMAP"
block|,
literal|"reserved 4"
block|,
literal|"reserved 5"
block|,
literal|"reserved 6"
block|,
literal|"reserved 7"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|u_int16_t
name|ac97_rdcd
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
if|if
condition|(
name|codec
operator|->
name|flags
operator|&
name|AC97_F_RDCD_BUG
condition|)
block|{
name|u_int16_t
name|i
index|[
literal|2
index|]
decl_stmt|,
name|j
init|=
literal|100
decl_stmt|;
name|i
index|[
literal|0
index|]
operator|=
name|AC97_READ
argument_list|(
name|codec
operator|->
name|methods
argument_list|,
name|codec
operator|->
name|devinfo
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|i
index|[
literal|1
index|]
operator|=
name|AC97_READ
argument_list|(
name|codec
operator|->
name|methods
argument_list|,
name|codec
operator|->
name|devinfo
argument_list|,
name|reg
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
index|[
literal|0
index|]
operator|!=
name|i
index|[
literal|1
index|]
operator|&&
name|j
condition|)
name|i
index|[
name|j
operator|--
operator|&
literal|1
index|]
operator|=
name|AC97_READ
argument_list|(
name|codec
operator|->
name|methods
argument_list|,
name|codec
operator|->
name|devinfo
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (j< 100) { 			device_printf(codec->dev, "%s(): Inconsistent register value at" 					" 0x%08x (retry: %d)\n", __func__, reg, 100 - j); 		}
endif|#
directive|endif
return|return
name|i
index|[
operator|!
operator|(
name|j
operator|&
literal|1
operator|)
index|]
return|;
block|}
return|return
name|AC97_READ
argument_list|(
name|codec
operator|->
name|methods
argument_list|,
name|codec
operator|->
name|devinfo
argument_list|,
name|reg
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ac97_wrcd
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|,
name|int
name|reg
parameter_list|,
name|u_int16_t
name|val
parameter_list|)
block|{
name|AC97_WRITE
argument_list|(
name|codec
operator|->
name|methods
argument_list|,
name|codec
operator|->
name|devinfo
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ac97_reset
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|)
block|{
name|u_int32_t
name|i
decl_stmt|,
name|ps
decl_stmt|;
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|500
condition|;
name|i
operator|++
control|)
block|{
name|ps
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_POWER
argument_list|)
operator|&
name|AC97_POWER_STATUS
expr_stmt|;
if|if
condition|(
name|ps
operator|==
name|AC97_POWER_STATUS
condition|)
return|return;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|codec
operator|->
name|dev
argument_list|,
literal|"AC97 reset timed out.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ac97_setrate
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|,
name|int
name|which
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
name|u_int16_t
name|v
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|AC97_REGEXT_FDACRATE
case|:
case|case
name|AC97_REGEXT_SDACRATE
case|:
case|case
name|AC97_REGEXT_LDACRATE
case|:
case|case
name|AC97_REGEXT_LADCRATE
case|:
case|case
name|AC97_REGEXT_MADCRATE
case|:
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
name|snd_mtxlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate
operator|!=
literal|0
condition|)
block|{
name|v
operator|=
name|rate
expr_stmt|;
if|if
condition|(
name|codec
operator|->
name|extstat
operator|&
name|AC97_EXTCAP_DRA
condition|)
name|v
operator|>>=
literal|1
expr_stmt|;
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|which
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|v
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|which
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|->
name|extstat
operator|&
name|AC97_EXTCAP_DRA
condition|)
name|v
operator|<<=
literal|1
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|int
name|ac97_setextmode
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|,
name|u_int16_t
name|mode
parameter_list|)
block|{
name|mode
operator|&=
name|AC97_EXTCAPS
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
operator|~
name|codec
operator|->
name|extcaps
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|codec
operator|->
name|dev
argument_list|,
literal|"ac97 invalid mode set 0x%04x\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|snd_mtxlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|AC97_REGEXT_STAT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|codec
operator|->
name|extstat
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REGEXT_STAT
argument_list|)
operator|&
name|AC97_EXTCAPS
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|mode
operator|==
name|codec
operator|->
name|extstat
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|u_int16_t
name|ac97_getextmode
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|)
block|{
return|return
name|codec
operator|->
name|extstat
return|;
block|}
end_function

begin_function
name|u_int16_t
name|ac97_getextcaps
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|)
block|{
return|return
name|codec
operator|->
name|extcaps
return|;
block|}
end_function

begin_function
name|u_int16_t
name|ac97_getcaps
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|)
block|{
return|return
name|codec
operator|->
name|caps
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ac97_setrecsrc
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|struct
name|ac97mixtable_entry
modifier|*
name|e
init|=
operator|&
name|codec
operator|->
name|mix
index|[
name|channel
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|recidx
operator|>
literal|0
condition|)
block|{
name|int
name|val
init|=
name|e
operator|->
name|recidx
operator|-
literal|1
decl_stmt|;
name|val
operator||=
name|val
operator|<<
literal|8
expr_stmt|;
name|snd_mtxlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_RECSEL
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ac97_setmixer
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|,
name|unsigned
name|channel
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|struct
name|ac97mixtable_entry
modifier|*
name|e
init|=
operator|&
name|codec
operator|->
name|mix
index|[
name|channel
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|reg
operator|&&
name|e
operator|->
name|enable
operator|&&
name|e
operator|->
name|bits
condition|)
block|{
name|int
name|mask
decl_stmt|,
name|max
decl_stmt|,
name|val
decl_stmt|,
name|reg
decl_stmt|;
name|reg
operator|=
operator|(
name|e
operator|->
name|reg
operator|>=
literal|0
operator|)
condition|?
name|e
operator|->
name|reg
else|:
operator|-
name|e
operator|->
name|reg
expr_stmt|;
comment|/* AC97 register    */
name|max
operator|=
operator|(
literal|1
operator|<<
name|e
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* actual range	    */
name|mask
operator|=
operator|(
name|max
operator|<<
literal|8
operator|)
operator||
name|max
expr_stmt|;
comment|/* bits of interest */
if|if
condition|(
operator|!
name|e
operator|->
name|stereo
condition|)
name|right
operator|=
name|left
expr_stmt|;
comment|/* 		 * Invert the range if the polarity requires so, 		 * then scale to 0..max-1 to compute the value to 		 * write into the codec, and scale back to 0..100 		 * for the return value. 		 */
if|if
condition|(
name|e
operator|->
name|reg
operator|>
literal|0
condition|)
block|{
name|left
operator|=
literal|100
operator|-
name|left
expr_stmt|;
name|right
operator|=
literal|100
operator|-
name|right
expr_stmt|;
block|}
name|left
operator|=
operator|(
name|left
operator|*
name|max
operator|)
operator|/
literal|100
expr_stmt|;
name|right
operator|=
operator|(
name|right
operator|*
name|max
operator|)
operator|/
literal|100
expr_stmt|;
name|val
operator|=
operator|(
name|left
operator|<<
literal|8
operator|)
operator||
name|right
expr_stmt|;
name|left
operator|=
operator|(
name|left
operator|*
literal|100
operator|)
operator|/
name|max
expr_stmt|;
name|right
operator|=
operator|(
name|right
operator|*
literal|100
operator|)
operator|/
name|max
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|reg
operator|>
literal|0
condition|)
block|{
name|left
operator|=
literal|100
operator|-
name|left
expr_stmt|;
name|right
operator|=
literal|100
operator|-
name|right
expr_stmt|;
block|}
comment|/* 		 * For mono controls, trim val and mask, also taking 		 * care of e->ofs (offset of control field). 		 */
if|if
condition|(
name|e
operator|->
name|ofs
condition|)
block|{
name|val
operator|&=
name|max
expr_stmt|;
name|val
operator|<<=
name|e
operator|->
name|ofs
expr_stmt|;
name|mask
operator|=
operator|(
name|max
operator|<<
name|e
operator|->
name|ofs
operator|)
expr_stmt|;
block|}
comment|/* 		 * If we have a mute bit, add it to the mask and 		 * update val and set mute if both channels require a 		 * zero volume. 		 */
if|if
condition|(
name|e
operator|->
name|mute
operator|==
literal|1
condition|)
block|{
name|mask
operator||=
name|AC97_MUTE
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
operator|&&
name|right
operator|==
literal|0
condition|)
name|val
operator|=
name|AC97_MUTE
expr_stmt|;
block|}
comment|/* 		 * If the mask bit is set, do not alter the other bits. 		 */
name|snd_mtxlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|mask
condition|)
block|{
name|int
name|cur
init|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|val
operator||=
name|cur
operator|&
operator|~
operator|(
name|mask
operator|)
expr_stmt|;
block|}
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|left
operator||
operator|(
name|right
operator|<<
literal|8
operator|)
return|;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|printf("ac97_setmixer: reg=%d, bits=%d, enable=%d\n", e->reg, e->bits, e->enable);
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ac97_fix_auxout
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|)
block|{
name|int
name|keep_ogain
decl_stmt|;
comment|/* 	 * By default, The ac97 aux_out register (0x04) corresponds to OSS's 	 * OGAIN setting. 	 * 	 * We first check whether aux_out is a valid register.  If not 	 * we may not want to keep ogain. 	 */
name|keep_ogain
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_MIX_AUXOUT
argument_list|)
operator|&
literal|0x8000
expr_stmt|;
comment|/* 	 * Determine what AUX_OUT really means, it can be: 	 * 	 * 1. Headphone out. 	 * 2. 4-Channel Out 	 * 3. True line level out (effectively master volume). 	 * 	 * See Sections 5.2.1 and 5.27 for AUX_OUT Options in AC97r2.{2,3}. 	 */
if|if
condition|(
name|codec
operator|->
name|extcaps
operator|&
name|AC97_EXTCAP_SDAC
operator|&&
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_MIXEXT_SURROUND
argument_list|)
operator|==
literal|0x8080
condition|)
block|{
name|codec
operator|->
name|mix
index|[
name|SOUND_MIXER_OGAIN
index|]
operator|.
name|reg
operator|=
name|AC97_MIXEXT_SURROUND
expr_stmt|;
name|keep_ogain
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|keep_ogain
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|codec
operator|->
name|mix
index|[
name|SOUND_MIXER_OGAIN
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|codec
operator|->
name|mix
index|[
name|SOUND_MIXER_OGAIN
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ac97_fix_tone
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|)
block|{
comment|/* Hide treble and bass if they don't exist */
if|if
condition|(
operator|(
name|codec
operator|->
name|caps
operator|&
name|AC97_CAP_TONE
operator|)
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|codec
operator|->
name|mix
index|[
name|SOUND_MIXER_BASS
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|codec
operator|->
name|mix
index|[
name|SOUND_MIXER_BASS
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|codec
operator|->
name|mix
index|[
name|SOUND_MIXER_TREBLE
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|codec
operator|->
name|mix
index|[
name|SOUND_MIXER_TREBLE
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ac97_hw_desc
parameter_list|(
name|u_int32_t
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|vname
parameter_list|,
specifier|const
name|char
modifier|*
name|cname
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|cname
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown AC97 Codec (id = 0x%08x)"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
if|if
condition|(
name|vname
operator|==
name|NULL
condition|)
name|vname
operator|=
literal|"Unknown"
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s AC97 Codec (id = 0x%08x)"
argument_list|,
name|vname
argument_list|,
name|cname
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s AC97 Codec"
argument_list|,
name|vname
argument_list|,
name|cname
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|ac97_initmixer
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|)
block|{
name|ac97_patch
name|codec_patch
decl_stmt|;
specifier|const
name|char
modifier|*
name|cname
decl_stmt|,
modifier|*
name|vname
decl_stmt|;
name|char
name|desc
index|[
literal|80
index|]
decl_stmt|;
name|u_int8_t
name|model
decl_stmt|,
name|step
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|bit
decl_stmt|,
name|old
decl_stmt|;
name|u_int32_t
name|id
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|snd_mtxlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
name|codec
operator|->
name|count
operator|=
name|AC97_INIT
argument_list|(
name|codec
operator|->
name|methods
argument_list|,
name|codec
operator|->
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|codec
operator|->
name|dev
argument_list|,
literal|"ac97 codec init failed\n"
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_POWER
argument_list|,
operator|(
name|codec
operator|->
name|flags
operator|&
name|AC97_F_EAPD_INV
operator|)
condition|?
literal|0x8000
else|:
literal|0x0000
argument_list|)
expr_stmt|;
name|ac97_reset
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_POWER
argument_list|,
operator|(
name|codec
operator|->
name|flags
operator|&
name|AC97_F_EAPD_INV
operator|)
condition|?
literal|0x8000
else|:
literal|0x0000
argument_list|)
expr_stmt|;
name|i
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_RESET
argument_list|)
expr_stmt|;
name|j
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * Let see if this codec can return consistent value. 	 * If not, turn on aggressive read workaround 	 * (STAC9704 comes in mind). 	 */
if|if
condition|(
name|i
operator|!=
name|j
condition|)
block|{
name|codec
operator|->
name|flags
operator||=
name|AC97_F_RDCD_BUG
expr_stmt|;
name|i
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_RESET
argument_list|)
expr_stmt|;
block|}
name|codec
operator|->
name|caps
operator|=
name|i
operator|&
literal|0x03ff
expr_stmt|;
name|codec
operator|->
name|se
operator|=
operator|(
name|i
operator|&
literal|0x7c00
operator|)
operator|>>
literal|10
expr_stmt|;
name|id
operator|=
operator|(
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_ID1
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_ID2
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
operator|||
name|id
operator|==
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|codec
operator|->
name|dev
argument_list|,
literal|"ac97 codec invalid or not present (id == %x)\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
name|codec
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|codec
operator|->
name|noext
operator|=
literal|0
expr_stmt|;
name|codec_patch
operator|=
name|NULL
expr_stmt|;
name|cname
operator|=
name|NULL
expr_stmt|;
name|model
operator|=
name|step
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ac97codecid
index|[
name|i
index|]
operator|.
name|id
condition|;
name|i
operator|++
control|)
block|{
name|u_int32_t
name|modelmask
init|=
literal|0xffffffff
operator|^
name|ac97codecid
index|[
name|i
index|]
operator|.
name|stepmask
decl_stmt|;
if|if
condition|(
operator|(
name|ac97codecid
index|[
name|i
index|]
operator|.
name|id
operator|&
name|modelmask
operator|)
operator|==
operator|(
name|id
operator|&
name|modelmask
operator|)
condition|)
block|{
name|codec
operator|->
name|noext
operator|=
name|ac97codecid
index|[
name|i
index|]
operator|.
name|noext
expr_stmt|;
name|codec_patch
operator|=
name|ac97codecid
index|[
name|i
index|]
operator|.
name|patch
expr_stmt|;
name|cname
operator|=
name|ac97codecid
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|model
operator|=
operator|(
name|id
operator|&
name|modelmask
operator|)
operator|&
literal|0xff
expr_stmt|;
name|step
operator|=
operator|(
name|id
operator|&
operator|~
name|modelmask
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
block|}
block|}
name|vname
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ac97vendorid
index|[
name|i
index|]
operator|.
name|id
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ac97vendorid
index|[
name|i
index|]
operator|.
name|id
operator|==
operator|(
name|id
operator|&
literal|0xffffff00
operator|)
condition|)
block|{
name|vname
operator|=
name|ac97vendorid
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
break|break;
block|}
block|}
name|codec
operator|->
name|extcaps
operator|=
literal|0
expr_stmt|;
name|codec
operator|->
name|extid
operator|=
literal|0
expr_stmt|;
name|codec
operator|->
name|extstat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|codec
operator|->
name|noext
condition|)
block|{
name|i
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REGEXT_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0xffff
condition|)
block|{
name|codec
operator|->
name|extcaps
operator|=
name|i
operator|&
literal|0x3fff
expr_stmt|;
name|codec
operator|->
name|extid
operator|=
operator|(
name|i
operator|&
literal|0xc000
operator|)
operator|>>
literal|14
expr_stmt|;
name|codec
operator|->
name|extstat
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REGEXT_STAT
argument_list|)
operator|&
name|AC97_EXTCAPS
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|=
name|ac97mixtable_default
index|[
name|i
index|]
expr_stmt|;
block|}
name|ac97_fix_auxout
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|ac97_fix_tone
argument_list|(
name|codec
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec_patch
condition|)
name|codec_patch
argument_list|(
name|codec
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|k
operator|=
name|codec
operator|->
name|noext
condition|?
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|.
name|enable
else|:
literal|1
expr_stmt|;
name|reg
operator|=
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|reg
operator|<
literal|0
condition|)
name|reg
operator|=
operator|-
name|reg
expr_stmt|;
if|if
condition|(
name|k
operator|&&
name|reg
condition|)
block|{
name|j
operator|=
name|old
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* 			 * Test for mute bit (except for AC97_MIX_TONE, 			 * where we simply assume it as available). 			 */
if|if
condition|(
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|.
name|mute
condition|)
block|{
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|reg
argument_list|,
name|j
operator||
literal|0x8000
argument_list|)
expr_stmt|;
name|j
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|j
operator||=
literal|0x8000
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|&
literal|0x8000
operator|)
condition|)
block|{
comment|/* 				 * Test whether the control width should be 				 * 4, 5 or 6 bit. For 5bit register, we should 				 * test it whether it's really 5 or 6bit. Leave 				 * 4bit register alone, because sometimes an 				 * attempt to write past 4th bit may cause 				 * incorrect result especially for AC97_MIX_BEEP 				 * (ac97 2.3). 				 */
name|bit
operator|=
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|.
name|bits
expr_stmt|;
if|if
condition|(
name|bit
operator|==
literal|5
condition|)
name|bit
operator|++
expr_stmt|;
name|j
operator|=
operator|(
operator|(
literal|1
operator|<<
name|bit
operator|)
operator|-
literal|1
operator|)
operator|<<
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|.
name|ofs
expr_stmt|;
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|reg
argument_list|,
name|j
operator||
operator|(
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|.
name|mute
condition|?
literal|0x8000
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|k
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|reg
argument_list|)
operator|&
name|j
expr_stmt|;
name|k
operator|>>=
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|.
name|ofs
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|AC97_MIX_TONE
operator|&&
operator|(
operator|(
name|k
operator|&
literal|0x0001
operator|)
operator|==
literal|0x0000
operator|)
condition|)
name|k
operator|>>=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|k
operator|>>
name|j
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|device_printf(codec->dev, "%2d: [ac97_rdcd() = %d] [Testbit = %d] %d -> %d\n", 						i, k, bit, codec->mix[i].bits, j);
endif|#
directive|endif
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|.
name|bits
operator|=
name|j
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|==
name|AC97_MIX_BEEP
condition|)
block|{
comment|/* 					 * Few codec such as CX20468-21 does 					 * have this control register, although 					 * the only usable part is the mute bit. 					 */
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|reg
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("mixch %d, en=%d, b=%d\n", i, codec->mix[i].enable, codec->mix[i].bits);
endif|#
directive|endif
block|}
name|device_printf
argument_list|(
name|codec
operator|->
name|dev
argument_list|,
literal|"<%s>\n"
argument_list|,
name|ac97_hw_desc
argument_list|(
name|codec
operator|->
name|id
argument_list|,
name|vname
argument_list|,
name|cname
argument_list|,
name|desc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|codec
operator|->
name|flags
operator|&
name|AC97_F_RDCD_BUG
condition|)
name|device_printf
argument_list|(
name|codec
operator|->
name|dev
argument_list|,
literal|"Buggy AC97 Codec: aggressive ac97_rdcd() workaround enabled\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|codec
operator|->
name|dev
argument_list|,
literal|"Codec features "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|codec
operator|->
name|caps
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|j
operator|++
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|ac97feature
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d bit master volume"
argument_list|,
name|j
operator|++
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|codec
operator|->
name|mix
index|[
name|SOUND_MIXER_VOLUME
index|]
operator|.
name|bits
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s\n"
argument_list|,
name|j
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|ac97enhancement
index|[
name|codec
operator|->
name|se
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|->
name|extcaps
operator|!=
literal|0
operator|||
name|codec
operator|->
name|extid
condition|)
block|{
name|device_printf
argument_list|(
name|codec
operator|->
name|dev
argument_list|,
literal|"%s codec"
argument_list|,
name|codec
operator|->
name|extid
condition|?
literal|"Secondary"
else|:
literal|"Primary"
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|->
name|extcaps
condition|)
name|printf
argument_list|(
literal|" extended features "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|14
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|codec
operator|->
name|extcaps
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|j
operator|++
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|ac97extfeature
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_POWER
argument_list|)
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
literal|100
condition|)
block|{
name|device_printf
argument_list|(
name|codec
operator|->
name|dev
argument_list|,
literal|"ac97 codec reports dac not ready\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|codec
operator|->
name|dev
argument_list|,
literal|"ac97 codec dac ready count: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|ac97_reinitmixer
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|)
block|{
name|snd_mtxlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
name|codec
operator|->
name|count
operator|=
name|AC97_INIT
argument_list|(
name|codec
operator|->
name|methods
argument_list|,
name|codec
operator|->
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|codec
operator|->
name|dev
argument_list|,
literal|"ac97 codec init failed\n"
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_POWER
argument_list|,
operator|(
name|codec
operator|->
name|flags
operator|&
name|AC97_F_EAPD_INV
operator|)
condition|?
literal|0x8000
else|:
literal|0x0000
argument_list|)
expr_stmt|;
name|ac97_reset
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_POWER
argument_list|,
operator|(
name|codec
operator|->
name|flags
operator|&
name|AC97_F_EAPD_INV
operator|)
condition|?
literal|0x8000
else|:
literal|0x0000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|codec
operator|->
name|noext
condition|)
block|{
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|AC97_REGEXT_STAT
argument_list|,
name|codec
operator|->
name|extstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REGEXT_STAT
argument_list|)
operator|&
name|AC97_EXTCAPS
operator|)
operator|!=
name|codec
operator|->
name|extstat
condition|)
name|device_printf
argument_list|(
name|codec
operator|->
name|dev
argument_list|,
literal|"ac97 codec failed to reset extended mode (%x, got %x)\n"
argument_list|,
name|codec
operator|->
name|extstat
argument_list|,
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REGEXT_STAT
argument_list|)
operator|&
name|AC97_EXTCAPS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_POWER
argument_list|)
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|codec
operator|->
name|dev
argument_list|,
literal|"ac97 codec reports dac not ready\n"
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|ac97_info
modifier|*
name|ac97_create
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|kobj_class_t
name|cls
parameter_list|)
block|{
name|struct
name|ac97_info
modifier|*
name|codec
decl_stmt|;
name|int
name|eapdinv
decl_stmt|;
name|codec
operator|=
operator|(
expr|struct
name|ac97_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|codec
argument_list|,
name|M_AC97
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|snprintf
argument_list|(
name|codec
operator|->
name|name
argument_list|,
name|AC97_NAMELEN
argument_list|,
literal|"%s:ac97"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|codec
operator|->
name|lock
operator|=
name|snd_mtxcreate
argument_list|(
name|codec
operator|->
name|name
argument_list|,
literal|"ac97 codec"
argument_list|)
expr_stmt|;
name|codec
operator|->
name|methods
operator|=
name|kobj_create
argument_list|(
name|cls
argument_list|,
name|M_AC97
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|->
name|methods
operator|==
name|NULL
condition|)
block|{
name|snd_mtxlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
name|snd_mtxfree
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|codec
argument_list|,
name|M_AC97
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|codec
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|codec
operator|->
name|devinfo
operator|=
name|devinfo
expr_stmt|;
name|codec
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"eapdinv"
argument_list|,
operator|&
name|eapdinv
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|eapdinv
operator|!=
literal|0
condition|)
name|codec
operator|->
name|flags
operator||=
name|AC97_F_EAPD_INV
expr_stmt|;
block|}
return|return
name|codec
return|;
block|}
end_function

begin_function
name|void
name|ac97_destroy
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|)
block|{
name|snd_mtxlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|->
name|methods
operator|!=
name|NULL
condition|)
name|kobj_delete
argument_list|(
name|codec
operator|->
name|methods
argument_list|,
name|M_AC97
argument_list|)
expr_stmt|;
name|snd_mtxfree
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|codec
argument_list|,
name|M_AC97
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ac97_setflags
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|,
name|u_int32_t
name|val
parameter_list|)
block|{
name|codec
operator|->
name|flags
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|ac97_getflags
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|)
block|{
return|return
name|codec
operator|->
name|flags
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SND_DYNSYSCTL
end_ifdef

begin_function
specifier|static
name|int
name|sysctl_hw_snd_ac97_eapd
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ac97_info
modifier|*
name|codec
decl_stmt|;
name|int
name|ea
decl_stmt|,
name|inv
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|val
decl_stmt|;
name|codec
operator|=
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
operator|||
name|codec
operator|->
name|id
operator|==
literal|0
operator|||
name|codec
operator|->
name|lock
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|snd_mtxlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
name|val
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_POWER
argument_list|)
expr_stmt|;
name|inv
operator|=
operator|(
name|codec
operator|->
name|flags
operator|&
name|AC97_F_EAPD_INV
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|ea
operator|=
operator|(
name|val
operator|>>
literal|15
operator|)
operator|^
name|inv
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|ea
argument_list|,
sizeof|sizeof
argument_list|(
name|ea
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ea
operator|!=
literal|0
operator|&&
name|ea
operator|!=
literal|1
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|ea
operator|!=
operator|(
operator|(
name|val
operator|>>
literal|15
operator|)
operator|^
name|inv
operator|)
condition|)
block|{
name|snd_mtxlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_POWER
argument_list|,
name|val
operator|^
literal|0x8000
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ac97_init_sysctl
parameter_list|(
name|struct
name|ac97_info
modifier|*
name|codec
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SND_DYNSYSCTL
name|u_int16_t
name|orig
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
operator|||
name|codec
operator|->
name|dev
operator|==
name|NULL
condition|)
return|return;
name|snd_mtxlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
name|orig
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_POWER
argument_list|)
expr_stmt|;
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_POWER
argument_list|,
name|orig
operator|^
literal|0x8000
argument_list|)
expr_stmt|;
name|val
operator|=
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_POWER
argument_list|)
expr_stmt|;
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|AC97_REG_POWER
argument_list|,
name|orig
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|codec
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0x8000
operator|)
operator|==
operator|(
name|orig
operator|&
literal|0x8000
operator|)
condition|)
return|return;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|codec
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|codec
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"eapd"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|codec
argument_list|,
sizeof|sizeof
argument_list|(
name|codec
argument_list|)
argument_list|,
name|sysctl_hw_snd_ac97_eapd
argument_list|,
literal|"I"
argument_list|,
literal|"AC97 External Amplifier"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|ac97mix_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ac97_info
modifier|*
name|codec
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|u_int32_t
name|subvendor
decl_stmt|;
name|u_int32_t
name|i
decl_stmt|,
name|mask
decl_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ac97_initmixer
argument_list|(
name|codec
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|codec
operator|->
name|id
condition|)
block|{
case|case
literal|0x41445374
case|:
comment|/* AD1981B */
name|subvendor
operator|=
operator|(
name|u_int32_t
operator|)
name|pci_get_subdevice
argument_list|(
name|codec
operator|->
name|dev
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|subvendor
operator||=
operator|(
name|u_int32_t
operator|)
name|pci_get_subvendor
argument_list|(
name|codec
operator|->
name|dev
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
comment|/* IBM Thinkcentre */
if|if
condition|(
name|subvendor
operator|==
literal|0x02d91014
condition|)
block|{
comment|/* Enable headphone jack sensing */
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
literal|0x72
argument_list|,
name|ac97_rdcd
argument_list|(
name|codec
argument_list|,
literal|0x72
argument_list|)
operator||
literal|0x0800
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|codec
operator|->
name|mix
index|[
name|SOUND_MIXER_OGAIN
index|]
operator|.
name|enable
condition|)
name|mask
operator||=
name|SOUND_MASK_OGAIN
expr_stmt|;
if|if
condition|(
name|codec
operator|->
name|mix
index|[
name|SOUND_MIXER_PHONEOUT
index|]
operator|.
name|enable
condition|)
name|mask
operator||=
name|SOUND_MASK_PHONEOUT
expr_stmt|;
comment|/* Tie ogain/phone to master volume */
if|if
condition|(
name|codec
operator|->
name|mix
index|[
name|SOUND_MIXER_VOLUME
index|]
operator|.
name|enable
condition|)
name|mix_setparentchild
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|mask
argument_list|)
expr_stmt|;
else|else
block|{
name|mix_setparentchild
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mix_setrealdev
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|SOUND_MIXER_NONE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x434d4941
case|:
comment|/* CMI9738 */
case|case
literal|0x434d4961
case|:
comment|/* CMI9739 */
case|case
literal|0x434d4978
case|:
comment|/* CMI9761 */
case|case
literal|0x434d4982
case|:
comment|/* CMI9761 */
case|case
literal|0x434d4983
case|:
comment|/* CMI9761 */
name|ac97_wrcd
argument_list|(
name|codec
argument_list|,
name|AC97_MIX_PCM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|codec
operator|->
name|mix
index|[
name|SOUND_MIXER_PCM
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|codec
operator|->
name|mix
index|[
name|SOUND_MIXER_PCM
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|device_get_softc
argument_list|(
name|codec
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
name|d
operator|->
name|flags
operator||=
name|SD_F_SOFTPCMVOL
expr_stmt|;
comment|/* XXX How about master volume ? */
break|break;
default|default:
break|break;
block|}
if|#
directive|if
literal|0
comment|/* XXX For the sake of debugging purposes */
block|mix_setparentchild(m, SOUND_MIXER_VOLUME, 	    SOUND_MASK_PCM | SOUND_MASK_CD); 	mix_setrealdev(m, SOUND_MIXER_VOLUME, SOUND_MIXER_NONE); 	ac97_wrcd(codec, AC97_MIX_MASTER, 0);
endif|#
directive|endif
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|mask
operator||=
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|.
name|enable
condition|?
literal|1
operator|<<
name|i
else|:
literal|0
expr_stmt|;
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|mask
operator||=
name|codec
operator|->
name|mix
index|[
name|i
index|]
operator|.
name|recidx
condition|?
literal|1
operator|<<
name|i
else|:
literal|0
expr_stmt|;
name|mix_setrecdevs
argument_list|(
name|m
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|ac97_init_sysctl
argument_list|(
name|codec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ac97mix_uninit
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ac97_info
modifier|*
name|codec
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	if (ac97_uninitmixer(codec)) 		return -1; 	*/
name|ac97_destroy
argument_list|(
name|codec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ac97mix_reinit
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ac97_info
modifier|*
name|codec
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ac97_reinitmixer
argument_list|(
name|codec
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ac97mix_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|dev
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|struct
name|ac97_info
modifier|*
name|codec
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ac97_setmixer
argument_list|(
name|codec
argument_list|,
name|dev
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ac97mix_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|u_int32_t
name|src
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ac97_info
modifier|*
name|codec
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|src
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
return|return
operator|(
name|ac97_setrecsrc
argument_list|(
name|codec
argument_list|,
name|i
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|1
operator|<<
name|i
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|ac97mixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|ac97mix_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_uninit
argument_list|,
name|ac97mix_uninit
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_reinit
argument_list|,
name|ac97mix_reinit
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|ac97mix_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_setrecsrc
argument_list|,
name|ac97mix_setrecsrc
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|ac97mixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_function
name|kobj_class_t
name|ac97_getmixerclass
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|ac97mixer_class
return|;
block|}
end_function

end_unit

