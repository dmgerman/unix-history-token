begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2001 Eduardo Horvath.  * Copyright (c) 2001-2003 Thomas Moestl  * Copyright (c) 2007-2009 Marius Strobl<marius@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR  ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: NetBSD: gem.c,v 1.21 2002/06/01 23:50:58 lukem Exp  *	from: FreeBSD: if_gem.c 182060 2008-08-23 15:03:26Z marius  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * driver for Sun Cassini/Cassini+ and National Semiconductor DP83065  * Saturn Gigabit Ethernet controllers  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|CAS_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__powerpc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparc64__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<machine/ofw_machdep.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/cas/if_casreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/cas/if_casvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_define
define|#
directive|define
name|RINGASSERT
parameter_list|(
name|n
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
define|\
value|CTASSERT(powerof2(n)&& (n)>= (min)&& (n)<= (max))
end_define

begin_expr_stmt
name|RINGASSERT
argument_list|(
name|CAS_NRXCOMP
argument_list|,
literal|128
argument_list|,
literal|32768
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RINGASSERT
argument_list|(
name|CAS_NRXDESC
argument_list|,
literal|32
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RINGASSERT
argument_list|(
name|CAS_NRXDESC2
argument_list|,
literal|32
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RINGASSERT
argument_list|(
name|CAS_NTXDESC
argument_list|,
literal|32
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|RINGASSERT
end_undef

begin_define
define|#
directive|define
name|CCDASSERT
parameter_list|(
name|m
parameter_list|,
name|a
parameter_list|)
define|\
value|CTASSERT((offsetof(struct cas_control_data, m)& ((a) - 1)) == 0)
end_define

begin_expr_stmt
name|CCDASSERT
argument_list|(
name|ccd_rxcomps
argument_list|,
name|CAS_RX_COMP_ALIGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CCDASSERT
argument_list|(
name|ccd_rxdescs
argument_list|,
name|CAS_RX_DESC_ALIGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CCDASSERT
argument_list|(
name|ccd_rxdescs2
argument_list|,
name|CAS_RX_DESC_ALIGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|CCDASSERT
end_undef

begin_define
define|#
directive|define
name|CAS_TRIES
value|10000
end_define

begin_comment
comment|/*  * According to documentation, the hardware has support for basic TCP  * checksum offloading only, in practice this can be also used for UDP  * however (i.e. the problem of previous Sun NICs that a checksum of 0x0  * is not converted to 0xffff no longer exists).  */
end_comment

begin_define
define|#
directive|define
name|CAS_CSUM_FEATURES
value|(CSUM_TCP | CSUM_UDP)
end_define

begin_function_decl
specifier|static
specifier|inline
name|void
name|cas_add_rxdesc
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|idx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_attach
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_bitwait
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|r
parameter_list|,
name|uint32_t
name|clr
parameter_list|,
name|uint32_t
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_cddma_callback
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_detach
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_disable_rx
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_disable_tx
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_eint
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_free
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_init_locked
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_init_regs
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_intr
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_intr_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_load_txmbuf
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_meminit
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_mifinit
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_mii_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_mii_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_mii_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_reset
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_reset_rx
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_reset_tx
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_resume
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|cas_descsize
parameter_list|(
name|u_int
name|sz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_rint
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_rint_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|cas_rxcksum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint16_t
name|cksum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|cas_rxcompinit
parameter_list|(
name|struct
name|cas_rx_comp
modifier|*
name|rxcomp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|cas_rxcompsize
parameter_list|(
name|u_int
name|sz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_rxdma_callback
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_setladrf
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_suspend
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_tint
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_tx_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|cas_txkick
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cas_watchdog
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|devclass_t
name|cas_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|cas
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|cas
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CAS_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_define
define|#
directive|define
name|KTR_CAS
value|KTR_CT2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|cas_attach
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cas_txsoft
modifier|*
name|txs
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
comment|/* Set up ifnet structure. */
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|cas_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|cas_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|cas_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|CAS_TXQUEUELEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|CAS_TXQUEUELEN
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Create local taskq. */
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_intr_task
argument_list|,
literal|0
argument_list|,
name|cas_intr_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_tx_task
argument_list|,
literal|1
argument_list|,
name|cas_tx_task
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"cas_taskq"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not create taskqueue\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail_ifnet
goto|;
block|}
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|sc_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure the chip is stopped. */
name|cas_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BUS_SPACE_MAXSIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXSIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_pdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail_taskq
goto|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|CAS_PAGE_SIZE
argument_list|,
literal|1
argument_list|,
name|CAS_PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_rdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail_ptag
goto|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
operator|*
name|CAS_NTXSEGS
argument_list|,
name|CAS_NTXSEGS
argument_list|,
name|MCLBYTES
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_tdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail_rtag
goto|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|,
name|CAS_TX_DESC_ALIGN
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cas_control_data
argument_list|)
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cas_control_data
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail_ttag
goto|;
comment|/* 	 * Allocate the control data structures, create and load the 	 * DMA map for it. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_control_data
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc
operator|->
name|sc_cddmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to allocate control data, error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_ctag
goto|;
block|}
name|sc
operator|->
name|sc_cddma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|,
name|sc
operator|->
name|sc_control_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cas_control_data
argument_list|)
argument_list|,
name|cas_cddma_callback
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|||
name|sc
operator|->
name|sc_cddma
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to load control data DMA map, error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_cmem
goto|;
block|}
comment|/* 	 * Initialize the transmit job descriptors. 	 */
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
expr_stmt|;
comment|/* 	 * Create the transmit buffer DMA maps. 	 */
name|error
operator|=
name|ENOMEM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAS_TXQUEUELEN
condition|;
name|i
operator|++
control|)
block|{
name|txs
operator|=
operator|&
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
name|NULL
expr_stmt|;
name|txs
operator|->
name|txs_ndescs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
literal|0
argument_list|,
operator|&
name|txs
operator|->
name|txs_dmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create TX DMA map %d, error = %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_txd
goto|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate the receive buffers, create and load the DMA maps 	 * for them. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAS_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_buf
argument_list|,
name|BUS_DMA_WAITOK
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_dmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to allocate RX buffer %d, error = %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_rxmem
goto|;
block|}
name|sc
operator|->
name|sc_rxdptr
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_paddr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_dmamap
argument_list|,
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_buf
argument_list|,
name|CAS_PAGE_SIZE
argument_list|,
name|cas_rxdma_callback
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|||
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_paddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to load RX DMA map %d, error = %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_rxmap
goto|;
block|}
block|}
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_PCS_DATAPATH
argument_list|,
name|CAS_PCS_DATAPATH_MII
argument_list|)
expr_stmt|;
name|cas_mifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Look for an external PHY. 	 */
name|error
operator|=
name|ENXIO
expr_stmt|;
name|v
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MIF_CONF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|CAS_MIF_CONF_MDI1
operator|)
operator|!=
literal|0
condition|)
block|{
name|v
operator||=
name|CAS_MIF_CONF_PHY_SELECT
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MIF_CONF
argument_list|,
name|v
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_variant
condition|)
block|{
default|default:
name|sc
operator|->
name|sc_phyad
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_miibus
argument_list|,
name|cas_mediachange
argument_list|,
name|cas_mediastatus
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fall back on an internal PHY if no external PHY was found. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
operator|(
name|v
operator|&
name|CAS_MIF_CONF_MDI0
operator|)
operator|!=
literal|0
condition|)
block|{
name|v
operator|&=
operator|~
name|CAS_MIF_CONF_PHY_SELECT
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MIF_CONF
argument_list|,
name|v
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_variant
condition|)
block|{
default|default:
name|sc
operator|->
name|sc_phyad
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_miibus
argument_list|,
name|cas_mediachange
argument_list|,
name|cas_mediastatus
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Try the external PCS SERDES if we didn't find any PHYs. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_PCS_DATAPATH
argument_list|,
name|CAS_PCS_DATAPATH_SERDES
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_PCS_SERDES_CTRL
argument_list|,
name|CAS_PCS_SERDES_CTRL_ESD
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_PCS_CONF_EN
argument_list|,
name|CAS_PCS_CONF_EN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|CAS_SERDES
expr_stmt|;
name|sc
operator|->
name|sc_phyad
operator|=
name|CAS_PHYAD_EXTERNAL
expr_stmt|;
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_miibus
argument_list|,
name|cas_mediachange
argument_list|,
name|cas_mediastatus
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"PHY probe failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_rxmap
goto|;
block|}
name|sc
operator|->
name|sc_mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
comment|/* 	 * From this point forward, the attachment cannot fail.  A failure 	 * before this point releases all resources that may have been 	 * allocated. 	 */
comment|/* Announce FIFO sizes. */
name|v
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_TX_FIFO_SIZE
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%ukB RX FIFO, %ukB TX FIFO\n"
argument_list|,
name|CAS_RX_FIFO_SIZE
operator|/
literal|1024
argument_list|,
name|v
operator|/
literal|16
argument_list|)
expr_stmt|;
comment|/* Attach the interface. */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames/checksum offloads. 	 */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_VLAN_MTU
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_NO_CSUM
operator|)
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|CAS_CSUM_FEATURES
expr_stmt|;
block|}
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Free any resources we've allocated during the failed attach 	 * attempt.  Do this in reverse order and fall through. 	 */
name|fail_rxmap
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAS_NRXDESC
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_paddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_dmamap
argument_list|)
expr_stmt|;
name|fail_rxmem
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAS_NRXDESC
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_buf
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_buf
argument_list|,
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_dmamap
argument_list|)
expr_stmt|;
name|fail_txd
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAS_TXQUEUELEN
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
operator|.
name|txs_dmamap
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
operator|.
name|txs_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|)
expr_stmt|;
name|fail_cmem
label|:
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_control_data
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|)
expr_stmt|;
name|fail_ctag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|)
expr_stmt|;
name|fail_ttag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|)
expr_stmt|;
name|fail_rtag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|)
expr_stmt|;
name|fail_ptag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|)
expr_stmt|;
name|fail_taskq
label|:
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|fail_ifnet
label|:
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_detach
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|CAS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cas_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_intr_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx_task
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAS_NRXDESC
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_dmamap
operator|!=
name|NULL
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAS_NRXDESC
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_paddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_dmamap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAS_NRXDESC
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_buf
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_buf
argument_list|,
name|sc
operator|->
name|sc_rxdsoft
index|[
name|i
index|]
operator|.
name|rxds_dmamap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAS_TXQUEUELEN
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
operator|.
name|txs_dmamap
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|sc
operator|->
name|sc_txsoft
index|[
name|i
index|]
operator|.
name|txs_dmamap
argument_list|)
expr_stmt|;
name|CAS_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_control_data
argument_list|,
name|sc
operator|->
name|sc_cddmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_suspend
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|CAS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cas_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_resume
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|CAS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * On resume all registers have to be initialized again like 	 * after power-on. 	 */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CAS_INITED
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|cas_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|cas_rxcksum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint16_t
name|cksum
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
decl_stmt|;
name|uint16_t
modifier|*
name|opts
decl_stmt|;
name|int32_t
name|hlen
decl_stmt|,
name|len
decl_stmt|,
name|pktlen
decl_stmt|;
name|uint32_t
name|temp32
decl_stmt|;
name|pktlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
return|return;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
return|return;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|!=
name|IPVERSION
condition|)
return|return;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|pktlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|<
name|hlen
condition|)
return|return;
if|if
condition|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|!=
name|pktlen
condition|)
return|return;
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
operator||
name|IP_OFFMASK
argument_list|)
condition|)
return|return;
comment|/* Cannot handle fragmented packet. */
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|pktlen
operator|<
operator|(
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|)
condition|)
return|return;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|pktlen
operator|<
operator|(
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|)
condition|)
return|return;
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|ip
operator|+
name|hlen
operator|)
expr_stmt|;
if|if
condition|(
name|uh
operator|->
name|uh_sum
operator|==
literal|0
condition|)
return|return;
comment|/* no checksum */
break|break;
default|default:
return|return;
block|}
name|cksum
operator|=
operator|~
name|cksum
expr_stmt|;
comment|/* checksum fixup for IP options */
name|len
operator|=
name|hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|opts
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|,
name|opts
operator|++
control|)
block|{
name|temp32
operator|=
name|cksum
operator|-
operator|*
name|opts
expr_stmt|;
name|temp32
operator|=
operator|(
name|temp32
operator|>>
literal|16
operator|)
operator|+
operator|(
name|temp32
operator|&
literal|65535
operator|)
expr_stmt|;
name|cksum
operator|=
name|temp32
operator|&
literal|65535
expr_stmt|;
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|cksum
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_cddma_callback
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|nsegs
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: bad control buffer segment count"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cddma
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_rxdma_callback
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|nsegs
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: bad RX buffer segment count"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxdsoft
index|[
name|sc
operator|->
name|sc_rxdptr
index|]
operator|.
name|rxds_paddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|CAS_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Unload collision and error counters. 	 */
name|ifp
operator|->
name|if_collisions
operator|+=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_NORM_COLL_CNT
argument_list|)
operator|+
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_FIRST_COLL_CNT
argument_list|)
expr_stmt|;
name|v
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_EXCESS_COLL_CNT
argument_list|)
operator|+
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_LATE_COLL_CNT
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
name|v
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|+=
name|v
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|+=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_LEN_ERR_CNT
argument_list|)
operator|+
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_ALIGN_ERR
argument_list|)
operator|+
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CRC_ERR_CNT
argument_list|)
operator|+
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CODE_VIOL
argument_list|)
expr_stmt|;
comment|/* 	 * Then clear the hardware counters. 	 */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_NORM_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_FIRST_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_EXCESS_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_LATE_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_LEN_ERR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_ALIGN_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CRC_ERR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CODE_VIOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_txfree
operator|!=
name|CAS_MAXTXFREE
condition|)
name|cas_tint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cas_watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
name|hz
argument_list|,
name|cas_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cas_bitwait
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|r
parameter_list|,
name|uint32_t
name|clr
parameter_list|,
name|uint32_t
name|set
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
for|for
control|(
name|i
operator|=
name|CAS_TRIES
init|;
name|i
operator|--
condition|;
name|DELAY
argument_list|(
literal|100
argument_list|)
control|)
block|{
name|reg
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|clr
operator|)
operator|==
literal|0
operator|&&
operator|(
name|reg
operator|&
name|set
operator|)
operator|==
name|set
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_reset
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR2
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: %s"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Disable all interrupts in order to avoid spurious ones. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_INTMASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|cas_reset_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cas_reset_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Do a full reset modulo the result of the last auto-negotiation 	 * when using the SERDES. 	 */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RESET
argument_list|,
name|CAS_RESET_RX
operator||
name|CAS_RESET_TX
operator||
operator|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_SERDES
operator|)
operator|!=
literal|0
condition|?
name|CAS_RESET_PCS_DIS
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_RESET
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cas_bitwait
argument_list|(
name|sc
argument_list|,
name|CAS_RESET
argument_list|,
name|CAS_RESET_RX
operator||
name|CAS_RESET_TX
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot reset device\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|cas_txsoft
modifier|*
name|txs
decl_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR2
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: %s"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|)
expr_stmt|;
comment|/* Disable all interrupts in order to avoid spurious ones. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_INTMASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|cas_reset_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cas_reset_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Release any queued transmit buffers. 	 */
while|while
condition|(
operator|(
name|txs
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|txs
operator|->
name|txs_ndescs
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|txs
operator|->
name|txs_mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txs
operator|->
name|txs_mbuf
argument_list|)
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Mark the interface down and cancel the watchdog timer. 	 */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CAS_LINK
expr_stmt|;
name|sc
operator|->
name|sc_wdog_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cas_reset_rx
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Resetting while DMA is in progress can cause a bus hang, so we 	 * disable DMA first. 	 */
name|cas_disable_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_CONF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_RX_CONF
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cas_bitwait
argument_list|(
name|sc
argument_list|,
name|CAS_RX_CONF
argument_list|,
name|CAS_RX_CONF_RXDMA_EN
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot disable RX DMA\n"
argument_list|)
expr_stmt|;
comment|/* Finally, reset the ERX. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RESET
argument_list|,
name|CAS_RESET_RX
operator||
operator|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_SERDES
operator|)
operator|!=
literal|0
condition|?
name|CAS_RESET_PCS_DIS
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_RESET
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cas_bitwait
argument_list|(
name|sc
argument_list|,
name|CAS_RESET
argument_list|,
name|CAS_RESET_RX
operator||
name|CAS_RESET_TX
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot reset receiver\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cas_reset_tx
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Resetting while DMA is in progress can cause a bus hang, so we 	 * disable DMA first. 	 */
name|cas_disable_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_TX_CONF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_TX_CONF
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cas_bitwait
argument_list|(
name|sc
argument_list|,
name|CAS_TX_CONF
argument_list|,
name|CAS_TX_CONF_TXDMA_EN
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot disable TX DMA\n"
argument_list|)
expr_stmt|;
comment|/* Finally, reset the ETX. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RESET
argument_list|,
name|CAS_RESET_TX
operator||
operator|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_SERDES
operator|)
operator|!=
literal|0
condition|?
name|CAS_RESET_PCS_DIS
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_RESET
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cas_bitwait
argument_list|(
name|sc
argument_list|,
name|CAS_RESET
argument_list|,
name|CAS_RESET_RX
operator||
name|CAS_RESET_TX
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot reset transmitter\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cas_disable_rx
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|)
operator|&
operator|~
name|CAS_MAC_RX_CONF_EN
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
return|return
operator|(
name|cas_bitwait
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
name|CAS_MAC_RX_CONF_EN
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cas_disable_tx
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONF
argument_list|,
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONF
argument_list|)
operator|&
operator|~
name|CAS_MAC_TX_CONF_EN
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONF
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
return|return
operator|(
name|cas_bitwait
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONF
argument_list|,
name|CAS_MAC_TX_CONF_EN
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|cas_rxcompinit
parameter_list|(
name|struct
name|cas_rx_comp
modifier|*
name|rxcomp
parameter_list|)
block|{
name|rxcomp
operator|->
name|crc_word1
operator|=
literal|0
expr_stmt|;
name|rxcomp
operator|->
name|crc_word2
operator|=
literal|0
expr_stmt|;
name|rxcomp
operator|->
name|crc_word3
operator|=
name|htole64
argument_list|(
name|CAS_SET
argument_list|(
name|ETHER_HDR_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|,
name|CAS_RC3_CSO
argument_list|)
argument_list|)
expr_stmt|;
name|rxcomp
operator|->
name|crc_word4
operator|=
name|htole64
argument_list|(
name|CAS_RC4_ZERO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_meminit
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CAS_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the transmit descriptor ring. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAS_NTXDESC
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|cd_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|cd_buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|sc_txfree
operator|=
name|CAS_MAXTXFREE
expr_stmt|;
name|sc
operator|->
name|sc_txnext
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_txwin
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize the receive completion ring. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAS_NRXCOMP
condition|;
name|i
operator|++
control|)
name|cas_rxcompinit
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxcomps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxcptr
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize the first receive descriptor ring.  We leave 	 * the second one zeroed as we don't actually use it. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAS_NRXDESC
condition|;
name|i
operator|++
control|)
name|CAS_INIT_RXDESC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxdptr
operator|=
literal|0
expr_stmt|;
name|CAS_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|cas_descsize
parameter_list|(
name|u_int
name|sz
parameter_list|)
block|{
switch|switch
condition|(
name|sz
condition|)
block|{
case|case
literal|32
case|:
return|return
operator|(
name|CAS_DESC_32
operator|)
return|;
case|case
literal|64
case|:
return|return
operator|(
name|CAS_DESC_64
operator|)
return|;
case|case
literal|128
case|:
return|return
operator|(
name|CAS_DESC_128
operator|)
return|;
case|case
literal|256
case|:
return|return
operator|(
name|CAS_DESC_256
operator|)
return|;
case|case
literal|512
case|:
return|return
operator|(
name|CAS_DESC_512
operator|)
return|;
case|case
literal|1024
case|:
return|return
operator|(
name|CAS_DESC_1K
operator|)
return|;
case|case
literal|2048
case|:
return|return
operator|(
name|CAS_DESC_2K
operator|)
return|;
case|case
literal|4096
case|:
return|return
operator|(
name|CAS_DESC_4K
operator|)
return|;
case|case
literal|8192
case|:
return|return
operator|(
name|CAS_DESC_8K
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"%s: invalid descriptor ring size %d\n"
argument_list|,
name|__func__
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAS_DESC_32
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int
name|cas_rxcompsize
parameter_list|(
name|u_int
name|sz
parameter_list|)
block|{
switch|switch
condition|(
name|sz
condition|)
block|{
case|case
literal|128
case|:
return|return
operator|(
name|CAS_RX_CONF_COMP_128
operator|)
return|;
case|case
literal|256
case|:
return|return
operator|(
name|CAS_RX_CONF_COMP_256
operator|)
return|;
case|case
literal|512
case|:
return|return
operator|(
name|CAS_RX_CONF_COMP_512
operator|)
return|;
case|case
literal|1024
case|:
return|return
operator|(
name|CAS_RX_CONF_COMP_1K
operator|)
return|;
case|case
literal|2048
case|:
return|return
operator|(
name|CAS_RX_CONF_COMP_2K
operator|)
return|;
case|case
literal|4096
case|:
return|return
operator|(
name|CAS_RX_CONF_COMP_4K
operator|)
return|;
case|case
literal|8192
case|:
return|return
operator|(
name|CAS_RX_CONF_COMP_8K
operator|)
return|;
case|case
literal|16384
case|:
return|return
operator|(
name|CAS_RX_CONF_COMP_16K
operator|)
return|;
case|case
literal|32768
case|:
return|return
operator|(
name|CAS_RX_CONF_COMP_32K
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"%s: invalid dcompletion ring size %d\n"
argument_list|,
name|__func__
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAS_RX_CONF_COMP_128
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cas_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|CAS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cas_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialization of interface; set up initialization block  * and transmit/receive descriptor rings.  */
end_comment

begin_function
specifier|static
name|void
name|cas_init_locked
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|CAS_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR2
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: %s: calling stop"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialization sequence.  The numbered steps below correspond 	 * to the sequence outlined in section 6.3.5.1 in the Ethernet 	 * Channel Engine manual (part of the PCIO manual). 	 * See also the STP2002-STQ document from Sun Microsystems. 	 */
comment|/* step 1& 2.  Reset the Ethernet Channel. */
name|cas_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|cas_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR2
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: %s: restarting"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Re-initialize the MIF. */
name|cas_mifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* step 3.  Setup data structures in host memory. */
name|cas_meminit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* step 4.  TX MAC registers& counters */
name|cas_init_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* step 5.  RX MAC registers& counters */
name|cas_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* step 6& 7.  Program Ring Base Addresses. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_TX_DESC3_BASE_HI
argument_list|,
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|CAS_CDTXDADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_TX_DESC3_BASE_LO
argument_list|,
name|CAS_CDTXDADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_COMP_BASE_HI
argument_list|,
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|CAS_CDRXCADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_COMP_BASE_LO
argument_list|,
name|CAS_CDRXCADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_DESC_BASE_HI
argument_list|,
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|CAS_CDRXDADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_DESC_BASE_LO
argument_list|,
name|CAS_CDRXDADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_REG_PLUS
operator|)
operator|!=
literal|0
condition|)
block|{
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_DESC2_BASE_HI
argument_list|,
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|CAS_CDRXD2ADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|>>
literal|32
operator|)
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_DESC2_BASE_LO
argument_list|,
name|CAS_CDRXD2ADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR5
argument_list|(
name|KTR_CAS
argument_list|,
literal|"loading TXDR %lx, RXCR %lx, RXDR %lx, RXD2R %lx, cddma %lx"
argument_list|,
name|CAS_CDTXDADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|CAS_CDRXCADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|CAS_CDRXDADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|CAS_CDRXD2ADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_cddma
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* step 8.  Global Configuration& Interrupt Masks */
comment|/* Disable weighted round robin. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_CAW
argument_list|,
name|CAS_CAW_RR_DIS
argument_list|)
expr_stmt|;
comment|/* 	 * Enable infinite bursts for revisions without PCI issues if 	 * applicable.  Doing so greatly improves the TX performance on 	 * !__sparc64__. 	 */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_INF_BURST
argument_list|,
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__sparc64__
argument_list|)
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_TABORT
operator|)
operator|==
literal|0
condition|?
name|CAS_INF_BURST_EN
else|:
endif|#
directive|endif
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up interrupts. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_INTMASK
argument_list|,
operator|~
operator|(
name|CAS_INTR_TX_INT_ME
operator||
name|CAS_INTR_TX_TAG_ERR
operator||
name|CAS_INTR_RX_DONE
operator||
name|CAS_INTR_RX_BUF_NA
operator||
name|CAS_INTR_RX_TAG_ERR
operator||
name|CAS_INTR_RX_COMP_FULL
operator||
name|CAS_INTR_RX_BUF_AEMPTY
operator||
name|CAS_INTR_RX_COMP_AFULL
operator||
name|CAS_INTR_RX_LEN_MMATCH
operator||
name|CAS_INTR_PCI_ERROR_INT
ifdef|#
directive|ifdef
name|CAS_DEBUG
operator||
name|CAS_INTR_PCS_INT
operator||
name|CAS_INTR_MIF
endif|#
directive|endif
operator|)
argument_list|)
expr_stmt|;
comment|/* Don't clear top level interrupts when CAS_STATUS_ALIAS is read. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_CLEAR_ALIAS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_MASK
argument_list|,
operator|~
name|CAS_MAC_RX_OVERFLOW
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_MASK
argument_list|,
operator|~
operator|(
name|CAS_MAC_TX_UNDERRUN
operator||
name|CAS_MAC_TX_MAX_PKT_ERR
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_CTRL_MASK
argument_list|,
operator|~
operator|(
name|CAS_MAC_CTRL_PAUSE_RCVD
operator||
name|CAS_MAC_CTRL_PAUSE
operator||
name|CAS_MAC_CTRL_NON_PAUSE
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_CTRL_MASK
argument_list|,
name|CAS_MAC_CTRL_PAUSE_RCVD
operator||
name|CAS_MAC_CTRL_PAUSE
operator||
name|CAS_MAC_CTRL_NON_PAUSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Enable PCI error interrupts. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_ERROR_MASK
argument_list|,
operator|~
operator|(
name|CAS_ERROR_DTRTO
operator||
name|CAS_ERROR_OTHER
operator||
name|CAS_ERROR_DMAW_ZERO
operator||
name|CAS_ERROR_DMAR_ZERO
operator||
name|CAS_ERROR_RTRTO
operator|)
argument_list|)
expr_stmt|;
comment|/* Enable PCI error interrupts in BIM configuration. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_BIM_CONF
argument_list|,
name|CAS_BIM_CONF_DPAR_EN
operator||
name|CAS_BIM_CONF_RMA_EN
operator||
name|CAS_BIM_CONF_RTA_EN
argument_list|)
expr_stmt|;
comment|/* 	 * step 9.  ETX Configuration: encode receive descriptor ring size, 	 * enable DMA and disable pre-interrupt writeback completion. 	 */
name|v
operator|=
name|cas_descsize
argument_list|(
name|CAS_NTXDESC
argument_list|)
operator|<<
name|CAS_TX_CONF_DESC3_SHFT
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_TX_CONF
argument_list|,
name|v
operator||
name|CAS_TX_CONF_TXDMA_EN
operator||
name|CAS_TX_CONF_RDPP_DIS
operator||
name|CAS_TX_CONF_PICWB_DIS
argument_list|)
expr_stmt|;
comment|/* step 10.  ERX Configuration */
comment|/* 	 * Encode receive completion and descriptor ring sizes, set the 	 * swivel offset. 	 */
name|v
operator|=
name|cas_rxcompsize
argument_list|(
name|CAS_NRXCOMP
argument_list|)
operator|<<
name|CAS_RX_CONF_COMP_SHFT
expr_stmt|;
name|v
operator||=
name|cas_descsize
argument_list|(
name|CAS_NRXDESC
argument_list|)
operator|<<
name|CAS_RX_CONF_DESC_SHFT
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_REG_PLUS
operator|)
operator|!=
literal|0
condition|)
name|v
operator||=
name|cas_descsize
argument_list|(
name|CAS_NRXDESC2
argument_list|)
operator|<<
name|CAS_RX_CONF_DESC2_SHFT
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_CONF
argument_list|,
name|v
operator||
operator|(
name|ETHER_ALIGN
operator|<<
name|CAS_RX_CONF_SOFF_SHFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Set the PAUSE thresholds.  We use the maximum OFF threshold. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_PTHRS
argument_list|,
operator|(
operator|(
literal|111
operator|*
literal|64
operator|)
operator|<<
name|CAS_RX_PTHRS_XOFF_SHFT
operator|)
operator||
operator|(
operator|(
literal|15
operator|*
literal|64
operator|)
operator|<<
name|CAS_RX_PTHRS_XON_SHFT
operator|)
argument_list|)
expr_stmt|;
comment|/* RX blanking */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_BLANK
argument_list|,
operator|(
literal|15
operator|<<
name|CAS_RX_BLANK_TIME_SHFT
operator|)
operator||
operator|(
literal|5
operator|<<
name|CAS_RX_BLANK_PKTS_SHFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Set RX_COMP_AFULL threshold to half of the RX completions. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_AEMPTY_THRS
argument_list|,
operator|(
name|CAS_NRXCOMP
operator|/
literal|2
operator|)
operator|<<
name|CAS_RX_AEMPTY_COMP_SHFT
argument_list|)
expr_stmt|;
comment|/* Initialize the RX page size register as appropriate for 8k. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_PSZ
argument_list|,
operator|(
name|CAS_RX_PSZ_8K
operator|<<
name|CAS_RX_PSZ_SHFT
operator|)
operator||
operator|(
literal|4
operator|<<
name|CAS_RX_PSZ_MB_CNT_SHFT
operator|)
operator||
operator|(
name|CAS_RX_PSZ_MB_STRD_2K
operator|<<
name|CAS_RX_PSZ_MB_STRD_SHFT
operator|)
operator||
operator|(
name|CAS_RX_PSZ_MB_OFF_64
operator|<<
name|CAS_RX_PSZ_MB_OFF_SHFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Disable RX random early detection. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_RED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Zero the RX reassembly DMA table. */
for|for
control|(
name|v
operator|=
literal|0
init|;
name|v
operator|<=
name|CAS_RX_REAS_DMA_ADDR_LC
condition|;
name|v
operator|++
control|)
block|{
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_REAS_DMA_ADDR
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_REAS_DMA_DATA_LO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_REAS_DMA_DATA_MD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_REAS_DMA_DATA_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure the RX control FIFO and RX IPP FIFO addresses are zero. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_CTRL_FIFO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_IPP_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Finally, enable RX DMA. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_CONF
argument_list|,
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_CONF
argument_list|)
operator||
name|CAS_RX_CONF_RXDMA_EN
argument_list|)
expr_stmt|;
comment|/* step 11.  Configure Media. */
comment|/* step 12.  RX_MAC Configuration Register */
name|v
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|)
operator|&
operator|~
name|CAS_MAC_RX_CONF_STRPPAD
expr_stmt|;
name|v
operator||=
name|CAS_MAC_RX_CONF_EN
operator||
name|CAS_MAC_RX_CONF_STRPFCS
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cas_bitwait
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
name|CAS_MAC_RX_CONF_EN
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot configure RX MAC\n"
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* step 13.  TX_MAC Configuration Register */
name|v
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONF
argument_list|)
expr_stmt|;
name|v
operator||=
name|CAS_MAC_TX_CONF_EN
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONF
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cas_bitwait
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONF
argument_list|,
name|CAS_MAC_TX_CONF_EN
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot configure TX MAC\n"
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONF
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* step 14.  Issue Transmit Pending command. */
comment|/* step 15.  Give the reciever a swift kick. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_KICK
argument_list|,
name|CAS_NRXDESC
operator|-
literal|4
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_COMP_TAIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_REG_PLUS
operator|)
operator|!=
literal|0
condition|)
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_KICK2
argument_list|,
name|CAS_NRXDESC2
operator|-
literal|4
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|mii_mediachg
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
comment|/* Start the one second timer. */
name|sc
operator|->
name|sc_wdog_timer
operator|=
literal|0
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
name|hz
argument_list|,
name|cas_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cas_load_txmbuf
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|)
block|{
name|bus_dma_segment_t
name|txsegs
index|[
name|CAS_NTXSEGS
index|]
decl_stmt|;
name|struct
name|cas_txsoft
modifier|*
name|txs
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint64_t
name|cflags
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nexttx
decl_stmt|,
name|nsegs
decl_stmt|,
name|offset
decl_stmt|,
name|seg
decl_stmt|;
name|CAS_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Get a work queue entry. */
if|if
condition|(
operator|(
name|txs
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Ran out of descriptors. */
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|cflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|m_head
operator|)
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CAS_CSUM_FEATURES
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|M_WRITABLE
argument_list|(
operator|*
name|m_head
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|m_dup
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_pullup
argument_list|(
operator|*
name|m_head
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|offset
operator|)
expr_stmt|;
name|offset
operator|+=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|cflags
operator|=
operator|(
name|offset
operator|<<
name|CAS_TD_CKSUM_START_SHFT
operator|)
operator||
operator|(
operator|(
name|offset
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|)
operator|<<
name|CAS_TD_CKSUM_STUFF_SHFT
operator|)
operator||
name|CAS_TD_CKSUM_EN
expr_stmt|;
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
block|}
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
operator|*
name|m_head
argument_list|,
name|txsegs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|m
operator|=
name|m_collapse
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|,
name|CAS_NTXSEGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
operator|*
name|m_head
argument_list|,
name|txsegs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* If nsegs is wrong then the stack is corrupt. */
name|KASSERT
argument_list|(
name|nsegs
operator|<=
name|CAS_NTXSEGS
argument_list|,
operator|(
literal|"%s: too many DMA segments (%d)"
operator|,
name|__func__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsegs
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Ensure we have enough descriptors free to describe 	 * the packet.  Note, we always reserve one descriptor 	 * at the end of the ring as a termination point, in 	 * order to prevent wrap-around. 	 */
if|if
condition|(
name|nsegs
operator|>
name|sc
operator|->
name|sc_txfree
operator|-
literal|1
condition|)
block|{
name|txs
operator|->
name|txs_ndescs
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|txs
operator|->
name|txs_ndescs
operator|=
name|nsegs
expr_stmt|;
name|txs
operator|->
name|txs_firstdesc
operator|=
name|sc
operator|->
name|sc_txnext
expr_stmt|;
name|nexttx
operator|=
name|txs
operator|->
name|txs_firstdesc
expr_stmt|;
for|for
control|(
name|seg
operator|=
literal|0
init|;
name|seg
operator|<
name|nsegs
condition|;
name|seg
operator|++
operator|,
name|nexttx
operator|=
name|CAS_NEXTTX
argument_list|(
name|nexttx
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR6
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: mapping seg %d (txd %d), len %lx, addr %#lx (%#lx)"
argument_list|,
name|__func__
argument_list|,
name|seg
argument_list|,
name|nexttx
argument_list|,
name|txsegs
index|[
name|seg
index|]
operator|.
name|ds_len
argument_list|,
name|txsegs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|,
name|htole64
argument_list|(
name|txsegs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_txdescs
index|[
name|nexttx
index|]
operator|.
name|cd_buf_ptr
operator|=
name|htole64
argument_list|(
name|txsegs
index|[
name|seg
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txsegs
index|[
name|seg
index|]
operator|.
name|ds_len
operator|<
name|CAS_TD_BUF_LEN_MASK
operator|>>
name|CAS_TD_BUF_LEN_SHFT
argument_list|,
operator|(
literal|"%s: segment size too large!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txdescs
index|[
name|nexttx
index|]
operator|.
name|cd_flags
operator|=
name|htole64
argument_list|(
name|txsegs
index|[
name|seg
index|]
operator|.
name|ds_len
operator|<<
name|CAS_TD_BUF_LEN_SHFT
argument_list|)
expr_stmt|;
name|txs
operator|->
name|txs_lastdesc
operator|=
name|nexttx
expr_stmt|;
block|}
comment|/* Set EOF on the last descriptor. */
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR3
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: end of frame at segment %d, TX %d"
argument_list|,
name|__func__
argument_list|,
name|seg
argument_list|,
name|nexttx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_txdescs
index|[
name|txs
operator|->
name|txs_lastdesc
index|]
operator|.
name|cd_flags
operator||=
name|htole64
argument_list|(
name|CAS_TD_END_OF_FRAME
argument_list|)
expr_stmt|;
comment|/* Lastly set SOF on the first descriptor. */
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR3
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: start of frame at segment %d, TX %d"
argument_list|,
name|__func__
argument_list|,
name|seg
argument_list|,
name|nexttx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_txwin
operator|+=
name|nsegs
operator|>
name|CAS_MAXTXFREE
operator|*
literal|2
operator|/
literal|3
condition|)
block|{
name|sc
operator|->
name|sc_txwin
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_txdescs
index|[
name|txs
operator|->
name|txs_firstdesc
index|]
operator|.
name|cd_flags
operator||=
name|htole64
argument_list|(
name|cflags
operator||
name|CAS_TD_START_OF_FRAME
operator||
name|CAS_TD_INT_ME
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_txdescs
index|[
name|txs
operator|->
name|txs_firstdesc
index|]
operator|.
name|cd_flags
operator||=
name|htole64
argument_list|(
name|cflags
operator||
name|CAS_TD_START_OF_FRAME
argument_list|)
expr_stmt|;
comment|/* Sync the DMA map. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR4
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: setting firstdesc=%d, lastdesc=%d, ndescs=%d"
argument_list|,
name|__func__
argument_list|,
name|txs
operator|->
name|txs_firstdesc
argument_list|,
name|txs
operator|->
name|txs_lastdesc
argument_list|,
name|txs
operator|->
name|txs_ndescs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
operator|*
name|m_head
expr_stmt|;
name|sc
operator|->
name|sc_txnext
operator|=
name|CAS_NEXTTX
argument_list|(
name|txs
operator|->
name|txs_lastdesc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txfree
operator|-=
name|txs
operator|->
name|txs_ndescs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_init_regs
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|laddr
init|=
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
decl_stmt|;
name|CAS_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* These registers are not cleared on reset. */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_INITED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* magic values */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_IPG0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_IPG1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_IPG2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* min frame length */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_MIN_FRAME
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
comment|/* max frame length and max burst size */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_MAX_BF
argument_list|,
operator|(
operator|(
name|ETHER_MAX_LEN_JUMBO
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|)
operator|<<
name|CAS_MAC_MAX_BF_FRM_SHFT
operator|)
operator||
operator|(
literal|0x2000
operator|<<
name|CAS_MAC_MAX_BF_BST_SHFT
operator|)
argument_list|)
expr_stmt|;
comment|/* more magic values */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_PREAMBLE_LEN
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_JAM_SIZE
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_ATTEMPT_LIMIT
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_CTRL_TYPE
argument_list|,
literal|0x8088
argument_list|)
expr_stmt|;
comment|/* random number seed */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RANDOM_SEED
argument_list|,
operator|(
operator|(
name|laddr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|laddr
index|[
literal|4
index|]
operator|)
operator|&
literal|0x3ff
argument_list|)
expr_stmt|;
comment|/* secondary MAC addresses: 0:0:0:0:0:0 */
for|for
control|(
name|i
operator|=
name|CAS_MAC_ADDR3
init|;
name|i
operator|<=
name|CAS_MAC_ADDR41
condition|;
name|i
operator|+=
name|CAS_MAC_ADDR4
operator|-
name|CAS_MAC_ADDR3
control|)
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* MAC control address: 01:80:c2:00:00:01 */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_ADDR42
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_ADDR43
argument_list|,
literal|0xc200
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_ADDR44
argument_list|,
literal|0x0180
argument_list|)
expr_stmt|;
comment|/* MAC filter address: 0:0:0:0:0:0 */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_AFILTER0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_AFILTER1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_AFILTER2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_AFILTER_MASK1_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_AFILTER_MASK0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Zero the hash table. */
for|for
control|(
name|i
operator|=
name|CAS_MAC_HASH0
init|;
name|i
operator|<=
name|CAS_MAC_HASH15
condition|;
name|i
operator|+=
name|CAS_MAC_HASH1
operator|-
name|CAS_MAC_HASH0
control|)
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|CAS_INITED
expr_stmt|;
block|}
comment|/* Counters need to be zeroed. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_NORM_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_FIRST_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_EXCESS_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_LATE_COLL_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_DEFER_TMR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_PEAK_ATTEMPTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_FRAME_COUNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_LEN_ERR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_ALIGN_ERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CRC_ERR_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CODE_VIOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set XOFF PAUSE time. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_SPC
argument_list|,
literal|0x1BF0
operator|<<
name|CAS_MAC_SPC_TIME_SHFT
argument_list|)
expr_stmt|;
comment|/* Set the station address. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_ADDR0
argument_list|,
operator|(
name|laddr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|laddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_ADDR1
argument_list|,
operator|(
name|laddr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|laddr
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_ADDR2
argument_list|,
operator|(
name|laddr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|laddr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Enable MII outputs. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_XIF_CONF
argument_list|,
name|CAS_MAC_XIF_CONF_TX_OE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_tx_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|arg
expr_stmt|;
name|cas_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|cas_txkick
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Update the TX kick register.  This register has to point to the 	 * descriptor after the last valid one and for optimum performance 	 * should be incremented in multiples of 4 (the DMA engine fetches/ 	 * updates descriptors in batches of 4). 	 */
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR3
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: %s: kicking TX %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_txnext
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CAS_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_TX_KICK3
argument_list|,
name|sc
operator|->
name|sc_txnext
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|kicked
decl_stmt|,
name|ntx
decl_stmt|;
name|CAS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_LINK
operator|)
operator|==
literal|0
condition|)
block|{
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_txfree
operator|<
name|CAS_MAXTXFREE
operator|/
literal|4
condition|)
name|cas_tint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR4
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: %s: txfree %d, txnext %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_txfree
argument_list|,
name|sc
operator|->
name|sc_txnext
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ntx
operator|=
literal|0
expr_stmt|;
name|kicked
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
operator|&&
name|sc
operator|->
name|sc_txfree
operator|>
literal|1
condition|;
control|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|cas_load_txmbuf
argument_list|(
name|sc
argument_list|,
operator|&
name|m
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_txnext
operator|%
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
name|cas_txkick
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|kicked
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|kicked
operator|=
literal|0
expr_stmt|;
name|ntx
operator|++
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntx
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|kicked
operator|==
literal|0
condition|)
name|cas_txkick
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR2
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: packets enqueued, OWN on %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_txnext
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set a watchdog timer in case the chip flakes out. */
name|sc
operator|->
name|sc_wdog_timer
operator|=
literal|5
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR3
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: %s: watchdog %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_wdog_timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_tint
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|cas_txsoft
modifier|*
name|txs
decl_stmt|;
name|int
name|progress
decl_stmt|;
name|uint32_t
name|txlast
decl_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|int
name|i
decl_stmt|;
name|CAS_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: %s"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Go through our TX list and free mbufs for those 	 * frames that have been transmitted. 	 */
name|progress
operator|=
literal|0
expr_stmt|;
name|CAS_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|txs
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|CAS_DEBUG
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"    txsoft %p transmit chain:\n"
argument_list|,
name|txs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|txs
operator|->
name|txs_firstdesc
init|;
condition|;
name|i
operator|=
name|CAS_NEXTTX
argument_list|(
name|i
argument_list|)
control|)
block|{
name|printf
argument_list|(
literal|"descriptor %d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cd_flags: 0x%016llx\t"
argument_list|,
operator|(
name|long
name|long
operator|)
name|le64toh
argument_list|(
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|cd_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cd_buf_ptr: 0x%016llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|le64toh
argument_list|(
name|sc
operator|->
name|sc_txdescs
index|[
name|i
index|]
operator|.
name|cd_buf_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|txs
operator|->
name|txs_lastdesc
condition|)
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * In theory, we could harvest some descriptors before 		 * the ring is empty, but that's a bit complicated. 		 * 		 * CAS_TX_COMPn points to the last descriptor 		 * processed + 1. 		 */
name|txlast
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_TX_COMP3
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR4
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: txs->txs_firstdesc = %d, "
literal|"txs->txs_lastdesc = %d, txlast = %d"
argument_list|,
name|__func__
argument_list|,
name|txs
operator|->
name|txs_firstdesc
argument_list|,
name|txs
operator|->
name|txs_lastdesc
argument_list|,
name|txlast
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|txs
operator|->
name|txs_firstdesc
operator|<=
name|txs
operator|->
name|txs_lastdesc
condition|)
block|{
if|if
condition|(
operator|(
name|txlast
operator|>=
name|txs
operator|->
name|txs_firstdesc
operator|)
operator|&&
operator|(
name|txlast
operator|<=
name|txs
operator|->
name|txs_lastdesc
operator|)
condition|)
break|break;
block|}
else|else
block|{
comment|/* Ick -- this command wraps. */
if|if
condition|(
operator|(
name|txlast
operator|>=
name|txs
operator|->
name|txs_firstdesc
operator|)
operator|||
operator|(
name|txlast
operator|<=
name|txs
operator|->
name|txs_lastdesc
operator|)
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR1
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: releasing a descriptor"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txfree
operator|+=
name|txs
operator|->
name|txs_ndescs
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|txs
operator|->
name|txs_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|txs
operator|->
name|txs_mbuf
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txs
operator|->
name|txs_mbuf
argument_list|)
expr_stmt|;
name|txs
operator|->
name|txs_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txfreeq
argument_list|,
name|txs
argument_list|,
name|txs_q
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|progress
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR4
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: CAS_TX_STATE_MACHINE %x CAS_TX_DESC_BASE %llx "
literal|"CAS_TX_COMP3 %x"
argument_list|,
name|__func__
argument_list|,
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_TX_STATE_MACHINE
argument_list|)
argument_list|,
operator|(
operator|(
name|long
name|long
operator|)
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_TX_DESC_BASE_HI3
argument_list|)
operator|<<
literal|32
operator|)
operator||
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_TX_DESC_BASE_LO3
argument_list|)
argument_list|,
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_TX_COMP3
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|progress
condition|)
block|{
comment|/* We freed some descriptors, so reset IFF_DRV_OACTIVE. */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_txdirtyq
argument_list|)
condition|)
name|sc
operator|->
name|sc_wdog_timer
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR3
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: %s: watchdog %d"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_wdog_timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|cas_rint_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|CAS_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|cas_rint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_rint
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cas_rxdsoft
modifier|*
name|rxds
decl_stmt|,
modifier|*
name|rxds2
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m2
decl_stmt|;
name|uint64_t
name|word1
decl_stmt|,
name|word2
decl_stmt|,
name|word3
decl_stmt|,
name|word4
decl_stmt|;
name|uint32_t
name|rxhead
decl_stmt|;
name|u_int
name|idx
decl_stmt|,
name|idx2
decl_stmt|,
name|len
decl_stmt|,
name|off
decl_stmt|,
name|skip
decl_stmt|;
name|CAS_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR2
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: %s"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
define|#
directive|define
name|PRINTWORD
parameter_list|(
name|n
parameter_list|,
name|delimiter
parameter_list|)
define|\
value|printf("word ## n: 0x%016llx%c", (long long)word ## n, delimiter)
define|#
directive|define
name|SKIPASSERT
parameter_list|(
name|n
parameter_list|)
define|\
value|KASSERT(sc->sc_rxcomps[sc->sc_rxcptr].crc_word ## n == 0,	\ 	    ("%s: word ## n not 0", __func__))
define|#
directive|define
name|WORDTOH
parameter_list|(
name|n
parameter_list|)
define|\
value|word ## n = le64toh(sc->sc_rxcomps[sc->sc_rxcptr].crc_word ## n)
comment|/* 	 * Read the completion head register once.  This limits 	 * how long the following loop can execute. 	 */
name|rxhead
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_COMP_HEAD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR4
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: sc->sc_rxcptr %d, sc->sc_rxdptr %d, head %d"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|rxcptr
argument_list|,
name|sc
operator|->
name|sc_rxdptr
argument_list|,
name|rxhead
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|skip
operator|=
literal|0
expr_stmt|;
name|CAS_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sc
operator|->
name|sc_rxcptr
operator|!=
name|rxhead
condition|;
name|sc
operator|->
name|sc_rxcptr
operator|=
name|CAS_NEXTRXCOMP
argument_list|(
name|sc
operator|->
name|sc_rxcptr
argument_list|)
control|)
block|{
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|SKIPASSERT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SKIPASSERT
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|SKIPASSERT
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|--
name|skip
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|WORDTOH
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|WORDTOH
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|WORDTOH
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|WORDTOH
argument_list|(
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"    completion %d: "
argument_list|,
name|sc
operator|->
name|sc_rxcptr
argument_list|)
expr_stmt|;
name|PRINTWORD
argument_list|(
literal|1
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|PRINTWORD
argument_list|(
literal|2
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|PRINTWORD
argument_list|(
literal|3
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|PRINTWORD
argument_list|(
literal|4
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|word1
operator|&
name|CAS_RC1_TYPE_MASK
operator|)
operator|==
name|CAS_RC1_TYPE_HW
operator|||
operator|(
name|word4
operator|&
name|CAS_RC4_ZERO
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
comment|/* 			 * The descriptor is still marked as owned, although 			 * it is supposed to have completed.  This has been 			 * observed on some machines.  Just exiting here 			 * might leave the packet sitting around until another 			 * one arrives to trigger a new interrupt, which is 			 * generally undesirable, so set up a timeout. 			 */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_rx_ch
argument_list|,
name|CAS_RXOWN_TICKS
argument_list|,
name|cas_rint_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|word4
operator|&
operator|(
name|CAS_RC4_BAD
operator||
name|CAS_RC4_LEN_MMATCH
operator|)
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"receive error: CRC error\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|KASSERT
argument_list|(
name|CAS_GET
argument_list|(
name|word1
argument_list|,
name|CAS_RC1_DATA_SIZE
argument_list|)
operator|==
literal|0
operator|||
name|CAS_GET
argument_list|(
name|word2
argument_list|,
name|CAS_RC2_HDR_SIZE
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: data and header present"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|word1
operator|&
name|CAS_RC1_SPLIT_PKT
operator|)
operator|==
literal|0
operator|||
name|CAS_GET
argument_list|(
name|word2
argument_list|,
name|CAS_RC2_HDR_SIZE
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: split and header present"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|CAS_GET
argument_list|(
name|word1
argument_list|,
name|CAS_RC1_DATA_SIZE
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|word1
operator|&
name|CAS_RC1_RELEASE_HDR
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: data present but header release"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|CAS_GET
argument_list|(
name|word2
argument_list|,
name|CAS_RC2_HDR_SIZE
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|word1
operator|&
name|CAS_RC1_RELEASE_DATA
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: header present but data release"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|CAS_GET
argument_list|(
name|word2
argument_list|,
name|CAS_RC2_HDR_SIZE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|idx
operator|=
name|CAS_GET
argument_list|(
name|word2
argument_list|,
name|CAS_RC2_HDR_INDEX
argument_list|)
expr_stmt|;
name|off
operator|=
name|CAS_GET
argument_list|(
name|word2
argument_list|,
name|CAS_RC2_HDR_OFF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR4
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: hdr at idx %d, off %d, len %d"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rxds
operator|=
operator|&
name|sc
operator|->
name|sc_rxdsoft
index|[
name|idx
index|]
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|rxds
operator|->
name|rxds_refcount
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxds
operator|->
name|rxds_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800016
name|MEXTADD
argument_list|(
name|m
argument_list|,
operator|(
name|caddr_t
operator|)
name|rxds
operator|->
name|rxds_buf
operator|+
name|off
operator|*
literal|256
operator|+
name|ETHER_ALIGN
argument_list|,
name|len
argument_list|,
name|cas_free
argument_list|,
name|rxds
argument_list|,
name|M_RDONLY
argument_list|,
name|EXT_NET_DRV
argument_list|)
expr_stmt|;
else|#
directive|else
name|MEXTADD
argument_list|(
name|m
argument_list|,
operator|(
name|caddr_t
operator|)
name|rxds
operator|->
name|rxds_buf
operator|+
name|off
operator|*
literal|256
operator|+
name|ETHER_ALIGN
argument_list|,
name|len
argument_list|,
name|cas_free
argument_list|,
name|sc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|idx
argument_list|,
name|M_RDONLY
argument_list|,
name|EXT_NET_DRV
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|cas_rxcksum
argument_list|(
name|m
argument_list|,
name|CAS_GET
argument_list|(
name|word4
argument_list|,
name|CAS_RC4_TCP_CSUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pass it on. */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|word1
operator|&
name|CAS_RC1_RELEASE_HDR
operator|)
operator|!=
literal|0
operator|&&
name|refcount_release
argument_list|(
operator|&
name|rxds
operator|->
name|rxds_refcount
argument_list|)
operator|!=
literal|0
condition|)
name|cas_add_rxdesc
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|=
name|CAS_GET
argument_list|(
name|word1
argument_list|,
name|CAS_RC1_DATA_SIZE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|idx
operator|=
name|CAS_GET
argument_list|(
name|word1
argument_list|,
name|CAS_RC1_DATA_INDEX
argument_list|)
expr_stmt|;
name|off
operator|=
name|CAS_GET
argument_list|(
name|word1
argument_list|,
name|CAS_RC1_DATA_OFF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR4
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: data at idx %d, off %d, len %d"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rxds
operator|=
operator|&
name|sc
operator|->
name|sc_rxdsoft
index|[
name|idx
index|]
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|rxds
operator|->
name|rxds_refcount
argument_list|)
expr_stmt|;
name|off
operator|+=
name|ETHER_ALIGN
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|CAS_PAGE_SIZE
operator|-
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxds
operator|->
name|rxds_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800016
name|MEXTADD
argument_list|(
name|m
argument_list|,
operator|(
name|caddr_t
operator|)
name|rxds
operator|->
name|rxds_buf
operator|+
name|off
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|cas_free
argument_list|,
name|rxds
argument_list|,
name|M_RDONLY
argument_list|,
name|EXT_NET_DRV
argument_list|)
expr_stmt|;
else|#
directive|else
name|MEXTADD
argument_list|(
name|m
argument_list|,
operator|(
name|caddr_t
operator|)
name|rxds
operator|->
name|rxds_buf
operator|+
name|off
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|cas_free
argument_list|,
name|sc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|idx
argument_list|,
name|M_RDONLY
argument_list|,
name|EXT_NET_DRV
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|idx2
operator|=
literal|0
expr_stmt|;
name|rxds2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|word1
operator|&
name|CAS_RC1_SPLIT_PKT
operator|)
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|word1
operator|&
name|CAS_RC1_RELEASE_NEXT
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: split but no release next"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|idx2
operator|=
name|CAS_GET
argument_list|(
name|word2
argument_list|,
name|CAS_RC2_NEXT_INDEX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR2
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: split at idx %d"
argument_list|,
name|__func__
argument_list|,
name|idx2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rxds2
operator|=
operator|&
name|sc
operator|->
name|sc_rxdsoft
index|[
name|idx2
index|]
expr_stmt|;
name|MGET
argument_list|(
name|m2
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|!=
name|NULL
condition|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|rxds2
operator|->
name|rxds_refcount
argument_list|)
expr_stmt|;
name|m2
operator|->
name|m_len
operator|=
name|len
operator|-
name|m
operator|->
name|m_len
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rxds2
operator|->
name|rxds_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800016
name|MEXTADD
argument_list|(
name|m2
argument_list|,
operator|(
name|caddr_t
operator|)
name|rxds2
operator|->
name|rxds_buf
argument_list|,
name|m2
operator|->
name|m_len
argument_list|,
name|cas_free
argument_list|,
name|rxds2
argument_list|,
name|M_RDONLY
argument_list|,
name|EXT_NET_DRV
argument_list|)
expr_stmt|;
else|#
directive|else
name|MEXTADD
argument_list|(
name|m2
argument_list|,
operator|(
name|caddr_t
operator|)
name|rxds2
operator|->
name|rxds_buf
argument_list|,
name|m2
operator|->
name|m_len
argument_list|,
name|cas_free
argument_list|,
name|sc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|idx2
argument_list|,
name|M_RDONLY
argument_list|,
name|EXT_NET_DRV
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|m2
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m2
argument_list|)
expr_stmt|;
name|m2
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m2
operator|!=
name|NULL
condition|)
name|m
operator|->
name|m_next
operator|=
name|m2
expr_stmt|;
else|else
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|cas_rxcksum
argument_list|(
name|m
argument_list|,
name|CAS_GET
argument_list|(
name|word4
argument_list|,
name|CAS_RC4_TCP_CSUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pass it on. */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|word1
operator|&
name|CAS_RC1_RELEASE_DATA
operator|)
operator|!=
literal|0
operator|&&
name|refcount_release
argument_list|(
operator|&
name|rxds
operator|->
name|rxds_refcount
argument_list|)
operator|!=
literal|0
condition|)
name|cas_add_rxdesc
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|word1
operator|&
name|CAS_RC1_SPLIT_PKT
operator|)
operator|!=
literal|0
operator|&&
name|refcount_release
argument_list|(
operator|&
name|rxds2
operator|->
name|rxds_refcount
argument_list|)
operator|!=
literal|0
condition|)
name|cas_add_rxdesc
argument_list|(
name|sc
argument_list|,
name|idx2
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
name|CAS_GET
argument_list|(
name|word1
argument_list|,
name|CAS_RC1_SKIP
argument_list|)
expr_stmt|;
name|skip
label|:
name|cas_rxcompinit
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxcomps
index|[
name|sc
operator|->
name|sc_rxcptr
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
name|CAS_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_COMP_TAIL
argument_list|,
name|sc
operator|->
name|sc_rxcptr
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PRINTWORD
undef|#
directive|undef
name|SKIPASSERT
undef|#
directive|undef
name|WORDTOH
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR4
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: done sc->sc_rxcptr %d, sc->sc_rxdptr %d, head %d"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|rxcptr
argument_list|,
name|sc
operator|->
name|sc_rxdptr
argument_list|,
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_COMP_HEAD
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|cas_free
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|cas_rxdsoft
modifier|*
name|rxds
decl_stmt|;
name|struct
name|cas_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800016
name|rxds
operator|=
name|arg2
expr_stmt|;
name|sc
operator|=
name|rxds
operator|->
name|rxds_sc
expr_stmt|;
name|idx
operator|=
name|rxds
operator|->
name|rxds_idx
expr_stmt|;
else|#
directive|else
name|sc
operator|=
name|arg1
expr_stmt|;
name|idx
operator|=
operator|(
name|uintptr_t
operator|)
name|arg2
expr_stmt|;
name|rxds
operator|=
operator|&
name|sc
operator|->
name|sc_rxdsoft
index|[
name|idx
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|rxds
operator|->
name|rxds_refcount
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * NB: this function can be called via m_freem(9) within 	 * this driver! 	 */
name|cas_add_rxdesc
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|cas_add_rxdesc
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|idx
parameter_list|)
block|{
name|u_int
name|locked
decl_stmt|;
if|if
condition|(
operator|(
name|locked
operator|=
name|CAS_LOCK_OWNED
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|CAS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rxdsoft
index|[
name|idx
index|]
operator|.
name|rxds_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|CAS_UPDATE_RXDESC
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxdptr
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxdptr
operator|=
name|CAS_NEXTRXDESC
argument_list|(
name|sc
operator|->
name|sc_rxdptr
argument_list|)
expr_stmt|;
comment|/* 	 * Update the RX kick register.  This register has to point to the 	 * descriptor after the last valid one (before the current batch) 	 * and for optimum performance should be incremented in multiples 	 * of 4 (the DMA engine fetches/updates descriptors in batches of 4). 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_rxdptr
operator|%
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
name|CAS_CDSYNC
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_KICK
argument_list|,
operator|(
name|sc
operator|->
name|sc_rxdptr
operator|+
name|CAS_NRXDESC
operator|-
literal|4
operator|)
operator|&
name|CAS_NRXDESC_MASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locked
operator|==
literal|0
condition|)
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_eint
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|status
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|CAS_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: status 0x%x"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|CAS_INTR_PCI_ERROR_INT
operator|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_ERROR_STATUS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", PCI bus error 0x%x"
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|CAS_ERROR_OTHER
operator|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", PCI status 0x%x"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|PCIR_STATUS
argument_list|,
name|status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|cas_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cas_intr
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_STATUS_ALIAS
argument_list|)
operator|&
name|CAS_INTR_SUMMARY
operator|)
operator|==
literal|0
argument_list|)
condition|)
return|return
operator|(
name|FILTER_STRAY
operator|)
return|;
comment|/* Disable interrupts. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_INTMASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_intr_task
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_intr_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|status
decl_stmt|,
name|status2
decl_stmt|;
name|CAS_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|status
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|status
operator|&
name|CAS_INTR_SUMMARY
operator|)
operator|==
literal|0
argument_list|)
condition|)
goto|goto
name|done
goto|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR4
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: %s: cplt %x, status %x"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|__func__
argument_list|,
operator|(
name|status
operator|>>
name|CAS_STATUS_TX_COMP3_SHIFT
operator|)
argument_list|,
operator|(
name|u_int
operator|)
name|status
argument_list|)
expr_stmt|;
comment|/* 	 * PCS interrupts must be cleared, otherwise no traffic is passed! 	 */
if|if
condition|(
operator|(
name|status
operator|&
name|CAS_INTR_PCS_INT
operator|)
operator|!=
literal|0
condition|)
block|{
name|status2
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_PCS_INTR_STATUS
argument_list|)
operator||
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_PCS_INTR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status2
operator|&
name|CAS_PCS_INTR_LINK
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: PCS link status changed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|CAS_MAC_CTRL_STATUS
operator|)
operator|!=
literal|0
condition|)
block|{
name|status2
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_CTRL_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status2
operator|&
name|CAS_MAC_CTRL_PAUSE
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: PAUSE received (PAUSE time %d slots)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|status2
operator|&
name|CAS_MAC_CTRL_STATUS_PT_MASK
operator|)
operator|>>
name|CAS_MAC_CTRL_STATUS_PT_SHFT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status2
operator|&
name|CAS_MAC_CTRL_PAUSE
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: transited to PAUSE state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status2
operator|&
name|CAS_MAC_CTRL_NON_PAUSE
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: transited to non-PAUSE state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|CAS_INTR_MIF
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: MIF interrupt\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|status
operator|&
operator|(
name|CAS_INTR_TX_TAG_ERR
operator||
name|CAS_INTR_RX_TAG_ERR
operator||
name|CAS_INTR_RX_LEN_MMATCH
operator||
name|CAS_INTR_PCI_ERROR_INT
operator|)
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|cas_eint
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|status
operator|&
name|CAS_INTR_TX_MAC_INT
argument_list|)
condition|)
block|{
name|status2
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status2
operator|&
operator|(
name|CAS_MAC_TX_UNDERRUN
operator||
name|CAS_MAC_TX_MAX_PKT_ERR
operator|)
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|status2
operator|&
operator|~
name|CAS_MAC_TX_FRAME_XMTD
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"MAC TX fault, status %x\n"
argument_list|,
name|status2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|status
operator|&
name|CAS_INTR_RX_MAC_INT
argument_list|)
condition|)
block|{
name|status2
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status2
operator|&
name|CAS_MAC_RX_OVERFLOW
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|status2
operator|&
operator|~
name|CAS_MAC_RX_FRAME_RCVD
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"MAC RX fault, status %x\n"
argument_list|,
name|status2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|CAS_INTR_RX_DONE
operator||
name|CAS_INTR_RX_BUF_NA
operator||
name|CAS_INTR_RX_COMP_FULL
operator||
name|CAS_INTR_RX_BUF_AEMPTY
operator||
name|CAS_INTR_RX_COMP_AFULL
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cas_rint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|status
operator|&
operator|(
name|CAS_INTR_RX_BUF_NA
operator||
name|CAS_INTR_RX_COMP_FULL
operator||
name|CAS_INTR_RX_BUF_AEMPTY
operator||
name|CAS_INTR_RX_COMP_AFULL
operator|)
operator|)
operator|!=
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RX fault, status %x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|CAS_INTR_TX_INT_ME
operator||
name|CAS_INTR_TX_ALL
operator||
name|CAS_INTR_TX_DONE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|CAS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cas_tint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx_task
argument_list|)
expr_stmt|;
name|status
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_STATUS_ALIAS
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|status
operator|&
name|CAS_INTR_SUMMARY
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_intr_task
argument_list|)
expr_stmt|;
return|return;
block|}
name|done
label|:
comment|/* Re-enable interrupts. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_INTMASK
argument_list|,
operator|~
operator|(
name|CAS_INTR_TX_INT_ME
operator||
name|CAS_INTR_TX_TAG_ERR
operator||
name|CAS_INTR_RX_DONE
operator||
name|CAS_INTR_RX_BUF_NA
operator||
name|CAS_INTR_RX_TAG_ERR
operator||
name|CAS_INTR_RX_COMP_FULL
operator||
name|CAS_INTR_RX_BUF_AEMPTY
operator||
name|CAS_INTR_RX_COMP_AFULL
operator||
name|CAS_INTR_RX_LEN_MMATCH
operator||
name|CAS_INTR_PCI_ERROR_INT
ifdef|#
directive|ifdef
name|CAS_DEBUG
operator||
name|CAS_INTR_PCS_INT
operator||
name|CAS_INTR_MIF
endif|#
directive|endif
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_watchdog
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|CAS_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
name|CTR4
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: CAS_RX_CONFIG %x CAS_MAC_RX_STATUS %x CAS_MAC_RX_CONFIG %x"
argument_list|,
name|__func__
argument_list|,
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_RX_CONFIG
argument_list|)
argument_list|,
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_STATUS
argument_list|)
argument_list|,
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CAS
argument_list|,
literal|"%s: CAS_TX_CONFIG %x CAS_MAC_TX_STATUS %x CAS_MAC_TX_CONFIG %x"
argument_list|,
name|__func__
argument_list|,
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_TX_CONFIG
argument_list|)
argument_list|,
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_STATUS
argument_list|)
argument_list|,
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONFIG
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_wdog_timer
operator|==
literal|0
operator|||
operator|--
name|sc
operator|->
name|sc_wdog_timer
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_LINK
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device timeout (no link)\n"
argument_list|)
expr_stmt|;
operator|++
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
comment|/* Try to get more packets going. */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|cas_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_mifinit
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Configure the MIF in frame mode. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MIF_CONF
argument_list|,
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MIF_CONF
argument_list|)
operator|&
operator|~
name|CAS_MIF_CONF_BB_MODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MII interface  *  * The MII interface supports at least three different operating modes:  *  * Bitbang mode is implemented using data, clock and output enable registers.  *  * Frame mode is implemented by loading a complete frame into the frame  * register and polling the valid bit for completion.  *  * Polling mode uses the frame register but completion is indicated by  * an interrupt.  *  */
end_comment

begin_function
specifier|static
name|int
name|cas_mii_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG_PHY
name|printf
argument_list|(
literal|"%s: phy %d reg %d\n"
argument_list|,
name|__func__
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_phyad
operator|!=
operator|-
literal|1
operator|&&
name|phy
operator|!=
name|sc
operator|->
name|sc_phyad
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_SERDES
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|MII_BMCR
case|:
name|reg
operator|=
name|CAS_PCS_CTRL
expr_stmt|;
break|break;
case|case
name|MII_BMSR
case|:
name|reg
operator|=
name|CAS_PCS_STATUS
expr_stmt|;
break|break;
case|case
name|MII_PHYIDR1
case|:
case|case
name|MII_PHYIDR2
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MII_ANAR
case|:
name|reg
operator|=
name|CAS_PCS_ANAR
expr_stmt|;
break|break;
case|case
name|MII_ANLPAR
case|:
name|reg
operator|=
name|CAS_PCS_ANLPAR
expr_stmt|;
break|break;
case|case
name|MII_EXTSR
case|:
return|return
operator|(
name|EXTSR_1000XFDX
operator||
name|EXTSR_1000XHDX
operator|)
return|;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unhandled register %d\n"
argument_list|,
name|__func__
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
comment|/* Construct the frame command. */
name|v
operator|=
name|CAS_MIF_FRAME_READ
operator||
operator|(
name|phy
operator|<<
name|CAS_MIF_FRAME_PHY_SHFT
operator|)
operator||
operator|(
name|reg
operator|<<
name|CAS_MIF_FRAME_REG_SHFT
operator|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MIF_FRAME
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_MIF_FRAME
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|100
condition|;
name|n
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MIF_FRAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|CAS_MIF_FRAME_TA_LSB
condition|)
return|return
operator|(
name|v
operator|&
name|CAS_MIF_FRAME_DATA
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timed out\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cas_mii_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG_PHY
name|printf
argument_list|(
literal|"%s: phy %d reg %d val %x\n"
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|,
name|val
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_phyad
operator|!=
operator|-
literal|1
operator|&&
name|phy
operator|!=
name|sc
operator|->
name|sc_phyad
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_SERDES
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|MII_BMSR
case|:
name|reg
operator|=
name|CAS_PCS_STATUS
expr_stmt|;
break|break;
case|case
name|MII_BMCR
case|:
name|reg
operator|=
name|CAS_PCS_CTRL
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|CAS_PCS_CTRL_RESET
operator|)
operator|==
literal|0
condition|)
break|break;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_PCS_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_PCS_CTRL
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cas_bitwait
argument_list|(
name|sc
argument_list|,
name|CAS_PCS_CTRL
argument_list|,
name|CAS_PCS_CTRL_RESET
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot reset PCS\n"
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MII_ANAR
case|:
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_PCS_CONF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_PCS_CONF
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_PCS_ANAR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_PCS_SERDES_CTRL
argument_list|,
name|CAS_PCS_SERDES_CTRL_ESD
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_PCS_CONF
argument_list|,
name|CAS_PCS_CONF_EN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MII_ANLPAR
case|:
name|reg
operator|=
name|CAS_PCS_ANLPAR
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: unhandled register %d\n"
argument_list|,
name|__func__
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Construct the frame command. */
name|v
operator|=
name|CAS_MIF_FRAME_WRITE
operator||
operator|(
name|phy
operator|<<
name|CAS_MIF_FRAME_PHY_SHFT
operator|)
operator||
operator|(
name|reg
operator|<<
name|CAS_MIF_FRAME_REG_SHFT
operator|)
operator||
operator|(
name|val
operator|&
name|CAS_MIF_FRAME_DATA
operator|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MIF_FRAME
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_MIF_FRAME
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|100
condition|;
name|n
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MIF_FRAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|CAS_MIF_FRAME_TA_LSB
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timed out\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_mii_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|gigabit
decl_stmt|;
name|uint32_t
name|rxcfg
decl_stmt|,
name|txcfg
decl_stmt|,
name|v
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|CAS_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CAS_DEBUG
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: status change: PHY = %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_phyad
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_status
operator|&
name|IFM_ACTIVE
operator|)
operator|!=
literal|0
operator|&&
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|!=
name|IFM_NONE
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|CAS_LINK
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|CAS_LINK
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_1000_SX
case|:
case|case
name|IFM_1000_LX
case|:
case|case
name|IFM_1000_CX
case|:
case|case
name|IFM_1000_T
case|:
name|gigabit
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|gigabit
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * The configuration done here corresponds to the steps F) and 	 * G) and as far as enabling of RX and TX MAC goes also step H) 	 * of the initialization sequence outlined in section 11.2.1 of 	 * the Cassini+ ASIC Specification. 	 */
name|rxcfg
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|)
expr_stmt|;
name|rxcfg
operator|&=
operator|~
operator|(
name|CAS_MAC_RX_CONF_EN
operator||
name|CAS_MAC_RX_CONF_CARR
operator|)
expr_stmt|;
name|txcfg
operator|=
name|CAS_MAC_TX_CONF_EN_IPG0
operator||
name|CAS_MAC_TX_CONF_NGU
operator||
name|CAS_MAC_TX_CONF_NGUL
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|txcfg
operator||=
name|CAS_MAC_TX_CONF_ICARR
operator||
name|CAS_MAC_TX_CONF_ICOLLIS
expr_stmt|;
elseif|else
if|if
condition|(
name|gigabit
operator|!=
literal|0
condition|)
block|{
name|rxcfg
operator||=
name|CAS_MAC_RX_CONF_CARR
expr_stmt|;
name|txcfg
operator||=
name|CAS_MAC_TX_CONF_CARR
expr_stmt|;
block|}
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONF
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cas_bitwait
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONF
argument_list|,
name|CAS_MAC_TX_CONF_EN
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot disable TX MAC\n"
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONF
argument_list|,
name|txcfg
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cas_bitwait
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
name|CAS_MAC_RX_CONF_EN
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot disable RX MAC\n"
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
name|rxcfg
argument_list|)
expr_stmt|;
name|v
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_CTRL_CONF
argument_list|)
operator|&
operator|~
operator|(
name|CAS_MAC_CTRL_CONF_TXP
operator||
name|CAS_MAC_CTRL_CONF_RXP
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_RXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|v
operator||=
name|CAS_MAC_CTRL_CONF_RXP
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_TXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|v
operator||=
name|CAS_MAC_CTRL_CONF_TXP
expr_stmt|;
endif|#
directive|endif
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_CTRL_CONF
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* 	 * All supported chips have a bug causing incorrect checksum 	 * to be calculated when letting them strip the FCS in half- 	 * duplex mode.  In theory we could disable FCS stripping and 	 * manually adjust the checksum accordingly.  It seems to make 	 * more sense to optimze for the common case and just disable 	 * hardware checksumming in half-duplex mode though. 	 */
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_NO_CSUM
operator|)
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|CAS_CSUM_FEATURES
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_variant
operator|==
name|CAS_SATURN
condition|)
block|{
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|==
literal|0
condition|)
comment|/* silicon bug workaround */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_PREAMBLE_LEN
argument_list|,
literal|0x41
argument_list|)
expr_stmt|;
else|else
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_PREAMBLE_LEN
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|==
literal|0
operator|&&
name|gigabit
operator|!=
literal|0
condition|)
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_SLOT_TIME
argument_list|,
name|CAS_MAC_SLOT_TIME_CARR
argument_list|)
expr_stmt|;
else|else
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_SLOT_TIME
argument_list|,
name|CAS_MAC_SLOT_TIME_NORM
argument_list|)
expr_stmt|;
comment|/* XIF Configuration */
name|v
operator|=
name|CAS_MAC_XIF_CONF_TX_OE
operator||
name|CAS_MAC_XIF_CONF_LNKLED
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_SERDES
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|==
literal|0
condition|)
name|v
operator||=
name|CAS_MAC_XIF_CONF_NOECHO
expr_stmt|;
name|v
operator||=
name|CAS_MAC_XIF_CONF_BUF_OE
expr_stmt|;
block|}
if|if
condition|(
name|gigabit
operator|!=
literal|0
condition|)
name|v
operator||=
name|CAS_MAC_XIF_CONF_GMII
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|v
operator||=
name|CAS_MAC_XIF_CONF_FDXLED
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_XIF_CONF
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_LINK
operator|)
operator|!=
literal|0
condition|)
block|{
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_TX_CONF
argument_list|,
name|txcfg
operator||
name|CAS_MAC_TX_CONF_EN
argument_list|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
name|rxcfg
operator||
name|CAS_MAC_RX_CONF_EN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cas_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* XXX add support for serial media. */
name|CAS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mii_mediachg
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|CAS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|mii_pollstat
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_status
expr_stmt|;
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cas_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|CAS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|sc_ifflags
operator|)
operator|&
operator|(
name|IFF_ALLMULTI
operator||
name|IFF_PROMISC
operator|)
operator|)
operator|!=
literal|0
condition|)
name|cas_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|cas_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|cas_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifflags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|CAS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CAS_NO_CSUM
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|ifp
operator|->
name|if_capenable
operator|=
name|ifr
operator|->
name|ifr_reqcap
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|CAS_CSUM_FEATURES
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|CAS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|cas_setladrf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CAS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_mtu
operator|<
name|ETHERMIN
operator|)
operator|||
operator|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU_JUMBO
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cas_setladrf
parameter_list|(
name|struct
name|cas_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|inm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|hash
index|[
literal|16
index|]
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|,
name|v
decl_stmt|;
name|CAS_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Get the current RX configuration. */
name|v
operator|=
name|CAS_READ_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|)
expr_stmt|;
comment|/* 	 * Turn off promiscuous mode, promiscuous group mode (all multicast), 	 * and hash filter.  Depending on the case, the right bit will be 	 * enabled. 	 */
name|v
operator|&=
operator|~
operator|(
name|CAS_MAC_RX_CONF_PROMISC
operator||
name|CAS_MAC_RX_CONF_HFILTER
operator||
name|CAS_MAC_RX_CONF_PGRP
operator|)
expr_stmt|;
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|CAS_BARRIER
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cas_bitwait
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
name|CAS_MAC_RX_CONF_HFILTER
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot disable RX hash filter\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
block|{
name|v
operator||=
name|CAS_MAC_RX_CONF_PROMISC
expr_stmt|;
goto|goto
name|chipit
goto|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|!=
literal|0
condition|)
block|{
name|v
operator||=
name|CAS_MAC_RX_CONF_PGRP
expr_stmt|;
goto|goto
name|chipit
goto|;
block|}
comment|/* 	 * Set up multicast address filter by passing all multicast 	 * addresses through a crc generator, and then using the high 	 * order 8 bits as an index into the 256 bit logical address 	 * filter.  The high order 4 bits selects the word, while the 	 * other 4 bits select the bit within the word (where bit 0 	 * is the MSB). 	 */
comment|/* Clear the hash table. */
name|memset
argument_list|(
name|hash
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|inm
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|inm
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|crc
operator|=
name|ether_crc32_le
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|inm
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* We just want the 8 most significant bits. */
name|crc
operator|>>=
literal|24
expr_stmt|;
comment|/* Set the corresponding bit in the filter. */
name|hash
index|[
name|crc
operator|>>
literal|4
index|]
operator||=
literal|1
operator|<<
operator|(
literal|15
operator|-
operator|(
name|crc
operator|&
literal|15
operator|)
operator|)
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|v
operator||=
name|CAS_MAC_RX_CONF_HFILTER
expr_stmt|;
comment|/* Now load the hash table into the chip (if we are using it). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_HASH0
operator|+
name|i
operator|*
operator|(
name|CAS_MAC_HASH1
operator|-
name|CAS_MAC_HASH0
operator|)
argument_list|,
name|hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|chipit
label|:
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_MAC_RX_CONF
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|cas_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cas_pci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|cas_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cas_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cas_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cas_pci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|cas_pci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|cas_pci_resume
argument_list|)
block|,
comment|/* Use the suspend handler here, it is all that is required. */
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|cas_pci_suspend
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|cas_mii_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|cas_mii_writereg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|cas_mii_statchg
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cas_pci_driver
init|=
block|{
literal|"cas"
block|,
name|cas_pci_methods
block|,
expr|sizeof
operator|(
expr|struct
name|cas_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cas
argument_list|,
name|pci
argument_list|,
name|cas_pci_driver
argument_list|,
name|cas_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|cas
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|cas
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
specifier|const
struct|struct
name|cas_pci_dev
block|{
name|uint32_t
name|cpd_devid
decl_stmt|;
name|uint8_t
name|cpd_revid
decl_stmt|;
name|int
name|cpd_variant
decl_stmt|;
specifier|const
name|char
modifier|*
name|cpd_desc
decl_stmt|;
block|}
decl|const
name|cas_pci_devlist
index|[]
init|=
block|{
block|{
literal|0x0035100b
block|,
literal|0x0
block|,
name|CAS_SATURN
block|,
literal|"NS DP83065 Saturn Gigabit Ethernet"
block|}
block|,
block|{
literal|0xabba108e
block|,
literal|0x10
block|,
name|CAS_CASPLUS
block|,
literal|"Sun Cassini+ Gigabit Ethernet"
block|}
block|,
block|{
literal|0xabba108e
block|,
literal|0x0
block|,
name|CAS_CAS
block|,
literal|"Sun Cassini Gigabit Ethernet"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|cas_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cas_pci_devlist
index|[
name|i
index|]
operator|.
name|cpd_desc
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|cas_pci_devlist
index|[
name|i
index|]
operator|.
name|cpd_devid
operator|&&
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
operator|>=
name|cas_pci_devlist
index|[
name|i
index|]
operator|.
name|cpd_revid
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|cas_pci_devlist
index|[
name|i
index|]
operator|.
name|cpd_desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|cas_pci_res_spec
index|[]
init|=
block|{
block|{
name|SYS_RES_IRQ
block|,
literal|0
block|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
block|}
block|,
comment|/* CAS_RES_INTR */
block|{
name|SYS_RES_MEMORY
block|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* CAS_RES_MEM */
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|cas_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|__powerpc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparc64__
argument_list|)
operator|)
name|u_char
name|enaddr
index|[
literal|4
index|]
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|char
name|lma
index|[
sizeof|sizeof
argument_list|(
literal|"local-mac-address"
argument_list|)
index|]
decl_stmt|;
name|int
name|found
decl_stmt|,
name|j
decl_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_variant
operator|=
name|CAS_UNKNOWN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cas_pci_devlist
index|[
name|i
index|]
operator|.
name|cpd_desc
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|cas_pci_devlist
index|[
name|i
index|]
operator|.
name|cpd_devid
operator|&&
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
operator|>=
name|cas_pci_devlist
index|[
name|i
index|]
operator|.
name|cpd_revid
condition|)
block|{
name|sc
operator|->
name|sc_variant
operator|=
name|cas_pci_devlist
index|[
name|i
index|]
operator|.
name|cpd_variant
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_variant
operator|==
name|CAS_UNKNOWN
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unknown adaptor\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_variant
operator|==
name|CAS_CAS
operator|&&
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|<
literal|0x02
condition|)
comment|/* Hardware checksumming may hang TX. */
name|sc
operator|->
name|sc_flags
operator||=
name|CAS_NO_CSUM
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_variant
operator|==
name|CAS_CASPLUS
operator|||
name|sc
operator|->
name|sc_variant
operator|==
name|CAS_SATURN
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|CAS_REG_PLUS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_variant
operator|==
name|CAS_CAS
operator|||
operator|(
name|sc
operator|->
name|sc_variant
operator|==
name|CAS_CASPLUS
operator|&&
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
operator|<
literal|0x11
operator|)
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|CAS_TABORT
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"flags=0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|cas_pci_res_spec
argument_list|,
name|sc
operator|->
name|sc_res
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate resources\n"
argument_list|)
expr_stmt|;
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|cas_pci_res_spec
argument_list|,
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|CAS_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__powerpc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparc64__
argument_list|)
name|OF_getetheraddr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Dig out VPD (vital product data) and read the MAX address. 	 * The VPD resides in the PCI Expansion ROM (PCI FCode) and 	 * can't be accessed via the PCI capability pointer. 	 * SUNW,pci-ce and SUNW,pci-qge use the Enhanced VPD format 	 * described in US Patent 7149820. 	 */
define|#
directive|define
name|PCI_ROMHDR_SIZE
value|0x1c
define|#
directive|define
name|PCI_ROMHDR_SIG
value|0x00
define|#
directive|define
name|PCI_ROMHDR_SIG_MAGIC
value|0xaa55
comment|/* little endian */
define|#
directive|define
name|PCI_ROMHDR_PTR_DATA
value|0x18
define|#
directive|define
name|PCI_ROM_SIZE
value|0x18
define|#
directive|define
name|PCI_ROM_SIG
value|0x00
define|#
directive|define
name|PCI_ROM_SIG_MAGIC
value|0x52494350
comment|/* "PCIR", endian */
comment|/* reversed */
define|#
directive|define
name|PCI_ROM_VENDOR
value|0x04
define|#
directive|define
name|PCI_ROM_DEVICE
value|0x06
define|#
directive|define
name|PCI_ROM_PTR_VPD
value|0x08
define|#
directive|define
name|PCI_VPDRES_BYTE0
value|0x00
define|#
directive|define
name|PCI_VPDRES_ISLARGE
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x80)
define|#
directive|define
name|PCI_VPDRES_LARGE_NAME
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x7f)
define|#
directive|define
name|PCI_VPDRES_LARGE_LEN_LSB
value|0x01
define|#
directive|define
name|PCI_VPDRES_LARGE_LEN_MSB
value|0x02
define|#
directive|define
name|PCI_VPDRES_LARGE_SIZE
value|0x03
define|#
directive|define
name|PCI_VPDRES_TYPE_ID_STRING
value|0x02
comment|/* large */
define|#
directive|define
name|PCI_VPDRES_TYPE_VPD
value|0x10
comment|/* large */
define|#
directive|define
name|PCI_VPD_KEY0
value|0x00
define|#
directive|define
name|PCI_VPD_KEY1
value|0x01
define|#
directive|define
name|PCI_VPD_LEN
value|0x02
define|#
directive|define
name|PCI_VPD_SIZE
value|0x03
define|#
directive|define
name|CAS_ROM_READ_1
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|)
define|\
value|CAS_READ_1((sc), CAS_PCI_ROM_OFFSET + (offs))
define|#
directive|define
name|CAS_ROM_READ_2
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|)
define|\
value|CAS_READ_2((sc), CAS_PCI_ROM_OFFSET + (offs))
define|#
directive|define
name|CAS_ROM_READ_4
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|)
define|\
value|CAS_READ_4((sc), CAS_PCI_ROM_OFFSET + (offs))
name|found
operator|=
literal|0
expr_stmt|;
comment|/* Enable PCI Expansion ROM access. */
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_BIM_LDEV_OEN
argument_list|,
name|CAS_BIM_LDEV_OEN_PAD
operator||
name|CAS_BIM_LDEV_OEN_PROM
argument_list|)
expr_stmt|;
comment|/* Read PCI Expansion ROM header. */
if|if
condition|(
name|CAS_ROM_READ_2
argument_list|(
name|sc
argument_list|,
name|PCI_ROMHDR_SIG
argument_list|)
operator|!=
name|PCI_ROMHDR_SIG_MAGIC
operator|||
operator|(
name|i
operator|=
name|CAS_ROM_READ_2
argument_list|(
name|sc
argument_list|,
name|PCI_ROMHDR_PTR_DATA
argument_list|)
operator|)
operator|<
name|PCI_ROMHDR_SIZE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unexpected PCI Expansion ROM header\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_prom
goto|;
block|}
comment|/* Read PCI Expansion ROM data. */
if|if
condition|(
name|CAS_ROM_READ_4
argument_list|(
name|sc
argument_list|,
name|i
operator|+
name|PCI_ROM_SIG
argument_list|)
operator|!=
name|PCI_ROM_SIG_MAGIC
operator|||
name|CAS_ROM_READ_2
argument_list|(
name|sc
argument_list|,
name|i
operator|+
name|PCI_ROM_VENDOR
argument_list|)
operator|!=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|||
name|CAS_ROM_READ_2
argument_list|(
name|sc
argument_list|,
name|i
operator|+
name|PCI_ROM_DEVICE
argument_list|)
operator|!=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|||
operator|(
name|j
operator|=
name|CAS_ROM_READ_2
argument_list|(
name|sc
argument_list|,
name|i
operator|+
name|PCI_ROM_PTR_VPD
argument_list|)
operator|)
operator|<
name|i
operator|+
name|PCI_ROM_SIZE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unexpected PCI Expansion ROM data\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_prom
goto|;
block|}
comment|/* Read PCI VPD. */
name|next
label|:
if|if
condition|(
name|PCI_VPDRES_ISLARGE
argument_list|(
name|CAS_ROM_READ_1
argument_list|(
name|sc
argument_list|,
name|j
operator|+
name|PCI_VPDRES_BYTE0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"no large PCI VPD\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_prom
goto|;
block|}
name|i
operator|=
operator|(
name|CAS_ROM_READ_1
argument_list|(
name|sc
argument_list|,
name|j
operator|+
name|PCI_VPDRES_LARGE_LEN_MSB
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|CAS_ROM_READ_1
argument_list|(
name|sc
argument_list|,
name|j
operator|+
name|PCI_VPDRES_LARGE_LEN_LSB
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|PCI_VPDRES_LARGE_NAME
argument_list|(
name|CAS_ROM_READ_1
argument_list|(
name|sc
argument_list|,
name|j
operator|+
name|PCI_VPDRES_BYTE0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|PCI_VPDRES_TYPE_ID_STRING
case|:
comment|/* Skip identifier string. */
name|j
operator|+=
name|PCI_VPDRES_LARGE_SIZE
operator|+
name|i
expr_stmt|;
goto|goto
name|next
goto|;
case|case
name|PCI_VPDRES_TYPE_VPD
case|:
for|for
control|(
name|j
operator|+=
name|PCI_VPDRES_LARGE_SIZE
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
name|PCI_VPD_SIZE
operator|+
name|CAS_ROM_READ_1
argument_list|(
name|sc
argument_list|,
name|j
operator|+
name|PCI_VPD_LEN
argument_list|)
operator|,
name|j
operator|+=
name|PCI_VPD_SIZE
operator|+
name|CAS_ROM_READ_1
argument_list|(
name|sc
argument_list|,
name|j
operator|+
name|PCI_VPD_LEN
argument_list|)
control|)
block|{
if|if
condition|(
name|CAS_ROM_READ_1
argument_list|(
name|sc
argument_list|,
name|j
operator|+
name|PCI_VPD_KEY0
argument_list|)
operator|!=
literal|'Z'
condition|)
comment|/* no Enhanced VPD */
continue|continue;
if|if
condition|(
name|CAS_ROM_READ_1
argument_list|(
name|sc
argument_list|,
name|j
operator|+
name|PCI_VPD_SIZE
argument_list|)
operator|!=
literal|'I'
condition|)
comment|/* no instance property */
continue|continue;
if|if
condition|(
name|CAS_ROM_READ_1
argument_list|(
name|sc
argument_list|,
name|j
operator|+
name|PCI_VPD_SIZE
operator|+
literal|3
argument_list|)
operator|!=
literal|'B'
condition|)
comment|/* no byte array */
continue|continue;
if|if
condition|(
name|CAS_ROM_READ_1
argument_list|(
name|sc
argument_list|,
name|j
operator|+
name|PCI_VPD_SIZE
operator|+
literal|4
argument_list|)
operator|!=
name|ETHER_ADDR_LEN
condition|)
continue|continue;
name|bus_read_region_1
argument_list|(
name|sc
operator|->
name|sc_res
index|[
name|CAS_RES_MEM
index|]
argument_list|,
name|CAS_PCI_ROM_OFFSET
operator|+
name|j
operator|+
name|PCI_VPD_SIZE
operator|+
literal|5
argument_list|,
name|lma
argument_list|,
sizeof|sizeof
argument_list|(
name|lma
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|lma
argument_list|,
literal|"local-mac-address"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|bus_read_region_1
argument_list|(
name|sc
operator|->
name|sc_res
index|[
name|CAS_RES_MEM
index|]
argument_list|,
name|CAS_PCI_ROM_OFFSET
operator|+
name|j
operator|+
name|PCI_VPD_SIZE
operator|+
literal|5
operator|+
sizeof|sizeof
argument_list|(
name|lma
argument_list|)
argument_list|,
name|enaddr
index|[
name|found
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|enaddr
index|[
name|found
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|++
operator|==
literal|4
condition|)
break|break;
block|}
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unexpected PCI VPD\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_prom
goto|;
block|}
name|fail_prom
label|:
name|CAS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|CAS_BIM_LDEV_OEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not determine Ethernet address\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|found
operator|>
literal|1
operator|&&
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|enaddr
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|enaddr
argument_list|)
condition|)
name|i
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|enaddr
index|[
name|i
index|]
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cas_attach
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not be attached\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_res
index|[
name|CAS_RES_INTR
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|cas_intr
argument_list|,
name|NULL
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to set up interrupt\n"
argument_list|)
expr_stmt|;
name|cas_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|CAS_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|cas_pci_res_spec
argument_list|,
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cas_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cas_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_res
index|[
name|CAS_RES_INTR
index|]
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|cas_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CAS_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|cas_pci_res_spec
argument_list|,
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cas_pci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|cas_suspend
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cas_pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|cas_resume
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

