begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, 1998, 1999  *	Bill Paul<wpaul@ctr.columbia.edu>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Lucent WaveLAN/IEEE 802.11 PCMCIA driver for FreeBSD.  *  * Written by Bill Paul<wpaul@ctr.columbia.edu>  * Electrical Engineering Department  * Columbia University, New York City  */
end_comment

begin_comment
comment|/*  * The WaveLAN/IEEE adapter is the second generation of the WaveLAN  * from Lucent. Unlike the older cards, the new ones are programmed  * entirely via a firmware-driven controller called the Hermes.  * Unfortunately, Lucent will not release the Hermes programming manual  * without an NDA (if at all). What they do release is an API library  * called the HCF (Hardware Control Functions) which is supposed to  * do the device-specific operations of a device driver for you. The  * publically available version of the HCF library (the 'HCF Light') is   * a) extremely gross, b) lacks certain features, particularly support  * for 802.11 frames, and c) is contaminated by the GNU Public License.  *  * This driver does not use the HCF or HCF Light at all. Instead, it  * programs the Hermes controller directly, using information gleaned  * from the HCF Light code and corresponding documentation.  *  * This driver supports the ISA, PCMCIA and PCI versions of the Lucent  * WaveLan cards (based on the Hermes chipset), as well as the newer  * Prism 2 chipsets with firmware from Intersil and Symbol.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/owi/if_ieee80211.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<dev/wi/if_wavelan_ieee.h>
end_include

begin_include
include|#
directive|include
file|<dev/owi/if_wivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/owi/if_wireg.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|wi_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wi_reset
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wi_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wi_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wi_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wi_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wi_rxeof
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wi_txeof
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wi_update_stats
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wi_setmulti
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wi_cmd
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wi_read_record
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|,
name|struct
name|wi_ltv_gen
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wi_write_record
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|,
name|struct
name|wi_ltv_gen
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wi_read_data
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wi_write_data
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wi_seek
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wi_alloc_nicmem
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wi_inquire
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wi_setdef
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|,
name|struct
name|wi_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|WICACHE
end_ifdef

begin_function_decl
specifier|static
name|void
name|wi_cache_store
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|,
name|struct
name|ether_header
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|unsigned
name|short
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|wi_get_cur_ssid
parameter_list|(
name|struct
name|wi_softc
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wi_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wi_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|devclass_t
name|owi_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|wi_card_ident
name|wi_card_ident
index|[]
init|=
block|{
comment|/* CARD_ID			CARD_NAME		FIRM_TYPE */
block|{
name|WI_NIC_LUCENT_ID
block|,
name|WI_NIC_LUCENT_STR
block|,
name|WI_LUCENT
block|}
block|,
block|{
name|WI_NIC_SONY_ID
block|,
name|WI_NIC_SONY_STR
block|,
name|WI_LUCENT
block|}
block|,
block|{
name|WI_NIC_LUCENT_EMB_ID
block|,
name|WI_NIC_LUCENT_EMB_STR
block|,
name|WI_LUCENT
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|owi_generic_detach
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"already unloaded\n"
argument_list|)
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|sc
operator|->
name|wi_gone
operator|=
operator|!
name|bus_child_present
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|owi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Delete all remaining media. */
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|wi_intrhand
argument_list|)
expr_stmt|;
name|owi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_gone
operator|=
literal|1
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|wi_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|owi_generic_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_ltv_macaddr
name|mac
decl_stmt|;
name|struct
name|wi_ltv_gen
name|gen
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* XXX maybe we need the splimp stuff here XXX */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
name|owi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|wi_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|wi_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_setup_intr() failed! (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|owi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|wi_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Reset the NIC. */
name|wi_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Read the station address. 	 * And do it twice. I've seen PRISM-based cards that return 	 * an error when trying to read it the first time, which causes 	 * the probe to fail. 	 */
name|mac
operator|.
name|wi_type
operator|=
name|WI_RID_MAC_NODE
expr_stmt|;
name|mac
operator|.
name|wi_len
operator|=
literal|4
expr_stmt|;
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|mac
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"mac read failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|owi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|owi_get_id
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|wi_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|wi_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|wi_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|wi_init
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|wi_node_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_node_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|WI_DEFAULT_NODENAME
argument_list|,
name|sc
operator|->
name|wi_node_name
argument_list|,
sizeof|sizeof
argument_list|(
name|WI_DEFAULT_NODENAME
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|WI_DEFAULT_NETNAME
argument_list|,
name|sc
operator|->
name|wi_net_name
argument_list|,
sizeof|sizeof
argument_list|(
name|WI_DEFAULT_NETNAME
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|wi_ibss_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_ibss_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|WI_DEFAULT_IBSS
argument_list|,
name|sc
operator|->
name|wi_ibss_name
argument_list|,
sizeof|sizeof
argument_list|(
name|WI_DEFAULT_IBSS
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_portnum
operator|=
name|WI_DEFAULT_PORT
expr_stmt|;
name|sc
operator|->
name|wi_ptype
operator|=
name|WI_PORTTYPE_BSS
expr_stmt|;
name|sc
operator|->
name|wi_ap_density
operator|=
name|WI_DEFAULT_AP_DENSITY
expr_stmt|;
name|sc
operator|->
name|wi_rts_thresh
operator|=
name|WI_DEFAULT_RTS_THRESH
expr_stmt|;
name|sc
operator|->
name|wi_tx_rate
operator|=
name|WI_DEFAULT_TX_RATE
expr_stmt|;
name|sc
operator|->
name|wi_max_data_len
operator|=
name|WI_DEFAULT_DATALEN
expr_stmt|;
name|sc
operator|->
name|wi_create_ibss
operator|=
name|WI_DEFAULT_CREATE_IBSS
expr_stmt|;
name|sc
operator|->
name|wi_pm_enabled
operator|=
name|WI_DEFAULT_PM_ENABLED
expr_stmt|;
name|sc
operator|->
name|wi_max_sleep
operator|=
name|WI_DEFAULT_MAX_SLEEP
expr_stmt|;
name|sc
operator|->
name|wi_roaming
operator|=
name|WI_DEFAULT_ROAMING
expr_stmt|;
name|sc
operator|->
name|wi_authtype
operator|=
name|WI_DEFAULT_AUTHTYPE
expr_stmt|;
name|sc
operator|->
name|wi_authmode
operator|=
name|IEEE80211_AUTH_OPEN
expr_stmt|;
comment|/* 	 * Read the default channel from the NIC. This may vary 	 * depending on the country where the NIC was purchased, so 	 * we can't hard-code a default and expect it to work for 	 * everyone. 	 */
name|gen
operator|.
name|wi_type
operator|=
name|WI_RID_OWN_CHNL
expr_stmt|;
name|gen
operator|.
name|wi_len
operator|=
literal|2
expr_stmt|;
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|&
name|gen
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_channel
operator|=
name|gen
operator|.
name|wi_val
expr_stmt|;
comment|/* 	 * Set flags based on firmware version. 	 */
switch|switch
condition|(
name|sc
operator|->
name|sc_firmware_type
condition|)
block|{
case|case
name|WI_LUCENT
case|:
name|sc
operator|->
name|wi_flags
operator||=
name|WI_FLAGS_HAS_ROAMING
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_sta_firmware_ver
operator|>=
literal|60000
condition|)
name|sc
operator|->
name|wi_flags
operator||=
name|WI_FLAGS_HAS_MOR
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_sta_firmware_ver
operator|>=
literal|60006
condition|)
block|{
name|sc
operator|->
name|wi_flags
operator||=
name|WI_FLAGS_HAS_IBSS
expr_stmt|;
name|sc
operator|->
name|wi_flags
operator||=
name|WI_FLAGS_HAS_CREATE_IBSS
expr_stmt|;
block|}
name|sc
operator|->
name|wi_ibss_port
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Find out if we support WEP on this card. 	 */
name|gen
operator|.
name|wi_type
operator|=
name|WI_RID_WEP_AVAIL
expr_stmt|;
name|gen
operator|.
name|wi_len
operator|=
literal|2
expr_stmt|;
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|&
name|gen
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_has_wep
operator|=
name|gen
operator|.
name|wi_val
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"owi_has_wep = %d\n"
argument_list|,
name|sc
operator|->
name|wi_has_wep
argument_list|)
expr_stmt|;
comment|/*  	 * Find supported rates. 	 */
name|gen
operator|.
name|wi_type
operator|=
name|WI_RID_DATA_RATES
expr_stmt|;
name|gen
operator|.
name|wi_len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|&
name|gen
argument_list|)
condition|)
name|sc
operator|->
name|wi_supprates
operator|=
name|WI_SUPPRATES_1M
operator||
name|WI_SUPPRATES_2M
operator||
name|WI_SUPPRATES_5M
operator||
name|WI_SUPPRATES_11M
expr_stmt|;
else|else
name|sc
operator|->
name|wi_supprates
operator|=
name|gen
operator|.
name|wi_val
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_stats
argument_list|)
argument_list|)
expr_stmt|;
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|owi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
literal|0
argument_list|,
name|wi_media_change
argument_list|,
name|wi_media_status
argument_list|)
expr_stmt|;
define|#
directive|define
name|ADD
parameter_list|(
name|m
parameter_list|,
name|c
parameter_list|)
value|ifmedia_add(&sc->ifmedia, (m), (c), NULL)
if|if
condition|(
name|sc
operator|->
name|wi_supprates
operator|&
name|WI_SUPPRATES_1M
condition|)
block|{
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS1
argument_list|,
name|IFM_IEEE80211_ADHOC
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_flags
operator|&
name|WI_FLAGS_HAS_IBSS
condition|)
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS1
argument_list|,
name|IFM_IEEE80211_IBSS
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_flags
operator|&
name|WI_FLAGS_HAS_CREATE_IBSS
condition|)
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS1
argument_list|,
name|IFM_IEEE80211_IBSSMASTER
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|wi_supprates
operator|&
name|WI_SUPPRATES_2M
condition|)
block|{
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS2
argument_list|,
name|IFM_IEEE80211_ADHOC
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_flags
operator|&
name|WI_FLAGS_HAS_IBSS
condition|)
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS2
argument_list|,
name|IFM_IEEE80211_IBSS
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_flags
operator|&
name|WI_FLAGS_HAS_CREATE_IBSS
condition|)
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS2
argument_list|,
name|IFM_IEEE80211_IBSSMASTER
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|wi_supprates
operator|&
name|WI_SUPPRATES_5M
condition|)
block|{
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS5
argument_list|,
name|IFM_IEEE80211_ADHOC
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_flags
operator|&
name|WI_FLAGS_HAS_IBSS
condition|)
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS5
argument_list|,
name|IFM_IEEE80211_IBSS
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_flags
operator|&
name|WI_FLAGS_HAS_CREATE_IBSS
condition|)
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS5
argument_list|,
name|IFM_IEEE80211_IBSSMASTER
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|wi_supprates
operator|&
name|WI_SUPPRATES_11M
condition|)
block|{
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS11
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS11
argument_list|,
name|IFM_IEEE80211_ADHOC
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_flags
operator|&
name|WI_FLAGS_HAS_IBSS
condition|)
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS11
argument_list|,
name|IFM_IEEE80211_IBSS
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_flags
operator|&
name|WI_FLAGS_HAS_CREATE_IBSS
condition|)
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_IEEE80211_DS11
argument_list|,
name|IFM_IEEE80211_IBSSMASTER
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_MANUAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_AUTO
argument_list|,
name|IFM_IEEE80211_ADHOC
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_flags
operator|&
name|WI_FLAGS_HAS_IBSS
condition|)
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_AUTO
argument_list|,
name|IFM_IEEE80211_IBSS
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_flags
operator|&
name|WI_FLAGS_HAS_CREATE_IBSS
condition|)
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_AUTO
argument_list|,
name|IFM_IEEE80211_IBSSMASTER
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ADD
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_MAKEWORD
argument_list|(
name|IFM_IEEE80211
argument_list|,
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Call MI attach routine. 	 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
operator|(
specifier|const
name|u_int8_t
operator|*
operator|)
name|mac
operator|.
name|wi_mac_addr
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|wi_stat_ch
argument_list|)
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|owi_get_id
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|wi_ltv_ver
name|ver
decl_stmt|;
name|struct
name|wi_card_ident
modifier|*
name|id
decl_stmt|;
comment|/* getting chip identity */
name|memset
argument_list|(
operator|&
name|ver
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ver
argument_list|)
argument_list|)
expr_stmt|;
name|ver
operator|.
name|wi_type
operator|=
name|WI_RID_CARD_ID
expr_stmt|;
name|ver
operator|.
name|wi_len
operator|=
literal|5
expr_stmt|;
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|ver
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"using "
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_firmware_type
operator|=
name|WI_NOTYPE
expr_stmt|;
for|for
control|(
name|id
operator|=
name|wi_card_ident
init|;
name|id
operator|->
name|card_name
operator|!=
name|NULL
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
name|le16toh
argument_list|(
name|ver
operator|.
name|wi_ver
index|[
literal|0
index|]
argument_list|)
operator|==
name|id
operator|->
name|card_id
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|id
operator|->
name|card_name
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_firmware_type
operator|=
name|id
operator|->
name|firm_type
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_firmware_type
operator|==
name|WI_NOTYPE
condition|)
block|{
if|if
condition|(
operator|(
name|le16toh
argument_list|(
name|ver
operator|.
name|wi_ver
index|[
literal|0
index|]
argument_list|)
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unknown Lucent chip"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_firmware_type
operator|=
name|WI_LUCENT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_firmware_type
operator|!=
name|WI_LUCENT
condition|)
return|return;
comment|/* get station firmware version */
name|memset
argument_list|(
operator|&
name|ver
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ver
argument_list|)
argument_list|)
expr_stmt|;
name|ver
operator|.
name|wi_type
operator|=
name|WI_RID_STA_IDENTITY
expr_stmt|;
name|ver
operator|.
name|wi_len
operator|=
literal|5
expr_stmt|;
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|ver
argument_list|)
expr_stmt|;
name|ver
operator|.
name|wi_ver
index|[
literal|1
index|]
operator|=
name|le16toh
argument_list|(
name|ver
operator|.
name|wi_ver
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ver
operator|.
name|wi_ver
index|[
literal|2
index|]
operator|=
name|le16toh
argument_list|(
name|ver
operator|.
name|wi_ver
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ver
operator|.
name|wi_ver
index|[
literal|3
index|]
operator|=
name|le16toh
argument_list|(
name|ver
operator|.
name|wi_ver
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sta_firmware_ver
operator|=
name|ver
operator|.
name|wi_ver
index|[
literal|2
index|]
operator|*
literal|10000
operator|+
name|ver
operator|.
name|wi_ver
index|[
literal|3
index|]
operator|*
literal|100
operator|+
name|ver
operator|.
name|wi_ver
index|[
literal|1
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Lucent Firmware: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Station %u.%02u.%02u\n"
argument_list|,
name|sc
operator|->
name|sc_sta_firmware_ver
operator|/
literal|10000
argument_list|,
operator|(
name|sc
operator|->
name|sc_sta_firmware_ver
operator|%
literal|10000
operator|)
operator|/
literal|100
argument_list|,
name|sc
operator|->
name|sc_sta_firmware_ver
operator|%
literal|100
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_rxeof
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|s
decl_stmt|;
name|WI_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_RX_FID
argument_list|)
expr_stmt|;
comment|/* 	 * if we have the procframe flag set, disregard all this and just 	 * read the data from the device. 	 */
if|if
condition|(
name|sc
operator|->
name|wi_procframe
operator|||
name|sc
operator|->
name|wi_debug
operator|.
name|wi_monitor
condition|)
block|{
name|struct
name|wi_frame
modifier|*
name|rx_frame
decl_stmt|;
name|int
name|datlen
decl_stmt|,
name|hdrlen
decl_stmt|;
comment|/* first allocate mbuf for packet storage */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
comment|/* now read wi_frame first so we know how much data to read */
if|if
condition|(
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|rx_frame
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|wi_frame
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|rx_frame
operator|->
name|wi_status
operator|&
name|WI_STAT_MAC_PORT
operator|)
operator|>>
literal|8
condition|)
block|{
case|case
literal|7
case|:
switch|switch
condition|(
name|rx_frame
operator|->
name|wi_frame_ctl
operator|&
name|WI_FCTL_FTYPE
condition|)
block|{
case|case
name|WI_FTYPE_DATA
case|:
name|hdrlen
operator|=
name|WI_DATA_HDRLEN
expr_stmt|;
name|datlen
operator|=
name|rx_frame
operator|->
name|wi_dat_len
operator|+
name|WI_FCS_LEN
expr_stmt|;
break|break;
case|case
name|WI_FTYPE_MGMT
case|:
name|hdrlen
operator|=
name|WI_MGMT_HDRLEN
expr_stmt|;
name|datlen
operator|=
name|rx_frame
operator|->
name|wi_dat_len
operator|+
name|WI_FCS_LEN
expr_stmt|;
break|break;
case|case
name|WI_FTYPE_CTL
case|:
comment|/* 				 * prism2 cards don't pass control packets 				 * down properly or consistently, so we'll only 				 * pass down the header. 				 */
name|hdrlen
operator|=
name|WI_CTL_HDRLEN
expr_stmt|;
name|datlen
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"received packet of "
literal|"unknown type on port 7\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|0
case|:
name|hdrlen
operator|=
name|WI_DATA_HDRLEN
expr_stmt|;
name|datlen
operator|=
name|rx_frame
operator|->
name|wi_dat_len
operator|+
name|WI_FCS_LEN
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"received packet on invalid "
literal|"port (wi_status=0x%x)\n"
argument_list|,
name|rx_frame
operator|->
name|wi_status
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|hdrlen
operator|+
name|datlen
operator|+
literal|2
operator|)
operator|>
name|MCLBYTES
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"oversized packet received "
literal|"(wi_dat_len=%d, wi_status=0x%x)\n"
argument_list|,
name|datlen
argument_list|,
name|rx_frame
operator|->
name|wi_status
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|hdrlen
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|hdrlen
argument_list|,
name|datlen
operator|+
literal|2
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|hdrlen
operator|+
name|datlen
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* Handle BPF listeners. */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|wi_frame
name|rx_frame
decl_stmt|;
comment|/* First read in the frame header */
if|if
condition|(
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rx_frame
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_frame
argument_list|)
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rx_frame
operator|.
name|wi_status
operator|&
name|WI_STAT_ERRSTAT
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|rx_frame
operator|.
name|wi_status
operator|==
name|WI_STAT_1042
operator|||
name|rx_frame
operator|.
name|wi_status
operator|==
name|WI_STAT_TUNNEL
operator|||
name|rx_frame
operator|.
name|wi_status
operator|==
name|WI_STAT_WMP_MSG
condition|)
block|{
if|if
condition|(
operator|(
name|rx_frame
operator|.
name|wi_dat_len
operator|+
name|WI_SNAPHDR_LEN
operator|)
operator|>
name|MCLBYTES
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"oversized packet received "
literal|"(wi_dat_len=%d, wi_status=0x%x)\n"
argument_list|,
name|rx_frame
operator|.
name|wi_dat_len
argument_list|,
name|rx_frame
operator|.
name|wi_status
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|rx_frame
operator|.
name|wi_dat_len
operator|+
name|WI_SNAPHDR_LEN
expr_stmt|;
if|#
directive|if
literal|0
block|bcopy((char *)&rx_frame.wi_addr1, 			    (char *)&eh->ether_dhost, ETHER_ADDR_LEN); 			if (sc->wi_ptype == WI_PORTTYPE_ADHOC) { 				bcopy((char *)&rx_frame.wi_addr2, 				    (char *)&eh->ether_shost, ETHER_ADDR_LEN); 			} else { 				bcopy((char *)&rx_frame.wi_addr3, 				    (char *)&eh->ether_shost, ETHER_ADDR_LEN); 			}
else|#
directive|else
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame
operator|.
name|wi_dst_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame
operator|.
name|wi_src_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame
operator|.
name|wi_type
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_type
argument_list|,
name|ETHER_TYPE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|WI_802_11_OFFSET
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|+
literal|2
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rx_frame
operator|.
name|wi_dat_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
operator|>
name|MCLBYTES
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"oversized packet received "
literal|"(wi_dat_len=%d, wi_status=0x%x)\n"
argument_list|,
name|rx_frame
operator|.
name|wi_dat_len
argument_list|,
name|rx_frame
operator|.
name|wi_status
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|rx_frame
operator|.
name|wi_dat_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|WI_802_3_OFFSET
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|+
literal|2
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* Receive packet. */
ifdef|#
directive|ifdef
name|WICACHE
name|wi_cache_store
argument_list|(
name|sc
argument_list|,
name|eh
argument_list|,
name|m
argument_list|,
name|rx_frame
operator|.
name|wi_q_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wi_txeof
parameter_list|(
name|sc
parameter_list|,
name|status
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|WI_EV_TX_EXC
condition|)
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
else|else
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_inquire
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|sc
operator|->
name|wi_stat_ch
operator|=
name|timeout
argument_list|(
name|wi_inquire
argument_list|,
name|sc
argument_list|,
name|hz
operator|*
literal|60
argument_list|)
expr_stmt|;
comment|/* Don't do this while we're transmitting */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
return|return;
name|WI_LOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_INQUIRE
argument_list|,
name|WI_INFO_COUNTERS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_update_stats
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|wi_ltv_gen
name|gen
decl_stmt|;
name|u_int16_t
name|id
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int32_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|u_int16_t
name|t
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_INFO_FID
argument_list|)
expr_stmt|;
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gen
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * if we just got our scan results, copy it over into the scan buffer 	 * so we can return it to anyone that asks for it. (add a little 	 * compatibility with the prism2 scanning mechanism) 	 */
if|if
condition|(
name|gen
operator|.
name|wi_type
operator|==
name|WI_INFO_SCAN_RESULTS
condition|)
block|{
name|sc
operator|->
name|wi_scanbuf_len
operator|=
name|gen
operator|.
name|wi_len
expr_stmt|;
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|4
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|wi_scanbuf
argument_list|,
name|sc
operator|->
name|wi_scanbuf_len
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|gen
operator|.
name|wi_type
operator|!=
name|WI_INFO_COUNTERS
condition|)
return|return;
name|len
operator|=
operator|(
name|gen
operator|.
name|wi_len
operator|-
literal|1
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_stats
argument_list|)
operator|/
literal|4
operator|)
condition|?
name|gen
operator|.
name|wi_len
operator|-
literal|1
else|:
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_stats
argument_list|)
operator|/
literal|4
expr_stmt|;
name|ptr
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_stats
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WI_HERMES_STATS_WAR
if|if
condition|(
name|t
operator|>
literal|0xF000
condition|)
name|t
operator|=
operator|~
name|t
operator|&
literal|0xFFFF
expr_stmt|;
endif|#
directive|endif
name|ptr
index|[
name|i
index|]
operator|+=
name|t
expr_stmt|;
block|}
name|ifp
operator|->
name|if_collisions
operator|=
name|sc
operator|->
name|wi_stats
operator|.
name|wi_tx_single_retries
operator|+
name|sc
operator|->
name|wi_stats
operator|.
name|wi_tx_multi_retries
operator|+
name|sc
operator|->
name|wi_stats
operator|.
name|wi_tx_retry_limit
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_intr
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int16_t
name|status
decl_stmt|;
name|int
name|s
decl_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
operator|||
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Disable interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_STAT
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
operator|~
name|WI_INTRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|WI_EV_RX
condition|)
block|{
name|wi_rxeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_RX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_TX
condition|)
block|{
name|wi_txeof
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_TX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_ALLOC
condition|)
block|{
name|int
name|id
decl_stmt|;
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_ALLOC_FID
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|sc
operator|->
name|wi_tx_data_id
condition|)
name|wi_txeof
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_INFO
condition|)
block|{
name|wi_update_stats
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_INFO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_TX_EXC
condition|)
block|{
name|wi_txeof
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_TX_EXC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_INFO_DROP
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_INFO_DROP
argument_list|)
expr_stmt|;
block|}
comment|/* Re-enable interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
name|WI_INTRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
block|{
name|wi_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_cmd
parameter_list|(
name|sc
parameter_list|,
name|cmd
parameter_list|,
name|val0
parameter_list|,
name|val1
parameter_list|,
name|val2
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|val0
decl_stmt|;
name|int
name|val1
decl_stmt|;
name|int
name|val2
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|s
init|=
literal|0
decl_stmt|;
specifier|static
specifier|volatile
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|panic
argument_list|(
literal|"Hey partner, hold on there!"
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
comment|/* wait for the busy bit to clear */
for|for
control|(
name|i
operator|=
literal|500
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* 5s */
if|if
condition|(
operator|!
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_COMMAND
argument_list|)
operator|&
name|WI_CMD_BUSY
operator|)
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* 10 m sec */
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"owi_cmd: busy bit won't clear.\n"
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_PARAM0
argument_list|,
name|val0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_PARAM1
argument_list|,
name|val1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_PARAM2
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WI_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Wait for 'command complete' bit to be 		 * set in the event status register. 		 */
name|s
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&
name|WI_EV_CMD
condition|)
block|{
comment|/* Ack the event and read result code. */
name|s
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_STATUS
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_CMD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|foo
if|if
condition|(
operator|(
name|s
operator|&
name|WI_CMD_CODE_MASK
operator|)
operator|!=
operator|(
name|cmd
operator|&
name|WI_CMD_CODE_MASK
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|s
operator|&
name|WI_STAT_CMD_RESULT
condition|)
block|{
name|count
operator|--
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
break|break;
block|}
name|DELAY
argument_list|(
name|WI_DELAY
argument_list|)
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|WI_TIMEOUT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"timeout in wi_cmd 0x%04x; event status 0x%04x\n"
argument_list|,
name|cmd
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
define|#
directive|define
name|WI_INIT_TRIES
value|3
name|int
name|i
decl_stmt|;
name|int
name|tries
decl_stmt|;
name|tries
operator|=
name|WI_INIT_TRIES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_INI
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
name|WI_DELAY
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_enabled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|tries
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"init failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
comment|/* Calibrate timer. */
name|WI_SETVAL
argument_list|(
name|WI_RID_TICK_TIME
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Read an LTV record from the NIC.  */
end_comment

begin_function
specifier|static
name|int
name|wi_read_record
parameter_list|(
name|sc
parameter_list|,
name|ltv
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_ltv_gen
modifier|*
name|ltv
decl_stmt|;
block|{
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|code
decl_stmt|;
name|struct
name|wi_ltv_gen
modifier|*
name|oltv
decl_stmt|;
name|oltv
operator|=
name|ltv
expr_stmt|;
comment|/* Tell the NIC to enter record read mode. */
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_ACCESS
operator||
name|WI_ACCESS_READ
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Seek to the record. */
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|,
literal|0
argument_list|,
name|WI_BAP1
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* 	 * Read the length and record type and make sure they 	 * match what we expect (this verifies that we have enough 	 * room to hold all of the returned data). 	 */
name|len
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|ltv
operator|->
name|wi_len
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|code
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|ltv
operator|->
name|wi_type
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|ltv
operator|->
name|wi_len
operator|=
name|len
expr_stmt|;
name|ltv
operator|->
name|wi_type
operator|=
name|code
expr_stmt|;
comment|/* Now read the data. */
name|ptr
operator|=
operator|&
name|ltv
operator|->
name|wi_val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ltv
operator|->
name|wi_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|ptr
index|[
name|i
index|]
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltv
operator|->
name|wi_type
operator|==
name|WI_RID_PORTTYPE
operator|&&
name|sc
operator|->
name|wi_ptype
operator|==
name|WI_PORTTYPE_IBSS
operator|&&
name|ltv
operator|->
name|wi_val
operator|==
name|sc
operator|->
name|wi_ibss_port
condition|)
block|{
comment|/* 		 * Convert vendor IBSS port type to WI_PORTTYPE_IBSS. 		 * Since Lucent uses port type 1 for BSS *and* IBSS we 		 * have to rely on wi_ptype to distinguish this for us. 		 */
name|ltv
operator|->
name|wi_val
operator|=
name|htole16
argument_list|(
name|WI_PORTTYPE_IBSS
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Same as read, except we inject data instead of reading it.  */
end_comment

begin_function
specifier|static
name|int
name|wi_write_record
parameter_list|(
name|sc
parameter_list|,
name|ltv
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_ltv_gen
modifier|*
name|ltv
decl_stmt|;
block|{
name|uint16_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|wi_ltv_gen
name|p2ltv
decl_stmt|;
if|if
condition|(
name|ltv
operator|->
name|wi_type
operator|==
name|WI_RID_PORTTYPE
operator|&&
name|le16toh
argument_list|(
name|ltv
operator|->
name|wi_val
argument_list|)
operator|==
name|WI_PORTTYPE_IBSS
condition|)
block|{
comment|/* Convert WI_PORTTYPE_IBSS to vendor IBSS port type. */
name|p2ltv
operator|.
name|wi_type
operator|=
name|WI_RID_PORTTYPE
expr_stmt|;
name|p2ltv
operator|.
name|wi_len
operator|=
literal|2
expr_stmt|;
name|p2ltv
operator|.
name|wi_val
operator|=
name|sc
operator|->
name|wi_ibss_port
expr_stmt|;
name|ltv
operator|=
operator|&
name|p2ltv
expr_stmt|;
block|}
else|else
block|{
comment|/* LUCENT */
switch|switch
condition|(
name|ltv
operator|->
name|wi_type
condition|)
block|{
case|case
name|WI_RID_TX_RATE
case|:
switch|switch
condition|(
name|ltv
operator|->
name|wi_val
condition|)
block|{
case|case
literal|1
case|:
name|ltv
operator|->
name|wi_val
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* 1Mb/s fixed */
case|case
literal|2
case|:
name|ltv
operator|->
name|wi_val
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* 2Mb/s fixed */
case|case
literal|3
case|:
name|ltv
operator|->
name|wi_val
operator|=
literal|3
expr_stmt|;
break|break;
comment|/* 11Mb/s auto */
case|case
literal|5
case|:
name|ltv
operator|->
name|wi_val
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* 5.5Mb/s fixed */
case|case
literal|6
case|:
name|ltv
operator|->
name|wi_val
operator|=
literal|6
expr_stmt|;
break|break;
comment|/* 2Mb/s auto */
case|case
literal|7
case|:
name|ltv
operator|->
name|wi_val
operator|=
literal|7
expr_stmt|;
break|break;
comment|/* 5.5Mb/s auto */
case|case
literal|11
case|:
name|ltv
operator|->
name|wi_val
operator|=
literal|5
expr_stmt|;
break|break;
comment|/* 11Mb/s fixed */
default|default:
return|return
name|EINVAL
return|;
block|}
case|case
name|WI_RID_TX_CRYPT_KEY
case|:
if|if
condition|(
name|ltv
operator|->
name|wi_val
operator|>
name|WI_NLTV_KEYS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
block|}
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|,
literal|0
argument_list|,
name|WI_BAP1
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|,
name|ltv
operator|->
name|wi_len
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|&
name|ltv
operator|->
name|wi_val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ltv
operator|->
name|wi_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_ACCESS
operator||
name|WI_ACCESS_WRITE
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_seek
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|chan
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|,
name|chan
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|selreg
decl_stmt|,
name|offreg
decl_stmt|;
name|int
name|status
decl_stmt|;
switch|switch
condition|(
name|chan
condition|)
block|{
case|case
name|WI_BAP0
case|:
name|selreg
operator|=
name|WI_SEL0
expr_stmt|;
name|offreg
operator|=
name|WI_OFF0
expr_stmt|;
break|break;
case|case
name|WI_BAP1
case|:
name|selreg
operator|=
name|WI_SEL1
expr_stmt|;
name|offreg
operator|=
name|WI_OFF1
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"invalid data path: %x\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|selreg
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|offreg
argument_list|,
name|off
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WI_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|offreg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
operator|(
name|WI_OFF_BUSY
operator||
name|WI_OFF_ERR
operator|)
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
name|WI_DELAY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|WI_TIMEOUT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"timeout in wi_seek to %x/%x; last status %x\n"
argument_list|,
name|id
argument_list|,
name|off
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_read_data
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|off
argument_list|,
name|WI_BAP1
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|ptr
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|ptr
index|[
name|i
index|]
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * According to the comments in the HCF Light code, there is a bug in  * the Hermes (or possibly in certain Hermes firmware revisions) where  * the chip's internal autoincrement counter gets thrown off during  * data writes: the autoincrement is missed, causing one data word to  * be overwritten and subsequent words to be written to the wrong memory  * locations. The end result is that we could end up transmitting bogus  * frames without realizing it. The workaround for this is to write a  * couple of extra guard words after the end of the transfer, then  * attempt to read then back. If we fail to locate the guard words where  * we expect them, we preform the transfer over again.  */
end_comment

begin_function
specifier|static
name|int
name|wi_write_data
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|WI_HERMES_AUTOINC_WAR
name|int
name|retries
decl_stmt|;
name|retries
operator|=
literal|512
expr_stmt|;
name|again
label|:
endif|#
directive|endif
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|off
argument_list|,
name|WI_BAP0
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|ptr
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|len
operator|/
literal|2
operator|)
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WI_HERMES_AUTOINC_WAR
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|,
literal|0x1234
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|,
literal|0x5678
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|off
operator|+
name|len
argument_list|,
name|WI_BAP0
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|)
operator|!=
literal|0x1234
operator|||
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|)
operator|!=
literal|0x5678
condition|)
block|{
if|if
condition|(
operator|--
name|retries
operator|>=
literal|0
condition|)
goto|goto
name|again
goto|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"owi_write_data device timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a region of memory inside the NIC and zero  * it out.  */
end_comment

begin_function
specifier|static
name|int
name|wi_alloc_nicmem
parameter_list|(
name|sc
parameter_list|,
name|len
parameter_list|,
name|id
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
modifier|*
name|id
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_ALLOC_MEM
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate %d bytes on NIC\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WI_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_STAT
argument_list|)
operator|&
name|WI_EV_ALLOC
condition|)
break|break;
name|DELAY
argument_list|(
name|WI_DELAY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|WI_TIMEOUT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"time out allocating memory on card\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_ALLOC
argument_list|)
expr_stmt|;
operator|*
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_ALLOC_FID
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
operator|*
name|id
argument_list|,
literal|0
argument_list|,
name|WI_BAP0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"seek failed while allocating memory on card\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_setmulti
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|wi_ltv_mcast
name|mcast
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mcast
argument_list|,
sizeof|sizeof
argument_list|(
name|mcast
argument_list|)
argument_list|)
expr_stmt|;
name|mcast
operator|.
name|wi_type
operator|=
name|WI_RID_MCAST_LIST
expr_stmt|;
name|mcast
operator|.
name|wi_len
operator|=
operator|(
literal|3
operator|*
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|||
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|mcast
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|i
operator|<
literal|16
condition|)
block|{
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mcast
operator|.
name|wi_mcast
index|[
name|i
index|]
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mcast
argument_list|,
sizeof|sizeof
argument_list|(
name|mcast
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mcast
operator|.
name|wi_len
operator|=
operator|(
name|i
operator|*
literal|3
operator|)
operator|+
literal|1
expr_stmt|;
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|mcast
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_setdef
parameter_list|(
name|sc
parameter_list|,
name|wreq
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_req
modifier|*
name|wreq
decl_stmt|;
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
switch|switch
condition|(
name|wreq
operator|->
name|wi_type
condition|)
block|{
case|case
name|WI_RID_MAC_NODE
case|:
name|ifa
operator|=
name|ifaddr_byindex
argument_list|(
name|ifp
operator|->
name|if_index
argument_list|)
expr_stmt|;
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|IFP2ENADDR
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_PORTTYPE
case|:
name|sc
operator|->
name|wi_ptype
operator|=
name|le16toh
argument_list|(
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_TX_RATE
case|:
name|sc
operator|->
name|wi_tx_rate
operator|=
name|le16toh
argument_list|(
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_MAX_DATALEN
case|:
name|sc
operator|->
name|wi_max_data_len
operator|=
name|le16toh
argument_list|(
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_RTS_THRESH
case|:
name|sc
operator|->
name|wi_rts_thresh
operator|=
name|le16toh
argument_list|(
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_SYSTEM_SCALE
case|:
name|sc
operator|->
name|wi_ap_density
operator|=
name|le16toh
argument_list|(
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_CREATE_IBSS
case|:
name|sc
operator|->
name|wi_create_ibss
operator|=
name|le16toh
argument_list|(
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_OWN_CHNL
case|:
name|sc
operator|->
name|wi_channel
operator|=
name|le16toh
argument_list|(
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_NODENAME
case|:
name|bzero
argument_list|(
name|sc
operator|->
name|wi_node_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_node_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|wi_node_name
argument_list|,
literal|30
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_DESIRED_SSID
case|:
name|bzero
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|wi_net_name
argument_list|,
literal|30
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_OWN_SSID
case|:
name|bzero
argument_list|(
name|sc
operator|->
name|wi_ibss_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_ibss_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|wi_ibss_name
argument_list|,
literal|30
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_PM_ENABLED
case|:
name|sc
operator|->
name|wi_pm_enabled
operator|=
name|le16toh
argument_list|(
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_MICROWAVE_OVEN
case|:
name|sc
operator|->
name|wi_mor_enabled
operator|=
name|le16toh
argument_list|(
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_MAX_SLEEP
case|:
name|sc
operator|->
name|wi_max_sleep
operator|=
name|le16toh
argument_list|(
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_CNFAUTHMODE
case|:
name|sc
operator|->
name|wi_authtype
operator|=
name|le16toh
argument_list|(
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_ROAMING_MODE
case|:
name|sc
operator|->
name|wi_roaming
operator|=
name|le16toh
argument_list|(
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_ENCRYPTION
case|:
name|sc
operator|->
name|wi_use_wep
operator|=
name|le16toh
argument_list|(
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_TX_CRYPT_KEY
case|:
name|sc
operator|->
name|wi_tx_key
operator|=
name|le16toh
argument_list|(
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_DEFLT_CRYPT_KEYS
case|:
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wreq
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_keys
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_ltv_keys
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Reinitialize WaveLAN. */
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|s
decl_stmt|;
name|uint16_t
name|mif
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|u_int8_t
name|tmpkey
index|[
literal|14
index|]
decl_stmt|;
name|char
name|tmpssid
index|[
name|IEEE80211_NWID_LEN
index|]
decl_stmt|;
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_req
name|wreq
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|ieee80211req
modifier|*
name|ireq
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|ireq
operator|=
operator|(
expr|struct
name|ieee80211req
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * Can't do promisc and hostap at the same time.  If all that's 		 * changing is the promisc flag, try to short-circuit a call to 		 * wi_init() by just setting PROMISC in the hardware. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|&&
operator|!
operator|(
name|sc
operator|->
name|wi_if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
name|WI_SETVAL
argument_list|(
name|WI_RID_PROMISC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|sc
operator|->
name|wi_if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|WI_SETVAL
argument_list|(
name|WI_RID_PROMISC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|owi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|wi_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|wi_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCGWAVELAN
case|:
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|wreq
argument_list|,
sizeof|sizeof
argument_list|(
name|wreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|wreq
operator|.
name|wi_len
operator|>
name|WI_MAX_DATALEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Don't show WEP keys to non-root users. */
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_DEFLT_CRYPT_KEYS
operator|&&
name|suser
argument_list|(
name|td
argument_list|)
condition|)
break|break;
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_IFACE_STATS
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_stats
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|.
name|wi_val
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_stats
argument_list|)
argument_list|)
expr_stmt|;
name|wreq
operator|.
name|wi_len
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_stats
argument_list|)
operator|/
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_DEFLT_CRYPT_KEYS
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_keys
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_ltv_keys
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WICACHE
elseif|else
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_ZERO_CACHE
condition|)
block|{
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|sc
operator|->
name|wi_sigitems
operator|=
name|sc
operator|->
name|wi_nextitem
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_READ_CACHE
condition|)
block|{
name|char
modifier|*
name|pt
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|.
name|wi_val
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_sigitems
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
name|wreq
operator|.
name|wi_len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|/
literal|2
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_sigcache
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_sigcache
argument_list|)
operator|*
name|sc
operator|->
name|wi_sigitems
argument_list|)
expr_stmt|;
name|wreq
operator|.
name|wi_len
operator|+=
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|wi_sigcache
argument_list|)
operator|*
name|sc
operator|->
name|wi_sigitems
operator|)
operator|/
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_PROCFRAME
condition|)
block|{
name|wreq
operator|.
name|wi_len
operator|=
literal|2
expr_stmt|;
name|wreq
operator|.
name|wi_val
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|wi_procframe
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_SCAN_RES
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wreq
operator|.
name|wi_val
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|wi_scanbuf
argument_list|,
name|sc
operator|->
name|wi_scanbuf_len
operator|*
literal|2
argument_list|)
expr_stmt|;
name|wreq
operator|.
name|wi_len
operator|=
name|sc
operator|->
name|wi_scanbuf_len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_MIF
condition|)
block|{
name|mif
operator|=
name|wreq
operator|.
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
name|error
operator|=
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_READMIF
argument_list|,
name|mif
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_RESP0
argument_list|)
expr_stmt|;
name|wreq
operator|.
name|wi_len
operator|=
literal|2
expr_stmt|;
name|wreq
operator|.
name|wi_val
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|wreq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|wreq
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|wreq
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSWAVELAN
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|wreq
argument_list|,
sizeof|sizeof
argument_list|(
name|wreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|wreq
operator|.
name|wi_len
operator|>
name|WI_MAX_DATALEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_IFACE_STATS
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_PROCFRAME
condition|)
block|{
name|sc
operator|->
name|wi_procframe
operator|=
name|wreq
operator|.
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
comment|/* 		 * if we're getting a scan request from a wavelan card 		 * (non-prism2), send out a cmd_inquire to the card to scan 		 * results for the scan will be received through the info 		 * interrupt handler. otherwise the scan request can be 		 * directly handled by a prism2 card's rid interface. 		 */
block|}
elseif|else
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_SCAN_REQ
condition|)
block|{
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_INQUIRE
argument_list|,
name|WI_INFO_SCAN_RESULTS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_MIF
condition|)
block|{
name|mif
operator|=
name|wreq
operator|.
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
name|val
operator|=
name|wreq
operator|.
name|wi_val
index|[
literal|1
index|]
expr_stmt|;
name|error
operator|=
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_WRITEMIF
argument_list|,
name|mif
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|wreq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|wi_setdef
argument_list|(
name|sc
argument_list|,
operator|&
name|wreq
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCG80211
case|:
switch|switch
condition|(
name|ireq
operator|->
name|i_type
condition|)
block|{
case|case
name|IEEE80211_IOC_SSID
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|==
operator|-
literal|1
condition|)
block|{
name|bzero
argument_list|(
name|tmpssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|error
operator|=
name|wi_get_cur_ssid
argument_list|(
name|sc
argument_list|,
name|tmpssid
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
name|copyout
argument_list|(
name|tmpssid
argument_list|,
name|ireq
operator|->
name|i_data
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|ireq
operator|->
name|i_len
operator|=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|copyout
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|,
name|ireq
operator|->
name|i_data
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|ireq
operator|->
name|i_len
operator|=
name|IEEE80211_NWID_LEN
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_NUMSSIDS
case|:
name|ireq
operator|->
name|i_val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_WEP
case|:
if|if
condition|(
operator|!
name|sc
operator|->
name|wi_has_wep
condition|)
block|{
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_WEP_NOSUP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|wi_use_wep
condition|)
block|{
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_WEP_MIXED
expr_stmt|;
block|}
else|else
block|{
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_WEP_OFF
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IEEE80211_IOC_WEPKEY
case|:
if|if
condition|(
operator|!
name|sc
operator|->
name|wi_has_wep
operator|||
name|ireq
operator|->
name|i_val
operator|<
literal|0
operator|||
name|ireq
operator|->
name|i_val
operator|>
literal|3
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|sc
operator|->
name|wi_keys
operator|.
name|wi_keys
index|[
name|ireq
operator|->
name|i_val
index|]
operator|.
name|wi_keylen
expr_stmt|;
if|if
condition|(
name|suser
argument_list|(
name|td
argument_list|)
condition|)
name|bcopy
argument_list|(
name|sc
operator|->
name|wi_keys
operator|.
name|wi_keys
index|[
name|ireq
operator|->
name|i_val
index|]
operator|.
name|wi_keydat
argument_list|,
name|tmpkey
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|bzero
argument_list|(
name|tmpkey
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ireq
operator|->
name|i_len
operator|=
name|len
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|tmpkey
argument_list|,
name|ireq
operator|->
name|i_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_NUMWEPKEYS
case|:
if|if
condition|(
operator|!
name|sc
operator|->
name|wi_has_wep
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|ireq
operator|->
name|i_val
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_WEPTXKEY
case|:
if|if
condition|(
operator|!
name|sc
operator|->
name|wi_has_wep
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|ireq
operator|->
name|i_val
operator|=
name|sc
operator|->
name|wi_tx_key
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_AUTHMODE
case|:
name|ireq
operator|->
name|i_val
operator|=
name|sc
operator|->
name|wi_authmode
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_STATIONNAME
case|:
name|error
operator|=
name|copyout
argument_list|(
name|sc
operator|->
name|wi_node_name
argument_list|,
name|ireq
operator|->
name|i_data
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|ireq
operator|->
name|i_len
operator|=
name|IEEE80211_NWID_LEN
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_CHANNEL
case|:
name|wreq
operator|.
name|wi_type
operator|=
name|WI_RID_CURRENT_CHAN
expr_stmt|;
name|wreq
operator|.
name|wi_len
operator|=
name|WI_MAX_DATALEN
expr_stmt|;
if|if
condition|(
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|wreq
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|ireq
operator|->
name|i_val
operator|=
name|wreq
operator|.
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_IOC_POWERSAVE
case|:
if|if
condition|(
name|sc
operator|->
name|wi_pm_enabled
condition|)
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_POWERSAVE_ON
expr_stmt|;
else|else
name|ireq
operator|->
name|i_val
operator|=
name|IEEE80211_POWERSAVE_OFF
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_POWERSAVESLEEP
case|:
name|ireq
operator|->
name|i_val
operator|=
name|sc
operator|->
name|wi_max_sleep
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SIOCS80211
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|ireq
operator|->
name|i_type
condition|)
block|{
case|case
name|IEEE80211_IOC_SSID
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|!=
literal|0
operator|||
name|ireq
operator|->
name|i_len
operator|>
name|IEEE80211_NWID_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* We set both of them */
name|bzero
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|ireq
operator|->
name|i_data
argument_list|,
name|sc
operator|->
name|wi_net_name
argument_list|,
name|ireq
operator|->
name|i_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|,
name|sc
operator|->
name|wi_ibss_name
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_WEP
case|:
comment|/* 			 * These cards only support one mode so 			 * we just turn wep on what ever is 			 * passed in if it's not OFF. 			 */
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|==
name|IEEE80211_WEP_OFF
condition|)
block|{
name|sc
operator|->
name|wi_use_wep
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|wi_use_wep
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_IOC_WEPKEY
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|<
literal|0
operator|||
name|ireq
operator|->
name|i_val
operator|>
literal|3
operator|||
name|ireq
operator|->
name|i_len
operator|>
literal|13
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|wi_keys
operator|.
name|wi_keys
index|[
name|ireq
operator|->
name|i_val
index|]
operator|.
name|wi_keydat
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|ireq
operator|->
name|i_data
argument_list|,
name|sc
operator|->
name|wi_keys
operator|.
name|wi_keys
index|[
name|ireq
operator|->
name|i_val
index|]
operator|.
name|wi_keydat
argument_list|,
name|ireq
operator|->
name|i_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|sc
operator|->
name|wi_keys
operator|.
name|wi_keys
index|[
name|ireq
operator|->
name|i_val
index|]
operator|.
name|wi_keylen
operator|=
name|ireq
operator|->
name|i_len
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_WEPTXKEY
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|<
literal|0
operator|||
name|ireq
operator|->
name|i_val
operator|>
literal|3
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|wi_tx_key
operator|=
name|ireq
operator|->
name|i_val
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_AUTHMODE
case|:
name|sc
operator|->
name|wi_authmode
operator|=
name|ireq
operator|->
name|i_val
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_STATIONNAME
case|:
if|if
condition|(
name|ireq
operator|->
name|i_len
operator|>
literal|32
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|wi_node_name
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|ireq
operator|->
name|i_data
argument_list|,
name|sc
operator|->
name|wi_node_name
argument_list|,
name|ireq
operator|->
name|i_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_CHANNEL
case|:
comment|/* 			 * The actual range is 1-14, but if you 			 * set it to 0 you get the default. So 			 * we let that work too. 			 */
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|<
literal|0
operator|||
name|ireq
operator|->
name|i_val
operator|>
literal|14
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|wi_channel
operator|=
name|ireq
operator|->
name|i_val
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_POWERSAVE
case|:
switch|switch
condition|(
name|ireq
operator|->
name|i_val
condition|)
block|{
case|case
name|IEEE80211_POWERSAVE_OFF
case|:
name|sc
operator|->
name|wi_pm_enabled
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IEEE80211_POWERSAVE_ON
case|:
name|sc
operator|->
name|wi_pm_enabled
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IEEE80211_IOC_POWERSAVESLEEP
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|wi_max_sleep
operator|=
name|ireq
operator|->
name|i_val
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Reinitialize WaveLAN. */
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|wi_ltv_macaddr
name|mac
decl_stmt|;
name|int
name|id
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
block|{
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|owi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wi_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Program max data length. */
name|WI_SETVAL
argument_list|(
name|WI_RID_MAX_DATALEN
argument_list|,
name|sc
operator|->
name|wi_max_data_len
argument_list|)
expr_stmt|;
comment|/* Set the port type. */
name|WI_SETVAL
argument_list|(
name|WI_RID_PORTTYPE
argument_list|,
name|sc
operator|->
name|wi_ptype
argument_list|)
expr_stmt|;
comment|/* Enable/disable IBSS creation. */
name|WI_SETVAL
argument_list|(
name|WI_RID_CREATE_IBSS
argument_list|,
name|sc
operator|->
name|wi_create_ibss
argument_list|)
expr_stmt|;
comment|/* Program the RTS/CTS threshold. */
name|WI_SETVAL
argument_list|(
name|WI_RID_RTS_THRESH
argument_list|,
name|sc
operator|->
name|wi_rts_thresh
argument_list|)
expr_stmt|;
comment|/* Program the TX rate */
name|WI_SETVAL
argument_list|(
name|WI_RID_TX_RATE
argument_list|,
name|sc
operator|->
name|wi_tx_rate
argument_list|)
expr_stmt|;
comment|/* Access point density */
name|WI_SETVAL
argument_list|(
name|WI_RID_SYSTEM_SCALE
argument_list|,
name|sc
operator|->
name|wi_ap_density
argument_list|)
expr_stmt|;
comment|/* Power Management Enabled */
name|WI_SETVAL
argument_list|(
name|WI_RID_PM_ENABLED
argument_list|,
name|sc
operator|->
name|wi_pm_enabled
argument_list|)
expr_stmt|;
comment|/* Power Managment Max Sleep */
name|WI_SETVAL
argument_list|(
name|WI_RID_MAX_SLEEP
argument_list|,
name|sc
operator|->
name|wi_max_sleep
argument_list|)
expr_stmt|;
comment|/* Roaming type */
name|WI_SETVAL
argument_list|(
name|WI_RID_ROAMING_MODE
argument_list|,
name|sc
operator|->
name|wi_roaming
argument_list|)
expr_stmt|;
comment|/* Specify the IBSS name */
name|WI_SETSTR
argument_list|(
name|WI_RID_OWN_SSID
argument_list|,
name|sc
operator|->
name|wi_ibss_name
argument_list|)
expr_stmt|;
comment|/* Specify the network name */
name|WI_SETSTR
argument_list|(
name|WI_RID_DESIRED_SSID
argument_list|,
name|sc
operator|->
name|wi_net_name
argument_list|)
expr_stmt|;
comment|/* Specify the frequency to use */
name|WI_SETVAL
argument_list|(
name|WI_RID_OWN_CHNL
argument_list|,
name|sc
operator|->
name|wi_channel
argument_list|)
expr_stmt|;
comment|/* Program the nodename. */
name|WI_SETSTR
argument_list|(
name|WI_RID_NODENAME
argument_list|,
name|sc
operator|->
name|wi_node_name
argument_list|)
expr_stmt|;
comment|/* Specify the authentication mode. */
name|WI_SETVAL
argument_list|(
name|WI_RID_CNFAUTHMODE
argument_list|,
name|sc
operator|->
name|wi_authmode
argument_list|)
expr_stmt|;
comment|/* Set our MAC address. */
name|mac
operator|.
name|wi_len
operator|=
literal|4
expr_stmt|;
name|mac
operator|.
name|wi_type
operator|=
name|WI_RID_MAC_NODE
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|IFP2ENADDR
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mac
operator|.
name|wi_mac_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|mac
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize promisc mode. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|WI_SETVAL
argument_list|(
name|WI_RID_PROMISC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|WI_SETVAL
argument_list|(
name|WI_RID_PROMISC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure WEP. */
if|if
condition|(
name|sc
operator|->
name|wi_has_wep
condition|)
block|{
name|WI_SETVAL
argument_list|(
name|WI_RID_ENCRYPTION
argument_list|,
name|sc
operator|->
name|wi_use_wep
argument_list|)
expr_stmt|;
name|WI_SETVAL
argument_list|(
name|WI_RID_TX_CRYPT_KEY
argument_list|,
name|sc
operator|->
name|wi_tx_key
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_keys
operator|.
name|wi_len
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|wi_ltv_keys
argument_list|)
operator|/
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|wi_keys
operator|.
name|wi_type
operator|=
name|WI_RID_DEFLT_CRYPT_KEYS
expr_stmt|;
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_keys
argument_list|)
expr_stmt|;
block|}
comment|/* Set multicast filter. */
name|wi_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable desired port */
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_ENABLE
operator||
name|sc
operator|->
name|wi_portnum
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_alloc_nicmem
argument_list|(
name|sc
argument_list|,
name|ETHER_MAX_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
operator|+
literal|8
argument_list|,
operator|&
name|id
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"tx buffer allocation failed\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_tx_data_id
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|wi_alloc_nicmem
argument_list|(
name|sc
argument_list|,
name|ETHER_MAX_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
operator|+
literal|8
argument_list|,
operator|&
name|id
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"mgmt. buffer allocation failed\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_tx_mgmt_id
operator|=
name|id
expr_stmt|;
comment|/* enable interrupts */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
name|WI_INTRS
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|wi_stat_ch
operator|=
name|timeout
argument_list|(
name|wi_inquire
argument_list|,
name|sc
argument_list|,
name|hz
operator|*
literal|60
argument_list|)
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|wi_frame
name|tx_frame
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|s
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
block|{
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
block|{
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_frame
argument_list|)
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_frame_ctl
operator|=
name|htole16
argument_list|(
name|WI_FTYPE_DATA
argument_list|)
expr_stmt|;
name|id
operator|=
name|sc
operator|->
name|wi_tx_data_id
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Use RFC1042 encoding for IP and ARP datagrams, 	 * 802.3 for anything else. 	 */
if|if
condition|(
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|>
name|ETHER_MAX_LEN
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
operator|.
name|wi_addr1
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
operator|.
name|wi_addr2
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
operator|.
name|wi_dst_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
operator|.
name|wi_src_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_dat_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|WI_SNAPHDR_LEN
expr_stmt|;
name|tx_frame
operator|.
name|wi_dat
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
name|WI_SNAP_WORD0
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_dat
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|WI_SNAP_WORD1
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_len
operator|=
name|htons
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|WI_SNAPHDR_LEN
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_type
operator|=
name|eh
operator|->
name|ether_type
expr_stmt|;
name|m_copydata
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|wi_txbuf
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tx_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|WI_802_11_OFFSET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|wi_txbuf
argument_list|,
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tx_frame
operator|.
name|wi_dat_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|htons
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|WI_SNAPHDR_LEN
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|wi_txbuf
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tx_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|WI_802_3_OFFSET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|wi_txbuf
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there's a BPF listner, bounce a copy of  	 * this frame to him. Also, don't send this to the bpf sniffer  	 * if we're in procframe or monitor sniffing mode. 	 */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|wi_procframe
operator|||
name|sc
operator|->
name|wi_debug
operator|.
name|wi_monitor
operator|)
condition|)
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_TX
operator||
name|WI_RECLAIM
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"xmit failed\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
comment|/* 	 * Set a timeout in case the chip goes out to lunch. 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|owi_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|WI_LOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|wi_inquire
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|wi_stat_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
block|{
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
comment|/* 	 * If the card is gone and the memory port isn't mapped, we will 	 * (hopefully) get 0xffff back from the status read, which is not 	 * a valid status value. 	 */
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_STATUS
argument_list|)
operator|!=
literal|0xffff
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_DISABLE
operator||
name|sc
operator|->
name|wi_portnum
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
name|WI_UNLOCK
argument_list|(
name|sc
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_watchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"watchdog timeout\n"
argument_list|)
expr_stmt|;
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|owi_alloc
parameter_list|(
name|dev
parameter_list|,
name|rid
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_bus_type
operator|!=
name|WI_BUS_PCI_NATIVE
condition|)
block|{
name|sc
operator|->
name|iobase_rid
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|iobase
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|iobase_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
operator|(
literal|1
operator|<<
literal|6
operator|)
argument_list|,
name|rman_make_alignment_flags
argument_list|(
literal|1
operator|<<
literal|6
argument_list|)
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|iobase
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No I/O space?!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|wi_io_addr
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|iobase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mem_rid
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|mem_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mem
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No Mem space on prism2.5?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|wi_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_ACTIVE
operator||
operator|(
operator|(
name|sc
operator|->
name|wi_bus_type
operator|==
name|WI_BUS_PCCARD
operator|)
condition|?
literal|0
else|:
name|RF_SHAREABLE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq
condition|)
block|{
name|owi_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No irq?!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|wi_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|owi_free
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|iobase
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iobase_rid
argument_list|,
name|sc
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|sc
operator|->
name|iobase
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mem
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_rid
argument_list|,
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|owi_shutdown
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|owi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WICACHE
end_ifdef

begin_comment
comment|/* wavelan signal strength cache code.  * store signal/noise/quality on per MAC src basis in  * a small fixed cache.  The cache wraps if> MAX slots  * used.  The cache may be zeroed out to start over.  * Two simple filters exist to reduce computation:  * 1. ip only (literally 0x800) which may be used  * to ignore some packets.  It defaults to ip only.  * it could be used to focus on broadcast, non-IP 802.11 beacons.  * 2. multicast/broadcast only.  This may be used to  * ignore unicast packets and only cache signal strength  * for multicast/broadcast packets (beacons); e.g., Mobile-IP  * beacons and not unicast traffic.  *  * The cache stores (MAC src(index), IP src (major clue), signal,  *	quality, noise)  *  * No apologies for storing IP src here.  It's easy and saves much  * trouble elsewhere.  The cache is assumed to be INET dependent,   * although it need not be.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|documentation
end_ifdef

begin_decl_stmt
name|int
name|wi_sigitems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of cached entries */
end_comment

begin_decl_stmt
name|struct
name|wi_sigcache
name|wi_sigcache
index|[
name|MAXWICACHE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  array of cache entries */
end_comment

begin_decl_stmt
name|int
name|wi_nextitem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  index/# of entries */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* control variables for cache filtering.  Basic idea is  * to reduce cost (e.g., to only Mobile-IP agent beacons  * which are broadcast or multicast).  Still you might  * want to measure signal strength with unicast ping packets  * on a pt. to pt. ant. setup.  */
end_comment

begin_comment
comment|/* set true if you want to limit cache items to broadcast/mcast   * only packets (not unicast).  Useful for mobile-ip beacons which  * are broadcast/multicast at network layer.  Default is all packets  * so ping/unicast will work say with pt. to pt. antennae setup.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wi_cache_mcastonly
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|wi_cache_mcastonly
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|wi_cache_mcastonly
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* set true if you want to limit cache items to IP packets only */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wi_cache_iponly
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|wi_cache_iponly
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|wi_cache_iponly
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Original comments:  * -----------------  * wi_cache_store, per rx packet store signal  * strength in MAC (src) indexed cache.  *  * follows linux driver in how signal strength is computed.  * In ad hoc mode, we use the rx_quality field.   * signal and noise are trimmed to fit in the range from 47..138.  * rx_quality field MSB is signal strength.  * rx_quality field LSB is noise.  * "quality" is (signal - noise) as is log value.  * note: quality CAN be negative.  *   * In BSS mode, we use the RID for communication quality.  * TBD:  BSS mode is currently untested.  *  * Bill's comments:  * ---------------  * Actually, we use the rx_quality field all the time for both "ad-hoc"  * and BSS modes. Why? Because reading an RID is really, really expensive:  * there's a bunch of PIO operations that have to be done to read a record  * from the NIC, and reading the comms quality RID each time a packet is  * received can really hurt performance. We don't have to do this anyway:  * the comms quality field only reflects the values in the rx_quality field  * anyway. The comms quality RID is only meaningful in infrastructure mode,  * but the values it contains are updated based on the rx_quality from  * frames received from the access point.  *  * Also, according to Lucent, the signal strength and noise level values  * can be converted to dBms by subtracting 149, so I've modified the code  * to do that instead of the scaling it did originally.  */
end_comment

begin_function
specifier|static
name|void
name|wi_cache_store
parameter_list|(
name|struct
name|wi_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ether_header
modifier|*
name|eh
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|short
name|rx_quality
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|cache_slot
init|=
literal|0
decl_stmt|;
comment|/* use this cache entry */
specifier|static
name|int
name|wrapindex
init|=
literal|0
decl_stmt|;
comment|/* next "free" cache entry */
name|int
name|sig
decl_stmt|,
name|noise
decl_stmt|;
name|int
name|sawip
init|=
literal|0
decl_stmt|;
comment|/*  	 * filters: 	 * 1. ip only 	 * 2. configurable filter to throw out unicast packets, 	 * keep multicast only. 	 */
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|==
name|ETHERTYPE_IP
operator|)
condition|)
block|{
name|sawip
operator|=
literal|1
expr_stmt|;
block|}
comment|/*  	 * filter for ip packets only  	*/
if|if
condition|(
name|wi_cache_iponly
operator|&&
operator|!
name|sawip
condition|)
block|{
return|return;
block|}
comment|/* 	 *  filter for broadcast/multicast only 	 */
if|if
condition|(
name|wi_cache_mcastonly
operator|&&
operator|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return;
block|}
ifdef|#
directive|ifdef
name|SIGDEBUG
name|printf
argument_list|(
literal|"owi%d: q value %x (MSB=0x%x, LSB=0x%x) \n"
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|,
name|rx_quality
operator|&
literal|0xffff
argument_list|,
name|rx_quality
operator|>>
literal|8
argument_list|,
name|rx_quality
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  find the ip header.  we want to store the ip_src 	 * address.   	 */
if|if
condition|(
name|sawip
condition|)
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * do a linear search for a matching MAC address  	 * in the cache table 	 * . MAC address is 6 bytes, 	 * . var w_nextitem holds total number of entries already cached 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|wi_nextitem
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|wi_sigcache
index|[
name|i
index|]
operator|.
name|macsrc
argument_list|,
literal|6
argument_list|)
condition|)
block|{
comment|/*  			 * Match!, 			 * so we already have this entry, 			 * update the data 			 */
break|break;
block|}
block|}
comment|/* 	 *  did we find a matching mac address? 	 * if yes, then overwrite a previously existing cache entry 	 */
if|if
condition|(
name|i
operator|<
name|sc
operator|->
name|wi_nextitem
condition|)
block|{
name|cache_slot
operator|=
name|i
expr_stmt|;
block|}
comment|/* 	 * else, have a new address entry,so 	 * add this new entry, 	 * if table full, then we need to replace LRU entry 	 */
else|else
block|{
comment|/*  		 * check for space in cache table  		 * note: wi_nextitem also holds number of entries 		 * added in the cache table  		 */
if|if
condition|(
name|sc
operator|->
name|wi_nextitem
operator|<
name|MAXWICACHE
condition|)
block|{
name|cache_slot
operator|=
name|sc
operator|->
name|wi_nextitem
expr_stmt|;
name|sc
operator|->
name|wi_nextitem
operator|++
expr_stmt|;
name|sc
operator|->
name|wi_sigitems
operator|=
name|sc
operator|->
name|wi_nextitem
expr_stmt|;
block|}
comment|/* no space found, so simply wrap with wrap index 		 * and "zap" the next entry 		 */
else|else
block|{
if|if
condition|(
name|wrapindex
operator|==
name|MAXWICACHE
condition|)
block|{
name|wrapindex
operator|=
literal|0
expr_stmt|;
block|}
name|cache_slot
operator|=
name|wrapindex
operator|++
expr_stmt|;
block|}
block|}
comment|/*  	 * invariant: cache_slot now points at some slot 	 * in cache. 	 */
if|if
condition|(
name|cache_slot
operator|<
literal|0
operator|||
name|cache_slot
operator|>=
name|MAXWICACHE
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"owi_cache_store, bad index: %d of "
literal|"[0..%d], gross cache error\n"
argument_list|,
name|cache_slot
argument_list|,
name|MAXWICACHE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  store items in cache 	 *  .ip source address 	 *  .mac src 	 *  .signal, etc. 	 */
if|if
condition|(
name|sawip
condition|)
name|sc
operator|->
name|wi_sigcache
index|[
name|cache_slot
index|]
operator|.
name|ipsrc
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|wi_sigcache
index|[
name|cache_slot
index|]
operator|.
name|macsrc
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|sig
operator|=
operator|(
name|rx_quality
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|noise
operator|=
name|rx_quality
operator|&
literal|0xFF
expr_stmt|;
comment|/* 	 * -149 is Lucent specific to convert to dBm.  Prism2 cards do 	 * things differently, sometimes don't have a noise measurement, 	 * and is firmware dependent :-( 	 */
name|sc
operator|->
name|wi_sigcache
index|[
name|cache_slot
index|]
operator|.
name|signal
operator|=
name|sig
operator|-
literal|149
expr_stmt|;
name|sc
operator|->
name|wi_sigcache
index|[
name|cache_slot
index|]
operator|.
name|noise
operator|=
name|noise
operator|-
literal|149
expr_stmt|;
name|sc
operator|->
name|wi_sigcache
index|[
name|cache_slot
index|]
operator|.
name|quality
operator|=
name|sig
operator|-
name|noise
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|wi_get_cur_ssid
parameter_list|(
name|sc
parameter_list|,
name|ssid
parameter_list|,
name|len
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|ssid
decl_stmt|;
name|int
modifier|*
name|len
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|wi_req
name|wreq
decl_stmt|;
name|wreq
operator|.
name|wi_len
operator|=
name|WI_MAX_DATALEN
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|wi_ptype
condition|)
block|{
case|case
name|WI_PORTTYPE_IBSS
case|:
case|case
name|WI_PORTTYPE_ADHOC
case|:
name|wreq
operator|.
name|wi_type
operator|=
name|WI_RID_CURRENT_SSID
expr_stmt|;
name|error
operator|=
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|wreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|wreq
operator|.
name|wi_val
index|[
literal|0
index|]
operator|>
name|IEEE80211_NWID_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
operator|*
name|len
operator|=
name|wreq
operator|.
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|wreq
operator|.
name|wi_val
index|[
literal|1
index|]
argument_list|,
name|ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_PORTTYPE_BSS
case|:
name|wreq
operator|.
name|wi_type
operator|=
name|WI_RID_COMMQUAL
expr_stmt|;
name|error
operator|=
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|wreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|wreq
operator|.
name|wi_val
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
comment|/* associated */
block|{
name|wreq
operator|.
name|wi_type
operator|=
name|WI_RID_CURRENT_SSID
expr_stmt|;
name|wreq
operator|.
name|wi_len
operator|=
name|WI_MAX_DATALEN
expr_stmt|;
name|error
operator|=
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|wreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|wreq
operator|.
name|wi_val
index|[
literal|0
index|]
operator|>
name|IEEE80211_NWID_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
operator|*
name|len
operator|=
name|wreq
operator|.
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|wreq
operator|.
name|wi_val
index|[
literal|1
index|]
argument_list|,
name|ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|len
operator|=
name|IEEE80211_NWID_LEN
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|,
name|ssid
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_media_change
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|otype
init|=
name|sc
operator|->
name|wi_ptype
decl_stmt|;
name|int
name|orate
init|=
name|sc
operator|->
name|wi_tx_rate
decl_stmt|;
name|int
name|ocreate_ibss
init|=
name|sc
operator|->
name|wi_create_ibss
decl_stmt|;
name|sc
operator|->
name|wi_create_ibss
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_cur
operator|->
name|ifm_media
operator|&
name|IFM_OMASK
condition|)
block|{
case|case
literal|0
case|:
name|sc
operator|->
name|wi_ptype
operator|=
name|WI_PORTTYPE_BSS
expr_stmt|;
break|break;
case|case
name|IFM_IEEE80211_ADHOC
case|:
name|sc
operator|->
name|wi_ptype
operator|=
name|WI_PORTTYPE_ADHOC
expr_stmt|;
break|break;
case|case
name|IFM_IEEE80211_IBSSMASTER
case|:
case|case
name|IFM_IEEE80211_IBSSMASTER
operator||
name|IFM_IEEE80211_IBSS
case|:
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|wi_flags
operator|&
name|WI_FLAGS_HAS_CREATE_IBSS
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|->
name|wi_create_ibss
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|IFM_IEEE80211_IBSS
case|:
name|sc
operator|->
name|wi_ptype
operator|=
name|WI_PORTTYPE_IBSS
expr_stmt|;
break|break;
default|default:
comment|/* Invalid combination. */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_cur
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_IEEE80211_DS1
case|:
name|sc
operator|->
name|wi_tx_rate
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IFM_IEEE80211_DS2
case|:
name|sc
operator|->
name|wi_tx_rate
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|IFM_IEEE80211_DS5
case|:
name|sc
operator|->
name|wi_tx_rate
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|IFM_IEEE80211_DS11
case|:
name|sc
operator|->
name|wi_tx_rate
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|IFM_AUTO
case|:
name|sc
operator|->
name|wi_tx_rate
operator|=
literal|3
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ocreate_ibss
operator|!=
name|sc
operator|->
name|wi_create_ibss
operator|||
name|otype
operator|!=
name|sc
operator|->
name|wi_ptype
operator|||
name|orate
operator|!=
name|sc
operator|->
name|wi_tx_rate
condition|)
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_media_status
parameter_list|(
name|ifp
parameter_list|,
name|imr
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmediareq
modifier|*
name|imr
decl_stmt|;
block|{
name|struct
name|wi_req
name|wreq
decl_stmt|;
name|struct
name|wi_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_tx_rate
operator|==
literal|3
condition|)
block|{
name|imr
operator|->
name|ifm_active
operator|=
name|IFM_IEEE80211
operator||
name|IFM_AUTO
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_ptype
operator|==
name|WI_PORTTYPE_ADHOC
condition|)
name|imr
operator|->
name|ifm_active
operator||=
name|IFM_IEEE80211_ADHOC
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|wi_ptype
operator|==
name|WI_PORTTYPE_IBSS
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|wi_create_ibss
condition|)
name|imr
operator|->
name|ifm_active
operator||=
name|IFM_IEEE80211_IBSSMASTER
expr_stmt|;
else|else
name|imr
operator|->
name|ifm_active
operator||=
name|IFM_IEEE80211_IBSS
expr_stmt|;
block|}
name|wreq
operator|.
name|wi_type
operator|=
name|WI_RID_CUR_TX_RATE
expr_stmt|;
name|wreq
operator|.
name|wi_len
operator|=
name|WI_MAX_DATALEN
expr_stmt|;
if|if
condition|(
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|wreq
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|wreq
operator|.
name|wi_val
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|1
case|:
name|imr
operator|->
name|ifm_active
operator||=
name|IFM_IEEE80211_DS1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|imr
operator|->
name|ifm_active
operator||=
name|IFM_IEEE80211_DS2
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|imr
operator|->
name|ifm_active
operator||=
name|IFM_IEEE80211_DS5
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|imr
operator|->
name|ifm_active
operator||=
name|IFM_IEEE80211_DS11
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|imr
operator|->
name|ifm_active
operator|=
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
block|}
name|imr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_ptype
operator|==
name|WI_PORTTYPE_ADHOC
operator|||
name|sc
operator|->
name|wi_ptype
operator|==
name|WI_PORTTYPE_IBSS
condition|)
comment|/* 		 * XXX: It would be nice if we could give some actually 		 * useful status like whether we joined another IBSS or 		 * created one ourselves. 		 */
name|imr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
else|else
block|{
name|wreq
operator|.
name|wi_type
operator|=
name|WI_RID_COMMQUAL
expr_stmt|;
name|wreq
operator|.
name|wi_len
operator|=
name|WI_MAX_DATALEN
expr_stmt|;
if|if
condition|(
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|wreq
argument_list|)
operator|==
literal|0
operator|&&
name|wreq
operator|.
name|wi_val
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|imr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
block|}
block|}
end_function

end_unit

