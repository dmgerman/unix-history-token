begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: if_stge.c,v 1.32 2005/12/11 12:22:49 christos Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2001 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Jason R. Thorpe.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Device driver for the Sundance Tech. TC9021 10/100/1000  * Ethernet controller.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/stge/if_stgereg.h>
end_include

begin_define
define|#
directive|define
name|STGE_CSUM_FEATURES
value|(CSUM_IP | CSUM_TCP | CSUM_UDP)
end_define

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|stge
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|stge
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|stge
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* "device miibus" required.  See GENERIC if you get errors here. */
end_comment

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_comment
comment|/*  * Devices supported by this driver.  */
end_comment

begin_struct
specifier|static
struct|struct
name|stge_product
block|{
name|uint16_t
name|stge_vendorid
decl_stmt|;
name|uint16_t
name|stge_deviceid
decl_stmt|;
specifier|const
name|char
modifier|*
name|stge_name
decl_stmt|;
block|}
name|stge_products
index|[]
init|=
block|{
block|{
name|VENDOR_SUNDANCETI
block|,
name|DEVICEID_SUNDANCETI_ST1023
block|,
literal|"Sundance ST-1023 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDOR_SUNDANCETI
block|,
name|DEVICEID_SUNDANCETI_ST2021
block|,
literal|"Sundance ST-2021 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDOR_TAMARACK
block|,
name|DEVICEID_TAMARACK_TC9021
block|,
literal|"Tamarack TC9021 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDOR_TAMARACK
block|,
name|DEVICEID_TAMARACK_TC9021_ALT
block|,
literal|"Tamarack TC9021 Gigabit Ethernet"
block|}
block|,
comment|/* 	 * The Sundance sample boards use the Sundance vendor ID, 	 * but the Tamarack product ID. 	 */
block|{
name|VENDOR_SUNDANCETI
block|,
name|DEVICEID_TAMARACK_TC9021
block|,
literal|"Sundance TC9021 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDOR_SUNDANCETI
block|,
name|DEVICEID_TAMARACK_TC9021_ALT
block|,
literal|"Sundance TC9021 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDOR_DLINK
block|,
name|DEVICEID_DLINK_DL4000
block|,
literal|"D-Link DL-4000 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDOR_ANTARES
block|,
name|DEVICEID_ANTARES_TC9021
block|,
literal|"Antares Gigabit Ethernet"
block|}
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|stge_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_encap
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_watchdog
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_init_locked
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_vlan_setup
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_stop
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_start_tx
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_start_rx
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_stop_tx
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_stop_rx
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_reset
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_eeprom_wait
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_read_eeprom
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_stats_update
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_set_filter
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_set_multi
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_link_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|stge_tx_error
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_txeof
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_rxeof
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|stge_discard_rxbuf
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_newbuf
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
end_ifndef

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|stge_fixup_rx
argument_list|(
expr|struct
name|stge_softc
operator|*
argument_list|,
expr|struct
name|mbuf
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|stge_mii_sync
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_mii_send
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_mii_readreg
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|,
name|struct
name|stge_mii_frame
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_mii_writereg
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|,
name|struct
name|stge_mii_frame
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_miibus_readreg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_miibus_writereg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_miibus_statchg
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_dmamap_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_dma_alloc
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_dma_free
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_dma_wait
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stge_init_tx_ring
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stge_init_rx_ring
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_function_decl
specifier|static
name|int
name|stge_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|enum
name|poll_cmd
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|stge_setwol
parameter_list|(
name|struct
name|stge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_int_range
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_stge_rxint_nframe
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_stge_rxint_dmawait
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|stge_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|stge_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|stge_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|stge_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|stge_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|stge_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|stge_resume
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|stge_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|stge_miibus_writereg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|stge_miibus_statchg
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|stge_driver
init|=
block|{
literal|"stge"
block|,
name|stge_methods
block|,
expr|sizeof
operator|(
expr|struct
name|stge_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|stge_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|stge
argument_list|,
name|pci
argument_list|,
name|stge_driver
argument_list|,
name|stge_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|stge
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|stge_res_spec_io
index|[]
init|=
block|{
block|{
name|SYS_RES_IOPORT
block|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_IRQ
block|,
literal|0
block|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|stge_res_spec_mem
index|[]
init|=
block|{
block|{
name|SYS_RES_MEMORY
block|,
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_IRQ
block|,
literal|0
block|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MII_SET
parameter_list|(
name|x
parameter_list|)
define|\
value|CSR_WRITE_1(sc, STGE_PhyCtrl, CSR_READ_1(sc, STGE_PhyCtrl) | (x))
end_define

begin_define
define|#
directive|define
name|MII_CLR
parameter_list|(
name|x
parameter_list|)
define|\
value|CSR_WRITE_1(sc, STGE_PhyCtrl, CSR_READ_1(sc, STGE_PhyCtrl)& ~(x))
end_define

begin_comment
comment|/*  * Sync the PHYs by setting data bit and strobing the clock 32 times.  */
end_comment

begin_function
specifier|static
name|void
name|stge_mii_sync
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|MII_SET
argument_list|(
name|PC_MgmtDir
operator||
name|PC_MgmtData
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|MII_SET
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MII_CLR
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clock a series of bits through the MII.  */
end_comment

begin_function
specifier|static
name|void
name|stge_mii_send
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|bits
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|MII_CLR
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
literal|0x1
operator|<<
operator|(
name|cnt
operator|-
literal|1
operator|)
operator|)
init|;
name|i
condition|;
name|i
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|bits
operator|&
name|i
condition|)
name|MII_SET
argument_list|(
name|PC_MgmtData
argument_list|)
expr_stmt|;
else|else
name|MII_CLR
argument_list|(
name|PC_MgmtData
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MII_CLR
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MII_SET
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read an PHY register through the MII.  */
end_comment

begin_function
specifier|static
name|int
name|stge_mii_readreg
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|stge_mii_frame
modifier|*
name|frame
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ack
decl_stmt|;
comment|/* 	 * Set up frame for RX. 	 */
name|frame
operator|->
name|mii_stdelim
operator|=
name|STGE_MII_STARTDELIM
expr_stmt|;
name|frame
operator|->
name|mii_opcode
operator|=
name|STGE_MII_READOP
expr_stmt|;
name|frame
operator|->
name|mii_turnaround
operator|=
literal|0
expr_stmt|;
name|frame
operator|->
name|mii_data
operator|=
literal|0
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STGE_PhyCtrl
argument_list|,
literal|0
operator||
name|sc
operator|->
name|sc_PhyCtrl
argument_list|)
expr_stmt|;
comment|/*  	 * Turn on data xmit. 	 */
name|MII_SET
argument_list|(
name|PC_MgmtDir
argument_list|)
expr_stmt|;
name|stge_mii_sync
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Send command/address info. 	 */
name|stge_mii_send
argument_list|(
name|sc
argument_list|,
name|frame
operator|->
name|mii_stdelim
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|stge_mii_send
argument_list|(
name|sc
argument_list|,
name|frame
operator|->
name|mii_opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|stge_mii_send
argument_list|(
name|sc
argument_list|,
name|frame
operator|->
name|mii_phyaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|stge_mii_send
argument_list|(
name|sc
argument_list|,
name|frame
operator|->
name|mii_regaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* Turn off xmit. */
name|MII_CLR
argument_list|(
name|PC_MgmtDir
argument_list|)
expr_stmt|;
comment|/* Idle bit */
name|MII_CLR
argument_list|(
operator|(
name|PC_MgmtClk
operator||
name|PC_MgmtData
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MII_SET
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Check for ack */
name|MII_CLR
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ack
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|STGE_PhyCtrl
argument_list|)
operator|&
name|PC_MgmtData
expr_stmt|;
name|MII_SET
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Now try reading data bits. If the ack failed, we still 	 * need to clock through 16 cycles to keep the PHY(s) in sync. 	 */
if|if
condition|(
name|ack
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|MII_CLR
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MII_SET
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0x8000
init|;
name|i
condition|;
name|i
operator|>>=
literal|1
control|)
block|{
name|MII_CLR
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ack
condition|)
block|{
if|if
condition|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|STGE_PhyCtrl
argument_list|)
operator|&
name|PC_MgmtData
condition|)
name|frame
operator|->
name|mii_data
operator||=
name|i
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|MII_SET
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fail
label|:
name|MII_CLR
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MII_SET
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write to a PHY register through the MII.  */
end_comment

begin_function
specifier|static
name|int
name|stge_mii_writereg
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|stge_mii_frame
modifier|*
name|frame
parameter_list|)
block|{
comment|/* 	 * Set up frame for TX. 	 */
name|frame
operator|->
name|mii_stdelim
operator|=
name|STGE_MII_STARTDELIM
expr_stmt|;
name|frame
operator|->
name|mii_opcode
operator|=
name|STGE_MII_WRITEOP
expr_stmt|;
name|frame
operator|->
name|mii_turnaround
operator|=
name|STGE_MII_TURNAROUND
expr_stmt|;
comment|/*  	 * Turn on data output. 	 */
name|MII_SET
argument_list|(
name|PC_MgmtDir
argument_list|)
expr_stmt|;
name|stge_mii_sync
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stge_mii_send
argument_list|(
name|sc
argument_list|,
name|frame
operator|->
name|mii_stdelim
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|stge_mii_send
argument_list|(
name|sc
argument_list|,
name|frame
operator|->
name|mii_opcode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|stge_mii_send
argument_list|(
name|sc
argument_list|,
name|frame
operator|->
name|mii_phyaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|stge_mii_send
argument_list|(
name|sc
argument_list|,
name|frame
operator|->
name|mii_regaddr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|stge_mii_send
argument_list|(
name|sc
argument_list|,
name|frame
operator|->
name|mii_turnaround
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|stge_mii_send
argument_list|(
name|sc
argument_list|,
name|frame
operator|->
name|mii_data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Idle bit. */
name|MII_SET
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MII_CLR
argument_list|(
name|PC_MgmtClk
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Turn off xmit. 	 */
name|MII_CLR
argument_list|(
name|PC_MgmtDir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sc_miibus_readreg:	[mii interface function]  *  *	Read a PHY register on the MII of the TC9021.  */
end_comment

begin_function
specifier|static
name|int
name|stge_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|stge_mii_frame
name|frame
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|STGE_PhyCtrl
condition|)
block|{
comment|/* XXX allow ip1000phy read STGE_PhyCtrl register. */
name|STGE_MII_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|STGE_PhyCtrl
argument_list|)
expr_stmt|;
name|STGE_MII_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|mii_phyaddr
operator|=
name|phy
expr_stmt|;
name|frame
operator|.
name|mii_regaddr
operator|=
name|reg
expr_stmt|;
name|STGE_MII_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|stge_mii_readreg
argument_list|(
name|sc
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
name|STGE_MII_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* Don't show errors for PHY probe request */
if|if
condition|(
name|reg
operator|!=
literal|1
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"phy read fail\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|frame
operator|.
name|mii_data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * stge_miibus_writereg:	[mii interface function]  *  *	Write a PHY register on the MII of the TC9021.  */
end_comment

begin_function
specifier|static
name|int
name|stge_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|stge_mii_frame
name|frame
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|mii_phyaddr
operator|=
name|phy
expr_stmt|;
name|frame
operator|.
name|mii_regaddr
operator|=
name|reg
expr_stmt|;
name|frame
operator|.
name|mii_data
operator|=
name|val
expr_stmt|;
name|STGE_MII_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|stge_mii_writereg
argument_list|(
name|sc
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
name|STGE_MII_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"phy write fail\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * stge_miibus_statchg:	[mii interface function]  *  *	Callback from MII layer when media changes.  */
end_comment

begin_function
specifier|static
name|void
name|stge_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|sc_link_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * stge_mediastatus:	[ifmedia interface function]  *  *	Get the current interface media status.  */
end_comment

begin_function
specifier|static
name|void
name|stge_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * stge_mediachange:	[ifmedia interface function]  *  *	Set hardware to newly-selected media.  */
end_comment

begin_function
specifier|static
name|int
name|stge_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|stge_eeprom_wait
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STGE_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_EepromCtrl
argument_list|)
operator|&
name|EC_EepromBusy
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * stge_read_eeprom:  *  *	Read data from the serial EEPROM.  */
end_comment

begin_function
specifier|static
name|void
name|stge_read_eeprom
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|stge_eeprom_wait
argument_list|(
name|sc
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"EEPROM failed to come ready\n"
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_EepromCtrl
argument_list|,
name|EC_EepromAddress
argument_list|(
name|offset
argument_list|)
operator||
name|EC_EepromOpcode
argument_list|(
name|EC_OP_RR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stge_eeprom_wait
argument_list|(
name|sc
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"EEPROM read timed out\n"
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_EepromData
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|stge_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|stge_product
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|,
name|devid
decl_stmt|;
name|vendor
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|devid
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sp
operator|=
name|stge_products
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|stge_products
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|stge_products
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|vendor
operator|==
name|sp
operator|->
name|stge_vendorid
operator|&&
name|devid
operator|==
name|sp
operator|->
name|stge_deviceid
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|sp
operator|->
name|stge_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|stge_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint8_t
name|enaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii_mtx
argument_list|,
literal|"stge_mii_mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_link_task
argument_list|,
literal|0
argument_list|,
name|stge_link_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Map the device. 	 */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0x01
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_spec
operator|=
name|stge_res_spec_mem
expr_stmt|;
else|else
block|{
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0x01
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"couldn't locate IO BAR\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|sc_spec
operator|=
name|stge_res_spec_io
expr_stmt|;
block|}
name|error
operator|=
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_spec
argument_list|,
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't allocate %s resources\n"
argument_list|,
name|sc
operator|->
name|sc_spec
operator|==
name|stge_res_spec_mem
condition|?
literal|"memory"
else|:
literal|"I/O"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|sc_rev
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxint_nframe"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxint_nframe
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_stge_rxint_nframe
argument_list|,
literal|"I"
argument_list|,
literal|"stge rx interrupt nframe"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxint_dmawait"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxint_dmawait
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_stge_rxint_dmawait
argument_list|,
literal|"I"
argument_list|,
literal|"stge rx interrupt dmawait"
argument_list|)
expr_stmt|;
comment|/* Pull in device tunables. */
name|sc
operator|->
name|sc_rxint_nframe
operator|=
name|STGE_RXINT_NFRAME_DEFAULT
expr_stmt|;
name|error
operator|=
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"rxint_nframe"
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxint_nframe
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rxint_nframe
operator|<
name|STGE_RXINT_NFRAME_MIN
operator|||
name|sc
operator|->
name|sc_rxint_nframe
operator|>
name|STGE_RXINT_NFRAME_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"rxint_nframe value out of range; "
literal|"using default: %d\n"
argument_list|,
name|STGE_RXINT_NFRAME_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxint_nframe
operator|=
name|STGE_RXINT_NFRAME_DEFAULT
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_rxint_dmawait
operator|=
name|STGE_RXINT_DMAWAIT_DEFAULT
expr_stmt|;
name|error
operator|=
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"rxint_dmawait"
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxint_dmawait
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rxint_dmawait
operator|<
name|STGE_RXINT_DMAWAIT_MIN
operator|||
name|sc
operator|->
name|sc_rxint_dmawait
operator|>
name|STGE_RXINT_DMAWAIT_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"rxint_dmawait value out of range; "
literal|"using default: %d\n"
argument_list|,
name|STGE_RXINT_DMAWAIT_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxint_dmawait
operator|=
name|STGE_RXINT_DMAWAIT_DEFAULT
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|stge_dma_alloc
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Determine if we're copper or fiber.  It affects how we 	 * reset the card. 	 */
if|if
condition|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_AsicCtrl
argument_list|)
operator|&
name|AC_PhyMedia
condition|)
name|sc
operator|->
name|sc_usefiber
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|sc_usefiber
operator|=
literal|0
expr_stmt|;
comment|/* Load LED configuration from EEPROM. */
name|stge_read_eeprom
argument_list|(
name|sc
argument_list|,
name|STGE_EEPROM_LEDMode
argument_list|,
operator|&
name|sc
operator|->
name|sc_led
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the chip to a known state. 	 */
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stge_reset
argument_list|(
name|sc
argument_list|,
name|STGE_RESET_FULL
argument_list|)
expr_stmt|;
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Reading the station address from the EEPROM doesn't seem 	 * to work, at least on my sample boards.  Instead, since 	 * the reset sequence does AutoInit, read it from the station 	 * address registers. For Sundance 1023 you can only read it 	 * from EEPROM. 	 */
if|if
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|!=
name|DEVICEID_SUNDANCETI_ST1023
condition|)
block|{
name|uint16_t
name|v
decl_stmt|;
name|v
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_StationAddress0
argument_list|)
expr_stmt|;
name|enaddr
index|[
literal|0
index|]
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
name|enaddr
index|[
literal|1
index|]
operator|=
name|v
operator|>>
literal|8
expr_stmt|;
name|v
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_StationAddress1
argument_list|)
expr_stmt|;
name|enaddr
index|[
literal|2
index|]
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
name|enaddr
index|[
literal|3
index|]
operator|=
name|v
operator|>>
literal|8
expr_stmt|;
name|v
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_StationAddress2
argument_list|)
expr_stmt|;
name|enaddr
index|[
literal|4
index|]
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
name|enaddr
index|[
literal|5
index|]
operator|=
name|v
operator|>>
literal|8
expr_stmt|;
name|sc
operator|->
name|sc_stge1023
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|uint16_t
name|myaddr
index|[
name|ETHER_ADDR_LEN
operator|/
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|stge_read_eeprom
argument_list|(
name|sc
argument_list|,
name|STGE_EEPROM_StationAddress0
operator|+
name|i
argument_list|,
operator|&
name|myaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|myaddr
index|[
name|i
index|]
operator|=
name|le16toh
argument_list|(
name|myaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|myaddr
argument_list|,
name|enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|enaddr
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stge1023
operator|=
literal|1
expr_stmt|;
block|}
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to if_alloc()\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|stge_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|stge_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|stge_init
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|STGE_TX_RING_CNT
operator|-
literal|1
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* Revision B3 and earlier chips have checksum bug. */
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|>=
literal|0x0c
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator|=
name|STGE_CSUM_FEATURES
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWCSUM
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
literal|0
expr_stmt|;
block|}
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_WOL_MAGIC
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	 * Read some important bits from the PhyCtrl register. 	 */
name|sc
operator|->
name|sc_PhyCtrl
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|STGE_PhyCtrl
argument_list|)
operator|&
operator|(
name|PC_PhyDuplexPolarity
operator||
name|PC_PhyLnkPolarity
operator|)
expr_stmt|;
comment|/* Set up MII bus. */
name|flags
operator|=
name|MIIF_DOPAUSE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|>=
literal|0x40
operator|&&
name|sc
operator|->
name|sc_rev
operator|<=
literal|0x4e
condition|)
name|flags
operator||=
name|MIIF_MACPRIV0
expr_stmt|;
name|error
operator|=
name|mii_attach
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_miibus
argument_list|,
name|ifp
argument_list|,
name|stge_mediachange
argument_list|,
name|stge_mediastatus
argument_list|,
name|BMSR_DEFCAPMASK
argument_list|,
name|MII_PHY_ANY
argument_list|,
name|MII_OFFSET_ANY
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"attaching PHYs failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|enaddr
argument_list|)
expr_stmt|;
comment|/* VLAN capability setup */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|>=
literal|0x0c
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_POLLING
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 * Must appear after the call to ether_ifattach() because 	 * ether_ifattach() sets ifi_hdrlen to the default value. 	 */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
comment|/* 	 * The manual recommends disabling early transmit, so we 	 * do.  It's disabled anyway, if using IP checksumming, 	 * since the entire packet must be in the FIFO in order 	 * for the chip to perform the checksum. 	 */
name|sc
operator|->
name|sc_txthresh
operator|=
literal|0x0fff
expr_stmt|;
comment|/* 	 * Disable MWI if the PCI layer tells us to. 	 */
name|sc
operator|->
name|sc_DMACtrl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
name|PCIM_CMD_MWRICEN
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_DMACtrl
operator||=
name|DMAC_MWIDisable
expr_stmt|;
comment|/* 	 * Hookup IRQ 	 */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_res
index|[
literal|1
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|stge_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"couldn't set up IRQ\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fail
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|stge_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|stge_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|&&
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX */
name|sc
operator|->
name|sc_detach
operator|=
literal|1
expr_stmt|;
name|stge_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|sc_link_task
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_miibus
operator|!=
name|NULL
condition|)
block|{
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_miibus
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|stge_dma_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ih
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_res
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ih
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_spec
argument_list|,
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|stge_dmamap_arg
block|{
name|bus_addr_t
name|stge_busaddr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|stge_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|stge_dmamap_arg
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|ctx
operator|=
operator|(
expr|struct
name|stge_dmamap_arg
operator|*
operator|)
name|arg
expr_stmt|;
name|ctx
operator|->
name|stge_busaddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|stge_dma_alloc
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|stge_dmamap_arg
name|ctx
decl_stmt|;
name|struct
name|stge_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|stge_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* create parent tag. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|STGE_DMA_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
literal|0
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_parent_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to create parent DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* create tag for Tx ring. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_parent_tag
argument_list|,
comment|/* parent */
name|STGE_RING_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|STGE_TX_RING_SZ
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|STGE_TX_RING_SZ
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to allocate Tx ring DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* create tag for Rx ring. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_parent_tag
argument_list|,
comment|/* parent */
name|STGE_RING_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|STGE_RX_RING_SZ
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|STGE_RX_RING_SZ
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to allocate Rx ring DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* create tag for Tx buffers. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_parent_tag
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
operator|*
name|STGE_MAXTXSEGS
argument_list|,
comment|/* maxsize */
name|STGE_MAXTXSEGS
argument_list|,
comment|/* nsegments */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to allocate Tx DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* create tag for Rx buffers. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_parent_tag
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to allocate Rx DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* allocate DMA'able memory and load the DMA map for Tx ring. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_tx_ring
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to allocate DMA'able memory for Tx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ctx
operator|.
name|stge_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_tag
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_map
argument_list|,
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_tx_ring
argument_list|,
name|STGE_TX_RING_SZ
argument_list|,
name|stge_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|ctx
operator|.
name|stge_busaddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to load DMA'able memory for Tx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_tx_ring_paddr
operator|=
name|ctx
operator|.
name|stge_busaddr
expr_stmt|;
comment|/* allocate DMA'able memory and load the DMA map for Rx ring. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_rx_ring
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to allocate DMA'able memory for Rx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ctx
operator|.
name|stge_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_tag
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_map
argument_list|,
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_rx_ring
argument_list|,
name|STGE_RX_RING_SZ
argument_list|,
name|stge_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|ctx
operator|.
name|stge_busaddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to load DMA'able memory for Rx ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_rx_ring_paddr
operator|=
name|ctx
operator|.
name|stge_busaddr
expr_stmt|;
comment|/* create DMA maps for Tx buffers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STGE_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_txdesc
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
name|txd
operator|->
name|tx_dmamap
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to create Tx dmamap\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* create DMA maps for Rx buffers. */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_sparemap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to create spare Rx dmamap\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STGE_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxdesc
index|[
name|i
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to create Rx dmamap\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stge_dma_free
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|stge_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|stge_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Tx ring */
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_tag
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_map
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_tag
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_map
operator|&&
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_tx_ring
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_tag
argument_list|,
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_tx_ring
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_tx_ring
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_map
operator|=
literal|0
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Rx ring */
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_tag
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_map
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_tag
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_map
operator|&&
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_rx_ring
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_tag
argument_list|,
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_rx_ring
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_rx_ring
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_map
operator|=
literal|0
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Tx buffers */
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_tag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STGE_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_txdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txd
operator|->
name|tx_dmamap
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_dmamap
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Rx buffers */
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_tag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STGE_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_dmamap
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_sparemap
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_tag
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_sparemap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_sparemap
operator|=
literal|0
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_parent_tag
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_parent_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_parent_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * stge_shutdown:  *  *	Make sure the interface is stopped at reboot time.  */
end_comment

begin_function
specifier|static
name|int
name|stge_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|stge_suspend
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stge_setwol
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
name|STGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|v
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|STGE_WakeEvent
argument_list|)
expr_stmt|;
comment|/* Disable all WOL bits. */
name|v
operator|&=
operator|~
operator|(
name|WE_WakePktEnable
operator||
name|WE_MagicPktEnable
operator||
name|WE_LinkEventEnable
operator||
name|WE_WakeOnLanEnable
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_WOL_MAGIC
operator|)
operator|!=
literal|0
condition|)
name|v
operator||=
name|WE_MagicPktEnable
operator||
name|WE_WakeOnLanEnable
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STGE_WakeEvent
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Reset Tx and prevent transmission. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_AsicCtrl
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_AsicCtrl
argument_list|)
operator||
name|AC_TxReset
argument_list|)
expr_stmt|;
comment|/* 	 * TC9021 automatically reset link speed to 100Mbps when it's put 	 * into sleep so there is no need to try to resetting link speed. 	 */
block|}
end_function

begin_function
specifier|static
name|int
name|stge_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stge_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_suspended
operator|=
literal|1
expr_stmt|;
name|stge_setwol
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|stge_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Clear WOL bits, so special frames wouldn't interfere 	 * normal Rx operation anymore. 	 */
name|v
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|STGE_WakeEvent
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|~
operator|(
name|WE_WakePktEnable
operator||
name|WE_MagicPktEnable
operator||
name|WE_LinkEventEnable
operator||
name|WE_WakeOnLanEnable
operator|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STGE_WakeEvent
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|stge_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_suspended
operator|=
literal|0
expr_stmt|;
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stge_dma_wait
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STGE_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_DMACtrl
argument_list|)
operator|&
name|DMAC_TxDMAInProg
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|STGE_TIMEOUT
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"DMA wait timed out\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|stge_encap
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|)
block|{
name|struct
name|stge_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|stge_tfd
modifier|*
name|tfd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dma_segment_t
name|txsegs
index|[
name|STGE_MAXTXSEGS
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|nsegs
decl_stmt|,
name|si
decl_stmt|;
name|uint64_t
name|csum_flags
decl_stmt|,
name|tfc
decl_stmt|;
name|STGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|txd
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_txfreeq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
operator|*
name|m_head
argument_list|,
name|txsegs
argument_list|,
operator|&
name|nsegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|m
operator|=
name|m_collapse
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|,
name|STGE_MAXTXSEGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
operator|*
name|m_head
argument_list|,
name|txsegs
argument_list|,
operator|&
name|nsegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nsegs
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|m
operator|=
operator|*
name|m_head
expr_stmt|;
name|csum_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|STGE_CSUM_FEATURES
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
condition|)
name|csum_flags
operator||=
name|TFD_IPChecksumEnable
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
condition|)
name|csum_flags
operator||=
name|TFD_TCPChecksumEnable
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
condition|)
name|csum_flags
operator||=
name|TFD_UDPChecksumEnable
expr_stmt|;
block|}
name|si
operator|=
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_prod
expr_stmt|;
name|tfd
operator|=
operator|&
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_tx_ring
index|[
name|si
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
name|tfd
operator|->
name|tfd_frags
index|[
name|i
index|]
operator|.
name|frag_word0
operator|=
name|htole64
argument_list|(
name|FRAG_ADDR
argument_list|(
name|txsegs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
operator||
name|FRAG_LEN
argument_list|(
name|txsegs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_cnt
operator|++
expr_stmt|;
name|tfc
operator|=
name|TFD_FrameId
argument_list|(
name|si
argument_list|)
operator||
name|TFD_WordAlign
argument_list|(
name|TFD_WordAlign_disable
argument_list|)
operator||
name|TFD_FragCount
argument_list|(
name|nsegs
argument_list|)
operator||
name|csum_flags
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_cnt
operator|>=
name|STGE_TX_HIWAT
condition|)
name|tfc
operator||=
name|TFD_TxDMAIndicate
expr_stmt|;
comment|/* Update producer index. */
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_prod
operator|=
operator|(
name|si
operator|+
literal|1
operator|)
operator|%
name|STGE_TX_RING_CNT
expr_stmt|;
comment|/* Check if we have a VLAN tag to insert. */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
name|tfc
operator||=
operator|(
name|TFD_VLANTagInsert
operator||
name|TFD_VID
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
operator|)
expr_stmt|;
name|tfd
operator|->
name|tfd_control
operator|=
name|htole64
argument_list|(
name|tfc
argument_list|)
expr_stmt|;
comment|/* Update Tx Queue. */
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_txfreeq
argument_list|,
name|tx_q
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_txbusyq
argument_list|,
name|txd
argument_list|,
name|tx_q
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|m
expr_stmt|;
comment|/* Sync descriptors. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_tag
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * stge_start:		[ifnet interface function]  *  *	Start packet transmission on the interface.  */
end_comment

begin_function
specifier|static
name|void
name|stge_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stge_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stge_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|int
name|enq
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|STGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|||
name|sc
operator|->
name|sc_link
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|enq
operator|=
literal|0
init|;
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|;
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_cnt
operator|>=
name|STGE_TX_HIWAT
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Pack the data into the transmit ring. If we 		 * don't have room, set the OACTIVE flag and wait 		 * for the NIC to drain the ring. 		 */
if|if
condition|(
name|stge_encap
argument_list|(
name|sc
argument_list|,
operator|&
name|m_head
argument_list|)
condition|)
block|{
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
name|enq
operator|++
expr_stmt|;
comment|/* 		 * If there's a BPF listener, bounce a copy of this frame 		 * to him. 		 */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enq
operator|>
literal|0
condition|)
block|{
comment|/* Transmit */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_DMACtrl
argument_list|,
name|DMAC_TxDMAPollNow
argument_list|)
expr_stmt|;
comment|/* Set a timeout in case the chip goes out to lunch. */
name|sc
operator|->
name|sc_watchdog_timer
operator|=
literal|5
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * stge_watchdog:  *  *	Watchdog timer handler.  */
end_comment

begin_function
specifier|static
name|void
name|stge_watchdog
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|STGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_watchdog_timer
operator|==
literal|0
operator|||
operator|--
name|sc
operator|->
name|sc_watchdog_timer
condition|)
return|return;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|stge_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|stge_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * stge_ioctl:		[ifnet interface function]  *  *	Handle control requests from the operator.  */
end_comment

begin_function
specifier|static
name|int
name|stge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|error
decl_stmt|,
name|mask
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|<
name|ETHERMIN
operator|||
name|ifr
operator|->
name|ifr_mtu
operator|>
name|STGE_JUMBO_MTU
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|!=
name|ifr
operator|->
name|ifr_mtu
condition|)
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|stge_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|sc_if_flags
operator|)
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
name|stge_set_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_detach
operator|==
literal|0
condition|)
name|stge_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|stge_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|stge_set_multi
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_POLLING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ether_poll_register
argument_list|(
name|stge_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_IntEnable
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING
expr_stmt|;
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_IntEnable
argument_list|,
name|sc
operator|->
name|sc_IntEnable
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_POLLING
expr_stmt|;
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_HWCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_HWCSUM
expr_stmt|;
if|if
condition|(
operator|(
name|IFCAP_HWCSUM
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IFCAP_HWCSUM
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|STGE_CSUM_FEATURES
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_WOL
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_WOL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_WOL_MAGIC
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_WOL_MAGIC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stge_vlan_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stge_link_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint32_t
name|v
decl_stmt|,
name|ac
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|stge_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii
operator|->
name|mii_media_status
operator|&
name|IFM_ACTIVE
condition|)
block|{
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|!=
name|IFM_NONE
condition|)
name|sc
operator|->
name|sc_link
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_link
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_MACCtrl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_GMASK
operator|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_MACCtrl
operator||=
name|MC_DuplexSelect
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_GMASK
operator|)
operator|&
name|IFM_ETH_RXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_MACCtrl
operator||=
name|MC_RxFlowControlEnable
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_GMASK
operator|)
operator|&
name|IFM_ETH_TXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_MACCtrl
operator||=
name|MC_TxFlowControlEnable
expr_stmt|;
comment|/* 	 * Update STGE_MACCtrl register depending on link status. 	 * (duplex, flow control etc) 	 */
name|v
operator|=
name|ac
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|)
operator|&
name|MC_MASK
expr_stmt|;
name|v
operator|&=
operator|~
operator|(
name|MC_DuplexSelect
operator||
name|MC_RxFlowControlEnable
operator||
name|MC_TxFlowControlEnable
operator|)
expr_stmt|;
name|v
operator||=
name|sc
operator|->
name|sc_MACCtrl
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ac
operator|^
name|sc
operator|->
name|sc_MACCtrl
operator|)
operator|&
name|MC_DuplexSelect
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Duplex setting changed, reset Tx/Rx functions. */
name|ac
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_AsicCtrl
argument_list|)
expr_stmt|;
name|ac
operator||=
name|AC_TxReset
operator||
name|AC_RxReset
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_AsicCtrl
argument_list|,
name|ac
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STGE_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_AsicCtrl
argument_list|)
operator|&
name|AC_ResetBusy
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|STGE_TIMEOUT
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"reset failed to complete\n"
argument_list|)
expr_stmt|;
block|}
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|stge_tx_error
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|txstat
decl_stmt|;
name|int
name|error
decl_stmt|;
for|for
control|(
name|error
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|txstat
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_TxStatus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|txstat
operator|&
name|TS_TxComplete
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* Tx underrun */
if|if
condition|(
operator|(
name|txstat
operator|&
name|TS_TxUnderrun
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * XXX 			 * There should be a more better way to recover 			 * from Tx underrun instead of a full reset. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_nerr
operator|++
operator|<
name|STGE_MAXERR
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Tx underrun, "
literal|"resetting...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nerr
operator|==
name|STGE_MAXERR
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"too many errors; "
literal|"not reporting any more\n"
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Maximum/Late collisions, Re-enable Tx MAC. */
if|if
condition|(
operator|(
name|txstat
operator|&
operator|(
name|TS_MaxCollisions
operator||
name|TS_LateCollision
operator|)
operator|)
operator|!=
literal|0
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|,
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|)
operator|&
name|MC_MASK
operator|)
operator||
name|MC_TxEnable
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * stge_intr:  *  *	Interrupt service routine.  */
end_comment

begin_function
specifier|static
name|void
name|stge_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|reinit
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|stge_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done_locked
goto|;
endif|#
directive|endif
name|status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_IntStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_suspended
operator|||
operator|(
name|status
operator|&
name|IS_InterruptStatus
operator|)
operator|==
literal|0
condition|)
goto|goto
name|done_locked
goto|;
comment|/* Disable interrupts. */
for|for
control|(
name|reinit
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_IntStatusAck
argument_list|)
expr_stmt|;
name|status
operator|&=
name|sc
operator|->
name|sc_IntEnable
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
break|break;
comment|/* Host interface errors. */
if|if
condition|(
operator|(
name|status
operator|&
name|IS_HostError
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Host interface error, resetting...\n"
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
goto|goto
name|force_init
goto|;
block|}
comment|/* Receive interrupts. */
if|if
condition|(
operator|(
name|status
operator|&
name|IS_RxDMAComplete
operator|)
operator|!=
literal|0
condition|)
block|{
name|stge_rxeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|IS_RFDListEnd
operator|)
operator|!=
literal|0
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_DMACtrl
argument_list|,
name|DMAC_RxDMAPollNow
argument_list|)
expr_stmt|;
block|}
comment|/* Transmit interrupts. */
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|IS_TxDMAComplete
operator||
name|IS_TxComplete
operator|)
operator|)
operator|!=
literal|0
condition|)
name|stge_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Transmission errors.*/
if|if
condition|(
operator|(
name|status
operator|&
name|IS_TxComplete
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|reinit
operator|=
name|stge_tx_error
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
name|force_init
label|:
if|if
condition|(
name|reinit
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|stge_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Re-enable interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_IntEnable
argument_list|,
name|sc
operator|->
name|sc_IntEnable
argument_list|)
expr_stmt|;
comment|/* Try to get more packets going. */
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|stge_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|done_locked
label|:
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * stge_txeof:  *  *	Helper; handle transmit interrupts.  */
end_comment

begin_function
specifier|static
name|void
name|stge_txeof
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|stge_txdesc
modifier|*
name|txd
decl_stmt|;
name|uint64_t
name|control
decl_stmt|;
name|int
name|cons
decl_stmt|;
name|STGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|txd
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_txbusyq
argument_list|)
expr_stmt|;
if|if
condition|(
name|txd
operator|==
name|NULL
condition|)
return|return;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_tag
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* 	 * Go through our Tx list and free mbufs for those 	 * frames which have been transmitted. 	 */
for|for
control|(
name|cons
operator|=
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_cons
init|;
condition|;
name|cons
operator|=
operator|(
name|cons
operator|+
literal|1
operator|)
operator|%
name|STGE_TX_RING_CNT
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_cnt
operator|<=
literal|0
condition|)
break|break;
name|control
operator|=
name|le64toh
argument_list|(
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_tx_ring
index|[
name|cons
index|]
operator|.
name|tfd_control
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|&
name|TFD_TFDDone
operator|)
operator|==
literal|0
condition|)
break|break;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_cnt
operator|--
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
comment|/* Output counter is updated with statistics register */
name|m_freem
argument_list|(
name|txd
operator|->
name|tx_m
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_txbusyq
argument_list|,
name|tx_q
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_txfreeq
argument_list|,
name|txd
argument_list|,
name|tx_q
argument_list|)
expr_stmt|;
name|txd
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_txbusyq
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_cons
operator|=
name|cons
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_cnt
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_watchdog_timer
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_tag
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|stge_discard_rxbuf
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|stge_rfd
modifier|*
name|rfd
decl_stmt|;
name|rfd
operator|=
operator|&
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_rx_ring
index|[
name|idx
index|]
expr_stmt|;
name|rfd
operator|->
name|rfd_status
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
end_ifndef

begin_comment
comment|/*  * It seems that TC9021's DMA engine has alignment restrictions in  * DMA scatter operations. The first DMA segment has no address  * alignment restrictins but the rest should be aligned on 4(?) bytes  * boundary. Otherwise it would corrupt random memory. Since we don't  * know which one is used for the first segment in advance we simply  * don't align at all.  * To avoid copying over an entire frame to align, we allocate a new  * mbuf and copy ethernet header to the new mbuf. The new mbuf is  * prepended into the existing mbuf chain.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|stge_fixup_rx
argument_list|(
argument|struct stge_softc *sc
argument_list|,
argument|struct mbuf *m
argument_list|)
block|{ 	struct
name|mbuf
operator|*
name|n
block|;
name|n
operator|=
name|NULL
block|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
operator|(
name|MCLBYTES
operator|-
name|ETHER_HDR_LEN
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_data
operator|+
name|ETHER_HDR_LEN
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|ETHER_HDR_LEN
expr_stmt|;
name|n
operator|=
name|m
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|n
operator|->
name|m_data
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|ETHER_HDR_LEN
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|ETHER_HDR_LEN
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|M_MOVE_PKTHDR
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
block|}
else|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_else

begin_return
return|return
operator|(
name|n
operator|)
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * stge_rxeof:  *  *	Helper; handle receive interrupts.  */
end_comment

begin_function
unit|static
name|int
name|stge_rxeof
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|stge_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|uint64_t
name|status64
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|int
name|cons
decl_stmt|,
name|prog
decl_stmt|,
name|rx_npkts
decl_stmt|;
name|STGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rx_npkts
operator|=
literal|0
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_tag
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|prog
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cons
operator|=
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_cons
init|;
name|prog
operator|<
name|STGE_RX_RING_CNT
condition|;
name|prog
operator|++
operator|,
name|cons
operator|=
operator|(
name|cons
operator|+
literal|1
operator|)
operator|%
name|STGE_RX_RING_CNT
control|)
block|{
name|status64
operator|=
name|le64toh
argument_list|(
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_rx_ring
index|[
name|cons
index|]
operator|.
name|rfd_status
argument_list|)
expr_stmt|;
name|status
operator|=
name|RFD_RxStatus
argument_list|(
name|status64
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|RFD_RFDDone
operator|)
operator|==
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxcycles
operator|<=
literal|0
condition|)
break|break;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxcycles
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
name|prog
operator|++
expr_stmt|;
name|rxd
operator|=
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxdesc
index|[
name|cons
index|]
expr_stmt|;
name|mp
operator|=
name|rxd
operator|->
name|rx_m
expr_stmt|;
comment|/* 		 * If the packet had an error, drop it.  Note we count 		 * the error later in the periodic stats update. 		 */
if|if
condition|(
operator|(
name|status
operator|&
name|RFD_FrameEnd
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|status
operator|&
operator|(
name|RFD_RxFIFOOverrun
operator||
name|RFD_RxRuntFrame
operator||
name|RFD_RxAlignmentError
operator||
name|RFD_RxFCSError
operator||
name|RFD_RxLengthError
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|stge_discard_rxbuf
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxhead
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxhead
argument_list|)
expr_stmt|;
name|STGE_RXCHAIN_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		 * Add a new receive buffer to the ring. 		 */
if|if
condition|(
name|stge_newbuf
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
name|stge_discard_rxbuf
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxhead
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxhead
argument_list|)
expr_stmt|;
name|STGE_RXCHAIN_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|RFD_FrameEnd
operator|)
operator|!=
literal|0
condition|)
name|mp
operator|->
name|m_len
operator|=
name|RFD_RxDMAFrameLen
argument_list|(
name|status
argument_list|)
operator|-
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxlen
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxlen
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
comment|/* Chain mbufs. */
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxhead
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxhead
operator|=
name|mp
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxtail
operator|=
name|mp
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxtail
operator|->
name|m_next
operator|=
name|mp
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxtail
operator|=
name|mp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|RFD_FrameEnd
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxhead
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxlen
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|sc
operator|->
name|sc_if_framesize
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|STGE_RXCHAIN_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Set the incoming checksum information for 			 * the packet. 			 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|status
operator|&
name|RFD_IPDetected
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_CHECKED
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|RFD_IPError
operator|)
operator|==
literal|0
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|status
operator|&
name|RFD_TCPDetected
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|status
operator|&
name|RFD_TCPError
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|status
operator|&
name|RFD_UDPDetected
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|status
operator|&
name|RFD_UDPError
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
if|if
condition|(
name|sc
operator|->
name|sc_if_framesize
operator|>
operator|(
name|MCLBYTES
operator|-
name|ETHER_ALIGN
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|stge_fixup_rx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|STGE_RXCHAIN_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* Check for VLAN tagged packets. */
if|if
condition|(
operator|(
name|status
operator|&
name|RFD_VLANDetected
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|RFD_TCI
argument_list|(
name|status64
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Pass it on. */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rx_npkts
operator|++
expr_stmt|;
name|STGE_RXCHAIN_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prog
operator|>
literal|0
condition|)
block|{
comment|/* Update the consumer index. */
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_cons
operator|=
name|cons
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_tag
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rx_npkts
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_function
specifier|static
name|int
name|stge_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|int
name|rx_npkts
decl_stmt|;
name|rx_npkts
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rx_npkts
operator|)
return|;
block|}
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxcycles
operator|=
name|count
expr_stmt|;
name|rx_npkts
operator|=
name|stge_rxeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stge_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
condition|)
block|{
name|status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_IntStatus
argument_list|)
expr_stmt|;
name|status
operator|&=
name|sc
operator|->
name|sc_IntEnable
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|status
operator|&
name|IS_HostError
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Host interface error, resetting...\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|stge_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|IS_TxComplete
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|stge_tx_error
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|stge_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|stge_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rx_npkts
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_comment
comment|/*  * stge_tick:  *  *	One second timer, used to tick the MII.  */
end_comment

begin_function
specifier|static
name|void
name|stge_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|stge_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|STGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
comment|/* Update statistics counters. */
name|stge_stats_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Relcaim any pending Tx descriptors to release mbufs in a 	 * timely manner as we don't generate Tx completion interrupts 	 * for every frame. This limits the delay to a maximum of one 	 * second. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_cnt
operator|!=
literal|0
condition|)
name|stge_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stge_watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
name|hz
argument_list|,
name|stge_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * stge_stats_update:  *  *	Read the TC9021 statistics counters.  */
end_comment

begin_function
specifier|static
name|void
name|stge_stats_update
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|STGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_OctetRcvOk
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|+=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_FramesRcvdOk
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|+=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_FramesLostRxErrors
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_OctetXmtdOk
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|+=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_FramesXmtdOk
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_LateCollisions
argument_list|)
operator|+
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_MultiColFrames
argument_list|)
operator|+
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_SingleColFrames
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|+=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_FramesAbortXSColls
argument_list|)
operator|+
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_FramesWEXDeferal
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * stge_reset:  *  *	Perform a soft reset on the TC9021.  */
end_comment

begin_function
specifier|static
name|void
name|stge_reset
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|how
parameter_list|)
block|{
name|uint32_t
name|ac
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dv
decl_stmt|;
name|STGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dv
operator|=
literal|5000
expr_stmt|;
name|ac
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_AsicCtrl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|STGE_RESET_TX
case|:
name|ac
operator||=
name|AC_TxReset
operator||
name|AC_FIFO
expr_stmt|;
name|dv
operator|=
literal|100
expr_stmt|;
break|break;
case|case
name|STGE_RESET_RX
case|:
name|ac
operator||=
name|AC_RxReset
operator||
name|AC_FIFO
expr_stmt|;
name|dv
operator|=
literal|100
expr_stmt|;
break|break;
case|case
name|STGE_RESET_FULL
case|:
default|default:
comment|/* 		 * Only assert RstOut if we're fiber.  We need GMII clocks 		 * to be present in order for the reset to complete on fiber 		 * cards. 		 */
name|ac
operator||=
name|AC_GlobalReset
operator||
name|AC_RxReset
operator||
name|AC_TxReset
operator||
name|AC_DMA
operator||
name|AC_FIFO
operator||
name|AC_Network
operator||
name|AC_Host
operator||
name|AC_AutoInit
operator||
operator|(
name|sc
operator|->
name|sc_usefiber
condition|?
name|AC_RstOut
else|:
literal|0
operator|)
expr_stmt|;
break|break;
block|}
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_AsicCtrl
argument_list|,
name|ac
argument_list|)
expr_stmt|;
comment|/* Account for reset problem at 10Mbps. */
name|DELAY
argument_list|(
name|dv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STGE_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_AsicCtrl
argument_list|)
operator|&
name|AC_ResetBusy
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
name|dv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|STGE_TIMEOUT
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"reset failed to complete\n"
argument_list|)
expr_stmt|;
comment|/* Set LED, from Linux IPG driver. */
name|ac
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_AsicCtrl
argument_list|)
expr_stmt|;
name|ac
operator|&=
operator|~
operator|(
name|AC_LEDMode
operator||
name|AC_LEDSpeed
operator||
name|AC_LEDModeBit1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_led
operator|&
literal|0x01
operator|)
operator|!=
literal|0
condition|)
name|ac
operator||=
name|AC_LEDMode
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_led
operator|&
literal|0x03
operator|)
operator|!=
literal|0
condition|)
name|ac
operator||=
name|AC_LEDModeBit1
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_led
operator|&
literal|0x08
operator|)
operator|!=
literal|0
condition|)
name|ac
operator||=
name|AC_LEDSpeed
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_AsicCtrl
argument_list|,
name|ac
argument_list|)
expr_stmt|;
comment|/* Set PHY, from Linux IPG driver */
name|v
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|STGE_PhySet
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|~
operator|(
name|PS_MemLenb9b
operator||
name|PS_MemLen
operator||
name|PS_NonCompdet
operator|)
expr_stmt|;
name|v
operator||=
operator|(
operator|(
name|sc
operator|->
name|sc_led
operator|&
literal|0x70
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STGE_PhySet
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * stge_init:		[ ifnet interface function ]  *  *	Initialize the interface.  */
end_comment

begin_function
specifier|static
name|void
name|stge_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|stge_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|stge_softc
operator|*
operator|)
name|xsc
expr_stmt|;
name|STGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stge_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stge_init_locked
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint16_t
name|eaddr
index|[
literal|3
index|]
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|int
name|error
decl_stmt|;
name|STGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
return|return;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
comment|/* 	 * Cancel any pending I/O. 	 */
name|stge_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the chip to a known state. 	 */
name|stge_reset
argument_list|(
name|sc
argument_list|,
name|STGE_RESET_FULL
argument_list|)
expr_stmt|;
comment|/* Init descriptors. */
name|error
operator|=
name|stge_init_rx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"initialization failed: no memory for rx buffers\n"
argument_list|)
expr_stmt|;
name|stge_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|stge_init_tx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set the station address. */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|eaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_StationAddress0
argument_list|,
name|htole16
argument_list|(
name|eaddr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_StationAddress1
argument_list|,
name|htole16
argument_list|(
name|eaddr
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_StationAddress2
argument_list|,
name|htole16
argument_list|(
name|eaddr
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set the statistics masks.  Disable all the RMON stats, 	 * and disable selected stats in the non-RMON stats registers. 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_RMONStatisticsMask
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_StatisticsMask
argument_list|,
operator|(
literal|1U
operator|<<
literal|1
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|2
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|3
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|4
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|5
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|7
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|8
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|9
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|10
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|13
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|14
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|15
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|19
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|20
operator|)
operator||
operator|(
literal|1U
operator|<<
literal|21
operator|)
argument_list|)
expr_stmt|;
comment|/* Set up the receive filter. */
name|stge_set_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Program multicast filter. */
name|stge_set_multi
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Give the transmit and receive ring to the chip. 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_TFDListPtrHi
argument_list|,
name|STGE_ADDR_HI
argument_list|(
name|STGE_TX_RING_ADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_TFDListPtrLo
argument_list|,
name|STGE_ADDR_LO
argument_list|(
name|STGE_TX_RING_ADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_RFDListPtrHi
argument_list|,
name|STGE_ADDR_HI
argument_list|(
name|STGE_RX_RING_ADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_RFDListPtrLo
argument_list|,
name|STGE_ADDR_LO
argument_list|(
name|STGE_RX_RING_ADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the Tx auto-poll period.  It's OK to make this number 	 * large (255 is the max, but we use 127) -- we explicitly kick the 	 * transmit engine when there's actually a packet. 	 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STGE_TxDMAPollPeriod
argument_list|,
literal|127
argument_list|)
expr_stmt|;
comment|/* ..and the Rx auto-poll period. */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STGE_RxDMAPollPeriod
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize the Tx start threshold. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_TxStartThresh
argument_list|,
name|sc
operator|->
name|sc_txthresh
argument_list|)
expr_stmt|;
comment|/* Rx DMA thresholds, from Linux */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STGE_RxDMABurstThresh
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STGE_RxDMAUrgentThresh
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
comment|/* Rx early threhold, from Linux */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_RxEarlyThresh
argument_list|,
literal|0x7ff
argument_list|)
expr_stmt|;
comment|/* Tx DMA thresholds, from Linux */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STGE_TxDMABurstThresh
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STGE_TxDMAUrgentThresh
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the Rx DMA interrupt control register.  We 	 * request an interrupt after every incoming packet, but 	 * defer it for sc_rxint_dmawait us. When the number of 	 * interrupts pending reaches STGE_RXINT_NFRAME, we stop 	 * deferring the interrupt, and signal it immediately. 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_RxDMAIntCtrl
argument_list|,
name|RDIC_RxFrameCount
argument_list|(
name|sc
operator|->
name|sc_rxint_nframe
argument_list|)
operator||
name|RDIC_RxDMAWaitTime
argument_list|(
name|STGE_RXINT_USECS2TICK
argument_list|(
name|sc
operator|->
name|sc_rxint_dmawait
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the interrupt mask. 	 */
name|sc
operator|->
name|sc_IntEnable
operator|=
name|IS_HostError
operator||
name|IS_TxComplete
operator||
name|IS_TxDMAComplete
operator||
name|IS_RxDMAComplete
operator||
name|IS_RFDListEnd
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* Disable interrupts if we are polling. */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
operator|!=
literal|0
condition|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_IntEnable
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_IntEnable
argument_list|,
name|sc
operator|->
name|sc_IntEnable
argument_list|)
expr_stmt|;
comment|/* 	 * Configure the DMA engine. 	 * XXX Should auto-tune TxBurstLimit. 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_DMACtrl
argument_list|,
name|sc
operator|->
name|sc_DMACtrl
operator||
name|DMAC_TxBurstLimit
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Send a PAUSE frame when we reach 29,696 bytes in the Rx 	 * FIFO, and send an un-PAUSE frame when we reach 3056 bytes 	 * in the Rx FIFO. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_FlowOnTresh
argument_list|,
literal|29696
operator|/
literal|16
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_FlowOffThresh
argument_list|,
literal|3056
operator|/
literal|16
argument_list|)
expr_stmt|;
comment|/* 	 * Set the maximum frame size. 	 */
name|sc
operator|->
name|sc_if_framesize
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_MaxFrameSize
argument_list|,
name|sc
operator|->
name|sc_if_framesize
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize MacCtrl -- do it before setting the media, 	 * as setting the media will actually program the register. 	 * 	 * Note: We have to poke the IFS value before poking 	 * anything else. 	 */
comment|/* Tx/Rx MAC should be disabled before programming IFS.*/
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|,
name|MC_IFSSelect
argument_list|(
name|MC_IFS96bit
argument_list|)
argument_list|)
expr_stmt|;
name|stge_vlan_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|>=
literal|6
condition|)
block|{
comment|/*>= B.2 */
comment|/* Multi-frag frame bug work-around. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_DebugCtrl
argument_list|,
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_DebugCtrl
argument_list|)
operator||
literal|0x0200
argument_list|)
expr_stmt|;
comment|/* Tx Poll Now bug work-around. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_DebugCtrl
argument_list|,
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_DebugCtrl
argument_list|)
operator||
literal|0x0010
argument_list|)
expr_stmt|;
comment|/* Tx Poll Now bug work-around. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_DebugCtrl
argument_list|,
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_DebugCtrl
argument_list|)
operator||
literal|0x0020
argument_list|)
expr_stmt|;
block|}
name|v
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|)
operator|&
name|MC_MASK
expr_stmt|;
name|v
operator||=
name|MC_StatisticsEnable
operator||
name|MC_TxEnable
operator||
name|MC_RxEnable
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* 	 * It seems that transmitting frames without checking the state of 	 * Rx/Tx MAC wedge the hardware. 	 */
name|stge_start_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stge_start_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_link
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set the current media. 	 */
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
comment|/* 	 * Start the one second MII clock. 	 */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
name|hz
argument_list|,
name|stge_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * ...all done! 	 */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"interface not running\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stge_vlan_setup
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
comment|/* 	 * The NIC always copy a VLAN tag regardless of STGE_MACCtrl 	 * MC_AutoVLANuntagging bit. 	 * MC_AutoVLANtagging bit selects which VLAN source to use 	 * between STGE_VLANTag and TFC. However TFC TFD_VLANTagInsert 	 * bit has priority over MC_AutoVLANtagging bit. So we always 	 * use TFC instead of STGE_VLANTag register. 	 */
name|v
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|)
operator|&
name|MC_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
name|v
operator||=
name|MC_AutoVLANuntagging
expr_stmt|;
else|else
name|v
operator|&=
operator|~
name|MC_AutoVLANuntagging
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Stop transmission on the interface.  */
end_comment

begin_function
specifier|static
name|void
name|stge_stop
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|stge_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|stge_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|STGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Stop the one second clock. 	 */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_watchdog_timer
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Disable interrupts. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_IntEnable
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Stop receiver, transmitter, and stats update. 	 */
name|stge_stop_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stge_stop_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|)
operator|&
name|MC_MASK
expr_stmt|;
name|v
operator||=
name|MC_StatisticsDisable
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* 	 * Stop the transmit and receive DMA. 	 */
name|stge_dma_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_TFDListPtrHi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_TFDListPtrLo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_RFDListPtrHi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_RFDListPtrLo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Free RX and TX mbufs still in the queues. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STGE_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxd
operator|->
name|rx_m
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STGE_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_txdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txd
operator|->
name|tx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txd
operator|->
name|tx_m
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Mark the interface down and cancel the watchdog timer. 	 */
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_link
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stge_start_tx
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|v
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|)
operator|&
name|MC_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|MC_TxEnabled
operator|)
operator|!=
literal|0
condition|)
return|return;
name|v
operator||=
name|MC_TxEnable
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STGE_TxDMAPollPeriod
argument_list|,
literal|127
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|STGE_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|v
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|)
operator|&
name|MC_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|MC_TxEnabled
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Starting Tx MAC timed out\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stge_start_rx
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|v
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|)
operator|&
name|MC_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|MC_RxEnabled
operator|)
operator|!=
literal|0
condition|)
return|return;
name|v
operator||=
name|MC_RxEnable
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|STGE_RxDMAPollPeriod
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|STGE_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|v
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|)
operator|&
name|MC_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|MC_RxEnabled
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Starting Rx MAC timed out\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stge_stop_tx
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|v
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|)
operator|&
name|MC_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|MC_TxEnabled
operator|)
operator|==
literal|0
condition|)
return|return;
name|v
operator||=
name|MC_TxDisable
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|,
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|STGE_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|v
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|)
operator|&
name|MC_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|MC_TxEnabled
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Stopping Tx MAC timed out\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stge_stop_rx
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|v
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|)
operator|&
name|MC_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|MC_RxEnabled
operator|)
operator|==
literal|0
condition|)
return|return;
name|v
operator||=
name|MC_RxDisable
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|,
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|STGE_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|v
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|STGE_MACCtrl
argument_list|)
operator|&
name|MC_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|MC_RxEnabled
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Stopping Rx MAC timed out\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stge_init_tx_ring
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|stge_ring_data
modifier|*
name|rd
decl_stmt|;
name|struct
name|stge_txdesc
modifier|*
name|txd
decl_stmt|;
name|bus_addr_t
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_txfreeq
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_txbusyq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_prod
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_cons
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_cnt
operator|=
literal|0
expr_stmt|;
name|rd
operator|=
operator|&
name|sc
operator|->
name|sc_rdata
expr_stmt|;
name|bzero
argument_list|(
name|rd
operator|->
name|stge_tx_ring
argument_list|,
name|STGE_TX_RING_SZ
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STGE_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|STGE_TX_RING_CNT
operator|-
literal|1
operator|)
condition|)
name|addr
operator|=
name|STGE_TX_RING_ADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|STGE_TX_RING_ADDR
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rd
operator|->
name|stge_tx_ring
index|[
name|i
index|]
operator|.
name|tfd_next
operator|=
name|htole64
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|rd
operator|->
name|stge_tx_ring
index|[
name|i
index|]
operator|.
name|tfd_control
operator|=
name|htole64
argument_list|(
name|TFD_TFDDone
argument_list|)
expr_stmt|;
name|txd
operator|=
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_txdesc
index|[
name|i
index|]
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_txfreeq
argument_list|,
name|txd
argument_list|,
name|tx_q
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_tag
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_tx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|stge_init_rx_ring
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|stge_ring_data
modifier|*
name|rd
decl_stmt|;
name|bus_addr_t
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_cons
operator|=
literal|0
expr_stmt|;
name|STGE_RXCHAIN_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rd
operator|=
operator|&
name|sc
operator|->
name|sc_rdata
expr_stmt|;
name|bzero
argument_list|(
name|rd
operator|->
name|stge_rx_ring
argument_list|,
name|STGE_RX_RING_SZ
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STGE_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stge_newbuf
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
if|if
condition|(
name|i
operator|==
operator|(
name|STGE_RX_RING_CNT
operator|-
literal|1
operator|)
condition|)
name|addr
operator|=
name|STGE_RX_RING_ADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|STGE_RX_RING_ADDR
argument_list|(
name|sc
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rd
operator|->
name|stge_rx_ring
index|[
name|i
index|]
operator|.
name|rfd_next
operator|=
name|htole64
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|rd
operator|->
name|stge_rx_ring
index|[
name|i
index|]
operator|.
name|rfd_status
operator|=
literal|0
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_tag
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * stge_newbuf:  *  *	Add a receive buffer to the indicated descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|stge_newbuf
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|stge_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|stge_rfd
modifier|*
name|rfd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
comment|/* 	 * The hardware requires 4bytes aligned DMA address when JUMBO 	 * frame is used. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_if_framesize
operator|<=
operator|(
name|MCLBYTES
operator|-
name|ETHER_ALIGN
operator|)
condition|)
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_tag
argument_list|,
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_sparemap
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: %d segments returned!"
operator|,
name|__func__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
name|rxd
operator|=
operator|&
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rxdesc
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
name|rxd
operator|->
name|rx_dmamap
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_sparemap
expr_stmt|;
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_sparemap
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdata
operator|.
name|stge_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|m
expr_stmt|;
name|rfd
operator|=
operator|&
name|sc
operator|->
name|sc_rdata
operator|.
name|stge_rx_ring
index|[
name|idx
index|]
expr_stmt|;
name|rfd
operator|->
name|rfd_frag
operator|.
name|frag_word0
operator|=
name|htole64
argument_list|(
name|FRAG_ADDR
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
operator||
name|FRAG_LEN
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|)
argument_list|)
expr_stmt|;
name|rfd
operator|->
name|rfd_status
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * stge_set_filter:  *  *	Set up the receive filter.  */
end_comment

begin_function
specifier|static
name|void
name|stge_set_filter
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint16_t
name|mode
decl_stmt|;
name|STGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|mode
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_ReceiveMode
argument_list|)
expr_stmt|;
name|mode
operator||=
name|RM_ReceiveUnicast
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
operator|)
operator|!=
literal|0
condition|)
name|mode
operator||=
name|RM_ReceiveBroadcast
expr_stmt|;
else|else
name|mode
operator|&=
operator|~
name|RM_ReceiveBroadcast
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
name|mode
operator||=
name|RM_ReceiveAllFrames
expr_stmt|;
else|else
name|mode
operator|&=
operator|~
name|RM_ReceiveAllFrames
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_ReceiveMode
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stge_set_multi
parameter_list|(
name|struct
name|stge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|;
name|uint32_t
name|mchash
index|[
literal|2
index|]
decl_stmt|;
name|uint16_t
name|mode
decl_stmt|;
name|int
name|count
decl_stmt|;
name|STGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|mode
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|STGE_ReceiveMode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
name|mode
operator||=
name|RM_ReceiveAllFrames
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|!=
literal|0
condition|)
name|mode
operator||=
name|RM_ReceiveMulticast
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_ReceiveMode
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* clear existing filters. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_HashTable0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_HashTable1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the multicast address filter by passing all multicast 	 * addresses through a CRC generator, and then using the low-order 	 * 6 bits as an index into the 64 bit multicast hash table.  The 	 * high order bits select the register, while the rest of the bits 	 * select the bit within the register. 	 */
name|bzero
argument_list|(
name|mchash
argument_list|,
sizeof|sizeof
argument_list|(
name|mchash
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&sc->sc_ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|crc
operator|=
name|ether_crc32_be
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Just want the 6 least significant bits. */
name|crc
operator|&=
literal|0x3f
expr_stmt|;
comment|/* Set the corresponding bit in the hash table. */
name|mchash
index|[
name|crc
operator|>>
literal|5
index|]
operator||=
literal|1
operator|<<
operator|(
name|crc
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mode
operator|&=
operator|~
operator|(
name|RM_ReceiveMulticast
operator||
name|RM_ReceiveAllFrames
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|mode
operator||=
name|RM_ReceiveMulticastHash
expr_stmt|;
else|else
name|mode
operator|&=
operator|~
name|RM_ReceiveMulticastHash
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_HashTable0
argument_list|,
name|mchash
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|STGE_HashTable1
argument_list|,
name|mchash
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|STGE_ReceiveMode
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_int_range
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|,
name|int
name|low
parameter_list|,
name|int
name|high
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|arg1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|value
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|value
operator|<
name|low
operator|||
name|value
operator|>
name|high
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_stge_rxint_nframe
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_int_range
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
name|STGE_RXINT_NFRAME_MIN
argument_list|,
name|STGE_RXINT_NFRAME_MAX
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_stge_rxint_dmawait
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_int_range
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
name|STGE_RXINT_DMAWAIT_MIN
argument_list|,
name|STGE_RXINT_DMAWAIT_MAX
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

