begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Yahoo! Inc.  * Copyright (c) 2011-2015 LSI Corp.  * Copyright (c) 2013-2016 Avago Technologies  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Avago Technologies (LSI) MPT-Fusion Host Adapter FreeBSD  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Communications core for Avago Technologies (LSI) MPT3 */
end_comment

begin_comment
comment|/* TODO Move headers to mprvar */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2_type.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2_ioc.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2_sas.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2_pci.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2_cnfg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2_init.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2_tool.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpr_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mprvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpr_table.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpr_sas.h>
end_include

begin_function_decl
specifier|static
name|int
name|mpr_diag_reset
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_init_queues
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_message_unit_reset
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_transition_operational
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_iocfacts_allocate
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|attaching
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpr_iocfacts_free
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpr_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_send_iocinit
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_alloc_queues
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_alloc_replies
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_alloc_requests
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_alloc_nvme_prp_pages
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_attach_log
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|mpr_complete_command
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpr_dispatch_event
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|uintptr_t
name|data
parameter_list|,
name|MPI2_EVENT_NOTIFICATION_REPLY
modifier|*
name|reply
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpr_config_complete
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpr_periodic
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_reregister_events
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpr_enqueue_request
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_get_iocfacts
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|MPI2_IOC_FACTS_REPLY
modifier|*
name|facts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_wait_db_ack
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|mpr
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"MPR Driver Parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MPR
argument_list|,
literal|"mpr"
argument_list|,
literal|"mpr driver memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Do a "Diagnostic Reset" aka a hard reset.  This should get the chip out of  * any state and back to its initialization state machine.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mpt2_reset_magic
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x0f
block|,
literal|0x04
block|,
literal|0x0b
block|,
literal|0x02
block|,
literal|0x07
block|,
literal|0x0d
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Added this union to smoothly convert le64toh cm->cm_desc.Words.  * Compiler only supports uint64_t to be passed as an argument.  * Otherwise it will through this error:  * "aggregate value used where an integer was expected"  */
end_comment

begin_typedef
typedef|typedef
union|union
name|_reply_descriptor
block|{
name|u64
name|word
decl_stmt|;
struct|struct
block|{
name|u32
name|low
decl_stmt|;
name|u32
name|high
decl_stmt|;
block|}
name|u
struct|;
block|}
name|reply_descriptor
operator|,
name|request_descriptor
typedef|;
end_typedef

begin_comment
comment|/* Rate limit chain-fail messages to 1 per minute */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|mpr_chainfail_interval
init|=
block|{
literal|60
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * sleep_flag can be either CAN_SLEEP or NO_SLEEP.  * If this function is called from process context, it can sleep  * and there is no harm to sleep, in case if this fuction is called  * from Interrupt handler, we can not sleep and need NO_SLEEP flag set.  * based on sleep flags driver will call either msleep, pause or DELAY.  * msleep and pause are of same variant, but pause is used when mpr_mtx  * is not hold by driver.  */
end_comment

begin_function
specifier|static
name|int
name|mpr_diag_reset
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|tries
init|=
literal|0
decl_stmt|;
name|uint8_t
name|first_wait_done
init|=
name|FALSE
decl_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupts */
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* 	 * Force NO_SLEEP for threads prohibited to sleep  	 * e.a Thread from interrupt handler are prohibited to sleep.  	 */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1000029
if|if
condition|(
name|curthread
operator|->
name|td_no_sleeping
condition|)
else|#
directive|else
comment|//__FreeBSD_version< 1000029
if|if
condition|(
name|curthread
operator|->
name|td_pflags
operator|&
name|TDP_NOSLEEPING
condition|)
endif|#
directive|endif
comment|//__FreeBSD_version>= 1000029
name|sleep_flag
operator|=
name|NO_SLEEP
expr_stmt|;
comment|/* Push the magic sequence */
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
while|while
condition|(
name|tries
operator|++
operator|<
literal|20
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mpt2_reset_magic
argument_list|)
condition|;
name|i
operator|++
control|)
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_WRITE_SEQUENCE_OFFSET
argument_list|,
name|mpt2_reset_magic
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* wait 100 msec */
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|)
operator|&&
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|msleep_fake_chan
argument_list|,
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|,
literal|0
argument_list|,
literal|"mprdiag"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
name|pause
argument_list|(
literal|"mprdiag"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
else|else
name|DELAY
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|reg
operator|=
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_DIAGNOSTIC_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|MPI2_DIAG_DIAG_WRITE_ENABLE
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Send the actual reset.  XXX need to refresh the reg? */
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_DIAGNOSTIC_OFFSET
argument_list|,
name|reg
operator||
name|MPI2_DIAG_RESET_ADAPTER
argument_list|)
expr_stmt|;
comment|/* Wait up to 300 seconds in 50ms intervals */
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6000
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Wait 50 msec. If this is the first time through, wait 256 		 * msec to satisfy Diag Reset timing requirements. 		 */
if|if
condition|(
name|first_wait_done
condition|)
block|{
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|)
operator|&&
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|msleep_fake_chan
argument_list|,
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|,
literal|0
argument_list|,
literal|"mprdiag"
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
name|pause
argument_list|(
literal|"mprdiag"
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
else|else
name|DELAY
argument_list|(
literal|50
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DELAY
argument_list|(
literal|256
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|first_wait_done
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 		 * Check for the RESET_ADAPTER bit to be cleared first, then 		 * wait for the RESET state to be cleared, which takes a little 		 * longer. 		 */
name|reg
operator|=
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_DIAGNOSTIC_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|MPI2_DIAG_RESET_ADAPTER
condition|)
block|{
continue|continue;
block|}
name|reg
operator|=
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|MPI2_IOC_STATE_MASK
operator|)
operator|!=
name|MPI2_IOC_STATE_RESET
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_WRITE_SEQUENCE_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_message_unit_reset
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
block|{
name|MPR_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|,
name|MPI2_FUNCTION_IOC_MESSAGE_UNIT_RESET
operator|<<
name|MPI2_DOORBELL_FUNCTION_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpr_wait_db_ack
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
name|sleep_flag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Doorbell handshake failed :<%s>\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_transition_ready
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|,
name|state
decl_stmt|;
name|int
name|error
decl_stmt|,
name|tries
init|=
literal|0
decl_stmt|;
name|int
name|sleep_flags
decl_stmt|;
name|MPR_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If we are in attach call, do not sleep */
name|sleep_flags
operator|=
operator|(
name|sc
operator|->
name|mpr_flags
operator|&
name|MPR_FLAGS_ATTACH_DONE
operator|)
condition|?
name|CAN_SLEEP
else|:
name|NO_SLEEP
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tries
operator|++
operator|<
literal|1200
condition|)
block|{
name|reg
operator|=
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_INIT
argument_list|,
literal|"Doorbell= 0x%x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure the IOC is ready to talk.  If it's not, try 		 * resetting it. 		 */
if|if
condition|(
name|reg
operator|&
name|MPI2_DOORBELL_USED
condition|)
block|{
name|mpr_diag_reset
argument_list|(
name|sc
argument_list|,
name|sleep_flags
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Is the adapter owned by another peer? */
if|if
condition|(
operator|(
name|reg
operator|&
name|MPI2_DOORBELL_WHO_INIT_MASK
operator|)
operator|==
operator|(
name|MPI2_WHOINIT_PCI_PEER
operator|<<
name|MPI2_DOORBELL_WHO_INIT_SHIFT
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"IOC is under the control "
literal|"of another peer host, aborting initialization.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|state
operator|=
name|reg
operator|&
name|MPI2_IOC_STATE_MASK
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|MPI2_IOC_STATE_READY
condition|)
block|{
comment|/* Ready to go! */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|MPI2_IOC_STATE_FAULT
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"IOC in fault state 0x%x\n"
argument_list|,
name|state
operator|&
name|MPI2_DOORBELL_FAULT_CODE_MASK
argument_list|)
expr_stmt|;
name|mpr_diag_reset
argument_list|(
name|sc
argument_list|,
name|sleep_flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|MPI2_IOC_STATE_OPERATIONAL
condition|)
block|{
comment|/* Need to take ownership */
name|mpr_message_unit_reset
argument_list|(
name|sc
argument_list|,
name|sleep_flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|MPI2_IOC_STATE_RESET
condition|)
block|{
comment|/* Wait a bit, IOC might be in transition */
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"IOC in unexpected reset state\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"IOC in unknown state 0x%x\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Wait 50ms for things to settle down. */
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot transition IOC to ready\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_transition_operational
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|,
name|state
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MPR_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_INIT
argument_list|,
literal|"Doorbell= 0x%x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|state
operator|=
name|reg
operator|&
name|MPI2_IOC_STATE_MASK
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|MPI2_IOC_STATE_READY
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|mpr_transition_ready
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"%s failed to transition ready\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|error
operator|=
name|mpr_send_iocinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called during attach and when re-initializing due to a Diag Reset.  * IOC Facts is used to allocate many of the structures needed by the driver.  * If called from attach, de-allocation is not required because the driver has  * not allocated any structures yet, but if called from a Diag Reset, previously  * allocated structures based on IOC Facts will need to be freed and re-  * allocated bases on the latest IOC Facts.  */
end_comment

begin_function
specifier|static
name|int
name|mpr_iocfacts_allocate
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|attaching
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|Mpi2IOCFactsReply_t
name|saved_facts
decl_stmt|;
name|uint8_t
name|saved_mode
decl_stmt|,
name|reallocating
decl_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Save old IOC Facts and then only reallocate if Facts have changed */
if|if
condition|(
operator|!
name|attaching
condition|)
block|{
name|bcopy
argument_list|(
name|sc
operator|->
name|facts
argument_list|,
operator|&
name|saved_facts
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_IOC_FACTS_REPLY
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get IOC Facts.  In all cases throughout this function, panic if doing 	 * a re-initialization and only return the error if attaching so the OS 	 * can handle it. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|mpr_get_iocfacts
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|facts
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|attaching
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"%s failed to get IOC Facts "
literal|"with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"%s failed to get IOC Facts with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
name|mpr_print_iocfacts
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|facts
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"%02d.%02d.%02d.%02d"
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|FWVersion
operator|.
name|Struct
operator|.
name|Major
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|FWVersion
operator|.
name|Struct
operator|.
name|Minor
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|FWVersion
operator|.
name|Struct
operator|.
name|Unit
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|FWVersion
operator|.
name|Struct
operator|.
name|Dev
argument_list|)
expr_stmt|;
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"Firmware: %s, Driver: %s\n"
argument_list|,
name|sc
operator|->
name|fw_version
argument_list|,
name|MPR_DRIVER_VERSION
argument_list|)
expr_stmt|;
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"IOCCapabilities: %b\n"
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
argument_list|,
literal|"\20"
literal|"\3ScsiTaskFull"
literal|"\4DiagTrace"
literal|"\5SnapBuf"
literal|"\6ExtBuf"
literal|"\7EEDP"
literal|"\10BiDirTarg"
literal|"\11Multicast"
literal|"\14TransRetry"
literal|"\15IR"
literal|"\16EventReplay"
literal|"\17RaidAccel"
literal|"\20MSIXIndex"
literal|"\21HostDisc"
literal|"\22FastPath"
literal|"\23RDPQArray"
literal|"\24AtomicReqDesc"
literal|"\25PCIeSRIOV"
argument_list|)
expr_stmt|;
comment|/* 	 * If the chip doesn't support event replay then a hard reset will be 	 * required to trigger a full discovery.  Do the reset here then 	 * retransition to Ready.  A hard reset might have already been done, 	 * but it doesn't hurt to do it again.  Only do this if attaching, not 	 * for a Diag Reset. 	 */
if|if
condition|(
name|attaching
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_EVENT_REPLAY
operator|)
operator|==
literal|0
condition|)
block|{
name|mpr_diag_reset
argument_list|(
name|sc
argument_list|,
name|NO_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mpr_transition_ready
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"%s failed to "
literal|"transition to ready with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * Set flag if IR Firmware is loaded.  If the RAID Capability has 	 * changed from the previous IOC Facts, log a warning, but only if 	 * checking this after a Diag Reset and not during attach. 	 */
name|saved_mode
operator|=
name|sc
operator|->
name|ir_firmware
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_INTEGRATED_RAID
condition|)
name|sc
operator|->
name|ir_firmware
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|attaching
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ir_firmware
operator|!=
name|saved_mode
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"%s new IR/IT mode in IOC "
literal|"Facts does not match previous mode\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Only deallocate and reallocate if relevant IOC Facts have changed */
name|reallocating
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|attaching
operator|)
operator|&&
operator|(
operator|(
name|saved_facts
operator|.
name|MsgVersion
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MsgVersion
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|HeaderVersion
operator|!=
name|sc
operator|->
name|facts
operator|->
name|HeaderVersion
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|MaxChainDepth
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MaxChainDepth
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|RequestCredit
operator|!=
name|sc
operator|->
name|facts
operator|->
name|RequestCredit
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|ProductID
operator|!=
name|sc
operator|->
name|facts
operator|->
name|ProductID
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|IOCCapabilities
operator|!=
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|IOCRequestFrameSize
operator|!=
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|IOCMaxChainSegmentSize
operator|!=
name|sc
operator|->
name|facts
operator|->
name|IOCMaxChainSegmentSize
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|MaxTargets
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MaxTargets
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|MaxSasExpanders
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MaxSasExpanders
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|MaxEnclosures
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MaxEnclosures
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|HighPriorityCredit
operator|!=
name|sc
operator|->
name|facts
operator|->
name|HighPriorityCredit
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|MaxReplyDescriptorPostQueueDepth
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MaxReplyDescriptorPostQueueDepth
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|ReplyFrameSize
operator|!=
name|sc
operator|->
name|facts
operator|->
name|ReplyFrameSize
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|MaxVolumes
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MaxVolumes
operator|)
operator|||
operator|(
name|saved_facts
operator|.
name|MaxPersistentEntries
operator|!=
name|sc
operator|->
name|facts
operator|->
name|MaxPersistentEntries
operator|)
operator|)
condition|)
block|{
name|reallocating
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	 * Some things should be done if attaching or re-allocating after a Diag 	 * Reset, but are not needed after a Diag Reset if the FW has not 	 * changed. 	 */
if|if
condition|(
name|attaching
operator|||
name|reallocating
condition|)
block|{
comment|/* 		 * Check if controller supports FW diag buffers and set flag to 		 * enable each type. 		 */
if|if
condition|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER
condition|)
name|sc
operator|->
name|fw_diag_buffer_list
index|[
name|MPI2_DIAG_BUF_TYPE_TRACE
index|]
operator|.
name|enabled
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_SNAPSHOT_BUFFER
condition|)
name|sc
operator|->
name|fw_diag_buffer_list
index|[
name|MPI2_DIAG_BUF_TYPE_SNAPSHOT
index|]
operator|.
name|enabled
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_EXTENDED_BUFFER
condition|)
name|sc
operator|->
name|fw_diag_buffer_list
index|[
name|MPI2_DIAG_BUF_TYPE_EXTENDED
index|]
operator|.
name|enabled
operator|=
name|TRUE
expr_stmt|;
comment|/* 		 * Set flags for some supported items. 		 */
if|if
condition|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_EEDP
condition|)
name|sc
operator|->
name|eedp_enabled
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI2_IOCFACTS_CAPABILITY_TLR
condition|)
name|sc
operator|->
name|control_TLR
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|facts
operator|->
name|IOCCapabilities
operator|&
name|MPI26_IOCFACTS_CAPABILITY_ATOMIC_REQ
condition|)
name|sc
operator|->
name|atomic_desc_capable
operator|=
name|TRUE
expr_stmt|;
comment|/* 		 * Size the queues. Since the reply queues always need one free 		 * entry, we'll just deduct one reply message here. 		 */
name|sc
operator|->
name|num_reqs
operator|=
name|MIN
argument_list|(
name|MPR_REQ_FRAMES
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|RequestCredit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_replies
operator|=
name|MIN
argument_list|(
name|MPR_REPLY_FRAMES
operator|+
name|MPR_EVT_REPLY_FRAMES
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|MaxReplyDescriptorPostQueueDepth
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Initialize all Tail Queues 		 */
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|req_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|high_priority_req_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|chain_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|prp_page_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|tm_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If doing a Diag Reset and the FW is significantly different 	 * (reallocating will be set above in IOC Facts comparison), then all 	 * buffers based on the IOC Facts will need to be freed before they are 	 * reallocated. 	 */
if|if
condition|(
name|reallocating
condition|)
block|{
name|mpr_iocfacts_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mprsas_realloc_targets
argument_list|(
name|sc
argument_list|,
name|saved_facts
operator|.
name|MaxTargets
operator|+
name|saved_facts
operator|.
name|MaxVolumes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Any deallocation has been completed.  Now start reallocating 	 * if needed.  Will only need to reallocate if attaching or if the new 	 * IOC Facts are different from the previous IOC Facts after a Diag 	 * Reset. Targets have already been allocated above if needed. 	 */
if|if
condition|(
name|attaching
operator|||
name|reallocating
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|error
operator|=
name|mpr_alloc_queues
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mpr_alloc_replies
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mpr_alloc_requests
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|attaching
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"%s failed to alloc "
literal|"queues with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mpr_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"%s failed to alloc queues with error "
literal|"%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Always initialize the queues */
name|bzero
argument_list|(
name|sc
operator|->
name|free_queue
argument_list|,
name|sc
operator|->
name|fqdepth
operator|*
literal|4
argument_list|)
expr_stmt|;
name|mpr_init_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Always get the chip out of the reset state, but only panic if not 	 * attaching.  If attaching and there is an error, that is handled by 	 * the OS. 	 */
name|error
operator|=
name|mpr_transition_operational
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|attaching
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s failed to transition to operational "
literal|"with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mpr_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"%s failed to transition to operational with "
literal|"error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Finish the queue initialization. 	 * These are set here instead of in mpr_init_queues() because the 	 * IOC resets these values during the state transition in 	 * mpr_transition_operational().  The free index is set to 1 	 * because the corresponding index in the IOC is set to 0, and the 	 * IOC treats the queues as full if both are set to the same value. 	 * Hence the reason that the queue can't hold all of the possible 	 * replies. 	 */
name|sc
operator|->
name|replypostindex
operator|=
literal|0
expr_stmt|;
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REPLY_FREE_HOST_INDEX_OFFSET
argument_list|,
name|sc
operator|->
name|replyfreeindex
argument_list|)
expr_stmt|;
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REPLY_POST_HOST_INDEX_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Attach the subsystems so they can prepare their event masks. 	 */
comment|/* XXX Should be dynamic so that IM/IR and user modules can attach */
if|if
condition|(
name|attaching
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|error
operator|=
name|mpr_attach_log
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mpr_attach_sas
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mpr_attach_user
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s failed to attach all subsystems: "
literal|"error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mpr_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|mpr_pci_setup_interrupts
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s failed to setup interrupts\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mpr_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called if memory is being free (during detach for example) and when  * buffers need to be reallocated due to a Diag Reset.  */
end_comment

begin_function
specifier|static
name|void
name|mpr_iocfacts_free
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mpr_command
modifier|*
name|cm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|free_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|,
name|sc
operator|->
name|queues_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|free_queue
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|,
name|sc
operator|->
name|free_queue
argument_list|,
name|sc
operator|->
name|queues_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|queues_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chain_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|,
name|sc
operator|->
name|chain_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chain_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|,
name|sc
operator|->
name|chain_frames
argument_list|,
name|sc
operator|->
name|chain_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chain_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sense_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|,
name|sc
operator|->
name|sense_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sense_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|,
name|sc
operator|->
name|sense_frames
argument_list|,
name|sc
operator|->
name|sense_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sense_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|prp_page_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|prp_page_dmat
argument_list|,
name|sc
operator|->
name|prp_page_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|prp_pages
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|prp_page_dmat
argument_list|,
name|sc
operator|->
name|prp_pages
argument_list|,
name|sc
operator|->
name|prp_page_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|prp_page_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|prp_page_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reply_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|,
name|sc
operator|->
name|reply_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reply_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|,
name|sc
operator|->
name|reply_frames
argument_list|,
name|sc
operator|->
name|reply_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reply_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|req_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|,
name|sc
operator|->
name|req_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|req_frames
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|,
name|sc
operator|->
name|req_frames
argument_list|,
name|sc
operator|->
name|req_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|req_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chains
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|chains
argument_list|,
name|M_MPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|prps
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|prps
argument_list|,
name|M_MPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|commands
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|num_reqs
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|commands
index|[
name|i
index|]
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|commands
argument_list|,
name|M_MPR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|buffer_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * The terms diag reset and hard reset are used interchangeably in the MPI  * docs to mean resetting the controller chip.  In this code diag reset  * cleans everything up, and the hard reset function just sends the reset  * sequence to the chip.  This should probably be refactored so that every  * subsystem gets a reset notification of some sort, and can clean up  * appropriately.  */
end_comment

begin_function
name|int
name|mpr_reinit
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|mprsas_softc
modifier|*
name|sassc
decl_stmt|;
name|sassc
operator|=
name|sc
operator|->
name|sassc
expr_stmt|;
name|MPR_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mpr_flags
operator|&
name|MPR_FLAGS_DIAGRESET
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_INIT
argument_list|,
literal|"%s reset already in progress\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_INFO
argument_list|,
literal|"Reinitializing controller,\n"
argument_list|)
expr_stmt|;
comment|/* make sure the completion callbacks can recognize they're getting 	 * a NULL cm_reply due to a reset. 	 */
name|sc
operator|->
name|mpr_flags
operator||=
name|MPR_FLAGS_DIAGRESET
expr_stmt|;
comment|/* 	 * Mask interrupts here. 	 */
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_INIT
argument_list|,
literal|"%s mask interrupts\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mpr_mask_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mpr_diag_reset
argument_list|(
name|sc
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"%s hard reset failed with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the PCI state, including the MSI-X registers */
name|mpr_pci_restore
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Give the I/O subsystem special priority to get itself prepared */
name|mprsas_handle_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Get IOC Facts and allocate all structures based on this information. 	 * The attach function will also call mpr_iocfacts_allocate at startup. 	 * If relevant values have changed in IOC Facts, this function will free 	 * all of the memory based on IOC Facts and reallocate that memory. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|mpr_iocfacts_allocate
argument_list|(
name|sc
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"%s IOC Facts based allocation failed with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Mapping structures will be re-allocated after getting IOC Page8, so 	 * free these structures here. 	 */
name|mpr_mapping_exit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * The static page function currently read is IOC Page8.  Others can be 	 * added in future.  It's possible that the values in IOC Page8 have 	 * changed after a Diag Reset due to user modification, so always read 	 * these.  Interrupts are masked, so unmask them before getting config 	 * pages. 	 */
name|mpr_unmask_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mpr_flags
operator|&=
operator|~
name|MPR_FLAGS_DIAGRESET
expr_stmt|;
name|mpr_base_static_config_pages
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Some mapping info is based in IOC Page8 data, so re-initialize the 	 * mapping tables. 	 */
name|mpr_mapping_initialize
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Restart will reload the event masks clobbered by the reset, and 	 * then enable the port. 	 */
name|mpr_reregister_events
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* the end of discovery will release the simq, so we're done. */
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_INFO
argument_list|,
literal|"%s finished sc %p post %u free %u\n"
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|replypostindex
argument_list|,
name|sc
operator|->
name|replyfreeindex
argument_list|)
expr_stmt|;
name|mprsas_release_simq_reinit
argument_list|(
name|sassc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Wait for the chip to ACK a word that we've put into its FIFO   * Wait for<timeout> seconds. In single loop wait for busy loop  * for 500 microseconds.  * Total is [ 0.5 * (2000 *<timeout>) ] in miliseconds.  * */
end_comment

begin_function
specifier|static
name|int
name|mpr_wait_db_ack
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
block|{
name|u32
name|cntdn
decl_stmt|,
name|count
decl_stmt|;
name|u32
name|int_status
decl_stmt|;
name|u32
name|doorbell
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|cntdn
operator|=
operator|(
name|sleep_flag
operator|==
name|CAN_SLEEP
operator|)
condition|?
literal|1000
operator|*
name|timeout
else|:
literal|2000
operator|*
name|timeout
expr_stmt|;
do|do
block|{
name|int_status
operator|=
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|int_status
operator|&
name|MPI2_HIS_SYS2IOC_DB_STATUS
operator|)
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_INIT
argument_list|,
literal|"%s: successful count(%d), "
literal|"timeout(%d)\n"
argument_list|,
name|__func__
argument_list|,
name|count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|int_status
operator|&
name|MPI2_HIS_IOC2SYS_DB_STATUS
condition|)
block|{
name|doorbell
operator|=
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|doorbell
operator|&
name|MPI2_IOC_STATE_MASK
operator|)
operator|==
name|MPI2_IOC_STATE_FAULT
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"fault_state(0x%04x)!\n"
argument_list|,
name|doorbell
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|int_status
operator|==
literal|0xFFFFFFFF
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * If it can sleep, sleep for 1 milisecond, else busy loop for  		 * 0.5 milisecond 		 */
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|)
operator|&&
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|msleep_fake_chan
argument_list|,
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|,
literal|0
argument_list|,
literal|"mprdba"
argument_list|,
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
name|pause
argument_list|(
literal|"mprdba"
argument_list|,
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|cntdn
condition|)
do|;
name|out
label|:
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"%s: failed due to timeout count(%d), "
literal|"int_status(%x)!\n"
argument_list|,
name|__func__
argument_list|,
name|count
argument_list|,
name|int_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Wait for the chip to signal that the next word in its FIFO can be fetched */
end_comment

begin_function
specifier|static
name|int
name|mpr_wait_db_int
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|retry
decl_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
name|MPR_DB_MAX_WAIT
condition|;
name|retry
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|)
operator|&
name|MPI2_HIS_IOC2SYS_DB_STATUS
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Step through the synchronous command state machine, i.e. "Doorbell mode" */
end_comment

begin_function
specifier|static
name|int
name|mpr_request_sync
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|req
parameter_list|,
name|MPI2_DEFAULT_REPLY
modifier|*
name|reply
parameter_list|,
name|int
name|req_sz
parameter_list|,
name|int
name|reply_sz
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|uint32_t
modifier|*
name|data32
decl_stmt|;
name|uint16_t
modifier|*
name|data16
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|ioc_sz
decl_stmt|,
name|residual
decl_stmt|;
name|int
name|sleep_flags
init|=
name|CAN_SLEEP
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1000029
if|if
condition|(
name|curthread
operator|->
name|td_no_sleeping
condition|)
else|#
directive|else
comment|//__FreeBSD_version< 1000029
if|if
condition|(
name|curthread
operator|->
name|td_pflags
operator|&
name|TDP_NOSLEEPING
condition|)
endif|#
directive|endif
comment|//__FreeBSD_version>= 1000029
name|sleep_flags
operator|=
name|NO_SLEEP
expr_stmt|;
comment|/* Step 1 */
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Step 2 */
if|if
condition|(
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_USED
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Step 3 	 * Announce that a message is coming through the doorbell.  Messages 	 * are pushed at 32bit words, so round up if needed. 	 */
name|count
operator|=
operator|(
name|req_sz
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|,
operator|(
name|MPI2_FUNCTION_HANDSHAKE
operator|<<
name|MPI2_DOORBELL_FUNCTION_SHIFT
operator|)
operator||
operator|(
name|count
operator|<<
name|MPI2_DOORBELL_ADD_DWORDS_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Step 4 */
if|if
condition|(
name|mpr_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|||
operator|(
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_USED
operator|)
operator|==
literal|0
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Doorbell failed to activate\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpr_wait_db_ack
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
name|sleep_flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Doorbell handshake failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Step 5 */
comment|/* Clock out the message data synchronously in 32-bit dwords*/
name|data32
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|req
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|,
name|htole32
argument_list|(
name|data32
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpr_wait_db_ack
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
name|sleep_flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Timeout while writing doorbell\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/* Step 6 */
comment|/* Clock in the reply in 16-bit words.  The total length of the 	 * message is always in the 4th byte, so clock out the first 2 words 	 * manually, then loop the rest. 	 */
name|data16
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|reply
expr_stmt|;
if|if
condition|(
name|mpr_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Timeout reading doorbell 0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|data16
index|[
literal|0
index|]
operator|=
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_DATA_MASK
expr_stmt|;
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpr_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Timeout reading doorbell 1\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|data16
index|[
literal|1
index|]
operator|=
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_DATA_MASK
expr_stmt|;
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Number of 32bit words in the message */
name|ioc_sz
operator|=
name|reply
operator|->
name|MsgLength
expr_stmt|;
comment|/* 	 * Figure out how many 16bit words to clock in without overrunning. 	 * The precision loss with dividing reply_sz can safely be 	 * ignored because the messages can only be multiples of 32bits. 	 */
name|residual
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
operator|(
name|reply_sz
operator|/
literal|4
operator|)
argument_list|,
name|ioc_sz
argument_list|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|ioc_sz
operator|*
literal|2
condition|)
block|{
name|residual
operator|=
name|ioc_sz
operator|*
literal|2
operator|-
name|count
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_ERROR
argument_list|,
literal|"Driver error, throwing away %d "
literal|"residual message words\n"
argument_list|,
name|residual
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mpr_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Timeout reading doorbell %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|data16
index|[
name|i
index|]
operator|=
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_DATA_MASK
expr_stmt|;
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Pull out residual words that won't fit into the provided buffer. 	 * This keeps the chip from hanging due to a driver programming 	 * error. 	 */
while|while
condition|(
name|residual
operator|--
condition|)
block|{
if|if
condition|(
name|mpr_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Timeout reading doorbell\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
comment|/* Step 7 */
if|if
condition|(
name|mpr_wait_db_int
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Timeout waiting to exit doorbell\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
operator|&
name|MPI2_DOORBELL_USED
condition|)
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Warning, doorbell still active\n"
argument_list|)
expr_stmt|;
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpr_enqueue_request
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|)
block|{
name|request_descriptor
name|rd
decl_stmt|;
name|MPR_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"SMID %u cm %p ccb %p\n"
argument_list|,
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|SMID
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mpr_flags
operator|&
name|MPR_FLAGS_ATTACH_DONE
operator|&&
operator|!
operator|(
name|sc
operator|->
name|mpr_flags
operator|&
name|MPR_FLAGS_SHUTDOWN
operator|)
condition|)
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|sc
operator|->
name|io_cmds_active
operator|>
name|sc
operator|->
name|io_cmds_highwater
condition|)
name|sc
operator|->
name|io_cmds_highwater
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|atomic_desc_capable
condition|)
block|{
name|rd
operator|.
name|u
operator|.
name|low
operator|=
name|cm
operator|->
name|cm_desc
operator|.
name|Words
operator|.
name|Low
expr_stmt|;
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI26_ATOMIC_REQUEST_DESCRIPTOR_POST_OFFSET
argument_list|,
name|rd
operator|.
name|u
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rd
operator|.
name|u
operator|.
name|low
operator|=
name|cm
operator|->
name|cm_desc
operator|.
name|Words
operator|.
name|Low
expr_stmt|;
name|rd
operator|.
name|u
operator|.
name|high
operator|=
name|cm
operator|->
name|cm_desc
operator|.
name|Words
operator|.
name|High
expr_stmt|;
name|rd
operator|.
name|word
operator|=
name|htole64
argument_list|(
name|rd
operator|.
name|word
argument_list|)
expr_stmt|;
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REQUEST_DESCRIPTOR_POST_LOW_OFFSET
argument_list|,
name|rd
operator|.
name|u
operator|.
name|low
argument_list|)
expr_stmt|;
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REQUEST_DESCRIPTOR_POST_HIGH_OFFSET
argument_list|,
name|rd
operator|.
name|u
operator|.
name|high
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Just the FACTS, ma'am.  */
end_comment

begin_function
specifier|static
name|int
name|mpr_get_iocfacts
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|MPI2_IOC_FACTS_REPLY
modifier|*
name|facts
parameter_list|)
block|{
name|MPI2_DEFAULT_REPLY
modifier|*
name|reply
decl_stmt|;
name|MPI2_IOC_FACTS_REQUEST
name|request
decl_stmt|;
name|int
name|error
decl_stmt|,
name|req_sz
decl_stmt|,
name|reply_sz
decl_stmt|;
name|MPR_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|req_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_IOC_FACTS_REQUEST
argument_list|)
expr_stmt|;
name|reply_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_IOC_FACTS_REPLY
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_DEFAULT_REPLY
operator|*
operator|)
name|facts
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|request
argument_list|,
name|req_sz
argument_list|)
expr_stmt|;
name|request
operator|.
name|Function
operator|=
name|MPI2_FUNCTION_IOC_FACTS
expr_stmt|;
name|error
operator|=
name|mpr_request_sync
argument_list|(
name|sc
argument_list|,
operator|&
name|request
argument_list|,
name|reply
argument_list|,
name|req_sz
argument_list|,
name|reply_sz
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_send_iocinit
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|MPI2_IOC_INIT_REQUEST
name|init
decl_stmt|;
name|MPI2_DEFAULT_REPLY
name|reply
decl_stmt|;
name|int
name|req_sz
decl_stmt|,
name|reply_sz
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|uint64_t
name|time_in_msec
decl_stmt|;
name|MPR_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|req_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_IOC_INIT_REQUEST
argument_list|)
expr_stmt|;
name|reply_sz
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_IOC_INIT_REPLY
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|init
argument_list|,
name|req_sz
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|reply
argument_list|,
name|reply_sz
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the init block.  Note that most addresses are 	 * deliberately in the lower 32bits of memory.  This is a micro- 	 * optimzation for PCI/PCIX, though it's not clear if it helps PCIe. 	 */
name|init
operator|.
name|Function
operator|=
name|MPI2_FUNCTION_IOC_INIT
expr_stmt|;
name|init
operator|.
name|WhoInit
operator|=
name|MPI2_WHOINIT_HOST_DRIVER
expr_stmt|;
name|init
operator|.
name|MsgVersion
operator|=
name|htole16
argument_list|(
name|MPI2_VERSION
argument_list|)
expr_stmt|;
name|init
operator|.
name|HeaderVersion
operator|=
name|htole16
argument_list|(
name|MPI2_HEADER_VERSION
argument_list|)
expr_stmt|;
name|init
operator|.
name|SystemRequestFrameSize
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
argument_list|)
expr_stmt|;
name|init
operator|.
name|ReplyDescriptorPostQueueDepth
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|pqdepth
argument_list|)
expr_stmt|;
name|init
operator|.
name|ReplyFreeQueueDepth
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|fqdepth
argument_list|)
expr_stmt|;
name|init
operator|.
name|SenseBufferAddressHigh
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|SystemReplyAddressHigh
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|SystemRequestFrameBaseAddress
operator|.
name|High
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|SystemRequestFrameBaseAddress
operator|.
name|Low
operator|=
name|htole32
argument_list|(
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|req_busaddr
argument_list|)
expr_stmt|;
name|init
operator|.
name|ReplyDescriptorPostQueueAddress
operator|.
name|High
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|ReplyDescriptorPostQueueAddress
operator|.
name|Low
operator|=
name|htole32
argument_list|(
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|post_busaddr
argument_list|)
expr_stmt|;
name|init
operator|.
name|ReplyFreeQueueAddress
operator|.
name|High
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|ReplyFreeQueueAddress
operator|.
name|Low
operator|=
name|htole32
argument_list|(
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|free_busaddr
argument_list|)
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|time_in_msec
operator|=
operator|(
name|now
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|now
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
expr_stmt|;
name|init
operator|.
name|TimeStamp
operator|.
name|High
operator|=
name|htole32
argument_list|(
operator|(
name|time_in_msec
operator|>>
literal|32
operator|)
operator|&
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|init
operator|.
name|TimeStamp
operator|.
name|Low
operator|=
name|htole32
argument_list|(
name|time_in_msec
operator|&
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|init
operator|.
name|HostPageSize
operator|=
name|HOST_PAGE_SIZE_4K
expr_stmt|;
name|error
operator|=
name|mpr_request_sync
argument_list|(
name|sc
argument_list|,
operator|&
name|init
argument_list|,
operator|&
name|reply
argument_list|,
name|req_sz
argument_list|,
name|reply_sz
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reply
operator|.
name|IOCStatus
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_INIT
argument_list|,
literal|"IOCInit status= 0x%x\n"
argument_list|,
name|reply
operator|.
name|IOCStatus
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mpr_memaddr_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_alloc_queues
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_addr_t
name|queues_busaddr
decl_stmt|;
name|uint8_t
modifier|*
name|queues
decl_stmt|;
name|int
name|qsize
decl_stmt|,
name|fqsize
decl_stmt|,
name|pqsize
decl_stmt|;
comment|/* 	 * The reply free queue contains 4 byte entries in multiples of 16 and 	 * aligned on a 16 byte boundary. There must always be an unused entry. 	 * This queue supplies fresh reply frames for the firmware to use. 	 * 	 * The reply descriptor post queue contains 8 byte entries in 	 * multiples of 16 and aligned on a 16 byte boundary.  This queue 	 * contains filled-in reply frames sent from the firmware to the host. 	 * 	 * These two queues are allocated together for simplicity. 	 */
name|sc
operator|->
name|fqdepth
operator|=
name|roundup2
argument_list|(
name|sc
operator|->
name|num_replies
operator|+
literal|1
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pqdepth
operator|=
name|roundup2
argument_list|(
name|sc
operator|->
name|num_replies
operator|+
literal|1
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|fqsize
operator|=
name|sc
operator|->
name|fqdepth
operator|*
literal|4
expr_stmt|;
name|pqsize
operator|=
name|sc
operator|->
name|pqdepth
operator|*
literal|8
expr_stmt|;
name|qsize
operator|=
name|fqsize
operator|+
name|pqsize
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mpr_parent_dmat
argument_list|,
comment|/* parent */
literal|16
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|qsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|qsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|queues_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate queues DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|queues
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|queues_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate queues memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|queues
argument_list|,
name|qsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|queues_dmat
argument_list|,
name|sc
operator|->
name|queues_map
argument_list|,
name|queues
argument_list|,
name|qsize
argument_list|,
name|mpr_memaddr_cb
argument_list|,
operator|&
name|queues_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|free_queue
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|queues
expr_stmt|;
name|sc
operator|->
name|free_busaddr
operator|=
name|queues_busaddr
expr_stmt|;
name|sc
operator|->
name|post_queue
operator|=
operator|(
name|MPI2_REPLY_DESCRIPTORS_UNION
operator|*
operator|)
operator|(
name|queues
operator|+
name|fqsize
operator|)
expr_stmt|;
name|sc
operator|->
name|post_busaddr
operator|=
name|queues_busaddr
operator|+
name|fqsize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_alloc_replies
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rsize
decl_stmt|,
name|num_replies
decl_stmt|;
comment|/* 	 * sc->num_replies should be one less than sc->fqdepth.  We need to 	 * allocate space for sc->fqdepth replies, but only sc->num_replies 	 * replies can be used at once. 	 */
name|num_replies
operator|=
name|max
argument_list|(
name|sc
operator|->
name|fqdepth
argument_list|,
name|sc
operator|->
name|num_replies
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|sc
operator|->
name|facts
operator|->
name|ReplyFrameSize
operator|*
name|num_replies
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mpr_parent_dmat
argument_list|,
comment|/* parent */
literal|4
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|rsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|rsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|reply_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate replies DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|reply_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|reply_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate replies memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|reply_frames
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|reply_dmat
argument_list|,
name|sc
operator|->
name|reply_map
argument_list|,
name|sc
operator|->
name|reply_frames
argument_list|,
name|rsize
argument_list|,
name|mpr_memaddr_cb
argument_list|,
operator|&
name|sc
operator|->
name|reply_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_alloc_requests
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mpr_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mpr_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rsize
decl_stmt|,
name|nsegs
decl_stmt|;
name|rsize
operator|=
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
name|sc
operator|->
name|num_reqs
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mpr_parent_dmat
argument_list|,
comment|/* parent */
literal|16
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|rsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|rsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|req_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate request DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|req_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|req_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate request memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|req_frames
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|req_dmat
argument_list|,
name|sc
operator|->
name|req_map
argument_list|,
name|sc
operator|->
name|req_frames
argument_list|,
name|rsize
argument_list|,
name|mpr_memaddr_cb
argument_list|,
operator|&
name|sc
operator|->
name|req_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Gen3 and beyond uses the IOCMaxChainSegmentSize from IOC Facts to 	 * get the size of a Chain Frame.  Previous versions use the size as a 	 * Request Frame for the Chain Frame size.  If IOCMaxChainSegmentSize 	 * is 0, use the default value.  The IOCMaxChainSegmentSize is the 	 * number of 16-byte elelements that can fit in a Chain Frame, which is 	 * the size of an IEEE Simple SGE. 	 */
if|if
condition|(
name|sc
operator|->
name|facts
operator|->
name|MsgVersion
operator|>=
name|MPI2_VERSION_02_05
condition|)
block|{
name|sc
operator|->
name|chain_seg_size
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|facts
operator|->
name|IOCMaxChainSegmentSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chain_seg_size
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|chain_frame_size
operator|=
name|MPR_DEFAULT_CHAIN_SEG_SIZE
operator|*
name|MPR_MAX_CHAIN_ELEMENT_SIZE
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|chain_frame_size
operator|=
name|sc
operator|->
name|chain_seg_size
operator|*
name|MPR_MAX_CHAIN_ELEMENT_SIZE
expr_stmt|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|chain_frame_size
operator|=
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
expr_stmt|;
block|}
name|rsize
operator|=
name|sc
operator|->
name|chain_frame_size
operator|*
name|sc
operator|->
name|max_chains
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mpr_parent_dmat
argument_list|,
comment|/* parent */
literal|16
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|rsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|rsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|chain_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate chain DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|chain_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|chain_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate chain memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|chain_frames
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|chain_dmat
argument_list|,
name|sc
operator|->
name|chain_map
argument_list|,
name|sc
operator|->
name|chain_frames
argument_list|,
name|rsize
argument_list|,
name|mpr_memaddr_cb
argument_list|,
operator|&
name|sc
operator|->
name|chain_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|MPR_SENSE_LEN
operator|*
name|sc
operator|->
name|num_reqs
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mpr_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|rsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|rsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|sense_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate sense DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sense_frames
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|sense_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate sense memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|sense_frames
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sense_dmat
argument_list|,
name|sc
operator|->
name|sense_map
argument_list|,
name|sc
operator|->
name|sense_frames
argument_list|,
name|rsize
argument_list|,
name|mpr_memaddr_cb
argument_list|,
operator|&
name|sc
operator|->
name|sense_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|chains
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mpr_chain
argument_list|)
operator|*
name|sc
operator|->
name|max_chains
argument_list|,
name|M_MPR
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|chains
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate memory %s %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|max_chains
condition|;
name|i
operator|++
control|)
block|{
name|chain
operator|=
operator|&
name|sc
operator|->
name|chains
index|[
name|i
index|]
expr_stmt|;
name|chain
operator|->
name|chain
operator|=
operator|(
name|MPI2_SGE_IO_UNION
operator|*
operator|)
operator|(
name|sc
operator|->
name|chain_frames
operator|+
name|i
operator|*
name|sc
operator|->
name|chain_frame_size
operator|)
expr_stmt|;
name|chain
operator|->
name|chain_busaddr
operator|=
name|sc
operator|->
name|chain_busaddr
operator|+
name|i
operator|*
name|sc
operator|->
name|chain_frame_size
expr_stmt|;
name|mpr_free_chain
argument_list|(
name|sc
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|sc
operator|->
name|chain_free_lowwater
operator|++
expr_stmt|;
block|}
comment|/* 	 * Allocate NVMe PRP Pages for NVMe SGL support only if the FW supports 	 * these devices. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|facts
operator|->
name|MsgVersion
operator|>=
name|MPI2_VERSION_02_06
operator|)
operator|&&
operator|(
name|sc
operator|->
name|facts
operator|->
name|ProtocolFlags
operator|&
name|MPI2_IOCFACTS_PROTOCOL_NVME_DEVICES
operator|)
condition|)
block|{
if|if
condition|(
name|mpr_alloc_nvme_prp_pages
argument_list|(
name|sc
argument_list|)
operator|==
name|ENOMEM
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* XXX Need to pick a more precise value */
name|nsegs
operator|=
operator|(
name|MAXPHYS
operator|/
name|PAGE_SIZE
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mpr_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
name|nsegs
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|busdma_lock_mutex
argument_list|,
comment|/* lockfunc */
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|,
comment|/* lockarg */
operator|&
name|sc
operator|->
name|buffer_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate buffer DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * SMID 0 cannot be used as a free command per the firmware spec. 	 * Just drop that command instead of risking accounting bugs. 	 */
name|sc
operator|->
name|commands
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mpr_command
argument_list|)
operator|*
name|sc
operator|->
name|num_reqs
argument_list|,
name|M_MPR
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|commands
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate memory %s %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|num_reqs
condition|;
name|i
operator|++
control|)
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|commands
index|[
name|i
index|]
expr_stmt|;
name|cm
operator|->
name|cm_req
operator|=
name|sc
operator|->
name|req_frames
operator|+
name|i
operator|*
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_req_busaddr
operator|=
name|sc
operator|->
name|req_busaddr
operator|+
name|i
operator|*
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_sense
operator|=
operator|&
name|sc
operator|->
name|sense_frames
index|[
name|i
index|]
expr_stmt|;
name|cm
operator|->
name|cm_sense_busaddr
operator|=
name|sc
operator|->
name|sense_busaddr
operator|+
name|i
operator|*
name|MPR_SENSE_LEN
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|SMID
operator|=
name|i
expr_stmt|;
name|cm
operator|->
name|cm_sc
operator|=
name|sc
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cm
operator|->
name|cm_chain_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cm
operator|->
name|cm_prp_page_list
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|cm
operator|->
name|cm_callout
argument_list|,
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX Is a failure here a critical problem? */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|cm
operator|->
name|cm_dmamap
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|<=
name|sc
operator|->
name|facts
operator|->
name|HighPriorityCredit
condition|)
name|mpr_free_high_priority_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
else|else
name|mpr_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"failed to allocate command %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_reqs
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate contiguous buffers for PCIe NVMe devices for building native PRPs,  * which are scatter/gather lists for NVMe devices.   *  * This buffer must be contiguous due to the nature of how NVMe PRPs are built  * and translated by FW.  *  * returns ENOMEM if memory could not be allocated, otherwise returns 0.  */
end_comment

begin_function
specifier|static
name|int
name|mpr_alloc_nvme_prp_pages
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|PRPs_per_page
decl_stmt|,
name|PRPs_required
decl_stmt|,
name|pages_required
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|mpr_prp_page
modifier|*
name|prp_page
decl_stmt|;
comment|/* 	 * Assuming a MAX_IO_SIZE of 1MB and a PAGE_SIZE of 4k, the max number 	 * of PRPs (NVMe's Scatter/Gather Element) needed per I/O is: 	 * MAX_IO_SIZE / PAGE_SIZE = 256 	 *  	 * 1 PRP entry in main frame for PRP list pointer still leaves 255 PRPs 	 * required for the remainder of the 1MB I/O. 512 PRPs can fit into one 	 * page (4096 / 8 = 512), so only one page is required for each I/O. 	 * 	 * Each of these buffers will need to be contiguous. For simplicity, 	 * only one buffer is allocated here, which has all of the space 	 * required for the NVMe Queue Depth. If there are problems allocating 	 * this one buffer, this function will need to change to allocate 	 * individual, contiguous NVME_QDEPTH buffers. 	 * 	 * The real calculation will use the real max io size. Above is just an 	 * example. 	 * 	 */
name|PRPs_required
operator|=
name|sc
operator|->
name|maxio
operator|/
name|PAGE_SIZE
expr_stmt|;
name|PRPs_per_page
operator|=
operator|(
name|PAGE_SIZE
operator|/
name|PRP_ENTRY_SIZE
operator|)
operator|-
literal|1
expr_stmt|;
name|pages_required
operator|=
operator|(
name|PRPs_required
operator|/
name|PRPs_per_page
operator|)
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|prp_buffer_size
operator|=
name|PAGE_SIZE
operator|*
name|pages_required
expr_stmt|;
name|rsize
operator|=
name|sc
operator|->
name|prp_buffer_size
operator|*
name|NVME_QDEPTH
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mpr_parent_dmat
argument_list|,
comment|/* parent */
literal|4
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|rsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|rsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|prp_page_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate NVMe PRP DMA "
literal|"tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|prp_page_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|prp_pages
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|prp_page_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate NVMe PRP memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|prp_pages
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|prp_page_dmat
argument_list|,
name|sc
operator|->
name|prp_page_map
argument_list|,
name|sc
operator|->
name|prp_pages
argument_list|,
name|rsize
argument_list|,
name|mpr_memaddr_cb
argument_list|,
operator|&
name|sc
operator|->
name|prp_page_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|prps
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mpr_prp_page
argument_list|)
operator|*
name|NVME_QDEPTH
argument_list|,
name|M_MPR
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVME_QDEPTH
condition|;
name|i
operator|++
control|)
block|{
name|prp_page
operator|=
operator|&
name|sc
operator|->
name|prps
index|[
name|i
index|]
expr_stmt|;
name|prp_page
operator|->
name|prp_page
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|prp_pages
operator|+
name|i
operator|*
name|sc
operator|->
name|prp_buffer_size
operator|)
expr_stmt|;
name|prp_page
operator|->
name|prp_page_busaddr
operator|=
call|(
name|uint64_t
call|)
argument_list|(
name|sc
operator|->
name|prp_page_busaddr
operator|+
name|i
operator|*
name|sc
operator|->
name|prp_buffer_size
argument_list|)
expr_stmt|;
name|mpr_free_prp_page
argument_list|(
name|sc
argument_list|,
name|prp_page
argument_list|)
expr_stmt|;
name|sc
operator|->
name|prp_pages_free_lowwater
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_init_queues
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|post_queue
argument_list|,
literal|0xff
argument_list|,
name|sc
operator|->
name|pqdepth
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * According to the spec, we need to use one less reply than we 	 * have space for on the queue.  So sc->num_replies (the number we 	 * use) should be less than sc->fqdepth (allocated size). 	 */
if|if
condition|(
name|sc
operator|->
name|num_replies
operator|>=
name|sc
operator|->
name|fqdepth
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Initialize all of the free queue entries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|fqdepth
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|free_queue
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|reply_busaddr
operator|+
operator|(
name|i
operator|*
name|sc
operator|->
name|facts
operator|->
name|ReplyFrameSize
operator|*
literal|4
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|replyfreeindex
operator|=
name|sc
operator|->
name|num_replies
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the driver parameter tunables.  Lowest priority are the driver defaults.  * Next are the global settings, if they exist.  Highest are the per-unit  * settings, if they exist.  */
end_comment

begin_function
specifier|static
name|void
name|mpr_get_tunables
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|;
comment|/* XXX default to some debugging for now */
name|sc
operator|->
name|mpr_debug
operator|=
name|MPR_INFO
operator||
name|MPR_FAULT
expr_stmt|;
name|sc
operator|->
name|disable_msix
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|disable_msi
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|max_chains
operator|=
name|MPR_CHAIN_FRAMES
expr_stmt|;
name|sc
operator|->
name|max_io_pages
operator|=
name|MPR_MAXIO_PAGES
expr_stmt|;
name|sc
operator|->
name|enable_ssu
operator|=
name|MPR_SSU_ENABLE_SSD_DISABLE_HDD
expr_stmt|;
name|sc
operator|->
name|spinup_wait_time
operator|=
name|DEFAULT_SPINUP_WAIT
expr_stmt|;
name|sc
operator|->
name|use_phynum
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Grab the global variables. 	 */
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mpr.debug_level"
argument_list|,
operator|&
name|sc
operator|->
name|mpr_debug
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mpr.disable_msix"
argument_list|,
operator|&
name|sc
operator|->
name|disable_msix
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mpr.disable_msi"
argument_list|,
operator|&
name|sc
operator|->
name|disable_msi
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mpr.max_chains"
argument_list|,
operator|&
name|sc
operator|->
name|max_chains
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mpr.max_io_pages"
argument_list|,
operator|&
name|sc
operator|->
name|max_io_pages
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mpr.enable_ssu"
argument_list|,
operator|&
name|sc
operator|->
name|enable_ssu
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mpr.spinup_wait_time"
argument_list|,
operator|&
name|sc
operator|->
name|spinup_wait_time
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mpr.use_phy_num"
argument_list|,
operator|&
name|sc
operator|->
name|use_phynum
argument_list|)
expr_stmt|;
comment|/* Grab the unit-instance variables */
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mpr.%d.debug_level"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|mpr_debug
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mpr.%d.disable_msix"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|disable_msix
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mpr.%d.disable_msi"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|disable_msi
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mpr.%d.max_chains"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|max_chains
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mpr.%d.max_io_pages"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|max_io_pages
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|exclude_ids
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|exclude_ids
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mpr.%d.exclude_ids"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_STR_FETCH
argument_list|(
name|tmpstr
argument_list|,
name|sc
operator|->
name|exclude_ids
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|exclude_ids
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mpr.%d.enable_ssu"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|enable_ssu
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mpr.%d.spinup_wait_time"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|spinup_wait_time
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"dev.mpr.%d.use_phy_num"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|tmpstr
argument_list|,
operator|&
name|sc
operator|->
name|use_phynum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpr_setup_sysctl
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|sysctl_ctx
init|=
name|NULL
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sysctl_tree
init|=
name|NULL
decl_stmt|;
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|,
name|tmpstr2
index|[
literal|80
index|]
decl_stmt|;
comment|/* 	 * Setup the sysctl variable so the user can change the debug level 	 * on the fly. 	 */
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"MPR controller %d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpstr2
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr2
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
argument_list|)
expr_stmt|;
name|sysctl_ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl_ctx
operator|!=
name|NULL
condition|)
name|sysctl_tree
operator|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl_tree
operator|==
name|NULL
condition|)
block|{
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw_mpr
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|tmpstr2
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sysctl_tree
operator|==
name|NULL
condition|)
return|return;
name|sysctl_ctx
operator|=
operator|&
name|sc
operator|->
name|sysctl_ctx
expr_stmt|;
name|sysctl_tree
operator|=
name|sc
operator|->
name|sysctl_tree
expr_stmt|;
block|}
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug_level"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|mpr_debug
argument_list|,
literal|0
argument_list|,
literal|"mpr debug level"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"disable_msix"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|disable_msix
argument_list|,
literal|0
argument_list|,
literal|"Disable the use of MSI-X interrupts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"disable_msi"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|disable_msi
argument_list|,
literal|0
argument_list|,
literal|"Disable the use of MSI interrupts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"firmware_version"
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|sc
operator|->
name|fw_version
argument_list|,
name|strlen
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"driver_version"
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|MPR_DRIVER_VERSION
argument_list|,
name|strlen
argument_list|(
name|MPR_DRIVER_VERSION
argument_list|)
argument_list|,
literal|"driver version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"io_cmds_active"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|io_cmds_active
argument_list|,
literal|0
argument_list|,
literal|"number of currently active commands"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"io_cmds_highwater"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|io_cmds_highwater
argument_list|,
literal|0
argument_list|,
literal|"maximum active commands seen"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"chain_free"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|chain_free
argument_list|,
literal|0
argument_list|,
literal|"number of free chain elements"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"chain_free_lowwater"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|chain_free_lowwater
argument_list|,
literal|0
argument_list|,
literal|"lowest number of free chain elements"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_chains"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|max_chains
argument_list|,
literal|0
argument_list|,
literal|"maximum chain frames that will be allocated"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_io_pages"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|max_io_pages
argument_list|,
literal|0
argument_list|,
literal|"maximum pages to allow per I/O (if<1 use "
literal|"IOCFacts)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enable_ssu"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|enable_ssu
argument_list|,
literal|0
argument_list|,
literal|"enable SSU to SATA SSD/HDD at shutdown"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"chain_alloc_fail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|chain_alloc_fail
argument_list|,
literal|"chain allocation failures"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"spinup_wait_time"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|spinup_wait_time
argument_list|,
name|DEFAULT_SPINUP_WAIT
argument_list|,
literal|"seconds to wait for "
literal|"spinup after SATA ID error"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"use_phy_num"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|use_phynum
argument_list|,
literal|0
argument_list|,
literal|"Use the phy number for enumeration"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"prp_pages_free"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|prp_pages_free
argument_list|,
literal|0
argument_list|,
literal|"number of free PRP pages"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"prp_pages_free_lowwater"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|prp_pages_free_lowwater
argument_list|,
literal|0
argument_list|,
literal|"lowest number of free PRP pages"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"prp_page_alloc_fail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|prp_page_alloc_fail
argument_list|,
literal|"PRP page allocation failures"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mpr_attach
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mpr_get_tunables
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|MPR_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|,
literal|"MPR lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|periodic
argument_list|,
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|device_check_callout
argument_list|,
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|event_list
argument_list|)
expr_stmt|;
name|timevalclear
argument_list|(
operator|&
name|sc
operator|->
name|lastfail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mpr_transition_ready
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s failed to transition ready\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|facts
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MPI2_IOC_FACTS_REPLY
argument_list|)
argument_list|,
name|M_MPR
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|facts
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate memory %s %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Get IOC Facts and allocate all structures based on this information. 	 * A Diag Reset will also call mpr_iocfacts_allocate and re-read the IOC 	 * Facts. If relevant values have changed in IOC Facts, this function 	 * will free all of the memory based on IOC Facts and reallocate that 	 * memory.  If this fails, any allocated memory should already be freed. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|mpr_iocfacts_allocate
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"%s IOC Facts based allocation "
literal|"failed with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Start the periodic watchdog check on the IOC Doorbell */
name|mpr_periodic
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * The portenable will kick off discovery events that will drive the 	 * rest of the initialization process.  The CAM/SAS module will 	 * hold up the boot sequence until discovery is complete. 	 */
name|sc
operator|->
name|mpr_ich
operator|.
name|ich_func
operator|=
name|mpr_startup
expr_stmt|;
name|sc
operator|->
name|mpr_ich
operator|.
name|ich_arg
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|mpr_ich
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_ERROR
argument_list|,
literal|"Cannot establish MPR config hook\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* 	 * Allow IR to shutdown gracefully when shutdown occurs. 	 */
name|sc
operator|->
name|shutdown_eh
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|mprsas_ir_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|shutdown_eh
operator|==
name|NULL
condition|)
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_ERROR
argument_list|,
literal|"shutdown event registration "
literal|"failed\n"
argument_list|)
expr_stmt|;
name|mpr_setup_sysctl
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mpr_flags
operator||=
name|MPR_FLAGS_ATTACH_DONE
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Run through any late-start handlers. */
end_comment

begin_function
specifier|static
name|void
name|mpr_startup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mpr_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mpr_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mpr_unmask_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* initialize device mapping tables */
name|mpr_base_static_config_pages
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mpr_mapping_initialize
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mprsas_startup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Periodic watchdog.  Is called with the driver lock already held. */
end_comment

begin_function
specifier|static
name|void
name|mpr_periodic
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mpr_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|db
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mpr_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mpr_flags
operator|&
name|MPR_FLAGS_SHUTDOWN
condition|)
return|return;
name|db
operator|=
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_DOORBELL_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|db
operator|&
name|MPI2_IOC_STATE_MASK
operator|)
operator|==
name|MPI2_IOC_STATE_FAULT
condition|)
block|{
if|if
condition|(
operator|(
name|db
operator|&
name|MPI2_DOORBELL_FAULT_CODE_MASK
operator|)
operator|==
name|IFAULT_IOP_OVER_TEMP_THRESHOLD_EXCEEDED
condition|)
block|{
name|panic
argument_list|(
literal|"TEMPERATURE FAULT: STOPPING."
argument_list|)
expr_stmt|;
block|}
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"IOC Fault 0x%08x, Resetting\n"
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|mpr_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|periodic
argument_list|,
name|MPR_PERIODIC_DELAY
operator|*
name|hz
argument_list|,
name|mpr_periodic
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpr_log_evt_handler
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|uintptr_t
name|data
parameter_list|,
name|MPI2_EVENT_NOTIFICATION_REPLY
modifier|*
name|event
parameter_list|)
block|{
name|MPI2_EVENT_DATA_LOG_ENTRY_ADDED
modifier|*
name|entry
decl_stmt|;
name|mpr_print_event
argument_list|(
name|sc
argument_list|,
name|event
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|Event
condition|)
block|{
case|case
name|MPI2_EVENT_LOG_DATA
case|:
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_EVENT
argument_list|,
literal|"MPI2_EVENT_LOG_DATA:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mpr_debug
operator|&
name|MPR_EVENT
condition|)
name|hexdump
argument_list|(
name|event
operator|->
name|EventData
argument_list|,
name|event
operator|->
name|EventDataLength
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI2_EVENT_LOG_ENTRY_ADDED
case|:
name|entry
operator|=
operator|(
name|MPI2_EVENT_DATA_LOG_ENTRY_ADDED
operator|*
operator|)
name|event
operator|->
name|EventData
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_EVENT
argument_list|,
literal|"MPI2_EVENT_LOG_ENTRY_ADDED event "
literal|"0x%x Sequence %d:\n"
argument_list|,
name|entry
operator|->
name|LogEntryQualifier
argument_list|,
name|entry
operator|->
name|LogSequence
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_attach_log
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|events
index|[
literal|16
index|]
decl_stmt|;
name|bzero
argument_list|(
name|events
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_LOG_DATA
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|events
argument_list|,
name|MPI2_EVENT_LOG_ENTRY_ADDED
argument_list|)
expr_stmt|;
name|mpr_register_events
argument_list|(
name|sc
argument_list|,
name|events
argument_list|,
name|mpr_log_evt_handler
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|mpr_log_eh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_detach_log
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|mpr_log_eh
operator|!=
name|NULL
condition|)
name|mpr_deregister_events
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mpr_log_eh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all of the driver resources and detach submodules.  Should be called  * without the lock held.  */
end_comment

begin_function
name|int
name|mpr_free
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Turn off the watchdog */
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mpr_flags
operator||=
name|MPR_FLAGS_SHUTDOWN
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Lock must not be held for this */
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|periodic
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|device_check_callout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|error
operator|=
name|mpr_detach_log
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|error
operator|=
name|mpr_detach_sas
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mpr_detach_user
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Put the IOC back in the READY state. */
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mpr_transition_ready
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|facts
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|facts
argument_list|,
name|M_MPR
argument_list|)
expr_stmt|;
comment|/* 	 * Free all buffers that are based on IOC Facts.  A Diag Reset may need 	 * to free these buffers too. 	 */
name|mpr_iocfacts_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sysctl_tree
operator|!=
name|NULL
condition|)
name|sysctl_ctx_free
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
comment|/* Deregister the shutdown function */
if|if
condition|(
name|sc
operator|->
name|shutdown_eh
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|sc
operator|->
name|shutdown_eh
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|mpr_complete_command
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|)
block|{
name|MPR_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_ERROR
argument_list|,
literal|"Completing NULL command\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_POLLED
condition|)
name|cm
operator|->
name|cm_flags
operator||=
name|MPR_CM_FLAGS_COMPLETE
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_complete
operator|!=
name|NULL
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"%s cm %p calling cm_complete %p data %p reply %p\n"
argument_list|,
name|__func__
argument_list|,
name|cm
argument_list|,
name|cm
operator|->
name|cm_complete
argument_list|,
name|cm
operator|->
name|cm_complete_data
argument_list|,
name|cm
operator|->
name|cm_reply
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_complete
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_WAKEUP
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"waking up %p\n"
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|io_cmds_active
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|io_cmds_active
operator|--
expr_stmt|;
block|}
else|else
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_ERROR
argument_list|,
literal|"Warning: io_cmds_active is "
literal|"out of sync - resynching to 0\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mpr_sas_log_info
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|u32
name|log_info
parameter_list|)
block|{
union|union
name|loginfo_type
block|{
name|u32
name|loginfo
decl_stmt|;
struct|struct
block|{
name|u32
name|subcode
range|:
literal|16
decl_stmt|;
name|u32
name|code
range|:
literal|8
decl_stmt|;
name|u32
name|originator
range|:
literal|4
decl_stmt|;
name|u32
name|bus_type
range|:
literal|4
decl_stmt|;
block|}
name|dw
struct|;
block|}
union|;
name|union
name|loginfo_type
name|sas_loginfo
decl_stmt|;
name|char
modifier|*
name|originator_str
init|=
name|NULL
decl_stmt|;
name|sas_loginfo
operator|.
name|loginfo
operator|=
name|log_info
expr_stmt|;
if|if
condition|(
name|sas_loginfo
operator|.
name|dw
operator|.
name|bus_type
operator|!=
literal|3
comment|/*SAS*/
condition|)
return|return;
comment|/* each nexus loss loginfo */
if|if
condition|(
name|log_info
operator|==
literal|0x31170000
condition|)
return|return;
comment|/* eat the loginfos associated with task aborts */
if|if
condition|(
operator|(
name|log_info
operator|==
literal|30050000
operator|)
operator|||
operator|(
name|log_info
operator|==
literal|0x31140000
operator|)
operator|||
operator|(
name|log_info
operator|==
literal|0x31130000
operator|)
condition|)
return|return;
switch|switch
condition|(
name|sas_loginfo
operator|.
name|dw
operator|.
name|originator
condition|)
block|{
case|case
literal|0
case|:
name|originator_str
operator|=
literal|"IOP"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|originator_str
operator|=
literal|"PL"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|originator_str
operator|=
literal|"IR"
expr_stmt|;
break|break;
block|}
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_LOG
argument_list|,
literal|"log_info(0x%08x): originator(%s), "
literal|"code(0x%02x), sub_code(0x%04x)\n"
argument_list|,
name|log_info
argument_list|,
name|originator_str
argument_list|,
name|sas_loginfo
operator|.
name|dw
operator|.
name|code
argument_list|,
name|sas_loginfo
operator|.
name|dw
operator|.
name|subcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpr_display_reply_info
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|reply
parameter_list|)
block|{
name|MPI2DefaultReply_t
modifier|*
name|mpi_reply
decl_stmt|;
name|u16
name|sc_status
decl_stmt|;
name|mpi_reply
operator|=
operator|(
name|MPI2DefaultReply_t
operator|*
operator|)
name|reply
expr_stmt|;
name|sc_status
operator|=
name|le16toh
argument_list|(
name|mpi_reply
operator|->
name|IOCStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_status
operator|&
name|MPI2_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE
condition|)
name|mpr_sas_log_info
argument_list|(
name|sc
argument_list|,
name|le32toh
argument_list|(
name|mpi_reply
operator|->
name|IOCLogInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mpr_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mpr_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mpr_softc
operator|*
operator|)
name|data
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Check interrupt status register to flush the bus.  This is 	 * needed for both INTx interrupts and driver-driven polling 	 */
name|status
operator|=
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|MPI2_HOST_INTERRUPT_STATUS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|MPI2_HIS_REPLY_DESCRIPTOR_INTERRUPT
operator|)
operator|==
literal|0
condition|)
return|return;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mpr_intr_locked
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * In theory, MSI/MSIX interrupts shouldn't need to read any registers on the  * chip.  Hopefully this theory is correct.  */
end_comment

begin_function
name|void
name|mpr_intr_msi
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mpr_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mpr_softc
operator|*
operator|)
name|data
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mpr_intr_locked
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * The locking is overly broad and simplistic, but easy to deal with for now.  */
end_comment

begin_function
name|void
name|mpr_intr_locked
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|MPI2_REPLY_DESCRIPTORS_UNION
modifier|*
name|desc
decl_stmt|;
name|struct
name|mpr_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mpr_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|u_int
name|pq
decl_stmt|;
name|MPI2_DIAG_RELEASE_REPLY
modifier|*
name|rel_rep
decl_stmt|;
name|mpr_fw_diagnostic_buffer_t
modifier|*
name|pBuffer
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mpr_softc
operator|*
operator|)
name|data
expr_stmt|;
name|pq
operator|=
name|sc
operator|->
name|replypostindex
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"%s sc %p starting with replypostindex %u\n"
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|replypostindex
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cm
operator|=
name|NULL
expr_stmt|;
name|desc
operator|=
operator|&
name|sc
operator|->
name|post_queue
index|[
name|sc
operator|->
name|replypostindex
index|]
expr_stmt|;
name|flags
operator|=
name|desc
operator|->
name|Default
operator|.
name|ReplyFlags
operator|&
name|MPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|==
name|MPI2_RPY_DESCRIPT_FLAGS_UNUSED
operator|)
operator|||
operator|(
name|le32toh
argument_list|(
name|desc
operator|->
name|Words
operator|.
name|High
argument_list|)
operator|==
literal|0xffffffff
operator|)
condition|)
break|break;
comment|/* increment the replypostindex now, so that event handlers 		 * and cm completion handlers which decide to do a diag 		 * reset can zero it without it getting incremented again 		 * afterwards, and we break out of this loop on the next 		 * iteration since the reply post queue has been cleared to 		 * 0xFF and all descriptors look unused (which they are). 		 */
if|if
condition|(
operator|++
name|sc
operator|->
name|replypostindex
operator|>=
name|sc
operator|->
name|pqdepth
condition|)
name|sc
operator|->
name|replypostindex
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|flags
condition|)
block|{
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_SCSI_IO_SUCCESS
case|:
case|case
name|MPI25_RPY_DESCRIPT_FLAGS_FAST_PATH_SCSI_IO_SUCCESS
case|:
case|case
name|MPI26_RPY_DESCRIPT_FLAGS_PCIE_ENCAPSULATED_SUCCESS
case|:
name|cm
operator|=
operator|&
name|sc
operator|->
name|commands
index|[
name|le16toh
argument_list|(
name|desc
operator|->
name|SCSIIOSuccess
operator|.
name|SMID
argument_list|)
index|]
expr_stmt|;
name|cm
operator|->
name|cm_reply
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_ADDRESS_REPLY
case|:
block|{
name|uint32_t
name|baddr
decl_stmt|;
name|uint8_t
modifier|*
name|reply
decl_stmt|;
comment|/* 			 * Re-compose the reply address from the address 			 * sent back from the chip.  The ReplyFrameAddress 			 * is the lower 32 bits of the physical address of 			 * particular reply frame.  Convert that address to 			 * host format, and then use that to provide the 			 * offset against the virtual address base 			 * (sc->reply_frames). 			 */
name|baddr
operator|=
name|le32toh
argument_list|(
name|desc
operator|->
name|AddressReply
operator|.
name|ReplyFrameAddress
argument_list|)
expr_stmt|;
name|reply
operator|=
name|sc
operator|->
name|reply_frames
operator|+
operator|(
name|baddr
operator|-
operator|(
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|reply_busaddr
operator|)
operator|)
expr_stmt|;
comment|/* 			 * Make sure the reply we got back is in a valid 			 * range.  If not, go ahead and panic here, since 			 * we'll probably panic as soon as we deference the 			 * reply pointer anyway. 			 */
if|if
condition|(
operator|(
name|reply
operator|<
name|sc
operator|->
name|reply_frames
operator|)
operator|||
operator|(
name|reply
operator|>
operator|(
name|sc
operator|->
name|reply_frames
operator|+
operator|(
name|sc
operator|->
name|fqdepth
operator|*
name|sc
operator|->
name|facts
operator|->
name|ReplyFrameSize
operator|*
literal|4
operator|)
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING: reply %p out of range!\n"
argument_list|,
name|__func__
argument_list|,
name|reply
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: reply_frames %p, fqdepth %d, "
literal|"frame size %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|reply_frames
argument_list|,
name|sc
operator|->
name|fqdepth
argument_list|,
name|sc
operator|->
name|facts
operator|->
name|ReplyFrameSize
operator|*
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: baddr %#x,\n"
argument_list|,
name|__func__
argument_list|,
name|baddr
argument_list|)
expr_stmt|;
comment|/* LSI-TODO. See Linux Code for Graceful exit */
name|panic
argument_list|(
literal|"Reply address out of range"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|le16toh
argument_list|(
name|desc
operator|->
name|AddressReply
operator|.
name|SMID
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|MPI2_DEFAULT_REPLY
operator|*
operator|)
name|reply
operator|)
operator|->
name|Function
operator|==
name|MPI2_FUNCTION_DIAG_BUFFER_POST
condition|)
block|{
comment|/* 					 * If SMID is 0 for Diag Buffer Post, 					 * this implies that the reply is due to 					 * a release function with a status that 					 * the buffer has been released.  Set 					 * the buffer flags accordingly. 					 */
name|rel_rep
operator|=
operator|(
name|MPI2_DIAG_RELEASE_REPLY
operator|*
operator|)
name|reply
expr_stmt|;
if|if
condition|(
operator|(
name|le16toh
argument_list|(
name|rel_rep
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|==
name|MPI2_IOCSTATUS_DIAGNOSTIC_RELEASED
condition|)
block|{
name|pBuffer
operator|=
operator|&
name|sc
operator|->
name|fw_diag_buffer_list
index|[
name|rel_rep
operator|->
name|BufferType
index|]
expr_stmt|;
name|pBuffer
operator|->
name|valid_data
operator|=
name|TRUE
expr_stmt|;
name|pBuffer
operator|->
name|owned_by_firmware
operator|=
name|FALSE
expr_stmt|;
name|pBuffer
operator|->
name|immediate
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
name|mpr_dispatch_event
argument_list|(
name|sc
argument_list|,
name|baddr
argument_list|,
operator|(
name|MPI2_EVENT_NOTIFICATION_REPLY
operator|*
operator|)
name|reply
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cm
operator|=
operator|&
name|sc
operator|->
name|commands
index|[
name|le16toh
argument_list|(
name|desc
operator|->
name|AddressReply
operator|.
name|SMID
argument_list|)
index|]
expr_stmt|;
name|cm
operator|->
name|cm_reply
operator|=
name|reply
expr_stmt|;
name|cm
operator|->
name|cm_reply_data
operator|=
name|le32toh
argument_list|(
name|desc
operator|->
name|AddressReply
operator|.
name|ReplyFrameAddress
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_TARGETASSIST_SUCCESS
case|:
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_TARGET_COMMAND_BUFFER
case|:
case|case
name|MPI2_RPY_DESCRIPT_FLAGS_RAID_ACCELERATOR_SUCCESS
case|:
default|default:
comment|/* Unhandled */
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_ERROR
argument_list|,
literal|"Unhandled reply 0x%x\n"
argument_list|,
name|desc
operator|->
name|Default
operator|.
name|ReplyFlags
argument_list|)
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
comment|// Print Error reply frame
if|if
condition|(
name|cm
operator|->
name|cm_reply
condition|)
name|mpr_display_reply_info
argument_list|(
name|sc
argument_list|,
name|cm
operator|->
name|cm_reply
argument_list|)
expr_stmt|;
name|mpr_complete_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
name|desc
operator|->
name|Words
operator|.
name|Low
operator|=
literal|0xffffffff
expr_stmt|;
name|desc
operator|->
name|Words
operator|.
name|High
operator|=
literal|0xffffffff
expr_stmt|;
block|}
if|if
condition|(
name|pq
operator|!=
name|sc
operator|->
name|replypostindex
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"%s sc %p writing postindex %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|replypostindex
argument_list|)
expr_stmt|;
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|MPI2_REPLY_POST_HOST_INDEX_OFFSET
argument_list|,
name|sc
operator|->
name|replypostindex
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mpr_dispatch_event
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|uintptr_t
name|data
parameter_list|,
name|MPI2_EVENT_NOTIFICATION_REPLY
modifier|*
name|reply
parameter_list|)
block|{
name|struct
name|mpr_event_handle
modifier|*
name|eh
decl_stmt|;
name|int
name|event
decl_stmt|,
name|handled
init|=
literal|0
decl_stmt|;
name|event
operator|=
name|le16toh
argument_list|(
name|reply
operator|->
name|Event
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|eh
argument_list|,
argument|&sc->event_list
argument_list|,
argument|eh_list
argument_list|)
block|{
if|if
condition|(
name|isset
argument_list|(
name|eh
operator|->
name|mask
argument_list|,
name|event
argument_list|)
condition|)
block|{
name|eh
operator|->
name|callback
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
name|reply
argument_list|)
expr_stmt|;
name|handled
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|handled
operator|==
literal|0
condition|)
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_EVENT
argument_list|,
literal|"Unhandled event 0x%x\n"
argument_list|,
name|le16toh
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This is the only place that the event/reply should be freed. 	 * Anything wanting to hold onto the event data should have 	 * already copied it into their own storage. 	 */
name|mpr_free_reply
argument_list|(
name|sc
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpr_reregister_events_complete
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_reply
condition|)
name|mpr_print_event
argument_list|(
name|sc
argument_list|,
operator|(
name|MPI2_EVENT_NOTIFICATION_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
argument_list|)
expr_stmt|;
name|mpr_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
comment|/* next, send a port enable */
name|mprsas_startup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For both register_events and update_events, the caller supplies a bitmap  * of events that it _wants_.  These functions then turn that into a bitmask  * suitable for the controller.  */
end_comment

begin_function
name|int
name|mpr_register_events
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|mask
parameter_list|,
name|mpr_evt_callback_t
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|mpr_event_handle
modifier|*
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|mpr_event_handle
modifier|*
name|eh
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|eh
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mpr_event_handle
argument_list|)
argument_list|,
name|M_MPR
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eh
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate memory %s %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|eh
operator|->
name|callback
operator|=
name|cb
expr_stmt|;
name|eh
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|event_list
argument_list|,
name|eh
argument_list|,
name|eh_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
name|NULL
condition|)
name|error
operator|=
name|mpr_update_events
argument_list|(
name|sc
argument_list|,
name|eh
argument_list|,
name|mask
argument_list|)
expr_stmt|;
operator|*
name|handle
operator|=
name|eh
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mpr_update_events
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_event_handle
modifier|*
name|handle
parameter_list|,
name|uint8_t
modifier|*
name|mask
parameter_list|)
block|{
name|MPI2_EVENT_NOTIFICATION_REQUEST
modifier|*
name|evtreq
decl_stmt|;
name|MPI2_EVENT_NOTIFICATION_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mpr_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mpr_event_handle
modifier|*
name|eh
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|handle
operator|!=
name|NULL
operator|)
condition|)
name|bcopy
argument_list|(
name|mask
argument_list|,
operator|&
name|handle
operator|->
name|mask
index|[
literal|0
index|]
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|event_mask
argument_list|,
literal|0xff
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|eh
argument_list|,
argument|&sc->event_list
argument_list|,
argument|eh_list
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|event_mask
index|[
name|i
index|]
operator|&=
operator|~
name|eh
operator|->
name|mask
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cm
operator|=
name|mpr_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|evtreq
operator|=
operator|(
name|MPI2_EVENT_NOTIFICATION_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|evtreq
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_EVENT_NOTIFICATION
expr_stmt|;
name|evtreq
operator|->
name|MsgFlags
operator|=
literal|0
expr_stmt|;
name|evtreq
operator|->
name|SASBroadcastPrimitiveMasks
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MPR_DEBUG_ALL_EVENTS
block|{
name|u_char
name|fullmask
index|[
literal|16
index|]
decl_stmt|;
name|memset
argument_list|(
name|fullmask
argument_list|,
literal|0x00
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fullmask
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|evtreq
operator|->
name|EventMasks
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|bcopy
argument_list|(
name|sc
operator|->
name|event_mask
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|evtreq
operator|->
name|EventMasks
argument_list|,
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|mpr_request_polled
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|reply
operator|=
operator|(
name|MPI2_EVENT_NOTIFICATION_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
operator|(
name|reply
operator|==
name|NULL
operator|)
operator|||
operator|(
name|reply
operator|->
name|IOCStatus
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
name|reply
condition|)
name|mpr_print_event
argument_list|(
name|sc
argument_list|,
name|reply
argument_list|)
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"%s finished error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mpr_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_reregister_events
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|MPI2_EVENT_NOTIFICATION_REQUEST
modifier|*
name|evtreq
decl_stmt|;
name|struct
name|mpr_command
modifier|*
name|cm
decl_stmt|;
name|struct
name|mpr_event_handle
modifier|*
name|eh
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* first, reregister events */
name|memset
argument_list|(
name|sc
operator|->
name|event_mask
argument_list|,
literal|0xff
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|eh
argument_list|,
argument|&sc->event_list
argument_list|,
argument|eh_list
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|event_mask
index|[
name|i
index|]
operator|&=
operator|~
name|eh
operator|->
name|mask
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cm
operator|=
name|mpr_alloc_command
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|evtreq
operator|=
operator|(
name|MPI2_EVENT_NOTIFICATION_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|evtreq
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_EVENT_NOTIFICATION
expr_stmt|;
name|evtreq
operator|->
name|MsgFlags
operator|=
literal|0
expr_stmt|;
name|evtreq
operator|->
name|SASBroadcastPrimitiveMasks
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MPR_DEBUG_ALL_EVENTS
block|{
name|u_char
name|fullmask
index|[
literal|16
index|]
decl_stmt|;
name|memset
argument_list|(
name|fullmask
argument_list|,
literal|0x00
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fullmask
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|evtreq
operator|->
name|EventMasks
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|bcopy
argument_list|(
name|sc
operator|->
name|event_mask
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|evtreq
operator|->
name|EventMasks
argument_list|,
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|mpr_reregister_events_complete
expr_stmt|;
name|error
operator|=
name|mpr_map_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"%s finished with error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mpr_deregister_events
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_event_handle
modifier|*
name|handle
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|event_list
argument_list|,
name|handle
argument_list|,
name|eh_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|handle
argument_list|,
name|M_MPR
argument_list|)
expr_stmt|;
return|return
operator|(
name|mpr_update_events
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/** * mpr_build_nvme_prp - This function is called for NVMe end devices to build a * native SGL (NVMe PRP). The native SGL is built starting in the first PRP entry * of the NVMe message (PRP1). If the data buffer is small enough to be described * entirely using PRP1, then PRP2 is not used. If needed, PRP2 is used to * describe a larger data buffer. If the data buffer is too large to describe * using the two PRP entriess inside the NVMe message, then PRP1 describes the * first data memory segment, and PRP2 contains a pointer to a PRP list located * elsewhere in memory to describe the remaining data memory segments. The PRP * list will be contiguous.  * The native SGL for NVMe devices is a Physical Region Page (PRP). A PRP * consists of a list of PRP entries to describe a number of noncontigous * physical memory segments as a single memory buffer, just as a SGL does. Note * however, that this function is only used by the IOCTL call, so the memory * given will be guaranteed to be contiguous. There is no need to translate * non-contiguous SGL into a PRP in this case. All PRPs will describe contiguous * space that is one page size each. * * Each NVMe message contains two PRP entries. The first (PRP1) either contains * a PRP list pointer or a PRP element, depending upon the command. PRP2 contains * the second PRP element if the memory being described fits within 2 PRP * entries, or a PRP list pointer if the PRP spans more than two entries. * * A PRP list pointer contains the address of a PRP list, structured as a linear * array of PRP entries. Each PRP entry in this list describes a segment of * physical memory. * * Each 64-bit PRP entry comprises an address and an offset field. The address * always points to the beginning of a PAGE_SIZE physical memory page, and the * offset describes where within that page the memory segment begins. Only the * first element in a PRP list may contain a non-zero offest, implying that all * memory segments following the first begin at the start of a PAGE_SIZE page. * * Each PRP element normally describes a chunck of PAGE_SIZE physical memory, * with exceptions for the first and last elements in the list. If the memory * being described by the list begins at a non-zero offset within the first page, * then the first PRP element will contain a non-zero offset indicating where the * region begins within the page. The last memory segment may end before the end * of the PAGE_SIZE segment, depending upon the overall size of the memory being * described by the PRP list.  * * Since PRP entries lack any indication of size, the overall data buffer length * is used to determine where the end of the data memory buffer is located, and * how many PRP entries are required to describe it. * * Returns nothing. */
end_comment

begin_function
name|void
name|mpr_build_nvme_prp
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|Mpi26NVMeEncapsulatedRequest_t
modifier|*
name|nvme_encap_request
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|data_in_sz
parameter_list|,
name|uint32_t
name|data_out_sz
parameter_list|)
block|{
name|int
name|prp_size
init|=
name|PRP_ENTRY_SIZE
decl_stmt|;
name|uint64_t
modifier|*
name|prp_entry
decl_stmt|,
modifier|*
name|prp1_entry
decl_stmt|,
modifier|*
name|prp2_entry
decl_stmt|;
name|uint64_t
modifier|*
name|prp_entry_phys
decl_stmt|,
modifier|*
name|prp_page
decl_stmt|,
modifier|*
name|prp_page_phys
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|,
name|entry_len
decl_stmt|,
name|page_mask_result
decl_stmt|,
name|page_mask
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|struct
name|mpr_prp_page
modifier|*
name|prp_page_info
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Not all commands require a data transfer. If no data, just return 	 * without constructing any PRP. 	 */
if|if
condition|(
operator|!
name|data_in_sz
operator|&&
operator|!
name|data_out_sz
condition|)
return|return;
comment|/* 	 * Set pointers to PRP1 and PRP2, which are in the NVMe command. PRP1 is 	 * located at a 24 byte offset from the start of the NVMe command. Then 	 * set the current PRP entry pointer to PRP1. 	 */
name|prp1_entry
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|nvme_encap_request
operator|->
name|NVMe_Command
operator|+
name|NVME_CMD_PRP1_OFFSET
operator|)
expr_stmt|;
name|prp2_entry
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|nvme_encap_request
operator|->
name|NVMe_Command
operator|+
name|NVME_CMD_PRP2_OFFSET
operator|)
expr_stmt|;
name|prp_entry
operator|=
name|prp1_entry
expr_stmt|;
comment|/* 	 * For the PRP entries, use the specially allocated buffer of 	 * contiguous memory. PRP Page allocation failures should not happen 	 * because there should be enough PRP page buffers to account for the 	 * possible NVMe QDepth. 	 */
name|prp_page_info
operator|=
name|mpr_alloc_prp_page
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|prp_page_info
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: There are no PRP Pages left to be "
literal|"used for building a native NVMe SGL.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|prp_page
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|prp_page_info
operator|->
name|prp_page
expr_stmt|;
name|prp_page_phys
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|prp_page_info
operator|->
name|prp_page_busaddr
expr_stmt|;
comment|/* 	 * Insert the allocated PRP page into the command's PRP page list. This 	 * will be freed when the command is freed. 	 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cm
operator|->
name|cm_prp_page_list
argument_list|,
name|prp_page_info
argument_list|,
name|prp_page_link
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we are within 1 entry of a page boundary we don't want our 	 * first entry to be a PRP List entry. 	 */
name|page_mask
operator|=
name|PAGE_SIZE
operator|-
literal|1
expr_stmt|;
name|page_mask_result
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|prp_page
operator|+
name|prp_size
argument_list|)
operator|&
name|page_mask
expr_stmt|;
if|if
condition|(
operator|!
name|page_mask_result
condition|)
block|{
comment|/* Bump up to next page boundary. */
name|prp_page
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|prp_page
operator|+
name|prp_size
operator|)
expr_stmt|;
name|prp_page_phys
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|prp_page_phys
operator|+
name|prp_size
operator|)
expr_stmt|;
block|}
comment|/* 	 * Set PRP physical pointer, which initially points to the current PRP 	 * DMA memory page. 	 */
name|prp_entry_phys
operator|=
name|prp_page_phys
expr_stmt|;
comment|/* Get physical address and length of the data buffer. */
name|paddr
operator|=
operator|(
name|bus_addr_t
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|data_in_sz
condition|)
name|length
operator|=
name|data_in_sz
expr_stmt|;
else|else
name|length
operator|=
name|data_out_sz
expr_stmt|;
comment|/* Loop while the length is not zero. */
while|while
condition|(
name|length
condition|)
block|{
comment|/* 		 * Check if we need to put a list pointer here if we are at page 		 * boundary - prp_size (8 bytes). 		 */
name|page_mask_result
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|prp_entry_phys
operator|+
name|prp_size
argument_list|)
operator|&
name|page_mask
expr_stmt|;
if|if
condition|(
operator|!
name|page_mask_result
condition|)
block|{
comment|/* 			 * This is the last entry in a PRP List, so we need to 			 * put a PRP list pointer here. What this does is: 			 *   - bump the current memory pointer to the next 			 *     address, which will be the next full page. 			 *   - set the PRP Entry to point to that page. This is 			 *     now the PRP List pointer. 			 *   - bump the PRP Entry pointer the start of the next 			 *     page. Since all of this PRP memory is contiguous, 			 *     no need to get a new page - it's just the next 			 *     address. 			 */
name|prp_entry_phys
operator|++
expr_stmt|;
operator|*
name|prp_entry
operator|=
name|htole64
argument_list|(
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|prp_entry_phys
argument_list|)
expr_stmt|;
name|prp_entry
operator|++
expr_stmt|;
block|}
comment|/* Need to handle if entry will be part of a page. */
name|offset
operator|=
operator|(
name|uint32_t
operator|)
name|paddr
operator|&
name|page_mask
expr_stmt|;
name|entry_len
operator|=
name|PAGE_SIZE
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|prp_entry
operator|==
name|prp1_entry
condition|)
block|{
comment|/* 			 * Must fill in the first PRP pointer (PRP1) before 			 * moving on. 			 */
operator|*
name|prp1_entry
operator|=
name|htole64
argument_list|(
operator|(
name|uint64_t
operator|)
name|paddr
argument_list|)
expr_stmt|;
comment|/* 			 * Now point to the second PRP entry within the 			 * command (PRP2). 			 */
name|prp_entry
operator|=
name|prp2_entry
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prp_entry
operator|==
name|prp2_entry
condition|)
block|{
comment|/* 			 * Should the PRP2 entry be a PRP List pointer or just a 			 * regular PRP pointer? If there is more than one more 			 * page of data, must use a PRP List pointer. 			 */
if|if
condition|(
name|length
operator|>
name|PAGE_SIZE
condition|)
block|{
comment|/* 				 * PRP2 will contain a PRP List pointer because 				 * more PRP's are needed with this command. The 				 * list will start at the beginning of the 				 * contiguous buffer. 				 */
operator|*
name|prp2_entry
operator|=
name|htole64
argument_list|(
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|prp_entry_phys
argument_list|)
expr_stmt|;
comment|/* 				 * The next PRP Entry will be the start of the 				 * first PRP List. 				 */
name|prp_entry
operator|=
name|prp_page
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * After this, the PRP Entries are complete. 				 * This command uses 2 PRP's and no PRP list. 				 */
operator|*
name|prp2_entry
operator|=
name|htole64
argument_list|(
operator|(
name|uint64_t
operator|)
name|paddr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Put entry in list and bump the addresses. 			 * 			 * After PRP1 and PRP2 are filled in, this will fill in 			 * all remaining PRP entries in a PRP List, one per each 			 * time through the loop. 			 */
operator|*
name|prp_entry
operator|=
name|htole64
argument_list|(
operator|(
name|uint64_t
operator|)
name|paddr
argument_list|)
expr_stmt|;
name|prp_entry
operator|++
expr_stmt|;
name|prp_entry_phys
operator|++
expr_stmt|;
block|}
comment|/* 		 * Bump the phys address of the command's data buffer by the 		 * entry_len. 		 */
name|paddr
operator|+=
name|entry_len
expr_stmt|;
comment|/* Decrement length accounting for last partial page. */
if|if
condition|(
name|entry_len
operator|>
name|length
condition|)
name|length
operator|=
literal|0
expr_stmt|;
else|else
name|length
operator|-=
name|entry_len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * mpr_check_pcie_native_sgl - This function is called for PCIe end devices to  * determine if the driver needs to build a native SGL. If so, that native SGL  * is built in the contiguous buffers allocated especially for PCIe SGL  * creation. If the driver will not build a native SGL, return TRUE and a  * normal IEEE SGL will be built. Currently this routine supports NVMe devices  * only.  *  * Returns FALSE (0) if native SGL was built, TRUE (1) if no SGL was built.  */
end_comment

begin_function
specifier|static
name|int
name|mpr_check_pcie_native_sgl
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|segs_left
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|sge_dwords
decl_stmt|,
name|length
decl_stmt|,
name|offset
decl_stmt|,
name|entry_len
decl_stmt|;
name|uint32_t
name|num_entries
decl_stmt|,
name|buff_len
init|=
literal|0
decl_stmt|,
name|sges_in_segment
decl_stmt|;
name|uint32_t
name|page_mask
decl_stmt|,
name|page_mask_result
decl_stmt|,
modifier|*
name|curr_buff
decl_stmt|;
name|uint32_t
modifier|*
name|ptr_sgl
decl_stmt|,
modifier|*
name|ptr_first_sgl
decl_stmt|,
name|first_page_offset
decl_stmt|;
name|uint32_t
name|first_page_data_size
decl_stmt|,
name|end_residual
decl_stmt|;
name|uint64_t
modifier|*
name|msg_phys
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|int
name|build_native_sgl
init|=
literal|0
decl_stmt|,
name|first_prp_entry
decl_stmt|;
name|int
name|prp_size
init|=
name|PRP_ENTRY_SIZE
decl_stmt|;
name|Mpi25IeeeSgeChain64_t
modifier|*
name|main_chain_element
init|=
name|NULL
decl_stmt|;
name|struct
name|mpr_prp_page
modifier|*
name|prp_page_info
init|=
name|NULL
decl_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_TRACE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Add up the sizes of each segment length to get the total transfer 	 * size, which will be checked against the Maximum Data Transfer Size. 	 * If the data transfer length exceeds the MDTS for this device, just 	 * return 1 so a normal IEEE SGL will be built. F/W will break the I/O 	 * up into multiple I/O's. [nvme_mdts = 0 means unlimited] 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|segs_left
condition|;
name|i
operator|++
control|)
name|buff_len
operator|+=
name|htole32
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_targ
operator|->
name|MDTS
operator|>
literal|0
operator|)
operator|&&
operator|(
name|buff_len
operator|>
name|cm
operator|->
name|cm_targ
operator|->
name|MDTS
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Create page_mask (to get offset within page) */
name|page_mask
operator|=
name|PAGE_SIZE
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Check if the number of elements exceeds the max number that can be 	 * put in the main message frame (H/W can only translate an SGL that 	 * is contained entirely in the main message frame). 	 */
name|sges_in_segment
operator|=
operator|(
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|-
name|offsetof
argument_list|(
name|Mpi25SCSIIORequest_t
argument_list|,
name|SGL
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|MPI25_SGE_IO_UNION
argument_list|)
expr_stmt|;
if|if
condition|(
name|segs_left
operator|>
name|sges_in_segment
condition|)
name|build_native_sgl
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* 		 * NVMe uses one PRP for each physical page (or part of physical 		 * page). 		 *    if 4 pages or less then IEEE is OK 		 *    if> 5 pages then we need to build a native SGL 		 *    if> 4 and<= 5 pages, then check the physical address of 		 *      the first SG entry, then if this first size in the page 		 *      is>= the residual beyond 4 pages then use IEEE, 		 *      otherwise use native SGL 		 */
if|if
condition|(
name|buff_len
operator|>
operator|(
name|PAGE_SIZE
operator|*
literal|5
operator|)
condition|)
name|build_native_sgl
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|buff_len
operator|>
operator|(
name|PAGE_SIZE
operator|*
literal|4
operator|)
operator|)
operator|&&
operator|(
name|buff_len
operator|<=
operator|(
name|PAGE_SIZE
operator|*
literal|5
operator|)
operator|)
condition|)
block|{
name|msg_phys
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|first_page_offset
operator|=
operator|(
operator|(
name|uint32_t
operator|)
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|msg_phys
operator|&
name|page_mask
operator|)
expr_stmt|;
name|first_page_data_size
operator|=
name|PAGE_SIZE
operator|-
name|first_page_offset
expr_stmt|;
name|end_residual
operator|=
name|buff_len
operator|%
name|PAGE_SIZE
expr_stmt|;
comment|/* 			 * If offset into first page pushes the end of the data 			 * beyond end of the 5th page, we need the extra PRP 			 * list. 			 */
if|if
condition|(
name|first_page_data_size
operator|<
name|end_residual
condition|)
name|build_native_sgl
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Check if first SG entry size is< residual beyond 4 			 * pages. 			 */
if|if
condition|(
name|htole32
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|)
operator|<
operator|(
name|buff_len
operator|-
operator|(
name|PAGE_SIZE
operator|*
literal|4
operator|)
operator|)
condition|)
name|build_native_sgl
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* check if native SGL is needed */
if|if
condition|(
operator|!
name|build_native_sgl
condition|)
return|return
literal|1
return|;
comment|/* 	 * Native SGL is needed. 	 * Put a chain element in main message frame that points to the first 	 * chain buffer. 	 * 	 * NOTE:  The ChainOffset field must be 0 when using a chain pointer to 	 *        a native SGL. 	 */
comment|/* Set main message chain element pointer */
name|main_chain_element
operator|=
operator|(
name|pMpi25IeeeSgeChain64_t
operator|)
name|cm
operator|->
name|cm_sge
expr_stmt|;
comment|/* 	 * For NVMe the chain element needs to be the 2nd SGL entry in the main 	 * message. 	 */
name|main_chain_element
operator|=
operator|(
name|Mpi25IeeeSgeChain64_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|main_chain_element
operator|+
sizeof|sizeof
argument_list|(
name|MPI25_IEEE_SGE_CHAIN64
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * For the PRP entries, use the specially allocated buffer of 	 * contiguous memory. PRP Page allocation failures should not happen 	 * because there should be enough PRP page buffers to account for the 	 * possible NVMe QDepth. 	 */
name|prp_page_info
operator|=
name|mpr_alloc_prp_page
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|prp_page_info
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: There are no PRP Pages left to be "
literal|"used for building a native NVMe SGL.\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|curr_buff
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|prp_page_info
operator|->
name|prp_page
expr_stmt|;
name|msg_phys
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|prp_page_info
operator|->
name|prp_page_busaddr
expr_stmt|;
comment|/* 	 * Insert the allocated PRP page into the command's PRP page list. This 	 * will be freed when the command is freed. 	 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cm
operator|->
name|cm_prp_page_list
argument_list|,
name|prp_page_info
argument_list|,
name|prp_page_link
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we are within 1 entry of a page boundary we don't want our 	 * first entry to be a PRP List entry. 	 */
name|page_mask_result
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|curr_buff
operator|+
name|prp_size
argument_list|)
operator|&
name|page_mask
expr_stmt|;
if|if
condition|(
operator|!
name|page_mask_result
condition|)
block|{
comment|/* Bump up to next page boundary. */
name|curr_buff
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|curr_buff
operator|+
name|prp_size
operator|)
expr_stmt|;
name|msg_phys
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|msg_phys
operator|+
name|prp_size
operator|)
expr_stmt|;
block|}
comment|/* Fill in the chain element and make it an NVMe segment type. */
name|main_chain_element
operator|->
name|Address
operator|.
name|High
operator|=
name|htole32
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|msg_phys
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|main_chain_element
operator|->
name|Address
operator|.
name|Low
operator|=
name|htole32
argument_list|(
operator|(
name|uint32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|msg_phys
argument_list|)
expr_stmt|;
name|main_chain_element
operator|->
name|NextChainOffset
operator|=
literal|0
expr_stmt|;
name|main_chain_element
operator|->
name|Flags
operator|=
name|MPI2_IEEE_SGE_FLAGS_CHAIN_ELEMENT
operator||
name|MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR
operator||
name|MPI26_IEEE_SGE_FLAGS_NSF_NVME_PRP
expr_stmt|;
comment|/* Set SGL pointer to start of contiguous PCIe buffer. */
name|ptr_sgl
operator|=
name|curr_buff
expr_stmt|;
name|sge_dwords
operator|=
literal|2
expr_stmt|;
name|num_entries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * NVMe has a very convoluted PRP format. One PRP is required for each 	 * page or partial page. We need to split up OS SG entries if they are 	 * longer than one page or cross a page boundary. We also have to insert 	 * a PRP list pointer entry as the last entry in each physical page of 	 * the PRP list. 	 * 	 * NOTE: The first PRP "entry" is actually placed in the first SGL entry 	 * in the main message in IEEE 64 format. The 2nd entry in the main 	 * message is the chain element, and the rest of the PRP entries are 	 * built in the contiguous PCIe buffer. 	 */
name|first_prp_entry
operator|=
literal|1
expr_stmt|;
name|ptr_first_sgl
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|cm
operator|->
name|cm_sge
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|segs_left
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get physical address and length of this SG entry. */
name|paddr
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|length
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
comment|/* 		 * Check whether a given SGE buffer lies on a non-PAGED 		 * boundary if this is not the first page. If so, this is not 		 * expected so have FW build the SGL. 		 */
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
operator|(
name|uint32_t
operator|)
name|paddr
operator|&
name|page_mask
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_ERROR
argument_list|,
literal|"Unaligned SGE while "
literal|"building NVMe PRPs, low address is 0x%x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|paddr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Apart from last SGE, if any other SGE boundary is not page 		 * aligned then it means that hole exists. Existence of hole 		 * leads to data corruption. So fallback to IEEE SGEs. 		 */
if|if
condition|(
name|i
operator|!=
operator|(
name|segs_left
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|uint32_t
operator|)
name|paddr
operator|+
name|length
operator|)
operator|&
name|page_mask
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_ERROR
argument_list|,
literal|"Unaligned SGE "
literal|"boundary while building NVMe PRPs, low "
literal|"address: 0x%x and length: %u\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|paddr
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Loop while the length is not zero. */
while|while
condition|(
name|length
condition|)
block|{
comment|/* 			 * Check if we need to put a list pointer here if we are 			 * at page boundary - prp_size. 			 */
name|page_mask_result
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|ptr_sgl
operator|+
name|prp_size
argument_list|)
operator|&
name|page_mask
expr_stmt|;
if|if
condition|(
operator|!
name|page_mask_result
condition|)
block|{
comment|/* 				 * Need to put a PRP list pointer here. 				 */
name|msg_phys
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|msg_phys
operator|+
name|prp_size
operator|)
expr_stmt|;
operator|*
name|ptr_sgl
operator|=
name|htole32
argument_list|(
operator|(
name|uintptr_t
operator|)
name|msg_phys
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ptr_sgl
operator|+
literal|1
operator|)
operator|=
name|htole32
argument_list|(
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|msg_phys
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|ptr_sgl
operator|+=
name|sge_dwords
expr_stmt|;
name|num_entries
operator|++
expr_stmt|;
block|}
comment|/* Need to handle if entry will be part of a page. */
name|offset
operator|=
operator|(
name|uint32_t
operator|)
name|paddr
operator|&
name|page_mask
expr_stmt|;
name|entry_len
operator|=
name|PAGE_SIZE
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|first_prp_entry
condition|)
block|{
comment|/* 				 * Put IEEE entry in first SGE in main message. 				 * (Simple element, System addr, not end of 				 * list.) 				 */
operator|*
name|ptr_first_sgl
operator|=
name|htole32
argument_list|(
operator|(
name|uint32_t
operator|)
name|paddr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ptr_first_sgl
operator|+
literal|1
operator|)
operator|=
name|htole32
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
name|paddr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ptr_first_sgl
operator|+
literal|2
operator|)
operator|=
name|htole32
argument_list|(
name|entry_len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ptr_first_sgl
operator|+
literal|3
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* No longer the first PRP entry. */
name|first_prp_entry
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Put entry in list. */
operator|*
name|ptr_sgl
operator|=
name|htole32
argument_list|(
operator|(
name|uint32_t
operator|)
name|paddr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ptr_sgl
operator|+
literal|1
operator|)
operator|=
name|htole32
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
name|paddr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Bump ptr_sgl, msg_phys, and num_entries. */
name|ptr_sgl
operator|+=
name|sge_dwords
expr_stmt|;
name|msg_phys
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|msg_phys
operator|+
name|prp_size
operator|)
expr_stmt|;
name|num_entries
operator|++
expr_stmt|;
block|}
comment|/* Bump the phys address by the entry_len. */
name|paddr
operator|+=
name|entry_len
expr_stmt|;
comment|/* Decrement length accounting for last partial page. */
if|if
condition|(
name|entry_len
operator|>
name|length
condition|)
name|length
operator|=
literal|0
expr_stmt|;
else|else
name|length
operator|-=
name|entry_len
expr_stmt|;
block|}
block|}
comment|/* Set chain element Length. */
name|main_chain_element
operator|->
name|Length
operator|=
name|htole32
argument_list|(
name|num_entries
operator|*
name|prp_size
argument_list|)
expr_stmt|;
comment|/* Return 0, indicating we built a native SGL. */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add a chain element as the next SGE for the specified command.  * Reset cm_sge and cm_sgesize to indicate all the available space. Chains are  * only required for IEEE commands.  Therefore there is no code for commands  * that have the MPR_CM_FLAGS_SGE_SIMPLE flag set (and those commands  * shouldn't be requesting chains).  */
end_comment

begin_function
specifier|static
name|int
name|mpr_add_chain
parameter_list|(
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|int
name|segsleft
parameter_list|)
block|{
name|struct
name|mpr_softc
modifier|*
name|sc
init|=
name|cm
operator|->
name|cm_sc
decl_stmt|;
name|MPI2_REQUEST_HEADER
modifier|*
name|req
decl_stmt|;
name|MPI25_IEEE_SGE_CHAIN64
modifier|*
name|ieee_sgc
decl_stmt|;
name|struct
name|mpr_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|sgc_size
decl_stmt|,
name|current_segs
decl_stmt|,
name|rem_segs
decl_stmt|,
name|segs_per_frame
decl_stmt|;
name|uint8_t
name|next_chain_offset
init|=
literal|0
decl_stmt|;
comment|/* 	 * Fail if a command is requesting a chain for SIMPLE SGE's.  For SAS3 	 * only IEEE commands should be requesting chains.  Return some error 	 * code other than 0. 	 */
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_SGE_SIMPLE
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_ERROR
argument_list|,
literal|"A chain element cannot be added to "
literal|"an MPI SGL.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|sgc_size
operator|=
sizeof|sizeof
argument_list|(
name|MPI25_IEEE_SGE_CHAIN64
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_sglsize
operator|<
name|sgc_size
condition|)
name|panic
argument_list|(
literal|"MPR: Need SGE Error Code\n"
argument_list|)
expr_stmt|;
name|chain
operator|=
name|mpr_alloc_chain
argument_list|(
name|cm
operator|->
name|cm_sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* 	 * Note: a double-linked list is used to make it easier to walk for 	 * debugging. 	 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cm
operator|->
name|cm_chain_list
argument_list|,
name|chain
argument_list|,
name|chain_link
argument_list|)
expr_stmt|;
comment|/* 	 * Need to know if the number of frames left is more than 1 or not.  If 	 * more than 1 frame is required, NextChainOffset will need to be set, 	 * which will just be the last segment of the frame. 	 */
name|rem_segs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_sglsize
operator|<
operator|(
name|sgc_size
operator|*
name|segsleft
operator|)
condition|)
block|{
comment|/* 		 * rem_segs is the number of segements remaining after the 		 * segments that will go into the current frame.  Since it is 		 * known that at least one more frame is required, account for 		 * the chain element.  To know if more than one more frame is 		 * required, just check if there will be a remainder after using 		 * the current frame (with this chain) and the next frame.  If 		 * so the NextChainOffset must be the last element of the next 		 * frame. 		 */
name|current_segs
operator|=
operator|(
name|cm
operator|->
name|cm_sglsize
operator|/
name|sgc_size
operator|)
operator|-
literal|1
expr_stmt|;
name|rem_segs
operator|=
name|segsleft
operator|-
name|current_segs
expr_stmt|;
name|segs_per_frame
operator|=
name|sc
operator|->
name|chain_frame_size
operator|/
name|sgc_size
expr_stmt|;
if|if
condition|(
name|rem_segs
operator|>
name|segs_per_frame
condition|)
block|{
name|next_chain_offset
operator|=
name|segs_per_frame
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|ieee_sgc
operator|=
operator|&
operator|(
operator|(
name|MPI25_SGE_IO_UNION
operator|*
operator|)
name|cm
operator|->
name|cm_sge
operator|)
operator|->
name|IeeeChain
expr_stmt|;
name|ieee_sgc
operator|->
name|Length
operator|=
name|next_chain_offset
condition|?
name|htole32
argument_list|(
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|chain_frame_size
argument_list|)
else|:
name|htole32
argument_list|(
operator|(
name|uint32_t
operator|)
name|rem_segs
operator|*
operator|(
name|uint32_t
operator|)
name|sgc_size
argument_list|)
expr_stmt|;
name|ieee_sgc
operator|->
name|NextChainOffset
operator|=
name|next_chain_offset
expr_stmt|;
name|ieee_sgc
operator|->
name|Flags
operator|=
operator|(
name|MPI2_IEEE_SGE_FLAGS_CHAIN_ELEMENT
operator||
name|MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR
operator|)
expr_stmt|;
name|ieee_sgc
operator|->
name|Address
operator|.
name|Low
operator|=
name|htole32
argument_list|(
name|chain
operator|->
name|chain_busaddr
argument_list|)
expr_stmt|;
name|ieee_sgc
operator|->
name|Address
operator|.
name|High
operator|=
name|htole32
argument_list|(
name|chain
operator|->
name|chain_busaddr
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|&
operator|(
operator|(
name|MPI25_SGE_IO_UNION
operator|*
operator|)
name|chain
operator|->
name|chain
operator|)
operator|->
name|IeeeSimple
expr_stmt|;
name|req
operator|=
operator|(
name|MPI2_REQUEST_HEADER
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|req
operator|->
name|ChainOffset
operator|=
operator|(
name|sc
operator|->
name|chain_frame_size
operator|-
name|sgc_size
operator|)
operator|>>
literal|4
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
name|sc
operator|->
name|chain_frame_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add one scatter-gather element to the scatter-gather list for a command.  * Maintain cm_sglsize and cm_sge as the remaining size and pointer to the  * next SGE to fill in, respectively.  In Gen3, the MPI SGL does not have a  * chain, so don't consider any chain additions.  */
end_comment

begin_function
name|int
name|mpr_push_sge
parameter_list|(
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|MPI2_SGE_SIMPLE64
modifier|*
name|sge
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|segsleft
parameter_list|)
block|{
name|uint32_t
name|saved_buf_len
decl_stmt|,
name|saved_address_low
decl_stmt|,
name|saved_address_high
decl_stmt|;
name|u32
name|sge_flags
decl_stmt|;
comment|/* 	 * case 1:>=1 more segment, no room for anything (error) 	 * case 2: 1 more segment and enough room for it          */
if|if
condition|(
name|cm
operator|->
name|cm_sglsize
operator|<
operator|(
name|segsleft
operator|*
sizeof|sizeof
argument_list|(
name|MPI2_SGE_SIMPLE64
argument_list|)
operator|)
condition|)
block|{
name|mpr_dprint
argument_list|(
name|cm
operator|->
name|cm_sc
argument_list|,
name|MPR_ERROR
argument_list|,
literal|"%s: warning: Not enough room for MPI SGL in frame.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|segsleft
operator|==
literal|1
argument_list|,
operator|(
literal|"segsleft cannot be more than 1 for an MPI SGL; segsleft = %d\n"
operator|,
name|segsleft
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * There is one more segment left to add for the MPI SGL and there is 	 * enough room in the frame to add it.  This is the normal case because 	 * MPI SGL's don't have chains, otherwise something is wrong. 	 * 	 * If this is a bi-directional request, need to account for that 	 * here.  Save the pre-filled sge values.  These will be used 	 * either for the 2nd SGL or for a single direction SGL.  If 	 * cm_out_len is non-zero, this is a bi-directional request, so 	 * fill in the OUT SGL first, then the IN SGL, otherwise just 	 * fill in the IN SGL.  Note that at this time, when filling in 	 * 2 SGL's for a bi-directional request, they both use the same 	 * DMA buffer (same cm command). 	 */
name|saved_buf_len
operator|=
name|sge
operator|->
name|FlagsLength
operator|&
literal|0x00FFFFFF
expr_stmt|;
name|saved_address_low
operator|=
name|sge
operator|->
name|Address
operator|.
name|Low
expr_stmt|;
name|saved_address_high
operator|=
name|sge
operator|->
name|Address
operator|.
name|High
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_out_len
condition|)
block|{
name|sge
operator|->
name|FlagsLength
operator|=
name|cm
operator|->
name|cm_out_len
operator||
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|MPI2_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI2_SGE_FLAGS_END_OF_BUFFER
operator||
name|MPI2_SGE_FLAGS_HOST_TO_IOC
operator||
name|MPI2_SGE_FLAGS_64_BIT_ADDRESSING
argument_list|)
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|-=
name|len
expr_stmt|;
comment|/* Endian Safe code */
name|sge_flags
operator|=
name|sge
operator|->
name|FlagsLength
expr_stmt|;
name|sge
operator|->
name|FlagsLength
operator|=
name|htole32
argument_list|(
name|sge_flags
argument_list|)
expr_stmt|;
name|sge
operator|->
name|Address
operator|.
name|High
operator|=
name|htole32
argument_list|(
name|sge
operator|->
name|Address
operator|.
name|High
argument_list|)
expr_stmt|;
name|sge
operator|->
name|Address
operator|.
name|Low
operator|=
name|htole32
argument_list|(
name|sge
operator|->
name|Address
operator|.
name|Low
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sge
argument_list|,
name|cm
operator|->
name|cm_sge
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|(
name|MPI2_SGE_IO_UNION
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|cm
operator|->
name|cm_sge
operator|+
name|len
operator|)
expr_stmt|;
block|}
name|sge
operator|->
name|FlagsLength
operator|=
name|saved_buf_len
operator||
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|MPI2_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI2_SGE_FLAGS_END_OF_BUFFER
operator||
name|MPI2_SGE_FLAGS_LAST_ELEMENT
operator||
name|MPI2_SGE_FLAGS_END_OF_LIST
operator||
name|MPI2_SGE_FLAGS_64_BIT_ADDRESSING
argument_list|)
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_DATAIN
condition|)
block|{
name|sge
operator|->
name|FlagsLength
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|MPI2_SGE_FLAGS_IOC_TO_HOST
argument_list|)
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sge
operator|->
name|FlagsLength
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|MPI2_SGE_FLAGS_HOST_TO_IOC
argument_list|)
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
operator|)
expr_stmt|;
block|}
name|sge
operator|->
name|Address
operator|.
name|Low
operator|=
name|saved_address_low
expr_stmt|;
name|sge
operator|->
name|Address
operator|.
name|High
operator|=
name|saved_address_high
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|-=
name|len
expr_stmt|;
comment|/* Endian Safe code */
name|sge_flags
operator|=
name|sge
operator|->
name|FlagsLength
expr_stmt|;
name|sge
operator|->
name|FlagsLength
operator|=
name|htole32
argument_list|(
name|sge_flags
argument_list|)
expr_stmt|;
name|sge
operator|->
name|Address
operator|.
name|High
operator|=
name|htole32
argument_list|(
name|sge
operator|->
name|Address
operator|.
name|High
argument_list|)
expr_stmt|;
name|sge
operator|->
name|Address
operator|.
name|Low
operator|=
name|htole32
argument_list|(
name|sge
operator|->
name|Address
operator|.
name|Low
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sge
argument_list|,
name|cm
operator|->
name|cm_sge
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|(
name|MPI2_SGE_IO_UNION
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|cm
operator|->
name|cm_sge
operator|+
name|len
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add one IEEE scatter-gather element (chain or simple) to the IEEE scatter-  * gather list for a command.  Maintain cm_sglsize and cm_sge as the  * remaining size and pointer to the next SGE to fill in, respectively.  */
end_comment

begin_function
name|int
name|mpr_push_ieee_sge
parameter_list|(
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|void
modifier|*
name|sgep
parameter_list|,
name|int
name|segsleft
parameter_list|)
block|{
name|MPI2_IEEE_SGE_SIMPLE64
modifier|*
name|sge
init|=
name|sgep
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ieee_sge_size
init|=
sizeof|sizeof
argument_list|(
name|MPI25_SGE_IO_UNION
argument_list|)
decl_stmt|;
name|uint32_t
name|saved_buf_len
decl_stmt|,
name|saved_address_low
decl_stmt|,
name|saved_address_high
decl_stmt|;
name|uint32_t
name|sge_length
decl_stmt|;
comment|/* 	 * case 1: No room for chain or segment (error). 	 * case 2: Two or more segments left but only room for chain. 	 * case 3: Last segment and room for it, so set flags. 	 */
comment|/* 	 * There should be room for at least one element, or there is a big 	 * problem. 	 */
if|if
condition|(
name|cm
operator|->
name|cm_sglsize
operator|<
name|ieee_sge_size
condition|)
name|panic
argument_list|(
literal|"MPR: Need SGE Error Code\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|segsleft
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|cm
operator|->
name|cm_sglsize
operator|<
operator|(
name|ieee_sge_size
operator|*
literal|2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|mpr_add_chain
argument_list|(
name|cm
argument_list|,
name|segsleft
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|segsleft
operator|==
literal|1
condition|)
block|{
comment|/* 		 * If this is a bi-directional request, need to account for that 		 * here.  Save the pre-filled sge values.  These will be used 		 * either for the 2nd SGL or for a single direction SGL.  If 		 * cm_out_len is non-zero, this is a bi-directional request, so 		 * fill in the OUT SGL first, then the IN SGL, otherwise just 		 * fill in the IN SGL.  Note that at this time, when filling in 		 * 2 SGL's for a bi-directional request, they both use the same 		 * DMA buffer (same cm command). 		 */
name|saved_buf_len
operator|=
name|sge
operator|->
name|Length
expr_stmt|;
name|saved_address_low
operator|=
name|sge
operator|->
name|Address
operator|.
name|Low
expr_stmt|;
name|saved_address_high
operator|=
name|sge
operator|->
name|Address
operator|.
name|High
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_out_len
condition|)
block|{
name|sge
operator|->
name|Length
operator|=
name|cm
operator|->
name|cm_out_len
expr_stmt|;
name|sge
operator|->
name|Flags
operator|=
operator|(
name|MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR
operator|)
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|-=
name|ieee_sge_size
expr_stmt|;
comment|/* Endian Safe code */
name|sge_length
operator|=
name|sge
operator|->
name|Length
expr_stmt|;
name|sge
operator|->
name|Length
operator|=
name|htole32
argument_list|(
name|sge_length
argument_list|)
expr_stmt|;
name|sge
operator|->
name|Address
operator|.
name|High
operator|=
name|htole32
argument_list|(
name|sge
operator|->
name|Address
operator|.
name|High
argument_list|)
expr_stmt|;
name|sge
operator|->
name|Address
operator|.
name|Low
operator|=
name|htole32
argument_list|(
name|sge
operator|->
name|Address
operator|.
name|Low
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sgep
argument_list|,
name|cm
operator|->
name|cm_sge
argument_list|,
name|ieee_sge_size
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|(
name|MPI25_SGE_IO_UNION
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|cm
operator|->
name|cm_sge
operator|+
name|ieee_sge_size
operator|)
expr_stmt|;
block|}
name|sge
operator|->
name|Length
operator|=
name|saved_buf_len
expr_stmt|;
name|sge
operator|->
name|Flags
operator|=
operator|(
name|MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR
operator||
name|MPI25_IEEE_SGE_FLAGS_END_OF_LIST
operator|)
expr_stmt|;
name|sge
operator|->
name|Address
operator|.
name|Low
operator|=
name|saved_address_low
expr_stmt|;
name|sge
operator|->
name|Address
operator|.
name|High
operator|=
name|saved_address_high
expr_stmt|;
block|}
name|cm
operator|->
name|cm_sglsize
operator|-=
name|ieee_sge_size
expr_stmt|;
comment|/* Endian Safe code */
name|sge_length
operator|=
name|sge
operator|->
name|Length
expr_stmt|;
name|sge
operator|->
name|Length
operator|=
name|htole32
argument_list|(
name|sge_length
argument_list|)
expr_stmt|;
name|sge
operator|->
name|Address
operator|.
name|High
operator|=
name|htole32
argument_list|(
name|sge
operator|->
name|Address
operator|.
name|High
argument_list|)
expr_stmt|;
name|sge
operator|->
name|Address
operator|.
name|Low
operator|=
name|htole32
argument_list|(
name|sge
operator|->
name|Address
operator|.
name|Low
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sgep
argument_list|,
name|cm
operator|->
name|cm_sge
argument_list|,
name|ieee_sge_size
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
operator|(
name|MPI25_SGE_IO_UNION
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|cm
operator|->
name|cm_sge
operator|+
name|ieee_sge_size
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add one dma segment to the scatter-gather list for a command.  */
end_comment

begin_function
name|int
name|mpr_add_dmaseg
parameter_list|(
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|,
name|size_t
name|len
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int
name|segsleft
parameter_list|)
block|{
name|MPI2_SGE_SIMPLE64
name|sge
decl_stmt|;
name|MPI2_IEEE_SGE_SIMPLE64
name|ieee_sge
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_SGE_SIMPLE
operator|)
condition|)
block|{
name|ieee_sge
operator|.
name|Flags
operator|=
operator|(
name|MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR
operator|)
expr_stmt|;
name|ieee_sge
operator|.
name|Length
operator|=
name|len
expr_stmt|;
name|mpr_from_u64
argument_list|(
name|pa
argument_list|,
operator|&
name|ieee_sge
operator|.
name|Address
argument_list|)
expr_stmt|;
return|return
operator|(
name|mpr_push_ieee_sge
argument_list|(
name|cm
argument_list|,
operator|&
name|ieee_sge
argument_list|,
name|segsleft
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * This driver always uses 64-bit address elements for 		 * simplicity. 		 */
name|flags
operator||=
name|MPI2_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI2_SGE_FLAGS_64_BIT_ADDRESSING
expr_stmt|;
comment|/* Set Endian safe macro in mpr_push_sge */
name|sge
operator|.
name|FlagsLength
operator|=
name|len
operator||
operator|(
name|flags
operator|<<
name|MPI2_SGE_FLAGS_SHIFT
operator|)
expr_stmt|;
name|mpr_from_u64
argument_list|(
name|pa
argument_list|,
operator|&
name|sge
operator|.
name|Address
argument_list|)
expr_stmt|;
return|return
operator|(
name|mpr_push_sge
argument_list|(
name|cm
argument_list|,
operator|&
name|sge
argument_list|,
sizeof|sizeof
name|sge
argument_list|,
name|segsleft
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mpr_data_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|mpr_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mpr_command
modifier|*
name|cm
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|dir
decl_stmt|,
name|sflags
decl_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|mpr_command
operator|*
operator|)
name|arg
expr_stmt|;
name|sc
operator|=
name|cm
operator|->
name|cm_sc
expr_stmt|;
comment|/* 	 * In this case, just print out a warning and let the chip tell the 	 * user they did the wrong thing. 	 */
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_max_segs
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|nsegs
operator|>
name|cm
operator|->
name|cm_max_segs
operator|)
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_ERROR
argument_list|,
literal|"%s: warning: busdma returned %d "
literal|"segments, more than the %d allowed\n"
argument_list|,
name|__func__
argument_list|,
name|nsegs
argument_list|,
name|cm
operator|->
name|cm_max_segs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up DMA direction flags.  Bi-directional requests are also handled 	 * here.  In that case, both direction flags will be set. 	 */
name|sflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_SMP_PASS
condition|)
block|{
comment|/* 		 * We have to add a special case for SMP passthrough, there 		 * is no easy way to generically handle it.  The first 		 * S/G element is used for the command (therefore the 		 * direction bit needs to be set).  The second one is used 		 * for the reply.  We'll leave it to the caller to make 		 * sure we only have two buffers. 		 */
comment|/* 		 * Even though the busdma man page says it doesn't make 		 * sense to have both direction flags, it does in this case. 		 * We have one s/g element being accessed in each direction. 		 */
name|dir
operator|=
name|BUS_DMASYNC_PREWRITE
operator||
name|BUS_DMASYNC_PREREAD
expr_stmt|;
comment|/* 		 * Set the direction flag on the first buffer in the SMP 		 * passthrough request.  We'll clear it for the second one. 		 */
name|sflags
operator||=
name|MPI2_SGE_FLAGS_DIRECTION
operator||
name|MPI2_SGE_FLAGS_END_OF_BUFFER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_DATAOUT
condition|)
block|{
name|sflags
operator||=
name|MPI2_SGE_FLAGS_HOST_TO_IOC
expr_stmt|;
name|dir
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
block|}
else|else
name|dir
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
comment|/* Check if a native SG list is needed for an NVMe PCIe device. */
if|if
condition|(
name|cm
operator|->
name|cm_targ
operator|&&
name|cm
operator|->
name|cm_targ
operator|->
name|is_nvme
operator|&&
name|mpr_check_pcie_native_sgl
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* A native SG list was built, skip to end. */
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_SMP_PASS
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|0
operator|)
condition|)
block|{
name|sflags
operator|&=
operator|~
name|MPI2_SGE_FLAGS_DIRECTION
expr_stmt|;
block|}
name|error
operator|=
name|mpr_add_dmaseg
argument_list|(
name|cm
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|,
name|sflags
argument_list|,
name|nsegs
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* Resource shortage, roll back! */
if|if
condition|(
name|ratecheck
argument_list|(
operator|&
name|sc
operator|->
name|lastfail
argument_list|,
operator|&
name|mpr_chainfail_interval
argument_list|)
condition|)
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_INFO
argument_list|,
literal|"Out of chain frames, "
literal|"consider increasing hw.mpr.max_chains.\n"
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MPR_CM_FLAGS_CHAIN_FAILED
expr_stmt|;
name|mpr_complete_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|out
label|:
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|mpr_enqueue_request
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mpr_data_cb2
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|mpr_data_cb
argument_list|(
name|arg
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the routine to enqueue commands ansynchronously.  * Note that the only error path here is from bus_dmamap_load(), which can  * return EINPROGRESS if it is waiting for resources.  Other than this, it's  * assumed that if you have a command in-hand, then you have enough credits  * to use it.  */
end_comment

begin_function
name|int
name|mpr_map_command
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_USE_UIO
condition|)
block|{
name|error
operator|=
name|bus_dmamap_load_uio
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
operator|&
name|cm
operator|->
name|cm_uio
argument_list|,
name|mpr_data_cb2
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_USE_CCB
condition|)
block|{
name|error
operator|=
name|bus_dmamap_load_ccb
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|mpr_data_cb
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|cm
operator|->
name|cm_length
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|cm
operator|->
name|cm_length
argument_list|,
name|mpr_data_cb
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add a zero-length element as needed */
if|if
condition|(
name|cm
operator|->
name|cm_sge
operator|!=
name|NULL
condition|)
name|mpr_add_dmaseg
argument_list|(
name|cm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mpr_enqueue_request
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the routine to enqueue commands synchronously.  An error of  * EINPROGRESS from mpr_map_command() is ignored since the command will  * be executed and enqueued automatically.  Other errors come from msleep().  */
end_comment

begin_function
name|int
name|mpr_wait_command
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|sleep_flag
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|timeval
name|cur_time
decl_stmt|,
name|start_time
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mpr_flags
operator|&
name|MPR_FLAGS_DIAGRESET
condition|)
return|return
name|EBUSY
return|;
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
operator|(
name|MPR_CM_FLAGS_WAKEUP
operator|+
name|MPR_CM_FLAGS_POLLED
operator|)
expr_stmt|;
name|error
operator|=
name|mpr_map_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|error
operator|!=
name|EINPROGRESS
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|// Check for context and wait for 50 mSec at a time until time has
comment|// expired or the command has finished.  If msleep can't be used, need
comment|// to poll.
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1000029
if|if
condition|(
name|curthread
operator|->
name|td_no_sleeping
condition|)
else|#
directive|else
comment|//__FreeBSD_version< 1000029
if|if
condition|(
name|curthread
operator|->
name|td_pflags
operator|&
name|TDP_NOSLEEPING
condition|)
endif|#
directive|endif
comment|//__FreeBSD_version>= 1000029
name|sleep_flag
operator|=
name|NO_SLEEP
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|start_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|)
operator|&&
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
block|{
name|error
operator|=
name|msleep
argument_list|(
name|cm
argument_list|,
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|,
literal|0
argument_list|,
literal|"mprwait"
argument_list|,
name|timeout
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_COMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|mpr_intr_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleep_flag
operator|==
name|CAN_SLEEP
condition|)
name|pause
argument_list|(
literal|"mprwait"
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
else|else
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|cur_time
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cur_time
operator|.
name|tv_sec
operator|-
name|start_time
operator|.
name|tv_sec
operator|)
operator|>
name|timeout
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Calling Reinit from %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|mpr_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Reinit %s\n"
argument_list|,
operator|(
name|rc
operator|==
literal|0
operator|)
condition|?
literal|"success"
else|:
literal|"failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the routine to enqueue a command synchonously and poll for  * completion.  Its use should be rare.  */
end_comment

begin_function
name|int
name|mpr_request_polled
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|timeout
init|=
literal|0
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|timeval
name|cur_time
decl_stmt|,
name|start_time
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MPR_CM_FLAGS_POLLED
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
name|mpr_map_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|start_time
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_COMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
name|mpr_intr_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|)
condition|)
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|msleep_fake_chan
argument_list|,
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|,
literal|0
argument_list|,
literal|"mprpoll"
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
else|else
name|pause
argument_list|(
literal|"mprpoll"
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
comment|/* 		 * Check for real-time timeout and fail if more than 60 seconds. 		 */
name|getmicrotime
argument_list|(
operator|&
name|cur_time
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|cur_time
operator|.
name|tv_sec
operator|-
name|start_time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|60
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"polling failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Calling Reinit from %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|mpr_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Reinit %s\n"
argument_list|,
operator|(
name|rc
operator|==
literal|0
operator|)
condition|?
literal|"success"
else|:
literal|"failed"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The MPT driver had a verbose interface for config pages.  In this driver,  * reduce it to much simpler terms, similar to the Linux driver.  */
end_comment

begin_function
name|int
name|mpr_read_config_page
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_config_params
modifier|*
name|params
parameter_list|)
block|{
name|MPI2_CONFIG_REQUEST
modifier|*
name|req
decl_stmt|;
name|struct
name|mpr_command
modifier|*
name|cm
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mpr_flags
operator|&
name|MPR_FLAGS_BUSY
condition|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|cm
operator|=
name|mpr_alloc_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|req
operator|=
operator|(
name|MPI2_CONFIG_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|req
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_CONFIG
expr_stmt|;
name|req
operator|->
name|Action
operator|=
name|params
operator|->
name|action
expr_stmt|;
name|req
operator|->
name|SGLFlags
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|ChainOffset
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|PageAddress
operator|=
name|params
operator|->
name|page_address
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageType
operator|==
name|MPI2_CONFIG_PAGETYPE_EXTENDED
condition|)
block|{
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|&
name|params
operator|->
name|hdr
operator|.
name|Ext
expr_stmt|;
name|req
operator|->
name|ExtPageType
operator|=
name|hdr
operator|->
name|ExtPageType
expr_stmt|;
name|req
operator|->
name|ExtPageLength
operator|=
name|hdr
operator|->
name|ExtPageLength
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_EXTENDED
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageLength
operator|=
literal|0
expr_stmt|;
comment|/* Must be set to zero */
name|req
operator|->
name|Header
operator|.
name|PageNumber
operator|=
name|hdr
operator|->
name|PageNumber
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|hdr
operator|->
name|PageVersion
expr_stmt|;
block|}
else|else
block|{
name|MPI2_CONFIG_PAGE_HEADER
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|&
name|params
operator|->
name|hdr
operator|.
name|Struct
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageType
operator|=
name|hdr
operator|->
name|PageType
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageNumber
operator|=
name|hdr
operator|->
name|PageNumber
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageLength
operator|=
name|hdr
operator|->
name|PageLength
expr_stmt|;
name|req
operator|->
name|Header
operator|.
name|PageVersion
operator|=
name|hdr
operator|->
name|PageVersion
expr_stmt|;
block|}
name|cm
operator|->
name|cm_data
operator|=
name|params
operator|->
name|buffer
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|params
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_sge
operator|=
operator|&
name|req
operator|->
name|PageBufferSGE
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
sizeof|sizeof
argument_list|(
name|MPI2_SGE_IO_UNION
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MPR_CM_FLAGS_SGE_SIMPLE
operator||
name|MPR_CM_FLAGS_DATAIN
expr_stmt|;
block|}
else|else
name|cm
operator|->
name|cm_sge
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_complete_data
operator|=
name|params
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|callback
operator|!=
name|NULL
condition|)
block|{
name|cm
operator|->
name|cm_complete
operator|=
name|mpr_config_complete
expr_stmt|;
return|return
operator|(
name|mpr_map_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|error
operator|=
name|mpr_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"Error %d reading config page\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mpr_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mpr_config_complete
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mpr_write_config_page
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_config_params
modifier|*
name|params
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpr_config_complete
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|)
block|{
name|MPI2_CONFIG_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mpr_config_params
modifier|*
name|params
decl_stmt|;
name|MPR_FUNCTRACE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|params
operator|=
name|cm
operator|->
name|cm_complete_data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX KDM need to do more error recovery?  This results in the 	 * device in question not getting probed. 	 */
if|if
condition|(
operator|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_ERROR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|params
operator|->
name|status
operator|=
name|MPI2_IOCSTATUS_BUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|reply
operator|=
operator|(
name|MPI2_CONFIG_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|reply
operator|==
name|NULL
condition|)
block|{
name|params
operator|->
name|status
operator|=
name|MPI2_IOCSTATUS_BUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|params
operator|->
name|status
operator|=
name|reply
operator|->
name|IOCStatus
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageType
operator|==
name|MPI2_CONFIG_PAGETYPE_EXTENDED
condition|)
block|{
name|params
operator|->
name|hdr
operator|.
name|Ext
operator|.
name|ExtPageType
operator|=
name|reply
operator|->
name|ExtPageType
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Ext
operator|.
name|ExtPageLength
operator|=
name|reply
operator|->
name|ExtPageLength
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Ext
operator|.
name|PageType
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageType
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Ext
operator|.
name|PageNumber
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageNumber
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Ext
operator|.
name|PageVersion
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageVersion
expr_stmt|;
block|}
else|else
block|{
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageType
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageType
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageNumber
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageNumber
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageLength
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageLength
expr_stmt|;
name|params
operator|->
name|hdr
operator|.
name|Struct
operator|.
name|PageVersion
operator|=
name|reply
operator|->
name|Header
operator|.
name|PageVersion
expr_stmt|;
block|}
name|done
label|:
name|mpr_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|callback
operator|!=
name|NULL
condition|)
name|params
operator|->
name|callback
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

