begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Yahoo!, Inc.  * All rights reserved.  * Written by: John Baldwin<jhb@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Avago Technologies (LSI) MPT-Fusion Host Adapter FreeBSD userland interface  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2011-2015 LSI Corp.  * Copyright (c) 2013-2016 Avago Technologies  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Avago Technologies (LSI) MPT-Fusion Host Adapter FreeBSD  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_comment
comment|/* TODO Move headers to mprvar */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2_type.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2_ioc.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2_cnfg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2_init.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2_tool.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpi/mpi2_pci.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpr_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mprvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpr_table.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpr/mpr_sas.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_decl_stmt
specifier|static
name|d_open_t
name|mpr_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|mpr_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|mpr_ioctl_devsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|mpr_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|mpr_open
block|,
operator|.
name|d_close
operator|=
name|mpr_close
block|,
operator|.
name|d_ioctl
operator|=
name|mpr_ioctl_devsw
block|,
operator|.
name|d_name
operator|=
literal|"mpr"
block|, }
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
function_decl|(
name|mpr_user_f
function_decl|)
parameter_list|(
name|struct
name|mpr_command
modifier|*
parameter_list|,
name|struct
name|mpr_usr_command
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|mpr_user_f
name|mpi_pre_ioc_facts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpr_user_f
name|mpi_pre_port_facts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpr_user_f
name|mpi_pre_fw_download
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpr_user_f
name|mpi_pre_fw_upload
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpr_user_f
name|mpi_pre_sata_passthrough
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpr_user_f
name|mpi_pre_smp_passthrough
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpr_user_f
name|mpi_pre_config
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpr_user_f
name|mpi_pre_sas_io_unit_control
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|mpr_user_read_cfg_header
parameter_list|(
name|struct
name|mpr_softc
modifier|*
parameter_list|,
name|struct
name|mpr_cfg_page_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_user_read_cfg_page
parameter_list|(
name|struct
name|mpr_softc
modifier|*
parameter_list|,
name|struct
name|mpr_cfg_page_req
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_user_read_extcfg_header
parameter_list|(
name|struct
name|mpr_softc
modifier|*
parameter_list|,
name|struct
name|mpr_ext_cfg_page_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_user_read_extcfg_page
parameter_list|(
name|struct
name|mpr_softc
modifier|*
parameter_list|,
name|struct
name|mpr_ext_cfg_page_req
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_user_write_cfg_page
parameter_list|(
name|struct
name|mpr_softc
modifier|*
parameter_list|,
name|struct
name|mpr_cfg_page_req
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_user_setup_request
parameter_list|(
name|struct
name|mpr_command
modifier|*
parameter_list|,
name|struct
name|mpr_usr_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_user_command
parameter_list|(
name|struct
name|mpr_softc
modifier|*
parameter_list|,
name|struct
name|mpr_usr_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_user_pass_thru
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_pass_thru_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpr_user_get_adapter_data
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_adapter_data_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpr_user_read_pci_info
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_pci_info_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|mpr_get_fw_diag_buffer_number
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|unique_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_post_fw_diag_buffer
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_fw_diagnostic_buffer_t
modifier|*
name|pBuffer
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_release_fw_diag_buffer
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_fw_diagnostic_buffer_t
modifier|*
name|pBuffer
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|,
name|uint32_t
name|diag_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_diag_register
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_fw_diag_register_t
modifier|*
name|diag_register
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_diag_unregister
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_fw_diag_unregister_t
modifier|*
name|diag_unregister
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_diag_query
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_fw_diag_query_t
modifier|*
name|diag_query
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_diag_read_buffer
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_diag_read_buffer_t
modifier|*
name|diag_read_buffer
parameter_list|,
name|uint8_t
modifier|*
name|ioctl_buf
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_diag_release
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_fw_diag_release_t
modifier|*
name|diag_release
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_do_diag_action
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|action
parameter_list|,
name|uint8_t
modifier|*
name|diag_action
parameter_list|,
name|uint32_t
name|length
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_user_diag_action
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_diag_action_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpr_user_event_query
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_event_query_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpr_user_event_enable
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_event_enable_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_user_event_report
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_event_report_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_user_reg_access
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_reg_access_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpr_user_btdh
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_btdh_mapping_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MPRUSER
argument_list|,
literal|"mpr_user"
argument_list|,
literal|"Buffers for mpr(4) ioctls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Macros from compat/freebsd32/freebsd32.h */
end_comment

begin_define
define|#
directive|define
name|PTRIN
parameter_list|(
name|v
parameter_list|)
value|(void *)(uintptr_t)(v)
end_define

begin_define
define|#
directive|define
name|PTROUT
parameter_list|(
name|v
parameter_list|)
value|(uint32_t)(uintptr_t)(v)
end_define

begin_define
define|#
directive|define
name|CP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|fld
parameter_list|)
value|do { (dst).fld = (src).fld; } while (0)
end_define

begin_define
define|#
directive|define
name|PTRIN_CP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|fld
parameter_list|)
define|\
value|do { (dst).fld = PTRIN((src).fld); } while (0)
end_define

begin_define
define|#
directive|define
name|PTROUT_CP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|fld
parameter_list|)
define|\
value|do { (dst).fld = PTROUT((src).fld); } while (0)
end_define

begin_comment
comment|/*  * MPI functions that support IEEE SGLs for SAS3.  */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|ieee_sgl_func_list
index|[]
init|=
block|{
name|MPI2_FUNCTION_SCSI_IO_REQUEST
block|,
name|MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH
block|,
name|MPI2_FUNCTION_SMP_PASSTHROUGH
block|,
name|MPI2_FUNCTION_SATA_PASSTHROUGH
block|,
name|MPI2_FUNCTION_FW_UPLOAD
block|,
name|MPI2_FUNCTION_FW_DOWNLOAD
block|,
name|MPI2_FUNCTION_TARGET_ASSIST
block|,
name|MPI2_FUNCTION_TARGET_STATUS_SEND
block|,
name|MPI2_FUNCTION_TOOLBOX
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|mpr_attach_user
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mpr_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|mpr_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"mpr%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mpr_cdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sc
operator|->
name|mpr_cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mpr_detach_user
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* XXX: do a purge of pending requests? */
if|if
condition|(
name|sc
operator|->
name|mpr_cdev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|sc
operator|->
name|mpr_cdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_user_read_cfg_header
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_cfg_page_req
modifier|*
name|page_req
parameter_list|)
block|{
name|MPI2_CONFIG_PAGE_HEADER
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mpr_config_params
name|params
decl_stmt|;
name|int
name|error
decl_stmt|;
name|hdr
operator|=
operator|&
name|params
operator|.
name|hdr
operator|.
name|Struct
expr_stmt|;
name|params
operator|.
name|action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_HEADER
expr_stmt|;
name|params
operator|.
name|page_address
operator|=
name|le32toh
argument_list|(
name|page_req
operator|->
name|page_address
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|PageVersion
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|PageLength
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|PageNumber
operator|=
name|page_req
operator|->
name|header
operator|.
name|PageNumber
expr_stmt|;
name|hdr
operator|->
name|PageType
operator|=
name|page_req
operator|->
name|header
operator|.
name|PageType
expr_stmt|;
name|params
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|params
operator|.
name|callback
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mpr_read_config_page
argument_list|(
name|sc
argument_list|,
operator|&
name|params
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Leave the request. Without resetting the chip, it's 		 * still owned by it and we'll just get into trouble 		 * freeing it now. Mark it as abandoned so that if it 		 * shows up later it can be freed. 		 */
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"read_cfg_header timed out\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|page_req
operator|->
name|ioc_status
operator|=
name|htole16
argument_list|(
name|params
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|page_req
operator|->
name|ioc_status
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|==
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
name|bcopy
argument_list|(
name|hdr
argument_list|,
operator|&
name|page_req
operator|->
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|page_req
operator|->
name|header
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_user_read_cfg_page
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_cfg_page_req
modifier|*
name|page_req
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|MPI2_CONFIG_PAGE_HEADER
modifier|*
name|reqhdr
decl_stmt|,
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mpr_config_params
name|params
decl_stmt|;
name|int
name|error
decl_stmt|;
name|reqhdr
operator|=
name|buf
expr_stmt|;
name|hdr
operator|=
operator|&
name|params
operator|.
name|hdr
operator|.
name|Struct
expr_stmt|;
name|hdr
operator|->
name|PageVersion
operator|=
name|reqhdr
operator|->
name|PageVersion
expr_stmt|;
name|hdr
operator|->
name|PageLength
operator|=
name|reqhdr
operator|->
name|PageLength
expr_stmt|;
name|hdr
operator|->
name|PageNumber
operator|=
name|reqhdr
operator|->
name|PageNumber
expr_stmt|;
name|hdr
operator|->
name|PageType
operator|=
name|reqhdr
operator|->
name|PageType
operator|&
name|MPI2_CONFIG_PAGETYPE_MASK
expr_stmt|;
name|params
operator|.
name|action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_READ_CURRENT
expr_stmt|;
name|params
operator|.
name|page_address
operator|=
name|le32toh
argument_list|(
name|page_req
operator|->
name|page_address
argument_list|)
expr_stmt|;
name|params
operator|.
name|buffer
operator|=
name|buf
expr_stmt|;
name|params
operator|.
name|length
operator|=
name|le32toh
argument_list|(
name|page_req
operator|->
name|len
argument_list|)
expr_stmt|;
name|params
operator|.
name|callback
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mpr_read_config_page
argument_list|(
name|sc
argument_list|,
operator|&
name|params
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"mpr_user_read_cfg_page timed out\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|page_req
operator|->
name|ioc_status
operator|=
name|htole16
argument_list|(
name|params
operator|.
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_user_read_extcfg_header
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_ext_cfg_page_req
modifier|*
name|ext_page_req
parameter_list|)
block|{
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mpr_config_params
name|params
decl_stmt|;
name|int
name|error
decl_stmt|;
name|hdr
operator|=
operator|&
name|params
operator|.
name|hdr
operator|.
name|Ext
expr_stmt|;
name|params
operator|.
name|action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_HEADER
expr_stmt|;
name|hdr
operator|->
name|PageVersion
operator|=
name|ext_page_req
operator|->
name|header
operator|.
name|PageVersion
expr_stmt|;
name|hdr
operator|->
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_EXTENDED
expr_stmt|;
name|hdr
operator|->
name|ExtPageLength
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|PageNumber
operator|=
name|ext_page_req
operator|->
name|header
operator|.
name|PageNumber
expr_stmt|;
name|hdr
operator|->
name|ExtPageType
operator|=
name|ext_page_req
operator|->
name|header
operator|.
name|ExtPageType
expr_stmt|;
name|params
operator|.
name|page_address
operator|=
name|le32toh
argument_list|(
name|ext_page_req
operator|->
name|page_address
argument_list|)
expr_stmt|;
name|params
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|params
operator|.
name|callback
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mpr_read_config_page
argument_list|(
name|sc
argument_list|,
operator|&
name|params
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Leave the request. Without resetting the chip, it's 		 * still owned by it and we'll just get into trouble 		 * freeing it now. Mark it as abandoned so that if it 		 * shows up later it can be freed. 		 */
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"mpr_user_read_extcfg_header timed out\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|ext_page_req
operator|->
name|ioc_status
operator|=
name|htole16
argument_list|(
name|params
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ext_page_req
operator|->
name|ioc_status
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|==
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
name|ext_page_req
operator|->
name|header
operator|.
name|PageVersion
operator|=
name|hdr
operator|->
name|PageVersion
expr_stmt|;
name|ext_page_req
operator|->
name|header
operator|.
name|PageNumber
operator|=
name|hdr
operator|->
name|PageNumber
expr_stmt|;
name|ext_page_req
operator|->
name|header
operator|.
name|PageType
operator|=
name|hdr
operator|->
name|PageType
expr_stmt|;
name|ext_page_req
operator|->
name|header
operator|.
name|ExtPageLength
operator|=
name|hdr
operator|->
name|ExtPageLength
expr_stmt|;
name|ext_page_req
operator|->
name|header
operator|.
name|ExtPageType
operator|=
name|hdr
operator|->
name|ExtPageType
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_user_read_extcfg_page
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_ext_cfg_page_req
modifier|*
name|ext_page_req
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
modifier|*
name|reqhdr
decl_stmt|,
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mpr_config_params
name|params
decl_stmt|;
name|int
name|error
decl_stmt|;
name|reqhdr
operator|=
name|buf
expr_stmt|;
name|hdr
operator|=
operator|&
name|params
operator|.
name|hdr
operator|.
name|Ext
expr_stmt|;
name|params
operator|.
name|action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_READ_CURRENT
expr_stmt|;
name|params
operator|.
name|page_address
operator|=
name|le32toh
argument_list|(
name|ext_page_req
operator|->
name|page_address
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|PageVersion
operator|=
name|reqhdr
operator|->
name|PageVersion
expr_stmt|;
name|hdr
operator|->
name|PageType
operator|=
name|MPI2_CONFIG_PAGETYPE_EXTENDED
expr_stmt|;
name|hdr
operator|->
name|PageNumber
operator|=
name|reqhdr
operator|->
name|PageNumber
expr_stmt|;
name|hdr
operator|->
name|ExtPageType
operator|=
name|reqhdr
operator|->
name|ExtPageType
expr_stmt|;
name|hdr
operator|->
name|ExtPageLength
operator|=
name|reqhdr
operator|->
name|ExtPageLength
expr_stmt|;
name|params
operator|.
name|buffer
operator|=
name|buf
expr_stmt|;
name|params
operator|.
name|length
operator|=
name|le32toh
argument_list|(
name|ext_page_req
operator|->
name|len
argument_list|)
expr_stmt|;
name|params
operator|.
name|callback
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mpr_read_config_page
argument_list|(
name|sc
argument_list|,
operator|&
name|params
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"mpr_user_read_extcfg_page timed out\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|ext_page_req
operator|->
name|ioc_status
operator|=
name|htole16
argument_list|(
name|params
operator|.
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_user_write_cfg_page
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_cfg_page_req
modifier|*
name|page_req
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|MPI2_CONFIG_PAGE_HEADER
modifier|*
name|reqhdr
decl_stmt|,
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mpr_config_params
name|params
decl_stmt|;
name|u_int
name|hdr_attr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|reqhdr
operator|=
name|buf
expr_stmt|;
name|hdr
operator|=
operator|&
name|params
operator|.
name|hdr
operator|.
name|Struct
expr_stmt|;
name|hdr_attr
operator|=
name|reqhdr
operator|->
name|PageType
operator|&
name|MPI2_CONFIG_PAGEATTR_MASK
expr_stmt|;
if|if
condition|(
name|hdr_attr
operator|!=
name|MPI2_CONFIG_PAGEATTR_CHANGEABLE
operator|&&
name|hdr_attr
operator|!=
name|MPI2_CONFIG_PAGEATTR_PERSISTENT
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"page type 0x%x not changeable\n"
argument_list|,
name|reqhdr
operator|->
name|PageType
operator|&
name|MPI2_CONFIG_PAGETYPE_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * There isn't any point in restoring stripped out attributes 	 * if you then mask them going down to issue the request. 	 */
name|hdr
operator|->
name|PageVersion
operator|=
name|reqhdr
operator|->
name|PageVersion
expr_stmt|;
name|hdr
operator|->
name|PageLength
operator|=
name|reqhdr
operator|->
name|PageLength
expr_stmt|;
name|hdr
operator|->
name|PageNumber
operator|=
name|reqhdr
operator|->
name|PageNumber
expr_stmt|;
name|hdr
operator|->
name|PageType
operator|=
name|reqhdr
operator|->
name|PageType
expr_stmt|;
name|params
operator|.
name|action
operator|=
name|MPI2_CONFIG_ACTION_PAGE_WRITE_CURRENT
expr_stmt|;
name|params
operator|.
name|page_address
operator|=
name|le32toh
argument_list|(
name|page_req
operator|->
name|page_address
argument_list|)
expr_stmt|;
name|params
operator|.
name|buffer
operator|=
name|buf
expr_stmt|;
name|params
operator|.
name|length
operator|=
name|le32toh
argument_list|(
name|page_req
operator|->
name|len
argument_list|)
expr_stmt|;
name|params
operator|.
name|callback
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mpr_write_config_page
argument_list|(
name|sc
argument_list|,
operator|&
name|params
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"mpr_write_cfg_page timed out\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|page_req
operator|->
name|ioc_status
operator|=
name|htole16
argument_list|(
name|params
operator|.
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mpr_init_sge
parameter_list|(
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|void
modifier|*
name|req
parameter_list|,
name|void
modifier|*
name|sge
parameter_list|)
block|{
name|int
name|off
decl_stmt|,
name|space
decl_stmt|;
name|space
operator|=
operator|(
name|int
operator|)
name|cm
operator|->
name|cm_sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
expr_stmt|;
name|off
operator|=
operator|(
name|uintptr_t
operator|)
name|sge
operator|-
operator|(
name|uintptr_t
operator|)
name|req
expr_stmt|;
name|KASSERT
argument_list|(
name|off
operator|<
name|space
argument_list|,
operator|(
literal|"bad pointers %p %p, off %d, space %d"
operator|,
name|req
operator|,
name|sge
operator|,
name|off
operator|,
name|space
operator|)
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_sge
operator|=
name|sge
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
name|space
operator|-
name|off
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prepare the mpr_command for an IOC_FACTS request.  */
end_comment

begin_function
specifier|static
name|int
name|mpi_pre_ioc_facts
parameter_list|(
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|struct
name|mpr_usr_command
modifier|*
name|cmd
parameter_list|)
block|{
name|MPI2_IOC_FACTS_REQUEST
modifier|*
name|req
init|=
operator|(
name|void
operator|*
operator|)
name|cm
operator|->
name|cm_req
decl_stmt|;
name|MPI2_IOC_FACTS_REPLY
modifier|*
name|rpl
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|req_len
operator|!=
sizeof|sizeof
expr|*
name|req
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cmd
operator|->
name|rpl_len
operator|!=
sizeof|sizeof
expr|*
name|rpl
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cm
operator|->
name|cm_sge
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepare the mpr_command for a PORT_FACTS request.  */
end_comment

begin_function
specifier|static
name|int
name|mpi_pre_port_facts
parameter_list|(
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|struct
name|mpr_usr_command
modifier|*
name|cmd
parameter_list|)
block|{
name|MPI2_PORT_FACTS_REQUEST
modifier|*
name|req
init|=
operator|(
name|void
operator|*
operator|)
name|cm
operator|->
name|cm_req
decl_stmt|;
name|MPI2_PORT_FACTS_REPLY
modifier|*
name|rpl
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|req_len
operator|!=
sizeof|sizeof
expr|*
name|req
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cmd
operator|->
name|rpl_len
operator|!=
sizeof|sizeof
expr|*
name|rpl
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cm
operator|->
name|cm_sge
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepare the mpr_command for a FW_DOWNLOAD request.  */
end_comment

begin_function
specifier|static
name|int
name|mpi_pre_fw_download
parameter_list|(
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|struct
name|mpr_usr_command
modifier|*
name|cmd
parameter_list|)
block|{
name|MPI25_FW_DOWNLOAD_REQUEST
modifier|*
name|req
init|=
operator|(
name|void
operator|*
operator|)
name|cm
operator|->
name|cm_req
decl_stmt|;
name|MPI2_FW_DOWNLOAD_REPLY
modifier|*
name|rpl
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|req_len
operator|!=
sizeof|sizeof
expr|*
name|req
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cmd
operator|->
name|rpl_len
operator|!=
sizeof|sizeof
expr|*
name|rpl
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cmd
operator|->
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|cmd
operator|->
name|buf
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|cmd
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mpr_init_sge
argument_list|(
name|cm
argument_list|,
name|req
argument_list|,
operator|&
name|req
operator|->
name|SGL
argument_list|)
expr_stmt|;
comment|/* 	 * For now, the F/W image must be provided in a single request. 	 */
if|if
condition|(
operator|(
name|req
operator|->
name|MsgFlags
operator|&
name|MPI2_FW_DOWNLOAD_MSGFLGS_LAST_SEGMENT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|req
operator|->
name|TotalImageSize
operator|!=
name|cmd
operator|->
name|len
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|req
operator|->
name|ImageOffset
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|ImageSize
operator|=
name|cmd
operator|->
name|len
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MPR_CM_FLAGS_DATAOUT
expr_stmt|;
return|return
operator|(
name|mpr_push_ieee_sge
argument_list|(
name|cm
argument_list|,
operator|&
name|req
operator|->
name|SGL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepare the mpr_command for a FW_UPLOAD request.  */
end_comment

begin_function
specifier|static
name|int
name|mpi_pre_fw_upload
parameter_list|(
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|struct
name|mpr_usr_command
modifier|*
name|cmd
parameter_list|)
block|{
name|MPI25_FW_UPLOAD_REQUEST
modifier|*
name|req
init|=
operator|(
name|void
operator|*
operator|)
name|cm
operator|->
name|cm_req
decl_stmt|;
name|MPI2_FW_UPLOAD_REPLY
modifier|*
name|rpl
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|req_len
operator|!=
sizeof|sizeof
expr|*
name|req
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cmd
operator|->
name|rpl_len
operator|!=
sizeof|sizeof
expr|*
name|rpl
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mpr_init_sge
argument_list|(
name|cm
argument_list|,
name|req
argument_list|,
operator|&
name|req
operator|->
name|SGL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|len
operator|==
literal|0
condition|)
block|{
comment|/* Perhaps just asking what the size of the fw is? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|req
operator|->
name|ImageOffset
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|ImageSize
operator|=
name|cmd
operator|->
name|len
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator||=
name|MPR_CM_FLAGS_DATAIN
expr_stmt|;
return|return
operator|(
name|mpr_push_ieee_sge
argument_list|(
name|cm
argument_list|,
operator|&
name|req
operator|->
name|SGL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepare the mpr_command for a SATA_PASSTHROUGH request.  */
end_comment

begin_function
specifier|static
name|int
name|mpi_pre_sata_passthrough
parameter_list|(
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|struct
name|mpr_usr_command
modifier|*
name|cmd
parameter_list|)
block|{
name|MPI2_SATA_PASSTHROUGH_REQUEST
modifier|*
name|req
init|=
operator|(
name|void
operator|*
operator|)
name|cm
operator|->
name|cm_req
decl_stmt|;
name|MPI2_SATA_PASSTHROUGH_REPLY
modifier|*
name|rpl
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|req_len
operator|!=
sizeof|sizeof
expr|*
name|req
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cmd
operator|->
name|rpl_len
operator|!=
sizeof|sizeof
expr|*
name|rpl
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mpr_init_sge
argument_list|(
name|cm
argument_list|,
name|req
argument_list|,
operator|&
name|req
operator|->
name|SGL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepare the mpr_command for a SMP_PASSTHROUGH request.  */
end_comment

begin_function
specifier|static
name|int
name|mpi_pre_smp_passthrough
parameter_list|(
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|struct
name|mpr_usr_command
modifier|*
name|cmd
parameter_list|)
block|{
name|MPI2_SMP_PASSTHROUGH_REQUEST
modifier|*
name|req
init|=
operator|(
name|void
operator|*
operator|)
name|cm
operator|->
name|cm_req
decl_stmt|;
name|MPI2_SMP_PASSTHROUGH_REPLY
modifier|*
name|rpl
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|req_len
operator|!=
sizeof|sizeof
expr|*
name|req
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cmd
operator|->
name|rpl_len
operator|!=
sizeof|sizeof
expr|*
name|rpl
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mpr_init_sge
argument_list|(
name|cm
argument_list|,
name|req
argument_list|,
operator|&
name|req
operator|->
name|SGL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepare the mpr_command for a CONFIG request.  */
end_comment

begin_function
specifier|static
name|int
name|mpi_pre_config
parameter_list|(
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|struct
name|mpr_usr_command
modifier|*
name|cmd
parameter_list|)
block|{
name|MPI2_CONFIG_REQUEST
modifier|*
name|req
init|=
operator|(
name|void
operator|*
operator|)
name|cm
operator|->
name|cm_req
decl_stmt|;
name|MPI2_CONFIG_REPLY
modifier|*
name|rpl
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|req_len
operator|!=
sizeof|sizeof
expr|*
name|req
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cmd
operator|->
name|rpl_len
operator|!=
sizeof|sizeof
expr|*
name|rpl
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mpr_init_sge
argument_list|(
name|cm
argument_list|,
name|req
argument_list|,
operator|&
name|req
operator|->
name|PageBufferSGE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepare the mpr_command for a SAS_IO_UNIT_CONTROL request.  */
end_comment

begin_function
specifier|static
name|int
name|mpi_pre_sas_io_unit_control
parameter_list|(
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|struct
name|mpr_usr_command
modifier|*
name|cmd
parameter_list|)
block|{
name|cm
operator|->
name|cm_sge
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_sglsize
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A set of functions to prepare an mpr_command for the various  * supported requests.  */
end_comment

begin_struct
struct|struct
name|mpr_user_func
block|{
name|U8
name|Function
decl_stmt|;
name|mpr_user_f
modifier|*
name|f_pre
decl_stmt|;
block|}
name|mpr_user_func_list
index|[]
init|=
block|{
block|{
name|MPI2_FUNCTION_IOC_FACTS
block|,
name|mpi_pre_ioc_facts
block|}
block|,
block|{
name|MPI2_FUNCTION_PORT_FACTS
block|,
name|mpi_pre_port_facts
block|}
block|,
block|{
name|MPI2_FUNCTION_FW_DOWNLOAD
block|,
name|mpi_pre_fw_download
block|}
block|,
block|{
name|MPI2_FUNCTION_FW_UPLOAD
block|,
name|mpi_pre_fw_upload
block|}
block|,
block|{
name|MPI2_FUNCTION_SATA_PASSTHROUGH
block|,
name|mpi_pre_sata_passthrough
block|}
block|,
block|{
name|MPI2_FUNCTION_SMP_PASSTHROUGH
block|,
name|mpi_pre_smp_passthrough
block|}
block|,
block|{
name|MPI2_FUNCTION_CONFIG
block|,
name|mpi_pre_config
block|}
block|,
block|{
name|MPI2_FUNCTION_SAS_IO_UNIT_CONTROL
block|,
name|mpi_pre_sas_io_unit_control
block|}
block|,
block|{
literal|0xFF
block|,
name|NULL
block|}
comment|/* list end */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|mpr_user_setup_request
parameter_list|(
name|struct
name|mpr_command
modifier|*
name|cm
parameter_list|,
name|struct
name|mpr_usr_command
modifier|*
name|cmd
parameter_list|)
block|{
name|MPI2_REQUEST_HEADER
modifier|*
name|hdr
init|=
operator|(
name|MPI2_REQUEST_HEADER
operator|*
operator|)
name|cm
operator|->
name|cm_req
decl_stmt|;
name|struct
name|mpr_user_func
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|mpr_user_func_list
init|;
name|f
operator|->
name|f_pre
operator|!=
name|NULL
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|hdr
operator|->
name|Function
operator|==
name|f
operator|->
name|Function
condition|)
return|return
operator|(
name|f
operator|->
name|f_pre
argument_list|(
name|cm
argument_list|,
name|cmd
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_user_command
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mpr_usr_command
modifier|*
name|cmd
parameter_list|)
block|{
name|MPI2_REQUEST_HEADER
modifier|*
name|hdr
decl_stmt|;
name|MPI2_DEFAULT_REPLY
modifier|*
name|rpl
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|struct
name|mpr_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cm
operator|=
name|mpr_alloc_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: no mpr requests\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|Ret
goto|;
block|}
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|(
name|MPI2_REQUEST_HEADER
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_USER
argument_list|,
literal|"%s: req %p %d  rpl %p %d\n"
argument_list|,
name|__func__
argument_list|,
name|cmd
operator|->
name|req
argument_list|,
name|cmd
operator|->
name|req_len
argument_list|,
name|cmd
operator|->
name|rpl
argument_list|,
name|cmd
operator|->
name|rpl_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|req_len
operator|>
operator|(
name|int
operator|)
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|RetFreeUnlocked
goto|;
block|}
name|err
operator|=
name|copyin
argument_list|(
name|cmd
operator|->
name|req
argument_list|,
name|hdr
argument_list|,
name|cmd
operator|->
name|req_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|RetFreeUnlocked
goto|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_USER
argument_list|,
literal|"%s: Function %02X MsgFlags %02X\n"
argument_list|,
name|__func__
argument_list|,
name|hdr
operator|->
name|Function
argument_list|,
name|hdr
operator|->
name|MsgFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|buf
operator|=
name|malloc
argument_list|(
name|cmd
operator|->
name|len
argument_list|,
name|M_MPRUSER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|buf
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|cmd
operator|->
name|len
expr_stmt|;
block|}
else|else
block|{
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
literal|0
expr_stmt|;
block|}
name|cm
operator|->
name|cm_flags
operator|=
name|MPR_CM_FLAGS_SGE_SIMPLE
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|err
operator|=
name|mpr_user_setup_request
argument_list|(
name|cm
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EINVAL
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: unsupported parameter or unsupported "
literal|"function in request (function = 0x%X)\n"
argument_list|,
name|__func__
argument_list|,
name|hdr
operator|->
name|Function
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|RetFreeUnlocked
goto|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|mpr_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|30
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: invalid request: error %d\n"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|Ret
goto|;
block|}
name|rpl
operator|=
operator|(
name|MPI2_DEFAULT_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
name|rpl
operator|!=
name|NULL
condition|)
name|sz
operator|=
name|rpl
operator|->
name|MsgLength
operator|*
literal|4
expr_stmt|;
else|else
name|sz
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|cmd
operator|->
name|rpl_len
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: user reply buffer (%d) smaller than "
literal|"returned buffer (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|cmd
operator|->
name|rpl_len
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|sz
operator|=
name|cmd
operator|->
name|rpl_len
expr_stmt|;
block|}
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|rpl
argument_list|,
name|cmd
operator|->
name|rpl
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|copyout
argument_list|(
name|buf
argument_list|,
name|cmd
operator|->
name|buf
argument_list|,
name|cmd
operator|->
name|len
argument_list|)
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_USER
argument_list|,
literal|"%s: reply size %d\n"
argument_list|,
name|__func__
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|RetFreeUnlocked
label|:
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|!=
name|NULL
condition|)
name|mpr_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
name|Ret
label|:
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|,
name|M_MPRUSER
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_user_pass_thru
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_pass_thru_t
modifier|*
name|data
parameter_list|)
block|{
name|MPI2_REQUEST_HEADER
modifier|*
name|hdr
decl_stmt|,
name|tmphdr
decl_stmt|;
name|MPI2_DEFAULT_REPLY
modifier|*
name|rpl
decl_stmt|;
name|Mpi26NVMeEncapsulatedErrorReply_t
modifier|*
name|nvme_error_reply
init|=
name|NULL
decl_stmt|;
name|Mpi26NVMeEncapsulatedRequest_t
modifier|*
name|nvme_encap_request
init|=
name|NULL
decl_stmt|;
name|struct
name|mpr_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|,
name|dir
init|=
literal|0
decl_stmt|,
name|sz
decl_stmt|;
name|uint8_t
name|tool
decl_stmt|,
name|function
init|=
literal|0
decl_stmt|;
name|u_int
name|sense_len
decl_stmt|;
name|struct
name|mprsas_target
modifier|*
name|targ
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Only allow one passthru command at a time.  Use the MPR_FLAGS_BUSY 	 * bit to denote that a passthru is being processed. 	 */
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mpr_flags
operator|&
name|MPR_FLAGS_BUSY
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_USER
argument_list|,
literal|"%s: Only one passthru command "
literal|"allowed at a single time."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|sc
operator|->
name|mpr_flags
operator||=
name|MPR_FLAGS_BUSY
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Do some validation on data direction.  Valid cases are: 	 *    1) DataSize is 0 and direction is NONE 	 *    2) DataSize is non-zero and one of: 	 *        a) direction is READ or 	 *        b) direction is WRITE or 	 *        c) direction is BOTH and DataOutSize is non-zero 	 * If valid and the direction is BOTH, change the direction to READ. 	 * if valid and the direction is not BOTH, make sure DataOutSize is 0. 	 */
if|if
condition|(
operator|(
operator|(
name|data
operator|->
name|DataSize
operator|==
literal|0
operator|)
operator|&&
operator|(
name|data
operator|->
name|DataDirection
operator|==
name|MPR_PASS_THRU_DIRECTION_NONE
operator|)
operator|)
operator|||
operator|(
operator|(
name|data
operator|->
name|DataSize
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|data
operator|->
name|DataDirection
operator|==
name|MPR_PASS_THRU_DIRECTION_READ
operator|)
operator|||
operator|(
name|data
operator|->
name|DataDirection
operator|==
name|MPR_PASS_THRU_DIRECTION_WRITE
operator|)
operator|||
operator|(
operator|(
name|data
operator|->
name|DataDirection
operator|==
name|MPR_PASS_THRU_DIRECTION_BOTH
operator|)
operator|&&
operator|(
name|data
operator|->
name|DataOutSize
operator|!=
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|DataDirection
operator|==
name|MPR_PASS_THRU_DIRECTION_BOTH
condition|)
name|data
operator|->
name|DataDirection
operator|=
name|MPR_PASS_THRU_DIRECTION_READ
expr_stmt|;
else|else
name|data
operator|->
name|DataOutSize
operator|=
literal|0
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_USER
argument_list|,
literal|"%s: req 0x%jx %d  rpl 0x%jx %d "
literal|"data in 0x%jx %d data out 0x%jx %d data dir %d\n"
argument_list|,
name|__func__
argument_list|,
name|data
operator|->
name|PtrRequest
argument_list|,
name|data
operator|->
name|RequestSize
argument_list|,
name|data
operator|->
name|PtrReply
argument_list|,
name|data
operator|->
name|ReplySize
argument_list|,
name|data
operator|->
name|PtrData
argument_list|,
name|data
operator|->
name|DataSize
argument_list|,
name|data
operator|->
name|PtrDataOut
argument_list|,
name|data
operator|->
name|DataOutSize
argument_list|,
name|data
operator|->
name|DataDirection
argument_list|)
expr_stmt|;
comment|/* 	 * copy in the header so we know what we're dealing with before we 	 * commit to allocating a command for it. 	 */
name|err
operator|=
name|copyin
argument_list|(
name|PTRIN
argument_list|(
name|data
operator|->
name|PtrRequest
argument_list|)
argument_list|,
operator|&
name|tmphdr
argument_list|,
name|data
operator|->
name|RequestSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|RetFreeUnlocked
goto|;
if|if
condition|(
name|data
operator|->
name|RequestSize
operator|>
operator|(
name|int
operator|)
name|sc
operator|->
name|facts
operator|->
name|IOCRequestFrameSize
operator|*
literal|4
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|RetFreeUnlocked
goto|;
block|}
name|function
operator|=
name|tmphdr
operator|.
name|Function
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_USER
argument_list|,
literal|"%s: Function %02X MsgFlags %02X\n"
argument_list|,
name|__func__
argument_list|,
name|function
argument_list|,
name|tmphdr
operator|.
name|MsgFlags
argument_list|)
expr_stmt|;
comment|/* 	 * Handle a passthru TM request. 	 */
if|if
condition|(
name|function
operator|==
name|MPI2_FUNCTION_SCSI_TASK_MGMT
condition|)
block|{
name|MPI2_SCSI_TASK_MANAGE_REQUEST
modifier|*
name|task
decl_stmt|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cm
operator|=
name|mprsas_alloc_tm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|Ret
goto|;
block|}
comment|/* Copy the header in.  Only a small fixup is needed. */
name|task
operator|=
operator|(
name|MPI2_SCSI_TASK_MANAGE_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|tmphdr
argument_list|,
name|task
argument_list|,
name|data
operator|->
name|RequestSize
argument_list|)
expr_stmt|;
name|task
operator|->
name|TaskMID
operator|=
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|SMID
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|HighPriority
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY
expr_stmt|;
name|cm
operator|->
name|cm_complete
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_complete_data
operator|=
name|NULL
expr_stmt|;
name|targ
operator|=
name|mprsas_find_target_by_handle
argument_list|(
name|sc
operator|->
name|sassc
argument_list|,
literal|0
argument_list|,
name|task
operator|->
name|DevHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|==
name|NULL
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_INFO
argument_list|,
literal|"%s %d : invalid handle for requested TM 0x%x \n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|task
operator|->
name|DevHandle
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mprsas_prepare_for_tm
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
name|targ
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
name|err
operator|=
name|mpr_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|30
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|EIO
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"%s: task management failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Copy the reply data and sense data to user space. 		 */
if|if
condition|(
name|cm
operator|->
name|cm_reply
operator|!=
name|NULL
condition|)
block|{
name|rpl
operator|=
operator|(
name|MPI2_DEFAULT_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
name|sz
operator|=
name|rpl
operator|->
name|MsgLength
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|data
operator|->
name|ReplySize
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: user reply buffer (%d) "
literal|"smaller than returned buffer (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|data
operator|->
name|ReplySize
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|cm
operator|->
name|cm_reply
argument_list|,
name|PTRIN
argument_list|(
name|data
operator|->
name|PtrReply
argument_list|)
argument_list|,
name|data
operator|->
name|ReplySize
argument_list|)
expr_stmt|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|mprsas_free_tm
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
goto|goto
name|Ret
goto|;
block|}
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cm
operator|=
name|mpr_alloc_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: no mpr requests\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|Ret
goto|;
block|}
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|(
name|MPI2_REQUEST_HEADER
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|tmphdr
argument_list|,
name|hdr
argument_list|,
name|data
operator|->
name|RequestSize
argument_list|)
expr_stmt|;
comment|/* 	 * Do some checking to make sure the IOCTL request contains a valid 	 * request.  Then set the SGL info. 	 */
name|mpr_init_sge
argument_list|(
name|cm
argument_list|,
name|hdr
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|hdr
operator|+
name|data
operator|->
name|RequestSize
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set up for read, write or both.  From check above, DataOutSize will 	 * be 0 if direction is READ or WRITE, but it will have some non-zero 	 * value if the direction is BOTH.  So, just use the biggest size to get 	 * the cm_data buffer size.  If direction is BOTH, 2 SGLs need to be set 	 * up; the first is for the request and the second will contain the 	 * response data. cm_out_len needs to be set here and this will be used 	 * when the SGLs are set up. 	 */
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
name|MAX
argument_list|(
name|data
operator|->
name|DataSize
argument_list|,
name|data
operator|->
name|DataOutSize
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_out_len
operator|=
name|data
operator|->
name|DataOutSize
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_length
operator|!=
literal|0
condition|)
block|{
name|cm
operator|->
name|cm_data
operator|=
name|malloc
argument_list|(
name|cm
operator|->
name|cm_length
argument_list|,
name|M_MPRUSER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_flags
operator|=
name|MPR_CM_FLAGS_DATAIN
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|DataOutSize
condition|)
block|{
name|cm
operator|->
name|cm_flags
operator||=
name|MPR_CM_FLAGS_DATAOUT
expr_stmt|;
name|err
operator|=
name|copyin
argument_list|(
name|PTRIN
argument_list|(
name|data
operator|->
name|PtrDataOut
argument_list|)
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|data
operator|->
name|DataOutSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|DataDirection
operator|==
name|MPR_PASS_THRU_DIRECTION_WRITE
condition|)
block|{
name|cm
operator|->
name|cm_flags
operator|=
name|MPR_CM_FLAGS_DATAOUT
expr_stmt|;
name|err
operator|=
name|copyin
argument_list|(
name|PTRIN
argument_list|(
name|data
operator|->
name|PtrData
argument_list|)
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|data
operator|->
name|DataSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"%s: failed to copy IOCTL "
literal|"data from user space\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set this flag only if processing a command that does not need an 	 * IEEE SGL.  The CLI Tool within the Toolbox uses IEEE SGLs, so clear 	 * the flag only for that tool if processing a Toolbox function. 	 */
name|cm
operator|->
name|cm_flags
operator||=
name|MPR_CM_FLAGS_SGE_SIMPLE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ieee_sgl_func_list
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|function
operator|==
name|ieee_sgl_func_list
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|function
operator|==
name|MPI2_FUNCTION_TOOLBOX
condition|)
block|{
name|tool
operator|=
operator|(
name|uint8_t
operator|)
name|hdr
operator|->
name|FunctionDependent1
expr_stmt|;
if|if
condition|(
name|tool
operator|!=
name|MPI2_TOOLBOX_DIAGNOSTIC_CLI_TOOL
condition|)
break|break;
block|}
name|cm
operator|->
name|cm_flags
operator|&=
operator|~
name|MPR_CM_FLAGS_SGE_SIMPLE
expr_stmt|;
break|break;
block|}
block|}
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
if|if
condition|(
name|function
operator|==
name|MPI2_FUNCTION_NVME_ENCAPSULATED
condition|)
block|{
name|nvme_encap_request
operator|=
operator|(
name|Mpi26NVMeEncapsulatedRequest_t
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI26_REQ_DESCRIPT_FLAGS_PCIE_ENCAPSULATED
expr_stmt|;
comment|/* 		 * Get the Physical Address of the sense buffer. 		 * Save the user's Error Response buffer address and use that 		 *   field to hold the sense buffer address. 		 * Clear the internal sense buffer, which will potentially hold 		 *   the Completion Queue Entry on return, or 0 if no Entry. 		 * Build the PRPs and set direction bits. 		 * Send the request. 		 */
name|cm
operator|->
name|nvme_error_response
operator|=
operator|(
name|uint64_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
operator|(
operator|(
name|uint64_t
operator|)
name|nvme_encap_request
operator|->
name|ErrorResponseBaseAddress
operator|.
name|High
operator|<<
literal|32
operator|)
operator||
operator|(
name|uint64_t
operator|)
name|nvme_encap_request
operator|->
name|ErrorResponseBaseAddress
operator|.
name|Low
argument_list|)
expr_stmt|;
name|nvme_encap_request
operator|->
name|ErrorResponseBaseAddress
operator|.
name|High
operator|=
name|htole32
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
name|cm
operator|->
name|cm_sense_busaddr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|nvme_encap_request
operator|->
name|ErrorResponseBaseAddress
operator|.
name|Low
operator|=
name|htole32
argument_list|(
name|cm
operator|->
name|cm_sense_busaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cm
operator|->
name|cm_sense
argument_list|,
literal|0
argument_list|,
name|NVME_ERROR_RESPONSE_SIZE
argument_list|)
expr_stmt|;
name|mpr_build_nvme_prp
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
name|nvme_encap_request
argument_list|,
name|cm
operator|->
name|cm_data
argument_list|,
name|data
operator|->
name|DataSize
argument_list|,
name|data
operator|->
name|DataOutSize
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up Sense buffer and SGL offset for IO passthru.  SCSI IO request 	 * uses SCSI IO or Fast Path SCSI IO descriptor. 	 */
if|if
condition|(
operator|(
name|function
operator|==
name|MPI2_FUNCTION_SCSI_IO_REQUEST
operator|)
operator|||
operator|(
name|function
operator|==
name|MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH
operator|)
condition|)
block|{
name|MPI2_SCSI_IO_REQUEST
modifier|*
name|scsi_io_req
decl_stmt|;
name|scsi_io_req
operator|=
operator|(
name|MPI2_SCSI_IO_REQUEST
operator|*
operator|)
name|hdr
expr_stmt|;
comment|/* 		 * Put SGE for data and data_out buffer at the end of 		 * scsi_io_request message header (64 bytes in total). 		 * Following above SGEs, the residual space will be used by 		 * sense data. 		 */
name|scsi_io_req
operator|->
name|SenseBufferLength
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|data
operator|->
name|RequestSize
operator|-
literal|64
argument_list|)
expr_stmt|;
name|scsi_io_req
operator|->
name|SenseBufferLowAddress
operator|=
name|htole32
argument_list|(
name|cm
operator|->
name|cm_sense_busaddr
argument_list|)
expr_stmt|;
comment|/* 		 * Set SGLOffset0 value.  This is the number of dwords that SGL 		 * is offset from the beginning of MPI2_SCSI_IO_REQUEST struct. 		 */
name|scsi_io_req
operator|->
name|SGLOffset0
operator|=
literal|24
expr_stmt|;
comment|/* 		 * Setup descriptor info.  RAID passthrough must use the 		 * default request descriptor which is already set, so if this 		 * is a SCSI IO request, change the descriptor to SCSI IO or 		 * Fast Path SCSI IO.  Also, if this is a SCSI IO request, 		 * handle the reply in the mprsas_scsio_complete function. 		 */
if|if
condition|(
name|function
operator|==
name|MPI2_FUNCTION_SCSI_IO_REQUEST
condition|)
block|{
name|targ
operator|=
name|mprsas_find_target_by_handle
argument_list|(
name|sc
operator|->
name|sassc
argument_list|,
literal|0
argument_list|,
name|scsi_io_req
operator|->
name|DevHandle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targ
condition|)
block|{
name|printf
argument_list|(
literal|"No Target found for handle %d\n"
argument_list|,
name|scsi_io_req
operator|->
name|DevHandle
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|RetFreeUnlocked
goto|;
block|}
if|if
condition|(
name|targ
operator|->
name|scsi_req_desc_type
operator|==
name|MPI25_REQ_DESCRIPT_FLAGS_FAST_PATH_SCSI_IO
condition|)
block|{
name|cm
operator|->
name|cm_desc
operator|.
name|FastPathSCSIIO
operator|.
name|RequestFlags
operator|=
name|MPI25_REQ_DESCRIPT_FLAGS_FAST_PATH_SCSI_IO
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|atomic_desc_capable
condition|)
block|{
name|cm
operator|->
name|cm_desc
operator|.
name|FastPathSCSIIO
operator|.
name|DevHandle
operator|=
name|scsi_io_req
operator|->
name|DevHandle
expr_stmt|;
block|}
name|scsi_io_req
operator|->
name|IoFlags
operator||=
name|MPI25_SCSIIO_IOFLAGS_FAST_PATH
expr_stmt|;
block|}
else|else
block|{
name|cm
operator|->
name|cm_desc
operator|.
name|SCSIIO
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|atomic_desc_capable
condition|)
block|{
name|cm
operator|->
name|cm_desc
operator|.
name|SCSIIO
operator|.
name|DevHandle
operator|=
name|scsi_io_req
operator|->
name|DevHandle
expr_stmt|;
block|}
block|}
comment|/* 			 * Make sure the DevHandle is not 0 because this is a 			 * likely error. 			 */
if|if
condition|(
name|scsi_io_req
operator|->
name|DevHandle
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|RetFreeUnlocked
goto|;
block|}
block|}
block|}
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|mpr_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|30
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: invalid request: error %d\n"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|RetFreeUnlocked
goto|;
block|}
comment|/* 	 * Sync the DMA data, if any.  Then copy the data to user space. 	 */
if|if
condition|(
name|cm
operator|->
name|cm_data
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_DATAIN
condition|)
name|dir
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
elseif|else
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_DATAOUT
condition|)
name|dir
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|buffer_dmat
argument_list|,
name|cm
operator|->
name|cm_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cm_flags
operator|&
name|MPR_CM_FLAGS_DATAIN
condition|)
block|{
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|copyout
argument_list|(
name|cm
operator|->
name|cm_data
argument_list|,
name|PTRIN
argument_list|(
name|data
operator|->
name|PtrData
argument_list|)
argument_list|,
name|data
operator|->
name|DataSize
argument_list|)
expr_stmt|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"%s: failed to copy "
literal|"IOCTL data to user space\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Copy the reply data and sense data to user space. 	 */
if|if
condition|(
name|cm
operator|->
name|cm_reply
operator|!=
name|NULL
condition|)
block|{
name|rpl
operator|=
operator|(
name|MPI2_DEFAULT_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
name|sz
operator|=
name|rpl
operator|->
name|MsgLength
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|data
operator|->
name|ReplySize
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: user reply buffer (%d) smaller "
literal|"than returned buffer (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|data
operator|->
name|ReplySize
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|cm
operator|->
name|cm_reply
argument_list|,
name|PTRIN
argument_list|(
name|data
operator|->
name|PtrReply
argument_list|)
argument_list|,
name|data
operator|->
name|ReplySize
argument_list|)
expr_stmt|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|function
operator|==
name|MPI2_FUNCTION_SCSI_IO_REQUEST
operator|)
operator|||
operator|(
name|function
operator|==
name|MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|MPI2_SCSI_IO_REPLY
operator|*
operator|)
name|rpl
operator|)
operator|->
name|SCSIState
operator|&
name|MPI2_SCSI_STATE_AUTOSENSE_VALID
condition|)
block|{
name|sense_len
operator|=
name|MIN
argument_list|(
operator|(
name|le32toh
argument_list|(
operator|(
operator|(
name|MPI2_SCSI_IO_REPLY
operator|*
operator|)
name|rpl
operator|)
operator|->
name|SenseCount
argument_list|)
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|cm
operator|->
name|cm_sense
argument_list|,
name|cm
operator|->
name|cm_req
operator|+
literal|64
argument_list|,
name|sense_len
argument_list|)
expr_stmt|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Copy out the NVMe Error Reponse to user. The Error Response 		 * buffer is given by the user, but a sense buffer is used to 		 * get that data from the IOC. The user's 		 * ErrorResponseBaseAddress is saved in the 		 * 'nvme_error_response' field before the command because that 		 * field is set to a sense buffer. When the command is 		 * complete, the Error Response data from the IOC is copied to 		 * that user address after it is checked for validity. 		 * Also note that 'sense' buffers are not defined for 		 * NVMe commands. Sense terminalogy is only used here so that 		 * the same IOCTL structure and sense buffers can be used for 		 * NVMe. 		 */
if|if
condition|(
name|function
operator|==
name|MPI2_FUNCTION_NVME_ENCAPSULATED
condition|)
block|{
if|if
condition|(
name|cm
operator|->
name|nvme_error_response
operator|==
name|NULL
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_INFO
argument_list|,
literal|"NVMe Error Response "
literal|"buffer is NULL. Response data will not be "
literal|"returned.\n"
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|RetFreeUnlocked
goto|;
block|}
name|nvme_error_reply
operator|=
operator|(
name|Mpi26NVMeEncapsulatedErrorReply_t
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
name|sz
operator|=
name|MIN
argument_list|(
name|le32toh
argument_list|(
name|nvme_error_reply
operator|->
name|ErrorResponseCount
argument_list|)
argument_list|,
name|NVME_ERROR_RESPONSE_SIZE
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|cm
operator|->
name|cm_sense
argument_list|,
name|cm
operator|->
name|nvme_error_response
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RetFreeUnlocked
label|:
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cm
operator|->
name|cm_data
condition|)
name|free
argument_list|(
name|cm
operator|->
name|cm_data
argument_list|,
name|M_MPRUSER
argument_list|)
expr_stmt|;
name|mpr_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
block|}
name|Ret
label|:
name|sc
operator|->
name|mpr_flags
operator|&=
operator|~
name|MPR_FLAGS_BUSY
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpr_user_get_adapter_data
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_adapter_data_t
modifier|*
name|data
parameter_list|)
block|{
name|Mpi2ConfigReply_t
name|mpi_reply
decl_stmt|;
name|Mpi2BiosPage3_t
name|config_page
decl_stmt|;
comment|/* 	 * Use the PCI interface functions to get the Bus, Device, and Function 	 * information. 	 */
name|data
operator|->
name|PciInformation
operator|.
name|u
operator|.
name|bits
operator|.
name|BusNumber
operator|=
name|pci_get_bus
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
expr_stmt|;
name|data
operator|->
name|PciInformation
operator|.
name|u
operator|.
name|bits
operator|.
name|DeviceNumber
operator|=
name|pci_get_slot
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
expr_stmt|;
name|data
operator|->
name|PciInformation
operator|.
name|u
operator|.
name|bits
operator|.
name|FunctionNumber
operator|=
name|pci_get_function
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
expr_stmt|;
comment|/* 	 * Get the FW version that should already be saved in IOC Facts. 	 */
name|data
operator|->
name|MpiFirmwareVersion
operator|=
name|sc
operator|->
name|facts
operator|->
name|FWVersion
operator|.
name|Word
expr_stmt|;
comment|/* 	 * General device info. 	 */
name|data
operator|->
name|AdapterType
operator|=
name|MPRIOCTL_ADAPTER_TYPE_SAS3
expr_stmt|;
name|data
operator|->
name|PCIDeviceHwId
operator|=
name|pci_get_device
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
expr_stmt|;
name|data
operator|->
name|PCIDeviceHwRev
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|data
operator|->
name|SubSystemId
operator|=
name|pci_get_subdevice
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
expr_stmt|;
name|data
operator|->
name|SubsystemVendorId
operator|=
name|pci_get_subvendor
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
expr_stmt|;
comment|/* 	 * Get the driver version. 	 */
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|data
operator|->
name|DriverVersion
index|[
literal|0
index|]
argument_list|,
name|MPR_DRIVER_VERSION
argument_list|)
expr_stmt|;
comment|/* 	 * Need to get BIOS Config Page 3 for the BIOS Version. 	 */
name|data
operator|->
name|BiosVersion
operator|=
literal|0
expr_stmt|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpr_config_get_bios_pg3
argument_list|(
name|sc
argument_list|,
operator|&
name|mpi_reply
argument_list|,
operator|&
name|config_page
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s: Error while retrieving BIOS Version\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|else
name|data
operator|->
name|BiosVersion
operator|=
name|config_page
operator|.
name|BiosVersion
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpr_user_read_pci_info
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_pci_info_t
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * Use the PCI interface functions to get the Bus, Device, and Function 	 * information. 	 */
name|data
operator|->
name|BusNumber
operator|=
name|pci_get_bus
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
expr_stmt|;
name|data
operator|->
name|DeviceNumber
operator|=
name|pci_get_slot
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
expr_stmt|;
name|data
operator|->
name|FunctionNumber
operator|=
name|pci_get_function
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|)
expr_stmt|;
comment|/* 	 * Now get the interrupt vector and the pci header.  The vector can 	 * only be 0 right now.  The header is the first 256 bytes of config 	 * space. 	 */
name|data
operator|->
name|InterruptVector
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|data
operator|->
name|PciHeader
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|->
name|PciHeader
index|[
name|i
index|]
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|mpr_get_fw_diag_buffer_number
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|unique_id
parameter_list|)
block|{
name|uint8_t
name|index
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|MPI2_DIAG_BUF_TYPE_COUNT
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|fw_diag_buffer_list
index|[
name|index
index|]
operator|.
name|unique_id
operator|==
name|unique_id
condition|)
block|{
return|return
operator|(
name|index
operator|)
return|;
block|}
block|}
return|return
operator|(
name|MPR_FW_DIAGNOSTIC_UID_NOT_FOUND
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_post_fw_diag_buffer
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_fw_diagnostic_buffer_t
modifier|*
name|pBuffer
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|)
block|{
name|MPI2_DIAG_BUFFER_POST_REQUEST
modifier|*
name|req
decl_stmt|;
name|MPI2_DIAG_BUFFER_POST_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mpr_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|status
decl_stmt|;
comment|/* 	 * If buffer is not enabled, just leave. 	 */
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_POST_FAILED
expr_stmt|;
if|if
condition|(
operator|!
name|pBuffer
operator|->
name|enabled
condition|)
block|{
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
comment|/* 	 * Clear some flags initially. 	 */
name|pBuffer
operator|->
name|force_release
operator|=
name|FALSE
expr_stmt|;
name|pBuffer
operator|->
name|valid_data
operator|=
name|FALSE
expr_stmt|;
name|pBuffer
operator|->
name|owned_by_firmware
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Get a command. 	 */
name|cm
operator|=
name|mpr_alloc_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: no mpr requests\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
comment|/* 	 * Build the request for releasing the FW Diag Buffer and send it. 	 */
name|req
operator|=
operator|(
name|MPI2_DIAG_BUFFER_POST_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|req
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_DIAG_BUFFER_POST
expr_stmt|;
name|req
operator|->
name|BufferType
operator|=
name|pBuffer
operator|->
name|buffer_type
expr_stmt|;
name|req
operator|->
name|ExtendedType
operator|=
name|pBuffer
operator|->
name|extended_type
expr_stmt|;
name|req
operator|->
name|BufferLength
operator|=
name|pBuffer
operator|->
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|req
operator|->
name|ProductSpecific
argument_list|)
operator|/
literal|4
operator|)
condition|;
name|i
operator|++
control|)
name|req
operator|->
name|ProductSpecific
index|[
name|i
index|]
operator|=
name|pBuffer
operator|->
name|product_specific
index|[
name|i
index|]
expr_stmt|;
name|mpr_from_u64
argument_list|(
name|sc
operator|->
name|fw_diag_busaddr
argument_list|,
operator|&
name|req
operator|->
name|BufferAddress
argument_list|)
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_complete_data
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Send command synchronously. 	 */
name|status
operator|=
name|mpr_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|30
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: invalid request: error %d\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|status
operator|=
name|MPR_DIAG_FAILURE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Process POST reply. 	 */
name|reply
operator|=
operator|(
name|MPI2_DIAG_BUFFER_POST_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
operator|(
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
condition|)
block|{
name|status
operator|=
name|MPR_DIAG_FAILURE
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"%s: post of FW  Diag Buffer failed "
literal|"with IOCStatus = 0x%x, IOCLogInfo = 0x%x and "
literal|"TransferLength = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|reply
operator|->
name|IOCLogInfo
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|reply
operator|->
name|TransferLength
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Post was successful. 	 */
name|pBuffer
operator|->
name|valid_data
operator|=
name|TRUE
expr_stmt|;
name|pBuffer
operator|->
name|owned_by_firmware
operator|=
name|TRUE
expr_stmt|;
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_SUCCESS
expr_stmt|;
name|status
operator|=
name|MPR_DIAG_SUCCESS
expr_stmt|;
name|done
label|:
name|mpr_free_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_release_fw_diag_buffer
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_fw_diagnostic_buffer_t
modifier|*
name|pBuffer
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|,
name|uint32_t
name|diag_type
parameter_list|)
block|{
name|MPI2_DIAG_RELEASE_REQUEST
modifier|*
name|req
decl_stmt|;
name|MPI2_DIAG_RELEASE_REPLY
modifier|*
name|reply
decl_stmt|;
name|struct
name|mpr_command
modifier|*
name|cm
init|=
name|NULL
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* 	 * If buffer is not enabled, just leave. 	 */
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_RELEASE_FAILED
expr_stmt|;
if|if
condition|(
operator|!
name|pBuffer
operator|->
name|enabled
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_USER
argument_list|,
literal|"%s: This buffer type is not "
literal|"supported by the IOC"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
comment|/* 	 * Clear some flags initially. 	 */
name|pBuffer
operator|->
name|force_release
operator|=
name|FALSE
expr_stmt|;
name|pBuffer
operator|->
name|valid_data
operator|=
name|FALSE
expr_stmt|;
name|pBuffer
operator|->
name|owned_by_firmware
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Get a command. 	 */
name|cm
operator|=
name|mpr_alloc_command
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|==
name|NULL
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: no mpr requests\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
comment|/* 	 * Build the request for releasing the FW Diag Buffer and send it. 	 */
name|req
operator|=
operator|(
name|MPI2_DIAG_RELEASE_REQUEST
operator|*
operator|)
name|cm
operator|->
name|cm_req
expr_stmt|;
name|req
operator|->
name|Function
operator|=
name|MPI2_FUNCTION_DIAG_RELEASE
expr_stmt|;
name|req
operator|->
name|BufferType
operator|=
name|pBuffer
operator|->
name|buffer_type
expr_stmt|;
name|cm
operator|->
name|cm_data
operator|=
name|NULL
expr_stmt|;
name|cm
operator|->
name|cm_length
operator|=
literal|0
expr_stmt|;
name|cm
operator|->
name|cm_desc
operator|.
name|Default
operator|.
name|RequestFlags
operator|=
name|MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE
expr_stmt|;
name|cm
operator|->
name|cm_complete_data
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Send command synchronously. 	 */
name|status
operator|=
name|mpr_wait_command
argument_list|(
name|sc
argument_list|,
name|cm
argument_list|,
literal|30
argument_list|,
name|CAN_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|mpr_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: invalid request: error %d\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|status
operator|=
name|MPR_DIAG_FAILURE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Process RELEASE reply. 	 */
name|reply
operator|=
operator|(
name|MPI2_DIAG_RELEASE_REPLY
operator|*
operator|)
name|cm
operator|->
name|cm_reply
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
operator|&
name|MPI2_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI2_IOCSTATUS_SUCCESS
operator|)
operator|||
name|pBuffer
operator|->
name|owned_by_firmware
condition|)
block|{
name|status
operator|=
name|MPR_DIAG_FAILURE
expr_stmt|;
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_FAULT
argument_list|,
literal|"%s: release of FW Diag Buffer "
literal|"failed with IOCStatus = 0x%x and IOCLogInfo = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|reply
operator|->
name|IOCStatus
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|reply
operator|->
name|IOCLogInfo
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Release was successful. 	 */
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_SUCCESS
expr_stmt|;
name|status
operator|=
name|MPR_DIAG_SUCCESS
expr_stmt|;
comment|/* 	 * If this was for an UNREGISTER diag type command, clear the unique ID. 	 */
if|if
condition|(
name|diag_type
operator|==
name|MPR_FW_DIAG_TYPE_UNREGISTER
condition|)
block|{
name|pBuffer
operator|->
name|unique_id
operator|=
name|MPR_FW_DIAG_INVALID_UID
expr_stmt|;
block|}
name|done
label|:
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_diag_register
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_fw_diag_register_t
modifier|*
name|diag_register
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|)
block|{
name|mpr_fw_diagnostic_buffer_t
modifier|*
name|pBuffer
decl_stmt|;
name|uint8_t
name|extended_type
decl_stmt|,
name|buffer_type
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|buffer_size
decl_stmt|;
name|uint32_t
name|unique_id
decl_stmt|;
name|int
name|status
decl_stmt|;
name|extended_type
operator|=
name|diag_register
operator|->
name|ExtendedType
expr_stmt|;
name|buffer_type
operator|=
name|diag_register
operator|->
name|BufferType
expr_stmt|;
name|buffer_size
operator|=
name|diag_register
operator|->
name|RequestedBufferSize
expr_stmt|;
name|unique_id
operator|=
name|diag_register
operator|->
name|UniqueId
expr_stmt|;
comment|/* 	 * Check for valid buffer type 	 */
if|if
condition|(
name|buffer_type
operator|>=
name|MPI2_DIAG_BUF_TYPE_COUNT
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_PARAMETER
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
comment|/* 	 * Get the current buffer and look up the unique ID.  The unique ID 	 * should not be found.  If it is, the ID is already in use. 	 */
name|i
operator|=
name|mpr_get_fw_diag_buffer_number
argument_list|(
name|sc
argument_list|,
name|unique_id
argument_list|)
expr_stmt|;
name|pBuffer
operator|=
operator|&
name|sc
operator|->
name|fw_diag_buffer_list
index|[
name|buffer_type
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|MPR_FW_DIAGNOSTIC_UID_NOT_FOUND
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_UID
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
comment|/* 	 * The buffer's unique ID should not be registered yet, and the given 	 * unique ID cannot be 0. 	 */
if|if
condition|(
operator|(
name|pBuffer
operator|->
name|unique_id
operator|!=
name|MPR_FW_DIAG_INVALID_UID
operator|)
operator|||
operator|(
name|unique_id
operator|==
name|MPR_FW_DIAG_INVALID_UID
operator|)
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_UID
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
comment|/* 	 * If this buffer is already posted as immediate, just change owner. 	 */
if|if
condition|(
name|pBuffer
operator|->
name|immediate
operator|&&
name|pBuffer
operator|->
name|owned_by_firmware
operator|&&
operator|(
name|pBuffer
operator|->
name|unique_id
operator|==
name|MPR_FW_DIAG_INVALID_UID
operator|)
condition|)
block|{
name|pBuffer
operator|->
name|immediate
operator|=
name|FALSE
expr_stmt|;
name|pBuffer
operator|->
name|unique_id
operator|=
name|unique_id
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_SUCCESS
operator|)
return|;
block|}
comment|/* 	 * Post a new buffer after checking if it's enabled.  The DMA buffer 	 * that is allocated will be contiguous (nsegments = 1). 	 */
if|if
condition|(
operator|!
name|pBuffer
operator|->
name|enabled
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_NO_BUFFER
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|mpr_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|buffer_size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|buffer_size
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|fw_diag_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate FW diag buffer DMA "
literal|"tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|fw_diag_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|fw_diag_buffer
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|fw_diag_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|mpr_dev
argument_list|,
literal|"Cannot allocate FW diag buffer "
literal|"memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|fw_diag_buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|fw_diag_dmat
argument_list|,
name|sc
operator|->
name|fw_diag_map
argument_list|,
name|sc
operator|->
name|fw_diag_buffer
argument_list|,
name|buffer_size
argument_list|,
name|mpr_memaddr_cb
argument_list|,
operator|&
name|sc
operator|->
name|fw_diag_busaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pBuffer
operator|->
name|size
operator|=
name|buffer_size
expr_stmt|;
comment|/* 	 * Copy the given info to the diag buffer and post the buffer. 	 */
name|pBuffer
operator|->
name|buffer_type
operator|=
name|buffer_type
expr_stmt|;
name|pBuffer
operator|->
name|immediate
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|buffer_type
operator|==
name|MPI2_DIAG_BUF_TYPE_TRACE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|pBuffer
operator|->
name|product_specific
argument_list|)
operator|/
literal|4
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|pBuffer
operator|->
name|product_specific
index|[
name|i
index|]
operator|=
name|diag_register
operator|->
name|ProductSpecific
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|pBuffer
operator|->
name|extended_type
operator|=
name|extended_type
expr_stmt|;
name|pBuffer
operator|->
name|unique_id
operator|=
name|unique_id
expr_stmt|;
name|status
operator|=
name|mpr_post_fw_diag_buffer
argument_list|(
name|sc
argument_list|,
name|pBuffer
argument_list|,
name|return_code
argument_list|)
expr_stmt|;
comment|/* 	 * In case there was a failure, free the DMA buffer. 	 */
if|if
condition|(
name|status
operator|==
name|MPR_DIAG_FAILURE
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|fw_diag_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|fw_diag_dmat
argument_list|,
name|sc
operator|->
name|fw_diag_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fw_diag_buffer
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|fw_diag_dmat
argument_list|,
name|sc
operator|->
name|fw_diag_buffer
argument_list|,
name|sc
operator|->
name|fw_diag_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fw_diag_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|fw_diag_dmat
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_diag_unregister
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_fw_diag_unregister_t
modifier|*
name|diag_unregister
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|)
block|{
name|mpr_fw_diagnostic_buffer_t
modifier|*
name|pBuffer
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint32_t
name|unique_id
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unique_id
operator|=
name|diag_unregister
operator|->
name|UniqueId
expr_stmt|;
comment|/* 	 * Get the current buffer and look up the unique ID.  The unique ID 	 * should be there. 	 */
name|i
operator|=
name|mpr_get_fw_diag_buffer_number
argument_list|(
name|sc
argument_list|,
name|unique_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|MPR_FW_DIAGNOSTIC_UID_NOT_FOUND
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_UID
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
name|pBuffer
operator|=
operator|&
name|sc
operator|->
name|fw_diag_buffer_list
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Try to release the buffer from FW before freeing it.  If release 	 * fails, don't free the DMA buffer in case FW tries to access it 	 * later.  If buffer is not owned by firmware, can't release it. 	 */
if|if
condition|(
operator|!
name|pBuffer
operator|->
name|owned_by_firmware
condition|)
block|{
name|status
operator|=
name|MPR_DIAG_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|mpr_release_fw_diag_buffer
argument_list|(
name|sc
argument_list|,
name|pBuffer
argument_list|,
name|return_code
argument_list|,
name|MPR_FW_DIAG_TYPE_UNREGISTER
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * At this point, return the current status no matter what happens with 	 * the DMA buffer. 	 */
name|pBuffer
operator|->
name|unique_id
operator|=
name|MPR_FW_DIAG_INVALID_UID
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|MPR_DIAG_SUCCESS
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|fw_diag_busaddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|fw_diag_dmat
argument_list|,
name|sc
operator|->
name|fw_diag_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fw_diag_buffer
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|fw_diag_dmat
argument_list|,
name|sc
operator|->
name|fw_diag_buffer
argument_list|,
name|sc
operator|->
name|fw_diag_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fw_diag_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|fw_diag_dmat
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_diag_query
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_fw_diag_query_t
modifier|*
name|diag_query
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|)
block|{
name|mpr_fw_diagnostic_buffer_t
modifier|*
name|pBuffer
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint32_t
name|unique_id
decl_stmt|;
name|unique_id
operator|=
name|diag_query
operator|->
name|UniqueId
expr_stmt|;
comment|/* 	 * If ID is valid, query on ID. 	 * If ID is invalid, query on buffer type. 	 */
if|if
condition|(
name|unique_id
operator|==
name|MPR_FW_DIAG_INVALID_UID
condition|)
block|{
name|i
operator|=
name|diag_query
operator|->
name|BufferType
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|MPI2_DIAG_BUF_TYPE_COUNT
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_UID
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
block|}
else|else
block|{
name|i
operator|=
name|mpr_get_fw_diag_buffer_number
argument_list|(
name|sc
argument_list|,
name|unique_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|MPR_FW_DIAGNOSTIC_UID_NOT_FOUND
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_UID
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
block|}
comment|/* 	 * Fill query structure with the diag buffer info. 	 */
name|pBuffer
operator|=
operator|&
name|sc
operator|->
name|fw_diag_buffer_list
index|[
name|i
index|]
expr_stmt|;
name|diag_query
operator|->
name|BufferType
operator|=
name|pBuffer
operator|->
name|buffer_type
expr_stmt|;
name|diag_query
operator|->
name|ExtendedType
operator|=
name|pBuffer
operator|->
name|extended_type
expr_stmt|;
if|if
condition|(
name|diag_query
operator|->
name|BufferType
operator|==
name|MPI2_DIAG_BUF_TYPE_TRACE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|diag_query
operator|->
name|ProductSpecific
argument_list|)
operator|/
literal|4
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|diag_query
operator|->
name|ProductSpecific
index|[
name|i
index|]
operator|=
name|pBuffer
operator|->
name|product_specific
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|diag_query
operator|->
name|TotalBufferSize
operator|=
name|pBuffer
operator|->
name|size
expr_stmt|;
name|diag_query
operator|->
name|DriverAddedBufferSize
operator|=
literal|0
expr_stmt|;
name|diag_query
operator|->
name|UniqueId
operator|=
name|pBuffer
operator|->
name|unique_id
expr_stmt|;
name|diag_query
operator|->
name|ApplicationFlags
operator|=
literal|0
expr_stmt|;
name|diag_query
operator|->
name|DiagnosticFlags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set/Clear application flags 	 */
if|if
condition|(
name|pBuffer
operator|->
name|immediate
condition|)
block|{
name|diag_query
operator|->
name|ApplicationFlags
operator|&=
operator|~
name|MPR_FW_DIAG_FLAG_APP_OWNED
expr_stmt|;
block|}
else|else
block|{
name|diag_query
operator|->
name|ApplicationFlags
operator||=
name|MPR_FW_DIAG_FLAG_APP_OWNED
expr_stmt|;
block|}
if|if
condition|(
name|pBuffer
operator|->
name|valid_data
operator|||
name|pBuffer
operator|->
name|owned_by_firmware
condition|)
block|{
name|diag_query
operator|->
name|ApplicationFlags
operator||=
name|MPR_FW_DIAG_FLAG_BUFFER_VALID
expr_stmt|;
block|}
else|else
block|{
name|diag_query
operator|->
name|ApplicationFlags
operator|&=
operator|~
name|MPR_FW_DIAG_FLAG_BUFFER_VALID
expr_stmt|;
block|}
if|if
condition|(
name|pBuffer
operator|->
name|owned_by_firmware
condition|)
block|{
name|diag_query
operator|->
name|ApplicationFlags
operator||=
name|MPR_FW_DIAG_FLAG_FW_BUFFER_ACCESS
expr_stmt|;
block|}
else|else
block|{
name|diag_query
operator|->
name|ApplicationFlags
operator|&=
operator|~
name|MPR_FW_DIAG_FLAG_FW_BUFFER_ACCESS
expr_stmt|;
block|}
return|return
operator|(
name|MPR_DIAG_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_diag_read_buffer
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_diag_read_buffer_t
modifier|*
name|diag_read_buffer
parameter_list|,
name|uint8_t
modifier|*
name|ioctl_buf
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|)
block|{
name|mpr_fw_diagnostic_buffer_t
modifier|*
name|pBuffer
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
modifier|*
name|pData
decl_stmt|;
name|uint32_t
name|unique_id
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unique_id
operator|=
name|diag_read_buffer
operator|->
name|UniqueId
expr_stmt|;
comment|/* 	 * Get the current buffer and look up the unique ID.  The unique ID 	 * should be there. 	 */
name|i
operator|=
name|mpr_get_fw_diag_buffer_number
argument_list|(
name|sc
argument_list|,
name|unique_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|MPR_FW_DIAGNOSTIC_UID_NOT_FOUND
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_UID
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
name|pBuffer
operator|=
operator|&
name|sc
operator|->
name|fw_diag_buffer_list
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Make sure requested read is within limits 	 */
if|if
condition|(
name|diag_read_buffer
operator|->
name|StartingOffset
operator|+
name|diag_read_buffer
operator|->
name|BytesToRead
operator|>
name|pBuffer
operator|->
name|size
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_PARAMETER
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
comment|/* 	 * Copy the requested data from DMA to the diag_read_buffer.  The DMA 	 * buffer that was allocated is one contiguous buffer. 	 */
name|pData
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|fw_diag_buffer
operator|+
name|diag_read_buffer
operator|->
name|StartingOffset
operator|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|pData
argument_list|,
name|ioctl_buf
argument_list|,
name|diag_read_buffer
operator|->
name|BytesToRead
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
name|diag_read_buffer
operator|->
name|Status
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set or clear the Force Release flag. 	 */
if|if
condition|(
name|pBuffer
operator|->
name|force_release
condition|)
block|{
name|diag_read_buffer
operator|->
name|Flags
operator||=
name|MPR_FW_DIAG_FLAG_FORCE_RELEASE
expr_stmt|;
block|}
else|else
block|{
name|diag_read_buffer
operator|->
name|Flags
operator|&=
operator|~
name|MPR_FW_DIAG_FLAG_FORCE_RELEASE
expr_stmt|;
block|}
comment|/* 	 * If buffer is to be reregistered, make sure it's not already owned by 	 * firmware first. 	 */
name|status
operator|=
name|MPR_DIAG_SUCCESS
expr_stmt|;
if|if
condition|(
operator|!
name|pBuffer
operator|->
name|owned_by_firmware
condition|)
block|{
if|if
condition|(
name|diag_read_buffer
operator|->
name|Flags
operator|&
name|MPR_FW_DIAG_FLAG_REREGISTER
condition|)
block|{
name|status
operator|=
name|mpr_post_fw_diag_buffer
argument_list|(
name|sc
argument_list|,
name|pBuffer
argument_list|,
name|return_code
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_diag_release
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_fw_diag_release_t
modifier|*
name|diag_release
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|)
block|{
name|mpr_fw_diagnostic_buffer_t
modifier|*
name|pBuffer
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint32_t
name|unique_id
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unique_id
operator|=
name|diag_release
operator|->
name|UniqueId
expr_stmt|;
comment|/* 	 * Get the current buffer and look up the unique ID.  The unique ID 	 * should be there. 	 */
name|i
operator|=
name|mpr_get_fw_diag_buffer_number
argument_list|(
name|sc
argument_list|,
name|unique_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|MPR_FW_DIAGNOSTIC_UID_NOT_FOUND
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_UID
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
name|pBuffer
operator|=
operator|&
name|sc
operator|->
name|fw_diag_buffer_list
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * If buffer is not owned by firmware, it's already been released. 	 */
if|if
condition|(
operator|!
name|pBuffer
operator|->
name|owned_by_firmware
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_ALREADY_RELEASED
expr_stmt|;
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
comment|/* 	 * Release the buffer. 	 */
name|status
operator|=
name|mpr_release_fw_diag_buffer
argument_list|(
name|sc
argument_list|,
name|pBuffer
argument_list|,
name|return_code
argument_list|,
name|MPR_FW_DIAG_TYPE_RELEASE
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_do_diag_action
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|action
parameter_list|,
name|uint8_t
modifier|*
name|diag_action
parameter_list|,
name|uint32_t
name|length
parameter_list|,
name|uint32_t
modifier|*
name|return_code
parameter_list|)
block|{
name|mpr_fw_diag_register_t
name|diag_register
decl_stmt|;
name|mpr_fw_diag_unregister_t
name|diag_unregister
decl_stmt|;
name|mpr_fw_diag_query_t
name|diag_query
decl_stmt|;
name|mpr_diag_read_buffer_t
name|diag_read_buffer
decl_stmt|;
name|mpr_fw_diag_release_t
name|diag_release
decl_stmt|;
name|int
name|status
init|=
name|MPR_DIAG_SUCCESS
decl_stmt|;
name|uint32_t
name|original_return_code
decl_stmt|;
name|original_return_code
operator|=
operator|*
name|return_code
expr_stmt|;
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_SUCCESS
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|MPR_FW_DIAG_TYPE_REGISTER
case|:
if|if
condition|(
operator|!
name|length
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_PARAMETER
expr_stmt|;
name|status
operator|=
name|MPR_DIAG_FAILURE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|copyin
argument_list|(
name|diag_action
argument_list|,
operator|&
name|diag_register
argument_list|,
sizeof|sizeof
argument_list|(
name|diag_register
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
name|status
operator|=
name|mpr_diag_register
argument_list|(
name|sc
argument_list|,
operator|&
name|diag_register
argument_list|,
name|return_code
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPR_FW_DIAG_TYPE_UNREGISTER
case|:
if|if
condition|(
name|length
operator|<
sizeof|sizeof
argument_list|(
name|diag_unregister
argument_list|)
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_PARAMETER
expr_stmt|;
name|status
operator|=
name|MPR_DIAG_FAILURE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|copyin
argument_list|(
name|diag_action
argument_list|,
operator|&
name|diag_unregister
argument_list|,
sizeof|sizeof
argument_list|(
name|diag_unregister
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
name|status
operator|=
name|mpr_diag_unregister
argument_list|(
name|sc
argument_list|,
operator|&
name|diag_unregister
argument_list|,
name|return_code
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPR_FW_DIAG_TYPE_QUERY
case|:
if|if
condition|(
name|length
operator|<
sizeof|sizeof
argument_list|(
name|diag_query
argument_list|)
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_PARAMETER
expr_stmt|;
name|status
operator|=
name|MPR_DIAG_FAILURE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|copyin
argument_list|(
name|diag_action
argument_list|,
operator|&
name|diag_query
argument_list|,
sizeof|sizeof
argument_list|(
name|diag_query
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
name|status
operator|=
name|mpr_diag_query
argument_list|(
name|sc
argument_list|,
operator|&
name|diag_query
argument_list|,
name|return_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|MPR_DIAG_SUCCESS
condition|)
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|diag_query
argument_list|,
name|diag_action
argument_list|,
sizeof|sizeof
argument_list|(
name|diag_query
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
break|break;
case|case
name|MPR_FW_DIAG_TYPE_READ_BUFFER
case|:
if|if
condition|(
name|copyin
argument_list|(
name|diag_action
argument_list|,
operator|&
name|diag_read_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|diag_read_buffer
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
if|if
condition|(
name|length
operator|<
name|diag_read_buffer
operator|.
name|BytesToRead
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_PARAMETER
expr_stmt|;
name|status
operator|=
name|MPR_DIAG_FAILURE
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|mpr_diag_read_buffer
argument_list|(
name|sc
argument_list|,
operator|&
name|diag_read_buffer
argument_list|,
name|PTRIN
argument_list|(
name|diag_read_buffer
operator|.
name|PtrDataBuffer
argument_list|)
argument_list|,
name|return_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|MPR_DIAG_SUCCESS
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|diag_read_buffer
argument_list|,
name|diag_action
argument_list|,
sizeof|sizeof
argument_list|(
name|diag_read_buffer
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|diag_read_buffer
operator|.
name|PtrDataBuffer
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
block|}
break|break;
case|case
name|MPR_FW_DIAG_TYPE_RELEASE
case|:
if|if
condition|(
name|length
operator|<
sizeof|sizeof
argument_list|(
name|diag_release
argument_list|)
condition|)
block|{
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_PARAMETER
expr_stmt|;
name|status
operator|=
name|MPR_DIAG_FAILURE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|copyin
argument_list|(
name|diag_action
argument_list|,
operator|&
name|diag_release
argument_list|,
sizeof|sizeof
argument_list|(
name|diag_release
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|MPR_DIAG_FAILURE
operator|)
return|;
name|status
operator|=
name|mpr_diag_release
argument_list|(
name|sc
argument_list|,
operator|&
name|diag_release
argument_list|,
name|return_code
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|return_code
operator|=
name|MPR_FW_DIAG_ERROR_INVALID_PARAMETER
expr_stmt|;
name|status
operator|=
name|MPR_DIAG_FAILURE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|status
operator|==
name|MPR_DIAG_FAILURE
operator|)
operator|&&
operator|(
name|original_return_code
operator|==
name|MPR_FW_DIAG_NEW
operator|)
operator|&&
operator|(
operator|*
name|return_code
operator|!=
name|MPR_FW_DIAG_ERROR_SUCCESS
operator|)
condition|)
name|status
operator|=
name|MPR_DIAG_SUCCESS
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_user_diag_action
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_diag_action_t
modifier|*
name|data
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
comment|/* 	 * Only allow one diag action at one time. 	 */
if|if
condition|(
name|sc
operator|->
name|mpr_flags
operator|&
name|MPR_FLAGS_BUSY
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_USER
argument_list|,
literal|"%s: Only one FW diag command "
literal|"allowed at a single time."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|sc
operator|->
name|mpr_flags
operator||=
name|MPR_FLAGS_BUSY
expr_stmt|;
comment|/* 	 * Send diag action request 	 */
if|if
condition|(
name|data
operator|->
name|Action
operator|==
name|MPR_FW_DIAG_TYPE_REGISTER
operator|||
name|data
operator|->
name|Action
operator|==
name|MPR_FW_DIAG_TYPE_UNREGISTER
operator|||
name|data
operator|->
name|Action
operator|==
name|MPR_FW_DIAG_TYPE_QUERY
operator|||
name|data
operator|->
name|Action
operator|==
name|MPR_FW_DIAG_TYPE_READ_BUFFER
operator|||
name|data
operator|->
name|Action
operator|==
name|MPR_FW_DIAG_TYPE_RELEASE
condition|)
block|{
name|status
operator|=
name|mpr_do_diag_action
argument_list|(
name|sc
argument_list|,
name|data
operator|->
name|Action
argument_list|,
name|PTRIN
argument_list|(
name|data
operator|->
name|PtrDiagAction
argument_list|)
argument_list|,
name|data
operator|->
name|Length
argument_list|,
operator|&
name|data
operator|->
name|ReturnCode
argument_list|)
expr_stmt|;
block|}
else|else
name|status
operator|=
name|EINVAL
expr_stmt|;
name|sc
operator|->
name|mpr_flags
operator|&=
operator|~
name|MPR_FLAGS_BUSY
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy the event recording mask and the event queue size out.  For  * clarification, the event recording mask (events_to_record) is not the same  * thing as the event mask (event_mask).  events_to_record has a bit set for  * every event type that is to be recorded by the driver, and event_mask has a  * bit cleared for every event that is allowed into the driver from the IOC.  * They really have nothing to do with each other.  */
end_comment

begin_function
specifier|static
name|void
name|mpr_user_event_query
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_event_query_t
modifier|*
name|data
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|data
operator|->
name|Entries
operator|=
name|MPR_EVENT_QUEUE_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|->
name|Types
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|events_to_record
index|[
name|i
index|]
expr_stmt|;
block|}
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the driver's event mask according to what's been given.  See  * mpr_user_event_query for explanation of the event recording mask and the IOC  * event mask.  It's the app's responsibility to enable event logging by setting  * the bits in events_to_record.  Initially, no events will be logged.  */
end_comment

begin_function
specifier|static
name|void
name|mpr_user_event_enable
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_event_enable_t
modifier|*
name|data
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|events_to_record
index|[
name|i
index|]
operator|=
name|data
operator|->
name|Types
index|[
name|i
index|]
expr_stmt|;
block|}
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy out the events that have been recorded, up to the max events allowed.  */
end_comment

begin_function
specifier|static
name|int
name|mpr_user_event_report
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_event_report_t
modifier|*
name|data
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|size
operator|=
name|data
operator|->
name|Size
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|recorded_events
argument_list|)
operator|)
operator|&&
operator|(
name|status
operator|==
literal|0
operator|)
condition|)
block|{
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|recorded_events
argument_list|,
name|PTRIN
argument_list|(
name|data
operator|->
name|PtrEvents
argument_list|)
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
name|status
operator|=
name|EFAULT
expr_stmt|;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * data->Size value is not large enough to copy event data. 		 */
name|status
operator|=
name|EFAULT
expr_stmt|;
block|}
comment|/* 	 * Change size value to match the number of bytes that were copied. 	 */
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|data
operator|->
name|Size
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|recorded_events
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Record events into the driver from the IOC if they are not masked.  */
end_comment

begin_function
name|void
name|mprsas_record_event
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|MPI2_EVENT_NOTIFICATION_REPLY
modifier|*
name|event_reply
parameter_list|)
block|{
name|uint32_t
name|event
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint16_t
name|event_data_len
decl_stmt|;
name|boolean_t
name|sendAEN
init|=
name|FALSE
decl_stmt|;
name|event
operator|=
name|event_reply
operator|->
name|Event
expr_stmt|;
comment|/* 	 * Generate a system event to let anyone who cares know that a 	 * LOG_ENTRY_ADDED event has occurred.  This is sent no matter what the 	 * event mask is set to. 	 */
if|if
condition|(
name|event
operator|==
name|MPI2_EVENT_LOG_ENTRY_ADDED
condition|)
block|{
name|sendAEN
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	 * Record the event only if its corresponding bit is set in 	 * events_to_record.  event_index is the index into recorded_events and 	 * event_number is the overall number of an event being recorded since 	 * start-of-day.  event_index will roll over; event_number will never 	 * roll over. 	 */
name|i
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|event
operator|/
literal|32
argument_list|)
expr_stmt|;
name|j
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|event
operator|%
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
literal|4
operator|)
operator|&&
operator|(
operator|(
literal|1
operator|<<
name|j
operator|)
operator|&
name|sc
operator|->
name|events_to_record
index|[
name|i
index|]
operator|)
condition|)
block|{
name|i
operator|=
name|sc
operator|->
name|event_index
expr_stmt|;
name|sc
operator|->
name|recorded_events
index|[
name|i
index|]
operator|.
name|Type
operator|=
name|event
expr_stmt|;
name|sc
operator|->
name|recorded_events
index|[
name|i
index|]
operator|.
name|Number
operator|=
operator|++
name|sc
operator|->
name|event_number
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|recorded_events
index|[
name|i
index|]
operator|.
name|Data
argument_list|,
name|MPR_MAX_EVENT_DATA_LENGTH
operator|*
literal|4
argument_list|)
expr_stmt|;
name|event_data_len
operator|=
name|event_reply
operator|->
name|EventDataLength
expr_stmt|;
if|if
condition|(
name|event_data_len
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Limit data to size in m_event entry 			 */
if|if
condition|(
name|event_data_len
operator|>
name|MPR_MAX_EVENT_DATA_LENGTH
condition|)
block|{
name|event_data_len
operator|=
name|MPR_MAX_EVENT_DATA_LENGTH
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|event_data_len
condition|;
name|j
operator|++
control|)
block|{
name|sc
operator|->
name|recorded_events
index|[
name|i
index|]
operator|.
name|Data
index|[
name|j
index|]
operator|=
name|event_reply
operator|->
name|EventData
index|[
name|j
index|]
expr_stmt|;
block|}
comment|/* 			 * check for index wrap-around 			 */
if|if
condition|(
operator|++
name|i
operator|==
name|MPR_EVENT_QUEUE_SIZE
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|event_index
operator|=
operator|(
name|uint8_t
operator|)
name|i
expr_stmt|;
comment|/* 			 * Set flag to send the event. 			 */
name|sendAEN
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* 	 * Generate a system event if flag is set to let anyone who cares know 	 * that an event has occurred. 	 */
if|if
condition|(
name|sendAEN
condition|)
block|{
comment|//SLM-how to send a system event (see kqueue, kevent)
comment|//		(void) ddi_log_sysevent(mpt->m_dip, DDI_VENDOR_LSI, "MPT_SAS",
comment|//		    "SAS", NULL, NULL, DDI_NOSLEEP);
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_user_reg_access
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_reg_access_t
modifier|*
name|data
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|data
operator|->
name|Command
condition|)
block|{
comment|/* 		 * IO access is not supported. 		 */
case|case
name|REG_IO_READ
case|:
case|case
name|REG_IO_WRITE
case|:
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_USER
argument_list|,
literal|"IO access is not supported. "
literal|"Use memory access."
argument_list|)
expr_stmt|;
name|status
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|REG_MEM_READ
case|:
name|data
operator|->
name|RegData
operator|=
name|mpr_regread
argument_list|(
name|sc
argument_list|,
name|data
operator|->
name|RegOffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_MEM_WRITE
case|:
name|mpr_regwrite
argument_list|(
name|sc
argument_list|,
name|data
operator|->
name|RegOffset
argument_list|,
name|data
operator|->
name|RegData
argument_list|)
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_user_btdh
parameter_list|(
name|struct
name|mpr_softc
modifier|*
name|sc
parameter_list|,
name|mpr_btdh_mapping_t
modifier|*
name|data
parameter_list|)
block|{
name|uint8_t
name|bt2dh
init|=
name|FALSE
decl_stmt|;
name|uint8_t
name|dh2bt
init|=
name|FALSE
decl_stmt|;
name|uint16_t
name|dev_handle
decl_stmt|,
name|bus
decl_stmt|,
name|target
decl_stmt|;
name|bus
operator|=
name|data
operator|->
name|Bus
expr_stmt|;
name|target
operator|=
name|data
operator|->
name|TargetID
expr_stmt|;
name|dev_handle
operator|=
name|data
operator|->
name|DevHandle
expr_stmt|;
comment|/* 	 * When DevHandle is 0xFFFF and Bus/Target are not 0xFFFF, use Bus/ 	 * Target to get DevHandle.  When Bus/Target are 0xFFFF and DevHandle is 	 * not 0xFFFF, use DevHandle to get Bus/Target.  Anything else is 	 * invalid. 	 */
if|if
condition|(
operator|(
name|bus
operator|==
literal|0xFFFF
operator|)
operator|&&
operator|(
name|target
operator|==
literal|0xFFFF
operator|)
operator|&&
operator|(
name|dev_handle
operator|!=
literal|0xFFFF
operator|)
condition|)
name|dh2bt
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|dev_handle
operator|==
literal|0xFFFF
operator|)
operator|&&
operator|(
name|bus
operator|!=
literal|0xFFFF
operator|)
operator|&&
operator|(
name|target
operator|!=
literal|0xFFFF
operator|)
condition|)
name|bt2dh
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|dh2bt
operator|&&
operator|!
name|bt2dh
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Only handle bus of 0.  Make sure target is within range. 	 */
if|if
condition|(
name|bt2dh
condition|)
block|{
if|if
condition|(
name|bus
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|target
operator|>
name|sc
operator|->
name|max_devices
condition|)
block|{
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_XINFO
argument_list|,
literal|"Target ID is out of range "
literal|"for Bus/Target to DevHandle mapping."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|dev_handle
operator|=
name|sc
operator|->
name|mapping_table
index|[
name|target
index|]
operator|.
name|dev_handle
expr_stmt|;
if|if
condition|(
name|dev_handle
condition|)
name|data
operator|->
name|DevHandle
operator|=
name|dev_handle
expr_stmt|;
block|}
else|else
block|{
name|bus
operator|=
literal|0
expr_stmt|;
name|target
operator|=
name|mpr_mapping_get_sas_id_from_handle
argument_list|(
name|sc
argument_list|,
name|dev_handle
argument_list|)
expr_stmt|;
name|data
operator|->
name|Bus
operator|=
name|bus
expr_stmt|;
name|data
operator|->
name|TargetID
operator|=
name|target
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpr_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mpr_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mpr_cfg_page_req
modifier|*
name|page_req
decl_stmt|;
name|struct
name|mpr_ext_cfg_page_req
modifier|*
name|ext_page_req
decl_stmt|;
name|void
modifier|*
name|mpr_page
decl_stmt|;
name|int
name|error
decl_stmt|,
name|msleep_ret
decl_stmt|;
name|mpr_page
operator|=
name|NULL
expr_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|page_req
operator|=
operator|(
name|void
operator|*
operator|)
name|arg
expr_stmt|;
name|ext_page_req
operator|=
operator|(
name|void
operator|*
operator|)
name|arg
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MPRIO_READ_CFG_HEADER
case|:
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mpr_user_read_cfg_header
argument_list|(
name|sc
argument_list|,
name|page_req
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPRIO_READ_CFG_PAGE
case|:
name|mpr_page
operator|=
name|malloc
argument_list|(
name|page_req
operator|->
name|len
argument_list|,
name|M_MPRUSER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|page_req
operator|->
name|buf
argument_list|,
name|mpr_page
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_PAGE_HEADER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mpr_user_read_cfg_page
argument_list|(
name|sc
argument_list|,
name|page_req
argument_list|,
name|mpr_page
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|copyout
argument_list|(
name|mpr_page
argument_list|,
name|page_req
operator|->
name|buf
argument_list|,
name|page_req
operator|->
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPRIO_READ_EXT_CFG_HEADER
case|:
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mpr_user_read_extcfg_header
argument_list|(
name|sc
argument_list|,
name|ext_page_req
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPRIO_READ_EXT_CFG_PAGE
case|:
name|mpr_page
operator|=
name|malloc
argument_list|(
name|ext_page_req
operator|->
name|len
argument_list|,
name|M_MPRUSER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|ext_page_req
operator|->
name|buf
argument_list|,
name|mpr_page
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mpr_user_read_extcfg_page
argument_list|(
name|sc
argument_list|,
name|ext_page_req
argument_list|,
name|mpr_page
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|copyout
argument_list|(
name|mpr_page
argument_list|,
name|ext_page_req
operator|->
name|buf
argument_list|,
name|ext_page_req
operator|->
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPRIO_WRITE_CFG_PAGE
case|:
name|mpr_page
operator|=
name|malloc
argument_list|(
name|page_req
operator|->
name|len
argument_list|,
name|M_MPRUSER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|page_req
operator|->
name|buf
argument_list|,
name|mpr_page
argument_list|,
name|page_req
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mpr_user_write_cfg_page
argument_list|(
name|sc
argument_list|,
name|page_req
argument_list|,
name|mpr_page
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPRIO_MPR_COMMAND
case|:
name|error
operator|=
name|mpr_user_command
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|mpr_usr_command
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPTIOCTL_PASS_THRU
case|:
comment|/* 		 * The user has requested to pass through a command to be 		 * executed by the MPT firmware.  Call our routine which does 		 * this.  Only allow one passthru IOCTL at one time. 		 */
name|error
operator|=
name|mpr_user_pass_thru
argument_list|(
name|sc
argument_list|,
operator|(
name|mpr_pass_thru_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPTIOCTL_GET_ADAPTER_DATA
case|:
comment|/* 		 * The user has requested to read adapter data.  Call our 		 * routine which does this. 		 */
name|error
operator|=
literal|0
expr_stmt|;
name|mpr_user_get_adapter_data
argument_list|(
name|sc
argument_list|,
operator|(
name|mpr_adapter_data_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPTIOCTL_GET_PCI_INFO
case|:
comment|/* 		 * The user has requested to read pci info.  Call 		 * our routine which does this. 		 */
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|mpr_user_read_pci_info
argument_list|(
name|sc
argument_list|,
operator|(
name|mpr_pci_info_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPTIOCTL_RESET_ADAPTER
case|:
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port_enable_complete
operator|=
literal|0
expr_stmt|;
name|uint32_t
name|reinit_start
init|=
name|time_uptime
decl_stmt|;
name|error
operator|=
name|mpr_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Sleep for 300 second. */
name|msleep_ret
operator|=
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|port_enable_complete
argument_list|,
operator|&
name|sc
operator|->
name|mpr_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"mpr_porten"
argument_list|,
literal|300
operator|*
name|hz
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|msleep_ret
condition|)
name|printf
argument_list|(
literal|"Port Enable did not complete after Diag "
literal|"Reset msleep error %d.\n"
argument_list|,
name|msleep_ret
argument_list|)
expr_stmt|;
else|else
name|mpr_dprint
argument_list|(
name|sc
argument_list|,
name|MPR_USER
argument_list|,
literal|"Hard Reset with Port Enable "
literal|"completed in %d seconds.\n"
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|time_uptime
operator|-
name|reinit_start
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPTIOCTL_DIAG_ACTION
case|:
comment|/* 		 * The user has done a diag buffer action.  Call our routine 		 * which does this.  Only allow one diag action at one time. 		 */
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mpr_user_diag_action
argument_list|(
name|sc
argument_list|,
operator|(
name|mpr_diag_action_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPTIOCTL_EVENT_QUERY
case|:
comment|/* 		 * The user has done an event query. Call our routine which does 		 * this. 		 */
name|error
operator|=
literal|0
expr_stmt|;
name|mpr_user_event_query
argument_list|(
name|sc
argument_list|,
operator|(
name|mpr_event_query_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPTIOCTL_EVENT_ENABLE
case|:
comment|/* 		 * The user has done an event enable. Call our routine which 		 * does this. 		 */
name|error
operator|=
literal|0
expr_stmt|;
name|mpr_user_event_enable
argument_list|(
name|sc
argument_list|,
operator|(
name|mpr_event_enable_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPTIOCTL_EVENT_REPORT
case|:
comment|/* 		 * The user has done an event report. Call our routine which 		 * does this. 		 */
name|error
operator|=
name|mpr_user_event_report
argument_list|(
name|sc
argument_list|,
operator|(
name|mpr_event_report_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPTIOCTL_REG_ACCESS
case|:
comment|/* 		 * The user has requested register access.  Call our routine 		 * which does this. 		 */
name|mpr_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mpr_user_reg_access
argument_list|(
name|sc
argument_list|,
operator|(
name|mpr_reg_access_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|mpr_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPTIOCTL_BTDH_MAPPING
case|:
comment|/* 		 * The user has requested to translate a bus/target to a 		 * DevHandle or a DevHandle to a bus/target.  Call our routine 		 * which does this. 		 */
name|error
operator|=
name|mpr_user_btdh
argument_list|(
name|sc
argument_list|,
operator|(
name|mpr_btdh_mapping_t
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOIOCTL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mpr_page
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|mpr_page
argument_list|,
name|M_MPRUSER
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
end_ifdef

begin_struct
struct|struct
name|mpr_cfg_page_req32
block|{
name|MPI2_CONFIG_PAGE_HEADER
name|header
decl_stmt|;
name|uint32_t
name|page_address
decl_stmt|;
name|uint32_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|uint16_t
name|ioc_status
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mpr_ext_cfg_page_req32
block|{
name|MPI2_CONFIG_EXTENDED_PAGE_HEADER
name|header
decl_stmt|;
name|uint32_t
name|page_address
decl_stmt|;
name|uint32_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|uint16_t
name|ioc_status
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mpr_raid_action32
block|{
name|uint8_t
name|action
decl_stmt|;
name|uint8_t
name|volume_bus
decl_stmt|;
name|uint8_t
name|volume_id
decl_stmt|;
name|uint8_t
name|phys_disk_num
decl_stmt|;
name|uint32_t
name|action_data_word
decl_stmt|;
name|uint32_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|uint32_t
name|volume_status
decl_stmt|;
name|uint32_t
name|action_data
index|[
literal|4
index|]
decl_stmt|;
name|uint16_t
name|action_status
decl_stmt|;
name|uint16_t
name|ioc_status
decl_stmt|;
name|uint8_t
name|write
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mpr_usr_command32
block|{
name|uint32_t
name|req
decl_stmt|;
name|uint32_t
name|req_len
decl_stmt|;
name|uint32_t
name|rpl
decl_stmt|;
name|uint32_t
name|rpl_len
decl_stmt|;
name|uint32_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MPRIO_READ_CFG_HEADER32
value|_IOWR('M', 200, struct mpr_cfg_page_req32)
end_define

begin_define
define|#
directive|define
name|MPRIO_READ_CFG_PAGE32
value|_IOWR('M', 201, struct mpr_cfg_page_req32)
end_define

begin_define
define|#
directive|define
name|MPRIO_READ_EXT_CFG_HEADER32
value|_IOWR('M', 202, struct mpr_ext_cfg_page_req32)
end_define

begin_define
define|#
directive|define
name|MPRIO_READ_EXT_CFG_PAGE32
value|_IOWR('M', 203, struct mpr_ext_cfg_page_req32)
end_define

begin_define
define|#
directive|define
name|MPRIO_WRITE_CFG_PAGE32
value|_IOWR('M', 204, struct mpr_cfg_page_req32)
end_define

begin_define
define|#
directive|define
name|MPRIO_RAID_ACTION32
value|_IOWR('M', 205, struct mpr_raid_action32)
end_define

begin_define
define|#
directive|define
name|MPRIO_MPR_COMMAND32
value|_IOWR('M', 210, struct mpr_usr_command32)
end_define

begin_function
specifier|static
name|int
name|mpr_ioctl32
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd32
parameter_list|,
name|void
modifier|*
name|_arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mpr_cfg_page_req32
modifier|*
name|page32
init|=
name|_arg
decl_stmt|;
name|struct
name|mpr_ext_cfg_page_req32
modifier|*
name|ext32
init|=
name|_arg
decl_stmt|;
name|struct
name|mpr_raid_action32
modifier|*
name|raid32
init|=
name|_arg
decl_stmt|;
name|struct
name|mpr_usr_command32
modifier|*
name|user32
init|=
name|_arg
decl_stmt|;
union|union
block|{
name|struct
name|mpr_cfg_page_req
name|page
decl_stmt|;
name|struct
name|mpr_ext_cfg_page_req
name|ext
decl_stmt|;
name|struct
name|mpr_raid_action
name|raid
decl_stmt|;
name|struct
name|mpr_usr_command
name|user
decl_stmt|;
block|}
name|arg
union|;
name|u_long
name|cmd
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|cmd32
condition|)
block|{
case|case
name|MPRIO_READ_CFG_HEADER32
case|:
case|case
name|MPRIO_READ_CFG_PAGE32
case|:
case|case
name|MPRIO_WRITE_CFG_PAGE32
case|:
if|if
condition|(
name|cmd32
operator|==
name|MPRIO_READ_CFG_HEADER32
condition|)
name|cmd
operator|=
name|MPRIO_READ_CFG_HEADER
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd32
operator|==
name|MPRIO_READ_CFG_PAGE32
condition|)
name|cmd
operator|=
name|MPRIO_READ_CFG_PAGE
expr_stmt|;
else|else
name|cmd
operator|=
name|MPRIO_WRITE_CFG_PAGE
expr_stmt|;
name|CP
argument_list|(
operator|*
name|page32
argument_list|,
name|arg
operator|.
name|page
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|page32
argument_list|,
name|arg
operator|.
name|page
argument_list|,
name|page_address
argument_list|)
expr_stmt|;
name|PTRIN_CP
argument_list|(
operator|*
name|page32
argument_list|,
name|arg
operator|.
name|page
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|page32
argument_list|,
name|arg
operator|.
name|page
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|page32
argument_list|,
name|arg
operator|.
name|page
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPRIO_READ_EXT_CFG_HEADER32
case|:
case|case
name|MPRIO_READ_EXT_CFG_PAGE32
case|:
if|if
condition|(
name|cmd32
operator|==
name|MPRIO_READ_EXT_CFG_HEADER32
condition|)
name|cmd
operator|=
name|MPRIO_READ_EXT_CFG_HEADER
expr_stmt|;
else|else
name|cmd
operator|=
name|MPRIO_READ_EXT_CFG_PAGE
expr_stmt|;
name|CP
argument_list|(
operator|*
name|ext32
argument_list|,
name|arg
operator|.
name|ext
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|ext32
argument_list|,
name|arg
operator|.
name|ext
argument_list|,
name|page_address
argument_list|)
expr_stmt|;
name|PTRIN_CP
argument_list|(
operator|*
name|ext32
argument_list|,
name|arg
operator|.
name|ext
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|ext32
argument_list|,
name|arg
operator|.
name|ext
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|ext32
argument_list|,
name|arg
operator|.
name|ext
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPRIO_RAID_ACTION32
case|:
name|cmd
operator|=
name|MPRIO_RAID_ACTION
expr_stmt|;
name|CP
argument_list|(
operator|*
name|raid32
argument_list|,
name|arg
operator|.
name|raid
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|raid32
argument_list|,
name|arg
operator|.
name|raid
argument_list|,
name|volume_bus
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|raid32
argument_list|,
name|arg
operator|.
name|raid
argument_list|,
name|volume_id
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|raid32
argument_list|,
name|arg
operator|.
name|raid
argument_list|,
name|phys_disk_num
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|raid32
argument_list|,
name|arg
operator|.
name|raid
argument_list|,
name|action_data_word
argument_list|)
expr_stmt|;
name|PTRIN_CP
argument_list|(
operator|*
name|raid32
argument_list|,
name|arg
operator|.
name|raid
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|raid32
argument_list|,
name|arg
operator|.
name|raid
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|raid32
argument_list|,
name|arg
operator|.
name|raid
argument_list|,
name|volume_status
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|raid32
operator|->
name|action_data
argument_list|,
name|arg
operator|.
name|raid
operator|.
name|action_data
argument_list|,
sizeof|sizeof
name|arg
operator|.
name|raid
operator|.
name|action_data
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|raid32
argument_list|,
name|arg
operator|.
name|raid
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|raid32
argument_list|,
name|arg
operator|.
name|raid
argument_list|,
name|write
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPRIO_MPR_COMMAND32
case|:
name|cmd
operator|=
name|MPRIO_MPR_COMMAND
expr_stmt|;
name|PTRIN_CP
argument_list|(
operator|*
name|user32
argument_list|,
name|arg
operator|.
name|user
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|user32
argument_list|,
name|arg
operator|.
name|user
argument_list|,
name|req_len
argument_list|)
expr_stmt|;
name|PTRIN_CP
argument_list|(
operator|*
name|user32
argument_list|,
name|arg
operator|.
name|user
argument_list|,
name|rpl
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|user32
argument_list|,
name|arg
operator|.
name|user
argument_list|,
name|rpl_len
argument_list|)
expr_stmt|;
name|PTRIN_CP
argument_list|(
operator|*
name|user32
argument_list|,
name|arg
operator|.
name|user
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|user32
argument_list|,
name|arg
operator|.
name|user
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|CP
argument_list|(
operator|*
name|user32
argument_list|,
name|arg
operator|.
name|user
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
name|error
operator|=
name|mpr_ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
operator|&
name|arg
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|cmd32
operator|&
name|IOC_OUT
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|cmd32
condition|)
block|{
case|case
name|MPRIO_READ_CFG_HEADER32
case|:
case|case
name|MPRIO_READ_CFG_PAGE32
case|:
case|case
name|MPRIO_WRITE_CFG_PAGE32
case|:
name|CP
argument_list|(
name|arg
operator|.
name|page
argument_list|,
operator|*
name|page32
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|page
argument_list|,
operator|*
name|page32
argument_list|,
name|page_address
argument_list|)
expr_stmt|;
name|PTROUT_CP
argument_list|(
name|arg
operator|.
name|page
argument_list|,
operator|*
name|page32
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|page
argument_list|,
operator|*
name|page32
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|page
argument_list|,
operator|*
name|page32
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPRIO_READ_EXT_CFG_HEADER32
case|:
case|case
name|MPRIO_READ_EXT_CFG_PAGE32
case|:
name|CP
argument_list|(
name|arg
operator|.
name|ext
argument_list|,
operator|*
name|ext32
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|ext
argument_list|,
operator|*
name|ext32
argument_list|,
name|page_address
argument_list|)
expr_stmt|;
name|PTROUT_CP
argument_list|(
name|arg
operator|.
name|ext
argument_list|,
operator|*
name|ext32
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|ext
argument_list|,
operator|*
name|ext32
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|ext
argument_list|,
operator|*
name|ext32
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPRIO_RAID_ACTION32
case|:
name|CP
argument_list|(
name|arg
operator|.
name|raid
argument_list|,
operator|*
name|raid32
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|raid
argument_list|,
operator|*
name|raid32
argument_list|,
name|volume_bus
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|raid
argument_list|,
operator|*
name|raid32
argument_list|,
name|volume_id
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|raid
argument_list|,
operator|*
name|raid32
argument_list|,
name|phys_disk_num
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|raid
argument_list|,
operator|*
name|raid32
argument_list|,
name|action_data_word
argument_list|)
expr_stmt|;
name|PTROUT_CP
argument_list|(
name|arg
operator|.
name|raid
argument_list|,
operator|*
name|raid32
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|raid
argument_list|,
operator|*
name|raid32
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|raid
argument_list|,
operator|*
name|raid32
argument_list|,
name|volume_status
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|arg
operator|.
name|raid
operator|.
name|action_data
argument_list|,
name|raid32
operator|->
name|action_data
argument_list|,
sizeof|sizeof
name|arg
operator|.
name|raid
operator|.
name|action_data
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|raid
argument_list|,
operator|*
name|raid32
argument_list|,
name|ioc_status
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|raid
argument_list|,
operator|*
name|raid32
argument_list|,
name|write
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPRIO_MPR_COMMAND32
case|:
name|PTROUT_CP
argument_list|(
name|arg
operator|.
name|user
argument_list|,
operator|*
name|user32
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|user
argument_list|,
operator|*
name|user32
argument_list|,
name|req_len
argument_list|)
expr_stmt|;
name|PTROUT_CP
argument_list|(
name|arg
operator|.
name|user
argument_list|,
operator|*
name|user32
argument_list|,
name|rpl
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|user
argument_list|,
operator|*
name|user32
argument_list|,
name|rpl_len
argument_list|)
expr_stmt|;
name|PTROUT_CP
argument_list|(
name|arg
operator|.
name|user
argument_list|,
operator|*
name|user32
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|user
argument_list|,
operator|*
name|user32
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|arg
operator|.
name|user
argument_list|,
operator|*
name|user32
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_FREEBSD32 */
end_comment

begin_function
specifier|static
name|int
name|mpr_ioctl_devsw
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|com
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
name|SV_CURPROC_FLAG
argument_list|(
name|SV_ILP32
argument_list|)
condition|)
return|return
operator|(
name|mpr_ioctl32
argument_list|(
name|dev
argument_list|,
name|com
argument_list|,
name|arg
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|mpr_ioctl
argument_list|(
name|dev
argument_list|,
name|com
argument_list|,
name|arg
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

