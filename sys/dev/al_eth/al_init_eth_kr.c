begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015,2016 Annapurna Labs Ltd. and affiliates  * All rights reserved.  *  * Developed by Semihalf.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"al_init_eth_kr.h"
end_include

begin_include
include|#
directive|include
file|"al_serdes.h"
end_include

begin_comment
comment|/**  *  Ethernet  *  @{  * @file   al_init_eth_kr.c  *  * @brief  auto-negotiation and link training algorithms and state machines  *  * The link training algorithm implemented in this file going over the  * coefficients and looking for the best eye measurement possible for every one  * of them. it's using state machine to move between the different states.  * the state machine has 3 parts:  *	- preparation - waiting till the link partner (lp) will be ready and  *			change his state to preset.  *	- measurement (per coefficient) - issue decrement for the coefficient  *			under control till the eye measurement not increasing  *			and remains in the optimum.  *	- completion - indicate the receiver is ready and wait for the lp to  *		       finish his work.  */
end_comment

begin_comment
comment|/* TODO: fix with more reasonable numbers */
end_comment

begin_comment
comment|/* timeout in mSec before auto-negotiation will be terminated */
end_comment

begin_define
define|#
directive|define
name|AL_ETH_KR_AN_TIMEOUT
value|(500)
end_define

begin_define
define|#
directive|define
name|AL_ETH_KR_EYE_MEASURE_TIMEOUT
value|(100)
end_define

begin_comment
comment|/* timeout in uSec before the process will be terminated */
end_comment

begin_define
define|#
directive|define
name|AL_ETH_KR_FRAME_LOCK_TIMEOUT
value|(500 * 1000)
end_define

begin_define
define|#
directive|define
name|AL_ETH_KR_LT_DONE_TIMEOUT
value|(500 * 1000)
end_define

begin_comment
comment|/* number of times the receiver and transmitter tasks will be called before the  * algorithm will be terminated */
end_comment

begin_define
define|#
directive|define
name|AL_ETH_KR_LT_MAX_ROUNDS
value|(50000)
end_define

begin_comment
comment|/* mac algorithm state machine */
end_comment

begin_enum
enum|enum
name|al_eth_kr_mac_lt_state
block|{
name|TX_INIT
init|=
literal|0
block|,
comment|/* start of all */
name|WAIT_BEGIN
block|,
comment|/* wait for initial training lock */
name|DO_PRESET
block|,
comment|/* issue PRESET to link partner */
name|DO_HOLD
block|,
comment|/* issue HOLD to link partner */
comment|/* preparation is done, start testing the coefficient. */
name|QMEASURE
block|,
comment|/* EyeQ measurement. */
name|QCHECK
block|,
comment|/* Check if measurement shows best value. */
name|DO_NEXT_TRY
block|,
comment|/* issue DEC command to coeff for next measurement. */
name|END_STEPS
block|,
comment|/* perform last steps to go back to optimum. */
name|END_STEPS_HOLD
block|,
comment|/* perform last steps HOLD command. */
name|COEFF_DONE
block|,
comment|/* done with the current coefficient updates. 			 * Check if another should be done. */
comment|/* end of training to all coefficients */
name|SET_READY
block|,
comment|/* indicate local receiver ready */
name|TX_DONE
comment|/* transmit process completed, training can end. */
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|al_eth_kr_mac_sm_name
index|[]
init|=
block|{
literal|"TX_INIT"
block|,
literal|"WAIT_BEGIN"
block|,
literal|"DO_PRESET"
block|,
literal|"DO_HOLD"
block|,
literal|"QMEASURE"
block|,
literal|"QCHECK"
block|,
literal|"DO_NEXT_TRY"
block|,
literal|"END_STEPS"
block|,
literal|"END_STEPS_HOLD"
block|,
literal|"COEFF_DONE"
block|,
literal|"SET_READY"
block|,
literal|"TX_DONE"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constants used for the measurement. */
end_comment

begin_enum
enum|enum
name|al_eth_kr_coef
block|{
name|AL_ETH_KR_COEF_C_MINUS
block|,
name|AL_ETH_KR_COEF_C_ZERO
block|,
name|AL_ETH_KR_COEF_C_PLUS
block|, }
enum|;
end_enum

begin_comment
comment|/*  * test coefficients from COEFF_TO_MANIPULATE to COEFF_TO_MANIPULATE_LAST.  */
end_comment

begin_define
define|#
directive|define
name|COEFF_TO_MANIPULATE
value|AL_ETH_KR_COEF_C_MINUS
end_define

begin_define
define|#
directive|define
name|COEFF_TO_MANIPULATE_LAST
value|AL_ETH_KR_COEF_C_MINUS
end_define

begin_define
define|#
directive|define
name|QARRAY_SIZE
value|3
end_define

begin_comment
comment|/**< how many entries we want in our history array. */
end_comment

begin_struct
struct|struct
name|al_eth_kr_data
block|{
name|struct
name|al_hal_eth_adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|al_serdes_grp_obj
modifier|*
name|serdes_obj
decl_stmt|;
name|enum
name|al_serdes_lane
name|lane
decl_stmt|;
comment|/* Receiver side data */
name|struct
name|al_eth_kr_status_report_data
name|status_report
decl_stmt|;
comment|/* report to response */
name|struct
name|al_eth_kr_coef_up_data
name|last_lpcoeff
decl_stmt|;
comment|/* last coeff received */
comment|/* Transmitter side data */
name|enum
name|al_eth_kr_mac_lt_state
name|algo_state
decl_stmt|;
comment|/* Statemachine. */
name|unsigned
name|int
name|qarray
index|[
name|QARRAY_SIZE
index|]
decl_stmt|;
comment|/* EyeQ measurements history */
comment|/* How many entries in the array are valid for compares yet. */
name|unsigned
name|int
name|qarray_cnt
decl_stmt|;
name|enum
name|al_eth_kr_coef
name|curr_coeff
decl_stmt|;
comment|/* 	 * Status of coefficient during the last 	 * DEC/INC command (before issuing HOLD again). 	 */
name|unsigned
name|int
name|coeff_status_step
decl_stmt|;
name|unsigned
name|int
name|end_steps_cnt
decl_stmt|;
comment|/* Number of end steps needed */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|al_eth_kr_an_run
parameter_list|(
name|struct
name|al_eth_kr_data
modifier|*
name|kr_data
parameter_list|,
name|struct
name|al_eth_an_adv
modifier|*
name|an_adv
parameter_list|,
name|struct
name|al_eth_an_adv
modifier|*
name|an_partner_adv
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|boolean_t
name|page_received
init|=
name|FALSE
decl_stmt|;
name|boolean_t
name|an_completed
init|=
name|FALSE
decl_stmt|;
name|boolean_t
name|error
init|=
name|FALSE
decl_stmt|;
name|int
name|timeout
init|=
name|AL_ETH_KR_AN_TIMEOUT
decl_stmt|;
name|rc
operator|=
name|al_eth_kr_an_init
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|an_adv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|al_err
argument_list|(
literal|"%s %s autonegotiation init failed\n"
argument_list|,
name|kr_data
operator|->
name|adapter
operator|->
name|name
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|rc
operator|=
name|al_eth_kr_an_start
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|al_err
argument_list|(
literal|"%s %s autonegotiation enable failed\n"
argument_list|,
name|kr_data
operator|->
name|adapter
operator|->
name|name
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
do|do
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|timeout
operator|-=
literal|10
expr_stmt|;
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
block|{
name|al_info
argument_list|(
literal|"%s %s autonegotiation failed on timeout\n"
argument_list|,
name|kr_data
operator|->
name|adapter
operator|->
name|name
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|al_eth_kr_an_status_check
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
operator|&
name|page_received
argument_list|,
operator|&
name|an_completed
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|page_received
operator|==
name|FALSE
condition|)
do|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|al_info
argument_list|(
literal|"%s %s autonegotiation failed (status error)\n"
argument_list|,
name|kr_data
operator|->
name|adapter
operator|->
name|name
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|al_eth_kr_an_read_adv
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|an_partner_adv
argument_list|)
expr_stmt|;
name|al_dbg
argument_list|(
literal|"%s %s autonegotiation completed. error = %d\n"
argument_list|,
name|kr_data
operator|->
name|adapter
operator|->
name|name
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************** receiver side *********************************/
end_comment

begin_function
specifier|static
name|enum
name|al_eth_kr_cl72_cstate
name|al_eth_lt_coeff_set
parameter_list|(
name|struct
name|al_eth_kr_data
modifier|*
name|kr_data
parameter_list|,
name|enum
name|al_serdes_tx_deemph_param
name|param
parameter_list|,
name|uint32_t
name|op
parameter_list|)
block|{
name|enum
name|al_eth_kr_cl72_cstate
name|status
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|AL_PHY_KR_COEF_UP_HOLD
case|:
comment|/* no need to update the serdes - return not updated*/
name|status
operator|=
name|C72_CSTATE_NOT_UPDATED
expr_stmt|;
break|break;
case|case
name|AL_PHY_KR_COEF_UP_INC
case|:
name|status
operator|=
name|C72_CSTATE_UPDATED
expr_stmt|;
if|if
condition|(
name|kr_data
operator|->
name|serdes_obj
operator|->
name|tx_deemph_inc
argument_list|(
name|kr_data
operator|->
name|serdes_obj
argument_list|,
name|kr_data
operator|->
name|lane
argument_list|,
name|param
argument_list|)
operator|==
literal|0
condition|)
name|status
operator|=
name|C72_CSTATE_MAX
expr_stmt|;
break|break;
case|case
name|AL_PHY_KR_COEF_UP_DEC
case|:
name|status
operator|=
name|C72_CSTATE_UPDATED
expr_stmt|;
if|if
condition|(
name|kr_data
operator|->
name|serdes_obj
operator|->
name|tx_deemph_dec
argument_list|(
name|kr_data
operator|->
name|serdes_obj
argument_list|,
name|kr_data
operator|->
name|lane
argument_list|,
name|param
argument_list|)
operator|==
literal|0
condition|)
name|status
operator|=
name|C72_CSTATE_MIN
expr_stmt|;
break|break;
default|default:
comment|/* 3=reserved */
break|break;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Inspect the received coefficient update request and update all coefficients  * in the serdes accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|al_eth_coeff_req_handle
parameter_list|(
name|struct
name|al_eth_kr_data
modifier|*
name|kr_data
parameter_list|,
name|struct
name|al_eth_kr_coef_up_data
modifier|*
name|lpcoeff
parameter_list|)
block|{
name|struct
name|al_eth_kr_status_report_data
modifier|*
name|report
init|=
operator|&
name|kr_data
operator|->
name|status_report
decl_stmt|;
comment|/* First check for Init and Preset commands. */
if|if
condition|(
operator|(
name|lpcoeff
operator|->
name|preset
operator|!=
literal|0
operator|)
operator|||
operator|(
name|lpcoeff
operator|->
name|initialize
operator|)
operator|!=
literal|0
condition|)
block|{
name|kr_data
operator|->
name|serdes_obj
operator|->
name|tx_deemph_preset
argument_list|(
name|kr_data
operator|->
name|serdes_obj
argument_list|,
name|kr_data
operator|->
name|lane
argument_list|)
expr_stmt|;
comment|/* 		 * in case of preset c(0) should be set to maximum and both c(1) 		 * and c(-1) should be updated 		 */
name|report
operator|->
name|c_minus
operator|=
name|C72_CSTATE_UPDATED
expr_stmt|;
name|report
operator|->
name|c_plus
operator|=
name|C72_CSTATE_UPDATED
expr_stmt|;
name|report
operator|->
name|c_zero
operator|=
name|C72_CSTATE_MAX
expr_stmt|;
return|return;
block|}
comment|/* 	 * in case preset and initialize are false need to perform per 	 * coefficient action. 	 */
name|report
operator|->
name|c_minus
operator|=
name|al_eth_lt_coeff_set
argument_list|(
name|kr_data
argument_list|,
name|AL_SERDES_TX_DEEMP_C_MINUS
argument_list|,
name|lpcoeff
operator|->
name|c_minus
argument_list|)
expr_stmt|;
name|report
operator|->
name|c_zero
operator|=
name|al_eth_lt_coeff_set
argument_list|(
name|kr_data
argument_list|,
name|AL_SERDES_TX_DEEMP_C_ZERO
argument_list|,
name|lpcoeff
operator|->
name|c_zero
argument_list|)
expr_stmt|;
name|report
operator|->
name|c_plus
operator|=
name|al_eth_lt_coeff_set
argument_list|(
name|kr_data
argument_list|,
name|AL_SERDES_TX_DEEMP_C_PLUS
argument_list|,
name|lpcoeff
operator|->
name|c_plus
argument_list|)
expr_stmt|;
name|al_dbg
argument_list|(
literal|"%s: c(0) = 0x%x c(-1) = 0x%x c(1) = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|report
operator|->
name|c_zero
argument_list|,
name|report
operator|->
name|c_plus
argument_list|,
name|report
operator|->
name|c_minus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_kr_lt_receiver_task_init
parameter_list|(
name|struct
name|al_eth_kr_data
modifier|*
name|kr_data
parameter_list|)
block|{
name|al_memset
argument_list|(
operator|&
name|kr_data
operator|->
name|last_lpcoeff
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|al_eth_kr_coef_up_data
argument_list|)
argument_list|)
expr_stmt|;
name|al_memset
argument_list|(
operator|&
name|kr_data
operator|->
name|status_report
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|al_eth_kr_status_report_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|al_eth_lp_coeff_up_change
parameter_list|(
name|struct
name|al_eth_kr_data
modifier|*
name|kr_data
parameter_list|,
name|struct
name|al_eth_kr_coef_up_data
modifier|*
name|lpcoeff
parameter_list|)
block|{
name|struct
name|al_eth_kr_coef_up_data
modifier|*
name|last_lpcoeff
init|=
operator|&
name|kr_data
operator|->
name|last_lpcoeff
decl_stmt|;
if|if
condition|(
name|al_memcmp
argument_list|(
name|last_lpcoeff
argument_list|,
name|lpcoeff
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|al_eth_kr_coef_up_data
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|al_memcpy
argument_list|(
name|last_lpcoeff
argument_list|,
name|lpcoeff
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|al_eth_kr_coef_up_data
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the receiver task for one cycle.  * The receiver task continuously inspects the received coefficient update  * requests and acts upon.  *  * @return<0 if error occur  */
end_comment

begin_function
specifier|static
name|int
name|al_eth_kr_lt_receiver_task_run
parameter_list|(
name|struct
name|al_eth_kr_data
modifier|*
name|kr_data
parameter_list|)
block|{
name|struct
name|al_eth_kr_coef_up_data
name|new_lpcoeff
decl_stmt|;
comment|/* 	 * First inspect status of the link. It may have dropped frame lock as 	 * the remote did some reconfiguration of its serdes. 	 * Then we simply have nothing to do and return immediately as caller 	 * will call us continuously until lock comes back. 	 */
if|if
condition|(
name|al_eth_kr_receiver_frame_lock_get
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* check if a new update command was received */
name|al_eth_lp_coeff_up_get
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|,
operator|&
name|new_lpcoeff
argument_list|)
expr_stmt|;
if|if
condition|(
name|al_eth_lp_coeff_up_change
argument_list|(
name|kr_data
argument_list|,
operator|&
name|new_lpcoeff
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* got some new coefficient update request. */
name|al_eth_coeff_req_handle
argument_list|(
name|kr_data
argument_list|,
operator|&
name|new_lpcoeff
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************** transmitter side ***************************/
end_comment

begin_function
specifier|static
name|int
name|al_eth_kr_lt_transmitter_task_init
parameter_list|(
name|struct
name|al_eth_kr_data
modifier|*
name|kr_data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|unsigned
name|int
name|temp_val
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QARRAY_SIZE
condition|;
name|i
operator|++
control|)
name|kr_data
operator|->
name|qarray
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|kr_data
operator|->
name|qarray_cnt
operator|=
literal|0
expr_stmt|;
name|kr_data
operator|->
name|algo_state
operator|=
name|TX_INIT
expr_stmt|;
name|kr_data
operator|->
name|curr_coeff
operator|=
name|COEFF_TO_MANIPULATE
expr_stmt|;
comment|/* first coeff to test. */
name|kr_data
operator|->
name|coeff_status_step
operator|=
name|C72_CSTATE_NOT_UPDATED
expr_stmt|;
name|kr_data
operator|->
name|end_steps_cnt
operator|=
name|QARRAY_SIZE
operator|-
literal|1
expr_stmt|;
comment|/* go back to first entry */
comment|/* 	 * Perform measure eye here to run the rx equalizer 	 * for the first time to get init values 	 */
name|rc
operator|=
name|kr_data
operator|->
name|serdes_obj
operator|->
name|eye_measure_run
argument_list|(
name|kr_data
operator|->
name|serdes_obj
argument_list|,
name|kr_data
operator|->
name|lane
argument_list|,
name|AL_ETH_KR_EYE_MEASURE_TIMEOUT
argument_list|,
operator|&
name|temp_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|al_warn
argument_list|(
literal|"%s: Failed to run Rx equalizer (rc = 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|al_eth_kr_lt_all_not_updated
parameter_list|(
name|struct
name|al_eth_kr_status_report_data
modifier|*
name|report
parameter_list|)
block|{
if|if
condition|(
operator|(
name|report
operator|->
name|c_zero
operator|==
name|C72_CSTATE_NOT_UPDATED
operator|)
operator|&&
operator|(
name|report
operator|->
name|c_minus
operator|==
name|C72_CSTATE_NOT_UPDATED
operator|)
operator|&&
operator|(
name|report
operator|->
name|c_plus
operator|==
name|C72_CSTATE_NOT_UPDATED
operator|)
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_kr_lt_coef_set
parameter_list|(
name|struct
name|al_eth_kr_coef_up_data
modifier|*
name|ldcoeff
parameter_list|,
name|enum
name|al_eth_kr_coef
name|coef
parameter_list|,
name|enum
name|al_eth_kr_cl72_coef_op
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|coef
condition|)
block|{
case|case
name|AL_ETH_KR_COEF_C_MINUS
case|:
name|ldcoeff
operator|->
name|c_minus
operator|=
name|op
expr_stmt|;
break|break;
case|case
name|AL_ETH_KR_COEF_C_PLUS
case|:
name|ldcoeff
operator|->
name|c_plus
operator|=
name|op
expr_stmt|;
break|break;
case|case
name|AL_ETH_KR_COEF_C_ZERO
case|:
name|ldcoeff
operator|->
name|c_zero
operator|=
name|op
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|al_eth_kr_cl72_cstate
name|al_eth_kr_lt_coef_report_get
parameter_list|(
name|struct
name|al_eth_kr_status_report_data
modifier|*
name|report
parameter_list|,
name|enum
name|al_eth_kr_coef
name|coef
parameter_list|)
block|{
switch|switch
condition|(
name|coef
condition|)
block|{
case|case
name|AL_ETH_KR_COEF_C_MINUS
case|:
return|return
operator|(
name|report
operator|->
name|c_minus
operator|)
return|;
case|case
name|AL_ETH_KR_COEF_C_PLUS
case|:
return|return
operator|(
name|report
operator|->
name|c_plus
operator|)
return|;
case|case
name|AL_ETH_KR_COEF_C_ZERO
case|:
return|return
operator|(
name|report
operator|->
name|c_zero
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the transmitter_task for one cycle.  *  * @return<0 if error occurs  */
end_comment

begin_function
specifier|static
name|int
name|al_eth_kr_lt_transmitter_task_run
parameter_list|(
name|struct
name|al_eth_kr_data
modifier|*
name|kr_data
parameter_list|)
block|{
name|struct
name|al_eth_kr_status_report_data
name|report
decl_stmt|;
name|unsigned
name|int
name|coeff_status_cur
decl_stmt|;
name|struct
name|al_eth_kr_coef_up_data
name|ldcoeff
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|al_eth_kr_mac_lt_state
name|nextstate
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
comment|/* 	 * do nothing if currently there is no frame lock (which may happen 	 * when remote updates its analogs). 	 */
if|if
condition|(
name|al_eth_kr_receiver_frame_lock_get
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|al_eth_lp_status_report_get
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|,
operator|&
name|report
argument_list|)
expr_stmt|;
comment|/* extract curr status of the coefficient in use */
name|coeff_status_cur
operator|=
name|al_eth_kr_lt_coef_report_get
argument_list|(
operator|&
name|report
argument_list|,
name|kr_data
operator|->
name|curr_coeff
argument_list|)
expr_stmt|;
name|nextstate
operator|=
name|kr_data
operator|->
name|algo_state
expr_stmt|;
comment|/* default we stay in curr state; */
switch|switch
condition|(
name|kr_data
operator|->
name|algo_state
condition|)
block|{
case|case
name|TX_INIT
case|:
comment|/* waiting for start */
if|if
condition|(
name|al_eth_kr_startup_proto_prog_get
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* training is on and frame lock */
name|nextstate
operator|=
name|WAIT_BEGIN
expr_stmt|;
block|}
break|break;
case|case
name|WAIT_BEGIN
case|:
name|kr_data
operator|->
name|qarray_cnt
operator|=
literal|0
expr_stmt|;
name|kr_data
operator|->
name|curr_coeff
operator|=
name|COEFF_TO_MANIPULATE
expr_stmt|;
name|kr_data
operator|->
name|coeff_status_step
operator|=
name|C72_CSTATE_NOT_UPDATED
expr_stmt|;
name|coeff_status_cur
operator|=
name|C72_CSTATE_NOT_UPDATED
expr_stmt|;
name|kr_data
operator|->
name|end_steps_cnt
operator|=
name|QARRAY_SIZE
operator|-
literal|1
expr_stmt|;
comment|/* Wait for not_updated for all coefficients from remote */
if|if
condition|(
name|al_eth_kr_lt_all_not_updated
argument_list|(
operator|&
name|report
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ldcoeff
operator|.
name|preset
operator|=
name|TRUE
expr_stmt|;
name|nextstate
operator|=
name|DO_PRESET
expr_stmt|;
block|}
break|break;
case|case
name|DO_PRESET
case|:
comment|/* 		 * Send PRESET and wait for for updated for all 		 * coefficients from remote 		 */
if|if
condition|(
name|al_eth_kr_lt_all_not_updated
argument_list|(
operator|&
name|report
argument_list|)
operator|==
literal|0
condition|)
name|nextstate
operator|=
name|DO_HOLD
expr_stmt|;
else|else
comment|/* as long as the lp didn't response to the preset 		      * we should continue sending it */
name|ldcoeff
operator|.
name|preset
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|DO_HOLD
case|:
comment|/* 		 * clear the PRESET, issue HOLD command and wait for 		 * hold handshake 		 */
if|if
condition|(
name|al_eth_kr_lt_all_not_updated
argument_list|(
operator|&
name|report
argument_list|)
operator|!=
literal|0
condition|)
name|nextstate
operator|=
name|QMEASURE
expr_stmt|;
break|break;
case|case
name|QMEASURE
case|:
comment|/* makes a measurement and fills the new value into the array */
name|rc
operator|=
name|kr_data
operator|->
name|serdes_obj
operator|->
name|eye_measure_run
argument_list|(
name|kr_data
operator|->
name|serdes_obj
argument_list|,
name|kr_data
operator|->
name|lane
argument_list|,
name|AL_ETH_KR_EYE_MEASURE_TIMEOUT
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|al_warn
argument_list|(
literal|"%s: Rx eye measurement failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|al_dbg
argument_list|(
literal|"%s: Rx Measure eye returned 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* put the new value into the array at the top. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QARRAY_SIZE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|kr_data
operator|->
name|qarray
index|[
name|i
index|]
operator|=
name|kr_data
operator|->
name|qarray
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|kr_data
operator|->
name|qarray
index|[
name|QARRAY_SIZE
operator|-
literal|1
index|]
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|kr_data
operator|->
name|qarray_cnt
operator|<
name|QARRAY_SIZE
condition|)
name|kr_data
operator|->
name|qarray_cnt
operator|++
expr_stmt|;
name|nextstate
operator|=
name|QCHECK
expr_stmt|;
break|break;
case|case
name|QCHECK
case|:
comment|/* check if we reached the best link quality yet. */
if|if
condition|(
name|kr_data
operator|->
name|qarray_cnt
operator|<
name|QARRAY_SIZE
condition|)
block|{
comment|/* keep going until at least the history is 			 * filled. check that we can keep going or if 			 * coefficient has already reached minimum. 			 */
if|if
condition|(
name|kr_data
operator|->
name|coeff_status_step
operator|==
name|C72_CSTATE_MIN
condition|)
name|nextstate
operator|=
name|COEFF_DONE
expr_stmt|;
else|else
block|{
comment|/* 				 * request a DECREMENT of the 				 * coefficient under control 				 */
name|al_eth_kr_lt_coef_set
argument_list|(
operator|&
name|ldcoeff
argument_list|,
name|kr_data
operator|->
name|curr_coeff
argument_list|,
name|AL_PHY_KR_COEF_UP_DEC
argument_list|)
expr_stmt|;
name|nextstate
operator|=
name|DO_NEXT_TRY
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * check if current value and last both are worse than 			 * the 2nd last. This we take as an ending condition 			 * assuming the minimum was reached two tries before 			 * so we will now go back to that point. 			 */
if|if
condition|(
operator|(
name|kr_data
operator|->
name|qarray
index|[
literal|0
index|]
operator|<
name|kr_data
operator|->
name|qarray
index|[
literal|1
index|]
operator|)
operator|&&
operator|(
name|kr_data
operator|->
name|qarray
index|[
literal|0
index|]
operator|<
name|kr_data
operator|->
name|qarray
index|[
literal|2
index|]
operator|)
condition|)
block|{
comment|/* 				 * request a INCREMENT of the 				 * coefficient under control 				 */
name|al_eth_kr_lt_coef_set
argument_list|(
operator|&
name|ldcoeff
argument_list|,
name|kr_data
operator|->
name|curr_coeff
argument_list|,
name|AL_PHY_KR_COEF_UP_INC
argument_list|)
expr_stmt|;
comment|/* start going back to the maximum */
name|nextstate
operator|=
name|END_STEPS
expr_stmt|;
if|if
condition|(
name|kr_data
operator|->
name|end_steps_cnt
operator|>
literal|0
condition|)
name|kr_data
operator|->
name|end_steps_cnt
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|kr_data
operator|->
name|coeff_status_step
operator|==
name|C72_CSTATE_MIN
condition|)
block|{
name|nextstate
operator|=
name|COEFF_DONE
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * request a DECREMENT of the 					 * coefficient under control 					 */
name|al_eth_kr_lt_coef_set
argument_list|(
operator|&
name|ldcoeff
argument_list|,
name|kr_data
operator|->
name|curr_coeff
argument_list|,
name|AL_PHY_KR_COEF_UP_DEC
argument_list|)
expr_stmt|;
name|nextstate
operator|=
name|DO_NEXT_TRY
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|DO_NEXT_TRY
case|:
comment|/* 		 * save the status when we issue the DEC step to the remote, 		 * before the HOLD is done again. 		 */
name|kr_data
operator|->
name|coeff_status_step
operator|=
name|coeff_status_cur
expr_stmt|;
if|if
condition|(
name|coeff_status_cur
operator|!=
name|C72_CSTATE_NOT_UPDATED
condition|)
name|nextstate
operator|=
name|DO_HOLD
expr_stmt|;
comment|/* go to next measurement round */
else|else
name|al_eth_kr_lt_coef_set
argument_list|(
operator|&
name|ldcoeff
argument_list|,
name|kr_data
operator|->
name|curr_coeff
argument_list|,
name|AL_PHY_KR_COEF_UP_DEC
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Coefficient iteration completed, go back to the optimum step 	 * In this algorithm we assume 2 before curr was best hence need to do 	 * two INC runs. 	 */
case|case
name|END_STEPS
case|:
if|if
condition|(
name|coeff_status_cur
operator|!=
name|C72_CSTATE_NOT_UPDATED
condition|)
name|nextstate
operator|=
name|END_STEPS_HOLD
expr_stmt|;
else|else
name|al_eth_kr_lt_coef_set
argument_list|(
operator|&
name|ldcoeff
argument_list|,
name|kr_data
operator|->
name|curr_coeff
argument_list|,
name|AL_PHY_KR_COEF_UP_INC
argument_list|)
expr_stmt|;
break|break;
case|case
name|END_STEPS_HOLD
case|:
if|if
condition|(
name|coeff_status_cur
operator|==
name|C72_CSTATE_NOT_UPDATED
condition|)
block|{
if|if
condition|(
name|kr_data
operator|->
name|end_steps_cnt
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * request a INCREMENT of the 				 * coefficient under control 				 */
name|al_eth_kr_lt_coef_set
argument_list|(
operator|&
name|ldcoeff
argument_list|,
name|kr_data
operator|->
name|curr_coeff
argument_list|,
name|AL_PHY_KR_COEF_UP_INC
argument_list|)
expr_stmt|;
comment|/* go 2nd time - dec the end step count */
name|nextstate
operator|=
name|END_STEPS
expr_stmt|;
if|if
condition|(
name|kr_data
operator|->
name|end_steps_cnt
operator|>
literal|0
condition|)
name|kr_data
operator|->
name|end_steps_cnt
operator|--
expr_stmt|;
block|}
else|else
block|{
name|nextstate
operator|=
name|COEFF_DONE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|COEFF_DONE
case|:
comment|/* 		 * now this coefficient is done. 		 * We can now either choose to finish here, 		 * or keep going with another coefficient. 		 */
if|if
condition|(
operator|(
name|int
operator|)
name|kr_data
operator|->
name|curr_coeff
operator|<
name|COEFF_TO_MANIPULATE_LAST
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QARRAY_SIZE
condition|;
name|i
operator|++
control|)
name|kr_data
operator|->
name|qarray
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|kr_data
operator|->
name|qarray_cnt
operator|=
literal|0
expr_stmt|;
name|kr_data
operator|->
name|end_steps_cnt
operator|=
name|QARRAY_SIZE
operator|-
literal|1
expr_stmt|;
name|kr_data
operator|->
name|coeff_status_step
operator|=
name|C72_CSTATE_NOT_UPDATED
expr_stmt|;
name|kr_data
operator|->
name|curr_coeff
operator|++
expr_stmt|;
name|al_dbg
argument_list|(
literal|"[%s]: doing next coefficient: %d ---\n\n"
argument_list|,
name|kr_data
operator|->
name|adapter
operator|->
name|name
argument_list|,
name|kr_data
operator|->
name|curr_coeff
argument_list|)
expr_stmt|;
name|nextstate
operator|=
name|QMEASURE
expr_stmt|;
block|}
else|else
block|{
name|nextstate
operator|=
name|SET_READY
expr_stmt|;
block|}
break|break;
case|case
name|SET_READY
case|:
comment|/* 		 * our receiver is ready for data. 		 * no training will occur any more. 		 */
name|kr_data
operator|->
name|status_report
operator|.
name|receiver_ready
operator|=
name|TRUE
expr_stmt|;
comment|/* 		 * in addition to the status we transmit, we also must tell our 		 * local hardware state-machine that we are done, so the 		 * training can eventually complete when the remote indicates 		 * it is ready also. The hardware will then automatically 		 * give control to the PCS layer completing training. 		 */
name|al_eth_receiver_ready_set
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|)
expr_stmt|;
name|nextstate
operator|=
name|TX_DONE
expr_stmt|;
break|break;
case|case
name|TX_DONE
case|:
break|break;
comment|/* nothing else to do */
default|default:
name|nextstate
operator|=
name|kr_data
operator|->
name|algo_state
expr_stmt|;
break|break;
block|}
comment|/* 	 * The status we want to transmit to remote. 	 * Note that the status combines the receiver status of all coefficients 	 * with the transmitter's rx ready status. 	 */
if|if
condition|(
name|kr_data
operator|->
name|algo_state
operator|!=
name|nextstate
condition|)
block|{
name|al_dbg
argument_list|(
literal|"[%s] [al_eth_kr_lt_transmit_run] STM changes %s -> %s: "
literal|" Qarray=%d/%d/%d\n"
argument_list|,
name|kr_data
operator|->
name|adapter
operator|->
name|name
argument_list|,
name|al_eth_kr_mac_sm_name
index|[
name|kr_data
operator|->
name|algo_state
index|]
argument_list|,
name|al_eth_kr_mac_sm_name
index|[
name|nextstate
index|]
argument_list|,
name|kr_data
operator|->
name|qarray
index|[
literal|0
index|]
argument_list|,
name|kr_data
operator|->
name|qarray
index|[
literal|1
index|]
argument_list|,
name|kr_data
operator|->
name|qarray
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|kr_data
operator|->
name|algo_state
operator|=
name|nextstate
expr_stmt|;
comment|/* 	 * write fields for transmission into hardware. 	 * Important: this must be done always, as the receiver may have 	 * received update commands and wants to return its status. 	 */
name|al_eth_ld_coeff_up_set
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|,
operator|&
name|ldcoeff
argument_list|)
expr_stmt|;
name|al_eth_ld_status_report_set
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|,
operator|&
name|kr_data
operator|->
name|status_report
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|al_eth_kr_run_lt
parameter_list|(
name|struct
name|al_eth_kr_data
modifier|*
name|kr_data
parameter_list|)
block|{
name|unsigned
name|int
name|cnt
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|boolean_t
name|page_received
init|=
name|FALSE
decl_stmt|;
name|boolean_t
name|an_completed
init|=
name|FALSE
decl_stmt|;
name|boolean_t
name|error
init|=
name|FALSE
decl_stmt|;
name|boolean_t
name|training_failure
init|=
name|FALSE
decl_stmt|;
name|al_eth_kr_lt_initialize
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|al_eth_kr_lt_frame_lock_wait
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|,
name|AL_ETH_KR_FRAME_LOCK_TIMEOUT
argument_list|)
operator|==
name|TRUE
condition|)
block|{
comment|/* 		 * when locked, for the first time initialize the receiver and 		 * transmitter tasks to prepare it for detecting coefficient 		 * update requests. 		 */
name|al_eth_kr_lt_receiver_task_init
argument_list|(
name|kr_data
argument_list|)
expr_stmt|;
name|ret
operator|=
name|al_eth_kr_lt_transmitter_task_init
argument_list|(
name|kr_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
name|cnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|ret
operator|=
name|al_eth_kr_lt_receiver_task_run
argument_list|(
name|kr_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
comment|/* stop the link training */
name|ret
operator|=
name|al_eth_kr_lt_transmitter_task_run
argument_list|(
name|kr_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
comment|/* stop the link training */
name|cnt
operator|++
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|al_eth_kr_startup_proto_prog_get
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|)
operator|)
operator|&&
operator|(
name|cnt
operator|<=
name|AL_ETH_KR_LT_MAX_ROUNDS
operator|)
condition|)
do|;
name|training_failure
operator|=
name|al_eth_kr_training_status_fail_get
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|)
expr_stmt|;
name|al_dbg
argument_list|(
literal|"[%s] training ended after %d rounds, failed = %s\n"
argument_list|,
name|kr_data
operator|->
name|adapter
operator|->
name|name
argument_list|,
name|cnt
argument_list|,
operator|(
name|training_failure
operator|)
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
if|if
condition|(
name|training_failure
operator|||
name|cnt
operator|>
name|AL_ETH_KR_LT_MAX_ROUNDS
condition|)
block|{
name|al_warn
argument_list|(
literal|"[%s] Training Fail: status: %s, timeout: %s\n"
argument_list|,
name|kr_data
operator|->
name|adapter
operator|->
name|name
argument_list|,
operator|(
name|training_failure
operator|)
condition|?
literal|"Failed"
else|:
literal|"OK"
argument_list|,
operator|(
name|cnt
operator|>
name|AL_ETH_KR_LT_MAX_ROUNDS
operator|)
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
comment|/* 			 * note: link is now disabled, 			 * until training becomes disabled (see below). 			 */
name|ret
operator|=
name|EIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
else|else
block|{
name|al_info
argument_list|(
literal|"[%s] FAILED: did not achieve initial frame lock...\n"
argument_list|,
name|kr_data
operator|->
name|adapter
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * ensure to stop link training at the end to allow normal PCS 	 * datapath to operate in case of training failure. 	 */
name|al_eth_kr_lt_stop
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|AL_ETH_KR_LT_DONE_TIMEOUT
expr_stmt|;
while|while
condition|(
name|an_completed
operator|==
name|FALSE
condition|)
block|{
name|al_eth_kr_an_status_check
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|,
operator|&
name|page_received
argument_list|,
operator|&
name|an_completed
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|--
operator|)
operator|==
literal|0
condition|)
block|{
name|al_info
argument_list|(
literal|"%s: wait for an complete timeout!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ETIMEDOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|error
label|:
name|al_eth_kr_an_stop
argument_list|(
name|kr_data
operator|->
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* execute Autonegotiation process */
end_comment

begin_function
name|int
name|al_eth_an_lt_execute
parameter_list|(
name|struct
name|al_hal_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|al_serdes_grp_obj
modifier|*
name|serdes_obj
parameter_list|,
name|enum
name|al_serdes_lane
name|lane
parameter_list|,
name|struct
name|al_eth_an_adv
modifier|*
name|an_adv
parameter_list|,
name|struct
name|al_eth_an_adv
modifier|*
name|partner_adv
parameter_list|)
block|{
name|struct
name|al_eth_kr_data
name|kr_data
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|al_serdes_adv_rx_params
name|rx_params
decl_stmt|;
name|al_memset
argument_list|(
operator|&
name|kr_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|al_eth_kr_data
argument_list|)
argument_list|)
expr_stmt|;
name|kr_data
operator|.
name|adapter
operator|=
name|adapter
expr_stmt|;
name|kr_data
operator|.
name|serdes_obj
operator|=
name|serdes_obj
expr_stmt|;
name|kr_data
operator|.
name|lane
operator|=
name|lane
expr_stmt|;
comment|/* 	 * the link training progress will run rx equalization so need to make 	 * sure rx parameters is not been override 	 */
name|rx_params
operator|.
name|override
operator|=
name|FALSE
expr_stmt|;
name|kr_data
operator|.
name|serdes_obj
operator|->
name|rx_advanced_params_set
argument_list|(
name|kr_data
operator|.
name|serdes_obj
argument_list|,
name|kr_data
operator|.
name|lane
argument_list|,
operator|&
name|rx_params
argument_list|)
expr_stmt|;
name|rc
operator|=
name|al_eth_kr_an_run
argument_list|(
operator|&
name|kr_data
argument_list|,
name|an_adv
argument_list|,
name|partner_adv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|al_eth_kr_lt_stop
argument_list|(
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|)
expr_stmt|;
name|al_eth_kr_an_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|al_dbg
argument_list|(
literal|"%s: auto-negotiation failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
if|if
condition|(
name|partner_adv
operator|->
name|technology
operator|!=
name|AL_ETH_AN_TECH_10GBASE_KR
condition|)
block|{
name|al_eth_kr_lt_stop
argument_list|(
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|)
expr_stmt|;
name|al_eth_kr_an_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|al_dbg
argument_list|(
literal|"%s: link partner isn't 10GBASE_KR.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|rc
operator|=
name|al_eth_kr_run_lt
argument_list|(
operator|&
name|kr_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|al_eth_kr_lt_stop
argument_list|(
name|adapter
argument_list|,
name|AL_ETH_AN__LT_LANE_0
argument_list|)
expr_stmt|;
name|al_eth_kr_an_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|al_dbg
argument_list|(
literal|"%s: Link-training failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

