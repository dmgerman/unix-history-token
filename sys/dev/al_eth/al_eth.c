begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015,2016 Annapurna Labs Ltd. and affiliates  * All rights reserved.  *  * Developed by Semihalf.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_lro.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<al_hal_common.h>
end_include

begin_include
include|#
directive|include
file|<al_hal_plat_services.h>
end_include

begin_include
include|#
directive|include
file|<al_hal_udma_config.h>
end_include

begin_include
include|#
directive|include
file|<al_hal_udma_iofic.h>
end_include

begin_include
include|#
directive|include
file|<al_hal_udma_debug.h>
end_include

begin_include
include|#
directive|include
file|<al_hal_eth.h>
end_include

begin_include
include|#
directive|include
file|"al_eth.h"
end_include

begin_include
include|#
directive|include
file|"al_init_eth_lm.h"
end_include

begin_include
include|#
directive|include
file|"arm/annapurna/alpine/alpine_serdes.h"
end_include

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_define
define|#
directive|define
name|device_printf_dbg
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	if (AL_DBG_LEVEL>= AL_DBG_LEVEL_DBG) { AL_DBG_LOCK();		\ 	    device_printf(fmt, __VA_ARGS__); AL_DBG_UNLOCK();}		\ 	} while (0)
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IFAL
argument_list|,
literal|"if_al_malloc"
argument_list|,
literal|"All allocated data for AL ETH driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* move out to some pci header file */
end_comment

begin_define
define|#
directive|define
name|PCI_VENDOR_ID_ANNAPURNA_LABS
value|0x1c36
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_AL_ETH
value|0x0001
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_AL_ETH_ADVANCED
value|0x0002
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_AL_ETH_NIC
value|0x0003
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_AL_ETH_FPGA_NIC
value|0x0030
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_AL_CRYPTO
value|0x0011
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_AL_CRYPTO_VF
value|0x8011
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_AL_RAID_DMA
value|0x0021
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_AL_RAID_DMA_VF
value|0x8021
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_AL_USB
value|0x0041
end_define

begin_define
define|#
directive|define
name|MAC_ADDR_STR
value|"%02x:%02x:%02x:%02x:%02x:%02x"
end_define

begin_define
define|#
directive|define
name|MAC_ADDR
parameter_list|(
name|addr
parameter_list|)
value|addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]
end_define

begin_define
define|#
directive|define
name|AL_ETH_MAC_TABLE_UNICAST_IDX_BASE
value|0
end_define

begin_define
define|#
directive|define
name|AL_ETH_MAC_TABLE_UNICAST_MAX_COUNT
value|4
end_define

begin_define
define|#
directive|define
name|AL_ETH_MAC_TABLE_ALL_MULTICAST_IDX
value|(AL_ETH_MAC_TABLE_UNICAST_IDX_BASE + \ 						 AL_ETH_MAC_TABLE_UNICAST_MAX_COUNT)
end_define

begin_define
define|#
directive|define
name|AL_ETH_MAC_TABLE_DROP_IDX
value|(AL_ETH_FWD_MAC_NUM - 1)
end_define

begin_define
define|#
directive|define
name|AL_ETH_MAC_TABLE_BROADCAST_IDX
value|(AL_ETH_MAC_TABLE_DROP_IDX - 1)
end_define

begin_define
define|#
directive|define
name|AL_ETH_THASH_UDMA_SHIFT
value|0
end_define

begin_define
define|#
directive|define
name|AL_ETH_THASH_UDMA_MASK
value|(0xF<< AL_ETH_THASH_UDMA_SHIFT)
end_define

begin_define
define|#
directive|define
name|AL_ETH_THASH_Q_SHIFT
value|4
end_define

begin_define
define|#
directive|define
name|AL_ETH_THASH_Q_MASK
value|(0x3<< AL_ETH_THASH_Q_SHIFT)
end_define

begin_comment
comment|/* the following defines should be moved to hal */
end_comment

begin_define
define|#
directive|define
name|AL_ETH_FSM_ENTRY_IPV4_TCP
value|0
end_define

begin_define
define|#
directive|define
name|AL_ETH_FSM_ENTRY_IPV4_UDP
value|1
end_define

begin_define
define|#
directive|define
name|AL_ETH_FSM_ENTRY_IPV6_TCP
value|2
end_define

begin_define
define|#
directive|define
name|AL_ETH_FSM_ENTRY_IPV6_UDP
value|3
end_define

begin_define
define|#
directive|define
name|AL_ETH_FSM_ENTRY_IPV6_NO_UDP_TCP
value|4
end_define

begin_define
define|#
directive|define
name|AL_ETH_FSM_ENTRY_IPV4_NO_UDP_TCP
value|5
end_define

begin_comment
comment|/* FSM DATA format */
end_comment

begin_define
define|#
directive|define
name|AL_ETH_FSM_DATA_OUTER_2_TUPLE
value|0
end_define

begin_define
define|#
directive|define
name|AL_ETH_FSM_DATA_OUTER_4_TUPLE
value|1
end_define

begin_define
define|#
directive|define
name|AL_ETH_FSM_DATA_INNER_2_TUPLE
value|2
end_define

begin_define
define|#
directive|define
name|AL_ETH_FSM_DATA_INNER_4_TUPLE
value|3
end_define

begin_define
define|#
directive|define
name|AL_ETH_FSM_DATA_HASH_SEL
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|AL_ETH_FSM_DATA_DEFAULT_Q
value|0
end_define

begin_define
define|#
directive|define
name|AL_ETH_FSM_DATA_DEFAULT_UDMA
value|0
end_define

begin_define
define|#
directive|define
name|AL_BR_SIZE
value|512
end_define

begin_define
define|#
directive|define
name|AL_TSO_SIZE
value|65500
end_define

begin_define
define|#
directive|define
name|AL_DEFAULT_MTU
value|1500
end_define

begin_define
define|#
directive|define
name|CSUM_OFFLOAD
value|(CSUM_IP|CSUM_TCP|CSUM_UDP|CSUM_SCTP)
end_define

begin_define
define|#
directive|define
name|AL_IP_ALIGNMENT_OFFSET
value|2
end_define

begin_define
define|#
directive|define
name|SFP_I2C_ADDR
value|0x50
end_define

begin_define
define|#
directive|define
name|AL_MASK_GROUP_A_INT
value|0x7
end_define

begin_define
define|#
directive|define
name|AL_MASK_GROUP_B_INT
value|0xF
end_define

begin_define
define|#
directive|define
name|AL_MASK_GROUP_C_INT
value|0xF
end_define

begin_define
define|#
directive|define
name|AL_MASK_GROUP_D_INT
value|0xFFFFFFFF
end_define

begin_define
define|#
directive|define
name|AL_REG_OFFSET_FORWARD_INTR
value|(0x1800000 + 0x1210)
end_define

begin_define
define|#
directive|define
name|AL_EN_FORWARD_INTR
value|0x1FFFF
end_define

begin_define
define|#
directive|define
name|AL_DIS_FORWARD_INTR
value|0
end_define

begin_define
define|#
directive|define
name|AL_M2S_MASK_INIT
value|0x480
end_define

begin_define
define|#
directive|define
name|AL_S2M_MASK_INIT
value|0x1E0
end_define

begin_define
define|#
directive|define
name|AL_M2S_S2M_MASK_NOT_INT
value|(0x3f<< 25)
end_define

begin_define
define|#
directive|define
name|AL_10BASE_T_SPEED
value|10
end_define

begin_define
define|#
directive|define
name|AL_100BASE_TX_SPEED
value|100
end_define

begin_define
define|#
directive|define
name|AL_1000BASE_T_SPEED
value|1000
end_define

begin_decl_stmt
specifier|static
name|devclass_t
name|al_devclass
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AL_RX_LOCK_INIT
parameter_list|(
name|_sc
parameter_list|)
value|mtx_init(&((_sc)->if_rx_lock), "ALRXL", "ALRXL", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|AL_RX_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&((_sc)->if_rx_lock))
end_define

begin_define
define|#
directive|define
name|AL_RX_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&((_sc)->if_rx_lock))
end_define

begin_comment
comment|/* helper functions */
end_comment

begin_function_decl
specifier|static
name|int
name|al_is_device_supported
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_eth_init_rings
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_eth_flow_ctrl_disable
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|al_eth_fpga_read_pci_config
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|al_eth_fpga_write_pci_config
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|al_eth_read_pci_config
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|al_eth_write_pci_config
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|al_eth_irq_config
parameter_list|(
name|uint32_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|al_eth_forward_int_config
parameter_list|(
name|uint32_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_eth_start_xmit
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_eth_rx_recv_work
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|al_eth_up
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_eth_down
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_eth_interrupts_unmask
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_eth_interrupts_mask
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|al_eth_check_mtu
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|al_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|ift_counter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_eth_req_rx_buff_size
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|al_eth_board_params_init
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|al_media_update
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|al_eth_function_reset
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|al_eth_hw_init_adapter
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_eth_serdes_init
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_eth_lm_config
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|al_eth_hw_init
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_tick_stats
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ifnet entry points */
end_comment

begin_function_decl
specifier|static
name|void
name|al_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|al_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|al_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* bus entry points */
end_comment

begin_function_decl
specifier|static
name|int
name|al_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|al_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|al_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|al_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* mii bus support routines */
end_comment

begin_function_decl
specifier|static
name|int
name|al_miibus_readreg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|al_miibus_writereg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_miibus_statchg
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|al_miibus_linkchg
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|al_eth_adapter
modifier|*
name|g_adapters
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|g_adapters_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag for napi-like mbuf processing, controlled from sysctl */
end_comment

begin_decl_stmt
specifier|static
name|int
name|napi
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|al_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|al_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|al_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|al_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|al_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|al_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|al_miibus_writereg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|al_miibus_statchg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_linkchg
argument_list|,
name|al_miibus_linkchg
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|al_driver
init|=
block|{
literal|"al"
block|,
name|al_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|al_eth_adapter
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|al
argument_list|,
name|pci
argument_list|,
name|al_driver
argument_list|,
name|al_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|al
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|al_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|(
name|al_is_device_supported
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"al"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|al_eth_lm_context
modifier|*
name|lm_context
decl_stmt|;
name|struct
name|al_eth_adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|dev_id
decl_stmt|;
name|uint32_t
name|rev_id
decl_stmt|;
name|int
name|bar_udma
decl_stmt|;
name|int
name|bar_mac
decl_stmt|;
name|int
name|bar_ec
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
name|dev_id
operator|=
name|rev_id
operator|=
literal|0
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tree
operator|=
name|SYSCTL_PARENT
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_adapters_count
operator|==
literal|0
condition|)
block|{
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"napi"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|napi
argument_list|,
literal|0
argument_list|,
literal|"Use pseudo-napi mechanism"
argument_list|)
expr_stmt|;
block|}
name|adapter
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|adapter
operator|->
name|board_type
operator|=
name|ALPINE_INTEGRATED
expr_stmt|;
name|snprintf
argument_list|(
name|adapter
operator|->
name|name
argument_list|,
name|AL_ETH_NAME_MAX_LEN
argument_list|,
literal|"%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|AL_RX_LOCK_INIT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|g_adapters
index|[
name|g_adapters_count
index|]
operator|=
name|adapter
expr_stmt|;
name|lm_context
operator|=
operator|&
name|adapter
operator|->
name|lm_context
expr_stmt|;
name|bar_udma
operator|=
name|PCIR_BAR
argument_list|(
name|AL_ETH_UDMA_BAR
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|udma_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|bar_udma
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|udma_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"could not allocate memory resources for DMA.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_res_dma
goto|;
block|}
name|adapter
operator|->
name|udma_base
operator|=
name|al_bus_dma_to_va
argument_list|(
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|udma_res
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|udma_res
argument_list|)
argument_list|)
expr_stmt|;
name|bar_mac
operator|=
name|PCIR_BAR
argument_list|(
name|AL_ETH_MAC_BAR
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|mac_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|bar_mac
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|mac_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"could not allocate memory resources for MAC.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_res_mac
goto|;
block|}
name|adapter
operator|->
name|mac_base
operator|=
name|al_bus_dma_to_va
argument_list|(
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|mac_res
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|mac_res
argument_list|)
argument_list|)
expr_stmt|;
name|bar_ec
operator|=
name|PCIR_BAR
argument_list|(
name|AL_ETH_EC_BAR
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|ec_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|bar_ec
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|ec_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"could not allocate memory resources for EC.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_res_ec
goto|;
block|}
name|adapter
operator|->
name|ec_base
operator|=
name|al_bus_dma_to_va
argument_list|(
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|ec_res
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|ec_res
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|netdev
operator|=
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|netdev
operator|->
name|if_link_state
operator|=
name|LINK_STATE_DOWN
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|adapter
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_drv_flags
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator||
name|IFF_ALLMULTI
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|al_mq_start
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|al_qflush
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|al_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|al_init
expr_stmt|;
name|ifp
operator|->
name|if_get_counter
operator|=
name|al_get_counter
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|AL_DEFAULT_MTU
expr_stmt|;
name|adapter
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|ifp
operator|->
name|if_capenable
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
operator||
name|IFCAP_HWCSUM_IPV6
operator||
name|IFCAP_TSO
operator||
name|IFCAP_LRO
operator||
name|IFCAP_JUMBO_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
name|adapter
operator|->
name|id_number
operator|=
name|g_adapters_count
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|board_type
operator|==
name|ALPINE_INTEGRATED
condition|)
block|{
name|dev_id
operator|=
name|pci_get_device
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
expr_stmt|;
name|rev_id
operator|=
name|pci_get_revid
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|al_eth_fpga_read_pci_config
argument_list|(
name|adapter
operator|->
name|internal_pcie_base
argument_list|,
name|PCIR_DEVICE
argument_list|,
operator|&
name|dev_id
argument_list|)
expr_stmt|;
name|al_eth_fpga_read_pci_config
argument_list|(
name|adapter
operator|->
name|internal_pcie_base
argument_list|,
name|PCIR_REVID
argument_list|,
operator|&
name|rev_id
argument_list|)
expr_stmt|;
block|}
name|adapter
operator|->
name|dev_id
operator|=
name|dev_id
expr_stmt|;
name|adapter
operator|->
name|rev_id
operator|=
name|rev_id
expr_stmt|;
comment|/* set default ring sizes */
name|adapter
operator|->
name|tx_ring_count
operator|=
name|AL_ETH_DEFAULT_TX_SW_DESCS
expr_stmt|;
name|adapter
operator|->
name|tx_descs_count
operator|=
name|AL_ETH_DEFAULT_TX_HW_DESCS
expr_stmt|;
name|adapter
operator|->
name|rx_ring_count
operator|=
name|AL_ETH_DEFAULT_RX_DESCS
expr_stmt|;
name|adapter
operator|->
name|rx_descs_count
operator|=
name|AL_ETH_DEFAULT_RX_DESCS
expr_stmt|;
name|adapter
operator|->
name|num_tx_queues
operator|=
name|AL_ETH_NUM_QUEUES
expr_stmt|;
name|adapter
operator|->
name|num_rx_queues
operator|=
name|AL_ETH_NUM_QUEUES
expr_stmt|;
name|adapter
operator|->
name|small_copy_len
operator|=
name|AL_ETH_DEFAULT_SMALL_PACKET_LEN
expr_stmt|;
name|adapter
operator|->
name|link_poll_interval
operator|=
name|AL_ETH_DEFAULT_LINK_POLL_INTERVAL
expr_stmt|;
name|adapter
operator|->
name|max_rx_buff_alloc_size
operator|=
name|AL_ETH_DEFAULT_MAX_RX_BUFF_ALLOC_SIZE
expr_stmt|;
name|al_eth_req_rx_buff_size
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|netdev
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_config
operator|.
name|force_1000_base_x
operator|=
name|AL_ETH_DEFAULT_FORCE_1000_BASEX
expr_stmt|;
name|err
operator|=
name|al_eth_board_params_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|adapter
operator|->
name|mac_mode
operator|==
name|AL_ETH_MAC_MODE_10GbE_Serial
condition|)
block|{
name|ifmedia_init
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|al_media_update
argument_list|,
name|al_media_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_LX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_LR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
block|}
name|al_eth_function_reset
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err
operator|=
name|al_eth_hw_init_adapter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|al_eth_init_rings
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|g_adapters_count
operator|++
expr_stmt|;
name|al_eth_lm_config
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|adapter
operator|->
name|stats_mtx
argument_list|,
literal|"AlStatsMtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|adapter
operator|->
name|wd_mtx
argument_list|,
literal|"AlWdMtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|adapter
operator|->
name|stats_callout
argument_list|,
operator|&
name|adapter
operator|->
name|stats_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|adapter
operator|->
name|wd_callout
argument_list|,
operator|&
name|adapter
operator|->
name|wd_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|mac_addr
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|AL_DEFAULT_MTU
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|mac_mode
operator|==
name|AL_ETH_MAC_MODE_RGMII
condition|)
block|{
name|al_eth_hw_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Attach PHY(s) */
name|err
operator|=
name|mii_attach
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
operator|&
name|adapter
operator|->
name|miibus
argument_list|,
name|adapter
operator|->
name|netdev
argument_list|,
name|al_media_update
argument_list|,
name|al_media_status
argument_list|,
name|BMSR_DEFCAPMASK
argument_list|,
literal|0
argument_list|,
name|MII_OFFSET_ANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"attaching PHYs failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|adapter
operator|->
name|mii
operator|=
name|device_get_softc
argument_list|(
name|adapter
operator|->
name|miibus
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
name|err
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|bar_ec
argument_list|,
name|adapter
operator|->
name|ec_res
argument_list|)
expr_stmt|;
name|err_res_ec
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|bar_mac
argument_list|,
name|adapter
operator|->
name|mac_res
argument_list|)
expr_stmt|;
name|err_res_mac
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|bar_udma
argument_list|,
name|adapter
operator|->
name|udma_res
argument_list|)
expr_stmt|;
name|err_res_dma
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
decl_stmt|;
name|adapter
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|adapter
operator|->
name|netdev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|adapter
operator|->
name|stats_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|adapter
operator|->
name|wd_mtx
argument_list|)
expr_stmt|;
name|al_eth_down
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|adapter
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|adapter
operator|->
name|ec_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|adapter
operator|->
name|mac_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|adapter
operator|->
name|udma_res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|al_eth_fpga_read_pci_config
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|int
name|where
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
comment|/* handle is the base address of the adapter */
operator|*
name|val
operator|=
name|al_reg_read32
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|u_long
operator|)
name|handle
operator|+
name|where
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|al_eth_fpga_write_pci_config
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|int
name|where
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
comment|/* handle is the base address of the adapter */
name|al_reg_write32
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|u_long
operator|)
name|handle
operator|+
name|where
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|al_eth_read_pci_config
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|int
name|where
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
comment|/* handle is a pci_dev */
operator|*
name|val
operator|=
name|pci_read_config
argument_list|(
operator|(
name|device_t
operator|)
name|handle
argument_list|,
name|where
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|al_eth_write_pci_config
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|int
name|where
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
comment|/* handle is a pci_dev */
name|pci_write_config
argument_list|(
operator|(
name|device_t
operator|)
name|handle
argument_list|,
name|where
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|al_eth_irq_config
parameter_list|(
name|uint32_t
modifier|*
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|al_reg_write32_relaxed
argument_list|(
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|al_eth_forward_int_config
parameter_list|(
name|uint32_t
modifier|*
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|al_reg_write32
argument_list|(
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_serdes_init
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|void
name|__iomem
modifier|*
name|serdes_base
decl_stmt|;
name|adapter
operator|->
name|serdes_init
operator|=
name|false
expr_stmt|;
name|serdes_base
operator|=
name|alpine_serdes_resource_get
argument_list|(
name|adapter
operator|->
name|serdes_grp
argument_list|)
expr_stmt|;
if|if
condition|(
name|serdes_base
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"serdes_base get failed!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|serdes_base
operator|=
name|al_bus_dma_to_va
argument_list|(
name|serdes_tag
argument_list|,
name|serdes_base
argument_list|)
expr_stmt|;
name|al_serdes_handle_grp_init
argument_list|(
name|serdes_base
argument_list|,
name|adapter
operator|->
name|serdes_grp
argument_list|,
operator|&
name|adapter
operator|->
name|serdes_obj
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|serdes_init
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_dma_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
decl_stmt|;
name|paddr
operator|=
name|arg
expr_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_dma_alloc_coherent
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|bus_dma_tag_t
modifier|*
name|tag
parameter_list|,
name|bus_dmamap_t
modifier|*
name|map
parameter_list|,
name|bus_addr_t
modifier|*
name|baddr
parameter_list|,
name|void
modifier|*
modifier|*
name|vaddr
parameter_list|,
name|uint32_t
name|size
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uint32_t
name|maxsize
init|=
operator|(
operator|(
name|size
operator|-
literal|1
operator|)
operator|/
name|PAGE_SIZE
operator|+
literal|1
operator|)
operator|*
name|PAGE_SIZE
decl_stmt|;
name|ret
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|maxsize
argument_list|,
literal|1
argument_list|,
name|maxsize
argument_list|,
name|BUS_DMA_COHERENT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create bus tag, ret = %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|ret
operator|=
name|bus_dmamem_alloc
argument_list|(
operator|*
name|tag
argument_list|,
name|vaddr
argument_list|,
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate dmamem, ret = %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|ret
operator|=
name|bus_dmamap_load
argument_list|(
operator|*
name|tag
argument_list|,
operator|*
name|map
argument_list|,
operator|*
name|vaddr
argument_list|,
name|size
argument_list|,
name|al_dma_map_addr
argument_list|,
name|baddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate bus_dmamap_load, ret = %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_dma_free_coherent
parameter_list|(
name|bus_dma_tag_t
name|tag
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|void
modifier|*
name|vaddr
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|tag
argument_list|,
name|vaddr
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_mac_table_unicast_add
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|uint8_t
name|idx
parameter_list|,
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint8_t
name|udma_mask
parameter_list|)
block|{
name|struct
name|al_eth_fwd_mac_table_entry
name|entry
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
name|memcpy
argument_list|(
name|entry
operator|.
name|addr
argument_list|,
name|adapter
operator|->
name|mac_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|adapter
operator|->
name|mac_addr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|entry
operator|.
name|mask
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|rx_valid
operator|=
name|true
expr_stmt|;
name|entry
operator|.
name|tx_valid
operator|=
name|false
expr_stmt|;
name|entry
operator|.
name|udma_mask
operator|=
name|udma_mask
expr_stmt|;
name|entry
operator|.
name|filter
operator|=
name|false
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: [%d]: addr "
name|MAC_ADDR_STR
literal|" mask "
name|MAC_ADDR_STR
literal|"\n"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|,
name|MAC_ADDR
argument_list|(
name|entry
operator|.
name|addr
argument_list|)
argument_list|,
name|MAC_ADDR
argument_list|(
name|entry
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|al_eth_fwd_mac_table_set
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|idx
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_mac_table_all_multicast_add
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|uint8_t
name|idx
parameter_list|,
name|uint8_t
name|udma_mask
parameter_list|)
block|{
name|struct
name|al_eth_fwd_mac_table_entry
name|entry
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
name|memset
argument_list|(
name|entry
operator|.
name|addr
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|entry
operator|.
name|mask
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|mask
index|[
literal|0
index|]
operator||=
literal|1
expr_stmt|;
name|entry
operator|.
name|addr
index|[
literal|0
index|]
operator||=
literal|1
expr_stmt|;
name|entry
operator|.
name|rx_valid
operator|=
name|true
expr_stmt|;
name|entry
operator|.
name|tx_valid
operator|=
name|false
expr_stmt|;
name|entry
operator|.
name|udma_mask
operator|=
name|udma_mask
expr_stmt|;
name|entry
operator|.
name|filter
operator|=
name|false
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: [%d]: addr "
name|MAC_ADDR_STR
literal|" mask "
name|MAC_ADDR_STR
literal|"\n"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|,
name|MAC_ADDR
argument_list|(
name|entry
operator|.
name|addr
argument_list|)
argument_list|,
name|MAC_ADDR
argument_list|(
name|entry
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|al_eth_fwd_mac_table_set
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|idx
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_mac_table_broadcast_add
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|uint8_t
name|idx
parameter_list|,
name|uint8_t
name|udma_mask
parameter_list|)
block|{
name|struct
name|al_eth_fwd_mac_table_entry
name|entry
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
name|memset
argument_list|(
name|entry
operator|.
name|addr
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|entry
operator|.
name|mask
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|rx_valid
operator|=
name|true
expr_stmt|;
name|entry
operator|.
name|tx_valid
operator|=
name|false
expr_stmt|;
name|entry
operator|.
name|udma_mask
operator|=
name|udma_mask
expr_stmt|;
name|entry
operator|.
name|filter
operator|=
name|false
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: [%d]: addr "
name|MAC_ADDR_STR
literal|" mask "
name|MAC_ADDR_STR
literal|"\n"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|,
name|MAC_ADDR
argument_list|(
name|entry
operator|.
name|addr
argument_list|)
argument_list|,
name|MAC_ADDR
argument_list|(
name|entry
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|al_eth_fwd_mac_table_set
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|idx
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_mac_table_promiscuous_set
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|boolean_t
name|promiscuous
parameter_list|)
block|{
name|struct
name|al_eth_fwd_mac_table_entry
name|entry
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
name|memset
argument_list|(
name|entry
operator|.
name|addr
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|entry
operator|.
name|mask
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|rx_valid
operator|=
name|true
expr_stmt|;
name|entry
operator|.
name|tx_valid
operator|=
name|false
expr_stmt|;
name|entry
operator|.
name|udma_mask
operator|=
operator|(
name|promiscuous
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|entry
operator|.
name|filter
operator|=
operator|(
name|promiscuous
operator|)
condition|?
name|false
else|:
name|true
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: %s promiscuous mode\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|promiscuous
operator|)
condition|?
literal|"enter"
else|:
literal|"exit"
argument_list|)
expr_stmt|;
name|al_eth_fwd_mac_table_set
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|AL_ETH_MAC_TABLE_DROP_IDX
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_set_thash_table_entry
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|uint8_t
name|idx
parameter_list|,
name|uint8_t
name|udma
parameter_list|,
name|uint32_t
name|queue
parameter_list|)
block|{
if|if
condition|(
name|udma
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"only UDMA0 is supporter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
operator|>=
name|AL_ETH_NUM_QUEUES
condition|)
name|panic
argument_list|(
literal|"invalid queue number"
argument_list|)
expr_stmt|;
name|al_eth_thash_table_set
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|idx
argument_list|,
name|udma
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* init FSM, no tunneling supported yet, if packet is tcp/udp over ipv4/ipv6, use 4 tuple hash */
end_comment

begin_function
specifier|static
name|void
name|al_eth_fsm_table_init
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AL_ETH_RX_FSM_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|outer_type
init|=
name|AL_ETH_FSM_ENTRY_OUTER
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|outer_type
condition|)
block|{
case|case
name|AL_ETH_FSM_ENTRY_IPV4_TCP
case|:
case|case
name|AL_ETH_FSM_ENTRY_IPV4_UDP
case|:
case|case
name|AL_ETH_FSM_ENTRY_IPV6_TCP
case|:
case|case
name|AL_ETH_FSM_ENTRY_IPV6_UDP
case|:
name|val
operator|=
name|AL_ETH_FSM_DATA_OUTER_4_TUPLE
operator||
name|AL_ETH_FSM_DATA_HASH_SEL
expr_stmt|;
break|break;
case|case
name|AL_ETH_FSM_ENTRY_IPV6_NO_UDP_TCP
case|:
case|case
name|AL_ETH_FSM_ENTRY_IPV4_NO_UDP_TCP
case|:
name|val
operator|=
name|AL_ETH_FSM_DATA_OUTER_2_TUPLE
operator||
name|AL_ETH_FSM_DATA_HASH_SEL
expr_stmt|;
break|break;
default|default:
name|val
operator|=
name|AL_ETH_FSM_DATA_DEFAULT_Q
operator||
name|AL_ETH_FSM_DATA_DEFAULT_UDMA
expr_stmt|;
block|}
name|al_eth_fsm_table_set
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|i
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_mac_table_entry_clear
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|uint8_t
name|idx
parameter_list|)
block|{
name|struct
name|al_eth_fwd_mac_table_entry
name|entry
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: clear entry %d\n"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|al_eth_fwd_mac_table_set
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|idx
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_hw_init_adapter
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|al_eth_adapter_params
modifier|*
name|params
init|=
operator|&
name|adapter
operator|->
name|eth_hal_params
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* params->dev_id = adapter->dev_id; */
name|params
operator|->
name|rev_id
operator|=
name|adapter
operator|->
name|rev_id
expr_stmt|;
name|params
operator|->
name|udma_id
operator|=
literal|0
expr_stmt|;
name|params
operator|->
name|enable_rx_parser
operator|=
literal|1
expr_stmt|;
comment|/* enable rx epe parser*/
name|params
operator|->
name|udma_regs_base
operator|=
name|adapter
operator|->
name|udma_base
expr_stmt|;
comment|/* UDMA register base address */
name|params
operator|->
name|ec_regs_base
operator|=
name|adapter
operator|->
name|ec_base
expr_stmt|;
comment|/* Ethernet controller registers base address */
name|params
operator|->
name|mac_regs_base
operator|=
name|adapter
operator|->
name|mac_base
expr_stmt|;
comment|/* Ethernet MAC registers base address */
name|params
operator|->
name|name
operator|=
name|adapter
operator|->
name|name
expr_stmt|;
name|params
operator|->
name|serdes_lane
operator|=
name|adapter
operator|->
name|serdes_lane
expr_stmt|;
name|rc
operator|=
name|al_eth_adapter_init
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s failed at hal init!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|board_type
operator|==
name|ALPINE_NIC
operator|)
operator|||
operator|(
name|adapter
operator|->
name|board_type
operator|==
name|ALPINE_FPGA_NIC
operator|)
condition|)
block|{
comment|/* in pcie NIC mode, force eth UDMA to access PCIE0 using the vmid */
name|struct
name|al_udma_gen_tgtid_conf
name|conf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DMA_MAX_Q
condition|;
name|i
operator|++
control|)
block|{
name|conf
operator|.
name|tx_q_conf
index|[
name|i
index|]
operator|.
name|queue_en
operator|=
name|AL_TRUE
expr_stmt|;
name|conf
operator|.
name|tx_q_conf
index|[
name|i
index|]
operator|.
name|desc_en
operator|=
name|AL_FALSE
expr_stmt|;
name|conf
operator|.
name|tx_q_conf
index|[
name|i
index|]
operator|.
name|tgtid
operator|=
literal|0x100
expr_stmt|;
comment|/* for access from PCIE0 */
name|conf
operator|.
name|rx_q_conf
index|[
name|i
index|]
operator|.
name|queue_en
operator|=
name|AL_TRUE
expr_stmt|;
name|conf
operator|.
name|rx_q_conf
index|[
name|i
index|]
operator|.
name|desc_en
operator|=
name|AL_FALSE
expr_stmt|;
name|conf
operator|.
name|rx_q_conf
index|[
name|i
index|]
operator|.
name|tgtid
operator|=
literal|0x100
expr_stmt|;
comment|/* for access from PCIE0 */
block|}
name|al_udma_gen_tgtid_conf_set
argument_list|(
name|adapter
operator|->
name|udma_base
argument_list|,
operator|&
name|conf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_lm_config
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|al_eth_lm_init_params
name|params
init|=
block|{
literal|0
block|}
decl_stmt|;
name|params
operator|.
name|adapter
operator|=
operator|&
name|adapter
operator|->
name|hal_adapter
expr_stmt|;
name|params
operator|.
name|serdes_obj
operator|=
operator|&
name|adapter
operator|->
name|serdes_obj
expr_stmt|;
name|params
operator|.
name|lane
operator|=
name|adapter
operator|->
name|serdes_lane
expr_stmt|;
name|params
operator|.
name|sfp_detection
operator|=
name|adapter
operator|->
name|sfp_detection_needed
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|sfp_detection_needed
operator|==
name|true
condition|)
block|{
name|params
operator|.
name|sfp_bus_id
operator|=
name|adapter
operator|->
name|i2c_adapter_id
expr_stmt|;
name|params
operator|.
name|sfp_i2c_addr
operator|=
name|SFP_I2C_ADDR
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|sfp_detection_needed
operator|==
name|false
condition|)
block|{
switch|switch
condition|(
name|adapter
operator|->
name|mac_mode
condition|)
block|{
case|case
name|AL_ETH_MAC_MODE_10GbE_Serial
case|:
if|if
condition|(
operator|(
name|adapter
operator|->
name|lt_en
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|adapter
operator|->
name|an_en
operator|!=
literal|0
operator|)
condition|)
name|params
operator|.
name|default_mode
operator|=
name|AL_ETH_LM_MODE_10G_DA
expr_stmt|;
else|else
name|params
operator|.
name|default_mode
operator|=
name|AL_ETH_LM_MODE_10G_OPTIC
expr_stmt|;
break|break;
case|case
name|AL_ETH_MAC_MODE_SGMII
case|:
name|params
operator|.
name|default_mode
operator|=
name|AL_ETH_LM_MODE_1G
expr_stmt|;
break|break;
default|default:
name|params
operator|.
name|default_mode
operator|=
name|AL_ETH_LM_MODE_10G_DA
expr_stmt|;
block|}
block|}
else|else
name|params
operator|.
name|default_mode
operator|=
name|AL_ETH_LM_MODE_10G_DA
expr_stmt|;
name|params
operator|.
name|link_training
operator|=
name|adapter
operator|->
name|lt_en
expr_stmt|;
name|params
operator|.
name|rx_equal
operator|=
name|true
expr_stmt|;
name|params
operator|.
name|static_values
operator|=
operator|!
name|adapter
operator|->
name|dont_override_serdes
expr_stmt|;
name|params
operator|.
name|i2c_context
operator|=
name|adapter
expr_stmt|;
name|params
operator|.
name|kr_fec_enable
operator|=
name|false
expr_stmt|;
name|params
operator|.
name|retimer_exist
operator|=
name|adapter
operator|->
name|retimer
operator|.
name|exist
expr_stmt|;
name|params
operator|.
name|retimer_bus_id
operator|=
name|adapter
operator|->
name|retimer
operator|.
name|bus_id
expr_stmt|;
name|params
operator|.
name|retimer_i2c_addr
operator|=
name|adapter
operator|->
name|retimer
operator|.
name|i2c_addr
expr_stmt|;
name|params
operator|.
name|retimer_channel
operator|=
name|adapter
operator|->
name|retimer
operator|.
name|channel
expr_stmt|;
name|al_eth_lm_init
argument_list|(
operator|&
name|adapter
operator|->
name|lm_context
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_board_params_init
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|adapter
operator|->
name|board_type
operator|==
name|ALPINE_NIC
condition|)
block|{
name|adapter
operator|->
name|mac_mode
operator|=
name|AL_ETH_MAC_MODE_10GbE_Serial
expr_stmt|;
name|adapter
operator|->
name|sfp_detection_needed
operator|=
name|false
expr_stmt|;
name|adapter
operator|->
name|phy_exist
operator|=
name|false
expr_stmt|;
name|adapter
operator|->
name|an_en
operator|=
name|false
expr_stmt|;
name|adapter
operator|->
name|lt_en
operator|=
name|false
expr_stmt|;
name|adapter
operator|->
name|ref_clk_freq
operator|=
name|AL_ETH_REF_FREQ_375_MHZ
expr_stmt|;
name|adapter
operator|->
name|mdio_freq
operator|=
name|AL_ETH_DEFAULT_MDIO_FREQ_KHZ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|board_type
operator|==
name|ALPINE_FPGA_NIC
condition|)
block|{
name|adapter
operator|->
name|mac_mode
operator|=
name|AL_ETH_MAC_MODE_SGMII
expr_stmt|;
name|adapter
operator|->
name|sfp_detection_needed
operator|=
name|false
expr_stmt|;
name|adapter
operator|->
name|phy_exist
operator|=
name|false
expr_stmt|;
name|adapter
operator|->
name|an_en
operator|=
name|false
expr_stmt|;
name|adapter
operator|->
name|lt_en
operator|=
name|false
expr_stmt|;
name|adapter
operator|->
name|ref_clk_freq
operator|=
name|AL_ETH_REF_FREQ_375_MHZ
expr_stmt|;
name|adapter
operator|->
name|mdio_freq
operator|=
name|AL_ETH_DEFAULT_MDIO_FREQ_KHZ
expr_stmt|;
block|}
else|else
block|{
name|struct
name|al_eth_board_params
name|params
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|adapter
operator|->
name|auto_speed
operator|=
name|false
expr_stmt|;
name|rc
operator|=
name|al_eth_board_params_get
argument_list|(
name|adapter
operator|->
name|mac_base
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"board info not available\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|adapter
operator|->
name|phy_exist
operator|=
name|params
operator|.
name|phy_exist
operator|==
name|TRUE
expr_stmt|;
name|adapter
operator|->
name|phy_addr
operator|=
name|params
operator|.
name|phy_mdio_addr
expr_stmt|;
name|adapter
operator|->
name|an_en
operator|=
name|params
operator|.
name|autoneg_enable
expr_stmt|;
name|adapter
operator|->
name|lt_en
operator|=
name|params
operator|.
name|kr_lt_enable
expr_stmt|;
name|adapter
operator|->
name|serdes_grp
operator|=
name|params
operator|.
name|serdes_grp
expr_stmt|;
name|adapter
operator|->
name|serdes_lane
operator|=
name|params
operator|.
name|serdes_lane
expr_stmt|;
name|adapter
operator|->
name|sfp_detection_needed
operator|=
name|params
operator|.
name|sfp_plus_module_exist
expr_stmt|;
name|adapter
operator|->
name|i2c_adapter_id
operator|=
name|params
operator|.
name|i2c_adapter_id
expr_stmt|;
name|adapter
operator|->
name|ref_clk_freq
operator|=
name|params
operator|.
name|ref_clk_freq
expr_stmt|;
name|adapter
operator|->
name|dont_override_serdes
operator|=
name|params
operator|.
name|dont_override_serdes
expr_stmt|;
name|adapter
operator|->
name|link_config
operator|.
name|active_duplex
operator|=
operator|!
name|params
operator|.
name|half_duplex
expr_stmt|;
name|adapter
operator|->
name|link_config
operator|.
name|autoneg
operator|=
operator|!
name|params
operator|.
name|an_disable
expr_stmt|;
name|adapter
operator|->
name|link_config
operator|.
name|force_1000_base_x
operator|=
name|params
operator|.
name|force_1000_base_x
expr_stmt|;
name|adapter
operator|->
name|retimer
operator|.
name|exist
operator|=
name|params
operator|.
name|retimer_exist
expr_stmt|;
name|adapter
operator|->
name|retimer
operator|.
name|bus_id
operator|=
name|params
operator|.
name|retimer_bus_id
expr_stmt|;
name|adapter
operator|->
name|retimer
operator|.
name|i2c_addr
operator|=
name|params
operator|.
name|retimer_i2c_addr
expr_stmt|;
name|adapter
operator|->
name|retimer
operator|.
name|channel
operator|=
name|params
operator|.
name|retimer_channel
expr_stmt|;
switch|switch
condition|(
name|params
operator|.
name|speed
condition|)
block|{
default|default:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: invalid speed (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|params
operator|.
name|speed
argument_list|)
expr_stmt|;
case|case
name|AL_ETH_BOARD_1G_SPEED_1000M
case|:
name|adapter
operator|->
name|link_config
operator|.
name|active_speed
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
name|AL_ETH_BOARD_1G_SPEED_100M
case|:
name|adapter
operator|->
name|link_config
operator|.
name|active_speed
operator|=
literal|100
expr_stmt|;
break|break;
case|case
name|AL_ETH_BOARD_1G_SPEED_10M
case|:
name|adapter
operator|->
name|link_config
operator|.
name|active_speed
operator|=
literal|10
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|params
operator|.
name|mdio_freq
condition|)
block|{
default|default:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: invalid mdio freq (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|params
operator|.
name|mdio_freq
argument_list|)
expr_stmt|;
case|case
name|AL_ETH_BOARD_MDIO_FREQ_2_5_MHZ
case|:
name|adapter
operator|->
name|mdio_freq
operator|=
name|AL_ETH_DEFAULT_MDIO_FREQ_KHZ
expr_stmt|;
break|break;
case|case
name|AL_ETH_BOARD_MDIO_FREQ_1_MHZ
case|:
name|adapter
operator|->
name|mdio_freq
operator|=
name|AL_ETH_MDIO_FREQ_1000_KHZ
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|params
operator|.
name|media_type
condition|)
block|{
case|case
name|AL_ETH_BOARD_MEDIA_TYPE_RGMII
case|:
if|if
condition|(
name|params
operator|.
name|sfp_plus_module_exist
operator|==
name|TRUE
condition|)
comment|/* Backward compatibility */
name|adapter
operator|->
name|mac_mode
operator|=
name|AL_ETH_MAC_MODE_SGMII
expr_stmt|;
else|else
name|adapter
operator|->
name|mac_mode
operator|=
name|AL_ETH_MAC_MODE_RGMII
expr_stmt|;
name|adapter
operator|->
name|use_lm
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|AL_ETH_BOARD_MEDIA_TYPE_SGMII
case|:
name|adapter
operator|->
name|mac_mode
operator|=
name|AL_ETH_MAC_MODE_SGMII
expr_stmt|;
name|adapter
operator|->
name|use_lm
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|AL_ETH_BOARD_MEDIA_TYPE_10GBASE_SR
case|:
name|adapter
operator|->
name|mac_mode
operator|=
name|AL_ETH_MAC_MODE_10GbE_Serial
expr_stmt|;
name|adapter
operator|->
name|use_lm
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|AL_ETH_BOARD_MEDIA_TYPE_AUTO_DETECT
case|:
name|adapter
operator|->
name|sfp_detection_needed
operator|=
name|TRUE
expr_stmt|;
name|adapter
operator|->
name|auto_speed
operator|=
name|false
expr_stmt|;
name|adapter
operator|->
name|use_lm
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|AL_ETH_BOARD_MEDIA_TYPE_AUTO_DETECT_AUTO_SPEED
case|:
name|adapter
operator|->
name|sfp_detection_needed
operator|=
name|TRUE
expr_stmt|;
name|adapter
operator|->
name|auto_speed
operator|=
name|true
expr_stmt|;
name|adapter
operator|->
name|mac_mode_set
operator|=
name|false
expr_stmt|;
name|adapter
operator|->
name|use_lm
operator|=
name|true
expr_stmt|;
name|adapter
operator|->
name|mac_mode
operator|=
name|AL_ETH_MAC_MODE_10GbE_Serial
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: unsupported media type %d\n"
argument_list|,
name|__func__
argument_list|,
name|params
operator|.
name|media_type
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Board info: phy exist %s. phy addr %d. mdio freq %u Khz. "
literal|"SFP connected %s. media %d\n"
argument_list|,
name|params
operator|.
name|phy_exist
operator|==
name|TRUE
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|,
name|params
operator|.
name|phy_mdio_addr
argument_list|,
name|adapter
operator|->
name|mdio_freq
argument_list|,
name|params
operator|.
name|sfp_plus_module_exist
operator|==
name|TRUE
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|,
name|params
operator|.
name|media_type
argument_list|)
expr_stmt|;
block|}
name|al_eth_mac_addr_read
argument_list|(
name|adapter
operator|->
name|ec_base
argument_list|,
literal|0
argument_list|,
name|adapter
operator|->
name|mac_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_function_reset
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|al_eth_board_params
name|params
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* save board params so we restore it after reset */
name|al_eth_board_params_get
argument_list|(
name|adapter
operator|->
name|mac_base
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|al_eth_mac_addr_read
argument_list|(
name|adapter
operator|->
name|ec_base
argument_list|,
literal|0
argument_list|,
name|adapter
operator|->
name|mac_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|board_type
operator|==
name|ALPINE_INTEGRATED
condition|)
name|rc
operator|=
name|al_eth_flr_rmn
argument_list|(
operator|&
name|al_eth_read_pci_config
argument_list|,
operator|&
name|al_eth_write_pci_config
argument_list|,
name|adapter
operator|->
name|dev
argument_list|,
name|adapter
operator|->
name|mac_base
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|al_eth_flr_rmn
argument_list|(
operator|&
name|al_eth_fpga_read_pci_config
argument_list|,
operator|&
name|al_eth_fpga_write_pci_config
argument_list|,
name|adapter
operator|->
name|internal_pcie_base
argument_list|,
name|adapter
operator|->
name|mac_base
argument_list|)
expr_stmt|;
comment|/* restore params */
name|al_eth_board_params_set
argument_list|(
name|adapter
operator|->
name|mac_base
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|al_eth_mac_addr_store
argument_list|(
name|adapter
operator|->
name|ec_base
argument_list|,
literal|0
argument_list|,
name|adapter
operator|->
name|mac_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_init_rings
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_queues
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|al_eth_ring
modifier|*
name|ring
init|=
operator|&
name|adapter
operator|->
name|tx_ring
index|[
name|i
index|]
decl_stmt|;
name|ring
operator|->
name|ring_id
operator|=
name|i
expr_stmt|;
name|ring
operator|->
name|dev
operator|=
name|adapter
operator|->
name|dev
expr_stmt|;
name|ring
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|ring
operator|->
name|netdev
operator|=
name|adapter
operator|->
name|netdev
expr_stmt|;
name|al_udma_q_handle_get
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
operator|.
name|tx_udma
argument_list|,
name|i
argument_list|,
operator|&
name|ring
operator|->
name|dma_q
argument_list|)
expr_stmt|;
name|ring
operator|->
name|sw_count
operator|=
name|adapter
operator|->
name|tx_ring_count
expr_stmt|;
name|ring
operator|->
name|hw_count
operator|=
name|adapter
operator|->
name|tx_descs_count
expr_stmt|;
name|ring
operator|->
name|unmask_reg_offset
operator|=
name|al_udma_iofic_unmask_offset_get
argument_list|(
operator|(
expr|struct
name|unit_regs
operator|*
operator|)
name|adapter
operator|->
name|udma_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_C
argument_list|)
expr_stmt|;
name|ring
operator|->
name|unmask_val
operator|=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|al_eth_ring
modifier|*
name|ring
init|=
operator|&
name|adapter
operator|->
name|rx_ring
index|[
name|i
index|]
decl_stmt|;
name|ring
operator|->
name|ring_id
operator|=
name|i
expr_stmt|;
name|ring
operator|->
name|dev
operator|=
name|adapter
operator|->
name|dev
expr_stmt|;
name|ring
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|ring
operator|->
name|netdev
operator|=
name|adapter
operator|->
name|netdev
expr_stmt|;
name|al_udma_q_handle_get
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
operator|.
name|rx_udma
argument_list|,
name|i
argument_list|,
operator|&
name|ring
operator|->
name|dma_q
argument_list|)
expr_stmt|;
name|ring
operator|->
name|sw_count
operator|=
name|adapter
operator|->
name|rx_ring_count
expr_stmt|;
name|ring
operator|->
name|hw_count
operator|=
name|adapter
operator|->
name|rx_descs_count
expr_stmt|;
name|ring
operator|->
name|unmask_reg_offset
operator|=
name|al_udma_iofic_unmask_offset_get
argument_list|(
operator|(
expr|struct
name|unit_regs
operator|*
operator|)
name|adapter
operator|->
name|udma_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_B
argument_list|)
expr_stmt|;
name|ring
operator|->
name|unmask_val
operator|=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|al_init_locked
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|netdev
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|al_eth_down
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|rc
operator|=
name|al_eth_up
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|al_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|al_eth_alloc_rx_buf
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|al_eth_ring
modifier|*
name|rx_ring
parameter_list|,
name|struct
name|al_eth_rx_buffer
modifier|*
name|rx_info
parameter_list|)
block|{
name|struct
name|al_buf
modifier|*
name|al_buf
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
if|if
condition|(
name|rx_info
operator|->
name|m
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rx_info
operator|->
name|data_size
operator|=
name|adapter
operator|->
name|rx_mbuf_sz
expr_stmt|;
name|AL_RX_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Get mbuf using UMA allocator */
name|rx_info
operator|->
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|rx_info
operator|->
name|data_size
argument_list|)
expr_stmt|;
name|AL_RX_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_info
operator|->
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rx_info
operator|->
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|rx_info
operator|->
name|m
operator|->
name|m_len
operator|=
name|adapter
operator|->
name|rx_mbuf_sz
expr_stmt|;
comment|/* Map packets for DMA */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rx_ring
operator|->
name|dma_buf_tag
argument_list|,
name|rx_info
operator|->
name|dma_map
argument_list|,
name|rx_info
operator|->
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|rx_ring
operator|->
name|dev
argument_list|,
literal|"failed to map mbuf, error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rx_info
operator|->
name|m
argument_list|)
expr_stmt|;
name|rx_info
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|al_buf
operator|=
operator|&
name|rx_info
operator|->
name|al_buf
expr_stmt|;
name|al_buf
operator|->
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|+
name|AL_IP_ALIGNMENT_OFFSET
expr_stmt|;
name|al_buf
operator|->
name|len
operator|=
name|rx_info
operator|->
name|data_size
operator|-
name|AL_IP_ALIGNMENT_OFFSET
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_refill_rx_bufs
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|,
name|unsigned
name|int
name|num
parameter_list|)
block|{
name|struct
name|al_eth_ring
modifier|*
name|rx_ring
init|=
operator|&
name|adapter
operator|->
name|rx_ring
index|[
name|qid
index|]
decl_stmt|;
name|uint16_t
name|next_to_use
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|next_to_use
operator|=
name|rx_ring
operator|->
name|next_to_use
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|al_eth_rx_buffer
modifier|*
name|rx_info
init|=
operator|&
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|next_to_use
index|]
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|al_eth_alloc_rx_buf
argument_list|(
name|adapter
argument_list|,
name|rx_ring
argument_list|,
name|rx_info
argument_list|)
operator|<
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"failed to alloc buffer for rx queue %d\n"
argument_list|,
name|qid
argument_list|)
expr_stmt|;
break|break;
block|}
name|rc
operator|=
name|al_eth_rx_buffer_add
argument_list|(
name|rx_ring
operator|->
name|dma_q
argument_list|,
operator|&
name|rx_info
operator|->
name|al_buf
argument_list|,
name|AL_ETH_RX_FLAGS_INT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"failed to add buffer for rx queue %d\n"
argument_list|,
name|qid
argument_list|)
expr_stmt|;
break|break;
block|}
name|next_to_use
operator|=
name|AL_ETH_RX_RING_IDX_NEXT
argument_list|(
name|rx_ring
argument_list|,
name|next_to_use
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|i
operator|<
name|num
argument_list|)
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"refilled rx queue %d with %d pages only - available %d\n"
argument_list|,
name|qid
argument_list|,
name|i
argument_list|,
name|al_udma_available_get
argument_list|(
name|rx_ring
operator|->
name|dma_q
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|i
argument_list|)
condition|)
name|al_eth_rx_buffer_action
argument_list|(
name|rx_ring
operator|->
name|dma_q
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|next_to_use
operator|=
name|next_to_use
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * al_eth_refill_all_rx_bufs - allocate all queues Rx buffers  * @adapter: board private structure  */
end_comment

begin_function
specifier|static
name|void
name|al_eth_refill_all_rx_bufs
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
control|)
name|al_eth_refill_rx_bufs
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
name|AL_ETH_DEFAULT_RX_DESCS
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_tx_do_cleanup
parameter_list|(
name|struct
name|al_eth_ring
modifier|*
name|tx_ring
parameter_list|)
block|{
name|unsigned
name|int
name|total_done
decl_stmt|;
name|uint16_t
name|next_to_clean
decl_stmt|;
name|int
name|qid
init|=
name|tx_ring
operator|->
name|ring_id
decl_stmt|;
name|total_done
operator|=
name|al_eth_comp_tx_get
argument_list|(
name|tx_ring
operator|->
name|dma_q
argument_list|)
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|tx_ring
operator|->
name|dev
argument_list|,
literal|"tx_poll: q %d total completed descs %x\n"
argument_list|,
name|qid
argument_list|,
name|total_done
argument_list|)
expr_stmt|;
name|next_to_clean
operator|=
name|tx_ring
operator|->
name|next_to_clean
expr_stmt|;
while|while
condition|(
name|total_done
operator|!=
literal|0
condition|)
block|{
name|struct
name|al_eth_tx_buffer
modifier|*
name|tx_info
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|tx_info
operator|=
operator|&
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|next_to_clean
index|]
expr_stmt|;
comment|/* stop if not all descriptors of the packet are completed */
if|if
condition|(
name|tx_info
operator|->
name|tx_descs
operator|>
name|total_done
condition|)
break|break;
name|mbuf
operator|=
name|tx_info
operator|->
name|m
expr_stmt|;
name|tx_info
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|tx_ring
operator|->
name|dev
argument_list|,
literal|"tx_poll: q %d mbuf %p completed\n"
argument_list|,
name|qid
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
comment|/* map is no longer required */
name|bus_dmamap_unload
argument_list|(
name|tx_ring
operator|->
name|dma_buf_tag
argument_list|,
name|tx_info
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|total_done
operator|-=
name|tx_info
operator|->
name|tx_descs
expr_stmt|;
name|next_to_clean
operator|=
name|AL_ETH_TX_RING_IDX_NEXT
argument_list|(
name|tx_ring
argument_list|,
name|next_to_clean
argument_list|)
expr_stmt|;
block|}
name|tx_ring
operator|->
name|next_to_clean
operator|=
name|next_to_clean
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|tx_ring
operator|->
name|dev
argument_list|,
literal|"tx_poll: q %d done next to clean %x\n"
argument_list|,
name|qid
argument_list|,
name|next_to_clean
argument_list|)
expr_stmt|;
comment|/* 	 * need to make the rings circular update visible to 	 * al_eth_start_xmit() before checking for netif_queue_stopped(). 	 */
name|al_smp_data_memory_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_tx_csum
parameter_list|(
name|struct
name|al_eth_ring
modifier|*
name|tx_ring
parameter_list|,
name|struct
name|al_eth_tx_buffer
modifier|*
name|tx_info
parameter_list|,
name|struct
name|al_eth_pkt
modifier|*
name|hal_pkt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|uint32_t
name|mss
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|uint16_t
name|etype
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|NULL
decl_stmt|;
name|int
name|ehdrlen
decl_stmt|,
name|ip_hlen
init|=
literal|0
decl_stmt|;
name|uint8_t
name|ipproto
init|=
literal|0
decl_stmt|;
name|uint32_t
name|offload
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mss
operator|!=
literal|0
condition|)
name|offload
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
condition|)
name|offload
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_OFFLOAD
operator|)
operator|!=
literal|0
condition|)
name|offload
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|offload
operator|!=
literal|0
condition|)
block|{
name|struct
name|al_eth_meta_data
modifier|*
name|meta
init|=
operator|&
name|tx_ring
operator|->
name|hal_meta
decl_stmt|;
if|if
condition|(
name|mss
operator|!=
literal|0
condition|)
name|hal_pkt
operator|->
name|flags
operator||=
operator|(
name|AL_ETH_TX_FLAGS_TSO
operator||
name|AL_ETH_TX_FLAGS_L4_CSUM
operator|)
expr_stmt|;
else|else
name|hal_pkt
operator|->
name|flags
operator||=
operator|(
name|AL_ETH_TX_FLAGS_L4_CSUM
operator||
name|AL_ETH_TX_FLAGS_L4_PARTIAL_CSUM
operator|)
expr_stmt|;
comment|/* 		 * Determine where frame payload starts. 		 * Jump over vlan headers if already present, 		 * helpful for QinQ too. 		 */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
else|else
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
block|}
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|ipproto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|hal_pkt
operator|->
name|l3_proto_idx
operator|=
name|AL_ETH_PROTO_ID_IPv4
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|ip_hlen
operator|)
expr_stmt|;
if|if
condition|(
name|mss
operator|!=
literal|0
condition|)
name|hal_pkt
operator|->
name|flags
operator||=
name|AL_ETH_TX_FLAGS_IPV4_L3_CSUM
expr_stmt|;
if|if
condition|(
name|ipproto
operator|==
name|IPPROTO_TCP
condition|)
name|hal_pkt
operator|->
name|l4_proto_idx
operator|=
name|AL_ETH_PROTO_ID_TCP
expr_stmt|;
else|else
name|hal_pkt
operator|->
name|l4_proto_idx
operator|=
name|AL_ETH_PROTO_ID_UDP
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|hal_pkt
operator|->
name|l3_proto_idx
operator|=
name|AL_ETH_PROTO_ID_IPv6
expr_stmt|;
name|ip_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6
operator|+
name|ip_hlen
operator|)
expr_stmt|;
name|ipproto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
if|if
condition|(
name|ipproto
operator|==
name|IPPROTO_TCP
condition|)
name|hal_pkt
operator|->
name|l4_proto_idx
operator|=
name|AL_ETH_PROTO_ID_TCP
expr_stmt|;
else|else
name|hal_pkt
operator|->
name|l4_proto_idx
operator|=
name|AL_ETH_PROTO_ID_UDP
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|meta
operator|->
name|words_valid
operator|=
literal|4
expr_stmt|;
name|meta
operator|->
name|l3_header_len
operator|=
name|ip_hlen
expr_stmt|;
name|meta
operator|->
name|l3_header_offset
operator|=
name|ehdrlen
expr_stmt|;
if|if
condition|(
name|th
operator|!=
name|NULL
condition|)
name|meta
operator|->
name|l4_header_len
operator|=
name|th
operator|->
name|th_off
expr_stmt|;
comment|/* this param needed only for TSO */
name|meta
operator|->
name|mss_idx_sel
operator|=
literal|0
expr_stmt|;
comment|/* check how to select MSS */
name|meta
operator|->
name|mss_val
operator|=
name|mss
expr_stmt|;
name|hal_pkt
operator|->
name|meta
operator|=
name|meta
expr_stmt|;
block|}
else|else
name|hal_pkt
operator|->
name|meta
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|XMIT_QUEUE_TIMEOUT
value|100
end_define

begin_function
specifier|static
name|void
name|al_eth_xmit_mbuf
parameter_list|(
name|struct
name|al_eth_ring
modifier|*
name|tx_ring
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|al_eth_tx_buffer
modifier|*
name|tx_info
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|a
decl_stmt|;
name|uint16_t
name|next_to_use
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|AL_ETH_PKT_MAX_BUFS
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|al_eth_pkt
modifier|*
name|hal_pkt
decl_stmt|;
name|struct
name|al_buf
modifier|*
name|al_buf
decl_stmt|;
name|boolean_t
name|remap
decl_stmt|;
comment|/* Check if queue is ready */
if|if
condition|(
name|unlikely
argument_list|(
name|tx_ring
operator|->
name|stall
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
name|XMIT_QUEUE_TIMEOUT
condition|;
name|a
operator|++
control|)
block|{
if|if
condition|(
name|al_udma_available_get
argument_list|(
name|tx_ring
operator|->
name|dma_q
argument_list|)
operator|>=
operator|(
name|AL_ETH_DEFAULT_TX_HW_DESCS
operator|-
name|AL_ETH_TX_WAKEUP_THRESH
operator|)
condition|)
block|{
name|tx_ring
operator|->
name|stall
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|pause
argument_list|(
literal|"stall"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|==
name|XMIT_QUEUE_TIMEOUT
condition|)
block|{
name|device_printf
argument_list|(
name|tx_ring
operator|->
name|dev
argument_list|,
literal|"timeout waiting for queue %d ready!\n"
argument_list|,
name|tx_ring
operator|->
name|ring_id
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|device_printf_dbg
argument_list|(
name|tx_ring
operator|->
name|dev
argument_list|,
literal|"queue %d is ready!\n"
argument_list|,
name|tx_ring
operator|->
name|ring_id
argument_list|)
expr_stmt|;
block|}
block|}
name|next_to_use
operator|=
name|tx_ring
operator|->
name|next_to_use
expr_stmt|;
name|tx_info
operator|=
operator|&
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|next_to_use
index|]
expr_stmt|;
name|tx_info
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|hal_pkt
operator|=
operator|&
name|tx_info
operator|->
name|hal_pkt
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|tx_ring
operator|->
name|dev
argument_list|,
literal|"mbuf is NULL\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|remap
operator|=
name|TRUE
expr_stmt|;
comment|/* Map packets for DMA */
name|retry
label|:
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|tx_ring
operator|->
name|dma_buf_tag
argument_list|,
name|tx_info
operator|->
name|dma_map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* Try it again? - one try */
if|if
condition|(
name|remap
operator|==
name|TRUE
condition|)
block|{
name|remap
operator|=
name|FALSE
expr_stmt|;
name|m_new
operator|=
name|m_defrag
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|tx_ring
operator|->
name|dev
argument_list|,
literal|"failed to defrag mbuf\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|m
operator|=
name|m_new
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|tx_ring
operator|->
name|dev
argument_list|,
literal|"failed to map mbuf, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
block|}
else|else
block|{
name|device_printf
argument_list|(
name|tx_ring
operator|->
name|dev
argument_list|,
literal|"failed to map mbuf, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
block|}
comment|/* set flags and meta data */
name|hal_pkt
operator|->
name|flags
operator|=
name|AL_ETH_TX_FLAGS_INT
expr_stmt|;
name|al_eth_tx_csum
argument_list|(
name|tx_ring
argument_list|,
name|tx_info
argument_list|,
name|hal_pkt
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|al_buf
operator|=
name|hal_pkt
operator|->
name|bufs
expr_stmt|;
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
name|nsegs
condition|;
name|a
operator|++
control|)
block|{
name|al_buf
operator|->
name|addr
operator|=
name|segs
index|[
name|a
index|]
operator|.
name|ds_addr
expr_stmt|;
name|al_buf
operator|->
name|len
operator|=
name|segs
index|[
name|a
index|]
operator|.
name|ds_len
expr_stmt|;
name|al_buf
operator|++
expr_stmt|;
block|}
name|hal_pkt
operator|->
name|num_of_bufs
operator|=
name|nsegs
expr_stmt|;
comment|/* prepare the packet's descriptors to dma engine */
name|tx_info
operator|->
name|tx_descs
operator|=
name|al_eth_tx_pkt_prepare
argument_list|(
name|tx_ring
operator|->
name|dma_q
argument_list|,
name|hal_pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_info
operator|->
name|tx_descs
operator|==
literal|0
condition|)
goto|goto
name|exit
goto|;
comment|/* 	 * stop the queue when no more space available, the packet can have up 	 * to AL_ETH_PKT_MAX_BUFS + 1 buffers and a meta descriptor 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|al_udma_available_get
argument_list|(
name|tx_ring
operator|->
name|dma_q
argument_list|)
operator|<
operator|(
name|AL_ETH_PKT_MAX_BUFS
operator|+
literal|2
operator|)
argument_list|)
condition|)
block|{
name|tx_ring
operator|->
name|stall
operator|=
literal|1
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|tx_ring
operator|->
name|dev
argument_list|,
literal|"stall, stopping queue %d...\n"
argument_list|,
name|tx_ring
operator|->
name|ring_id
argument_list|)
expr_stmt|;
name|al_data_memory_barrier
argument_list|()
expr_stmt|;
block|}
name|tx_ring
operator|->
name|next_to_use
operator|=
name|AL_ETH_TX_RING_IDX_NEXT
argument_list|(
name|tx_ring
argument_list|,
name|next_to_use
argument_list|)
expr_stmt|;
comment|/* trigger the dma engine */
name|al_eth_tx_dma_action
argument_list|(
name|tx_ring
operator|->
name|dma_q
argument_list|,
name|tx_info
operator|->
name|tx_descs
argument_list|)
expr_stmt|;
return|return;
name|exit
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_tx_cmpl_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|al_eth_ring
modifier|*
name|tx_ring
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|napi
operator|!=
literal|0
condition|)
block|{
name|tx_ring
operator|->
name|cmpl_is_running
operator|=
literal|1
expr_stmt|;
name|al_data_memory_barrier
argument_list|()
expr_stmt|;
block|}
name|al_eth_tx_do_cleanup
argument_list|(
name|tx_ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|napi
operator|!=
literal|0
condition|)
block|{
name|tx_ring
operator|->
name|cmpl_is_running
operator|=
literal|0
expr_stmt|;
name|al_data_memory_barrier
argument_list|()
expr_stmt|;
block|}
comment|/* all work done, enable IRQs */
name|al_eth_irq_config
argument_list|(
name|tx_ring
operator|->
name|unmask_reg_offset
argument_list|,
name|tx_ring
operator|->
name|unmask_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_tx_cmlp_irq_filter
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|al_eth_ring
modifier|*
name|tx_ring
init|=
name|arg
decl_stmt|;
comment|/* Interrupt should be auto-masked upon arrival */
name|device_printf_dbg
argument_list|(
name|tx_ring
operator|->
name|dev
argument_list|,
literal|"%s for ring ID = %d\n"
argument_list|,
name|__func__
argument_list|,
name|tx_ring
operator|->
name|ring_id
argument_list|)
expr_stmt|;
comment|/* 	 * For napi, if work is not running, schedule it. Always schedule 	 * for casual (non-napi) packet handling. 	 */
if|if
condition|(
operator|(
name|napi
operator|==
literal|0
operator|)
operator|||
operator|(
name|napi
operator|&&
name|tx_ring
operator|->
name|cmpl_is_running
operator|==
literal|0
operator|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|tx_ring
operator|->
name|cmpl_tq
argument_list|,
operator|&
name|tx_ring
operator|->
name|cmpl_task
argument_list|)
expr_stmt|;
comment|/* Do not run bottom half */
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_rx_recv_irq_filter
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|al_eth_ring
modifier|*
name|rx_ring
init|=
name|arg
decl_stmt|;
comment|/* Interrupt should be auto-masked upon arrival */
name|device_printf_dbg
argument_list|(
name|rx_ring
operator|->
name|dev
argument_list|,
literal|"%s for ring ID = %d\n"
argument_list|,
name|__func__
argument_list|,
name|rx_ring
operator|->
name|ring_id
argument_list|)
expr_stmt|;
comment|/* 	 * For napi, if work is not running, schedule it. Always schedule 	 * for casual (non-napi) packet handling. 	 */
if|if
condition|(
operator|(
name|napi
operator|==
literal|0
operator|)
operator|||
operator|(
name|napi
operator|&&
name|rx_ring
operator|->
name|enqueue_is_running
operator|==
literal|0
operator|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|rx_ring
operator|->
name|enqueue_tq
argument_list|,
operator|&
name|rx_ring
operator|->
name|enqueue_task
argument_list|)
expr_stmt|;
comment|/* Do not run bottom half */
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * al_eth_rx_checksum - indicate in mbuf if hw indicated a good cksum  * @adapter: structure containing adapter specific data  * @hal_pkt: HAL structure for the packet  * @mbuf: mbuf currently being received and modified  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|al_eth_rx_checksum
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|al_eth_pkt
modifier|*
name|hal_pkt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|)
block|{
comment|/* if IPv4 and error */
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|adapter
operator|->
name|netdev
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|&&
operator|(
name|hal_pkt
operator|->
name|l3_proto_idx
operator|==
name|AL_ETH_PROTO_ID_IPv4
operator|)
operator|&&
operator|(
name|hal_pkt
operator|->
name|flags
operator|&
name|AL_ETH_RX_FLAGS_L3_CSUM_ERR
operator|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"rx ipv4 header checksum error\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if IPv6 and error */
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|adapter
operator|->
name|netdev
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM_IPV6
operator|)
operator|&&
operator|(
name|hal_pkt
operator|->
name|l3_proto_idx
operator|==
name|AL_ETH_PROTO_ID_IPv6
operator|)
operator|&&
operator|(
name|hal_pkt
operator|->
name|flags
operator|&
name|AL_ETH_RX_FLAGS_L3_CSUM_ERR
operator|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"rx ipv6 header checksum error\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if TCP/UDP */
if|if
condition|(
name|likely
argument_list|(
operator|(
name|hal_pkt
operator|->
name|l4_proto_idx
operator|==
name|AL_ETH_PROTO_ID_TCP
operator|)
operator|||
operator|(
name|hal_pkt
operator|->
name|l4_proto_idx
operator|==
name|AL_ETH_PROTO_ID_UDP
operator|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|hal_pkt
operator|->
name|flags
operator|&
name|AL_ETH_RX_FLAGS_L4_CSUM_ERR
argument_list|)
condition|)
block|{
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"rx L4 checksum error\n"
argument_list|)
expr_stmt|;
comment|/* TCP/UDP checksum error */
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"rx checksum correct\n"
argument_list|)
expr_stmt|;
comment|/* IP Checksum Good */
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
expr_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|al_eth_rx_mbuf
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|al_eth_ring
modifier|*
name|rx_ring
parameter_list|,
name|struct
name|al_eth_pkt
modifier|*
name|hal_pkt
parameter_list|,
name|unsigned
name|int
name|descs
parameter_list|,
name|uint16_t
modifier|*
name|next_to_clean
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|al_eth_rx_buffer
modifier|*
name|rx_info
init|=
operator|&
name|rx_ring
operator|->
name|rx_buffer_info
index|[
operator|*
name|next_to_clean
index|]
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|len
operator|=
name|hal_pkt
operator|->
name|bufs
index|[
literal|0
index|]
operator|.
name|len
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"rx_info %p data %p\n"
argument_list|,
name|rx_info
argument_list|,
name|rx_info
operator|->
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_info
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|next_to_clean
operator|=
name|AL_ETH_RX_RING_IDX_NEXT
argument_list|(
name|rx_ring
argument_list|,
operator|*
name|next_to_clean
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|mbuf
operator|=
name|rx_info
operator|->
name|m
expr_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|mbuf
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|rx_ring
operator|->
name|netdev
expr_stmt|;
name|mbuf
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|adapter
operator|->
name|small_copy_len
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|smbuf
decl_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"rx small packet. len %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|AL_RX_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|smbuf
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|AL_RX_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|smbuf
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"smbuf is NULL\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|smbuf
operator|->
name|m_data
operator|=
name|smbuf
operator|->
name|m_data
operator|+
name|AL_IP_ALIGNMENT_OFFSET
expr_stmt|;
name|memcpy
argument_list|(
name|smbuf
operator|->
name|m_data
argument_list|,
name|mbuf
operator|->
name|m_data
operator|+
name|AL_IP_ALIGNMENT_OFFSET
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|smbuf
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|smbuf
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|rx_ring
operator|->
name|netdev
expr_stmt|;
comment|/* first desc of a non-ps chain */
name|smbuf
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|smbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|smbuf
operator|->
name|m_len
expr_stmt|;
operator|*
name|next_to_clean
operator|=
name|AL_ETH_RX_RING_IDX_NEXT
argument_list|(
name|rx_ring
argument_list|,
operator|*
name|next_to_clean
argument_list|)
expr_stmt|;
return|return
operator|(
name|smbuf
operator|)
return|;
block|}
name|mbuf
operator|->
name|m_data
operator|=
name|mbuf
operator|->
name|m_data
operator|+
name|AL_IP_ALIGNMENT_OFFSET
expr_stmt|;
comment|/* Unmap the buffer */
name|bus_dmamap_unload
argument_list|(
name|rx_ring
operator|->
name|dma_buf_tag
argument_list|,
name|rx_info
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|rx_info
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
operator|*
name|next_to_clean
operator|=
name|AL_ETH_RX_RING_IDX_NEXT
argument_list|(
name|rx_ring
argument_list|,
operator|*
name|next_to_clean
argument_list|)
expr_stmt|;
return|return
operator|(
name|mbuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_rx_recv_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|al_eth_ring
modifier|*
name|rx_ring
init|=
name|arg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|lro_entry
modifier|*
name|queued
decl_stmt|;
name|unsigned
name|int
name|qid
init|=
name|rx_ring
operator|->
name|ring_id
decl_stmt|;
name|struct
name|al_eth_pkt
modifier|*
name|hal_pkt
init|=
operator|&
name|rx_ring
operator|->
name|hal_pkt
decl_stmt|;
name|uint16_t
name|next_to_clean
init|=
name|rx_ring
operator|->
name|next_to_clean
decl_stmt|;
name|uint32_t
name|refill_required
decl_stmt|;
name|uint32_t
name|refill_actual
decl_stmt|;
name|uint32_t
name|do_if_input
decl_stmt|;
if|if
condition|(
name|napi
operator|!=
literal|0
condition|)
block|{
name|rx_ring
operator|->
name|enqueue_is_running
operator|=
literal|1
expr_stmt|;
name|al_data_memory_barrier
argument_list|()
expr_stmt|;
block|}
do|do
block|{
name|unsigned
name|int
name|descs
decl_stmt|;
name|descs
operator|=
name|al_eth_pkt_rx
argument_list|(
name|rx_ring
operator|->
name|dma_q
argument_list|,
name|hal_pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|descs
operator|==
literal|0
argument_list|)
condition|)
break|break;
name|device_printf_dbg
argument_list|(
name|rx_ring
operator|->
name|dev
argument_list|,
literal|"rx_poll: q %d got packet "
literal|"from hal. descs %d\n"
argument_list|,
name|qid
argument_list|,
name|descs
argument_list|)
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|rx_ring
operator|->
name|dev
argument_list|,
literal|"rx_poll: q %d flags %x. "
literal|"l3 proto %d l4 proto %d\n"
argument_list|,
name|qid
argument_list|,
name|hal_pkt
operator|->
name|flags
argument_list|,
name|hal_pkt
operator|->
name|l3_proto_idx
argument_list|,
name|hal_pkt
operator|->
name|l4_proto_idx
argument_list|)
expr_stmt|;
comment|/* ignore if detected dma or eth controller errors */
if|if
condition|(
operator|(
name|hal_pkt
operator|->
name|flags
operator|&
operator|(
name|AL_ETH_RX_ERROR
operator||
name|AL_UDMA_CDESC_ERROR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|rx_ring
operator|->
name|dev
argument_list|,
literal|"receive packet with error. "
literal|"flags = 0x%x\n"
argument_list|,
name|hal_pkt
operator|->
name|flags
argument_list|)
expr_stmt|;
name|next_to_clean
operator|=
name|AL_ETH_RX_RING_IDX_ADD
argument_list|(
name|rx_ring
argument_list|,
name|next_to_clean
argument_list|,
name|descs
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* allocate mbuf and fill it */
name|mbuf
operator|=
name|al_eth_rx_mbuf
argument_list|(
name|rx_ring
operator|->
name|adapter
argument_list|,
name|rx_ring
argument_list|,
name|hal_pkt
argument_list|,
name|descs
argument_list|,
operator|&
name|next_to_clean
argument_list|)
expr_stmt|;
comment|/* exit if we failed to retrieve a buffer */
if|if
condition|(
name|unlikely
argument_list|(
name|mbuf
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|next_to_clean
operator|=
name|AL_ETH_RX_RING_IDX_ADD
argument_list|(
name|rx_ring
argument_list|,
name|next_to_clean
argument_list|,
name|descs
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|__predict_true
argument_list|(
name|rx_ring
operator|->
name|netdev
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|||
name|rx_ring
operator|->
name|netdev
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM_IPV6
argument_list|)
condition|)
block|{
name|al_eth_rx_checksum
argument_list|(
name|rx_ring
operator|->
name|adapter
argument_list|,
name|hal_pkt
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|qid
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_OPAQUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * LRO is only for IP/TCP packets and TCP checksum of the packet 		 * should be computed by hardware. 		 */
name|do_if_input
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rx_ring
operator|->
name|lro_enabled
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_VALID
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|hal_pkt
operator|->
name|l4_proto_idx
operator|==
name|AL_ETH_PROTO_ID_TCP
condition|)
block|{
comment|/* 			 * Send to the stack if: 			 *  - LRO not enabled, or 			 *  - no LRO resources, or 			 *  - lro enqueue fails 			 */
if|if
condition|(
name|rx_ring
operator|->
name|lro
operator|.
name|lro_cnt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tcp_lro_rx
argument_list|(
operator|&
name|rx_ring
operator|->
name|lro
argument_list|,
name|mbuf
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|do_if_input
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_if_input
condition|)
call|(
modifier|*
name|rx_ring
operator|->
name|netdev
operator|->
name|if_input
call|)
argument_list|(
name|rx_ring
operator|->
name|netdev
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|rx_ring
operator|->
name|next_to_clean
operator|=
name|next_to_clean
expr_stmt|;
name|refill_required
operator|=
name|al_udma_available_get
argument_list|(
name|rx_ring
operator|->
name|dma_q
argument_list|)
expr_stmt|;
name|refill_actual
operator|=
name|al_eth_refill_rx_bufs
argument_list|(
name|rx_ring
operator|->
name|adapter
argument_list|,
name|qid
argument_list|,
name|refill_required
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|refill_actual
operator|<
name|refill_required
argument_list|)
condition|)
block|{
name|device_printf_dbg
argument_list|(
name|rx_ring
operator|->
name|dev
argument_list|,
literal|"%s: not filling rx queue %d\n"
argument_list|,
name|__func__
argument_list|,
name|qid
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|(
name|queued
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|rx_ring
operator|->
name|lro
operator|.
name|lro_active
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|queued
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|tcp_lro_flush
argument_list|(
operator|&
name|rx_ring
operator|->
name|lro
argument_list|,
name|queued
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|napi
operator|!=
literal|0
condition|)
block|{
name|rx_ring
operator|->
name|enqueue_is_running
operator|=
literal|0
expr_stmt|;
name|al_data_memory_barrier
argument_list|()
expr_stmt|;
block|}
comment|/* unmask irq */
name|al_eth_irq_config
argument_list|(
name|rx_ring
operator|->
name|unmask_reg_offset
argument_list|,
name|rx_ring
operator|->
name|unmask_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_start_xmit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|al_eth_ring
modifier|*
name|tx_ring
init|=
name|arg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
if|if
condition|(
name|napi
operator|!=
literal|0
condition|)
block|{
name|tx_ring
operator|->
name|enqueue_is_running
operator|=
literal|1
expr_stmt|;
name|al_data_memory_barrier
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|tx_ring
operator|->
name|br_mtx
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|drbr_dequeue
argument_list|(
name|NULL
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tx_ring
operator|->
name|br_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
break|break;
name|al_eth_xmit_mbuf
argument_list|(
name|tx_ring
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|napi
operator|!=
literal|0
condition|)
block|{
name|tx_ring
operator|->
name|enqueue_is_running
operator|=
literal|0
expr_stmt|;
name|al_data_memory_barrier
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|tx_ring
operator|->
name|br_mtx
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|drbr_dequeue
argument_list|(
name|NULL
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tx_ring
operator|->
name|br_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
break|break;
name|al_eth_xmit_mbuf
argument_list|(
name|tx_ring
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|al_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|al_eth_ring
modifier|*
name|tx_ring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Which queue to use */
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
name|i
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|adapter
operator|->
name|num_tx_queues
expr_stmt|;
else|else
name|i
operator|=
name|curcpu
operator|%
name|adapter
operator|->
name|num_tx_queues
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
condition|)
block|{
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|tx_ring
operator|=
operator|&
name|adapter
operator|->
name|tx_ring
index|[
name|i
index|]
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"dgb start() - assuming link is active, "
literal|"sending packet to queue %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * For napi, if work is not running, schedule it. Always schedule 	 * for casual (non-napi) packet handling. 	 */
if|if
condition|(
operator|(
name|napi
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|napi
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|tx_ring
operator|->
name|enqueue_is_running
operator|==
literal|0
operator|)
operator|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|tx_ring
operator|->
name|enqueue_tq
argument_list|,
operator|&
name|tx_ring
operator|->
name|enqueue_task
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
comment|/* unused */
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|al_eth_flow_ctrl_init
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|uint8_t
name|default_flow_ctrl
decl_stmt|;
name|default_flow_ctrl
operator|=
name|AL_ETH_FLOW_CTRL_TX_PAUSE
expr_stmt|;
name|default_flow_ctrl
operator||=
name|AL_ETH_FLOW_CTRL_RX_PAUSE
expr_stmt|;
name|adapter
operator|->
name|link_config
operator|.
name|flow_ctrl_supported
operator|=
name|default_flow_ctrl
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_flow_ctrl_config
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|al_eth_flow_control_params
modifier|*
name|flow_ctrl_params
decl_stmt|;
name|uint8_t
name|active
init|=
name|adapter
operator|->
name|link_config
operator|.
name|flow_ctrl_active
decl_stmt|;
name|int
name|i
decl_stmt|;
name|flow_ctrl_params
operator|=
operator|&
name|adapter
operator|->
name|flow_ctrl_params
expr_stmt|;
name|flow_ctrl_params
operator|->
name|type
operator|=
name|AL_ETH_FLOW_CONTROL_TYPE_LINK_PAUSE
expr_stmt|;
name|flow_ctrl_params
operator|->
name|obay_enable
operator|=
operator|(
operator|(
name|active
operator|&
name|AL_ETH_FLOW_CTRL_RX_PAUSE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|flow_ctrl_params
operator|->
name|gen_enable
operator|=
operator|(
operator|(
name|active
operator|&
name|AL_ETH_FLOW_CTRL_TX_PAUSE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|flow_ctrl_params
operator|->
name|rx_fifo_th_high
operator|=
name|AL_ETH_FLOW_CTRL_RX_FIFO_TH_HIGH
expr_stmt|;
name|flow_ctrl_params
operator|->
name|rx_fifo_th_low
operator|=
name|AL_ETH_FLOW_CTRL_RX_FIFO_TH_LOW
expr_stmt|;
name|flow_ctrl_params
operator|->
name|quanta
operator|=
name|AL_ETH_FLOW_CTRL_QUANTA
expr_stmt|;
name|flow_ctrl_params
operator|->
name|quanta_th
operator|=
name|AL_ETH_FLOW_CTRL_QUANTA_TH
expr_stmt|;
comment|/* map priority to queue index, queue id = priority/2 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AL_ETH_FWD_PRIO_TABLE_NUM
condition|;
name|i
operator|++
control|)
name|flow_ctrl_params
operator|->
name|prio_q_map
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|i
operator|>>
literal|1
operator|)
expr_stmt|;
name|al_eth_flow_control_config
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|flow_ctrl_params
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_flow_ctrl_enable
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
comment|/* 	 * change the active configuration to the default / force by ethtool 	 * and call to configure 	 */
name|adapter
operator|->
name|link_config
operator|.
name|flow_ctrl_active
operator|=
name|adapter
operator|->
name|link_config
operator|.
name|flow_ctrl_supported
expr_stmt|;
name|al_eth_flow_ctrl_config
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_flow_ctrl_disable
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|adapter
operator|->
name|link_config
operator|.
name|flow_ctrl_active
operator|=
literal|0
expr_stmt|;
name|al_eth_flow_ctrl_config
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_hw_init
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|al_eth_hw_init_adapter
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|al_eth_mac_config
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|adapter
operator|->
name|mac_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s failed to configure mac!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|adapter
operator|->
name|mac_mode
operator|==
name|AL_ETH_MAC_MODE_SGMII
operator|)
operator|||
operator|(
name|adapter
operator|->
name|mac_mode
operator|==
name|AL_ETH_MAC_MODE_RGMII
operator|&&
name|adapter
operator|->
name|phy_exist
operator|==
name|FALSE
operator|)
condition|)
block|{
name|rc
operator|=
name|al_eth_mac_link_config
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|adapter
operator|->
name|link_config
operator|.
name|force_1000_base_x
argument_list|,
name|adapter
operator|->
name|link_config
operator|.
name|autoneg
argument_list|,
name|adapter
operator|->
name|link_config
operator|.
name|active_speed
argument_list|,
name|adapter
operator|->
name|link_config
operator|.
name|active_duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s failed to configure link parameters!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
name|rc
operator|=
name|al_eth_mdio_config
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|AL_ETH_MDIO_TYPE_CLAUSE_22
argument_list|,
name|TRUE
comment|/* shared_mdio_if */
argument_list|,
name|adapter
operator|->
name|ref_clk_freq
argument_list|,
name|adapter
operator|->
name|mdio_freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s failed at mdio config!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|al_eth_flow_ctrl_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_hw_stop
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|al_eth_mac_stop
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|)
expr_stmt|;
comment|/* 	 * wait till pending rx packets written and UDMA becomes idle, 	 * the MAC has ~10KB fifo, 10us should be enought time for the 	 * UDMA to write to the memory 	 */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|al_eth_adapter_stop
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|flags
operator||=
name|AL_ETH_FLAG_RESET_REQUESTED
expr_stmt|;
comment|/* disable flow ctrl to avoid pause packets*/
name|al_eth_flow_ctrl_disable
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * al_eth_intr_intx_all - Legacy Interrupt Handler for all interrupts  * @irq: interrupt number  * @data: pointer to a network interface device structure  */
end_comment

begin_function
specifier|static
name|int
name|al_eth_intr_intx_all
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|data
decl_stmt|;
name|struct
name|unit_regs
name|__iomem
modifier|*
name|regs_base
init|=
operator|(
expr|struct
name|unit_regs
name|__iomem
operator|*
operator|)
name|adapter
operator|->
name|udma_base
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|reg
operator|=
name|al_udma_iofic_read_cause
argument_list|(
name|regs_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_A
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|reg
argument_list|)
condition|)
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s group A cause %x\n"
argument_list|,
name|__func__
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|reg
operator|&
name|AL_INT_GROUP_A_GROUP_D_SUM
argument_list|)
condition|)
block|{
name|struct
name|al_iofic_grp_ctrl
name|__iomem
modifier|*
name|sec_ints_base
decl_stmt|;
name|uint32_t
name|cause_d
init|=
name|al_udma_iofic_read_cause
argument_list|(
name|regs_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_D
argument_list|)
decl_stmt|;
name|sec_ints_base
operator|=
operator|&
name|regs_base
operator|->
name|gen
operator|.
name|interrupt_regs
operator|.
name|secondary_iofic_ctrl
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|cause_d
operator|!=
literal|0
condition|)
block|{
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"got interrupt from group D. cause %x\n"
argument_list|,
name|cause_d
argument_list|)
expr_stmt|;
name|cause_d
operator|=
name|al_iofic_read_cause
argument_list|(
name|sec_ints_base
argument_list|,
name|AL_INT_GROUP_A
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"secondary A cause %x\n"
argument_list|,
name|cause_d
argument_list|)
expr_stmt|;
name|cause_d
operator|=
name|al_iofic_read_cause
argument_list|(
name|sec_ints_base
argument_list|,
name|AL_INT_GROUP_B
argument_list|)
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"secondary B cause %x\n"
argument_list|,
name|cause_d
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|reg
operator|&
name|AL_INT_GROUP_A_GROUP_B_SUM
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|cause_b
init|=
name|al_udma_iofic_read_cause
argument_list|(
name|regs_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_B
argument_list|)
decl_stmt|;
name|int
name|qid
decl_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"secondary B cause %x\n"
argument_list|,
name|cause_b
argument_list|)
expr_stmt|;
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|qid
operator|++
control|)
block|{
if|if
condition|(
name|cause_b
operator|&
operator|(
literal|1
operator|<<
name|qid
operator|)
condition|)
block|{
comment|/* mask */
name|al_udma_iofic_mask
argument_list|(
operator|(
expr|struct
name|unit_regs
name|__iomem
operator|*
operator|)
name|adapter
operator|->
name|udma_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_B
argument_list|,
literal|1
operator|<<
name|qid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|reg
operator|&
name|AL_INT_GROUP_A_GROUP_C_SUM
operator|)
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|cause_c
init|=
name|al_udma_iofic_read_cause
argument_list|(
name|regs_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_C
argument_list|)
decl_stmt|;
name|int
name|qid
decl_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"secondary C cause %x\n"
argument_list|,
name|cause_c
argument_list|)
expr_stmt|;
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|adapter
operator|->
name|num_tx_queues
condition|;
name|qid
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cause_c
operator|&
operator|(
literal|1
operator|<<
name|qid
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|al_udma_iofic_mask
argument_list|(
operator|(
expr|struct
name|unit_regs
name|__iomem
operator|*
operator|)
name|adapter
operator|->
name|udma_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_C
argument_list|,
literal|1
operator|<<
name|qid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|al_eth_tx_cmlp_irq_filter
argument_list|(
name|adapter
operator|->
name|tx_ring
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_intr_msix_all
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|data
decl_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_intr_msix_mgmt
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|data
decl_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_enable_msix
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|msix_vecs
decl_stmt|,
name|rc
decl_stmt|,
name|count
decl_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|msix_vecs
operator|=
literal|1
operator|+
name|adapter
operator|->
name|num_rx_queues
operator|+
name|adapter
operator|->
name|num_tx_queues
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Try to enable MSIX, vector numbers = %d\n"
argument_list|,
name|msix_vecs
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_entries
operator|=
name|malloc
argument_list|(
name|msix_vecs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|adapter
operator|->
name|msix_entries
argument_list|)
argument_list|,
name|M_IFAL
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix_entries
operator|==
name|NULL
condition|)
block|{
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"failed to allocate"
literal|" msix_entries %d\n"
argument_list|,
name|msix_vecs
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* management vector (GROUP_A) @2*/
name|adapter
operator|->
name|msix_entries
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|entry
operator|=
literal|2
expr_stmt|;
name|adapter
operator|->
name|msix_entries
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|vector
operator|=
literal|0
expr_stmt|;
comment|/* rx queues start @3 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
control|)
block|{
name|int
name|irq_idx
init|=
name|AL_ETH_RXQ_IRQ_IDX
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|adapter
operator|->
name|msix_entries
index|[
name|irq_idx
index|]
operator|.
name|entry
operator|=
literal|3
operator|+
name|i
expr_stmt|;
name|adapter
operator|->
name|msix_entries
index|[
name|irq_idx
index|]
operator|.
name|vector
operator|=
literal|0
expr_stmt|;
block|}
comment|/* tx queues start @7 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_queues
condition|;
name|i
operator|++
control|)
block|{
name|int
name|irq_idx
init|=
name|AL_ETH_TXQ_IRQ_IDX
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|adapter
operator|->
name|msix_entries
index|[
name|irq_idx
index|]
operator|.
name|entry
operator|=
literal|3
operator|+
name|AL_ETH_MAX_HW_QUEUES
operator|+
name|i
expr_stmt|;
name|adapter
operator|->
name|msix_entries
index|[
name|irq_idx
index|]
operator|.
name|vector
operator|=
literal|0
expr_stmt|;
block|}
name|count
operator|=
name|msix_vecs
operator|+
literal|2
expr_stmt|;
comment|/* entries start from 2 */
name|rc
operator|=
name|pci_alloc_msix
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"failed to allocate MSIX "
literal|"vectors %d\n"
argument_list|,
name|msix_vecs
operator|+
literal|2
argument_list|)
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"ret = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|msix_entries_exit
goto|;
block|}
if|if
condition|(
name|count
operator|!=
name|msix_vecs
operator|+
literal|2
condition|)
block|{
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"failed to allocate all MSIX "
literal|"vectors %d, allocated %d\n"
argument_list|,
name|msix_vecs
operator|+
literal|2
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|msix_entries_exit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix_vecs
condition|;
name|i
operator|++
control|)
name|adapter
operator|->
name|msix_entries
index|[
name|i
index|]
operator|.
name|vector
operator|=
literal|2
operator|+
literal|1
operator|+
name|i
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"successfully enabled MSIX,"
literal|" vectors %d\n"
argument_list|,
name|msix_vecs
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_vecs
operator|=
name|msix_vecs
expr_stmt|;
name|adapter
operator|->
name|flags
operator||=
name|AL_ETH_FLAG_MSIX_ENABLED
expr_stmt|;
goto|goto
name|exit
goto|;
name|msix_entries_exit
label|:
name|adapter
operator|->
name|msix_vecs
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|msix_entries
argument_list|,
name|M_IFAL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_entries
operator|=
name|NULL
expr_stmt|;
name|exit
label|:
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_setup_int_mode
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|rc
operator|=
name|al_eth_enable_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Failed to enable MSIX mode.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|adapter
operator|->
name|irq_vecs
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|adapter
operator|->
name|msix_vecs
argument_list|)
expr_stmt|;
comment|/* single INTX mode */
if|if
condition|(
name|adapter
operator|->
name|msix_vecs
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|adapter
operator|->
name|irq_tbl
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|name
argument_list|,
name|AL_ETH_IRQNAME_SIZE
argument_list|,
literal|"al-eth-intx-all@pci:%s"
argument_list|,
name|device_get_name
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|handler
operator|=
name|al_eth_intr_intx_all
expr_stmt|;
comment|/* IRQ vector will be resolved from device resources */
name|adapter
operator|->
name|irq_tbl
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|vector
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|data
operator|=
name|adapter
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s and vector %d \n"
argument_list|,
name|__func__
argument_list|,
name|adapter
operator|->
name|irq_tbl
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* single MSI-X mode */
if|if
condition|(
name|adapter
operator|->
name|msix_vecs
operator|==
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|adapter
operator|->
name|irq_tbl
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|name
argument_list|,
name|AL_ETH_IRQNAME_SIZE
argument_list|,
literal|"al-eth-msix-all@pci:%s"
argument_list|,
name|device_get_name
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|handler
operator|=
name|al_eth_intr_msix_all
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|vector
operator|=
name|adapter
operator|->
name|msix_entries
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|vector
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|data
operator|=
name|adapter
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* MSI-X per queue */
name|snprintf
argument_list|(
name|adapter
operator|->
name|irq_tbl
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|name
argument_list|,
name|AL_ETH_IRQNAME_SIZE
argument_list|,
literal|"al-eth-msix-mgmt@pci:%s"
argument_list|,
name|device_get_name
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|handler
operator|=
name|al_eth_intr_msix_mgmt
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|data
operator|=
name|adapter
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|vector
operator|=
name|adapter
operator|->
name|msix_entries
index|[
name|AL_ETH_MGMT_IRQ_IDX
index|]
operator|.
name|vector
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
control|)
block|{
name|int
name|irq_idx
init|=
name|AL_ETH_RXQ_IRQ_IDX
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|adapter
operator|->
name|irq_tbl
index|[
name|irq_idx
index|]
operator|.
name|name
argument_list|,
name|AL_ETH_IRQNAME_SIZE
argument_list|,
literal|"al-eth-rx-comp-%d@pci:%s"
argument_list|,
name|i
argument_list|,
name|device_get_name
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|irq_idx
index|]
operator|.
name|handler
operator|=
name|al_eth_rx_recv_irq_filter
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|irq_idx
index|]
operator|.
name|data
operator|=
operator|&
name|adapter
operator|->
name|rx_ring
index|[
name|i
index|]
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|irq_idx
index|]
operator|.
name|vector
operator|=
name|adapter
operator|->
name|msix_entries
index|[
name|irq_idx
index|]
operator|.
name|vector
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_queues
condition|;
name|i
operator|++
control|)
block|{
name|int
name|irq_idx
init|=
name|AL_ETH_TXQ_IRQ_IDX
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|adapter
operator|->
name|irq_tbl
index|[
name|irq_idx
index|]
operator|.
name|name
argument_list|,
name|AL_ETH_IRQNAME_SIZE
argument_list|,
literal|"al-eth-tx-comp-%d@pci:%s"
argument_list|,
name|i
argument_list|,
name|device_get_name
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|irq_idx
index|]
operator|.
name|handler
operator|=
name|al_eth_tx_cmlp_irq_filter
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|irq_idx
index|]
operator|.
name|data
operator|=
operator|&
name|adapter
operator|->
name|tx_ring
index|[
name|i
index|]
expr_stmt|;
name|adapter
operator|->
name|irq_tbl
index|[
name|irq_idx
index|]
operator|.
name|vector
operator|=
name|adapter
operator|->
name|msix_entries
index|[
name|irq_idx
index|]
operator|.
name|vector
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__al_eth_free_irq
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|al_eth_irq
modifier|*
name|irq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|irq_vecs
condition|;
name|i
operator|++
control|)
block|{
name|irq
operator|=
operator|&
name|adapter
operator|->
name|irq_tbl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|requested
operator|!=
literal|0
condition|)
block|{
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"tear down irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bus_teardown_intr
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|irq
operator|->
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"failed to tear "
literal|"down irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
block|}
name|irq
operator|->
name|requested
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_free_irq
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|al_eth_irq
modifier|*
name|irq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_RFS_ACCEL
if|if
condition|(
name|adapter
operator|->
name|msix_vecs
operator|>=
literal|1
condition|)
block|{
name|free_irq_cpu_rmap
argument_list|(
name|adapter
operator|->
name|netdev
operator|->
name|rx_cpu_rmap
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|netdev
operator|->
name|rx_cpu_rmap
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|__al_eth_free_irq
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|irq_vecs
condition|;
name|i
operator|++
control|)
block|{
name|irq
operator|=
operator|&
name|adapter
operator|->
name|irq_tbl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|res
operator|==
name|NULL
condition|)
continue|continue;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"release resource irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bus_release_resource
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|vector
argument_list|,
name|irq
operator|->
name|res
argument_list|)
expr_stmt|;
name|irq
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"dev has no parent while "
literal|"releasing res for irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
block|}
name|pci_release_msi
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|flags
operator|&=
operator|~
name|AL_ETH_FLAG_MSIX_ENABLED
expr_stmt|;
name|adapter
operator|->
name|msix_vecs
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|msix_entries
argument_list|,
name|M_IFAL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_entries
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_request_irq
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|al_eth_irq
modifier|*
name|irq
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|flags
operator|&
name|AL_ETH_FLAG_MSIX_ENABLED
operator|)
operator|!=
literal|0
condition|)
name|flags
operator|=
name|RF_ACTIVE
expr_stmt|;
else|else
name|flags
operator|=
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|irq_vecs
condition|;
name|i
operator|++
control|)
block|{
name|irq
operator|=
operator|&
name|adapter
operator|->
name|irq_tbl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|requested
operator|!=
literal|0
condition|)
continue|continue;
name|irq
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|irq
operator|->
name|vector
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"could not allocate "
literal|"irq vector=%d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|exit_res
goto|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|irq
operator|->
name|handler
argument_list|,
name|NULL
argument_list|,
name|irq
operator|->
name|data
argument_list|,
operator|&
name|irq
operator|->
name|cookie
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"failed to register "
literal|"interrupt handler for irq %ju: %d\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rman_get_start
argument_list|(
name|irq
operator|->
name|res
argument_list|)
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|exit_intr
goto|;
block|}
name|irq
operator|->
name|requested
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|exit
goto|;
name|exit_intr
label|:
name|v
operator|=
name|i
operator|-
literal|1
expr_stmt|;
comment|/* -1 because we omit the operation that failed */
while|while
condition|(
name|v
operator|--
operator|>=
literal|0
condition|)
block|{
name|int
name|bti
decl_stmt|;
name|irq
operator|=
operator|&
name|adapter
operator|->
name|irq_tbl
index|[
name|v
index|]
expr_stmt|;
name|bti
operator|=
name|bus_teardown_intr
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|res
argument_list|,
name|irq
operator|->
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|bti
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"failed to tear "
literal|"down irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
block|}
name|irq
operator|->
name|requested
operator|=
literal|0
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"exit_intr: releasing irq %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
block|}
name|exit_res
label|:
name|v
operator|=
name|i
operator|-
literal|1
expr_stmt|;
comment|/* -1 because we omit the operation that failed */
while|while
condition|(
name|v
operator|--
operator|>=
literal|0
condition|)
block|{
name|int
name|brr
decl_stmt|;
name|irq
operator|=
operator|&
name|adapter
operator|->
name|irq_tbl
index|[
name|v
index|]
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"exit_res: releasing resource"
literal|" for irq %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
name|brr
operator|=
name|bus_release_resource
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|vector
argument_list|,
name|irq
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|brr
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"dev has no parent while "
literal|"releasing res for irq: %d\n"
argument_list|,
name|irq
operator|->
name|vector
argument_list|)
expr_stmt|;
name|irq
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
block|}
name|exit
label|:
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * al_eth_setup_tx_resources - allocate Tx resources (Descriptors)  * @adapter: network interface device structure  * @qid: queue index  *  * Return 0 on success, negative on failure  **/
end_comment

begin_function
specifier|static
name|int
name|al_eth_setup_tx_resources
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|struct
name|al_eth_ring
modifier|*
name|tx_ring
init|=
operator|&
name|adapter
operator|->
name|tx_ring
index|[
name|qid
index|]
decl_stmt|;
name|struct
name|device
modifier|*
name|dev
init|=
name|tx_ring
operator|->
name|dev
decl_stmt|;
name|struct
name|al_udma_q_params
modifier|*
name|q_params
init|=
operator|&
name|tx_ring
operator|->
name|q_params
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|up
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|al_eth_tx_buffer
argument_list|)
operator|*
name|tx_ring
operator|->
name|sw_count
expr_stmt|;
name|tx_ring
operator|->
name|tx_buffer_info
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_IFAL
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_ring
operator|->
name|tx_buffer_info
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|tx_ring
operator|->
name|descs_size
operator|=
name|tx_ring
operator|->
name|hw_count
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|al_udma_desc
argument_list|)
expr_stmt|;
name|q_params
operator|->
name|size
operator|=
name|tx_ring
operator|->
name|hw_count
expr_stmt|;
name|ret
operator|=
name|al_dma_alloc_coherent
argument_list|(
name|dev
argument_list|,
operator|&
name|q_params
operator|->
name|desc_phy_base_tag
argument_list|,
operator|(
name|bus_dmamap_t
operator|*
operator|)
operator|&
name|q_params
operator|->
name|desc_phy_base_map
argument_list|,
operator|(
name|bus_addr_t
operator|*
operator|)
operator|&
name|q_params
operator|->
name|desc_phy_base
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|q_params
operator|->
name|desc_base
argument_list|,
name|tx_ring
operator|->
name|descs_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to al_dma_alloc_coherent,"
literal|" ret = %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|q_params
operator|->
name|desc_base
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|device_printf_dbg
argument_list|(
name|dev
argument_list|,
literal|"Initializing ring queues %d\n"
argument_list|,
name|qid
argument_list|)
expr_stmt|;
comment|/* Allocate Ring Queue */
name|mtx_init
argument_list|(
operator|&
name|tx_ring
operator|->
name|br_mtx
argument_list|,
literal|"AlRingMtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|tx_ring
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
name|AL_BR_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|tx_ring
operator|->
name|br_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_ring
operator|->
name|br
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up buf ring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Allocate taskqueues */
name|TASK_INIT
argument_list|(
operator|&
name|tx_ring
operator|->
name|enqueue_task
argument_list|,
literal|0
argument_list|,
name|al_eth_start_xmit
argument_list|,
name|tx_ring
argument_list|)
expr_stmt|;
name|tx_ring
operator|->
name|enqueue_tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"al_tx_enque"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|tx_ring
operator|->
name|enqueue_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|tx_ring
operator|->
name|enqueue_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s txeq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|tx_ring
operator|->
name|cmpl_task
argument_list|,
literal|0
argument_list|,
name|al_eth_tx_cmpl_work
argument_list|,
name|tx_ring
argument_list|)
expr_stmt|;
name|tx_ring
operator|->
name|cmpl_tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"al_tx_cmpl"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|tx_ring
operator|->
name|cmpl_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|tx_ring
operator|->
name|cmpl_tq
argument_list|,
literal|1
argument_list|,
name|PI_REALTIME
argument_list|,
literal|"%s txcq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup DMA descriptor areas. */
name|ret
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|AL_TSO_SIZE
argument_list|,
comment|/* maxsize */
name|AL_ETH_PKT_MAX_BUFS
argument_list|,
comment|/* nsegments */
name|PAGE_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|tx_ring
operator|->
name|dma_buf_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate dma_buf_tag, ret = %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
for|for
control|(
name|size
operator|=
literal|0
init|;
name|size
operator|<
name|tx_ring
operator|->
name|sw_count
condition|;
name|size
operator|++
control|)
block|{
name|ret
operator|=
name|bus_dmamap_create
argument_list|(
name|tx_ring
operator|->
name|dma_buf_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|size
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to map DMA TX "
literal|"buffer memory [iter=%d]\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
comment|/* completion queue not used for tx */
name|q_params
operator|->
name|cdesc_base
operator|=
name|NULL
expr_stmt|;
comment|/* size in bytes of the udma completion ring descriptor */
name|q_params
operator|->
name|cdesc_size
operator|=
literal|8
expr_stmt|;
name|tx_ring
operator|->
name|next_to_use
operator|=
literal|0
expr_stmt|;
name|tx_ring
operator|->
name|next_to_clean
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * al_eth_free_tx_resources - Free Tx Resources per Queue  * @adapter: network interface device structure  * @qid: queue index  *  * Free all transmit software resources  */
end_comment

begin_function
specifier|static
name|void
name|al_eth_free_tx_resources
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|struct
name|al_eth_ring
modifier|*
name|tx_ring
init|=
operator|&
name|adapter
operator|->
name|tx_ring
index|[
name|qid
index|]
decl_stmt|;
name|struct
name|al_udma_q_params
modifier|*
name|q_params
init|=
operator|&
name|tx_ring
operator|->
name|q_params
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* At this point interrupts' handlers must be deactivated */
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|tx_ring
operator|->
name|cmpl_tq
argument_list|,
operator|&
name|tx_ring
operator|->
name|cmpl_task
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain
argument_list|(
name|tx_ring
operator|->
name|cmpl_tq
argument_list|,
operator|&
name|tx_ring
operator|->
name|cmpl_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|tx_ring
operator|->
name|cmpl_tq
argument_list|)
expr_stmt|;
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|tx_ring
operator|->
name|enqueue_tq
argument_list|,
operator|&
name|tx_ring
operator|->
name|enqueue_task
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|tx_ring
operator|->
name|enqueue_tq
argument_list|,
operator|&
name|tx_ring
operator|->
name|enqueue_task
argument_list|)
expr_stmt|;
block|}
name|taskqueue_free
argument_list|(
name|tx_ring
operator|->
name|enqueue_tq
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_ring
operator|->
name|br
operator|!=
name|NULL
condition|)
block|{
name|drbr_flush
argument_list|(
name|adapter
operator|->
name|netdev
argument_list|,
name|tx_ring
operator|->
name|br
argument_list|)
expr_stmt|;
name|buf_ring_free
argument_list|(
name|tx_ring
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|size
operator|=
literal|0
init|;
name|size
operator|<
name|tx_ring
operator|->
name|sw_count
condition|;
name|size
operator|++
control|)
block|{
name|m_freem
argument_list|(
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|size
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|size
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|tx_ring
operator|->
name|dma_buf_tag
argument_list|,
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|size
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|tx_ring
operator|->
name|dma_buf_tag
argument_list|,
name|tx_ring
operator|->
name|tx_buffer_info
index|[
name|size
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|tx_ring
operator|->
name|dma_buf_tag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tx_ring
operator|->
name|tx_buffer_info
argument_list|,
name|M_IFAL
argument_list|)
expr_stmt|;
name|tx_ring
operator|->
name|tx_buffer_info
operator|=
name|NULL
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|tx_ring
operator|->
name|br_mtx
argument_list|)
expr_stmt|;
comment|/* if not set, then don't free */
if|if
condition|(
name|q_params
operator|->
name|desc_base
operator|==
name|NULL
condition|)
return|return;
name|al_dma_free_coherent
argument_list|(
name|q_params
operator|->
name|desc_phy_base_tag
argument_list|,
name|q_params
operator|->
name|desc_phy_base_map
argument_list|,
name|q_params
operator|->
name|desc_base
argument_list|)
expr_stmt|;
name|q_params
operator|->
name|desc_base
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * al_eth_free_all_tx_resources - Free Tx Resources for All Queues  * @adapter: board private structure  *  * Free all transmit software resources  */
end_comment

begin_function
specifier|static
name|void
name|al_eth_free_all_tx_resources
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_queues
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|adapter
operator|->
name|tx_ring
index|[
name|i
index|]
operator|.
name|q_params
operator|.
name|desc_base
condition|)
name|al_eth_free_tx_resources
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * al_eth_setup_rx_resources - allocate Rx resources (Descriptors)  * @adapter: network interface device structure  * @qid: queue index  *  * Returns 0 on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|al_eth_setup_rx_resources
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|)
block|{
name|struct
name|al_eth_ring
modifier|*
name|rx_ring
init|=
operator|&
name|adapter
operator|->
name|rx_ring
index|[
name|qid
index|]
decl_stmt|;
name|struct
name|device
modifier|*
name|dev
init|=
name|rx_ring
operator|->
name|dev
decl_stmt|;
name|struct
name|al_udma_q_params
modifier|*
name|q_params
init|=
operator|&
name|rx_ring
operator|->
name|q_params
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|al_eth_rx_buffer
argument_list|)
operator|*
name|rx_ring
operator|->
name|sw_count
expr_stmt|;
comment|/* alloc extra element so in rx path we can always prefetch rx_info + 1 */
name|size
operator|+=
literal|1
expr_stmt|;
name|rx_ring
operator|->
name|rx_buffer_info
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_IFAL
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_ring
operator|->
name|rx_buffer_info
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rx_ring
operator|->
name|descs_size
operator|=
name|rx_ring
operator|->
name|hw_count
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|al_udma_desc
argument_list|)
expr_stmt|;
name|q_params
operator|->
name|size
operator|=
name|rx_ring
operator|->
name|hw_count
expr_stmt|;
name|ret
operator|=
name|al_dma_alloc_coherent
argument_list|(
name|dev
argument_list|,
operator|&
name|q_params
operator|->
name|desc_phy_base_tag
argument_list|,
operator|&
name|q_params
operator|->
name|desc_phy_base_map
argument_list|,
operator|(
name|bus_addr_t
operator|*
operator|)
operator|&
name|q_params
operator|->
name|desc_phy_base
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|q_params
operator|->
name|desc_base
argument_list|,
name|rx_ring
operator|->
name|descs_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q_params
operator|->
name|desc_base
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ret
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* size in bytes of the udma completion ring descriptor */
name|q_params
operator|->
name|cdesc_size
operator|=
literal|16
expr_stmt|;
name|rx_ring
operator|->
name|cdescs_size
operator|=
name|rx_ring
operator|->
name|hw_count
operator|*
name|q_params
operator|->
name|cdesc_size
expr_stmt|;
name|ret
operator|=
name|al_dma_alloc_coherent
argument_list|(
name|dev
argument_list|,
operator|&
name|q_params
operator|->
name|cdesc_phy_base_tag
argument_list|,
operator|&
name|q_params
operator|->
name|cdesc_phy_base_map
argument_list|,
operator|(
name|bus_addr_t
operator|*
operator|)
operator|&
name|q_params
operator|->
name|cdesc_phy_base
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|q_params
operator|->
name|cdesc_base
argument_list|,
name|rx_ring
operator|->
name|cdescs_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q_params
operator|->
name|cdesc_base
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ret
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Allocate taskqueues */
name|TASK_INIT
argument_list|(
operator|&
name|rx_ring
operator|->
name|enqueue_task
argument_list|,
literal|0
argument_list|,
name|al_eth_rx_recv_work
argument_list|,
name|rx_ring
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|enqueue_tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"al_rx_enque"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|rx_ring
operator|->
name|enqueue_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|rx_ring
operator|->
name|enqueue_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s rxeq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup DMA descriptor areas. */
name|ret
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|AL_TSO_SIZE
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|AL_TSO_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|rx_ring
operator|->
name|dma_buf_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RX dma_buf_tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
for|for
control|(
name|size
operator|=
literal|0
init|;
name|size
operator|<
name|rx_ring
operator|->
name|sw_count
condition|;
name|size
operator|++
control|)
block|{
name|ret
operator|=
name|bus_dmamap_create
argument_list|(
name|rx_ring
operator|->
name|dma_buf_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|size
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to map DMA RX buffer memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
comment|/* Zero out the descriptor ring */
name|memset
argument_list|(
name|q_params
operator|->
name|cdesc_base
argument_list|,
literal|0
argument_list|,
name|rx_ring
operator|->
name|cdescs_size
argument_list|)
expr_stmt|;
comment|/* Create LRO for the ring */
if|if
condition|(
operator|(
name|adapter
operator|->
name|netdev
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|err
init|=
name|tcp_lro_init
argument_list|(
operator|&
name|rx_ring
operator|->
name|lro
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"LRO[%d] Initialization failed!\n"
argument_list|,
name|qid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"RX Soft LRO[%d] Initialized\n"
argument_list|,
name|qid
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|lro_enabled
operator|=
name|TRUE
expr_stmt|;
name|rx_ring
operator|->
name|lro
operator|.
name|ifp
operator|=
name|adapter
operator|->
name|netdev
expr_stmt|;
block|}
block|}
name|rx_ring
operator|->
name|next_to_clean
operator|=
literal|0
expr_stmt|;
name|rx_ring
operator|->
name|next_to_use
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * al_eth_free_rx_resources - Free Rx Resources  * @adapter: network interface device structure  * @qid: queue index  *  * Free all receive software resources  */
end_comment

begin_function
specifier|static
name|void
name|al_eth_free_rx_resources
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|)
block|{
name|struct
name|al_eth_ring
modifier|*
name|rx_ring
init|=
operator|&
name|adapter
operator|->
name|rx_ring
index|[
name|qid
index|]
decl_stmt|;
name|struct
name|al_udma_q_params
modifier|*
name|q_params
init|=
operator|&
name|rx_ring
operator|->
name|q_params
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* At this point interrupts' handlers must be deactivated */
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|rx_ring
operator|->
name|enqueue_tq
argument_list|,
operator|&
name|rx_ring
operator|->
name|enqueue_task
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|rx_ring
operator|->
name|enqueue_tq
argument_list|,
operator|&
name|rx_ring
operator|->
name|enqueue_task
argument_list|)
expr_stmt|;
block|}
name|taskqueue_free
argument_list|(
name|rx_ring
operator|->
name|enqueue_tq
argument_list|)
expr_stmt|;
for|for
control|(
name|size
operator|=
literal|0
init|;
name|size
operator|<
name|rx_ring
operator|->
name|sw_count
condition|;
name|size
operator|++
control|)
block|{
name|m_freem
argument_list|(
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|size
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|size
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rx_ring
operator|->
name|dma_buf_tag
argument_list|,
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|size
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|rx_ring
operator|->
name|dma_buf_tag
argument_list|,
name|rx_ring
operator|->
name|rx_buffer_info
index|[
name|size
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|rx_ring
operator|->
name|dma_buf_tag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rx_ring
operator|->
name|rx_buffer_info
argument_list|,
name|M_IFAL
argument_list|)
expr_stmt|;
name|rx_ring
operator|->
name|rx_buffer_info
operator|=
name|NULL
expr_stmt|;
comment|/* if not set, then don't free */
if|if
condition|(
name|q_params
operator|->
name|desc_base
operator|==
name|NULL
condition|)
return|return;
name|al_dma_free_coherent
argument_list|(
name|q_params
operator|->
name|desc_phy_base_tag
argument_list|,
name|q_params
operator|->
name|desc_phy_base_map
argument_list|,
name|q_params
operator|->
name|desc_base
argument_list|)
expr_stmt|;
name|q_params
operator|->
name|desc_base
operator|=
name|NULL
expr_stmt|;
comment|/* if not set, then don't free */
if|if
condition|(
name|q_params
operator|->
name|cdesc_base
operator|==
name|NULL
condition|)
return|return;
name|al_dma_free_coherent
argument_list|(
name|q_params
operator|->
name|cdesc_phy_base_tag
argument_list|,
name|q_params
operator|->
name|cdesc_phy_base_map
argument_list|,
name|q_params
operator|->
name|cdesc_base
argument_list|)
expr_stmt|;
name|q_params
operator|->
name|cdesc_phy_base
operator|=
literal|0
expr_stmt|;
comment|/* Free LRO resources */
name|tcp_lro_free
argument_list|(
operator|&
name|rx_ring
operator|->
name|lro
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * al_eth_free_all_rx_resources - Free Rx Resources for All Queues  * @adapter: board private structure  *  * Free all receive software resources  */
end_comment

begin_function
specifier|static
name|void
name|al_eth_free_all_rx_resources
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|adapter
operator|->
name|rx_ring
index|[
name|i
index|]
operator|.
name|q_params
operator|.
name|desc_base
operator|!=
literal|0
condition|)
name|al_eth_free_rx_resources
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * al_eth_setup_all_rx_resources - allocate all queues Rx resources  * @adapter: board private structure  *  * Return 0 on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|al_eth_setup_all_rx_resources
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|al_eth_setup_rx_resources
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
continue|continue;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Allocation for Rx Queue %u failed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|err_setup_rx
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err_setup_rx
label|:
comment|/* rewind the index freeing the rings as we go */
while|while
condition|(
name|i
operator|--
condition|)
name|al_eth_free_rx_resources
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * al_eth_setup_all_tx_resources - allocate all queues Tx resources  * @adapter: private structure  *  * Return 0 on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|al_eth_setup_all_tx_resources
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_queues
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|al_eth_setup_tx_resources
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
continue|continue;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Allocation for Tx Queue %u failed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|err_setup_tx
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err_setup_tx
label|:
comment|/* rewind the index freeing the rings as we go */
while|while
condition|(
name|i
operator|--
condition|)
name|al_eth_free_tx_resources
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_disable_int_sync
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
comment|/* disable forwarding interrupts from eth through pci end point */
if|if
condition|(
operator|(
name|adapter
operator|->
name|board_type
operator|==
name|ALPINE_FPGA_NIC
operator|)
operator|||
operator|(
name|adapter
operator|->
name|board_type
operator|==
name|ALPINE_NIC
operator|)
condition|)
block|{
name|al_eth_forward_int_config
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
name|adapter
operator|->
name|internal_pcie_base
operator|+
name|AL_REG_OFFSET_FORWARD_INTR
argument_list|,
name|AL_DIS_FORWARD_INTR
argument_list|)
expr_stmt|;
block|}
comment|/* mask hw interrupts */
name|al_eth_interrupts_mask
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_interrupts_unmask
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|uint32_t
name|group_a_mask
init|=
name|AL_INT_GROUP_A_GROUP_D_SUM
decl_stmt|;
comment|/* enable group D summery */
name|uint32_t
name|group_b_mask
init|=
operator|(
literal|1
operator|<<
name|adapter
operator|->
name|num_rx_queues
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* bit per Rx q*/
name|uint32_t
name|group_c_mask
init|=
operator|(
literal|1
operator|<<
name|adapter
operator|->
name|num_tx_queues
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* bit per Tx q*/
name|uint32_t
name|group_d_mask
init|=
literal|3
operator|<<
literal|8
decl_stmt|;
name|struct
name|unit_regs
name|__iomem
modifier|*
name|regs_base
init|=
operator|(
expr|struct
name|unit_regs
name|__iomem
operator|*
operator|)
name|adapter
operator|->
name|udma_base
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|int_mode
operator|==
name|AL_IOFIC_MODE_LEGACY
condition|)
name|group_a_mask
operator||=
name|AL_INT_GROUP_A_GROUP_B_SUM
operator||
name|AL_INT_GROUP_A_GROUP_C_SUM
operator||
name|AL_INT_GROUP_A_GROUP_D_SUM
expr_stmt|;
name|al_udma_iofic_unmask
argument_list|(
name|regs_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_A
argument_list|,
name|group_a_mask
argument_list|)
expr_stmt|;
name|al_udma_iofic_unmask
argument_list|(
name|regs_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_B
argument_list|,
name|group_b_mask
argument_list|)
expr_stmt|;
name|al_udma_iofic_unmask
argument_list|(
name|regs_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_C
argument_list|,
name|group_c_mask
argument_list|)
expr_stmt|;
name|al_udma_iofic_unmask
argument_list|(
name|regs_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_D
argument_list|,
name|group_d_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_interrupts_mask
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|unit_regs
name|__iomem
modifier|*
name|regs_base
init|=
operator|(
expr|struct
name|unit_regs
name|__iomem
operator|*
operator|)
name|adapter
operator|->
name|udma_base
decl_stmt|;
comment|/* mask all interrupts */
name|al_udma_iofic_mask
argument_list|(
name|regs_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_A
argument_list|,
name|AL_MASK_GROUP_A_INT
argument_list|)
expr_stmt|;
name|al_udma_iofic_mask
argument_list|(
name|regs_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_B
argument_list|,
name|AL_MASK_GROUP_B_INT
argument_list|)
expr_stmt|;
name|al_udma_iofic_mask
argument_list|(
name|regs_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_C
argument_list|,
name|AL_MASK_GROUP_C_INT
argument_list|)
expr_stmt|;
name|al_udma_iofic_mask
argument_list|(
name|regs_base
argument_list|,
name|AL_UDMA_IOFIC_LEVEL_PRIMARY
argument_list|,
name|AL_INT_GROUP_D
argument_list|,
name|AL_MASK_GROUP_D_INT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_configure_int_mode
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|enum
name|al_iofic_mode
name|int_mode
decl_stmt|;
name|uint32_t
name|m2s_errors_disable
init|=
name|AL_M2S_MASK_INIT
decl_stmt|;
name|uint32_t
name|m2s_aborts_disable
init|=
name|AL_M2S_MASK_INIT
decl_stmt|;
name|uint32_t
name|s2m_errors_disable
init|=
name|AL_S2M_MASK_INIT
decl_stmt|;
name|uint32_t
name|s2m_aborts_disable
init|=
name|AL_S2M_MASK_INIT
decl_stmt|;
comment|/* single INTX mode */
if|if
condition|(
name|adapter
operator|->
name|msix_vecs
operator|==
literal|0
condition|)
name|int_mode
operator|=
name|AL_IOFIC_MODE_LEGACY
expr_stmt|;
elseif|else
if|if
condition|(
name|adapter
operator|->
name|msix_vecs
operator|>
literal|1
condition|)
name|int_mode
operator|=
name|AL_IOFIC_MODE_MSIX_PER_Q
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"udma doesn't support single MSI-X mode yet.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|adapter
operator|->
name|board_type
operator|!=
name|ALPINE_INTEGRATED
condition|)
block|{
name|m2s_errors_disable
operator||=
name|AL_M2S_S2M_MASK_NOT_INT
expr_stmt|;
name|m2s_errors_disable
operator||=
name|AL_M2S_S2M_MASK_NOT_INT
expr_stmt|;
name|s2m_aborts_disable
operator||=
name|AL_M2S_S2M_MASK_NOT_INT
expr_stmt|;
name|s2m_aborts_disable
operator||=
name|AL_M2S_S2M_MASK_NOT_INT
expr_stmt|;
block|}
if|if
condition|(
name|al_udma_iofic_config
argument_list|(
operator|(
expr|struct
name|unit_regs
name|__iomem
operator|*
operator|)
name|adapter
operator|->
name|udma_base
argument_list|,
name|int_mode
argument_list|,
name|m2s_errors_disable
argument_list|,
name|m2s_aborts_disable
argument_list|,
name|s2m_errors_disable
argument_list|,
name|s2m_aborts_disable
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"al_udma_unit_int_config failed!.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|adapter
operator|->
name|int_mode
operator|=
name|int_mode
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"using %s interrupt mode\n"
argument_list|,
name|int_mode
operator|==
name|AL_IOFIC_MODE_LEGACY
condition|?
literal|"INTx"
else|:
name|int_mode
operator|==
name|AL_IOFIC_MODE_MSIX_PER_Q
condition|?
literal|"MSI-X per Queue"
else|:
literal|"Unknown"
argument_list|)
expr_stmt|;
comment|/* set interrupt moderation resolution to 15us */
name|al_iofic_moder_res_config
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|unit_regs
operator|*
operator|)
operator|(
name|adapter
operator|->
name|udma_base
operator|)
operator|)
operator|->
name|gen
operator|.
name|interrupt_regs
operator|.
name|main_iofic
argument_list|,
name|AL_INT_GROUP_B
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|al_iofic_moder_res_config
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|unit_regs
operator|*
operator|)
operator|(
name|adapter
operator|->
name|udma_base
operator|)
operator|)
operator|->
name|gen
operator|.
name|interrupt_regs
operator|.
name|main_iofic
argument_list|,
name|AL_INT_GROUP_C
argument_list|,
literal|15
argument_list|)
expr_stmt|;
comment|/* by default interrupt coalescing is disabled */
name|adapter
operator|->
name|tx_usecs
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|rx_usecs
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ethtool_rxfh_indir_default - get default value for RX flow hash indirection  * @index: Index in RX flow hash indirection table  * @n_rx_rings: Number of RX rings to use  *  * This function provides the default policy for RX flow hash indirection.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|ethtool_rxfh_indir_default
parameter_list|(
name|uint32_t
name|index
parameter_list|,
name|uint32_t
name|n_rx_rings
parameter_list|)
block|{
return|return
operator|(
name|index
operator|%
name|n_rx_rings
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|al_eth_update_stats
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|al_eth_mac_stats
modifier|*
name|mac_stats
init|=
operator|&
name|adapter
operator|->
name|mac_stats
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|up
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|al_eth_mac_stats_get
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|mac_stats
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|al_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|al_eth_mac_stats
modifier|*
name|mac_stats
decl_stmt|;
name|uint64_t
name|rv
decl_stmt|;
name|adapter
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mac_stats
operator|=
operator|&
name|adapter
operator|->
name|mac_stats
expr_stmt|;
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
name|IFCOUNTER_IPACKETS
case|:
return|return
operator|(
name|mac_stats
operator|->
name|aFramesReceivedOK
operator|)
return|;
comment|/* including pause frames */
case|case
name|IFCOUNTER_OPACKETS
case|:
return|return
operator|(
name|mac_stats
operator|->
name|aFramesTransmittedOK
operator|)
return|;
case|case
name|IFCOUNTER_IBYTES
case|:
return|return
operator|(
name|mac_stats
operator|->
name|aOctetsReceivedOK
operator|)
return|;
case|case
name|IFCOUNTER_OBYTES
case|:
return|return
operator|(
name|mac_stats
operator|->
name|aOctetsTransmittedOK
operator|)
return|;
case|case
name|IFCOUNTER_IMCASTS
case|:
return|return
operator|(
name|mac_stats
operator|->
name|ifInMulticastPkts
operator|)
return|;
case|case
name|IFCOUNTER_OMCASTS
case|:
return|return
operator|(
name|mac_stats
operator|->
name|ifOutMulticastPkts
operator|)
return|;
case|case
name|IFCOUNTER_COLLISIONS
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|IFCOUNTER_IQDROPS
case|:
return|return
operator|(
name|mac_stats
operator|->
name|etherStatsDropEvents
operator|)
return|;
case|case
name|IFCOUNTER_IERRORS
case|:
name|rv
operator|=
name|mac_stats
operator|->
name|ifInErrors
operator|+
name|mac_stats
operator|->
name|etherStatsUndersizePkts
operator|+
comment|/* good but short */
name|mac_stats
operator|->
name|etherStatsFragments
operator|+
comment|/* short and bad*/
name|mac_stats
operator|->
name|etherStatsJabbers
operator|+
comment|/* with crc errors */
name|mac_stats
operator|->
name|etherStatsOversizePkts
operator|+
name|mac_stats
operator|->
name|aFrameCheckSequenceErrors
operator|+
name|mac_stats
operator|->
name|aAlignmentErrors
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
case|case
name|IFCOUNTER_OERRORS
case|:
return|return
operator|(
name|mac_stats
operator|->
name|ifOutErrors
operator|)
return|;
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  *  Unicast, Multicast and Promiscuous mode set  *  *  The set_rx_mode entry point is called whenever the unicast or multicast  *  address lists or the network interface flags are updated.  This routine is  *  responsible for configuring the hardware for proper unicast, multicast,  *  promiscuous mode, and all-multi behavior.  */
end_comment

begin_define
define|#
directive|define
name|MAX_NUM_MULTICAST_ADDRESSES
value|32
end_define

begin_define
define|#
directive|define
name|MAX_NUM_ADDRESSES
value|32
end_define

begin_function
specifier|static
name|void
name|al_eth_set_rx_mode
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|netdev
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
comment|/* multicast addresses configured */
name|struct
name|ifaddr
modifier|*
name|ifua
decl_stmt|;
comment|/* unicast address */
name|int
name|mc
init|=
literal|0
decl_stmt|;
name|int
name|uc
init|=
literal|0
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mac
decl_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|mc
operator|==
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
break|break;
name|mac
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
comment|/* default mc address inside mac address */
if|if
condition|(
name|mac
index|[
literal|3
index|]
operator|!=
literal|0
operator|&&
name|mac
index|[
literal|4
index|]
operator|!=
literal|0
operator|&&
name|mac
index|[
literal|5
index|]
operator|!=
literal|1
condition|)
name|mc
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_addr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifua
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifua
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|uc
operator|==
name|MAX_NUM_ADDRESSES
condition|)
break|break;
name|uc
operator|++
expr_stmt|;
block|}
name|if_addr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
block|{
name|al_eth_mac_table_promiscuous_set
argument_list|(
name|adapter
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* This interface is in all-multicasts mode (used by multicast routers). */
name|al_eth_mac_table_all_multicast_add
argument_list|(
name|adapter
argument_list|,
name|AL_ETH_MAC_TABLE_ALL_MULTICAST_IDX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mc
operator|==
literal|0
condition|)
block|{
name|al_eth_mac_table_entry_clear
argument_list|(
name|adapter
argument_list|,
name|AL_ETH_MAC_TABLE_ALL_MULTICAST_IDX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|al_eth_mac_table_all_multicast_add
argument_list|(
name|adapter
argument_list|,
name|AL_ETH_MAC_TABLE_ALL_MULTICAST_IDX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|uc
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|AL_ETH_MAC_TABLE_UNICAST_IDX_BASE
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|uc
operator|>
name|AL_ETH_MAC_TABLE_UNICAST_MAX_COUNT
condition|)
block|{
comment|/* 				 * In this case there are more addresses then 				 * entries in the mac table - set promiscuous 				 */
name|al_eth_mac_table_promiscuous_set
argument_list|(
name|adapter
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* clear the last configuration */
while|while
condition|(
name|i
operator|<
operator|(
name|AL_ETH_MAC_TABLE_UNICAST_IDX_BASE
operator|+
name|AL_ETH_MAC_TABLE_UNICAST_MAX_COUNT
operator|)
condition|)
block|{
name|al_eth_mac_table_entry_clear
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* set new addresses */
name|i
operator|=
name|AL_ETH_MAC_TABLE_UNICAST_IDX_BASE
operator|+
literal|1
expr_stmt|;
name|if_addr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifua
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifua
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
block|{
continue|continue;
block|}
name|al_eth_mac_table_unicast_add
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ifua
operator|->
name|ifa_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|if_addr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|al_eth_mac_table_promiscuous_set
argument_list|(
name|adapter
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_config_rx_fwd
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|al_eth_fwd_ctrl_table_entry
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* let priority be equal to pbits */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AL_ETH_FWD_PBITS_TABLE_NUM
condition|;
name|i
operator|++
control|)
name|al_eth_fwd_pbits_table_set
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* map priority to queue index, queue id = priority/2 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AL_ETH_FWD_PRIO_TABLE_NUM
condition|;
name|i
operator|++
control|)
name|al_eth_fwd_priority_table_set
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|i
argument_list|,
name|i
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|entry
operator|.
name|prio_sel
operator|=
name|AL_ETH_CTRL_TABLE_PRIO_SEL_VAL_0
expr_stmt|;
name|entry
operator|.
name|queue_sel_1
operator|=
name|AL_ETH_CTRL_TABLE_QUEUE_SEL_1_THASH_TABLE
expr_stmt|;
name|entry
operator|.
name|queue_sel_2
operator|=
name|AL_ETH_CTRL_TABLE_QUEUE_SEL_2_NO_PRIO
expr_stmt|;
name|entry
operator|.
name|udma_sel
operator|=
name|AL_ETH_CTRL_TABLE_UDMA_SEL_MAC_TABLE
expr_stmt|;
name|entry
operator|.
name|filter
operator|=
name|FALSE
expr_stmt|;
name|al_eth_ctrl_table_def_set
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|FALSE
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
comment|/* 	 * By default set the mac table to forward all unicast packets to our 	 * MAC address and all broadcast. all the rest will be dropped. 	 */
name|al_eth_mac_table_unicast_add
argument_list|(
name|adapter
argument_list|,
name|AL_ETH_MAC_TABLE_UNICAST_IDX_BASE
argument_list|,
name|adapter
operator|->
name|mac_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|al_eth_mac_table_broadcast_add
argument_list|(
name|adapter
argument_list|,
name|AL_ETH_MAC_TABLE_BROADCAST_IDX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|al_eth_mac_table_promiscuous_set
argument_list|(
name|adapter
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* set toeplitz hash keys */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|adapter
operator|->
name|toeplitz_hash_key
argument_list|)
condition|;
name|i
operator|++
control|)
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|adapter
operator|->
name|toeplitz_hash_key
operator|+
name|i
operator|)
operator|=
operator|(
name|uint8_t
operator|)
name|random
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AL_ETH_RX_HASH_KEY_NUM
condition|;
name|i
operator|++
control|)
name|al_eth_hash_key_set
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|i
argument_list|,
name|htonl
argument_list|(
name|adapter
operator|->
name|toeplitz_hash_key
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AL_ETH_RX_RSS_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|adapter
operator|->
name|rss_ind_tbl
index|[
name|i
index|]
operator|=
name|ethtool_rxfh_indir_default
argument_list|(
name|i
argument_list|,
name|AL_ETH_NUM_QUEUES
argument_list|)
expr_stmt|;
name|al_eth_set_thash_table_entry
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|adapter
operator|->
name|rss_ind_tbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|al_eth_fsm_table_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_req_rx_buff_size
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|size
parameter_list|)
block|{
comment|/* 	* Determine the correct mbuf pool 	* for doing jumbo frames 	* Try from the smallest up to maximum supported 	*/
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MCLBYTES
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|2048
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|max_rx_buff_alloc_size
operator|>
literal|2048
condition|)
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUMPAGESIZE
expr_stmt|;
else|else
return|return;
block|}
if|if
condition|(
name|size
operator|>
literal|4096
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|max_rx_buff_alloc_size
operator|>
literal|4096
condition|)
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUM9BYTES
expr_stmt|;
else|else
return|return;
block|}
if|if
condition|(
name|size
operator|>
literal|9216
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|max_rx_buff_alloc_size
operator|>
literal|9216
condition|)
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUM16BYTES
expr_stmt|;
else|else
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_change_mtu
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|new_mtu
parameter_list|)
block|{
name|int
name|max_frame
init|=
name|new_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
decl_stmt|;
name|al_eth_req_rx_buff_size
argument_list|(
name|adapter
argument_list|,
name|new_mtu
argument_list|)
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"set MTU to %d\n"
argument_list|,
name|new_mtu
argument_list|)
expr_stmt|;
name|al_eth_rx_pkt_limit_config
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|AL_ETH_MIN_FRAME_LEN
argument_list|,
name|max_frame
argument_list|)
expr_stmt|;
name|al_eth_tso_mss_config
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
literal|0
argument_list|,
name|new_mtu
operator|-
literal|100
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_check_mtu
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|new_mtu
parameter_list|)
block|{
name|int
name|max_frame
init|=
name|new_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
decl_stmt|;
if|if
condition|(
operator|(
name|new_mtu
operator|<
name|AL_ETH_MIN_FRAME_LEN
operator|)
operator|||
operator|(
name|max_frame
operator|>
name|AL_ETH_MAX_FRAME_LEN
operator|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_udma_queue_enable
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|,
name|enum
name|al_udma_type
name|type
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|type
operator|==
name|UDMA_TX
operator|)
condition|?
literal|"Tx"
else|:
literal|"Rx"
decl_stmt|;
name|struct
name|al_udma_q_params
modifier|*
name|q_params
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|UDMA_TX
condition|)
name|q_params
operator|=
operator|&
name|adapter
operator|->
name|tx_ring
index|[
name|qid
index|]
operator|.
name|q_params
expr_stmt|;
else|else
name|q_params
operator|=
operator|&
name|adapter
operator|->
name|rx_ring
index|[
name|qid
index|]
operator|.
name|q_params
expr_stmt|;
name|rc
operator|=
name|al_eth_queue_config
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|type
argument_list|,
name|qid
argument_list|,
name|q_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"config %s queue %u failed\n"
argument_list|,
name|name
argument_list|,
name|qid
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_udma_queues_enable_all
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_queues
condition|;
name|i
operator|++
control|)
name|al_eth_udma_queue_enable
argument_list|(
name|adapter
argument_list|,
name|UDMA_TX
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_queues
condition|;
name|i
operator|++
control|)
name|al_eth_udma_queue_enable
argument_list|(
name|adapter
argument_list|,
name|UDMA_RX
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_up_complete
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|al_eth_configure_int_mode
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|al_eth_config_rx_fwd
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|al_eth_change_mtu
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|netdev
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
name|al_eth_udma_queues_enable_all
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|al_eth_refill_all_rx_bufs
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|al_eth_interrupts_unmask
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* enable forwarding interrupts from eth through pci end point */
if|if
condition|(
operator|(
name|adapter
operator|->
name|board_type
operator|==
name|ALPINE_FPGA_NIC
operator|)
operator|||
operator|(
name|adapter
operator|->
name|board_type
operator|==
name|ALPINE_NIC
operator|)
condition|)
block|{
name|al_eth_forward_int_config
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
name|adapter
operator|->
name|internal_pcie_base
operator|+
name|AL_REG_OFFSET_FORWARD_INTR
argument_list|,
name|AL_EN_FORWARD_INTR
argument_list|)
expr_stmt|;
block|}
name|al_eth_flow_ctrl_enable
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|adapter
operator|->
name|stats_mtx
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|stats_callout
argument_list|,
name|hz
argument_list|,
name|al_tick_stats
argument_list|,
operator|(
name|void
operator|*
operator|)
name|adapter
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|stats_mtx
argument_list|)
expr_stmt|;
name|al_eth_mac_start
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_media_update
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
name|mii_mediachg
argument_list|(
name|adapter
operator|->
name|mii
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mii
operator|==
name|NULL
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_NONE
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|mii
operator|=
name|sc
operator|->
name|mii
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|mii_tick
argument_list|(
name|adapter
operator|->
name|mii
argument_list|)
expr_stmt|;
comment|/* Schedule another timeout one second from now */
name|callout_schedule
argument_list|(
operator|&
name|adapter
operator|->
name|wd_callout
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_tick_stats
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|al_eth_update_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_schedule
argument_list|(
operator|&
name|adapter
operator|->
name|stats_callout
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_eth_up
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|netdev
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|up
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|flags
operator|&
name|AL_ETH_FLAG_RESET_REQUESTED
operator|)
operator|!=
literal|0
condition|)
block|{
name|al_eth_function_reset
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|flags
operator|&=
operator|~
name|AL_ETH_FLAG_RESET_REQUESTED
expr_stmt|;
block|}
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP_IPV6
operator||
name|CSUM_UDP_IPV6
operator|)
expr_stmt|;
name|al_eth_serdes_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|rc
operator|=
name|al_eth_hw_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|err_hw_init_open
goto|;
name|rc
operator|=
name|al_eth_setup_int_mode
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s failed at setup interrupt mode!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|err_setup_int
goto|;
block|}
comment|/* allocate transmit descriptors */
name|rc
operator|=
name|al_eth_setup_all_tx_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|err_setup_tx
goto|;
comment|/* allocate receive descriptors */
name|rc
operator|=
name|al_eth_setup_all_rx_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|err_setup_rx
goto|;
name|rc
operator|=
name|al_eth_request_irq
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|err_req_irq
goto|;
name|al_eth_up_complete
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|up
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|mac_mode
operator|==
name|AL_ETH_MAC_MODE_10GbE_Serial
condition|)
name|adapter
operator|->
name|netdev
operator|->
name|if_link_state
operator|=
name|LINK_STATE_UP
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|mac_mode
operator|==
name|AL_ETH_MAC_MODE_RGMII
condition|)
block|{
name|mii_mediachg
argument_list|(
name|adapter
operator|->
name|mii
argument_list|)
expr_stmt|;
comment|/* Schedule watchdog timeout */
name|mtx_lock
argument_list|(
operator|&
name|adapter
operator|->
name|wd_mtx
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|wd_callout
argument_list|,
name|hz
argument_list|,
name|al_tick
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|wd_mtx
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|adapter
operator|->
name|mii
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
name|err_req_irq
label|:
name|al_eth_free_all_rx_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_setup_rx
label|:
name|al_eth_free_all_tx_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_setup_tx
label|:
name|al_eth_free_irq
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_setup_int
label|:
name|al_eth_hw_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_hw_init_open
label|:
name|al_eth_function_reset
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|al_eth_down
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_eth_down
parameter_list|(
name|struct
name|al_eth_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"al_eth_down: begin\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|up
operator|=
name|false
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|adapter
operator|->
name|wd_mtx
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|wd_callout
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|wd_mtx
argument_list|)
expr_stmt|;
name|al_eth_disable_int_sync
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|adapter
operator|->
name|stats_mtx
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|stats_callout
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|adapter
operator|->
name|stats_mtx
argument_list|)
expr_stmt|;
name|al_eth_free_irq
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|al_eth_hw_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|al_eth_free_all_tx_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|al_eth_free_all_rx_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
block|{
name|error
operator|=
name|al_eth_check_mtu
argument_list|(
name|adapter
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"ioctl wrong mtu %u\n"
argument_list|,
name|adapter
operator|->
name|netdev
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
break|break;
block|}
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|adapter
operator|->
name|netdev
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|al_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|adapter
operator|->
name|if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"ioctl promisc/allmulti\n"
argument_list|)
expr_stmt|;
name|al_eth_set_rx_mode
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|al_eth_up
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|al_eth_down
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
block|}
name|adapter
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"ioctl add/del multi before\n"
argument_list|)
expr_stmt|;
name|al_eth_set_rx_mode
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
operator|==
literal|0
condition|)
endif|#
directive|endif
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
if|if
condition|(
name|adapter
operator|->
name|mii
operator|!=
name|NULL
condition|)
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|adapter
operator|->
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|mask
decl_stmt|,
name|reinit
decl_stmt|;
name|reinit
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_POLLING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Enable interrupt even in error case */
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_POLLING
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_HWCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* apply to both rx and tx */
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_HWCSUM
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_HWCSUM_IPV6
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_HWCSUM_IPV6
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_TSO
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_LRO
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_VLAN_HWFILTER
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reinit
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|al_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_is_device_supported
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint16_t
name|pci_vendor_id
init|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint16_t
name|pci_device_id
init|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|pci_vendor_id
operator|==
name|PCI_VENDOR_ID_ANNAPURNA_LABS
operator|&&
operator|(
name|pci_device_id
operator|==
name|PCI_DEVICE_ID_AL_ETH
operator|||
name|pci_device_id
operator|==
name|PCI_DEVICE_ID_AL_ETH_ADVANCED
operator|||
name|pci_device_id
operator|==
name|PCI_DEVICE_ID_AL_ETH_NIC
operator|||
name|pci_device_id
operator|==
name|PCI_DEVICE_ID_AL_ETH_FPGA_NIC
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Time in mSec to keep trying to read / write from MDIO in case of error */
end_comment

begin_define
define|#
directive|define
name|MDIO_TIMEOUT_MSEC
value|100
end_define

begin_define
define|#
directive|define
name|MDIO_PAUSE_MSEC
value|10
end_define

begin_function
specifier|static
name|int
name|al_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint16_t
name|value
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|timeout
init|=
name|MDIO_TIMEOUT_MSEC
decl_stmt|;
while|while
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|rc
operator|=
name|al_eth_mdio_read
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|adapter
operator|->
name|phy_addr
argument_list|,
operator|-
literal|1
argument_list|,
name|reg
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
return|return
operator|(
name|value
operator|)
return|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"mdio read failed. try again in 10 msec\n"
argument_list|)
expr_stmt|;
name|timeout
operator|-=
name|MDIO_PAUSE_MSEC
expr_stmt|;
name|pause
argument_list|(
literal|"readred pause"
argument_list|,
name|MDIO_PAUSE_MSEC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"MDIO read failed on timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|al_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|timeout
init|=
name|MDIO_TIMEOUT_MSEC
decl_stmt|;
while|while
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|rc
operator|=
name|al_eth_mdio_write
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
name|adapter
operator|->
name|phy_addr
argument_list|,
operator|-
literal|1
argument_list|,
name|reg
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"mdio write failed. try again in 10 msec\n"
argument_list|)
expr_stmt|;
name|timeout
operator|-=
name|MDIO_PAUSE_MSEC
expr_stmt|;
name|pause
argument_list|(
literal|"miibus writereg"
argument_list|,
name|MDIO_PAUSE_MSEC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"MDIO write failed on timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|al_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"al_miibus_statchg: state has changed!\n"
argument_list|)
expr_stmt|;
name|device_printf_dbg
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"al_miibus_statchg: active = 0x%x status = 0x%x\n"
argument_list|,
name|adapter
operator|->
name|mii
operator|->
name|mii_media_active
argument_list|,
name|adapter
operator|->
name|mii
operator|->
name|mii_media_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|up
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|adapter
operator|->
name|mii
operator|->
name|mii_media_status
operator|&
name|IFM_AVALID
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|mii
operator|->
name|mii_media_status
operator|&
name|IFM_ACTIVE
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"link is UP\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|netdev
operator|->
name|if_link_state
operator|=
name|LINK_STATE_UP
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"link is DOWN\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|netdev
operator|->
name|if_link_state
operator|=
name|LINK_STATE_DOWN
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|al_miibus_linkchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|al_eth_adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint8_t
name|duplex
init|=
literal|0
decl_stmt|;
name|uint8_t
name|speed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|mii
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|adapter
operator|->
name|netdev
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* Ignore link changes when link is not ready */
if|if
condition|(
operator|(
name|adapter
operator|->
name|mii
operator|->
name|mii_media_status
operator|&
operator|(
name|IFM_AVALID
operator||
name|IFM_ACTIVE
operator|)
operator|)
operator|!=
operator|(
name|IFM_AVALID
operator||
name|IFM_ACTIVE
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|adapter
operator|->
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|duplex
operator|=
literal|1
expr_stmt|;
name|speed
operator|=
name|IFM_SUBTYPE
argument_list|(
name|adapter
operator|->
name|mii
operator|->
name|mii_media_active
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|==
name|IFM_10_T
condition|)
block|{
name|al_eth_mac_link_config
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|AL_10BASE_T_SPEED
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|speed
operator|==
name|IFM_100_TX
condition|)
block|{
name|al_eth_mac_link_config
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|AL_100BASE_TX_SPEED
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|speed
operator|==
name|IFM_1000_T
condition|)
block|{
name|al_eth_mac_link_config
argument_list|(
operator|&
name|adapter
operator|->
name|hal_adapter
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|AL_1000BASE_T_SPEED
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"ERROR: unknown MII media active 0x%08x\n"
argument_list|,
name|adapter
operator|->
name|mii
operator|->
name|mii_media_active
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

