begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *       Copyright (c) 2000-03 ICP vortex GmbH  *       Copyright (c) 2002-03 Intel Corporation  *       Copyright (c) 2003    Adaptec Inc.  *       All Rights Reserved  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * iir.c: SCSI dependant code for the Intel Integrated RAID Controller driver  *  * Written by: Achim Leubner<achim_leubner@adaptec.com>  * Fixes/Additions: Boji Tony Kannanthanam<boji.t.kannanthanam@intel.com>  *  * credits:     Niklas Hallqvist;       OpenBSD driver for the ICP Controllers.  *              Mike Smith;             Some driver source code.  *              FreeBSD.ORG;            Great O/S to work on and for.  *  * $Id: iir.c 1.4 2003/08/26 12:29:44 achim Exp $"  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|_IIR_C_
end_define

begin_comment
comment|/* #include "opt_iir.h" */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/iir/iir.h>
end_include

begin_decl_stmt
name|struct
name|gdt_softc
modifier|*
name|gdt_wait_gdt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gdt_wait_index
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GDT_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|gdt_debug
init|=
name|GDT_DEBUG
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__SERIAL__
end_ifdef

begin_define
define|#
directive|define
name|MAX_SERBUF
value|160
end_define

begin_function_decl
specifier|static
name|void
name|ser_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ser_puts
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ser_putc
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|strbuf
index|[
name|MAX_SERBUF
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__COM2__
end_ifdef

begin_define
define|#
directive|define
name|COM_BASE
value|0x2f8
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COM_BASE
value|0x3f8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ser_init
parameter_list|()
block|{
name|unsigned
name|port
init|=
name|COM_BASE
decl_stmt|;
name|outb
argument_list|(
name|port
operator|+
literal|3
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 19200 Baud, if 9600: outb(12,port) */
name|outb
argument_list|(
name|port
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ser_puts
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|ser_init
argument_list|()
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|str
init|;
operator|*
name|ptr
condition|;
operator|++
name|ptr
control|)
name|ser_putc
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ser_putc
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|unsigned
name|port
init|=
name|COM_BASE
decl_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
literal|5
argument_list|)
operator|&
literal|0x20
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0x0a
condition|)
block|{
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
literal|5
argument_list|)
operator|&
literal|0x20
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
literal|0x0d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ser_printf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsprintf
argument_list|(
name|strbuf
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|ser_puts
argument_list|(
name|strbuf
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The linked list of softc structures */
end_comment

begin_decl_stmt
name|struct
name|gdt_softc_list
name|gdt_softcs
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|gdt_softcs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* controller cnt. */
end_comment

begin_decl_stmt
name|int
name|gdt_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* event buffer */
end_comment

begin_decl_stmt
specifier|static
name|gdt_evt_str
name|ebuffer
index|[
name|GDT_MAX_EVENTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elastidx
decl_stmt|,
name|eoldidx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* statistics */
end_comment

begin_decl_stmt
name|gdt_statist_t
name|gdt_stat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Definitions for our use of the SIM private CCB area */
end_comment

begin_define
define|#
directive|define
name|ccb_sim_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_priority
value|spriv_field1
end_define

begin_function_decl
specifier|static
name|void
name|iir_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iir_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iir_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iir_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iir_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdt_eval_mapping
parameter_list|(
name|u_int32_t
name|size
parameter_list|,
name|int
modifier|*
name|cyls
parameter_list|,
name|int
modifier|*
name|heads
parameter_list|,
name|int
modifier|*
name|secs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gdt_internal_cmd
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|struct
name|gdt_ccb
modifier|*
name|gccb
parameter_list|,
name|u_int8_t
name|service
parameter_list|,
name|u_int16_t
name|opcode
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gdt_wait
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|struct
name|gdt_ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|gdt_ccb
modifier|*
name|gdt_get_ccb
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|gdt_ccb_vtop
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|struct
name|gdt_ccb
modifier|*
name|gccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gdt_sync_event
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|int
name|service
parameter_list|,
name|u_int8_t
name|index
parameter_list|,
name|struct
name|gdt_ccb
modifier|*
name|gccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gdt_async_event
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|int
name|service
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|gdt_ccb
modifier|*
name|gdt_raw_cmd
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
modifier|*
name|lock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|gdt_ccb
modifier|*
name|gdt_cache_cmd
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
modifier|*
name|lock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|gdt_ccb
modifier|*
name|gdt_ioctl_cmd
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|gdt_ucmd_t
modifier|*
name|ucmd
parameter_list|,
name|int
modifier|*
name|lock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdt_internal_cache_cmd
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdtmapmem
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gdtexecuteccb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|iir_init
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|)
block|{
name|u_int16_t
name|cdev_cnt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|id
decl_stmt|,
name|drv_cyls
decl_stmt|,
name|drv_hds
decl_stmt|,
name|drv_secs
decl_stmt|;
name|struct
name|gdt_ccb
modifier|*
name|gccb
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_DEBUG
argument_list|,
operator|(
literal|"iir_init()\n"
operator|)
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_state
operator|=
name|GDT_POLLING
expr_stmt|;
name|gdt_clear_events
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|gdt_stat
argument_list|,
sizeof|sizeof
argument_list|(
name|gdt_statist_t
argument_list|)
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|gdt
operator|->
name|sc_free_gccb
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|gdt
operator|->
name|sc_pending_gccb
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ccb_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ucmd_queue
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|gdt_softcs
argument_list|,
name|gdt
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* DMA tag for mapping buffers into device visible space. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|gdt
operator|->
name|sc_parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|MAXBSIZE
argument_list|,
comment|/*nsegments*/
name|GDT_MAXSG
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
operator|&
name|gdt
operator|->
name|sc_buffer_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: bus_dma_tag_create(...,gdt->sc_buffer_dmat) failed\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|gdt
operator|->
name|sc_init_level
operator|++
expr_stmt|;
comment|/* DMA tag for our ccb structures */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|gdt
operator|->
name|sc_parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
name|GDT_MAXCMDS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gdt_ccb
argument_list|)
argument_list|,
comment|/* maxsize */
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
operator|&
name|gdt
operator|->
name|sc_gccb_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: bus_dma_tag_create(...,gdt->sc_gccb_dmat) failed\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|gdt
operator|->
name|sc_init_level
operator|++
expr_stmt|;
comment|/* Allocation for our ccbs */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|gdt
operator|->
name|sc_gccb_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|gdt
operator|->
name|sc_gccbs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|gdt
operator|->
name|sc_gccb_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: bus_dmamem_alloc(...,&gdt->sc_gccbs,...) failed\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|gdt
operator|->
name|sc_init_level
operator|++
expr_stmt|;
comment|/* And permanently map them */
name|bus_dmamap_load
argument_list|(
name|gdt
operator|->
name|sc_gccb_dmat
argument_list|,
name|gdt
operator|->
name|sc_gccb_dmamap
argument_list|,
name|gdt
operator|->
name|sc_gccbs
argument_list|,
name|GDT_MAXCMDS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gdt_ccb
argument_list|)
argument_list|,
name|gdtmapmem
argument_list|,
operator|&
name|gdt
operator|->
name|sc_gccb_busbase
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_init_level
operator|++
expr_stmt|;
comment|/* Clear them out. */
name|bzero
argument_list|(
name|gdt
operator|->
name|sc_gccbs
argument_list|,
name|GDT_MAXCMDS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gdt_ccb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the ccbs */
for|for
control|(
name|i
operator|=
name|GDT_MAXCMDS
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|gdt
operator|->
name|sc_gccbs
index|[
name|i
index|]
operator|.
name|gc_cmd_index
operator|=
name|i
operator|+
literal|2
expr_stmt|;
name|gdt
operator|->
name|sc_gccbs
index|[
name|i
index|]
operator|.
name|gc_flags
operator|=
name|GDT_GCF_UNUSED
expr_stmt|;
name|gdt
operator|->
name|sc_gccbs
index|[
name|i
index|]
operator|.
name|gc_map_flag
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|gdt
operator|->
name|sc_buffer_dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|gdt
operator|->
name|sc_gccbs
index|[
name|i
index|]
operator|.
name|gc_dmamap
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|gdt
operator|->
name|sc_gccbs
index|[
name|i
index|]
operator|.
name|gc_map_flag
operator|=
name|TRUE
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|gdt
operator|->
name|sc_free_gccb
argument_list|,
operator|&
name|gdt
operator|->
name|sc_gccbs
index|[
name|i
index|]
argument_list|,
name|sle
argument_list|)
expr_stmt|;
block|}
name|gdt
operator|->
name|sc_init_level
operator|++
expr_stmt|;
comment|/* create the control device */
name|gdt
operator|->
name|sc_dev
operator|=
name|gdt_make_dev
argument_list|(
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
comment|/* allocate ccb for gdt_internal_cmd() */
name|gccb
operator|=
name|gdt_get_ccb
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
if|if
condition|(
name|gccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: No free command index found\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_SCREENSERVICE
argument_list|,
name|GDT_INIT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: Screen service initialization error %d\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|,
name|gdt
operator|->
name|sc_status
argument_list|)
expr_stmt|;
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_CACHESERVICE
argument_list|,
name|GDT_INIT
argument_list|,
name|GDT_LINUX_OS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: Cache service initialization error %d\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|,
name|gdt
operator|->
name|sc_status
argument_list|)
expr_stmt|;
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_CACHESERVICE
argument_list|,
name|GDT_UNFREEZE_IO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_CACHESERVICE
argument_list|,
name|GDT_MOUNT
argument_list|,
literal|0xffff
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: Cache service mount error %d\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|,
name|gdt
operator|->
name|sc_status
argument_list|)
expr_stmt|;
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_CACHESERVICE
argument_list|,
name|GDT_INIT
argument_list|,
name|GDT_LINUX_OS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: Cache service post-mount initialization error %d\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|,
name|gdt
operator|->
name|sc_status
argument_list|)
expr_stmt|;
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cdev_cnt
operator|=
operator|(
name|u_int16_t
operator|)
name|gdt
operator|->
name|sc_info
expr_stmt|;
name|gdt
operator|->
name|sc_fw_vers
operator|=
name|gdt
operator|->
name|sc_service
expr_stmt|;
comment|/* Detect number of buses */
name|gdt_enc32
argument_list|(
name|gccb
operator|->
name|gc_scratch
operator|+
name|GDT_IOC_VERSION
argument_list|,
name|GDT_IOC_NEWEST
argument_list|)
expr_stmt|;
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_IOC_LIST_ENTRIES
index|]
operator|=
name|GDT_MAXBUS
expr_stmt|;
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_IOC_FIRST_CHAN
index|]
operator|=
literal|0
expr_stmt|;
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_IOC_LAST_CHAN
index|]
operator|=
name|GDT_MAXBUS
operator|-
literal|1
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gccb
operator|->
name|gc_scratch
operator|+
name|GDT_IOC_LIST_OFFSET
argument_list|,
name|GDT_IOC_HDR_SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_CACHESERVICE
argument_list|,
name|GDT_IOCTL
argument_list|,
name|GDT_IOCHAN_RAW_DESC
argument_list|,
name|GDT_INVALID_CHANNEL
argument_list|,
name|GDT_IOC_HDR_SZ
operator|+
name|GDT_MAXBUS
operator|*
name|GDT_RAWIOC_SZ
argument_list|)
condition|)
block|{
name|gdt
operator|->
name|sc_bus_cnt
operator|=
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_IOC_CHAN_COUNT
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gdt
operator|->
name|sc_bus_cnt
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_IOC_HDR_SZ
operator|+
name|i
operator|*
name|GDT_RAWIOC_SZ
operator|+
name|GDT_RAWIOC_PROC_ID
index|]
expr_stmt|;
name|gdt
operator|->
name|sc_bus_id
index|[
name|i
index|]
operator|=
name|id
operator|<
name|GDT_MAXID_FC
condition|?
name|id
else|:
literal|0xff
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* New method failed, use fallback. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GDT_MAXBUS
condition|;
name|i
operator|++
control|)
block|{
name|gdt_enc32
argument_list|(
name|gccb
operator|->
name|gc_scratch
operator|+
name|GDT_GETCH_CHANNEL_NO
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_CACHESERVICE
argument_list|,
name|GDT_IOCTL
argument_list|,
name|GDT_SCSI_CHAN_CNT
operator||
name|GDT_L_CTRL_PATTERN
argument_list|,
name|GDT_IO_CHANNEL
operator||
name|GDT_INVALID_CHANNEL
argument_list|,
name|GDT_GETCH_SZ
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: Cannot get channel count, "
literal|"error %d\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|,
name|gdt
operator|->
name|sc_status
argument_list|)
expr_stmt|;
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
name|gdt
operator|->
name|sc_bus_id
index|[
name|i
index|]
operator|=
operator|(
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_GETCH_SIOP_ID
index|]
operator|<
name|GDT_MAXID_FC
operator|)
condition|?
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_GETCH_SIOP_ID
index|]
else|:
literal|0xff
expr_stmt|;
block|}
name|gdt
operator|->
name|sc_bus_cnt
operator|=
name|i
expr_stmt|;
block|}
comment|/* add one "virtual" channel for the host drives */
name|gdt
operator|->
name|sc_virt_bus
operator|=
name|gdt
operator|->
name|sc_bus_cnt
expr_stmt|;
name|gdt
operator|->
name|sc_bus_cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_SCSIRAWSERVICE
argument_list|,
name|GDT_INIT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: Raw service initialization error %d\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|,
name|gdt
operator|->
name|sc_status
argument_list|)
expr_stmt|;
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Set/get features raw service (scatter/gather) */
name|gdt
operator|->
name|sc_raw_feat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_SCSIRAWSERVICE
argument_list|,
name|GDT_SET_FEAT
argument_list|,
name|GDT_SCATTER_GATHER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_SCSIRAWSERVICE
argument_list|,
name|GDT_GET_FEAT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|gdt
operator|->
name|sc_raw_feat
operator|=
name|gdt
operator|->
name|sc_info
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gdt
operator|->
name|sc_info
operator|&
name|GDT_SCATTER_GATHER
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"iir%d: Scatter/Gather Raw Service "
literal|"required but not supported!\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
comment|/* Set/get features cache service (scatter/gather) */
name|gdt
operator|->
name|sc_cache_feat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_CACHESERVICE
argument_list|,
name|GDT_SET_FEAT
argument_list|,
literal|0
argument_list|,
name|GDT_SCATTER_GATHER
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_CACHESERVICE
argument_list|,
name|GDT_GET_FEAT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|gdt
operator|->
name|sc_cache_feat
operator|=
name|gdt
operator|->
name|sc_info
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gdt
operator|->
name|sc_info
operator|&
name|GDT_SCATTER_GATHER
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"iir%d: Scatter/Gather Cache Service "
literal|"required but not supported!\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
comment|/* OEM */
name|gdt_enc32
argument_list|(
name|gccb
operator|->
name|gc_scratch
operator|+
name|GDT_OEM_VERSION
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gccb
operator|->
name|gc_scratch
operator|+
name|GDT_OEM_BUFSIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|gdt_oem_record_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_CACHESERVICE
argument_list|,
name|GDT_IOCTL
argument_list|,
name|GDT_OEM_STR_RECORD
argument_list|,
name|GDT_INVALID_CHANNEL
argument_list|,
sizeof|sizeof
argument_list|(
name|gdt_oem_str_record_t
argument_list|)
argument_list|)
condition|)
block|{
name|strncpy
argument_list|(
name|gdt
operator|->
name|oem_name
argument_list|,
operator|(
operator|(
name|gdt_oem_str_record_t
operator|*
operator|)
name|gccb
operator|->
name|gc_scratch
operator|)
operator|->
name|text
operator|.
name|scsi_host_drive_inquiry_vendor_id
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|oem_name
index|[
literal|7
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* Old method, based on PCI ID */
if|if
condition|(
name|gdt
operator|->
name|sc_vendor
operator|==
name|INTEL_VENDOR_ID
condition|)
name|strcpy
argument_list|(
name|gdt
operator|->
name|oem_name
argument_list|,
literal|"Intel  "
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|gdt
operator|->
name|oem_name
argument_list|,
literal|"ICP    "
argument_list|)
expr_stmt|;
block|}
comment|/* Scan for cache devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cdev_cnt
operator|&&
name|i
operator|<
name|GDT_MAX_HDRIVES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_CACHESERVICE
argument_list|,
name|GDT_INFO
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|gdt
operator|->
name|sc_hdr
index|[
name|i
index|]
operator|.
name|hd_present
operator|=
literal|1
expr_stmt|;
name|gdt
operator|->
name|sc_hdr
index|[
name|i
index|]
operator|.
name|hd_size
operator|=
name|gdt
operator|->
name|sc_info
expr_stmt|;
comment|/*              * Evaluate mapping (sectors per head, heads per cyl)              */
name|gdt
operator|->
name|sc_hdr
index|[
name|i
index|]
operator|.
name|hd_size
operator|&=
operator|~
name|GDT_SECS32
expr_stmt|;
if|if
condition|(
name|gdt
operator|->
name|sc_info2
operator|==
literal|0
condition|)
name|gdt_eval_mapping
argument_list|(
name|gdt
operator|->
name|sc_hdr
index|[
name|i
index|]
operator|.
name|hd_size
argument_list|,
operator|&
name|drv_cyls
argument_list|,
operator|&
name|drv_hds
argument_list|,
operator|&
name|drv_secs
argument_list|)
expr_stmt|;
else|else
block|{
name|drv_hds
operator|=
name|gdt
operator|->
name|sc_info2
operator|&
literal|0xff
expr_stmt|;
name|drv_secs
operator|=
operator|(
name|gdt
operator|->
name|sc_info2
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|drv_cyls
operator|=
name|gdt
operator|->
name|sc_hdr
index|[
name|i
index|]
operator|.
name|hd_size
operator|/
name|drv_hds
operator|/
name|drv_secs
expr_stmt|;
block|}
name|gdt
operator|->
name|sc_hdr
index|[
name|i
index|]
operator|.
name|hd_heads
operator|=
name|drv_hds
expr_stmt|;
name|gdt
operator|->
name|sc_hdr
index|[
name|i
index|]
operator|.
name|hd_secs
operator|=
name|drv_secs
expr_stmt|;
comment|/* Round the size */
name|gdt
operator|->
name|sc_hdr
index|[
name|i
index|]
operator|.
name|hd_size
operator|=
name|drv_cyls
operator|*
name|drv_hds
operator|*
name|drv_secs
expr_stmt|;
if|if
condition|(
name|gdt_internal_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_CACHESERVICE
argument_list|,
name|GDT_DEVTYPE
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|gdt
operator|->
name|sc_hdr
index|[
name|i
index|]
operator|.
name|hd_devtype
operator|=
name|gdt
operator|->
name|sc_info
expr_stmt|;
block|}
block|}
name|GDT_DPRINTF
argument_list|(
name|GDT_D_INIT
argument_list|,
operator|(
literal|"dpmem %x %d-bus %d cache device%s\n"
operator|,
name|gdt
operator|->
name|sc_dpmembase
operator|,
name|gdt
operator|->
name|sc_bus_cnt
operator|,
name|cdev_cnt
operator|,
name|cdev_cnt
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|)
expr_stmt|;
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
name|gdt_cnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|iir_free
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_INIT
argument_list|,
operator|(
literal|"iir_free()\n"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gdt
operator|->
name|sc_init_level
condition|)
block|{
default|default:
name|gdt_destroy_dev
argument_list|(
name|gdt
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
for|for
control|(
name|i
operator|=
name|GDT_MAXCMDS
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|gdt
operator|->
name|sc_gccbs
index|[
name|i
index|]
operator|.
name|gc_map_flag
condition|)
name|bus_dmamap_destroy
argument_list|(
name|gdt
operator|->
name|sc_buffer_dmat
argument_list|,
name|gdt
operator|->
name|sc_gccbs
index|[
name|i
index|]
operator|.
name|gc_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|gdt
operator|->
name|sc_gccb_dmat
argument_list|,
name|gdt
operator|->
name|sc_gccb_dmamap
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|bus_dmamem_free
argument_list|(
name|gdt
operator|->
name|sc_gccb_dmat
argument_list|,
name|gdt
operator|->
name|sc_gccbs
argument_list|,
name|gdt
operator|->
name|sc_gccb_dmamap
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|bus_dma_tag_destroy
argument_list|(
name|gdt
operator|->
name|sc_gccb_dmat
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|bus_dma_tag_destroy
argument_list|(
name|gdt
operator|->
name|sc_buffer_dmat
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|bus_dma_tag_destroy
argument_list|(
name|gdt
operator|->
name|sc_parent_dmat
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
break|break;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|gdt_softcs
argument_list|,
name|gdt
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iir_attach
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_INIT
argument_list|,
operator|(
literal|"iir_attach()\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Create the device queue for our SIM.      */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|GDT_MAXCMDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gdt
operator|->
name|sc_bus_cnt
condition|;
name|i
operator|++
control|)
block|{
comment|/*          * Construct our SIM entry          */
name|gdt
operator|->
name|sims
index|[
name|i
index|]
operator|=
name|cam_sim_alloc
argument_list|(
name|iir_action
argument_list|,
name|iir_poll
argument_list|,
literal|"iir"
argument_list|,
name|gdt
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|,
comment|/*untagged*/
literal|2
argument_list|,
comment|/*tagged*/
name|GDT_MAXCMDS
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|gdt
operator|->
name|sims
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|gdt
operator|->
name|sims
index|[
name|i
index|]
argument_list|,
comment|/*free_devq*/
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|gdt
operator|->
name|paths
index|[
name|i
index|]
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|gdt
operator|->
name|sims
index|[
name|i
index|]
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|gdt
operator|->
name|sims
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|gdt
operator|->
name|sims
index|[
name|i
index|]
argument_list|,
comment|/*free_devq*/
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|iir_shutdown
argument_list|,
name|gdt
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
comment|/* iir_watchdog(gdt); */
name|gdt
operator|->
name|sc_state
operator|=
name|GDT_NORMAL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gdt_eval_mapping
parameter_list|(
name|u_int32_t
name|size
parameter_list|,
name|int
modifier|*
name|cyls
parameter_list|,
name|int
modifier|*
name|heads
parameter_list|,
name|int
modifier|*
name|secs
parameter_list|)
block|{
operator|*
name|cyls
operator|=
name|size
operator|/
name|GDT_HEADS
operator|/
name|GDT_SECS
expr_stmt|;
if|if
condition|(
operator|*
name|cyls
operator|<
name|GDT_MAXCYLS
condition|)
block|{
operator|*
name|heads
operator|=
name|GDT_HEADS
expr_stmt|;
operator|*
name|secs
operator|=
name|GDT_SECS
expr_stmt|;
block|}
else|else
block|{
comment|/* Too high for 64 * 32 */
operator|*
name|cyls
operator|=
name|size
operator|/
name|GDT_MEDHEADS
operator|/
name|GDT_MEDSECS
expr_stmt|;
if|if
condition|(
operator|*
name|cyls
operator|<
name|GDT_MAXCYLS
condition|)
block|{
operator|*
name|heads
operator|=
name|GDT_MEDHEADS
expr_stmt|;
operator|*
name|secs
operator|=
name|GDT_MEDSECS
expr_stmt|;
block|}
else|else
block|{
comment|/* Too high for 127 * 63 */
operator|*
name|cyls
operator|=
name|size
operator|/
name|GDT_BIGHEADS
operator|/
name|GDT_BIGSECS
expr_stmt|;
operator|*
name|heads
operator|=
name|GDT_BIGHEADS
expr_stmt|;
operator|*
name|secs
operator|=
name|GDT_BIGSECS
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|gdt_wait
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|struct
name|gdt_ccb
modifier|*
name|gccb
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_INIT
argument_list|,
operator|(
literal|"gdt_wait(%p, %p, %d)\n"
operator|,
name|gdt
operator|,
name|gccb
operator|,
name|timeout
operator|)
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_state
operator||=
name|GDT_POLL_WAIT
expr_stmt|;
do|do
block|{
name|iir_intr
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdt
operator|==
name|gdt_wait_gdt
operator|&&
name|gccb
operator|->
name|gc_cmd_index
operator|==
name|gdt_wait_index
condition|)
block|{
name|rv
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|timeout
condition|)
do|;
name|gdt
operator|->
name|sc_state
operator|&=
operator|~
name|GDT_POLL_WAIT
expr_stmt|;
while|while
condition|(
name|gdt
operator|->
name|sc_test_busy
argument_list|(
name|gdt
argument_list|)
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX correct? */
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gdt_internal_cmd
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|struct
name|gdt_ccb
modifier|*
name|gccb
parameter_list|,
name|u_int8_t
name|service
parameter_list|,
name|u_int16_t
name|opcode
parameter_list|,
name|u_int32_t
name|arg1
parameter_list|,
name|u_int32_t
name|arg2
parameter_list|,
name|u_int32_t
name|arg3
parameter_list|)
block|{
name|int
name|retries
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_CMD
argument_list|,
operator|(
literal|"gdt_internal_cmd(%p, %d, %d, %d, %d, %d)\n"
operator|,
name|gdt
operator|,
name|service
operator|,
name|opcode
operator|,
name|arg1
operator|,
name|arg2
operator|,
name|arg3
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|gdt
operator|->
name|sc_cmd
argument_list|,
name|GDT_CMD_SZ
argument_list|)
expr_stmt|;
for|for
control|(
name|retries
operator|=
name|GDT_RETRIES
init|;
condition|;
control|)
block|{
name|gccb
operator|->
name|gc_service
operator|=
name|service
expr_stmt|;
name|gccb
operator|->
name|gc_flags
operator|=
name|GDT_GCF_INTERNAL
expr_stmt|;
name|gdt
operator|->
name|sc_set_sema0
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_COMMANDINDEX
argument_list|,
name|gccb
operator|->
name|gc_cmd_index
argument_list|)
expr_stmt|;
name|gdt_enc16
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_OPCODE
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|service
condition|)
block|{
case|case
name|GDT_CACHESERVICE
case|:
if|if
condition|(
name|opcode
operator|==
name|GDT_IOCTL
condition|)
block|{
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_IOCTL_SUBFUNC
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_IOCTL_CHANNEL
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|gdt_enc16
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_IOCTL_PARAM_SIZE
argument_list|,
operator|(
name|u_int16_t
operator|)
name|arg3
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_IOCTL_P_PARAM
argument_list|,
name|gdt_ccb_vtop
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|gdt_ccb
argument_list|,
name|gc_scratch
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdt_enc16
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_DEVICENO
argument_list|,
operator|(
name|u_int16_t
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_BLOCKNO
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GDT_SCSIRAWSERVICE
case|:
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_DIRECTION
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_cmd
index|[
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_BUS
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|arg2
expr_stmt|;
name|gdt
operator|->
name|sc_cmd
index|[
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_TARGET
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|arg3
expr_stmt|;
name|gdt
operator|->
name|sc_cmd
index|[
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_LUN
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|arg3
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
name|gdt
operator|->
name|sc_cmd_len
operator|=
name|GDT_CMD_SZ
expr_stmt|;
name|gdt
operator|->
name|sc_cmd_off
operator|=
literal|0
expr_stmt|;
name|gdt
operator|->
name|sc_cmd_cnt
operator|=
literal|0
expr_stmt|;
name|gdt
operator|->
name|sc_copy_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_release_event
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gdt_wait
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_POLL_TIMEOUT
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|gdt
operator|->
name|sc_status
operator|!=
name|GDT_S_BSY
operator|||
operator|--
name|retries
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|gdt
operator|->
name|sc_status
operator|==
name|GDT_S_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|gdt_ccb
modifier|*
name|gdt_get_ccb
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|)
block|{
name|struct
name|gdt_ccb
modifier|*
name|gccb
decl_stmt|;
name|int
name|lock
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_QUEUE
argument_list|,
operator|(
literal|"gdt_get_ccb(%p)\n"
operator|,
name|gdt
operator|)
argument_list|)
expr_stmt|;
name|lock
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|gccb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|gdt
operator|->
name|sc_free_gccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|gccb
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|gdt
operator|->
name|sc_free_gccb
argument_list|,
name|sle
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|gdt
operator|->
name|sc_pending_gccb
argument_list|,
name|gccb
argument_list|,
name|sle
argument_list|)
expr_stmt|;
operator|++
name|gdt_stat
operator|.
name|cmd_index_act
expr_stmt|;
if|if
condition|(
name|gdt_stat
operator|.
name|cmd_index_act
operator|>
name|gdt_stat
operator|.
name|cmd_index_max
condition|)
name|gdt_stat
operator|.
name|cmd_index_max
operator|=
name|gdt_stat
operator|.
name|cmd_index_act
expr_stmt|;
block|}
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|gccb
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gdt_free_ccb
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|struct
name|gdt_ccb
modifier|*
name|gccb
parameter_list|)
block|{
name|int
name|lock
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_QUEUE
argument_list|,
operator|(
literal|"gdt_free_ccb(%p, %p)\n"
operator|,
name|gdt
operator|,
name|gccb
operator|)
argument_list|)
expr_stmt|;
name|lock
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|gccb
operator|->
name|gc_flags
operator|=
name|GDT_GCF_UNUSED
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|gdt
operator|->
name|sc_pending_gccb
argument_list|,
name|gccb
argument_list|,
name|gdt_ccb
argument_list|,
name|sle
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|gdt
operator|->
name|sc_free_gccb
argument_list|,
name|gccb
argument_list|,
name|sle
argument_list|)
expr_stmt|;
operator|--
name|gdt_stat
operator|.
name|cmd_index_act
expr_stmt|;
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_SHUTDOWN
condition|)
name|wakeup
argument_list|(
name|gccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|gdt_ccb_vtop
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|struct
name|gdt_ccb
modifier|*
name|gccb
parameter_list|)
block|{
return|return
operator|(
name|gdt
operator|->
name|sc_gccb_busbase
operator|+
call|(
name|u_int32_t
call|)
argument_list|(
operator|(
name|caddr_t
operator|)
name|gccb
operator|-
operator|(
name|caddr_t
operator|)
name|gdt
operator|->
name|sc_gccbs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gdt_next
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|)
block|{
name|int
name|lock
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|gdt_ucmd_t
modifier|*
name|ucmd
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|int
name|next_cmd
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|struct
name|gdt_ccb
modifier|*
name|gccb
init|=
name|NULL
decl_stmt|;
name|u_int8_t
name|cmd
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_QUEUE
argument_list|,
operator|(
literal|"gdt_next(%p)\n"
operator|,
name|gdt
operator|)
argument_list|)
expr_stmt|;
name|lock
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|gdt
operator|->
name|sc_test_busy
argument_list|(
name|gdt
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_POLLING
operator|)
condition|)
block|{
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|gdt
operator|->
name|sc_test_busy
argument_list|(
name|gdt
argument_list|)
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|gdt
operator|->
name|sc_cmd_cnt
operator|=
name|gdt
operator|->
name|sc_cmd_off
operator|=
literal|0
expr_stmt|;
name|next_cmd
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* I/Os in queue? controller ready? */
if|if
condition|(
operator|!
name|TAILQ_FIRST
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ucmd_queue
argument_list|)
operator|&&
operator|!
name|TAILQ_FIRST
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ccb_queue
argument_list|)
condition|)
break|break;
comment|/* 1.: I/Os without ccb (IOCTLs) */
name|ucmd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ucmd_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucmd
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ucmd_queue
argument_list|,
name|ucmd
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gccb
operator|=
name|gdt_ioctl_cmd
argument_list|(
name|gdt
argument_list|,
name|ucmd
argument_list|,
operator|&
name|lock
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ucmd_queue
argument_list|,
name|ucmd
argument_list|,
name|links
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/* wenn mehrere Kdos. zulassen: if (!gdt_polling) continue; */
block|}
comment|/* 2.: I/Os with ccb */
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ccb_queue
argument_list|)
expr_stmt|;
comment|/* ist dann immer != NULL, da oben getestet */
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sim_ptr
expr_stmt|;
name|bus
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|target
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ccb_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
operator|--
name|gdt_stat
operator|.
name|req_queue_act
expr_stmt|;
comment|/* ccb->ccb_h.func_code is XPT_SCSI_IO */
name|GDT_DPRINTF
argument_list|(
name|GDT_D_QUEUE
argument_list|,
operator|(
literal|"XPT_SCSI_IO flags 0x%x)\n"
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|)
argument_list|)
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|ccbh
operator|=
operator|&
name|ccb
operator|->
name|ccb_h
expr_stmt|;
name|cmd
operator|=
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
expr_stmt|;
comment|/* Max CDB length is 12 bytes */
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|>
literal|12
condition|)
block|{
name|ccbh
operator|->
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
operator|--
name|gdt_stat
operator|.
name|io_count_act
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bus
operator|!=
name|gdt
operator|->
name|sc_virt_bus
condition|)
block|{
comment|/* raw service command */
if|if
condition|(
operator|(
name|gccb
operator|=
name|gdt_raw_cmd
argument_list|(
name|gdt
argument_list|,
name|ccb
argument_list|,
operator|&
name|lock
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ccb_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
operator|++
name|gdt_stat
operator|.
name|req_queue_act
expr_stmt|;
if|if
condition|(
name|gdt_stat
operator|.
name|req_queue_act
operator|>
name|gdt_stat
operator|.
name|req_queue_max
condition|)
name|gdt_stat
operator|.
name|req_queue_max
operator|=
name|gdt_stat
operator|.
name|req_queue_act
expr_stmt|;
name|next_cmd
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|target
operator|>=
name|GDT_MAX_HDRIVES
operator|||
operator|!
name|gdt
operator|->
name|sc_hdr
index|[
name|target
index|]
operator|.
name|hd_present
operator|||
name|lun
operator|!=
literal|0
condition|)
block|{
name|ccbh
operator|->
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
operator|--
name|gdt_stat
operator|.
name|io_count_act
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* cache service command */
if|if
condition|(
name|cmd
operator|==
name|READ_6
operator|||
name|cmd
operator|==
name|WRITE_6
operator|||
name|cmd
operator|==
name|READ_10
operator|||
name|cmd
operator|==
name|WRITE_10
condition|)
block|{
if|if
condition|(
operator|(
name|gccb
operator|=
name|gdt_cache_cmd
argument_list|(
name|gdt
argument_list|,
name|ccb
argument_list|,
operator|&
name|lock
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ccb_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
operator|++
name|gdt_stat
operator|.
name|req_queue_act
expr_stmt|;
if|if
condition|(
name|gdt_stat
operator|.
name|req_queue_act
operator|>
name|gdt_stat
operator|.
name|req_queue_max
condition|)
name|gdt_stat
operator|.
name|req_queue_max
operator|=
name|gdt_stat
operator|.
name|req_queue_act
expr_stmt|;
name|next_cmd
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|gdt_internal_cache_cmd
argument_list|(
name|gdt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|lock
operator|=
name|splcam
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_POLLING
operator|)
operator|||
operator|!
name|next_cmd
condition|)
break|break;
block|}
if|if
condition|(
name|gdt
operator|->
name|sc_cmd_cnt
operator|>
literal|0
condition|)
name|gdt
operator|->
name|sc_release_event
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_POLLING
operator|)
operator|&&
name|gdt
operator|->
name|sc_cmd_cnt
operator|>
literal|0
condition|)
block|{
name|gdt_wait
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|,
name|GDT_POLL_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|gdt_ccb
modifier|*
name|gdt_raw_cmd
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|gdt_ccb
modifier|*
name|gccb
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_CMD
argument_list|,
operator|(
literal|"gdt_raw_cmd(%p, %p)\n"
operator|,
name|gdt
operator|,
name|ccb
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|roundup
argument_list|(
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
operator|+
name|gdt
operator|->
name|sc_cmd_off
operator|+
name|GDT_DPMEM_COMMAND_OFFSET
operator|>
name|gdt
operator|->
name|sc_ic_all_size
condition|)
block|{
name|GDT_DPRINTF
argument_list|(
name|GDT_D_INVALID
argument_list|,
operator|(
literal|"iir%d: gdt_raw_cmd(): DPMEM overflow\n"
operator|,
name|gdt
operator|->
name|sc_hanum
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|gdt
operator|->
name|sc_cmd
argument_list|,
name|GDT_CMD_SZ
argument_list|)
expr_stmt|;
name|gccb
operator|=
name|gdt_get_ccb
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
if|if
condition|(
name|gccb
operator|==
name|NULL
condition|)
block|{
name|GDT_DPRINTF
argument_list|(
name|GDT_D_INVALID
argument_list|,
operator|(
literal|"iir%d: No free command index found\n"
operator|,
name|gdt
operator|->
name|sc_hanum
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|gccb
operator|)
return|;
block|}
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sim_ptr
expr_stmt|;
name|gccb
operator|->
name|gc_ccb
operator|=
name|ccb
expr_stmt|;
name|gccb
operator|->
name|gc_service
operator|=
name|GDT_SCSIRAWSERVICE
expr_stmt|;
name|gccb
operator|->
name|gc_flags
operator|=
name|GDT_GCF_SCSI
expr_stmt|;
if|if
condition|(
name|gdt
operator|->
name|sc_cmd_cnt
operator|==
literal|0
condition|)
name|gdt
operator|->
name|sc_set_sema0
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
name|splx
argument_list|(
operator|*
name|lock
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_COMMANDINDEX
argument_list|,
name|gccb
operator|->
name|gc_cmd_index
argument_list|)
expr_stmt|;
name|gdt_enc16
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_OPCODE
argument_list|,
name|GDT_WRITE
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_DIRECTION
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|?
name|GDT_DATA_IN
else|:
name|GDT_DATA_OUT
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SDLEN
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_CLEN
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_CMD
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_cmd
index|[
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_TARGET
index|]
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|gdt
operator|->
name|sc_cmd
index|[
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_LUN
index|]
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|gdt
operator|->
name|sc_cmd
index|[
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_BUS
index|]
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SENSE_LEN
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SENSE_DATA
argument_list|,
name|gdt_ccb_vtop
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|gdt_ccb
argument_list|,
name|gc_scratch
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * If we have any data to send with this command,      * map it into bus space.      */
comment|/* Only use S/G if there is a transfer */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* vorher unlock von splcam() ??? */
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|gdt
operator|->
name|sc_buffer_dmat
argument_list|,
name|gccb
operator|->
name|gc_dmamap
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|gdtexecuteccb
argument_list|,
name|gccb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gccb
operator|->
name|gc_state
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
comment|/* Pointer to physical buffer */
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|gdtexecuteccb
argument_list|(
name|gccb
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"iir%d: iir_action - Physical "
literal|"segment pointers unsupported"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"iir%d: iir_action - Virtual "
literal|"segment addresses unsupported"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|gdtexecuteccb
argument_list|(
name|gccb
argument_list|,
name|segs
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|gdtexecuteccb
argument_list|(
name|gccb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|lock
operator|=
name|splcam
argument_list|()
expr_stmt|;
return|return
operator|(
name|gccb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|gdt_ccb
modifier|*
name|gdt_cache_cmd
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|gdt_ccb
modifier|*
name|gccb
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|u_int8_t
modifier|*
name|cmdp
decl_stmt|;
name|u_int16_t
name|opcode
decl_stmt|;
name|u_int32_t
name|blockno
decl_stmt|,
name|blockcnt
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_CMD
argument_list|,
operator|(
literal|"gdt_cache_cmd(%p, %p)\n"
operator|,
name|gdt
operator|,
name|ccb
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|roundup
argument_list|(
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
operator|+
name|gdt
operator|->
name|sc_cmd_off
operator|+
name|GDT_DPMEM_COMMAND_OFFSET
operator|>
name|gdt
operator|->
name|sc_ic_all_size
condition|)
block|{
name|GDT_DPRINTF
argument_list|(
name|GDT_D_INVALID
argument_list|,
operator|(
literal|"iir%d: gdt_cache_cmd(): DPMEM overflow\n"
operator|,
name|gdt
operator|->
name|sc_hanum
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|gdt
operator|->
name|sc_cmd
argument_list|,
name|GDT_CMD_SZ
argument_list|)
expr_stmt|;
name|gccb
operator|=
name|gdt_get_ccb
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
if|if
condition|(
name|gccb
operator|==
name|NULL
condition|)
block|{
name|GDT_DPRINTF
argument_list|(
name|GDT_D_DEBUG
argument_list|,
operator|(
literal|"iir%d: No free command index found\n"
operator|,
name|gdt
operator|->
name|sc_hanum
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|gccb
operator|)
return|;
block|}
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sim_ptr
expr_stmt|;
name|gccb
operator|->
name|gc_ccb
operator|=
name|ccb
expr_stmt|;
name|gccb
operator|->
name|gc_service
operator|=
name|GDT_CACHESERVICE
expr_stmt|;
name|gccb
operator|->
name|gc_flags
operator|=
name|GDT_GCF_SCSI
expr_stmt|;
if|if
condition|(
name|gdt
operator|->
name|sc_cmd_cnt
operator|==
literal|0
condition|)
name|gdt
operator|->
name|sc_set_sema0
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
name|splx
argument_list|(
operator|*
name|lock
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_COMMANDINDEX
argument_list|,
name|gccb
operator|->
name|gc_cmd_index
argument_list|)
expr_stmt|;
name|cmdp
operator|=
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|opcode
operator|=
operator|(
operator|*
name|cmdp
operator|==
name|WRITE_6
operator|||
operator|*
name|cmdp
operator|==
name|WRITE_10
operator|)
condition|?
name|GDT_WRITE
else|:
name|GDT_READ
expr_stmt|;
if|if
condition|(
operator|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_SHUTDOWN
operator|)
operator|&&
name|opcode
operator|==
name|GDT_WRITE
condition|)
name|opcode
operator|=
name|GDT_WRITE_THR
expr_stmt|;
name|gdt_enc16
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_OPCODE
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|gdt_enc16
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_DEVICENO
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
operator|==
literal|6
condition|)
block|{
name|struct
name|scsi_rw_6
modifier|*
name|rw
init|=
operator|(
expr|struct
name|scsi_rw_6
operator|*
operator|)
name|cmdp
decl_stmt|;
name|blockno
operator|=
name|scsi_3btoul
argument_list|(
name|rw
operator|->
name|addr
argument_list|)
operator|&
operator|(
operator|(
name|SRW_TOPADDR
operator|<<
literal|16
operator|)
operator||
literal|0xffff
operator|)
expr_stmt|;
name|blockcnt
operator|=
name|rw
operator|->
name|length
condition|?
name|rw
operator|->
name|length
else|:
literal|0x100
expr_stmt|;
block|}
else|else
block|{
name|struct
name|scsi_rw_10
modifier|*
name|rw
init|=
operator|(
expr|struct
name|scsi_rw_10
operator|*
operator|)
name|cmdp
decl_stmt|;
name|blockno
operator|=
name|scsi_4btoul
argument_list|(
name|rw
operator|->
name|addr
argument_list|)
expr_stmt|;
name|blockcnt
operator|=
name|scsi_2btoul
argument_list|(
name|rw
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_BLOCKNO
argument_list|,
name|blockno
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_BLOCKCNT
argument_list|,
name|blockcnt
argument_list|)
expr_stmt|;
comment|/*      * If we have any data to send with this command,      * map it into bus space.      */
comment|/* Only use S/G if there is a transfer */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* vorher unlock von splcam() ??? */
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|gdt
operator|->
name|sc_buffer_dmat
argument_list|,
name|gccb
operator|->
name|gc_dmamap
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|gdtexecuteccb
argument_list|,
name|gccb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gccb
operator|->
name|gc_state
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
comment|/* Pointer to physical buffer */
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|gdtexecuteccb
argument_list|(
name|gccb
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"iir%d: iir_action - Physical "
literal|"segment pointers unsupported"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"iir%d: iir_action - Virtual "
literal|"segment addresses unsupported"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|gdtexecuteccb
argument_list|(
name|gccb
argument_list|,
name|segs
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|lock
operator|=
name|splcam
argument_list|()
expr_stmt|;
return|return
operator|(
name|gccb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|gdt_ccb
modifier|*
name|gdt_ioctl_cmd
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|gdt_ucmd_t
modifier|*
name|ucmd
parameter_list|,
name|int
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|gdt_ccb
modifier|*
name|gccb
decl_stmt|;
name|u_int32_t
name|cnt
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_DEBUG
argument_list|,
operator|(
literal|"gdt_ioctl_cmd(%p, %p)\n"
operator|,
name|gdt
operator|,
name|ucmd
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|gdt
operator|->
name|sc_cmd
argument_list|,
name|GDT_CMD_SZ
argument_list|)
expr_stmt|;
name|gccb
operator|=
name|gdt_get_ccb
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
if|if
condition|(
name|gccb
operator|==
name|NULL
condition|)
block|{
name|GDT_DPRINTF
argument_list|(
name|GDT_D_DEBUG
argument_list|,
operator|(
literal|"iir%d: No free command index found\n"
operator|,
name|gdt
operator|->
name|sc_hanum
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|gccb
operator|)
return|;
block|}
name|gccb
operator|->
name|gc_ucmd
operator|=
name|ucmd
expr_stmt|;
name|gccb
operator|->
name|gc_service
operator|=
name|ucmd
operator|->
name|service
expr_stmt|;
name|gccb
operator|->
name|gc_flags
operator|=
name|GDT_GCF_IOCTL
expr_stmt|;
comment|/* check DPMEM space, copy data buffer from user space */
if|if
condition|(
name|ucmd
operator|->
name|service
operator|==
name|GDT_CACHESERVICE
condition|)
block|{
if|if
condition|(
name|ucmd
operator|->
name|OpCode
operator|==
name|GDT_IOCTL
condition|)
block|{
name|gdt
operator|->
name|sc_cmd_len
operator|=
name|roundup
argument_list|(
name|GDT_CMD_UNION
operator|+
name|GDT_IOCTL_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|ucmd
operator|->
name|u
operator|.
name|ioctl
operator|.
name|param_size
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|GDT_SCRATCH_SZ
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: Scratch buffer too small (%d/%d)\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|,
name|GDT_SCRATCH_SZ
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
name|gdt
operator|->
name|sc_cmd_len
operator|=
name|roundup
argument_list|(
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_SG_LST
operator|+
name|GDT_SG_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|ucmd
operator|->
name|u
operator|.
name|cache
operator|.
name|BlockCnt
operator|*
name|GDT_SECTOR_SIZE
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|GDT_SCRATCH_SZ
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: Scratch buffer too small (%d/%d)\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|,
name|GDT_SCRATCH_SZ
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
name|gdt
operator|->
name|sc_cmd_len
operator|=
name|roundup
argument_list|(
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SG_LST
operator|+
name|GDT_SG_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|sdlen
expr_stmt|;
if|if
condition|(
name|cnt
operator|+
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|sense_len
operator|>
name|GDT_SCRATCH_SZ
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: Scratch buffer too small (%d/%d)\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|,
name|GDT_SCRATCH_SZ
argument_list|,
name|cnt
operator|+
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|sense_len
argument_list|)
expr_stmt|;
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
name|bcopy
argument_list|(
name|ucmd
operator|->
name|data
argument_list|,
name|gccb
operator|->
name|gc_scratch
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdt
operator|->
name|sc_cmd_off
operator|+
name|gdt
operator|->
name|sc_cmd_len
operator|+
name|GDT_DPMEM_COMMAND_OFFSET
operator|>
name|gdt
operator|->
name|sc_ic_all_size
condition|)
block|{
name|GDT_DPRINTF
argument_list|(
name|GDT_D_INVALID
argument_list|,
operator|(
literal|"iir%d: gdt_ioctl_cmd(): DPMEM overflow\n"
operator|,
name|gdt
operator|->
name|sc_hanum
operator|)
argument_list|)
expr_stmt|;
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|gdt
operator|->
name|sc_cmd_cnt
operator|==
literal|0
condition|)
name|gdt
operator|->
name|sc_set_sema0
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
name|splx
argument_list|(
operator|*
name|lock
argument_list|)
expr_stmt|;
comment|/* fill cmd structure */
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_COMMANDINDEX
argument_list|,
name|gccb
operator|->
name|gc_cmd_index
argument_list|)
expr_stmt|;
name|gdt_enc16
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_OPCODE
argument_list|,
name|ucmd
operator|->
name|OpCode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucmd
operator|->
name|service
operator|==
name|GDT_CACHESERVICE
condition|)
block|{
if|if
condition|(
name|ucmd
operator|->
name|OpCode
operator|==
name|GDT_IOCTL
condition|)
block|{
comment|/* IOCTL */
name|gdt_enc16
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_IOCTL_PARAM_SIZE
argument_list|,
name|ucmd
operator|->
name|u
operator|.
name|ioctl
operator|.
name|param_size
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_IOCTL_SUBFUNC
argument_list|,
name|ucmd
operator|->
name|u
operator|.
name|ioctl
operator|.
name|subfunc
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_IOCTL_CHANNEL
argument_list|,
name|ucmd
operator|->
name|u
operator|.
name|ioctl
operator|.
name|channel
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_IOCTL_P_PARAM
argument_list|,
name|gdt_ccb_vtop
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|gdt_ccb
argument_list|,
name|gc_scratch
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* cache service command */
name|gdt_enc16
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_DEVICENO
argument_list|,
name|ucmd
operator|->
name|u
operator|.
name|cache
operator|.
name|DeviceNo
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_BLOCKNO
argument_list|,
name|ucmd
operator|->
name|u
operator|.
name|cache
operator|.
name|BlockNo
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_BLOCKCNT
argument_list|,
name|ucmd
operator|->
name|u
operator|.
name|cache
operator|.
name|BlockCnt
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_DESTADDR
argument_list|,
literal|0xffffffffUL
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_SG_CANZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_SG_LST
operator|+
name|GDT_SG_PTR
argument_list|,
name|gdt_ccb_vtop
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|gdt_ccb
argument_list|,
name|gc_scratch
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_SG_LST
operator|+
name|GDT_SG_LEN
argument_list|,
name|ucmd
operator|->
name|u
operator|.
name|cache
operator|.
name|BlockCnt
operator|*
name|GDT_SECTOR_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* raw service command */
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_DIRECTION
argument_list|,
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|direction
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SDATA
argument_list|,
literal|0xffffffffUL
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SDLEN
argument_list|,
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|sdlen
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_CLEN
argument_list|,
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|clen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|cmd
argument_list|,
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_CMD
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_cmd
index|[
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_TARGET
index|]
operator|=
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|target
expr_stmt|;
name|gdt
operator|->
name|sc_cmd
index|[
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_LUN
index|]
operator|=
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|lun
expr_stmt|;
name|gdt
operator|->
name|sc_cmd
index|[
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_BUS
index|]
operator|=
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|bus
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SENSE_LEN
argument_list|,
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|sense_len
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SENSE_DATA
argument_list|,
name|gdt_ccb_vtop
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|gdt_ccb
argument_list|,
name|gc_scratch
index|[
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|sdlen
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SG_RANZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SG_LST
operator|+
name|GDT_SG_PTR
argument_list|,
name|gdt_ccb_vtop
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|gdt_ccb
argument_list|,
name|gc_scratch
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SG_LST
operator|+
name|GDT_SG_LEN
argument_list|,
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|sdlen
argument_list|)
expr_stmt|;
block|}
operator|*
name|lock
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|gdt_stat
operator|.
name|sg_count_act
operator|=
literal|1
expr_stmt|;
name|gdt
operator|->
name|sc_copy_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|gccb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gdt_internal_cache_cmd
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|t
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_CMD
argument_list|,
operator|(
literal|"gdt_internal_cache_cmd(%p, %p, 0x%x, %d)\n"
operator|,
name|gdt
operator|,
name|ccb
operator|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|,
name|t
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
condition|)
block|{
case|case
name|TEST_UNIT_READY
case|:
case|case
name|START_STOP
case|:
break|break;
case|case
name|REQUEST_SENSE
case|:
name|GDT_DPRINTF
argument_list|(
name|GDT_D_MISC
argument_list|,
operator|(
literal|"REQUEST_SENSE\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INQUIRY
case|:
block|{
name|struct
name|scsi_inquiry_data
modifier|*
name|inq
decl_stmt|;
name|inq
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|bzero
argument_list|(
name|inq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|)
expr_stmt|;
name|inq
operator|->
name|device
operator|=
operator|(
name|gdt
operator|->
name|sc_hdr
index|[
name|t
index|]
operator|.
name|hd_devtype
operator|&
literal|4
operator|)
condition|?
name|T_CDROM
else|:
name|T_DIRECT
expr_stmt|;
name|inq
operator|->
name|dev_qual2
operator|=
operator|(
name|gdt
operator|->
name|sc_hdr
index|[
name|t
index|]
operator|.
name|hd_devtype
operator|&
literal|1
operator|)
condition|?
literal|0x80
else|:
literal|0
expr_stmt|;
name|inq
operator|->
name|version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|inq
operator|->
name|response_format
operator|=
literal|2
expr_stmt|;
name|inq
operator|->
name|additional_length
operator|=
literal|32
expr_stmt|;
name|inq
operator|->
name|flags
operator|=
name|SID_CmdQue
operator||
name|SID_Sync
expr_stmt|;
name|strcpy
argument_list|(
name|inq
operator|->
name|vendor
argument_list|,
name|gdt
operator|->
name|oem_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|inq
operator|->
name|product
argument_list|,
literal|"Host Drive   #%02d"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|inq
operator|->
name|revision
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_SENSE_6
case|:
block|{
struct|struct
name|mpd_data
block|{
name|struct
name|scsi_mode_hdr_6
name|hd
decl_stmt|;
name|struct
name|scsi_mode_block_descr
name|bd
decl_stmt|;
name|struct
name|scsi_control_page
name|cp
decl_stmt|;
block|}
modifier|*
name|mpd
struct|;
name|u_int8_t
name|page
decl_stmt|;
name|mpd
operator|=
operator|(
expr|struct
name|mpd_data
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|bzero
argument_list|(
name|mpd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mpd_data
argument_list|)
argument_list|)
expr_stmt|;
name|mpd
operator|->
name|hd
operator|.
name|datalen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_hdr_6
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_block_descr
argument_list|)
expr_stmt|;
name|mpd
operator|->
name|hd
operator|.
name|dev_specific
operator|=
operator|(
name|gdt
operator|->
name|sc_hdr
index|[
name|t
index|]
operator|.
name|hd_devtype
operator|&
literal|2
operator|)
condition|?
literal|0x80
else|:
literal|0
expr_stmt|;
name|mpd
operator|->
name|hd
operator|.
name|block_descr_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_block_descr
argument_list|)
expr_stmt|;
name|mpd
operator|->
name|bd
operator|.
name|block_len
index|[
literal|0
index|]
operator|=
operator|(
name|GDT_SECTOR_SIZE
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|mpd
operator|->
name|bd
operator|.
name|block_len
index|[
literal|1
index|]
operator|=
operator|(
name|GDT_SECTOR_SIZE
operator|&
literal|0x0000ff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|mpd
operator|->
name|bd
operator|.
name|block_len
index|[
literal|2
index|]
operator|=
operator|(
name|GDT_SECTOR_SIZE
operator|&
literal|0x000000ff
operator|)
expr_stmt|;
name|page
operator|=
operator|(
operator|(
expr|struct
name|scsi_mode_sense_6
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
operator|)
operator|->
name|page
expr_stmt|;
switch|switch
condition|(
name|page
condition|)
block|{
default|default:
name|GDT_DPRINTF
argument_list|(
name|GDT_D_MISC
argument_list|,
operator|(
literal|"MODE_SENSE_6: page 0x%x\n"
operator|,
name|page
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|READ_CAPACITY
case|:
block|{
name|struct
name|scsi_read_capacity_data
modifier|*
name|rcd
decl_stmt|;
name|rcd
operator|=
operator|(
expr|struct
name|scsi_read_capacity_data
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|bzero
argument_list|(
name|rcd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_capacity_data
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|gdt
operator|->
name|sc_hdr
index|[
name|t
index|]
operator|.
name|hd_size
operator|-
literal|1
argument_list|,
name|rcd
operator|->
name|addr
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|GDT_SECTOR_SIZE
argument_list|,
name|rcd
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|GDT_DPRINTF
argument_list|(
name|GDT_D_MISC
argument_list|,
operator|(
literal|"gdt_internal_cache_cmd(%d) unknown\n"
operator|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
operator|--
name|gdt_stat
operator|.
name|io_count_act
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gdtmapmem
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|busaddrp
decl_stmt|;
name|busaddrp
operator|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
expr_stmt|;
operator|*
name|busaddrp
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gdtexecuteccb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|gdt_ccb
modifier|*
name|gccb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|gdt_softc
modifier|*
name|gdt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lock
decl_stmt|;
name|lock
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|gccb
operator|=
operator|(
expr|struct
name|gdt_ccb
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|gccb
operator|->
name|gc_ccb
expr_stmt|;
name|gdt
operator|=
name|cam_sim_softc
argument_list|(
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sim_ptr
argument_list|)
expr_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_CMD
argument_list|,
operator|(
literal|"gdtexecuteccb(%p, %p, %p, %d, %d)\n"
operator|,
name|gdt
operator|,
name|gccb
operator|,
name|dm_segs
operator|,
name|nseg
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|gdt_stat
operator|.
name|sg_count_act
operator|=
name|nseg
expr_stmt|;
if|if
condition|(
name|nseg
operator|>
name|gdt_stat
operator|.
name|sg_count_max
condition|)
name|gdt_stat
operator|.
name|sg_count_max
operator|=
name|nseg
expr_stmt|;
comment|/* Copy the segments into our SG list */
if|if
condition|(
name|gccb
operator|->
name|gc_service
operator|==
name|GDT_CACHESERVICE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
operator|++
name|i
control|)
block|{
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_SG_LST
operator|+
name|i
operator|*
name|GDT_SG_SZ
operator|+
name|GDT_SG_PTR
argument_list|,
name|dm_segs
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_SG_LST
operator|+
name|i
operator|*
name|GDT_SG_SZ
operator|+
name|GDT_SG_LEN
argument_list|,
name|dm_segs
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_SG_CANZ
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_DESTADDR
argument_list|,
literal|0xffffffffUL
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_cmd_len
operator|=
name|roundup
argument_list|(
name|GDT_CMD_UNION
operator|+
name|GDT_CACHE_SG_LST
operator|+
name|nseg
operator|*
name|GDT_SG_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
operator|++
name|i
control|)
block|{
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SG_LST
operator|+
name|i
operator|*
name|GDT_SG_SZ
operator|+
name|GDT_SG_PTR
argument_list|,
name|dm_segs
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SG_LST
operator|+
name|i
operator|*
name|GDT_SG_SZ
operator|+
name|GDT_SG_LEN
argument_list|,
name|dm_segs
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SG_RANZ
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SDATA
argument_list|,
literal|0xffffffffUL
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_cmd_len
operator|=
name|roundup
argument_list|(
name|GDT_CMD_UNION
operator|+
name|GDT_RAW_SG_LST
operator|+
name|nseg
operator|*
name|GDT_SG_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|gdt
operator|->
name|sc_buffer_dmat
argument_list|,
name|gccb
operator|->
name|gc_dmamap
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|?
name|BUS_DMASYNC_PREREAD
else|:
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
comment|/* We must NOT abort the command here if CAM_REQ_INPROG is not set,      * because command semaphore is already set!      */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
comment|/* timeout handling */
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|iir_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|gccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_copy_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iir_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|gdt_softc
modifier|*
name|gdt
decl_stmt|;
name|int
name|lock
decl_stmt|,
name|bus
decl_stmt|,
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|gdt
operator|=
operator|(
expr|struct
name|gdt_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_sim_ptr
operator|=
name|sim
expr_stmt|;
name|bus
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|target
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|lun
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_CMD
argument_list|,
operator|(
literal|"iir_action(%p) func 0x%x cmd 0x%x bus %d target %d lun %d\n"
operator|,
name|gdt
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|,
name|bus
operator|,
name|target
operator|,
name|lun
operator|)
argument_list|)
expr_stmt|;
operator|++
name|gdt_stat
operator|.
name|io_count_act
expr_stmt|;
if|if
condition|(
name|gdt_stat
operator|.
name|io_count_act
operator|>
name|gdt_stat
operator|.
name|io_count_max
condition|)
name|gdt_stat
operator|.
name|io_count_max
operator|=
name|gdt_stat
operator|.
name|io_count_act
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
name|lock
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ccb_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
operator|++
name|gdt_stat
operator|.
name|req_queue_act
expr_stmt|;
if|if
condition|(
name|gdt_stat
operator|.
name|req_queue_act
operator|>
name|gdt_stat
operator|.
name|req_queue_max
condition|)
name|gdt_stat
operator|.
name|req_queue_max
operator|=
name|gdt_stat
operator|.
name|req_queue_act
expr_stmt|;
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|gdt_next
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
operator|--
name|gdt_stat
operator|.
name|io_count_act
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
operator|--
name|gdt_stat
operator|.
name|io_count_act
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|u_int
name|target_mask
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|target_mask
operator|=
literal|0x01
operator|<<
name|target
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_USER_SETTINGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|cts
operator|->
name|flags
operator|=
name|CCB_TRANS_DISC_ENB
operator||
name|CCB_TRANS_TAG_ENB
expr_stmt|;
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
name|cts
operator|->
name|sync_period
operator|=
literal|25
expr_stmt|;
comment|/* 10MHz */
if|if
condition|(
name|cts
operator|->
name|sync_period
operator|!=
literal|0
condition|)
name|cts
operator|->
name|sync_offset
operator|=
literal|15
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
operator||
name|CCB_TRANS_BUS_WIDTH_VALID
operator||
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
block|}
operator|--
name|gdt_stat
operator|.
name|io_count_act
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|u_int32_t
name|secs_per_cylinder
decl_stmt|;
name|ccg
operator|=
operator|&
name|ccb
operator|->
name|ccg
expr_stmt|;
name|ccg
operator|->
name|heads
operator|=
name|gdt
operator|->
name|sc_hdr
index|[
name|target
index|]
operator|.
name|hd_heads
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
name|gdt
operator|->
name|sc_hdr
index|[
name|target
index|]
operator|.
name|hd_secs
expr_stmt|;
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
operator|--
name|gdt_stat
operator|.
name|io_count_act
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
block|{
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
operator|--
name|gdt_stat
operator|.
name|io_count_act
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
operator|--
name|gdt_stat
operator|.
name|io_count_act
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_WIDE_16
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bus
operator|==
name|gdt
operator|->
name|sc_virt_bus
condition|)
name|cpi
operator|->
name|max_target
operator|=
name|GDT_MAX_HDRIVES
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|gdt
operator|->
name|sc_class
operator|&
name|GDT_FC
condition|)
name|cpi
operator|->
name|max_target
operator|=
name|GDT_MAXID_FC
operator|-
literal|1
expr_stmt|;
else|else
name|cpi
operator|->
name|max_target
operator|=
name|GDT_MAXID
operator|-
literal|1
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|7
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|bus
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
operator|(
name|bus
operator|==
name|gdt
operator|->
name|sc_virt_bus
condition|?
literal|127
else|:
name|gdt
operator|->
name|sc_bus_id
index|[
name|bus
index|]
operator|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdt
operator|->
name|sc_vendor
operator|==
name|INTEL_VENDOR_ID
condition|)
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Intel Corp."
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
else|else
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"ICP vortex "
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
operator|--
name|gdt_stat
operator|.
name|io_count_act
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|GDT_DPRINTF
argument_list|(
name|GDT_D_INVALID
argument_list|,
operator|(
literal|"gdt_next(%p) cmd 0x%x invalid\n"
operator|,
name|gdt
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
operator|--
name|gdt_stat
operator|.
name|io_count_act
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iir_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|gdt_softc
modifier|*
name|gdt
decl_stmt|;
name|gdt
operator|=
operator|(
expr|struct
name|gdt_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_CMD
argument_list|,
operator|(
literal|"iir_poll sim %p gdt %p\n"
operator|,
name|sim
operator|,
name|gdt
operator|)
argument_list|)
expr_stmt|;
name|iir_intr
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iir_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|GDT_DPRINTF
argument_list|(
name|GDT_D_TIMEOUT
argument_list|,
operator|(
literal|"iir_timeout(%p)\n"
operator|,
name|arg
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iir_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|gdt_softc
modifier|*
name|gdt
decl_stmt|;
name|gdt
operator|=
operator|(
expr|struct
name|gdt_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_DEBUG
argument_list|,
operator|(
literal|"iir_watchdog(%p)\n"
operator|,
name|gdt
operator|)
argument_list|)
expr_stmt|;
block|{
name|int
name|ccbs
init|=
literal|0
decl_stmt|,
name|ucmds
init|=
literal|0
decl_stmt|,
name|frees
init|=
literal|0
decl_stmt|,
name|pends
init|=
literal|0
decl_stmt|;
name|struct
name|gdt_ccb
modifier|*
name|p
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|h
decl_stmt|;
name|struct
name|gdt_ucmd
modifier|*
name|u
decl_stmt|;
for|for
control|(
name|h
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ccb_queue
argument_list|)
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|TAILQ_NEXT
argument_list|(
name|h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
control|)
name|ccbs
operator|++
expr_stmt|;
for|for
control|(
name|u
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ucmd_queue
argument_list|)
init|;
name|u
operator|!=
name|NULL
condition|;
name|u
operator|=
name|TAILQ_NEXT
argument_list|(
name|u
argument_list|,
name|links
argument_list|)
control|)
name|ucmds
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|gdt
operator|->
name|sc_free_gccb
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|SLIST_NEXT
argument_list|(
name|p
argument_list|,
name|sle
argument_list|)
control|)
name|frees
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|gdt
operator|->
name|sc_pending_gccb
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|SLIST_NEXT
argument_list|(
name|p
argument_list|,
name|sle
argument_list|)
control|)
name|pends
operator|++
expr_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_TIMEOUT
argument_list|,
operator|(
literal|"ccbs %d ucmds %d frees %d pends %d\n"
operator|,
name|ccbs
operator|,
name|ucmds
operator|,
name|frees
operator|,
name|pends
operator|)
argument_list|)
expr_stmt|;
block|}
name|timeout
argument_list|(
name|iir_watchdog
argument_list|,
operator|(
name|caddr_t
operator|)
name|gdt
argument_list|,
name|hz
operator|*
literal|15
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iir_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|struct
name|gdt_softc
modifier|*
name|gdt
decl_stmt|;
name|struct
name|gdt_ccb
modifier|*
name|gccb
decl_stmt|;
name|gdt_ucmd_t
modifier|*
name|ucmd
decl_stmt|;
name|int
name|lock
decl_stmt|,
name|i
decl_stmt|;
name|gdt
operator|=
operator|(
expr|struct
name|gdt_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_CMD
argument_list|,
operator|(
literal|"iir_shutdown(%p, %d)\n"
operator|,
name|gdt
operator|,
name|howto
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iir%d: Flushing all Host Drives. Please wait ...  "
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
comment|/* allocate ucmd buffer */
name|ucmd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gdt_ucmd_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucmd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: iir_shutdown(): Cannot allocate resource\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|ucmd
argument_list|,
sizeof|sizeof
argument_list|(
name|gdt_ucmd_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* wait for pending IOs */
name|lock
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|gdt
operator|->
name|sc_state
operator|=
name|GDT_SHUTDOWN
expr_stmt|;
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gccb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|gdt
operator|->
name|sc_pending_gccb
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|void
operator|*
operator|)
name|gccb
argument_list|,
name|PCATCH
operator||
name|PRIBIO
argument_list|,
literal|"iirshw"
argument_list|,
literal|100
operator|*
name|hz
argument_list|)
expr_stmt|;
comment|/* flush */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GDT_MAX_HDRIVES
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|gdt
operator|->
name|sc_hdr
index|[
name|i
index|]
operator|.
name|hd_present
condition|)
block|{
name|ucmd
operator|->
name|service
operator|=
name|GDT_CACHESERVICE
expr_stmt|;
name|ucmd
operator|->
name|OpCode
operator|=
name|GDT_FLUSH
expr_stmt|;
name|ucmd
operator|->
name|u
operator|.
name|cache
operator|.
name|DeviceNo
operator|=
name|i
expr_stmt|;
name|lock
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ucmd_queue
argument_list|,
name|ucmd
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|ucmd
operator|->
name|complete_flag
operator|=
name|FALSE
expr_stmt|;
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|gdt_next
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ucmd
operator|->
name|complete_flag
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ucmd
argument_list|,
name|PCATCH
operator||
name|PRIBIO
argument_list|,
literal|"iirshw"
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|ucmd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iir_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|gdt_softc
modifier|*
name|gdt
init|=
name|arg
decl_stmt|;
name|struct
name|gdt_intr_ctx
name|ctx
decl_stmt|;
name|int
name|lock
init|=
literal|0
decl_stmt|;
name|struct
name|gdt_ccb
modifier|*
name|gccb
decl_stmt|;
name|gdt_ucmd_t
modifier|*
name|ucmd
decl_stmt|;
name|u_int32_t
name|cnt
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_INTR
argument_list|,
operator|(
literal|"gdt_intr(%p)\n"
operator|,
name|gdt
operator|)
argument_list|)
expr_stmt|;
comment|/* If polling and we were not called from gdt_wait, just return */
if|if
condition|(
operator|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_POLLING
operator|)
operator|&&
operator|!
operator|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_POLL_WAIT
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_POLLING
operator|)
condition|)
name|lock
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|gdt_wait_index
operator|=
literal|0
expr_stmt|;
name|ctx
operator|.
name|istatus
operator|=
name|gdt
operator|->
name|sc_get_status
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|.
name|istatus
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_POLLING
operator|)
condition|)
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_status
operator|=
name|GDT_S_NO_STATUS
expr_stmt|;
return|return;
block|}
name|gdt
operator|->
name|sc_intr
argument_list|(
name|gdt
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_status
operator|=
name|ctx
operator|.
name|cmd_status
expr_stmt|;
name|gdt
operator|->
name|sc_service
operator|=
name|ctx
operator|.
name|service
expr_stmt|;
name|gdt
operator|->
name|sc_info
operator|=
name|ctx
operator|.
name|info
expr_stmt|;
name|gdt
operator|->
name|sc_info2
operator|=
name|ctx
operator|.
name|info2
expr_stmt|;
if|if
condition|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_POLL_WAIT
condition|)
block|{
name|gdt_wait_gdt
operator|=
name|gdt
expr_stmt|;
name|gdt_wait_index
operator|=
name|ctx
operator|.
name|istatus
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|.
name|istatus
operator|==
name|GDT_ASYNCINDEX
condition|)
block|{
name|gdt_async_event
argument_list|(
name|gdt
argument_list|,
name|ctx
operator|.
name|service
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_POLLING
operator|)
condition|)
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ctx
operator|.
name|istatus
operator|==
name|GDT_SPEZINDEX
condition|)
block|{
name|GDT_DPRINTF
argument_list|(
name|GDT_D_INVALID
argument_list|,
operator|(
literal|"iir%d: Service unknown or not initialized!\n"
operator|,
name|gdt
operator|->
name|sc_hanum
operator|)
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|driver
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|driver
operator|.
name|ionode
operator|=
name|gdt
operator|->
name|sc_hanum
expr_stmt|;
name|gdt_store_event
argument_list|(
name|GDT_ES_DRIVER
argument_list|,
literal|4
argument_list|,
operator|&
name|gdt
operator|->
name|sc_dvr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_POLLING
operator|)
condition|)
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|gccb
operator|=
operator|&
name|gdt
operator|->
name|sc_gccbs
index|[
name|ctx
operator|.
name|istatus
operator|-
literal|2
index|]
expr_stmt|;
name|ctx
operator|.
name|service
operator|=
name|gccb
operator|->
name|gc_service
expr_stmt|;
switch|switch
condition|(
name|gccb
operator|->
name|gc_flags
condition|)
block|{
case|case
name|GDT_GCF_UNUSED
case|:
name|GDT_DPRINTF
argument_list|(
name|GDT_D_INVALID
argument_list|,
operator|(
literal|"iir%d: Index (%d) to unused command!\n"
operator|,
name|gdt
operator|->
name|sc_hanum
operator|,
name|ctx
operator|.
name|istatus
operator|)
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|driver
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|driver
operator|.
name|ionode
operator|=
name|gdt
operator|->
name|sc_hanum
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|driver
operator|.
name|index
operator|=
name|ctx
operator|.
name|istatus
expr_stmt|;
name|gdt_store_event
argument_list|(
name|GDT_ES_DRIVER
argument_list|,
literal|1
argument_list|,
operator|&
name|gdt
operator|->
name|sc_dvr
argument_list|)
expr_stmt|;
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
comment|/* fallthrough */
case|case
name|GDT_GCF_INTERNAL
case|:
if|if
condition|(
operator|!
operator|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_POLLING
operator|)
condition|)
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|GDT_GCF_IOCTL
case|:
name|ucmd
operator|=
name|gccb
operator|->
name|gc_ucmd
expr_stmt|;
if|if
condition|(
name|gdt
operator|->
name|sc_status
operator|==
name|GDT_S_BSY
condition|)
block|{
name|GDT_DPRINTF
argument_list|(
name|GDT_D_DEBUG
argument_list|,
operator|(
literal|"iir_intr(%p) ioctl: gccb %p busy\n"
operator|,
name|gdt
operator|,
name|gccb
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ucmd_queue
argument_list|,
name|ucmd
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_POLLING
operator|)
condition|)
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ucmd
operator|->
name|status
operator|=
name|gdt
operator|->
name|sc_status
expr_stmt|;
name|ucmd
operator|->
name|info
operator|=
name|gdt
operator|->
name|sc_info
expr_stmt|;
name|ucmd
operator|->
name|complete_flag
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ucmd
operator|->
name|service
operator|==
name|GDT_CACHESERVICE
condition|)
block|{
if|if
condition|(
name|ucmd
operator|->
name|OpCode
operator|==
name|GDT_IOCTL
condition|)
block|{
name|cnt
operator|=
name|ucmd
operator|->
name|u
operator|.
name|ioctl
operator|.
name|param_size
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
name|bcopy
argument_list|(
name|gccb
operator|->
name|gc_scratch
argument_list|,
name|ucmd
operator|->
name|data
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|=
name|ucmd
operator|->
name|u
operator|.
name|cache
operator|.
name|BlockCnt
operator|*
name|GDT_SECTOR_SIZE
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
name|bcopy
argument_list|(
name|gccb
operator|->
name|gc_scratch
argument_list|,
name|ucmd
operator|->
name|data
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cnt
operator|=
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|sdlen
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
name|bcopy
argument_list|(
name|gccb
operator|->
name|gc_scratch
argument_list|,
name|ucmd
operator|->
name|data
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucmd
operator|->
name|u
operator|.
name|raw
operator|.
name|sense_len
operator|!=
literal|0
condition|)
name|bcopy
argument_list|(
name|gccb
operator|->
name|gc_scratch
argument_list|,
name|ucmd
operator|->
name|data
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_POLLING
operator|)
condition|)
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
comment|/* wakeup */
name|wakeup
argument_list|(
name|ucmd
argument_list|)
expr_stmt|;
block|}
name|gdt_next
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gdt_free_ccb
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
name|gdt_sync_event
argument_list|(
name|gdt
argument_list|,
name|ctx
operator|.
name|service
argument_list|,
name|ctx
operator|.
name|istatus
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gdt
operator|->
name|sc_state
operator|&
name|GDT_POLLING
operator|)
condition|)
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|gdt_next
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|int
name|gdt_async_event
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|int
name|service
parameter_list|)
block|{
name|struct
name|gdt_ccb
modifier|*
name|gccb
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_INTR
argument_list|,
operator|(
literal|"gdt_async_event(%p, %d)\n"
operator|,
name|gdt
operator|,
name|service
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|==
name|GDT_SCREENSERVICE
condition|)
block|{
if|if
condition|(
name|gdt
operator|->
name|sc_status
operator|==
name|GDT_MSG_REQUEST
condition|)
block|{
while|while
condition|(
name|gdt
operator|->
name|sc_test_busy
argument_list|(
name|gdt
argument_list|)
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|gdt
operator|->
name|sc_cmd
argument_list|,
name|GDT_CMD_SZ
argument_list|)
expr_stmt|;
name|gccb
operator|=
name|gdt_get_ccb
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
if|if
condition|(
name|gccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: No free command index found\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|gccb
operator|->
name|gc_service
operator|=
name|service
expr_stmt|;
name|gccb
operator|->
name|gc_flags
operator|=
name|GDT_GCF_SCREEN
expr_stmt|;
name|gdt
operator|->
name|sc_set_sema0
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_COMMANDINDEX
argument_list|,
name|gccb
operator|->
name|gc_cmd_index
argument_list|)
expr_stmt|;
name|gdt_enc16
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_OPCODE
argument_list|,
name|GDT_READ
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_SCREEN_MSG_HANDLE
argument_list|,
name|GDT_MSG_INV_HANDLE
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_SCREEN_MSG_ADDR
argument_list|,
name|gdt_ccb_vtop
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|gdt_ccb
argument_list|,
name|gc_scratch
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_cmd_off
operator|=
literal|0
expr_stmt|;
name|gdt
operator|->
name|sc_cmd_len
operator|=
name|roundup
argument_list|(
name|GDT_CMD_UNION
operator|+
name|GDT_SCREEN_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_cmd_cnt
operator|=
literal|0
expr_stmt|;
name|gdt
operator|->
name|sc_copy_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iir%d: [PCI %d/%d] "
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|,
name|gdt
operator|->
name|sc_bus
argument_list|,
name|gdt
operator|->
name|sc_slot
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_release_event
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|gdt
operator|->
name|sc_fw_vers
operator|&
literal|0xff
operator|)
operator|>=
literal|0x1a
condition|)
block|{
name|gdt
operator|->
name|sc_dvr
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|async
operator|.
name|ionode
operator|=
name|gdt
operator|->
name|sc_hanum
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|async
operator|.
name|status
operator|=
name|gdt
operator|->
name|sc_status
expr_stmt|;
comment|/* severity and event_string already set! */
block|}
else|else
block|{
name|gdt
operator|->
name|sc_dvr
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|async
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|async
operator|.
name|ionode
operator|=
name|gdt
operator|->
name|sc_hanum
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|async
operator|.
name|service
operator|=
name|service
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|async
operator|.
name|status
operator|=
name|gdt
operator|->
name|sc_status
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|async
operator|.
name|info
operator|=
name|gdt
operator|->
name|sc_info
expr_stmt|;
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|async
operator|.
name|scsi_coord
operator|=
name|gdt
operator|->
name|sc_info2
expr_stmt|;
block|}
name|gdt_store_event
argument_list|(
name|GDT_ES_ASYNC
argument_list|,
name|service
argument_list|,
operator|&
name|gdt
operator|->
name|sc_dvr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iir%d: %s\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|,
name|gdt
operator|->
name|sc_dvr
operator|.
name|event_string
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gdt_sync_event
parameter_list|(
name|struct
name|gdt_softc
modifier|*
name|gdt
parameter_list|,
name|int
name|service
parameter_list|,
name|u_int8_t
name|index
parameter_list|,
name|struct
name|gdt_ccb
modifier|*
name|gccb
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_INTR
argument_list|,
operator|(
literal|"gdt_sync_event(%p, %d, %d, %p)\n"
operator|,
name|gdt
operator|,
name|service
operator|,
name|index
operator|,
name|gccb
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|gccb
operator|->
name|gc_ccb
expr_stmt|;
if|if
condition|(
name|service
operator|==
name|GDT_SCREENSERVICE
condition|)
block|{
name|u_int32_t
name|msg_len
decl_stmt|;
name|msg_len
operator|=
name|gdt_dec32
argument_list|(
name|gccb
operator|->
name|gc_scratch
operator|+
name|GDT_SCR_MSG_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg_len
condition|)
if|if
condition|(
operator|!
operator|(
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_SCR_MSG_ANSWER
index|]
operator|&&
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_SCR_MSG_EXT
index|]
operator|)
condition|)
block|{
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_SCR_MSG_TEXT
operator|+
name|msg_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|&
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_SCR_MSG_TEXT
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_SCR_MSG_EXT
index|]
operator|&&
operator|!
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_SCR_MSG_ANSWER
index|]
condition|)
block|{
while|while
condition|(
name|gdt
operator|->
name|sc_test_busy
argument_list|(
name|gdt
argument_list|)
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|gdt
operator|->
name|sc_cmd
argument_list|,
name|GDT_CMD_SZ
argument_list|)
expr_stmt|;
name|gccb
operator|=
name|gdt_get_ccb
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
if|if
condition|(
name|gccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: No free command index found\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|gccb
operator|->
name|gc_service
operator|=
name|service
expr_stmt|;
name|gccb
operator|->
name|gc_flags
operator|=
name|GDT_GCF_SCREEN
expr_stmt|;
name|gdt
operator|->
name|sc_set_sema0
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_COMMANDINDEX
argument_list|,
name|gccb
operator|->
name|gc_cmd_index
argument_list|)
expr_stmt|;
name|gdt_enc16
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_OPCODE
argument_list|,
name|GDT_READ
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_SCREEN_MSG_HANDLE
argument_list|,
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_SCR_MSG_HANDLE
index|]
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_SCREEN_MSG_ADDR
argument_list|,
name|gdt_ccb_vtop
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|gdt_ccb
argument_list|,
name|gc_scratch
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_cmd_off
operator|=
literal|0
expr_stmt|;
name|gdt
operator|->
name|sc_cmd_len
operator|=
name|roundup
argument_list|(
name|GDT_CMD_UNION
operator|+
name|GDT_SCREEN_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_cmd_cnt
operator|=
literal|0
expr_stmt|;
name|gdt
operator|->
name|sc_copy_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_release_event
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_SCR_MSG_ANSWER
index|]
operator|&&
name|gdt_dec32
argument_list|(
name|gccb
operator|->
name|gc_scratch
operator|+
name|GDT_SCR_MSG_ALEN
argument_list|)
condition|)
block|{
comment|/* default answers (getchar() not possible) */
if|if
condition|(
name|gdt_dec32
argument_list|(
name|gccb
operator|->
name|gc_scratch
operator|+
name|GDT_SCR_MSG_ALEN
argument_list|)
operator|==
literal|1
condition|)
block|{
name|gdt_enc32
argument_list|(
name|gccb
operator|->
name|gc_scratch
operator|+
name|GDT_SCR_MSG_ALEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gccb
operator|->
name|gc_scratch
operator|+
name|GDT_SCR_MSG_LEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_SCR_MSG_TEXT
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|gdt_enc32
argument_list|(
name|gccb
operator|->
name|gc_scratch
operator|+
name|GDT_SCR_MSG_ALEN
argument_list|,
name|gdt_dec32
argument_list|(
name|gccb
operator|->
name|gc_scratch
operator|+
name|GDT_SCR_MSG_ALEN
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gccb
operator|->
name|gc_scratch
operator|+
name|GDT_SCR_MSG_LEN
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_SCR_MSG_TEXT
index|]
operator|=
literal|1
expr_stmt|;
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_SCR_MSG_TEXT
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_SCR_MSG_EXT
index|]
operator|=
literal|0
expr_stmt|;
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_SCR_MSG_ANSWER
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|gdt
operator|->
name|sc_test_busy
argument_list|(
name|gdt
argument_list|)
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|gdt
operator|->
name|sc_cmd
argument_list|,
name|GDT_CMD_SZ
argument_list|)
expr_stmt|;
name|gccb
operator|=
name|gdt_get_ccb
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
if|if
condition|(
name|gccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"iir%d: No free command index found\n"
argument_list|,
name|gdt
operator|->
name|sc_hanum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|gccb
operator|->
name|gc_service
operator|=
name|service
expr_stmt|;
name|gccb
operator|->
name|gc_flags
operator|=
name|GDT_GCF_SCREEN
expr_stmt|;
name|gdt
operator|->
name|sc_set_sema0
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_COMMANDINDEX
argument_list|,
name|gccb
operator|->
name|gc_cmd_index
argument_list|)
expr_stmt|;
name|gdt_enc16
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_OPCODE
argument_list|,
name|GDT_WRITE
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_SCREEN_MSG_HANDLE
argument_list|,
name|gccb
operator|->
name|gc_scratch
index|[
name|GDT_SCR_MSG_HANDLE
index|]
argument_list|)
expr_stmt|;
name|gdt_enc32
argument_list|(
name|gdt
operator|->
name|sc_cmd
operator|+
name|GDT_CMD_UNION
operator|+
name|GDT_SCREEN_MSG_ADDR
argument_list|,
name|gdt_ccb_vtop
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|gdt_ccb
argument_list|,
name|gc_scratch
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_cmd_off
operator|=
literal|0
expr_stmt|;
name|gdt
operator|->
name|sc_cmd_len
operator|=
name|roundup
argument_list|(
name|GDT_CMD_UNION
operator|+
name|GDT_SCREEN_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_cmd_cnt
operator|=
literal|0
expr_stmt|;
name|gdt
operator|->
name|sc_copy_cmd
argument_list|(
name|gdt
argument_list|,
name|gccb
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_release_event
argument_list|(
name|gdt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|untimeout
argument_list|(
name|iir_timeout
argument_list|,
name|gccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdt
operator|->
name|sc_status
operator|==
name|GDT_S_BSY
condition|)
block|{
name|GDT_DPRINTF
argument_list|(
name|GDT_D_DEBUG
argument_list|,
operator|(
literal|"gdt_sync_event(%p) gccb %p busy\n"
operator|,
name|gdt
operator|,
name|gccb
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|gdt
operator|->
name|sc_ccb_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
operator|++
name|gdt_stat
operator|.
name|req_queue_act
expr_stmt|;
if|if
condition|(
name|gdt_stat
operator|.
name|req_queue_act
operator|>
name|gdt_stat
operator|.
name|req_queue_max
condition|)
name|gdt_stat
operator|.
name|req_queue_max
operator|=
name|gdt_stat
operator|.
name|req_queue_act
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
name|bus_dmamap_sync
argument_list|(
name|gdt
operator|->
name|sc_buffer_dmat
argument_list|,
name|gccb
operator|->
name|gc_dmamap
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|?
name|BUS_DMASYNC_POSTREAD
else|:
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gdt
operator|->
name|sc_status
operator|==
name|GDT_S_OK
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
comment|/* error */
if|if
condition|(
name|gccb
operator|->
name|gc_service
operator|==
name|GDT_CACHESERVICE
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|sense_data
operator|.
name|error_code
operator|=
name|SSD_CURRENT_ERROR
operator||
name|SSD_ERRCODE_VALID
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|sense_data
operator|.
name|flags
operator|=
name|SSD_KEY_NOT_READY
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|sync
argument_list|)
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|sync
operator|.
name|ionode
operator|=
name|gdt
operator|->
name|sc_hanum
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|sync
operator|.
name|service
operator|=
name|service
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|sync
operator|.
name|status
operator|=
name|gdt
operator|->
name|sc_status
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|sync
operator|.
name|info
operator|=
name|gdt
operator|->
name|sc_info
expr_stmt|;
name|gdt
operator|->
name|sc_dvr
operator|.
name|eu
operator|.
name|sync
operator|.
name|hostdrive
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
if|if
condition|(
name|gdt
operator|->
name|sc_status
operator|>=
literal|0x8000
condition|)
name|gdt_store_event
argument_list|(
name|GDT_ES_SYNC
argument_list|,
literal|0
argument_list|,
operator|&
name|gdt
operator|->
name|sc_dvr
argument_list|)
expr_stmt|;
else|else
name|gdt_store_event
argument_list|(
name|GDT_ES_SYNC
argument_list|,
name|service
argument_list|,
operator|&
name|gdt
operator|->
name|sc_dvr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* raw service */
if|if
condition|(
name|gdt
operator|->
name|sc_status
operator|!=
name|GDT_S_RAW_SCSI
operator|||
name|gdt
operator|->
name|sc_info
operator|>=
literal|0x100
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|gdt
operator|->
name|sc_info
expr_stmt|;
name|bcopy
argument_list|(
name|gccb
operator|->
name|gc_scratch
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|--
name|gdt_stat
operator|.
name|io_count_act
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Controller event handling functions */
end_comment

begin_function
name|gdt_evt_str
modifier|*
name|gdt_store_event
parameter_list|(
name|u_int16_t
name|source
parameter_list|,
name|u_int16_t
name|idx
parameter_list|,
name|gdt_evt_data
modifier|*
name|evt
parameter_list|)
block|{
name|gdt_evt_str
modifier|*
name|e
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_MISC
argument_list|,
operator|(
literal|"gdt_store_event(%d, %d)\n"
operator|,
name|source
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|==
literal|0
condition|)
comment|/* no source -> no event */
return|return
literal|0
return|;
if|if
condition|(
name|ebuffer
index|[
name|elastidx
index|]
operator|.
name|event_source
operator|==
name|source
operator|&&
name|ebuffer
index|[
name|elastidx
index|]
operator|.
name|event_idx
operator|==
name|idx
operator|&&
operator|(
operator|(
name|evt
operator|->
name|size
operator|!=
literal|0
operator|&&
name|ebuffer
index|[
name|elastidx
index|]
operator|.
name|event_data
operator|.
name|size
operator|!=
literal|0
operator|&&
operator|!
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ebuffer
index|[
name|elastidx
index|]
operator|.
name|event_data
operator|.
name|eu
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|evt
operator|->
name|eu
argument_list|,
name|evt
operator|->
name|size
argument_list|)
operator|)
operator|||
operator|(
name|evt
operator|->
name|size
operator|==
literal|0
operator|&&
name|ebuffer
index|[
name|elastidx
index|]
operator|.
name|event_data
operator|.
name|size
operator|==
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ebuffer
index|[
name|elastidx
index|]
operator|.
name|event_data
operator|.
name|event_string
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|evt
operator|->
name|event_string
argument_list|)
operator|)
operator|)
condition|)
block|{
name|e
operator|=
operator|&
name|ebuffer
index|[
name|elastidx
index|]
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|e
operator|->
name|last_stamp
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
operator|++
name|e
operator|->
name|same_count
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ebuffer
index|[
name|elastidx
index|]
operator|.
name|event_source
operator|!=
literal|0
condition|)
block|{
comment|/* entry not free ? */
operator|++
name|elastidx
expr_stmt|;
if|if
condition|(
name|elastidx
operator|==
name|GDT_MAX_EVENTS
condition|)
name|elastidx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|elastidx
operator|==
name|eoldidx
condition|)
block|{
comment|/* reached mark ? */
operator|++
name|eoldidx
expr_stmt|;
if|if
condition|(
name|eoldidx
operator|==
name|GDT_MAX_EVENTS
condition|)
name|eoldidx
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|e
operator|=
operator|&
name|ebuffer
index|[
name|elastidx
index|]
expr_stmt|;
name|e
operator|->
name|event_source
operator|=
name|source
expr_stmt|;
name|e
operator|->
name|event_idx
operator|=
name|idx
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|e
operator|->
name|first_stamp
operator|=
name|e
operator|->
name|last_stamp
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|e
operator|->
name|same_count
operator|=
literal|1
expr_stmt|;
name|e
operator|->
name|event_data
operator|=
operator|*
name|evt
expr_stmt|;
name|e
operator|->
name|application
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
end_function

begin_function
name|int
name|gdt_read_event
parameter_list|(
name|int
name|handle
parameter_list|,
name|gdt_evt_str
modifier|*
name|estr
parameter_list|)
block|{
name|gdt_evt_str
modifier|*
name|e
decl_stmt|;
name|int
name|eindex
decl_stmt|,
name|lock
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_MISC
argument_list|,
operator|(
literal|"gdt_read_event(%d)\n"
operator|,
name|handle
operator|)
argument_list|)
expr_stmt|;
name|lock
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|handle
operator|==
operator|-
literal|1
condition|)
name|eindex
operator|=
name|eoldidx
expr_stmt|;
else|else
name|eindex
operator|=
name|handle
expr_stmt|;
name|estr
operator|->
name|event_source
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eindex
operator|>=
name|GDT_MAX_EVENTS
condition|)
block|{
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
name|eindex
return|;
block|}
name|e
operator|=
operator|&
name|ebuffer
index|[
name|eindex
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|event_source
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|eindex
operator|!=
name|elastidx
condition|)
block|{
if|if
condition|(
operator|++
name|eindex
operator|==
name|GDT_MAX_EVENTS
condition|)
name|eindex
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|eindex
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|estr
argument_list|,
name|e
argument_list|,
sizeof|sizeof
argument_list|(
name|gdt_evt_str
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
name|eindex
return|;
block|}
end_function

begin_function
name|void
name|gdt_readapp_event
parameter_list|(
name|u_int8_t
name|application
parameter_list|,
name|gdt_evt_str
modifier|*
name|estr
parameter_list|)
block|{
name|gdt_evt_str
modifier|*
name|e
decl_stmt|;
name|int
name|found
init|=
name|FALSE
decl_stmt|;
name|int
name|eindex
decl_stmt|,
name|lock
decl_stmt|;
name|GDT_DPRINTF
argument_list|(
name|GDT_D_MISC
argument_list|,
operator|(
literal|"gdt_readapp_event(%d)\n"
operator|,
name|application
operator|)
argument_list|)
expr_stmt|;
name|lock
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|eindex
operator|=
name|eoldidx
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|e
operator|=
operator|&
name|ebuffer
index|[
name|eindex
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|event_source
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|e
operator|->
name|application
operator|&
name|application
operator|)
operator|==
literal|0
condition|)
block|{
name|e
operator|->
name|application
operator||=
name|application
expr_stmt|;
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|eindex
operator|==
name|elastidx
condition|)
break|break;
if|if
condition|(
operator|++
name|eindex
operator|==
name|GDT_MAX_EVENTS
condition|)
name|eindex
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
name|memcpy
argument_list|(
name|estr
argument_list|,
name|e
argument_list|,
sizeof|sizeof
argument_list|(
name|gdt_evt_str
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|estr
operator|->
name|event_source
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gdt_clear_events
parameter_list|()
block|{
name|GDT_DPRINTF
argument_list|(
name|GDT_D_MISC
argument_list|,
operator|(
literal|"gdt_clear_events\n"
operator|)
argument_list|)
expr_stmt|;
name|eoldidx
operator|=
name|elastidx
operator|=
literal|0
expr_stmt|;
name|ebuffer
index|[
literal|0
index|]
operator|.
name|event_source
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

