begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Izumi Tsutsui.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	from: NetBSD: mc146818.c,v 1.4 2003/11/24 06:20:40 tsutsui Exp  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * mc146818 and compatible time of day chip subroutines  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/mc146818/mc146818reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mc146818/mc146818var.h>
end_include

begin_include
include|#
directive|include
file|"clock_if.h"
end_include

begin_function_decl
specifier|static
name|u_int
name|mc146818_def_getcent
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mc146818_def_setcent
parameter_list|(
name|device_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|mc146818_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mc146818_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: mutex not initialized\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_mcread
operator|==
name|NULL
condition|)
name|sc
operator|->
name|sc_mcread
operator|=
name|mc146818_def_read
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mcwrite
operator|==
name|NULL
condition|)
name|sc
operator|->
name|sc_mcwrite
operator|=
name|mc146818_def_write
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flag
operator|&
name|MC146818_NO_CENT_ADJUST
condition|)
block|{
comment|/* 		 * Note that setting MC146818_NO_CENT_ADJUST means that 		 * the century has to be stored in NVRAM somewhere. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_getcent
operator|==
name|NULL
condition|)
name|sc
operator|->
name|sc_getcent
operator|=
name|mc146818_def_getcent
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_setcent
operator|==
name|NULL
condition|)
name|sc
operator|->
name|sc_setcent
operator|=
name|mc146818_def_setcent
expr_stmt|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|sc
operator|->
name|sc_mcread
call|)
argument_list|(
name|dev
argument_list|,
name|MC_REGD
argument_list|)
operator|&
name|MC_REGD_VRT
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: battery low\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_rega
operator|=
name|MC_BASE_32_KHz
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_mcwrite
call|)
argument_list|(
name|dev
argument_list|,
name|MC_REGA
argument_list|,
name|sc
operator|->
name|sc_rega
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_regb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_regb
operator||=
operator|(
name|sc
operator|->
name|sc_flag
operator|&
name|MC146818_BCD
operator|)
condition|?
literal|0
else|:
name|MC_REGB_BINARY
expr_stmt|;
name|sc
operator|->
name|sc_regb
operator||=
operator|(
name|sc
operator|->
name|sc_flag
operator|&
name|MC146818_12HR
operator|)
condition|?
literal|0
else|:
name|MC_REGB_24HR
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_mcwrite
call|)
argument_list|(
name|dev
argument_list|,
name|MC_REGB
argument_list|,
name|sc
operator|->
name|sc_regb
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|clock_register
argument_list|(
name|dev
argument_list|,
literal|1000000
argument_list|)
expr_stmt|;
comment|/* 1 second resolution */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get time of day and convert it to a struct timespec.  * Return 0 on success, an error number otherwise.  */
end_comment

begin_function
name|int
name|mc146818_gettime
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|mc146818_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|clocktime
name|ct
decl_stmt|;
name|int
name|timeout
decl_stmt|,
name|cent
decl_stmt|,
name|year
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|1000000
expr_stmt|;
comment|/* XXX how long should we wait? */
comment|/* 	 * If MC_REGA_UIP is 0 we have at least 244us before the next 	 * update.  If it's 1 an update is imminent. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|sc
operator|->
name|sc_mcread
call|)
argument_list|(
name|dev
argument_list|,
name|MC_REGA
argument_list|)
operator|&
name|MC_REGA_UIP
operator|)
condition|)
break|break;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|timeout
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: timeout\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
define|#
directive|define
name|FROMREG
parameter_list|(
name|x
parameter_list|)
value|((sc->sc_flag& MC146818_BCD) ? FROMBCD(x) : (x))
name|ct
operator|.
name|nsec
operator|=
literal|0
expr_stmt|;
name|ct
operator|.
name|sec
operator|=
name|FROMREG
argument_list|(
call|(
modifier|*
name|sc
operator|->
name|sc_mcread
call|)
argument_list|(
name|dev
argument_list|,
name|MC_SEC
argument_list|)
argument_list|)
expr_stmt|;
name|ct
operator|.
name|min
operator|=
name|FROMREG
argument_list|(
call|(
modifier|*
name|sc
operator|->
name|sc_mcread
call|)
argument_list|(
name|dev
argument_list|,
name|MC_MIN
argument_list|)
argument_list|)
expr_stmt|;
name|ct
operator|.
name|hour
operator|=
name|FROMREG
argument_list|(
call|(
modifier|*
name|sc
operator|->
name|sc_mcread
call|)
argument_list|(
name|dev
argument_list|,
name|MC_HOUR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Map dow from 1 - 7 to 0 - 6. */
name|ct
operator|.
name|dow
operator|=
name|FROMREG
argument_list|(
call|(
modifier|*
name|sc
operator|->
name|sc_mcread
call|)
argument_list|(
name|dev
argument_list|,
name|MC_DOW
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ct
operator|.
name|day
operator|=
name|FROMREG
argument_list|(
call|(
modifier|*
name|sc
operator|->
name|sc_mcread
call|)
argument_list|(
name|dev
argument_list|,
name|MC_DOM
argument_list|)
argument_list|)
expr_stmt|;
name|ct
operator|.
name|mon
operator|=
name|FROMREG
argument_list|(
call|(
modifier|*
name|sc
operator|->
name|sc_mcread
call|)
argument_list|(
name|dev
argument_list|,
name|MC_MONTH
argument_list|)
argument_list|)
expr_stmt|;
name|year
operator|=
name|FROMREG
argument_list|(
call|(
modifier|*
name|sc
operator|->
name|sc_mcread
call|)
argument_list|(
name|dev
argument_list|,
name|MC_YEAR
argument_list|)
argument_list|)
expr_stmt|;
name|year
operator|+=
name|sc
operator|->
name|sc_year0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flag
operator|&
name|MC146818_NO_CENT_ADJUST
condition|)
block|{
name|cent
operator|=
call|(
modifier|*
name|sc
operator|->
name|sc_getcent
call|)
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|year
operator|+=
name|cent
operator|*
literal|100
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|year
operator|<
name|POSIX_BASE_YEAR
condition|)
name|year
operator|+=
literal|100
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|ct
operator|.
name|year
operator|=
name|year
expr_stmt|;
return|return
operator|(
name|clock_ct_to_ts
argument_list|(
operator|&
name|ct
argument_list|,
name|ts
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
name|int
name|mc146818_getsecs
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|secp
parameter_list|)
block|{
name|struct
name|mc146818_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|sec
decl_stmt|,
name|timeout
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|1000000
expr_stmt|;
comment|/* XXX how long should we wait? */
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|sc
operator|->
name|sc_mcread
call|)
argument_list|(
name|dev
argument_list|,
name|MC_REGA
argument_list|)
operator|&
name|MC_REGA_UIP
operator|)
condition|)
block|{
name|sec
operator|=
name|FROMREG
argument_list|(
call|(
modifier|*
name|sc
operator|->
name|sc_mcread
call|)
argument_list|(
name|dev
argument_list|,
name|MC_SEC
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|timeout
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: timeout\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
undef|#
directive|undef
name|FROMREG
operator|*
name|secp
operator|=
name|sec
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Set the time of day clock based on the value of the struct timespec arg.  * Return 0 on success, an error number otherwise.  */
end_comment

begin_function
name|int
name|mc146818_settime
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|mc146818_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|clocktime
name|ct
decl_stmt|;
name|int
name|cent
decl_stmt|,
name|year
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Accuracy is only one second. */
if|if
condition|(
name|ts
operator|->
name|tv_nsec
operator|>=
literal|500000000
condition|)
name|ts
operator|->
name|tv_sec
operator|++
expr_stmt|;
name|ts
operator|->
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|clock_ts_to_ct
argument_list|(
name|ts
argument_list|,
operator|&
name|ct
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
comment|/* Disable RTC updates and interrupts (if enabled). */
call|(
modifier|*
name|sc
operator|->
name|sc_mcwrite
call|)
argument_list|(
name|dev
argument_list|,
name|MC_REGB
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|sc_regb
operator|&
operator|(
name|MC_REGB_BINARY
operator||
name|MC_REGB_24HR
operator|)
operator|)
operator||
name|MC_REGB_SET
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|TOREG
parameter_list|(
name|x
parameter_list|)
value|((sc->sc_flag& MC146818_BCD) ? TOBCD(x) : (x))
call|(
modifier|*
name|sc
operator|->
name|sc_mcwrite
call|)
argument_list|(
name|dev
argument_list|,
name|MC_SEC
argument_list|,
name|TOREG
argument_list|(
name|ct
operator|.
name|sec
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_mcwrite
call|)
argument_list|(
name|dev
argument_list|,
name|MC_MIN
argument_list|,
name|TOREG
argument_list|(
name|ct
operator|.
name|min
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_mcwrite
call|)
argument_list|(
name|dev
argument_list|,
name|MC_HOUR
argument_list|,
name|TOREG
argument_list|(
name|ct
operator|.
name|hour
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Map dow from 0 - 6 to 1 - 7. */
call|(
modifier|*
name|sc
operator|->
name|sc_mcwrite
call|)
argument_list|(
name|dev
argument_list|,
name|MC_DOW
argument_list|,
name|TOREG
argument_list|(
name|ct
operator|.
name|dow
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_mcwrite
call|)
argument_list|(
name|dev
argument_list|,
name|MC_DOM
argument_list|,
name|TOREG
argument_list|(
name|ct
operator|.
name|day
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_mcwrite
call|)
argument_list|(
name|dev
argument_list|,
name|MC_MONTH
argument_list|,
name|TOREG
argument_list|(
name|ct
operator|.
name|mon
argument_list|)
argument_list|)
expr_stmt|;
name|year
operator|=
name|ct
operator|.
name|year
operator|-
name|sc
operator|->
name|sc_year0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flag
operator|&
name|MC146818_NO_CENT_ADJUST
condition|)
block|{
name|cent
operator|=
name|year
operator|/
literal|100
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_setcent
call|)
argument_list|(
name|dev
argument_list|,
name|cent
argument_list|)
expr_stmt|;
name|year
operator|-=
name|cent
operator|*
literal|100
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|year
operator|>
literal|99
condition|)
name|year
operator|-=
literal|100
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_mcwrite
call|)
argument_list|(
name|dev
argument_list|,
name|MC_YEAR
argument_list|,
name|TOREG
argument_list|(
name|year
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reenable RTC updates and interrupts. */
call|(
modifier|*
name|sc
operator|->
name|sc_mcwrite
call|)
argument_list|(
name|dev
argument_list|,
name|MC_REGB
argument_list|,
name|sc
operator|->
name|sc_regb
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|TOREG
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MC_ADDR
value|0
end_define

begin_define
define|#
directive|define
name|MC_DATA
value|1
end_define

begin_function
name|u_int
name|mc146818_def_read
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|reg
parameter_list|)
block|{
name|struct
name|mc146818_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_bst
argument_list|,
name|sc
operator|->
name|sc_bsh
argument_list|,
name|MC_ADDR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_bst
argument_list|,
name|sc
operator|->
name|sc_bsh
argument_list|,
name|MC_DATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mc146818_def_write
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|u_int
name|val
parameter_list|)
block|{
name|struct
name|mc146818_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_bst
argument_list|,
name|sc
operator|->
name|sc_bsh
argument_list|,
name|MC_ADDR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_bst
argument_list|,
name|sc
operator|->
name|sc_bsh
argument_list|,
name|MC_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MC_ADDR
end_undef

begin_undef
undef|#
directive|undef
name|MC_DATA
end_undef

begin_comment
comment|/*  * Looks like it's common even across platforms to store the century at  * 0x32 in the NVRAM of the mc146818.  */
end_comment

begin_define
define|#
directive|define
name|MC_CENT
value|0x32
end_define

begin_function
specifier|static
name|u_int
name|mc146818_def_getcent
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mc146818_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
modifier|*
name|sc
operator|->
name|sc_mcread
call|)
argument_list|(
name|dev
argument_list|,
name|MC_CENT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mc146818_def_setcent
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|cent
parameter_list|)
block|{
name|struct
name|mc146818_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_mcwrite
call|)
argument_list|(
name|dev
argument_list|,
name|MC_CENT
argument_list|,
name|cent
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MC_CENT
end_undef

end_unit

