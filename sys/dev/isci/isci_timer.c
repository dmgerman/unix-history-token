begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/isci/isci.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_user_callback.h>
end_include

begin_function
specifier|static
name|void
name|isci_timer_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ISCI_TIMER
modifier|*
name|timer
init|=
operator|(
expr|struct
name|ISCI_TIMER
operator|*
operator|)
name|arg
decl_stmt|;
name|isci_log_message
argument_list|(
literal|3
argument_list|,
literal|"TIMER"
argument_list|,
literal|"timeout %p\n"
argument_list|,
name|timer
argument_list|)
expr_stmt|;
comment|/* callout_stop() will *not* keep the timer from running if it is 	 *  pending.  callout_drain() cannot be called from interrupt context, 	 *  because it may cause thread to sleep which is not allowed in 	 *  interrupt context.  So instead, check the is_started flag to see if 	 *  the timer routine should actually be run or not. 	 */
if|if
condition|(
name|timer
operator|->
name|is_started
operator|==
name|TRUE
condition|)
name|timer
operator|->
name|callback
argument_list|(
name|timer
operator|->
name|cookie
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to start the supplied timer.  *  * @warning All timers in the system started by the SCI Framework are one  *          shot timers.  Therefore, the SCI user should make sure that it  *          removes the timer from it's list when a timer actually fires.  *          Additionally, SCI Framework user's should be able to handle  *          calls from the SCI Framework to stop a timer that may already  *          be stopped.  *  * @param[in]  controller This parameter specifies the controller with  *             which this timer is to associated.  * @param[in]  timer This parameter specifies the timer to be started.  * @param[in]  milliseconds This parameter specifies the number of  *             milliseconds for which to stall.  The operating system driver  *             is allowed to round this value up where necessary.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_cb_timer_start
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|void
modifier|*
name|timer
parameter_list|,
name|uint32_t
name|milliseconds
parameter_list|)
block|{
name|struct
name|ISCI_TIMER
modifier|*
name|isci_timer
init|=
operator|(
expr|struct
name|ISCI_TIMER
operator|*
operator|)
name|timer
decl_stmt|;
name|isci_timer
operator|->
name|is_started
operator|=
name|TRUE
expr_stmt|;
name|isci_log_message
argument_list|(
literal|3
argument_list|,
literal|"TIMER"
argument_list|,
literal|"start %p %d\n"
argument_list|,
name|timer
argument_list|,
name|milliseconds
argument_list|)
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|isci_timer
operator|->
name|callout
argument_list|,
name|SBT_1MS
operator|*
name|milliseconds
argument_list|,
literal|0
argument_list|,
name|isci_timer_timeout
argument_list|,
name|timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to stop the supplied timer.  *  * @param[in]  controller This parameter specifies the controller with  *             which this timer is to associated.  * @param[in]  timer This parameter specifies the timer to be stopped.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_cb_timer_stop
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|void
modifier|*
name|timer
parameter_list|)
block|{
name|struct
name|ISCI_TIMER
modifier|*
name|isci_timer
init|=
operator|(
expr|struct
name|ISCI_TIMER
operator|*
operator|)
name|timer
decl_stmt|;
name|isci_log_message
argument_list|(
literal|3
argument_list|,
literal|"TIMER"
argument_list|,
literal|"stop %p\n"
argument_list|,
name|timer
argument_list|)
expr_stmt|;
name|isci_timer
operator|->
name|is_started
operator|=
name|FALSE
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|isci_timer
operator|->
name|callout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to create a timer and provide  *        a handle for this timer for use in further timer interactions.  *  * @warning The "timer_callback" method should be executed in a mutually  *          exlusive manner from the controller completion handler  *          handler (refer to scic_controller_get_handler_methods()).  *  * @param[in]  timer_callback This parameter specifies the callback method  *             to be invoked whenever the timer expires.  * @param[in]  controller This parameter specifies the controller with  *             which this timer is to be associated.  * @param[in]  cookie This parameter specifies a piece of information that  *             the user must retain.  This cookie is to be supplied by the  *             user anytime a timeout occurs for the created timer.  *  * @return This method returns a handle to a timer object created by the  *         user.  The handle will be utilized for all further interactions  *         relating to this timer.  */
end_comment

begin_function
name|void
modifier|*
name|scif_cb_timer_create
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|scif_controller
parameter_list|,
name|SCI_TIMER_CALLBACK_T
name|timer_callback
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|ISCI_CONTROLLER
modifier|*
name|isci_controller
init|=
operator|(
expr|struct
name|ISCI_CONTROLLER
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|scif_controller
argument_list|)
decl_stmt|;
name|struct
name|ISCI_TIMER
modifier|*
name|timer
decl_stmt|;
name|sci_pool_get
argument_list|(
name|isci_controller
operator|->
name|timer_pool
argument_list|,
name|timer
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|timer
operator|->
name|callout
argument_list|,
operator|&
name|isci_controller
operator|->
name|lock
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|timer
operator|->
name|callback
operator|=
name|timer_callback
expr_stmt|;
name|timer
operator|->
name|cookie
operator|=
name|cookie
expr_stmt|;
name|timer
operator|->
name|is_started
operator|=
name|FALSE
expr_stmt|;
name|isci_log_message
argument_list|(
literal|3
argument_list|,
literal|"TIMER"
argument_list|,
literal|"create %p %p %p\n"
argument_list|,
name|timer
argument_list|,
name|timer_callback
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
return|return
operator|(
name|timer
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to destroy the supplied timer.  *  * @param[in]  controller This parameter specifies the controller with  *             which this timer is to associated.  * @param[in]  timer This parameter specifies the timer to be destroyed.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_cb_timer_destroy
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|scif_controller
parameter_list|,
name|void
modifier|*
name|timer_handle
parameter_list|)
block|{
name|struct
name|ISCI_CONTROLLER
modifier|*
name|isci_controller
init|=
operator|(
expr|struct
name|ISCI_CONTROLLER
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|scif_controller
argument_list|)
decl_stmt|;
name|scif_cb_timer_stop
argument_list|(
name|scif_controller
argument_list|,
name|timer_handle
argument_list|)
expr_stmt|;
name|sci_pool_put
argument_list|(
name|isci_controller
operator|->
name|timer_pool
argument_list|,
operator|(
expr|struct
name|ISCI_TIMER
operator|*
operator|)
name|timer_handle
argument_list|)
expr_stmt|;
name|isci_log_message
argument_list|(
literal|3
argument_list|,
literal|"TIMER"
argument_list|,
literal|"destroy %p\n"
argument_list|,
name|timer_handle
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

