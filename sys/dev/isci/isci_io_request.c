begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/isci/isci.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_sas.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_io_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_user_callback.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_io_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_user_callback.h>
end_include

begin_comment
comment|/**  * @brief This user callback will inform the user that an IO request has  *        completed.  *  * @param[in]  controller This parameter specifies the controller on  *             which the IO request is completing.  * @param[in]  remote_device This parameter specifies the remote device on  *             which this request is completing.  * @param[in]  io_request This parameter specifies the IO request that has  *             completed.  * @param[in]  completion_status This parameter specifies the results of  *             the IO request operation.  SCI_IO_SUCCESS indicates  *             successful completion.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_cb_io_request_complete
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|scif_controller
parameter_list|,
name|SCI_REMOTE_DEVICE_HANDLE_T
name|remote_device
parameter_list|,
name|SCI_IO_REQUEST_HANDLE_T
name|io_request
parameter_list|,
name|SCI_IO_STATUS
name|completion_status
parameter_list|)
block|{
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|isci_request
init|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|io_request
argument_list|)
decl_stmt|;
name|scif_controller_complete_io
argument_list|(
name|scif_controller
argument_list|,
name|remote_device
argument_list|,
name|io_request
argument_list|)
expr_stmt|;
name|isci_io_request_complete
argument_list|(
name|scif_controller
argument_list|,
name|remote_device
argument_list|,
name|isci_request
argument_list|,
name|completion_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isci_io_request_complete
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|scif_controller
parameter_list|,
name|SCI_REMOTE_DEVICE_HANDLE_T
name|remote_device
parameter_list|,
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|isci_request
parameter_list|,
name|SCI_IO_STATUS
name|completion_status
parameter_list|)
block|{
name|struct
name|ISCI_CONTROLLER
modifier|*
name|isci_controller
decl_stmt|;
name|struct
name|ISCI_REMOTE_DEVICE
modifier|*
name|isci_remote_device
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|BOOL
name|complete_ccb
decl_stmt|;
name|complete_ccb
operator|=
name|TRUE
expr_stmt|;
name|isci_controller
operator|=
operator|(
expr|struct
name|ISCI_CONTROLLER
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|scif_controller
argument_list|)
expr_stmt|;
name|isci_remote_device
operator|=
operator|(
expr|struct
name|ISCI_REMOTE_DEVICE
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|remote_device
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|isci_request
operator|->
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
switch|switch
condition|(
name|completion_status
condition|)
block|{
case|case
name|SCI_IO_SUCCESS
case|:
case|case
name|SCI_IO_SUCCESS_COMPLETE_BEFORE_START
case|:
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|900026
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SMP_IO
condition|)
block|{
name|void
modifier|*
name|smp_response
init|=
name|scif_io_request_get_response_iu_address
argument_list|(
name|isci_request
operator|->
name|sci_object
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ccb
operator|->
name|smpio
operator|.
name|smp_response
argument_list|,
name|smp_response
argument_list|,
name|ccb
operator|->
name|smpio
operator|.
name|smp_response_len
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|SCI_IO_SUCCESS_IO_DONE_EARLY
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|scif_io_request_get_number_of_bytes_transferred
argument_list|(
name|isci_request
operator|->
name|sci_object
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCI_IO_FAILURE_RESPONSE_VALID
case|:
block|{
name|SCI_SSP_RESPONSE_IU_T
modifier|*
name|response_buffer
decl_stmt|;
name|uint32_t
name|sense_length
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|response_buffer
operator|=
operator|(
name|SCI_SSP_RESPONSE_IU_T
operator|*
operator|)
name|scif_io_request_get_response_iu_address
argument_list|(
name|isci_request
operator|->
name|sci_object
argument_list|)
expr_stmt|;
name|sense_length
operator|=
name|sci_ssp_get_sense_data_length
argument_list|(
name|response_buffer
operator|->
name|sense_data_length
argument_list|)
expr_stmt|;
name|sense_length
operator|=
name|MIN
argument_list|(
name|csio
operator|->
name|sense_len
argument_list|,
name|sense_length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
name|response_buffer
operator|->
name|data
argument_list|,
name|sense_length
argument_list|)
expr_stmt|;
name|csio
operator|->
name|sense_resid
operator|=
name|csio
operator|->
name|sense_len
operator|-
name|sense_length
expr_stmt|;
name|csio
operator|->
name|scsi_status
operator|=
name|response_buffer
operator|->
name|status
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
name|scsi_extract_sense
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|)
expr_stmt|;
name|isci_log_message
argument_list|(
literal|1
argument_list|,
literal|"ISCI"
argument_list|,
literal|"isci: bus=%x target=%x lun=%x cdb[0]=%x status=%x key=%x asc=%x ascq=%x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
name|csio
operator|->
name|scsi_status
argument_list|,
name|sense_key
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCI_IO_FAILURE_REMOTE_DEVICE_RESET_REQUIRED
case|:
name|isci_remote_device_reset
argument_list|(
name|isci_remote_device
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_TERMIO
expr_stmt|;
name|isci_log_message
argument_list|(
literal|0
argument_list|,
literal|"ISCI"
argument_list|,
literal|"isci: bus=%x target=%x lun=%x cdb[0]=%x remote device reset required\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCI_IO_FAILURE_TERMINATED
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_TERMIO
expr_stmt|;
name|isci_log_message
argument_list|(
literal|0
argument_list|,
literal|"ISCI"
argument_list|,
literal|"isci: bus=%x target=%x lun=%x cdb[0]=%x terminated\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCI_IO_FAILURE_INVALID_STATE
case|:
case|case
name|SCI_IO_FAILURE_INSUFFICIENT_RESOURCES
case|:
name|complete_ccb
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|SCI_IO_FAILURE_INVALID_REMOTE_DEVICE
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
break|break;
case|case
name|SCI_IO_FAILURE_NO_NCQ_TAG_AVAILABLE
case|:
block|{
name|struct
name|ccb_relsim
name|ccb_relsim
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|isci_controller
operator|->
name|sim
argument_list|)
argument_list|,
name|isci_remote_device
operator|->
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb_relsim
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ccb_relsim
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_REL_SIMQ
expr_stmt|;
name|ccb_relsim
operator|.
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DEV_QFREEZE
expr_stmt|;
name|ccb_relsim
operator|.
name|release_flags
operator|=
name|RELSIM_ADJUST_OPENINGS
expr_stmt|;
name|ccb_relsim
operator|.
name|openings
operator|=
name|scif_remote_device_get_max_queue_depth
argument_list|(
name|remote_device
argument_list|)
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|ccb_relsim
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|complete_ccb
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|SCI_IO_FAILURE
case|:
case|case
name|SCI_IO_FAILURE_REQUIRES_SCSI_ABORT
case|:
case|case
name|SCI_IO_FAILURE_UNSUPPORTED_PROTOCOL
case|:
case|case
name|SCI_IO_FAILURE_PROTOCOL_VIOLATION
case|:
case|case
name|SCI_IO_FAILURE_INVALID_PARAMETER_VALUE
case|:
case|case
name|SCI_IO_FAILURE_CONTROLLER_SPECIFIC_ERR
case|:
default|default:
name|isci_log_message
argument_list|(
literal|1
argument_list|,
literal|"ISCI"
argument_list|,
literal|"isci: bus=%x target=%x lun=%x cdb[0]=%x completion status=%x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
name|completion_status
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP_ERR
expr_stmt|;
break|break;
block|}
name|callout_stop
argument_list|(
operator|&
name|isci_request
operator|->
name|parent
operator|.
name|timer
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|isci_request
operator|->
name|parent
operator|.
name|dma_tag
argument_list|,
name|isci_request
operator|->
name|parent
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|isci_request
operator|->
name|parent
operator|.
name|dma_tag
argument_list|,
name|isci_request
operator|->
name|parent
operator|.
name|dma_map
argument_list|)
expr_stmt|;
name|isci_request
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|sci_pool_put
argument_list|(
name|isci_controller
operator|->
name|request_pool
argument_list|,
operator|(
expr|struct
name|ISCI_REQUEST
operator|*
operator|)
name|isci_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|complete_ccb
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
comment|/* ccb will be completed with some type of non-success 			 *  status.  So temporarily freeze the queue until the 			 *  upper layers can act on the status.  The 			 *  CAM_DEV_QFRZN flag will then release the queue 			 *  after the status is acted upon. 			 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_SIM_QUEUED
condition|)
block|{
name|KASSERT
argument_list|(
name|ccb
operator|==
name|isci_remote_device
operator|->
name|queued_ccb_in_progress
argument_list|,
operator|(
literal|"multiple internally queued ccbs in flight"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|isci_remote_device
operator|->
name|queued_ccbs
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
comment|/* 			 * This CCB that was in the queue was completed, so 			 *  set the in_progress pointer to NULL denoting that 			 *  we can retry another CCB from the queue.  We only 			 *  allow one CCB at a time from the queue to be 			 *  in progress so that we can effectively maintain 			 *  ordering. 			 */
name|isci_remote_device
operator|->
name|queued_ccb_in_progress
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|isci_remote_device
operator|->
name|frozen_lun_mask
operator|!=
literal|0
condition|)
block|{
name|isci_remote_device_release_device_queue
argument_list|(
name|isci_remote_device
argument_list|)
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|isci_controller
operator|->
name|is_frozen
operator|==
name|TRUE
condition|)
block|{
name|isci_controller
operator|->
name|is_frozen
operator|=
name|FALSE
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|isci_controller
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|isci_remote_device_freeze_lun_queue
argument_list|(
name|isci_remote_device
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_SIM_QUEUED
condition|)
block|{
name|KASSERT
argument_list|(
name|ccb
operator|==
name|isci_remote_device
operator|->
name|queued_ccb_in_progress
argument_list|,
operator|(
literal|"multiple internally queued ccbs in flight"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 *  Do nothing, CCB is already on the device's queue. 			 *   We leave it on the queue, to be retried again 			 *   next time a CCB on this device completes, or we 			 *   get a ready notification for this device. 			 */
name|isci_log_message
argument_list|(
literal|1
argument_list|,
literal|"ISCI"
argument_list|,
literal|"already queued %p %x\n"
argument_list|,
name|ccb
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|isci_remote_device
operator|->
name|queued_ccb_in_progress
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|isci_log_message
argument_list|(
literal|1
argument_list|,
literal|"ISCI"
argument_list|,
literal|"queue %p %x\n"
argument_list|,
name|ccb
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|isci_remote_device
operator|->
name|queued_ccbs
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to provide the physical  *        address for the supplied virtual address when building an  *        io request object.  *  * @param[in] controller This parameter is the core controller object  *            handle.  * @param[in] io_request This parameter is the io request object handle  *            for which the physical address is being requested.  * @param[in] virtual_address This paramter is the virtual address which  *            is to be returned as a physical address.  * @param[out] physical_address The physical address for the supplied virtual  *             address.  *  * @return None.  */
end_comment

begin_function
name|void
name|scic_cb_io_request_get_physical_address
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_IO_REQUEST_HANDLE_T
name|io_request
parameter_list|,
name|void
modifier|*
name|virtual_address
parameter_list|,
name|SCI_PHYSICAL_ADDRESS
modifier|*
name|physical_address
parameter_list|)
block|{
name|SCI_IO_REQUEST_HANDLE_T
name|scif_request
init|=
name|sci_object_get_association
argument_list|(
name|io_request
argument_list|)
decl_stmt|;
name|struct
name|ISCI_REQUEST
modifier|*
name|isci_request
init|=
name|sci_object_get_association
argument_list|(
name|scif_request
argument_list|)
decl_stmt|;
if|if
condition|(
name|isci_request
operator|!=
name|NULL
condition|)
block|{
comment|/* isci_request is not NULL, meaning this is a request initiated 		 *  by CAM or the isci layer (i.e. device reset for I/O 		 *  timeout).  Therefore we can calculate the physical address 		 *  based on the address we stored in the struct ISCI_REQUEST 		 *  object. 		 */
operator|*
name|physical_address
operator|=
name|isci_request
operator|->
name|physical_address
operator|+
operator|(
name|uintptr_t
operator|)
name|virtual_address
operator|-
operator|(
name|uintptr_t
operator|)
name|isci_request
expr_stmt|;
block|}
else|else
block|{
comment|/* isci_request is NULL, meaning this is a request generated 		 *  internally by SCIL (i.e. for SMP requests or NCQ error 		 *  recovery).  Therefore we calculate the physical address 		 *  based on the controller's uncached controller memory buffer, 		 *  since we know that this is what SCIL uses for internal 		 *  framework requests. 		 */
name|SCI_CONTROLLER_HANDLE_T
name|scif_controller
init|=
operator|(
name|SCI_CONTROLLER_HANDLE_T
operator|)
name|sci_object_get_association
argument_list|(
name|controller
argument_list|)
decl_stmt|;
name|struct
name|ISCI_CONTROLLER
modifier|*
name|isci_controller
init|=
operator|(
expr|struct
name|ISCI_CONTROLLER
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|scif_controller
argument_list|)
decl_stmt|;
name|U64
name|virt_addr_offset
init|=
operator|(
name|uintptr_t
operator|)
name|virtual_address
operator|-
operator|(
name|U64
operator|)
name|isci_controller
operator|->
name|uncached_controller_memory
operator|.
name|virtual_address
decl_stmt|;
operator|*
name|physical_address
operator|=
name|isci_controller
operator|->
name|uncached_controller_memory
operator|.
name|physical_address
operator|+
name|virt_addr_offset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to provide the address for  *        the command descriptor block (CDB) associated with this IO request.  *  * @param[in] scif_user_io_request This parameter points to the user's  *            IO request object.  It is a cookie that allows the user to  *            provide the necessary information for this callback.  *  * @return This method returns the virtual address of the CDB.  */
end_comment

begin_function
name|void
modifier|*
name|scif_cb_io_request_get_cdb_address
parameter_list|(
name|void
modifier|*
name|scif_user_io_request
parameter_list|)
block|{
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|isci_request
init|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|scif_user_io_request
decl_stmt|;
return|return
operator|(
name|isci_request
operator|->
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to provide the length of  *        the command descriptor block (CDB) associated with this IO request.  *  * @param[in] scif_user_io_request This parameter points to the user's  *            IO request object.  It is a cookie that allows the user to  *            provide the necessary information for this callback.  *  * @return This method returns the length of the CDB.  */
end_comment

begin_function
name|uint32_t
name|scif_cb_io_request_get_cdb_length
parameter_list|(
name|void
modifier|*
name|scif_user_io_request
parameter_list|)
block|{
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|isci_request
init|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|scif_user_io_request
decl_stmt|;
return|return
operator|(
name|isci_request
operator|->
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to provide the Logical Unit (LUN)  *        associated with this IO request.  *  * @note The contents of the value returned from this callback are defined  *       by the protocol standard (e.g. T10 SAS specification).  Please  *       refer to the transport command information unit description  *       in the associated standard.  *  * @param[in] scif_user_io_request This parameter points to the user's  *            IO request object.  It is a cookie that allows the user to  *            provide the necessary information for this callback.  *  * @return This method returns the LUN associated with this request.  */
end_comment

begin_function
name|uint32_t
name|scif_cb_io_request_get_lun
parameter_list|(
name|void
modifier|*
name|scif_user_io_request
parameter_list|)
block|{
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|isci_request
init|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|scif_user_io_request
decl_stmt|;
return|return
operator|(
name|isci_request
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to provide the task attribute  *        associated with this IO request.  *  * @note The contents of the value returned from this callback are defined  *       by the protocol standard (e.g. T10 SAS specification).  Please  *       refer to the transport command information unit description  *       in the associated standard.  *  * @param[in] scif_user_io_request This parameter points to the user's  *            IO request object.  It is a cookie that allows the user to  *            provide the necessary information for this callback.  *  * @return This method returns the task attribute associated with this  *         IO request.  */
end_comment

begin_function
name|uint32_t
name|scif_cb_io_request_get_task_attribute
parameter_list|(
name|void
modifier|*
name|scif_user_io_request
parameter_list|)
block|{
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|isci_request
init|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|scif_user_io_request
decl_stmt|;
name|uint32_t
name|task_attribute
decl_stmt|;
if|if
condition|(
operator|(
name|isci_request
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|isci_request
operator|->
name|ccb
operator|->
name|csio
operator|.
name|tag_action
condition|)
block|{
case|case
name|MSG_HEAD_OF_Q_TAG
case|:
name|task_attribute
operator|=
name|SCI_SAS_HEAD_OF_QUEUE_ATTRIBUTE
expr_stmt|;
break|break;
case|case
name|MSG_ORDERED_Q_TAG
case|:
name|task_attribute
operator|=
name|SCI_SAS_ORDERED_ATTRIBUTE
expr_stmt|;
break|break;
case|case
name|MSG_ACA_TASK
case|:
name|task_attribute
operator|=
name|SCI_SAS_ACA_ATTRIBUTE
expr_stmt|;
break|break;
default|default:
name|task_attribute
operator|=
name|SCI_SAS_SIMPLE_ATTRIBUTE
expr_stmt|;
break|break;
block|}
else|else
name|task_attribute
operator|=
name|SCI_SAS_SIMPLE_ATTRIBUTE
expr_stmt|;
return|return
operator|(
name|task_attribute
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to provide the command priority  *        associated with this IO request.  *  * @note The contents of the value returned from this callback are defined  *       by the protocol standard (e.g. T10 SAS specification).  Please  *       refer to the transport command information unit description  *       in the associated standard.  *  * @param[in] scif_user_io_request This parameter points to the user's  *            IO request object.  It is a cookie that allows the user to  *            provide the necessary information for this callback.  *  * @return This method returns the command priority associated with this  *         IO request.  */
end_comment

begin_function
name|uint32_t
name|scif_cb_io_request_get_command_priority
parameter_list|(
name|void
modifier|*
name|scif_user_io_request
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method simply returns the virtual address associated  *        with the scsi_io and byte_offset supplied parameters.  *  * @note This callback is not utilized in the fast path.  The expectation  *       is that this method is utilized for items such as SCSI to ATA  *       translation for commands like INQUIRY, READ CAPACITY, etc.  *  * @param[in] scif_user_io_request This parameter points to the user's  *            IO request object.  It is a cookie that allows the user to  *            provide the necessary information for this callback.  * @param[in] byte_offset This parameter specifies the offset into the data  *            buffers pointed to by the SGL.  The byte offset starts at 0  *            and continues until the last byte pointed to be the last SGL  *            element.  *  * @return A virtual address pointer to the location specified by the  *         parameters.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|scif_cb_io_request_get_virtual_address_from_sgl
parameter_list|(
name|void
modifier|*
name|scif_user_io_request
parameter_list|,
name|uint32_t
name|byte_offset
parameter_list|)
block|{
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|isci_request
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|isci_request
operator|=
name|scif_user_io_request
expr_stmt|;
name|ccb
operator|=
name|isci_request
operator|->
name|ccb
expr_stmt|;
comment|/* 	 * This callback is only invoked for SCSI/ATA translation of 	 *  PIO commands such as INQUIRY and READ_CAPACITY, to allow 	 *  the driver to write the translated data directly into the 	 *  data buffer.  It is never invoked for READ/WRITE commands. 	 *  The driver currently assumes only READ/WRITE commands will 	 *  be unmapped. 	 * 	 * As a safeguard against future changes to unmapped commands, 	 *  add an explicit panic here should the DATA_MASK != VADDR. 	 *  Otherwise, we would return some garbage pointer back to the 	 *  caller which would result in a panic or more subtle data 	 *  corruption later on. 	 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_MASK
operator|)
operator|!=
name|CAM_DATA_VADDR
condition|)
name|panic
argument_list|(
literal|"%s: requesting pointer into unmapped ccb"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
operator|+
name|byte_offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to provide the number of  *        bytes to be transfered as part of this request.  *  * @param[in] scif_user_io_request This parameter points to the user's  *            IO request object.  It is a cookie that allows the user to  *            provide the necessary information for this callback.  *  * @return This method returns the number of payload data bytes to be  *         transfered for this IO request.  */
end_comment

begin_function
name|uint32_t
name|scif_cb_io_request_get_transfer_length
parameter_list|(
name|void
modifier|*
name|scif_user_io_request
parameter_list|)
block|{
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|isci_request
init|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|scif_user_io_request
decl_stmt|;
return|return
operator|(
name|isci_request
operator|->
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to provide the data direction  *        for this request.  *  * @param[in] scif_user_io_request This parameter points to the user's  *            IO request object.  It is a cookie that allows the user to  *            provide the necessary information for this callback.  *  * @return This method returns the value of SCI_IO_REQUEST_DATA_OUT,  *         SCI_IO_REQUEST_DATA_IN, or SCI_IO_REQUEST_NO_DATA.  */
end_comment

begin_function
name|SCI_IO_REQUEST_DATA_DIRECTION
name|scif_cb_io_request_get_data_direction
parameter_list|(
name|void
modifier|*
name|scif_user_io_request
parameter_list|)
block|{
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|isci_request
init|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|scif_user_io_request
decl_stmt|;
switch|switch
condition|(
name|isci_request
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
condition|)
block|{
case|case
name|CAM_DIR_IN
case|:
return|return
operator|(
name|SCI_IO_REQUEST_DATA_IN
operator|)
return|;
case|case
name|CAM_DIR_OUT
case|:
return|return
operator|(
name|SCI_IO_REQUEST_DATA_OUT
operator|)
return|;
default|default:
return|return
operator|(
name|SCI_IO_REQUEST_NO_DATA
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to provide the address  *        to where the next Scatter-Gather Element is located.  *  * Details regarding usage:  *   - Regarding the first SGE: the user should initialize an index,  *     or a pointer, prior to construction of the request that will  *     reference the very first scatter-gather element.  This is  *     important since this method is called for every scatter-gather  *     element, including the first element.  *   - Regarding the last SGE: the user should return NULL from this  *     method when this method is called and the SGL has exhausted  *     all elements.  *  * @param[in] scif_user_io_request This parameter points to the user's  *            IO request object.  It is a cookie that allows the user to  *            provide the necessary information for this callback.  * @param[in] current_sge_address This parameter specifies the address for  *            the current SGE (i.e. the one that has just processed).  * @param[out] next_sge An address specifying the location for the next scatter  *             gather element to be processed.  *  * @return None.  */
end_comment

begin_function
name|void
name|scif_cb_io_request_get_next_sge
parameter_list|(
name|void
modifier|*
name|scif_user_io_request
parameter_list|,
name|void
modifier|*
name|current_sge_address
parameter_list|,
name|void
modifier|*
modifier|*
name|next_sge
parameter_list|)
block|{
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|isci_request
init|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|scif_user_io_request
decl_stmt|;
if|if
condition|(
name|isci_request
operator|->
name|current_sge_index
operator|==
name|isci_request
operator|->
name|num_segments
condition|)
operator|*
name|next_sge
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|bus_dma_segment_t
modifier|*
name|sge
init|=
operator|&
name|isci_request
operator|->
name|sge
index|[
name|isci_request
operator|->
name|current_sge_index
index|]
decl_stmt|;
name|isci_request
operator|->
name|current_sge_index
operator|++
expr_stmt|;
operator|*
name|next_sge
operator|=
name|sge
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to provide the contents of the  *        "address" field in the Scatter-Gather Element.  *  * @param[in] scif_user_io_request This parameter points to the user's  *            IO request object.  It is a cookie that allows the user to  *            provide the necessary information for this callback.  * @param[in] sge_address This parameter specifies the address for the  *            SGE from which to retrieve the address field.  *  * @return A physical address specifying the contents of the SGE's address  *         field.  */
end_comment

begin_function
name|SCI_PHYSICAL_ADDRESS
name|scif_cb_sge_get_address_field
parameter_list|(
name|void
modifier|*
name|scif_user_io_request
parameter_list|,
name|void
modifier|*
name|sge_address
parameter_list|)
block|{
name|bus_dma_segment_t
modifier|*
name|sge
init|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|sge_address
decl_stmt|;
return|return
operator|(
operator|(
name|SCI_PHYSICAL_ADDRESS
operator|)
name|sge
operator|->
name|ds_addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to provide the contents of the  *        "length" field in the Scatter-Gather Element.  *  * @param[in] scif_user_io_request This parameter points to the user's  *            IO request object.  It is a cookie that allows the user to  *            provide the necessary information for this callback.  * @param[in] sge_address This parameter specifies the address for the  *            SGE from which to retrieve the address field.  *  * @return This method returns the length field specified inside the SGE  *         referenced by the sge_address parameter.  */
end_comment

begin_function
name|uint32_t
name|scif_cb_sge_get_length_field
parameter_list|(
name|void
modifier|*
name|scif_user_io_request
parameter_list|,
name|void
modifier|*
name|sge_address
parameter_list|)
block|{
name|bus_dma_segment_t
modifier|*
name|sge
init|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|sge_address
decl_stmt|;
return|return
operator|(
operator|(
name|uint32_t
operator|)
name|sge
operator|->
name|ds_len
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isci_request_construct
parameter_list|(
name|struct
name|ISCI_REQUEST
modifier|*
name|request
parameter_list|,
name|SCI_CONTROLLER_HANDLE_T
name|scif_controller_handle
parameter_list|,
name|bus_dma_tag_t
name|io_buffer_dma_tag
parameter_list|,
name|bus_addr_t
name|physical_address
parameter_list|)
block|{
name|request
operator|->
name|controller_handle
operator|=
name|scif_controller_handle
expr_stmt|;
name|request
operator|->
name|dma_tag
operator|=
name|io_buffer_dma_tag
expr_stmt|;
name|request
operator|->
name|physical_address
operator|=
name|physical_address
expr_stmt|;
name|bus_dmamap_create
argument_list|(
name|request
operator|->
name|dma_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|request
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|request
operator|->
name|timer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isci_io_request_construct
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|seg
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|io_request
init|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|arg
decl_stmt|;
name|SCI_REMOTE_DEVICE_HANDLE_T
modifier|*
name|device
init|=
name|io_request
operator|->
name|parent
operator|.
name|remote_device_handle
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|io_request
operator|->
name|num_segments
operator|=
name|nseg
expr_stmt|;
name|io_request
operator|->
name|sge
operator|=
name|seg
expr_stmt|;
name|ccb
operator|=
name|io_request
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|status
operator|=
name|scif_io_request_construct
argument_list|(
name|io_request
operator|->
name|parent
operator|.
name|controller_handle
argument_list|,
name|io_request
operator|->
name|parent
operator|.
name|remote_device_handle
argument_list|,
name|SCI_CONTROLLER_INVALID_IO_TAG
argument_list|,
operator|(
name|void
operator|*
operator|)
name|io_request
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|io_request
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ISCI_IO_REQUEST
argument_list|)
operator|)
argument_list|,
operator|&
name|io_request
operator|->
name|sci_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|isci_io_request_complete
argument_list|(
name|io_request
operator|->
name|parent
operator|.
name|controller_handle
argument_list|,
name|device
argument_list|,
name|io_request
argument_list|,
operator|(
name|SCI_IO_STATUS
operator|)
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
name|sci_object_set_association
argument_list|(
name|io_request
operator|->
name|sci_object
argument_list|,
name|io_request
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|io_request
operator|->
name|parent
operator|.
name|dma_tag
argument_list|,
name|io_request
operator|->
name|parent
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|SCI_STATUS
operator|)
name|scif_controller_start_io
argument_list|(
name|io_request
operator|->
name|parent
operator|.
name|controller_handle
argument_list|,
name|device
argument_list|,
name|io_request
operator|->
name|sci_object
argument_list|,
name|SCI_CONTROLLER_INVALID_IO_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|isci_io_request_complete
argument_list|(
name|io_request
operator|->
name|parent
operator|.
name|controller_handle
argument_list|,
name|device
argument_list|,
name|io_request
argument_list|,
operator|(
name|SCI_IO_STATUS
operator|)
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
name|callout_reset_sbt
argument_list|(
operator|&
name|io_request
operator|->
name|parent
operator|.
name|timer
argument_list|,
name|SBT_1MS
operator|*
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|,
literal|0
argument_list|,
name|isci_io_request_timeout
argument_list|,
name|io_request
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isci_io_request_execute_scsi_io
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|ISCI_CONTROLLER
modifier|*
name|controller
parameter_list|)
block|{
name|target_id_t
name|target_id
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
decl_stmt|;
name|struct
name|ISCI_REQUEST
modifier|*
name|request
decl_stmt|;
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|io_request
decl_stmt|;
name|struct
name|ISCI_REMOTE_DEVICE
modifier|*
name|device
init|=
name|controller
operator|->
name|remote_device
index|[
name|target_id
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sci_pool_empty
argument_list|(
name|controller
operator|->
name|request_pool
argument_list|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|controller
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|controller
operator|->
name|is_frozen
operator|=
name|TRUE
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
name|device
operator|->
name|is_resetting
operator|==
name|FALSE
argument_list|)
expr_stmt|;
name|sci_pool_get
argument_list|(
name|controller
operator|->
name|request_pool
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|io_request
operator|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|request
expr_stmt|;
name|io_request
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|io_request
operator|->
name|current_sge_index
operator|=
literal|0
expr_stmt|;
name|io_request
operator|->
name|parent
operator|.
name|remote_device_handle
operator|=
name|device
operator|->
name|sci_object
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_ccb
argument_list|(
name|io_request
operator|->
name|parent
operator|.
name|dma_tag
argument_list|,
name|io_request
operator|->
name|parent
operator|.
name|dma_map
argument_list|,
name|ccb
argument_list|,
name|isci_io_request_construct
argument_list|,
name|io_request
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* A resource shortage from BUSDMA will be automatically 	 * continued at a later point, pushing the CCB processing 	 * forward, which will in turn unfreeze the simq. 	 */
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|controller
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|isci_io_request_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|request
init|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ISCI_REMOTE_DEVICE
modifier|*
name|remote_device
init|=
operator|(
expr|struct
name|ISCI_REMOTE_DEVICE
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|request
operator|->
name|parent
operator|.
name|remote_device_handle
argument_list|)
decl_stmt|;
name|struct
name|ISCI_CONTROLLER
modifier|*
name|controller
init|=
name|remote_device
operator|->
name|domain
operator|->
name|controller
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|controller
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isci_remote_device_reset
argument_list|(
name|remote_device
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|controller
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|900026
end_if

begin_comment
comment|/**  * @brief This callback method gets the size of and pointer to the buffer  *         (if any) containing the request buffer for an SMP request.  *  * @param[in]  core_request This parameter specifies the SCI core's request  *             object associated with the SMP request.  * @param[out] smp_request_buffer This parameter returns a pointer to the  *             payload portion of the SMP request - i.e. everything after  *             the SMP request header.  *  * @return Size of the request buffer in bytes.  This does *not* include  *          the size of the SMP request header.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|smp_io_request_cb_get_request_buffer
parameter_list|(
name|SCI_IO_REQUEST_HANDLE_T
name|core_request
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|smp_request_buffer
parameter_list|)
block|{
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|isci_request
init|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|sci_object_get_association
argument_list|(
name|core_request
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|smp_request_buffer
operator|=
name|isci_request
operator|->
name|ccb
operator|->
name|smpio
operator|.
name|smp_request
operator|+
sizeof|sizeof
argument_list|(
name|SMP_REQUEST_HEADER_T
argument_list|)
expr_stmt|;
return|return
operator|(
name|isci_request
operator|->
name|ccb
operator|->
name|smpio
operator|.
name|smp_request_len
operator|-
sizeof|sizeof
argument_list|(
name|SMP_REQUEST_HEADER_T
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method gets the SMP function for an SMP request.  *  * @param[in]  core_request This parameter specifies the SCI core's request  *             object associated with the SMP request.  *  * @return SMP function for the SMP request.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|smp_io_request_cb_get_function
parameter_list|(
name|SCI_IO_REQUEST_HANDLE_T
name|core_request
parameter_list|)
block|{
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|isci_request
init|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|sci_object_get_association
argument_list|(
name|core_request
argument_list|)
argument_list|)
decl_stmt|;
name|SMP_REQUEST_HEADER_T
modifier|*
name|header
init|=
operator|(
name|SMP_REQUEST_HEADER_T
operator|*
operator|)
name|isci_request
operator|->
name|ccb
operator|->
name|smpio
operator|.
name|smp_request
decl_stmt|;
return|return
operator|(
name|header
operator|->
name|function
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method gets the SMP frame type for an SMP request.  *  * @param[in]  core_request This parameter specifies the SCI core's request  *             object associated with the SMP request.  *  * @return SMP frame type for the SMP request.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|smp_io_request_cb_get_frame_type
parameter_list|(
name|SCI_IO_REQUEST_HANDLE_T
name|core_request
parameter_list|)
block|{
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|isci_request
init|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|sci_object_get_association
argument_list|(
name|core_request
argument_list|)
argument_list|)
decl_stmt|;
name|SMP_REQUEST_HEADER_T
modifier|*
name|header
init|=
operator|(
name|SMP_REQUEST_HEADER_T
operator|*
operator|)
name|isci_request
operator|->
name|ccb
operator|->
name|smpio
operator|.
name|smp_request
decl_stmt|;
return|return
operator|(
name|header
operator|->
name|smp_frame_type
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method gets the allocated response length for an SMP request.  *  * @param[in]  core_request This parameter specifies the SCI core's request  *             object associated with the SMP request.  *  * @return Allocated response length for the SMP request.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|smp_io_request_cb_get_allocated_response_length
parameter_list|(
name|SCI_IO_REQUEST_HANDLE_T
name|core_request
parameter_list|)
block|{
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|isci_request
init|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|sci_object_get_association
argument_list|(
name|core_request
argument_list|)
argument_list|)
decl_stmt|;
name|SMP_REQUEST_HEADER_T
modifier|*
name|header
init|=
operator|(
name|SMP_REQUEST_HEADER_T
operator|*
operator|)
name|isci_request
operator|->
name|ccb
operator|->
name|smpio
operator|.
name|smp_request
decl_stmt|;
return|return
operator|(
name|header
operator|->
name|allocated_response_length
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|SCI_STATUS
name|isci_smp_request_construct
parameter_list|(
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|request
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIC_SMP_PASSTHRU_REQUEST_CALLBACKS_T
name|callbacks
decl_stmt|;
name|status
operator|=
name|scif_request_construct
argument_list|(
name|request
operator|->
name|parent
operator|.
name|controller_handle
argument_list|,
name|request
operator|->
name|parent
operator|.
name|remote_device_handle
argument_list|,
name|SCI_CONTROLLER_INVALID_IO_TAG
argument_list|,
operator|(
name|void
operator|*
operator|)
name|request
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|request
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ISCI_IO_REQUEST
argument_list|)
operator|)
argument_list|,
operator|&
name|request
operator|->
name|sci_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|callbacks
operator|.
name|scic_cb_smp_passthru_get_request
operator|=
operator|&
name|smp_io_request_cb_get_request_buffer
expr_stmt|;
name|callbacks
operator|.
name|scic_cb_smp_passthru_get_function
operator|=
operator|&
name|smp_io_request_cb_get_function
expr_stmt|;
name|callbacks
operator|.
name|scic_cb_smp_passthru_get_frame_type
operator|=
operator|&
name|smp_io_request_cb_get_frame_type
expr_stmt|;
name|callbacks
operator|.
name|scic_cb_smp_passthru_get_allocated_response_length
operator|=
operator|&
name|smp_io_request_cb_get_allocated_response_length
expr_stmt|;
comment|/* create the smp passthrough part of the io request */
name|status
operator|=
name|scic_io_request_construct_smp_pass_through
argument_list|(
name|scif_io_request_get_scic_handle
argument_list|(
name|request
operator|->
name|sci_object
argument_list|)
argument_list|,
operator|&
name|callbacks
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isci_io_request_execute_smp_io
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|ISCI_CONTROLLER
modifier|*
name|controller
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|target_id_t
name|target_id
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
decl_stmt|;
name|struct
name|ISCI_REQUEST
modifier|*
name|request
decl_stmt|;
name|struct
name|ISCI_IO_REQUEST
modifier|*
name|io_request
decl_stmt|;
name|SCI_REMOTE_DEVICE_HANDLE_T
name|smp_device_handle
decl_stmt|;
name|struct
name|ISCI_REMOTE_DEVICE
modifier|*
name|end_device
init|=
name|controller
operator|->
name|remote_device
index|[
name|target_id
index|]
decl_stmt|;
comment|/* SMP commands are sent to an end device, because SMP devices are not 	 *  exposed to the kernel.  It is our responsibility to use this method 	 *  to get the SMP device that contains the specified end device.  If 	 *  the device is direct-attached, the handle will come back NULL, and 	 *  we'll just fail the SMP_IO with DEV_NOT_THERE. 	 */
name|scif_remote_device_get_containing_device
argument_list|(
name|end_device
operator|->
name|sci_object
argument_list|,
operator|&
name|smp_device_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp_device_handle
operator|==
name|NULL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sci_pool_empty
argument_list|(
name|controller
operator|->
name|request_pool
argument_list|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|controller
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|controller
operator|->
name|is_frozen
operator|=
name|TRUE
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
name|device
operator|->
name|is_resetting
operator|==
name|FALSE
argument_list|)
expr_stmt|;
name|sci_pool_get
argument_list|(
name|controller
operator|->
name|request_pool
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|io_request
operator|=
operator|(
expr|struct
name|ISCI_IO_REQUEST
operator|*
operator|)
name|request
expr_stmt|;
name|io_request
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|io_request
operator|->
name|parent
operator|.
name|remote_device_handle
operator|=
name|smp_device_handle
expr_stmt|;
name|status
operator|=
name|isci_smp_request_construct
argument_list|(
name|io_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|isci_io_request_complete
argument_list|(
name|controller
operator|->
name|scif_controller_handle
argument_list|,
name|smp_device_handle
argument_list|,
name|io_request
argument_list|,
operator|(
name|SCI_IO_STATUS
operator|)
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
name|sci_object_set_association
argument_list|(
name|io_request
operator|->
name|sci_object
argument_list|,
name|io_request
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|SCI_STATUS
operator|)
name|scif_controller_start_io
argument_list|(
name|controller
operator|->
name|scif_controller_handle
argument_list|,
name|smp_device_handle
argument_list|,
name|io_request
operator|->
name|sci_object
argument_list|,
name|SCI_CONTROLLER_INVALID_IO_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|isci_io_request_complete
argument_list|(
name|controller
operator|->
name|scif_controller_handle
argument_list|,
name|smp_device_handle
argument_list|,
name|io_request
argument_list|,
operator|(
name|SCI_IO_STATUS
operator|)
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
name|callout_reset_sbt
argument_list|(
operator|&
name|io_request
operator|->
name|parent
operator|.
name|timer
argument_list|,
name|SBT_1MS
operator|*
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
argument_list|,
literal|0
argument_list|,
name|isci_io_request_timeout
argument_list|,
name|request
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

