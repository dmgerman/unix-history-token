begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  *  * @brief This file contains the implementation of the SCIC_SDS_CONTROLLER  *        public, protected, and private methods.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isci/types.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_port.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_phy.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_user_callback.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_pci.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_library.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_controller_registers.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_port.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_phy.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_logger.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_port_configuration_agent.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scu_constants.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scu_event_codes.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scu_completion_codes.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scu_task_context.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scu_remote_node_context.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scu_unsolicited_frame.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_pci.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sgpio.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_phy_registers.h>
end_include

begin_define
define|#
directive|define
name|SCU_CONTEXT_RAM_INIT_STALL_TIME
value|200
end_define

begin_define
define|#
directive|define
name|SCIC_SDS_CONTROLLER_MIN_TIMER_COUNT
value|3
end_define

begin_define
define|#
directive|define
name|SCIC_SDS_CONTROLLER_MAX_TIMER_COUNT
value|3
end_define

begin_define
define|#
directive|define
name|SCU_MAX_ZPT_DWORD_INDEX
value|131
end_define

begin_comment
comment|/**  * The number of milliseconds to wait for a phy to start.  */
end_comment

begin_define
define|#
directive|define
name|SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT
value|100
end_define

begin_comment
comment|/**  * The number of milliseconds to wait while a given phy is consuming  * power before allowing another set of phys to consume power.  * Ultimately, this will be specified by OEM parameter.  */
end_comment

begin_define
define|#
directive|define
name|SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL
value|500
end_define

begin_comment
comment|/**  * This macro will return the cycle bit of the completion queue entry  */
end_comment

begin_define
define|#
directive|define
name|COMPLETION_QUEUE_CYCLE_BIT
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x80000000)
end_define

begin_comment
comment|/**  * This macro will normalize the completion queue get pointer so its value  * can be used as an index into an array  */
end_comment

begin_define
define|#
directive|define
name|NORMALIZE_GET_POINTER
parameter_list|(
name|x
parameter_list|)
define|\
value|((x)& SMU_COMPLETION_QUEUE_GET_POINTER_MASK)
end_define

begin_comment
comment|/**  *  This macro will normalize the completion queue put pointer so its value  *  can be used as an array inde  */
end_comment

begin_define
define|#
directive|define
name|NORMALIZE_PUT_POINTER
parameter_list|(
name|x
parameter_list|)
define|\
value|((x)& SMU_COMPLETION_QUEUE_PUT_POINTER_MASK)
end_define

begin_comment
comment|/**  * This macro will normalize the completion queue cycle pointer so it  * matches the completion queue cycle bit  */
end_comment

begin_define
define|#
directive|define
name|NORMALIZE_GET_POINTER_CYCLE_BIT
parameter_list|(
name|x
parameter_list|)
define|\
value|(((U32)(SMU_CQGR_CYCLE_BIT& (x)))<< (31 - SMU_COMPLETION_QUEUE_GET_CYCLE_BIT_SHIFT))
end_define

begin_comment
comment|/**  * This macro will normalize the completion queue event entry so its value  * can be used as an index.  */
end_comment

begin_define
define|#
directive|define
name|NORMALIZE_EVENT_POINTER
parameter_list|(
name|x
parameter_list|)
define|\
value|( \         ((U32)((x)& SMU_COMPLETION_QUEUE_GET_EVENT_POINTER_MASK)) \>> SMU_COMPLETION_QUEUE_GET_EVENT_POINTER_SHIFT \    )
end_define

begin_comment
comment|/**  * This macro will increment the controllers completion queue index value  * and possibly toggle the cycle bit if the completion queue index wraps  * back to 0.  */
end_comment

begin_define
define|#
directive|define
name|INCREMENT_COMPLETION_QUEUE_GET
parameter_list|(
name|controller
parameter_list|,
name|index
parameter_list|,
name|cycle
parameter_list|)
define|\
value|INCREMENT_QUEUE_GET( \       (index), \       (cycle), \       (controller)->completion_queue_entries, \       SMU_CQGR_CYCLE_BIT \    )
end_define

begin_comment
comment|/**  * This macro will increment the controllers event queue index value and  * possibly toggle the event cycle bit if the event queue index wraps back  * to 0.  */
end_comment

begin_define
define|#
directive|define
name|INCREMENT_EVENT_QUEUE_GET
parameter_list|(
name|controller
parameter_list|,
name|index
parameter_list|,
name|cycle
parameter_list|)
define|\
value|INCREMENT_QUEUE_GET( \       (index), \       (cycle), \       (controller)->completion_event_entries, \       SMU_CQGR_EVENT_CYCLE_BIT \    )
end_define

begin_comment
comment|//****************************************************************************-
end_comment

begin_comment
comment|//* SCIC SDS Controller Initialization Methods
end_comment

begin_comment
comment|//****************************************************************************-
end_comment

begin_comment
comment|/**  * @brief This timer is used to start another phy after we have given up on  *        the previous phy to transition to the ready state.  *  * @param[in] controller  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_phy_startup_timeout_handler
parameter_list|(
name|void
modifier|*
name|controller
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|this_controller
operator|->
name|phy_startup_timer_pending
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|SCI_FAILURE
expr_stmt|;
while|while
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|status
operator|=
name|scic_sds_controller_start_next_phy
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * This method initializes the phy startup operations for controller start.  *  * @param this_controller  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_initialize_phy_startup
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|this_controller
operator|->
name|phy_startup_timer
operator|=
name|scic_cb_timer_create
argument_list|(
name|this_controller
argument_list|,
name|scic_sds_controller_phy_startup_timeout_handler
argument_list|,
name|this_controller
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|phy_startup_timer
operator|==
name|NULL
condition|)
block|{
return|return
name|SCI_FAILURE_INSUFFICIENT_RESOURCES
return|;
block|}
else|else
block|{
name|this_controller
operator|->
name|next_phy_to_start
operator|=
literal|0
expr_stmt|;
name|this_controller
operator|->
name|phy_startup_timer_pending
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * This method initializes the power control operations for the controller  * object.  *  * @param this_controller  */
end_comment

begin_function
name|void
name|scic_sds_controller_initialize_power_control
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|this_controller
operator|->
name|power_control
operator|.
name|timer
operator|=
name|scic_cb_timer_create
argument_list|(
name|this_controller
argument_list|,
name|scic_sds_controller_power_control_timer_handler
argument_list|,
name|this_controller
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|this_controller
operator|->
name|power_control
operator|.
name|requesters
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|this_controller
operator|->
name|power_control
operator|.
name|requesters
argument_list|)
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|power_control
operator|.
name|phys_waiting
operator|=
literal|0
expr_stmt|;
name|this_controller
operator|->
name|power_control
operator|.
name|remote_devices_granted_power
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_define
define|#
directive|define
name|SCU_REMOTE_NODE_CONTEXT_ALIGNMENT
value|(32)
end_define

begin_define
define|#
directive|define
name|SCU_TASK_CONTEXT_ALIGNMENT
value|(256)
end_define

begin_define
define|#
directive|define
name|SCU_UNSOLICITED_FRAME_ADDRESS_ALIGNMENT
value|(64)
end_define

begin_define
define|#
directive|define
name|SCU_UNSOLICITED_FRAME_BUFFER_ALIGNMENT
value|(1024)
end_define

begin_define
define|#
directive|define
name|SCU_UNSOLICITED_FRAME_HEADER_ALIGNMENT
value|(64)
end_define

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_comment
comment|/**  * @brief This method builds the memory descriptor table for this  *        controller.  *  * @param[in] this_controller This parameter specifies the controller  *            object for which to build the memory table.  *  * @return none  */
end_comment

begin_function
name|void
name|scic_sds_controller_build_memory_descriptor_table
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|sci_base_mde_construct
argument_list|(
operator|&
name|this_controller
operator|->
name|memory_descriptors
index|[
name|SCU_MDE_COMPLETION_QUEUE
index|]
argument_list|,
name|SCU_COMPLETION_RAM_ALIGNMENT
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|*
name|this_controller
operator|->
name|completion_queue_entries
operator|)
argument_list|,
operator|(
name|SCI_MDE_ATTRIBUTE_CACHEABLE
operator||
name|SCI_MDE_ATTRIBUTE_PHYSICALLY_CONTIGUOUS
operator|)
argument_list|)
expr_stmt|;
name|sci_base_mde_construct
argument_list|(
operator|&
name|this_controller
operator|->
name|memory_descriptors
index|[
name|SCU_MDE_REMOTE_NODE_CONTEXT
index|]
argument_list|,
name|SCU_REMOTE_NODE_CONTEXT_ALIGNMENT
argument_list|,
name|this_controller
operator|->
name|remote_node_entries
operator|*
sizeof|sizeof
argument_list|(
name|SCU_REMOTE_NODE_CONTEXT_T
argument_list|)
argument_list|,
name|SCI_MDE_ATTRIBUTE_PHYSICALLY_CONTIGUOUS
argument_list|)
expr_stmt|;
name|sci_base_mde_construct
argument_list|(
operator|&
name|this_controller
operator|->
name|memory_descriptors
index|[
name|SCU_MDE_TASK_CONTEXT
index|]
argument_list|,
name|SCU_TASK_CONTEXT_ALIGNMENT
argument_list|,
name|this_controller
operator|->
name|task_context_entries
operator|*
sizeof|sizeof
argument_list|(
name|SCU_TASK_CONTEXT_T
argument_list|)
argument_list|,
name|SCI_MDE_ATTRIBUTE_PHYSICALLY_CONTIGUOUS
argument_list|)
expr_stmt|;
comment|// The UF buffer address table size must be programmed to a power
comment|// of 2.  Find the first power of 2 that is equal to or greater then
comment|// the number of unsolicited frame buffers to be utilized.
name|scic_sds_unsolicited_frame_control_set_address_table_count
argument_list|(
operator|&
name|this_controller
operator|->
name|uf_control
argument_list|)
expr_stmt|;
name|sci_base_mde_construct
argument_list|(
operator|&
name|this_controller
operator|->
name|memory_descriptors
index|[
name|SCU_MDE_UF_BUFFER
index|]
argument_list|,
name|SCU_UNSOLICITED_FRAME_BUFFER_ALIGNMENT
argument_list|,
name|scic_sds_unsolicited_frame_control_get_mde_size
argument_list|(
name|this_controller
operator|->
name|uf_control
argument_list|)
argument_list|,
name|SCI_MDE_ATTRIBUTE_PHYSICALLY_CONTIGUOUS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method validates the driver supplied memory descriptor  *        table.  *  * @param[in] this_controller  *  * @return SCI_STATUS  */
end_comment

begin_function
name|SCI_STATUS
name|scic_sds_controller_validate_memory_descriptor_table
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|BOOL
name|mde_list_valid
decl_stmt|;
name|mde_list_valid
operator|=
name|sci_base_mde_is_valid
argument_list|(
operator|&
name|this_controller
operator|->
name|memory_descriptors
index|[
name|SCU_MDE_COMPLETION_QUEUE
index|]
argument_list|,
name|SCU_COMPLETION_RAM_ALIGNMENT
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|*
name|this_controller
operator|->
name|completion_queue_entries
operator|)
argument_list|,
operator|(
name|SCI_MDE_ATTRIBUTE_CACHEABLE
operator||
name|SCI_MDE_ATTRIBUTE_PHYSICALLY_CONTIGUOUS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mde_list_valid
operator|==
name|FALSE
condition|)
return|return
name|SCI_FAILURE_UNSUPPORTED_INFORMATION_FIELD
return|;
name|mde_list_valid
operator|=
name|sci_base_mde_is_valid
argument_list|(
operator|&
name|this_controller
operator|->
name|memory_descriptors
index|[
name|SCU_MDE_REMOTE_NODE_CONTEXT
index|]
argument_list|,
name|SCU_REMOTE_NODE_CONTEXT_ALIGNMENT
argument_list|,
name|this_controller
operator|->
name|remote_node_entries
operator|*
sizeof|sizeof
argument_list|(
name|SCU_REMOTE_NODE_CONTEXT_T
argument_list|)
argument_list|,
name|SCI_MDE_ATTRIBUTE_PHYSICALLY_CONTIGUOUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mde_list_valid
operator|==
name|FALSE
condition|)
return|return
name|SCI_FAILURE_UNSUPPORTED_INFORMATION_FIELD
return|;
name|mde_list_valid
operator|=
name|sci_base_mde_is_valid
argument_list|(
operator|&
name|this_controller
operator|->
name|memory_descriptors
index|[
name|SCU_MDE_TASK_CONTEXT
index|]
argument_list|,
name|SCU_TASK_CONTEXT_ALIGNMENT
argument_list|,
name|this_controller
operator|->
name|task_context_entries
operator|*
sizeof|sizeof
argument_list|(
name|SCU_TASK_CONTEXT_T
argument_list|)
argument_list|,
name|SCI_MDE_ATTRIBUTE_PHYSICALLY_CONTIGUOUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mde_list_valid
operator|==
name|FALSE
condition|)
return|return
name|SCI_FAILURE_UNSUPPORTED_INFORMATION_FIELD
return|;
name|mde_list_valid
operator|=
name|sci_base_mde_is_valid
argument_list|(
operator|&
name|this_controller
operator|->
name|memory_descriptors
index|[
name|SCU_MDE_UF_BUFFER
index|]
argument_list|,
name|SCU_UNSOLICITED_FRAME_BUFFER_ALIGNMENT
argument_list|,
name|scic_sds_unsolicited_frame_control_get_mde_size
argument_list|(
name|this_controller
operator|->
name|uf_control
argument_list|)
argument_list|,
name|SCI_MDE_ATTRIBUTE_PHYSICALLY_CONTIGUOUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mde_list_valid
operator|==
name|FALSE
condition|)
return|return
name|SCI_FAILURE_UNSUPPORTED_INFORMATION_FIELD
return|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method initializes the controller with the physical memory  *        addresses that are used to communicate with the driver.  *  * @param[in] this_controller  *  * @return none  */
end_comment

begin_function
name|void
name|scic_sds_controller_ram_initialization
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|SCI_PHYSICAL_MEMORY_DESCRIPTOR_T
modifier|*
name|mde
decl_stmt|;
comment|// The completion queue is actually placed in cacheable memory
comment|// Therefore it no longer comes out of memory in the MDL.
name|mde
operator|=
operator|&
name|this_controller
operator|->
name|memory_descriptors
index|[
name|SCU_MDE_COMPLETION_QUEUE
index|]
expr_stmt|;
name|this_controller
operator|->
name|completion_queue
operator|=
operator|(
name|U32
operator|*
operator|)
name|mde
operator|->
name|virtual_address
expr_stmt|;
name|SMU_CQBAR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|mde
operator|->
name|physical_address
argument_list|)
expr_stmt|;
comment|// Program the location of the Remote Node Context table
comment|// into the SCU.
name|mde
operator|=
operator|&
name|this_controller
operator|->
name|memory_descriptors
index|[
name|SCU_MDE_REMOTE_NODE_CONTEXT
index|]
expr_stmt|;
name|this_controller
operator|->
name|remote_node_context_table
operator|=
operator|(
name|SCU_REMOTE_NODE_CONTEXT_T
operator|*
operator|)
name|mde
operator|->
name|virtual_address
expr_stmt|;
name|SMU_RNCBAR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|mde
operator|->
name|physical_address
argument_list|)
expr_stmt|;
comment|// Program the location of the Task Context table into the SCU.
name|mde
operator|=
operator|&
name|this_controller
operator|->
name|memory_descriptors
index|[
name|SCU_MDE_TASK_CONTEXT
index|]
expr_stmt|;
name|this_controller
operator|->
name|task_context_table
operator|=
operator|(
name|SCU_TASK_CONTEXT_T
operator|*
operator|)
name|mde
operator|->
name|virtual_address
expr_stmt|;
name|SMU_HTTBAR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|mde
operator|->
name|physical_address
argument_list|)
expr_stmt|;
name|mde
operator|=
operator|&
name|this_controller
operator|->
name|memory_descriptors
index|[
name|SCU_MDE_UF_BUFFER
index|]
expr_stmt|;
name|scic_sds_unsolicited_frame_control_construct
argument_list|(
operator|&
name|this_controller
operator|->
name|uf_control
argument_list|,
name|mde
argument_list|,
name|this_controller
argument_list|)
expr_stmt|;
comment|// Inform the silicon as to the location of the UF headers and
comment|// address table.
name|SCU_UFHBAR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|uf_control
operator|.
name|headers
operator|.
name|physical_address
argument_list|)
expr_stmt|;
name|SCU_PUFATHAR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|uf_control
operator|.
name|address_table
operator|.
name|physical_address
argument_list|)
expr_stmt|;
comment|//enable the ECC correction and detection.
name|SCU_SECR0_WRITE
argument_list|(
name|this_controller
argument_list|,
operator|(
name|SIGNLE_BIT_ERROR_CORRECTION_ENABLE
operator||
name|MULTI_BIT_ERROR_REPORTING_ENABLE
operator||
name|SINGLE_BIT_ERROR_REPORTING_ENABLE
operator|)
argument_list|)
expr_stmt|;
name|SCU_SECR1_WRITE
argument_list|(
name|this_controller
argument_list|,
operator|(
name|SIGNLE_BIT_ERROR_CORRECTION_ENABLE
operator||
name|MULTI_BIT_ERROR_REPORTING_ENABLE
operator||
name|SINGLE_BIT_ERROR_REPORTING_ENABLE
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method initializes the task context data for the controller.  *  * @param[in] this_controller  *  * @return none  */
end_comment

begin_function
name|void
name|scic_sds_controller_assign_task_entries
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U32
name|task_assignment
decl_stmt|;
comment|// Assign all the TCs to function 0
comment|// TODO: Do we actually need to read this register to write it back?
name|task_assignment
operator|=
name|SMU_TCA_READ
argument_list|(
name|this_controller
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|task_assignment
operator|=
operator|(
name|task_assignment
operator||
operator|(
name|SMU_TCA_GEN_VAL
argument_list|(
name|STARTING
argument_list|,
literal|0
argument_list|)
operator|)
operator||
operator|(
name|SMU_TCA_GEN_VAL
argument_list|(
name|ENDING
argument_list|,
name|this_controller
operator|->
name|task_context_entries
operator|-
literal|1
argument_list|)
operator|)
operator||
operator|(
name|SMU_TCA_GEN_BIT
argument_list|(
name|RANGE_CHECK_ENABLE
argument_list|)
operator|)
operator|)
expr_stmt|;
name|SMU_TCA_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0
argument_list|,
name|task_assignment
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method initializes the hardware completion queue.  *  * @param[in] this_controller  */
end_comment

begin_function
name|void
name|scic_sds_controller_initialize_completion_queue
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U32
name|index
decl_stmt|;
name|U32
name|completion_queue_control_value
decl_stmt|;
name|U32
name|completion_queue_get_value
decl_stmt|;
name|U32
name|completion_queue_put_value
decl_stmt|;
name|this_controller
operator|->
name|completion_queue_get
operator|=
literal|0
expr_stmt|;
name|completion_queue_control_value
operator|=
operator|(
name|SMU_CQC_QUEUE_LIMIT_SET
argument_list|(
name|this_controller
operator|->
name|completion_queue_entries
operator|-
literal|1
argument_list|)
operator||
name|SMU_CQC_EVENT_LIMIT_SET
argument_list|(
name|this_controller
operator|->
name|completion_event_entries
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
name|SMU_CQC_WRITE
argument_list|(
name|this_controller
argument_list|,
name|completion_queue_control_value
argument_list|)
expr_stmt|;
comment|// Set the completion queue get pointer and enable the queue
name|completion_queue_get_value
operator|=
operator|(
operator|(
name|SMU_CQGR_GEN_VAL
argument_list|(
name|POINTER
argument_list|,
literal|0
argument_list|)
operator|)
operator||
operator|(
name|SMU_CQGR_GEN_VAL
argument_list|(
name|EVENT_POINTER
argument_list|,
literal|0
argument_list|)
operator|)
operator||
operator|(
name|SMU_CQGR_GEN_BIT
argument_list|(
name|ENABLE
argument_list|)
operator|)
operator||
operator|(
name|SMU_CQGR_GEN_BIT
argument_list|(
name|EVENT_ENABLE
argument_list|)
operator|)
operator|)
expr_stmt|;
name|SMU_CQGR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|completion_queue_get_value
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|completion_queue_get
operator|=
name|completion_queue_get_value
expr_stmt|;
comment|// Set the completion queue put pointer
name|completion_queue_put_value
operator|=
operator|(
operator|(
name|SMU_CQPR_GEN_VAL
argument_list|(
name|POINTER
argument_list|,
literal|0
argument_list|)
operator|)
operator||
operator|(
name|SMU_CQPR_GEN_VAL
argument_list|(
name|EVENT_POINTER
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
expr_stmt|;
name|SMU_CQPR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|completion_queue_put_value
argument_list|)
expr_stmt|;
comment|// Initialize the cycle bit of the completion queue entries
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|this_controller
operator|->
name|completion_queue_entries
condition|;
name|index
operator|++
control|)
block|{
comment|// If get.cycle_bit != completion_queue.cycle_bit
comment|// its not a valid completion queue entry
comment|// so at system start all entries are invalid
name|this_controller
operator|->
name|completion_queue
index|[
name|index
index|]
operator|=
literal|0x80000000
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method initializes the hardware unsolicited frame queue.  *  * @param[in] this_controller  */
end_comment

begin_function
name|void
name|scic_sds_controller_initialize_unsolicited_frame_queue
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U32
name|frame_queue_control_value
decl_stmt|;
name|U32
name|frame_queue_get_value
decl_stmt|;
name|U32
name|frame_queue_put_value
decl_stmt|;
comment|// Write the queue size
name|frame_queue_control_value
operator|=
name|SCU_UFQC_GEN_VAL
argument_list|(
name|QUEUE_SIZE
argument_list|,
name|this_controller
operator|->
name|uf_control
operator|.
name|address_table
operator|.
name|count
argument_list|)
expr_stmt|;
name|SCU_UFQC_WRITE
argument_list|(
name|this_controller
argument_list|,
name|frame_queue_control_value
argument_list|)
expr_stmt|;
comment|// Setup the get pointer for the unsolicited frame queue
name|frame_queue_get_value
operator|=
operator|(
name|SCU_UFQGP_GEN_VAL
argument_list|(
name|POINTER
argument_list|,
literal|0
argument_list|)
operator||
name|SCU_UFQGP_GEN_BIT
argument_list|(
name|ENABLE_BIT
argument_list|)
operator|)
expr_stmt|;
name|SCU_UFQGP_WRITE
argument_list|(
name|this_controller
argument_list|,
name|frame_queue_get_value
argument_list|)
expr_stmt|;
comment|// Setup the put pointer for the unsolicited frame queue
name|frame_queue_put_value
operator|=
name|SCU_UFQPP_GEN_VAL
argument_list|(
name|POINTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCU_UFQPP_WRITE
argument_list|(
name|this_controller
argument_list|,
name|frame_queue_put_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method enables the hardware port task scheduler.  *  * @param[in] this_controller  */
end_comment

begin_function
name|void
name|scic_sds_controller_enable_port_task_scheduler
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U32
name|port_task_scheduler_value
decl_stmt|;
name|port_task_scheduler_value
operator|=
name|SCU_PTSGCR_READ
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|port_task_scheduler_value
operator||=
operator|(
name|SCU_PTSGCR_GEN_BIT
argument_list|(
name|ETM_ENABLE
argument_list|)
operator||
name|SCU_PTSGCR_GEN_BIT
argument_list|(
name|PTSG_ENABLE
argument_list|)
operator|)
expr_stmt|;
name|SCU_PTSGCR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|port_task_scheduler_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ARLINGTON_BUILD
end_ifdef

begin_comment
comment|/**  * This method will read from the lexington status register.  This is required  * as a read fence to the lexington register writes.  *  * @param this_controller  */
end_comment

begin_function
name|void
name|scic_sds_controller_lex_status_read_fence
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U32
name|lex_status
decl_stmt|;
comment|// Read Fence
name|lex_status
operator|=
name|lex_register_read
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0xC4
argument_list|)
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller 0x%x lex_status = 0x%08x\n"
operator|,
name|this_controller
operator|,
name|lex_status
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method will initialize the arlington through the LEX_BAR.  *  * @param this_controller  */
end_comment

begin_function
name|void
name|scic_sds_controller_lex_atux_initialization
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
comment|// 1. Reset all SCU PHY
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0x28
argument_list|,
literal|0x0020FFFF
argument_list|)
expr_stmt|;
comment|// 2. Write to LEX_CTRL
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0xC0
argument_list|,
literal|0x00000700
argument_list|)
expr_stmt|;
name|scic_sds_controller_lex_status_read_fence
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
comment|// 3. Enable PCI Master
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0x70
argument_list|,
literal|0x00000002
argument_list|)
expr_stmt|;
comment|// 4. Enable SCU Register Clock Domain
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0xC0
argument_list|,
literal|0x00000300
argument_list|)
expr_stmt|;
name|scic_sds_controller_lex_status_read_fence
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
comment|// 5.1 Release PHY-A Reg Reset
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0x28
argument_list|,
literal|0x0000FFFF
argument_list|)
expr_stmt|;
comment|// 5.2 Initialize the AFE for PHY-A
name|scic_sds_controller_afe_initialization
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|scic_sds_controller_lex_status_read_fence
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|// 5.3 Release PHY Reg Reset
block|lex_register_write(       this_controller, this_controller->lex_registers + 0x28, 0x0000FFFF);
endif|#
directive|endif
comment|// 6.1 Release PHY-B Reg Reset
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0x28
argument_list|,
literal|0x0040FFFF
argument_list|)
expr_stmt|;
comment|// 6.2 Initialize the AFE for PHY-B
name|scic_sds_controller_afe_initialization
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|scic_sds_controller_lex_status_read_fence
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|// 6.3 Release PHY-B Reg Reset
block|lex_register_write(       this_controller, this_controller->lex_registers + 0x28, 0x0040FFFF) ;
endif|#
directive|endif
comment|// 7. Enable SCU clock domaion
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0xC0
argument_list|,
literal|0x00000100
argument_list|)
expr_stmt|;
name|scic_sds_controller_lex_status_read_fence
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
comment|// 8. Release LEX SCU Reset
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0xC0
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|scic_sds_controller_lex_status_read_fence
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_INTERRUPTS
argument_list|)
comment|// 8a. Set legacy interrupts (SCU INTx to PCI-x INTA)
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0xC0
argument_list|,
literal|0x00000800
argument_list|)
expr_stmt|;
name|scic_sds_controller_lex_status_read_fence
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|// 9. Override TXOLVL
comment|//write to lex_ctrl
block|lex_register_write(       this_controller, this_controller->lex_registers + 0xC0, 0x27800000);
endif|#
directive|endif
comment|// 10. Release PHY-A& PHY-B Resets
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0x28
argument_list|,
literal|0x0000FF77
argument_list|)
expr_stmt|;
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0x28
argument_list|,
literal|0x0000FF55
argument_list|)
expr_stmt|;
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0x28
argument_list|,
literal|0x0000FF11
argument_list|)
expr_stmt|;
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0x28
argument_list|,
literal|0x0000FF00
argument_list|)
expr_stmt|;
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0x28
argument_list|,
literal|0x0003FF00
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// ARLINGTON_BUILD
end_comment

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ARLINGTON_BUILD
end_ifdef

begin_comment
comment|/**  * This method enables chipwatch on the arlington board  *  * @param[in] this_controller  */
end_comment

begin_function
name|void
name|scic_sds_controller_enable_chipwatch
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0x88
argument_list|,
literal|0x09090909
argument_list|)
expr_stmt|;
name|lex_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|lex_registers
operator|+
literal|0x8C
argument_list|,
literal|0xcac9c862
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * This macro is used to delay between writes to the AFE registers  * during AFE initialization.  */
end_comment

begin_define
define|#
directive|define
name|AFE_REGISTER_WRITE_DELAY
value|10
end_define

begin_comment
comment|/**  * Initialize the AFE for this phy index.  *  * @todo We need to read the AFE setup from the OEM parameters  *  * @param[in] this_controller  *  * @return none  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ARLINGTON_BUILD
argument_list|)
end_if

begin_function
name|void
name|scic_sds_controller_afe_initialization
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
comment|// 1. Establish Power
comment|//       Hold Bias, PLL, and RX TX in reset and powerdown
comment|//       pe_afe0_rst_n = 0
comment|//       pe_afe0_txpdn0,1,2,3 = 1
comment|//       pe_afe0_rxpdn0,1,2,3 = 1
comment|//       pe_afe0_txrst0,1,2,3_n = 0
comment|//       pe_afe0_rxrst0,1,2,3_n = 0
comment|//       wait 1us
comment|//       pe_afe0_rst_n = 1
comment|//       wait 1us
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pll_control
argument_list|,
literal|0x00247506
argument_list|)
expr_stmt|;
comment|// 2. Write 0x00000000 to AFE XCVR Ctrl2
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_dfx_transceiver_status_clear
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
comment|// 3. afe0_override_en = 0
comment|//    afe0_pll_dis_override = 0
comment|//    afe0_tx_rst_override = 0
comment|//    afe0_pll_dis = 1
comment|//    pe_afe0_txrate = 01
comment|//    pe_afe0_rxrate = 01
comment|//    pe_afe0_txdis = 11
comment|//    pe_afe0_txoob = 1
comment|//    pe_afe0_txovlv = 9'b001110000
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_transceiver_control0
index|[
literal|0
index|]
argument_list|,
literal|0x0700141e
argument_list|)
expr_stmt|;
comment|// 4. Configure PLL Unit
comment|//    Write 0x00200506 to AFE PLL Ctrl Register 0
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pll_control
argument_list|,
literal|0x00200506
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pll_dfx_control
argument_list|,
literal|0x10000080
argument_list|)
expr_stmt|;
comment|// 5. Configure Bias Unit
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_bias_control
index|[
literal|0
index|]
argument_list|,
literal|0x00124814
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_bias_control
index|[
literal|1
index|]
argument_list|,
literal|0x24900000
argument_list|)
expr_stmt|;
comment|// 6. Configure Transceiver Units
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_transceiver_control0
index|[
literal|0
index|]
argument_list|,
literal|0x0702941e
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_transceiver_control1
index|[
literal|0
index|]
argument_list|,
literal|0x0000000a
argument_list|)
expr_stmt|;
comment|// 7. Configure RX Units
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_transceiver_equalization_control
index|[
literal|0
index|]
argument_list|,
literal|0x00ba2223
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|reserved_0028_003c
index|[
literal|2
index|]
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
comment|// 8. Configure TX Units
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_dfx_transmit_control_register
index|[
literal|0
index|]
argument_list|,
literal|0x03815428
argument_list|)
expr_stmt|;
comment|// 9. Transfer control to PE signals
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_dfx_transceiver_status_clear
argument_list|,
literal|0x00000010
argument_list|)
expr_stmt|;
comment|// 10. Release PLL Powerdown
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pll_control
argument_list|,
literal|0x00200504
argument_list|)
expr_stmt|;
comment|// 11. Release PLL Reset
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pll_control
argument_list|,
literal|0x00200505
argument_list|)
expr_stmt|;
comment|// 12. Wait for PLL to Lock
comment|// (afe0_comm_sta [1:0] should go to 1'b11, and
comment|//                [5:2] is 0x5, 0x6, 0x7, 0x8, or 0x9
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pll_control
argument_list|,
literal|0x00200501
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|scu_afe_register_read
argument_list|(
name|this_controller
argument_list|,
name|afe_common_status
argument_list|)
operator|&
literal|0x03
operator|)
operator|!=
literal|0x03
condition|)
block|{
comment|// Give time for the PLLs to lock
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
comment|// 13. pe_afe0_rxpdn0 = 0
comment|//     pe_afe0_rxrst0 = 1
comment|//     pe_afe0_txrst0_n = 1
comment|//     pe_afe_txoob0_n = 0
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_transceiver_control0
index|[
literal|0
index|]
argument_list|,
literal|0x07028c11
argument_list|)
expr_stmt|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|PLEASANT_RIDGE_BUILD
argument_list|)
end_elif

begin_function
name|void
name|scic_sds_controller_afe_initialization
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U32
name|afe_status
decl_stmt|;
name|U32
name|phy_id
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SPREADSHEET_AFE_SETTINGS
argument_list|)
comment|// Clear DFX Status registers
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_dfx_master_control0
argument_list|,
literal|0x0000000f
argument_list|)
expr_stmt|;
comment|// Configure bias currents to normal
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_bias_control
argument_list|,
literal|0x0000aa00
argument_list|)
expr_stmt|;
comment|// Enable PLL
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pll_control0
argument_list|,
literal|0x80000908
argument_list|)
expr_stmt|;
comment|// Wait for the PLL to lock
do|do
block|{
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
name|afe_status
operator|=
name|scu_afe_register_read
argument_list|(
name|this_controller
argument_list|,
name|afe_common_block_status
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|afe_status
operator|&
literal|0x00001000
operator|)
operator|==
literal|0
condition|)
do|;
for|for
control|(
name|phy_id
operator|=
literal|0
init|;
name|phy_id
operator|<
name|SCI_MAX_PHYS
condition|;
name|phy_id
operator|++
control|)
block|{
comment|// Initialize transceiver channels
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_channel_control
argument_list|,
literal|0x00000157
argument_list|)
expr_stmt|;
comment|// Configure transceiver modes
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x38016d1a
argument_list|)
expr_stmt|;
comment|// Configure receiver parameters
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control1
argument_list|,
literal|0x01501014
argument_list|)
expr_stmt|;
comment|// Configure transmitter parameters
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_control
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
comment|// Configure transmitter equalization
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_amp_control0
argument_list|,
literal|0x000bdd08
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_amp_control1
argument_list|,
literal|0x000ffc00
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_amp_control2
argument_list|,
literal|0x000b7c09
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_amp_control3
argument_list|,
literal|0x000afc6e
argument_list|)
expr_stmt|;
comment|// Configure transmitter SSC parameters
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_ssc_control
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
comment|// Configure receiver parameters
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_rx_ssc_control0
argument_list|,
literal|0x3208903f
argument_list|)
expr_stmt|;
comment|// Start power on sequence
comment|// Enable bias currents to transceivers and wait 200ns
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_channel_control
argument_list|,
literal|0x00000154
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// Take receiver out of power down and wait 200ns
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x3801611a
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// Take receiver out of reset and wait 200ns
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x3801631a
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// Take transmitter out of power down and wait 200ns
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x38016318
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// Take transmitter out of reset and wait 200ns
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x38016319
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// Take transmitter out of DC idle
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x38016319
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
comment|// Transfer control to the PEs
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_dfx_master_control0
argument_list|,
literal|0x00010f00
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// !defined(SPREADSHEET_AFE_SETTINGS)
comment|// These are the AFEE settings used by the SV group
comment|// Clear DFX Status registers
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_dfx_master_control0
argument_list|,
literal|0x0081000f
argument_list|)
expr_stmt|;
comment|// Configure bias currents to normal
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_bias_control
argument_list|,
literal|0x0000aa00
argument_list|)
expr_stmt|;
comment|// Enable PLL
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pll_control0
argument_list|,
literal|0x80000908
argument_list|)
expr_stmt|;
comment|// Wait for the PLL to lock
comment|// Note: this is done later in the SV shell script however this looks
comment|//       like the location to do this since we have enabled the PLL.
do|do
block|{
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
name|afe_status
operator|=
name|scu_afe_register_read
argument_list|(
name|this_controller
argument_list|,
name|afe_common_block_status
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|afe_status
operator|&
literal|0x00001000
operator|)
operator|==
literal|0
condition|)
do|;
comment|// Make sure BIST is disabled
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_dfx_master_control1
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
comment|// Shorten SAS SNW lock time
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pmsn_master_control0
argument_list|,
literal|0x7bd316ad
argument_list|)
expr_stmt|;
for|for
control|(
name|phy_id
operator|=
literal|0
init|;
name|phy_id
operator|<
name|SCI_MAX_PHYS
condition|;
name|phy_id
operator|++
control|)
block|{
comment|// Initialize transceiver channels
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_channel_control
argument_list|,
literal|0x00000174
argument_list|)
expr_stmt|;
comment|// Configure SSC control
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_ssc_control
argument_list|,
literal|0x00030000
argument_list|)
expr_stmt|;
comment|// Configure transceiver modes
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x0000651a
argument_list|)
expr_stmt|;
comment|// Power up TX RX and RX OOB
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x00006518
argument_list|)
expr_stmt|;
comment|// Enable RX OOB Detect
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x00006518
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|// Configure transmitter parameters
block|scu_afe_register_write(          this_controller, scu_afe_xcvr[phy_id].afe_tx_control, 0x00000000);
comment|// Configure transmitter equalization
block|scu_afe_register_write(          this_controller, scu_afe_xcvr[phy_id].afe_tx_amp_control0, 0x000bdd08);       scu_afe_register_write(          this_controller, scu_afe_xcvr[phy_id].afe_tx_amp_control1, 0x000ffc00);       scu_afe_register_write(          this_controller, scu_afe_xcvr[phy_id].afe_tx_amp_control2, 0x000b7c09);       scu_afe_register_write(          this_controller, scu_afe_xcvr[phy_id].afe_tx_amp_control3, 0x000afc6e);
comment|// Configure transmitter SSC parameters
comment|// Power up TX RX
block|scu_afe_register_write(          this_controller, scu_afe_xcvr[phy_id].afe_channel_control, 0x00000154);       scic_cb_stall_execution(AFE_REGISTER_WRITE_DELAY);
comment|// FFE = Max
block|scu_afe_register_write(          this_controller, scu_afe_xcvr[phy_id].afe_dfx_rx_control1, 0x00000080);
comment|// DFE1-5 = small
block|scu_afe_register_write(          this_controller, scu_afe_xcvr[phy_id].afe_dfx_rx_control1, 0x01041042);
comment|// Enable DFE/FFE and freeze
block|scu_afe_register_write(          this_controller, scu_afe_xcvr[phy_id].afe_rx_ssc_control0, 0x320891bf);
endif|#
directive|endif
comment|// Take receiver out of power down and wait 200ns
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x00006118
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// TX Electrical Idle
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x00006108
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// Leave DFE/FFE on
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_rx_ssc_control0
argument_list|,
literal|0x0317108f
argument_list|)
expr_stmt|;
comment|// Configure receiver parameters
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control1
argument_list|,
literal|0x01e00021
argument_list|)
expr_stmt|;
comment|// Bring RX out of reset
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x00006109
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x00006009
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x00006209
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
comment|// Transfer control to the PEs
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_dfx_master_control0
argument_list|,
literal|0x00010f00
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|PBG_HBA_A0_BUILD
argument_list|)
operator|||
name|defined
argument_list|(
name|PBG_HBA_A2_BUILD
argument_list|)
operator|||
name|defined
argument_list|(
name|PBG_HBA_BETA_BUILD
argument_list|)
operator|||
name|defined
argument_list|(
name|PBG_BUILD
argument_list|)
end_elif

begin_function
name|void
name|scic_sds_controller_afe_initialization
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U32
name|afe_status
decl_stmt|;
name|U32
name|phy_id
decl_stmt|;
name|U8
name|cable_selection_mask
decl_stmt|;
if|if
condition|(
operator|(
name|this_controller
operator|->
name|pci_revision
operator|!=
name|SCIC_SDS_PCI_REVISION_A0
operator|)
operator|&&
operator|(
name|this_controller
operator|->
name|pci_revision
operator|!=
name|SCIC_SDS_PCI_REVISION_A2
operator|)
operator|&&
operator|(
name|this_controller
operator|->
name|pci_revision
operator|!=
name|SCIC_SDS_PCI_REVISION_B0
operator|)
operator|&&
operator|(
name|this_controller
operator|->
name|pci_revision
operator|!=
name|SCIC_SDS_PCI_REVISION_C0
operator|)
operator|&&
operator|(
name|this_controller
operator|->
name|pci_revision
operator|!=
name|SCIC_SDS_PCI_REVISION_C1
operator|)
condition|)
block|{
comment|// A programming bug has occurred if we are attempting to
comment|// support a PCI revision other than those listed.  Default
comment|// to B0, and attempt to limp along if it isn't B0.
name|ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|pci_revision
operator|=
name|SCIC_SDS_PCI_REVISION_C1
expr_stmt|;
block|}
name|cable_selection_mask
operator|=
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|controller
operator|.
name|cable_selection_mask
expr_stmt|;
comment|// These are the AFEE settings used by the SV group
comment|// Clear DFX Status registers
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_dfx_master_control0
argument_list|,
literal|0x0081000f
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_B0
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_C0
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_C1
operator|)
condition|)
block|{
comment|// PM Rx Equalization Save, PM SPhy Rx Acknowledgement Timer, PM Stagger Timer
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pmsn_master_control2
argument_list|,
literal|0x0007FFFF
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
comment|// Configure bias currents to normal
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A0
condition|)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_bias_control
argument_list|,
literal|0x00005500
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A2
condition|)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_bias_control
argument_list|,
literal|0x00005A00
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_B0
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_C0
operator|)
condition|)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_bias_control
argument_list|,
literal|0x00005F00
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_C1
condition|)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_bias_control
argument_list|,
literal|0x00005500
argument_list|)
expr_stmt|;
comment|// For C0 the AFE BIAS Controll is unchanged
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// Enable PLL
if|if
condition|(
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A0
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A2
operator|)
condition|)
block|{
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pll_control0
argument_list|,
literal|0x80040908
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_B0
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_C0
operator|)
condition|)
block|{
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pll_control0
argument_list|,
literal|0x80040A08
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_C1
condition|)
block|{
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pll_control0
argument_list|,
literal|0x80000b08
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pll_control0
argument_list|,
literal|0x00000b08
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pll_control0
argument_list|,
literal|0x80000b08
argument_list|)
expr_stmt|;
block|}
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// Wait for the PLL to lock
comment|// Note: this is done later in the SV shell script however this looks
comment|//       like the location to do this since we have enabled the PLL.
do|do
block|{
name|afe_status
operator|=
name|scu_afe_register_read
argument_list|(
name|this_controller
argument_list|,
name|afe_common_block_status
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|afe_status
operator|&
literal|0x00001000
operator|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A0
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A2
operator|)
condition|)
block|{
comment|// Shorten SAS SNW lock time (RxLock timer value from 76 us to 50 us)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_pmsn_master_control0
argument_list|,
literal|0x7bcc96ad
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|phy_id
operator|=
literal|0
init|;
name|phy_id
operator|<
name|SCI_MAX_PHYS
condition|;
name|phy_id
operator|++
control|)
block|{
name|U8
name|cable_length_long
init|=
operator|(
name|cable_selection_mask
operator|>>
name|phy_id
operator|)
operator|&
literal|1
decl_stmt|;
name|U8
name|cable_length_medium
init|=
operator|(
name|cable_selection_mask
operator|>>
operator|(
name|phy_id
operator|+
literal|4
operator|)
operator|)
operator|&
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A0
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A2
operator|)
condition|)
block|{
comment|// All defaults, except the Receive Word Alignament/Comma Detect
comment|// Enable....(0xe800)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x00004512
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control1
argument_list|,
literal|0x0050100F
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_B0
condition|)
block|{
comment|// Configure transmitter SSC parameters
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_ssc_control
argument_list|,
literal|0x00030000
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_C0
condition|)
block|{
comment|// Configure transmitter SSC parameters
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_ssc_control
argument_list|,
literal|0x00010202
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// All defaults, except the Receive Word Alignament/Comma Detect
comment|// Enable....(0xe800)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x00014500
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_C1
condition|)
block|{
comment|// Configure transmitter SSC parameters
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_ssc_control
argument_list|,
literal|0x00010202
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// All defaults, except the Receive Word Alignament/Comma Detect
comment|// Enable....(0xe800)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x0001C500
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
comment|// Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
comment|//& increase TX int& ext bias 20%....(0xe85c)
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A0
condition|)
block|{
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_channel_control
argument_list|,
literal|0x000003D4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A2
condition|)
block|{
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_channel_control
argument_list|,
literal|0x000003F0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_B0
condition|)
block|{
comment|// Power down TX and RX (PWRDNTX and PWRDNRX)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_channel_control
argument_list|,
literal|0x000003d7
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
comment|//& increase TX int& ext bias 20%....(0xe85c)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_channel_control
argument_list|,
literal|0x000003d4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_C0
condition|)
block|{
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_channel_control
argument_list|,
literal|0x000001e7
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
comment|//& increase TX int& ext bias 20%....(0xe85c)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_channel_control
argument_list|,
literal|0x000001e4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_C1
condition|)
block|{
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_channel_control
argument_list|,
name|cable_length_long
condition|?
literal|0x000002F7
else|:
name|cable_length_medium
condition|?
literal|0x000001F7
else|:
literal|0x000001F7
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
comment|//& increase TX int& ext bias 20%....(0xe85c)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_channel_control
argument_list|,
name|cable_length_long
condition|?
literal|0x000002F4
else|:
name|cable_length_medium
condition|?
literal|0x000001F4
else|:
literal|0x000001F4
argument_list|)
expr_stmt|;
block|}
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A0
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A2
operator|)
condition|)
block|{
comment|// Enable TX equalization (0xe824)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_control
argument_list|,
literal|0x00040000
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A0
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A2
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_B0
operator|)
condition|)
block|{
comment|// RDPI=0x0(RX Power On), RXOOBDETPDNC=0x0, TPD=0x0(TX Power On),
comment|// RDD=0x0(RX Detect Enabled) ....(0xe800)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x00004100
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_C0
condition|)
block|{
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x00014100
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_C1
condition|)
block|{
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control0
argument_list|,
literal|0x0001c100
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
comment|// Leave DFE/FFE on
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A0
condition|)
block|{
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_rx_ssc_control0
argument_list|,
literal|0x3F09983F
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A2
condition|)
block|{
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_rx_ssc_control0
argument_list|,
literal|0x3F11103F
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_B0
condition|)
block|{
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_rx_ssc_control0
argument_list|,
literal|0x3F11103F
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// Enable TX equalization (0xe824)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_control
argument_list|,
literal|0x00040000
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_C0
condition|)
block|{
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control1
argument_list|,
literal|0x01400c0f
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_rx_ssc_control0
argument_list|,
literal|0x3f6f103f
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// Enable TX equalization (0xe824)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_control
argument_list|,
literal|0x00040000
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_C1
condition|)
block|{
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_xcvr_control1
argument_list|,
name|cable_length_long
condition|?
literal|0x01500C0C
else|:
name|cable_length_medium
condition|?
literal|0x01400C0D
else|:
literal|0x02400C0D
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_dfx_rx_control1
argument_list|,
literal|0x000003e0
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_rx_ssc_control0
argument_list|,
name|cable_length_long
condition|?
literal|0x33091C1F
else|:
name|cable_length_medium
condition|?
literal|0x3315181F
else|:
literal|0x2B17161F
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
comment|// Enable TX equalization (0xe824)
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_control
argument_list|,
literal|0x00040000
argument_list|)
expr_stmt|;
block|}
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_amp_control0
argument_list|,
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|phy_id
index|]
operator|.
name|afe_tx_amp_control0
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_amp_control1
argument_list|,
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|phy_id
index|]
operator|.
name|afe_tx_amp_control1
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_amp_control2
argument_list|,
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|phy_id
index|]
operator|.
name|afe_tx_amp_control2
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|scu_afe_xcvr
index|[
name|phy_id
index|]
operator|.
name|afe_tx_amp_control3
argument_list|,
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|phy_id
index|]
operator|.
name|afe_tx_amp_control3
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
comment|// Transfer control to the PEs
name|scu_afe_register_write
argument_list|(
name|this_controller
argument_list|,
name|afe_dfx_master_control0
argument_list|,
literal|0x00010f00
argument_list|)
expr_stmt|;
name|scic_cb_stall_execution
argument_list|(
name|AFE_REGISTER_WRITE_DELAY
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Unsupported board type"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//****************************************************************************-
end_comment

begin_comment
comment|//* SCIC SDS Controller Internal Start/Stop Routines
end_comment

begin_comment
comment|//****************************************************************************-
end_comment

begin_comment
comment|/**  * @brief This method will attempt to transition into the ready state  *        for the controller and indicate that the controller start  *        operation has completed if all criteria are met.  *  * @param[in,out] this_controller This parameter indicates the controller  *                object for which to transition to ready.  * @param[in]     status This parameter indicates the status value to be  *                pass into the call to scic_cb_controller_start_complete().  *  * @return none.  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_transition_to_ready
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCI_STATUS
name|status
parameter_list|)
block|{
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_sds_controller_transition_to_ready(0x%x, 0x%x) enter\n"
operator|,
name|this_controller
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_CONTROLLER_STATE_STARTING
condition|)
block|{
comment|// We move into the ready state, because some of the phys/ports
comment|// may be up and operational.
name|sci_base_state_machine_change_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_READY
argument_list|)
expr_stmt|;
name|scic_cb_controller_start_complete
argument_list|(
name|this_controller
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method is the general timeout handler for the controller.  *        It will take the correct timetout action based on the current  *        controller state  *  * @param[in] controller This parameter indicates the controller on which  *            a timeout occurred.  *  * @return none  */
end_comment

begin_function
name|void
name|scic_sds_controller_timeout_handler
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCI_BASE_CONTROLLER_STATES
name|current_state
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|current_state
operator|=
name|sci_base_state_machine_get_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_state
operator|==
name|SCI_BASE_CONTROLLER_STATE_STARTING
condition|)
block|{
name|scic_sds_controller_transition_to_ready
argument_list|(
name|this_controller
argument_list|,
name|SCI_FAILURE_TIMEOUT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_state
operator|==
name|SCI_BASE_CONTROLLER_STATE_STOPPING
condition|)
block|{
name|sci_base_state_machine_change_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_FAILED
argument_list|)
expr_stmt|;
name|scic_cb_controller_stop_complete
argument_list|(
name|controller
argument_list|,
name|SCI_FAILURE_TIMEOUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/// @todo Now what do we want to do in this case?
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller timer fired when controller was not in a state being timed.\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief  *  * @param[in] this_controller  *  * @return SCI_STATUS  */
end_comment

begin_function
name|SCI_STATUS
name|scic_sds_controller_stop_ports
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U32
name|index
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|SCI_STATUS
name|port_status
decl_stmt|;
name|status
operator|=
name|SCI_SUCCESS
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|this_controller
operator|->
name|logical_port_entries
condition|;
name|index
operator|++
control|)
block|{
name|port_status
operator|=
name|this_controller
operator|->
name|port_table
index|[
name|index
index|]
operator|.
name|state_handlers
operator|->
name|parent
operator|.
name|stop_handler
argument_list|(
operator|&
name|this_controller
operator|->
name|port_table
index|[
name|index
index|]
operator|.
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|port_status
operator|!=
name|SCI_SUCCESS
operator|)
operator|&&
operator|(
name|port_status
operator|!=
name|SCI_FAILURE_INVALID_STATE
operator|)
condition|)
block|{
name|status
operator|=
name|SCI_FAILURE
expr_stmt|;
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PORT
operator|,
literal|"Controller stop operation failed to stop port %d because of status %d.\n"
operator|,
name|this_controller
operator|->
name|port_table
index|[
name|index
index|]
operator|.
name|logical_port_index
operator|,
name|port_status
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief  *  * @param[in] this_controller  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_phy_timer_start
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|scic_cb_timer_start
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|phy_startup_timer
argument_list|,
name|SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|phy_startup_timer_pending
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief  *  * @param[in] this_controller  */
end_comment

begin_function
name|void
name|scic_sds_controller_phy_timer_stop
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|scic_cb_timer_stop
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|phy_startup_timer
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|phy_startup_timer_pending
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method is called internally to determine whether the  *        controller start process is complete.  This is only true when:  *          - all links have been given an opportunity to start  *          - have no indication of a connected device  *          - have an indication of a connected device and it has  *             finished the link training process.  *  * @param[in] this_controller This parameter specifies the controller  *            object for which to start the next phy.  *  * @return BOOL  */
end_comment

begin_function
name|BOOL
name|scic_sds_controller_is_start_complete
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U8
name|index
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PHYS
condition|;
name|index
operator|++
control|)
block|{
name|SCIC_SDS_PHY_T
modifier|*
name|the_phy
init|=
operator|&
name|this_controller
operator|->
name|phy_table
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|controller
operator|.
name|mode_type
operator|==
name|SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE
operator|)
operator|||
operator|(
operator|(
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|controller
operator|.
name|mode_type
operator|==
name|SCIC_PORT_MANUAL_CONFIGURATION_MODE
operator|)
operator|&&
operator|(
name|scic_sds_phy_get_port
argument_list|(
name|the_phy
argument_list|)
operator|!=
name|SCI_INVALID_HANDLE
operator|)
operator|)
condition|)
block|{
comment|/**           * The controller start operation is complete if and only           * if:           * - all links have been given an opportunity to start           * - have no indication of a connected device           * - have an indication of a connected device and it has           *   finished the link training process.           */
if|if
condition|(
operator|(
operator|(
name|the_phy
operator|->
name|is_in_link_training
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|the_phy
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_PHY_STATE_INITIAL
operator|)
operator|)
operator|||
operator|(
operator|(
name|the_phy
operator|->
name|is_in_link_training
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|the_phy
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_PHY_STATE_STOPPED
operator|)
operator|)
operator|||
operator|(
operator|(
name|the_phy
operator|->
name|is_in_link_training
operator|==
name|TRUE
operator|)
operator|&&
operator|(
name|the_phy
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_PHY_STATE_STARTING
operator|)
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|port_agent
operator|.
name|phy_ready_mask
operator|!=
name|this_controller
operator|->
name|port_agent
operator|.
name|phy_configured_mask
operator|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method is called internally by the controller object to  *        start the next phy on the controller.  If all the phys have  *        been starte, then this method will attempt to transition the  *        controller to the READY state and inform the user  *        (scic_cb_controller_start_complete()).  *  * @param[in] this_controller This parameter specifies the controller  *            object for which to start the next phy.  *  * @return SCI_STATUS  */
end_comment

begin_function
name|SCI_STATUS
name|scic_sds_controller_start_next_phy
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|status
operator|=
name|SCI_SUCCESS
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|phy_startup_timer_pending
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|this_controller
operator|->
name|next_phy_to_start
operator|==
name|SCI_MAX_PHYS
condition|)
block|{
comment|// The controller has successfully finished the start process.
comment|// Inform the SCI Core user and transition to the READY state.
if|if
condition|(
name|scic_sds_controller_is_start_complete
argument_list|(
name|this_controller
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|scic_sds_controller_transition_to_ready
argument_list|(
name|this_controller
argument_list|,
name|SCI_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SCIC_SDS_PHY_T
modifier|*
name|the_phy
decl_stmt|;
name|the_phy
operator|=
operator|&
name|this_controller
operator|->
name|phy_table
index|[
name|this_controller
operator|->
name|next_phy_to_start
index|]
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|controller
operator|.
name|mode_type
operator|==
name|SCIC_PORT_MANUAL_CONFIGURATION_MODE
condition|)
block|{
if|if
condition|(
name|scic_sds_phy_get_port
argument_list|(
name|the_phy
argument_list|)
operator|==
name|SCI_INVALID_HANDLE
condition|)
block|{
name|this_controller
operator|->
name|next_phy_to_start
operator|++
expr_stmt|;
comment|// Caution recursion ahead be forwarned
comment|//
comment|// The PHY was never added to a PORT in MPC mode so start the next phy in sequence
comment|// This phy will never go link up and will not draw power the OEM parameters either
comment|// configured the phy incorrectly for the PORT or it was never assigned to a PORT
return|return
name|scic_sds_controller_start_next_phy
argument_list|(
name|this_controller
argument_list|)
return|;
block|}
block|}
name|status
operator|=
name|scic_phy_start
argument_list|(
name|the_phy
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|scic_sds_controller_phy_timer_start
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PHY
operator|,
literal|"Controller stop operation failed to stop phy %d because of status %d.\n"
operator|,
name|this_controller
operator|->
name|phy_table
index|[
name|this_controller
operator|->
name|next_phy_to_start
index|]
operator|.
name|phy_index
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
block|}
name|this_controller
operator|->
name|next_phy_to_start
operator|++
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief  *  * @param[in] this_controller  *  * @return SCI_STATUS  */
end_comment

begin_function
name|SCI_STATUS
name|scic_sds_controller_stop_phys
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U32
name|index
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|SCI_STATUS
name|phy_status
decl_stmt|;
name|status
operator|=
name|SCI_SUCCESS
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PHYS
condition|;
name|index
operator|++
control|)
block|{
name|phy_status
operator|=
name|scic_phy_stop
argument_list|(
operator|&
name|this_controller
operator|->
name|phy_table
index|[
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|phy_status
operator|!=
name|SCI_SUCCESS
operator|)
operator|&&
operator|(
name|phy_status
operator|!=
name|SCI_FAILURE_INVALID_STATE
operator|)
condition|)
block|{
name|status
operator|=
name|SCI_FAILURE
expr_stmt|;
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PHY
operator|,
literal|"Controller stop operation failed to stop phy %d because of status %d.\n"
operator|,
name|this_controller
operator|->
name|phy_table
index|[
name|index
index|]
operator|.
name|phy_index
operator|,
name|phy_status
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief  *  * @param[in] this_controller  *  * @return SCI_STATUS  */
end_comment

begin_function
name|SCI_STATUS
name|scic_sds_controller_stop_devices
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U32
name|index
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|SCI_STATUS
name|device_status
decl_stmt|;
name|status
operator|=
name|SCI_SUCCESS
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|this_controller
operator|->
name|remote_node_entries
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|this_controller
operator|->
name|device_table
index|[
name|index
index|]
operator|!=
name|SCI_INVALID_HANDLE
condition|)
block|{
comment|/// @todo What timeout value do we want to provide to this request?
name|device_status
operator|=
name|scic_remote_device_stop
argument_list|(
name|this_controller
operator|->
name|device_table
index|[
name|index
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|device_status
operator|!=
name|SCI_SUCCESS
operator|)
operator|&&
operator|(
name|device_status
operator|!=
name|SCI_FAILURE_INVALID_STATE
operator|)
condition|)
block|{
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_SSP_REMOTE_TARGET
operator|,
literal|"Controller stop operation failed to stop device 0x%x because of status %d.\n"
operator|,
name|this_controller
operator|->
name|device_table
index|[
name|index
index|]
operator|,
name|device_status
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|//****************************************************************************-
end_comment

begin_comment
comment|//* SCIC SDS Controller Power Control (Staggered Spinup)
end_comment

begin_comment
comment|//****************************************************************************-
end_comment

begin_comment
comment|/**  * This method starts the power control timer for this controller object.  *  * @param this_controller  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_power_control_timer_start
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|scic_cb_timer_start
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|power_control
operator|.
name|timer
argument_list|,
name|SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|power_control
operator|.
name|timer_started
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method stops the power control timer for this controller object.  *  * @param this_controller  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_power_control_timer_stop
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
if|if
condition|(
name|this_controller
operator|->
name|power_control
operator|.
name|timer_started
condition|)
block|{
name|scic_cb_timer_stop
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|power_control
operator|.
name|timer
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|power_control
operator|.
name|timer_started
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * This method stops and starts the power control timer for this controller object.  *  * @param this_controller  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_power_control_timer_restart
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|scic_sds_controller_power_control_timer_stop
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|scic_sds_controller_power_control_timer_start
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief  *  * @param[in] controller  */
end_comment

begin_function
name|void
name|scic_sds_controller_power_control_timer_handler
parameter_list|(
name|void
modifier|*
name|controller
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|this_controller
operator|->
name|power_control
operator|.
name|remote_devices_granted_power
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|power_control
operator|.
name|phys_waiting
operator|==
literal|0
condition|)
block|{
name|this_controller
operator|->
name|power_control
operator|.
name|timer_started
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|SCIC_SDS_PHY_T
modifier|*
name|the_phy
init|=
name|NULL
decl_stmt|;
name|U8
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|SCI_MAX_PHYS
operator|)
operator|&&
operator|(
name|this_controller
operator|->
name|power_control
operator|.
name|phys_waiting
operator|!=
literal|0
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|this_controller
operator|->
name|power_control
operator|.
name|requesters
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|this_controller
operator|->
name|power_control
operator|.
name|remote_devices_granted_power
operator|<
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|controller
operator|.
name|max_number_concurrent_device_spin_up
condition|)
block|{
name|the_phy
operator|=
name|this_controller
operator|->
name|power_control
operator|.
name|requesters
index|[
name|i
index|]
expr_stmt|;
name|this_controller
operator|->
name|power_control
operator|.
name|requesters
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|this_controller
operator|->
name|power_control
operator|.
name|phys_waiting
operator|--
expr_stmt|;
name|this_controller
operator|->
name|power_control
operator|.
name|remote_devices_granted_power
operator|++
expr_stmt|;
name|scic_sds_phy_consume_power_handler
argument_list|(
name|the_phy
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_phy
operator|->
name|protocol
operator|==
name|SCIC_SDS_PHY_PROTOCOL_SAS
condition|)
block|{
name|U8
name|j
decl_stmt|;
name|SCIC_SDS_PHY_T
modifier|*
name|current_requester_phy
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SCI_MAX_PHYS
condition|;
name|j
operator|++
control|)
block|{
name|current_requester_phy
operator|=
name|this_controller
operator|->
name|power_control
operator|.
name|requesters
index|[
name|j
index|]
expr_stmt|;
comment|//Search the power_control queue to see if there are other phys attached to
comment|//the same remote device. If found, take all of them out of await_sas_power state.
if|if
condition|(
name|current_requester_phy
operator|!=
name|NULL
operator|&&
name|current_requester_phy
operator|!=
name|the_phy
operator|&&
name|current_requester_phy
operator|->
name|phy_type
operator|.
name|sas
operator|.
name|identify_address_frame_buffer
operator|.
name|sas_address
operator|.
name|high
operator|==
name|the_phy
operator|->
name|phy_type
operator|.
name|sas
operator|.
name|identify_address_frame_buffer
operator|.
name|sas_address
operator|.
name|high
operator|&&
name|current_requester_phy
operator|->
name|phy_type
operator|.
name|sas
operator|.
name|identify_address_frame_buffer
operator|.
name|sas_address
operator|.
name|low
operator|==
name|the_phy
operator|->
name|phy_type
operator|.
name|sas
operator|.
name|identify_address_frame_buffer
operator|.
name|sas_address
operator|.
name|low
condition|)
block|{
name|this_controller
operator|->
name|power_control
operator|.
name|requesters
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
name|this_controller
operator|->
name|power_control
operator|.
name|phys_waiting
operator|--
expr_stmt|;
name|scic_sds_phy_consume_power_handler
argument_list|(
name|current_requester_phy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
comment|// It doesn't matter if the power list is empty, we need to start the
comment|// timer in case another phy becomes ready.
name|scic_sds_controller_power_control_timer_start
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method inserts the phy in the stagger spinup control queue.  *  * @param[in] this_controller  * @param[in] the_phy  */
end_comment

begin_function
name|void
name|scic_sds_controller_power_control_queue_insert
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|the_phy
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|the_phy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|power_control
operator|.
name|remote_devices_granted_power
operator|<
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|controller
operator|.
name|max_number_concurrent_device_spin_up
condition|)
block|{
name|this_controller
operator|->
name|power_control
operator|.
name|remote_devices_granted_power
operator|++
expr_stmt|;
name|scic_sds_phy_consume_power_handler
argument_list|(
name|the_phy
argument_list|)
expr_stmt|;
comment|//stop and start the power_control timer. When the timer fires, the
comment|//no_of_devices_granted_power will be set to 0
name|scic_sds_controller_power_control_timer_restart
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//there are phys, attached to the same sas address as this phy, are already
comment|//in READY state, this phy don't need wait.
name|U8
name|i
decl_stmt|;
name|SCIC_SDS_PHY_T
modifier|*
name|current_phy
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCI_MAX_PHYS
condition|;
name|i
operator|++
control|)
block|{
name|current_phy
operator|=
operator|&
name|this_controller
operator|->
name|phy_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|current_phy
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_PHY_STATE_READY
operator|&&
name|current_phy
operator|->
name|protocol
operator|==
name|SCIC_SDS_PHY_PROTOCOL_SAS
operator|&&
name|current_phy
operator|->
name|phy_type
operator|.
name|sas
operator|.
name|identify_address_frame_buffer
operator|.
name|sas_address
operator|.
name|high
operator|==
name|the_phy
operator|->
name|phy_type
operator|.
name|sas
operator|.
name|identify_address_frame_buffer
operator|.
name|sas_address
operator|.
name|high
operator|&&
name|current_phy
operator|->
name|phy_type
operator|.
name|sas
operator|.
name|identify_address_frame_buffer
operator|.
name|sas_address
operator|.
name|low
operator|==
name|the_phy
operator|->
name|phy_type
operator|.
name|sas
operator|.
name|identify_address_frame_buffer
operator|.
name|sas_address
operator|.
name|low
condition|)
block|{
name|scic_sds_phy_consume_power_handler
argument_list|(
name|the_phy
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|SCI_MAX_PHYS
condition|)
block|{
comment|//Add the phy in the waiting list
name|this_controller
operator|->
name|power_control
operator|.
name|requesters
index|[
name|the_phy
operator|->
name|phy_index
index|]
operator|=
name|the_phy
expr_stmt|;
name|this_controller
operator|->
name|power_control
operator|.
name|phys_waiting
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method removes the phy from the stagger spinup control  *        queue.  *  * @param[in] this_controller  * @param[in] the_phy  */
end_comment

begin_function
name|void
name|scic_sds_controller_power_control_queue_remove
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|the_phy
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|the_phy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|power_control
operator|.
name|requesters
index|[
name|the_phy
operator|->
name|phy_index
index|]
operator|!=
name|NULL
condition|)
block|{
name|this_controller
operator|->
name|power_control
operator|.
name|phys_waiting
operator|--
expr_stmt|;
block|}
name|this_controller
operator|->
name|power_control
operator|.
name|requesters
index|[
name|the_phy
operator|->
name|phy_index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|//****************************************************************************-
end_comment

begin_comment
comment|//* SCIC SDS Controller Completion Routines
end_comment

begin_comment
comment|//****************************************************************************-
end_comment

begin_comment
comment|/**  * @brief This method returns a TRUE value if the completion queue has  *        entries that can be processed  *  * @param[in] this_controller  *  * @return BOOL  * @retval TRUE if the completion queue has entries to process  *         FALSE if the completion queue has no entries to process  */
end_comment

begin_function
specifier|static
name|BOOL
name|scic_sds_controller_completion_queue_has_entries
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U32
name|get_value
init|=
name|this_controller
operator|->
name|completion_queue_get
decl_stmt|;
name|U32
name|get_index
init|=
name|get_value
operator|&
name|SMU_COMPLETION_QUEUE_GET_POINTER_MASK
decl_stmt|;
if|if
condition|(
name|NORMALIZE_GET_POINTER_CYCLE_BIT
argument_list|(
name|get_value
argument_list|)
operator|==
name|COMPLETION_QUEUE_CYCLE_BIT
argument_list|(
name|this_controller
operator|->
name|completion_queue
index|[
name|get_index
index|]
argument_list|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_comment
comment|/**  * @brief This method processes a task completion notification.  This is  *        called from within the controller completion handler.  *  * @param[in] this_controller  * @param[in] completion_entry  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_task_completion
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|U32
name|completion_entry
parameter_list|)
block|{
name|U32
name|index
decl_stmt|;
name|SCIC_SDS_REQUEST_T
modifier|*
name|io_request
decl_stmt|;
name|index
operator|=
name|SCU_GET_COMPLETION_INDEX
argument_list|(
name|completion_entry
argument_list|)
expr_stmt|;
name|io_request
operator|=
name|this_controller
operator|->
name|io_request_table
index|[
name|index
index|]
expr_stmt|;
comment|// Make sure that we really want to process this IO request
if|if
condition|(
operator|(
name|io_request
operator|!=
name|SCI_INVALID_HANDLE
operator|)
operator|&&
operator|(
name|io_request
operator|->
name|io_tag
operator|!=
name|SCI_CONTROLLER_INVALID_IO_TAG
operator|)
operator|&&
operator|(
name|scic_sds_io_tag_get_sequence
argument_list|(
name|io_request
operator|->
name|io_tag
argument_list|)
operator|==
name|this_controller
operator|->
name|io_request_sequence
index|[
name|index
index|]
operator|)
condition|)
block|{
comment|// Yep this is a valid io request pass it along to the io request handler
name|scic_sds_io_request_tc_completion
argument_list|(
name|io_request
argument_list|,
name|completion_entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method processes an SDMA completion event.  This is called  *        from within the controller completion handler.  *  * @param[in] this_controller  * @param[in] completion_entry  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_sdma_completion
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|U32
name|completion_entry
parameter_list|)
block|{
name|U32
name|index
decl_stmt|;
name|SCIC_SDS_REQUEST_T
modifier|*
name|io_request
decl_stmt|;
name|SCIC_SDS_REMOTE_DEVICE_T
modifier|*
name|device
decl_stmt|;
name|index
operator|=
name|SCU_GET_COMPLETION_INDEX
argument_list|(
name|completion_entry
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|scu_get_command_request_type
argument_list|(
name|completion_entry
argument_list|)
condition|)
block|{
case|case
name|SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC
case|:
case|case
name|SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_TC
case|:
name|io_request
operator|=
name|this_controller
operator|->
name|io_request_table
index|[
name|index
index|]
expr_stmt|;
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_SMP_IO_REQUEST
operator||
name|SCIC_LOG_OBJECT_SSP_IO_REQUEST
operator||
name|SCIC_LOG_OBJECT_STP_IO_REQUEST
operator|,
literal|"SCIC SDS Completion type SDMA %x for io request %x\n"
operator|,
name|completion_entry
operator|,
name|io_request
operator|)
argument_list|)
expr_stmt|;
comment|/// @todo For a post TC operation we need to fail the IO request
break|break;
case|case
name|SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_RNC
case|:
case|case
name|SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC
case|:
case|case
name|SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC
case|:
name|device
operator|=
name|this_controller
operator|->
name|device_table
index|[
name|index
index|]
expr_stmt|;
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_SSP_REMOTE_TARGET
operator||
name|SCIC_LOG_OBJECT_SMP_REMOTE_TARGET
operator||
name|SCIC_LOG_OBJECT_STP_REMOTE_TARGET
operator|,
literal|"SCIC SDS Completion type SDMA %x for remote device %x\n"
operator|,
name|completion_entry
operator|,
name|device
operator|)
argument_list|)
expr_stmt|;
comment|/// @todo For a port RNC operation we need to fail the device
break|break;
default|default:
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC SDS Completion unknown SDMA completion type %x\n"
operator|,
name|completion_entry
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/// This is an unexpected completion type and is un-recoverable
comment|/// Transition to the failed state and wait for a controller reset
name|sci_base_state_machine_change_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_FAILED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method processes an unsolicited frame message.  This is called from  * within the controller completion handler.  *  * @param[in] this_controller  * @param[in] completion_entry  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_unsolicited_frame
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|U32
name|completion_entry
parameter_list|)
block|{
name|U32
name|index
decl_stmt|;
name|U32
name|frame_index
decl_stmt|;
name|SCU_UNSOLICITED_FRAME_HEADER_T
modifier|*
name|frame_header
decl_stmt|;
name|SCIC_SDS_PHY_T
modifier|*
name|phy
decl_stmt|;
name|SCIC_SDS_REMOTE_DEVICE_T
modifier|*
name|device
decl_stmt|;
name|SCI_STATUS
name|result
init|=
name|SCI_FAILURE
decl_stmt|;
name|frame_index
operator|=
name|SCU_GET_FRAME_INDEX
argument_list|(
name|completion_entry
argument_list|)
expr_stmt|;
name|frame_header
operator|=
name|this_controller
operator|->
name|uf_control
operator|.
name|buffers
operator|.
name|array
index|[
name|frame_index
index|]
operator|.
name|header
expr_stmt|;
name|this_controller
operator|->
name|uf_control
operator|.
name|buffers
operator|.
name|array
index|[
name|frame_index
index|]
operator|.
name|state
operator|=
name|UNSOLICITED_FRAME_IN_USE
expr_stmt|;
if|if
condition|(
name|SCU_GET_FRAME_ERROR
argument_list|(
name|completion_entry
argument_list|)
condition|)
block|{
comment|/// @todo If the IAF frame or SIGNATURE FIS frame has an error will
comment|///       this cause a problem? We expect the phy initialization will
comment|///       fail if there is an error in the frame.
name|scic_sds_controller_release_frame
argument_list|(
name|this_controller
argument_list|,
name|frame_index
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|frame_header
operator|->
name|is_address_frame
condition|)
block|{
name|index
operator|=
name|SCU_GET_PROTOCOL_ENGINE_INDEX
argument_list|(
name|completion_entry
argument_list|)
expr_stmt|;
name|phy
operator|=
operator|&
name|this_controller
operator|->
name|phy_table
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|phy
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|scic_sds_phy_frame_handler
argument_list|(
name|phy
argument_list|,
name|frame_index
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|index
operator|=
name|SCU_GET_COMPLETION_INDEX
argument_list|(
name|completion_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX
condition|)
block|{
comment|// This is a signature fis or a frame from a direct attached SATA
comment|// device that has not yet been created.  In either case forwared
comment|// the frame to the PE and let it take care of the frame data.
name|index
operator|=
name|SCU_GET_PROTOCOL_ENGINE_INDEX
argument_list|(
name|completion_entry
argument_list|)
expr_stmt|;
name|phy
operator|=
operator|&
name|this_controller
operator|->
name|phy_table
index|[
name|index
index|]
expr_stmt|;
name|result
operator|=
name|scic_sds_phy_frame_handler
argument_list|(
name|phy
argument_list|,
name|frame_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|index
operator|<
name|this_controller
operator|->
name|remote_node_entries
condition|)
name|device
operator|=
name|this_controller
operator|->
name|device_table
index|[
name|index
index|]
expr_stmt|;
else|else
name|device
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
name|result
operator|=
name|scic_sds_remote_device_frame_handler
argument_list|(
name|device
argument_list|,
name|frame_index
argument_list|)
expr_stmt|;
else|else
name|scic_sds_controller_release_frame
argument_list|(
name|this_controller
argument_list|,
name|frame_index
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|!=
name|SCI_SUCCESS
condition|)
block|{
comment|/// @todo Is there any reason to report some additional error message
comment|///       when we get this failure notifiction?
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method processes an event completion entry.  This is called  *        from within the controller completion handler.  *  * @param[in] this_controller  * @param[in] completion_entry  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_event_completion
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|U32
name|completion_entry
parameter_list|)
block|{
name|U32
name|index
decl_stmt|;
name|SCIC_SDS_REQUEST_T
modifier|*
name|io_request
decl_stmt|;
name|SCIC_SDS_REMOTE_DEVICE_T
modifier|*
name|device
decl_stmt|;
name|SCIC_SDS_PHY_T
modifier|*
name|phy
decl_stmt|;
name|index
operator|=
name|SCU_GET_COMPLETION_INDEX
argument_list|(
name|completion_entry
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|scu_get_event_type
argument_list|(
name|completion_entry
argument_list|)
condition|)
block|{
case|case
name|SCU_EVENT_TYPE_SMU_COMMAND_ERROR
case|:
comment|/// @todo The driver did something wrong and we need to fix the condtion.
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller 0x%x received SMU command error 0x%x\n"
operator|,
name|this_controller
operator|,
name|completion_entry
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCU_EVENT_TYPE_FATAL_MEMORY_ERROR
case|:
comment|// report fatal memory error
name|this_controller
operator|->
name|parent
operator|.
name|error
operator|=
name|SCI_CONTROLLER_FATAL_MEMORY_ERROR
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_FAILED
argument_list|)
expr_stmt|;
comment|//continue as in following events
case|case
name|SCU_EVENT_TYPE_SMU_PCQ_ERROR
case|:
case|case
name|SCU_EVENT_TYPE_SMU_ERROR
case|:
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller 0x%x received fatal controller event 0x%x\n"
operator|,
name|this_controller
operator|,
name|completion_entry
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCU_EVENT_TYPE_TRANSPORT_ERROR
case|:
name|io_request
operator|=
name|this_controller
operator|->
name|io_request_table
index|[
name|index
index|]
expr_stmt|;
name|scic_sds_io_request_event_handler
argument_list|(
name|io_request
argument_list|,
name|completion_entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT
case|:
switch|switch
condition|(
name|scu_get_event_specifier
argument_list|(
name|completion_entry
argument_list|)
condition|)
block|{
case|case
name|SCU_EVENT_SPECIFIC_SMP_RESPONSE_NO_PE
case|:
case|case
name|SCU_EVENT_SPECIFIC_TASK_TIMEOUT
case|:
name|io_request
operator|=
name|this_controller
operator|->
name|io_request_table
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|io_request
operator|!=
name|SCI_INVALID_HANDLE
condition|)
block|{
name|scic_sds_io_request_event_handler
argument_list|(
name|io_request
argument_list|,
name|completion_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_SMP_IO_REQUEST
operator||
name|SCIC_LOG_OBJECT_SSP_IO_REQUEST
operator||
name|SCIC_LOG_OBJECT_STP_IO_REQUEST
operator|,
literal|"SCIC Controller 0x%x received event 0x%x for io request object that doesnt exist.\n"
operator|,
name|this_controller
operator|,
name|completion_entry
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCU_EVENT_SPECIFIC_IT_NEXUS_TIMEOUT
case|:
name|device
operator|=
name|this_controller
operator|->
name|device_table
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|device
operator|!=
name|SCI_INVALID_HANDLE
condition|)
block|{
name|scic_sds_remote_device_event_handler
argument_list|(
name|device
argument_list|,
name|completion_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_SMP_REMOTE_TARGET
operator||
name|SCIC_LOG_OBJECT_SSP_REMOTE_TARGET
operator||
name|SCIC_LOG_OBJECT_STP_REMOTE_TARGET
operator|,
literal|"SCIC Controller 0x%x received event 0x%x for remote device object that doesnt exist.\n"
operator|,
name|this_controller
operator|,
name|completion_entry
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
name|SCU_EVENT_TYPE_BROADCAST_CHANGE
case|:
comment|// direct the broadcast change event to the phy first and then let
comment|// the phy redirect the broadcast change to the port object
case|case
name|SCU_EVENT_TYPE_ERR_CNT_EVENT
case|:
comment|// direct error counter event to the phy object since that is where
comment|// we get the event notification.  This is a type 4 event.
case|case
name|SCU_EVENT_TYPE_OSSP_EVENT
case|:
name|index
operator|=
name|SCU_GET_PROTOCOL_ENGINE_INDEX
argument_list|(
name|completion_entry
argument_list|)
expr_stmt|;
name|phy
operator|=
operator|&
name|this_controller
operator|->
name|phy_table
index|[
name|index
index|]
expr_stmt|;
name|scic_sds_phy_event_handler
argument_list|(
name|phy
argument_list|,
name|completion_entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCU_EVENT_TYPE_RNC_SUSPEND_TX
case|:
case|case
name|SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX
case|:
case|case
name|SCU_EVENT_TYPE_RNC_OPS_MISC
case|:
if|if
condition|(
name|index
operator|<
name|this_controller
operator|->
name|remote_node_entries
condition|)
block|{
name|device
operator|=
name|this_controller
operator|->
name|device_table
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
block|{
name|scic_sds_remote_device_event_handler
argument_list|(
name|device
argument_list|,
name|completion_entry
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_SMP_REMOTE_TARGET
operator||
name|SCIC_LOG_OBJECT_SSP_REMOTE_TARGET
operator||
name|SCIC_LOG_OBJECT_STP_REMOTE_TARGET
operator|,
literal|"SCIC Controller 0x%x received event 0x%x for remote device object 0x%0x that doesnt exist.\n"
operator|,
name|this_controller
operator|,
name|completion_entry
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller received unknown event code %x\n"
operator|,
name|completion_entry
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method is a private routine for processing the completion  *        queue entries.  *  * @param[in] this_controller  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_process_completions
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U32
name|completion_count
init|=
literal|0
decl_stmt|;
name|U32
name|completion_entry
decl_stmt|;
name|U32
name|get_index
decl_stmt|;
name|U32
name|get_cycle
decl_stmt|;
name|U32
name|event_index
decl_stmt|;
name|U32
name|event_cycle
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_sds_controller_process_completions(0x%x) enter\n"
operator|,
name|this_controller
operator|)
argument_list|)
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_COMPLETION_QUEUE
operator|,
literal|"completion queue begining get : 0x%08x\n"
operator|,
name|this_controller
operator|->
name|completion_queue_get
operator|)
argument_list|)
expr_stmt|;
comment|// Get the component parts of the completion queue
name|get_index
operator|=
name|NORMALIZE_GET_POINTER
argument_list|(
name|this_controller
operator|->
name|completion_queue_get
argument_list|)
expr_stmt|;
name|get_cycle
operator|=
name|SMU_CQGR_CYCLE_BIT
operator|&
name|this_controller
operator|->
name|completion_queue_get
expr_stmt|;
name|event_index
operator|=
name|NORMALIZE_EVENT_POINTER
argument_list|(
name|this_controller
operator|->
name|completion_queue_get
argument_list|)
expr_stmt|;
name|event_cycle
operator|=
name|SMU_CQGR_EVENT_CYCLE_BIT
operator|&
name|this_controller
operator|->
name|completion_queue_get
expr_stmt|;
while|while
condition|(
name|NORMALIZE_GET_POINTER_CYCLE_BIT
argument_list|(
name|get_cycle
argument_list|)
operator|==
name|COMPLETION_QUEUE_CYCLE_BIT
argument_list|(
name|this_controller
operator|->
name|completion_queue
index|[
name|get_index
index|]
argument_list|)
condition|)
block|{
name|completion_count
operator|++
expr_stmt|;
name|completion_entry
operator|=
name|this_controller
operator|->
name|completion_queue
index|[
name|get_index
index|]
expr_stmt|;
name|INCREMENT_COMPLETION_QUEUE_GET
argument_list|(
name|this_controller
argument_list|,
name|get_index
argument_list|,
name|get_cycle
argument_list|)
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_COMPLETION_QUEUE
operator|,
literal|"completion queue entry : 0x%08x\n"
operator|,
name|completion_entry
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SCU_GET_COMPLETION_TYPE
argument_list|(
name|completion_entry
argument_list|)
condition|)
block|{
case|case
name|SCU_COMPLETION_TYPE_TASK
case|:
name|scic_sds_controller_task_completion
argument_list|(
name|this_controller
argument_list|,
name|completion_entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCU_COMPLETION_TYPE_SDMA
case|:
name|scic_sds_controller_sdma_completion
argument_list|(
name|this_controller
argument_list|,
name|completion_entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCU_COMPLETION_TYPE_UFI
case|:
name|scic_sds_controller_unsolicited_frame
argument_list|(
name|this_controller
argument_list|,
name|completion_entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCU_COMPLETION_TYPE_EVENT
case|:
name|scic_sds_controller_event_completion
argument_list|(
name|this_controller
argument_list|,
name|completion_entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCU_COMPLETION_TYPE_NOTIFY
case|:
comment|// Presently we do the same thing with a notify event that we do with the
comment|// other event codes.
name|INCREMENT_EVENT_QUEUE_GET
argument_list|(
name|this_controller
argument_list|,
name|event_index
argument_list|,
name|event_cycle
argument_list|)
expr_stmt|;
name|scic_sds_controller_event_completion
argument_list|(
name|this_controller
argument_list|,
name|completion_entry
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller received unknown completion type %x\n"
operator|,
name|completion_entry
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// Update the get register if we completed one or more entries
if|if
condition|(
name|completion_count
operator|>
literal|0
condition|)
block|{
name|this_controller
operator|->
name|completion_queue_get
operator|=
name|SMU_CQGR_GEN_BIT
argument_list|(
name|ENABLE
argument_list|)
operator||
name|SMU_CQGR_GEN_BIT
argument_list|(
name|EVENT_ENABLE
argument_list|)
operator||
name|event_cycle
operator||
name|SMU_CQGR_GEN_VAL
argument_list|(
name|EVENT_POINTER
argument_list|,
name|event_index
argument_list|)
operator||
name|get_cycle
operator||
name|SMU_CQGR_GEN_VAL
argument_list|(
name|POINTER
argument_list|,
name|get_index
argument_list|)
expr_stmt|;
name|SMU_CQGR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|completion_queue_get
argument_list|)
expr_stmt|;
block|}
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_COMPLETION_QUEUE
operator|,
literal|"completion queue ending get : 0x%08x\n"
operator|,
name|this_controller
operator|->
name|completion_queue_get
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method is a private routine for processing the completion  *        queue entries.  *  * @param[in] this_controller  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_transitioned_process_completions
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U32
name|completion_count
init|=
literal|0
decl_stmt|;
name|U32
name|completion_entry
decl_stmt|;
name|U32
name|get_index
decl_stmt|;
name|U32
name|get_cycle
decl_stmt|;
name|U32
name|event_index
decl_stmt|;
name|U32
name|event_cycle
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_sds_controller_transitioned_process_completions(0x%x) enter\n"
operator|,
name|this_controller
operator|)
argument_list|)
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_COMPLETION_QUEUE
operator|,
literal|"completion queue begining get : 0x%08x\n"
operator|,
name|this_controller
operator|->
name|completion_queue_get
operator|)
argument_list|)
expr_stmt|;
comment|// Get the component parts of the completion queue
name|get_index
operator|=
name|NORMALIZE_GET_POINTER
argument_list|(
name|this_controller
operator|->
name|completion_queue_get
argument_list|)
expr_stmt|;
name|get_cycle
operator|=
name|SMU_CQGR_CYCLE_BIT
operator|&
name|this_controller
operator|->
name|completion_queue_get
expr_stmt|;
name|event_index
operator|=
name|NORMALIZE_EVENT_POINTER
argument_list|(
name|this_controller
operator|->
name|completion_queue_get
argument_list|)
expr_stmt|;
name|event_cycle
operator|=
name|SMU_CQGR_EVENT_CYCLE_BIT
operator|&
name|this_controller
operator|->
name|completion_queue_get
expr_stmt|;
while|while
condition|(
name|NORMALIZE_GET_POINTER_CYCLE_BIT
argument_list|(
name|get_cycle
argument_list|)
operator|==
name|COMPLETION_QUEUE_CYCLE_BIT
argument_list|(
name|this_controller
operator|->
name|completion_queue
index|[
name|get_index
index|]
argument_list|)
condition|)
block|{
name|completion_count
operator|++
expr_stmt|;
name|completion_entry
operator|=
name|this_controller
operator|->
name|completion_queue
index|[
name|get_index
index|]
expr_stmt|;
name|INCREMENT_COMPLETION_QUEUE_GET
argument_list|(
name|this_controller
argument_list|,
name|get_index
argument_list|,
name|get_cycle
argument_list|)
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_COMPLETION_QUEUE
operator|,
literal|"completion queue entry : 0x%08x\n"
operator|,
name|completion_entry
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SCU_GET_COMPLETION_TYPE
argument_list|(
name|completion_entry
argument_list|)
condition|)
block|{
case|case
name|SCU_COMPLETION_TYPE_TASK
case|:
name|scic_sds_controller_task_completion
argument_list|(
name|this_controller
argument_list|,
name|completion_entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCU_COMPLETION_TYPE_NOTIFY
case|:
name|INCREMENT_EVENT_QUEUE_GET
argument_list|(
name|this_controller
argument_list|,
name|event_index
argument_list|,
name|event_cycle
argument_list|)
expr_stmt|;
comment|// Fall-through
case|case
name|SCU_COMPLETION_TYPE_EVENT
case|:
case|case
name|SCU_COMPLETION_TYPE_SDMA
case|:
case|case
name|SCU_COMPLETION_TYPE_UFI
case|:
default|default:
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller ignoring completion type %x\n"
operator|,
name|completion_entry
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// Update the get register if we completed one or more entries
if|if
condition|(
name|completion_count
operator|>
literal|0
condition|)
block|{
name|this_controller
operator|->
name|completion_queue_get
operator|=
name|SMU_CQGR_GEN_BIT
argument_list|(
name|ENABLE
argument_list|)
operator||
name|SMU_CQGR_GEN_BIT
argument_list|(
name|EVENT_ENABLE
argument_list|)
operator||
name|event_cycle
operator||
name|SMU_CQGR_GEN_VAL
argument_list|(
name|EVENT_POINTER
argument_list|,
name|event_index
argument_list|)
operator||
name|get_cycle
operator||
name|SMU_CQGR_GEN_VAL
argument_list|(
name|POINTER
argument_list|,
name|get_index
argument_list|)
expr_stmt|;
name|SMU_CQGR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|completion_queue_get
argument_list|)
expr_stmt|;
block|}
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_COMPLETION_QUEUE
operator|,
literal|"completion queue ending get : 0x%08x\n"
operator|,
name|this_controller
operator|->
name|completion_queue_get
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//****************************************************************************-
end_comment

begin_comment
comment|//* SCIC SDS Controller Interrupt and Completion functions
end_comment

begin_comment
comment|//****************************************************************************-
end_comment

begin_comment
comment|/**  * @brief This method provides standard (common) processing of interrupts  *        for polling and legacy based interrupts.  *  * @param[in] controller  * @param[in] interrupt_status  *  * @return This method returns a boolean (BOOL) indication as to  *         whether an completions are pending to be processed.  * @retval TRUE if an interrupt is to be processed  * @retval FALSE if no interrupt was pending  */
end_comment

begin_function
specifier|static
name|BOOL
name|scic_sds_controller_standard_interrupt_handler
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|U32
name|interrupt_status
parameter_list|)
block|{
name|BOOL
name|is_completion_needed
init|=
name|FALSE
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_sds_controller_standard_interrupt_handler(0x%d,0x%d) enter\n"
operator|,
name|this_controller
operator|,
name|interrupt_status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|interrupt_status
operator|&
name|SMU_ISR_QUEUE_ERROR
operator|)
operator|||
operator|(
operator|(
name|interrupt_status
operator|&
name|SMU_ISR_QUEUE_SUSPEND
operator|)
operator|&&
operator|(
operator|!
name|scic_sds_controller_completion_queue_has_entries
argument_list|(
name|this_controller
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|// We have a fatal error on the read of the completion queue bar
comment|// OR
comment|// We have a fatal error there is nothing in the completion queue
comment|// but we have a report from the hardware that the queue is full
comment|/// @todo how do we request the a controller reset
name|is_completion_needed
operator|=
name|TRUE
expr_stmt|;
name|this_controller
operator|->
name|encountered_fatal_error
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|scic_sds_controller_completion_queue_has_entries
argument_list|(
name|this_controller
argument_list|)
condition|)
block|{
name|is_completion_needed
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|is_completion_needed
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This is the method provided to handle polling for interrupts  *        for the controller object.  *  * @param[in] controller  *  * @return BOOL  * @retval TRUE if an interrupt is to be processed  * @retval FALSE if no interrupt was pending  */
end_comment

begin_function
specifier|static
name|BOOL
name|scic_sds_controller_polling_interrupt_handler
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|U32
name|interrupt_status
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_sds_controller_polling_interrupt_handler(0x%d) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
comment|/*     * In INTERRUPT_POLLING_MODE we exit the interrupt handler if the hardware     * indicates nothing is pending. Since we are not being called from a real     * interrupt, we don't want to confuse the hardware by servicing the     * completion queue before the hardware indicates it is ready. We'll     * simply wait for another polling interval and check again.     */
name|interrupt_status
operator|=
name|SMU_ISR_READ
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|interrupt_status
operator|&
operator|(
name|SMU_ISR_COMPLETION
operator||
name|SMU_ISR_QUEUE_ERROR
operator||
name|SMU_ISR_QUEUE_SUSPEND
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|FALSE
return|;
block|}
return|return
name|scic_sds_controller_standard_interrupt_handler
argument_list|(
name|controller
argument_list|,
name|interrupt_status
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This is the method provided to handle completions when interrupt  *        polling is in use.  *  * @param[in] controller  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_polling_completion_handler
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_sds_controller_polling_completion_handler(0x%d) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|encountered_fatal_error
operator|==
name|TRUE
condition|)
block|{
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller has encountered a fatal error.\n"
operator|)
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_FAILED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scic_sds_controller_completion_queue_has_entries
argument_list|(
name|this_controller
argument_list|)
condition|)
block|{
if|if
condition|(
name|this_controller
operator|->
name|restrict_completions
operator|==
name|FALSE
condition|)
name|scic_sds_controller_process_completions
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
else|else
name|scic_sds_controller_transitioned_process_completions
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
block|}
comment|/*     * The interrupt handler does not adjust the CQ's     * get pointer.  So, SCU's INTx pin stays asserted during the     * interrupt handler even though it tries to clear the interrupt     * source.  Therefore, the completion handler must ensure that the     * interrupt source is cleared.  Otherwise, we get a spurious     * interrupt for which the interrupt handler will not issue a     * corresponding completion event. Also, we unmask interrupts.     */
name|SMU_ISR_WRITE
argument_list|(
name|this_controller
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|SMU_ISR_COMPLETION
operator||
name|SMU_ISR_QUEUE_ERROR
operator||
name|SMU_ISR_QUEUE_SUSPEND
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_INTERRUPTS
argument_list|)
end_if

begin_comment
comment|/**  * @brief This is the method provided to handle legacy interrupts for the  *        controller object.  *  * @param[in] controller  *  * @return BOOL  * @retval TRUE if an interrupt is processed  *         FALSE if no interrupt was processed  */
end_comment

begin_function
specifier|static
name|BOOL
name|scic_sds_controller_legacy_interrupt_handler
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|U32
name|interrupt_status
decl_stmt|;
name|BOOL
name|is_completion_needed
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|interrupt_status
operator|=
name|SMU_ISR_READ
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|is_completion_needed
operator|=
name|scic_sds_controller_standard_interrupt_handler
argument_list|(
name|this_controller
argument_list|,
name|interrupt_status
argument_list|)
expr_stmt|;
return|return
name|is_completion_needed
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This is the method provided to handle legacy completions it is  *        expected that the SCI User will call this completion handler  *        anytime the interrupt handler reports that it has handled an  *        interrupt.  *  * @param[in] controller  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_legacy_completion_handler
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_sds_controller_legacy_completion_handler(0x%d) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
name|scic_sds_controller_polling_completion_handler
argument_list|(
name|controller
argument_list|)
expr_stmt|;
name|SMU_IMR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IMR_READ_FENCE
block|{
specifier|volatile
name|U32
name|int_mask_value
init|=
literal|0
decl_stmt|;
name|ULONG
name|count
init|=
literal|0
decl_stmt|;
comment|/*        * Temporary code since we have seen with legacy interrupts        * that interrupts are still masked after clearing the mask        * above. This may be an Arlington problem or it may be an        * old driver problem.  Presently this code is turned off        * since we have not seen this problem recently.        */
do|do
block|{
name|int_mask_value
operator|=
name|SMU_IMR_READ
argument_list|(
name|this_controler
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|++
operator|>
literal|10
condition|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_ENTER_DEBUGGER
name|__debugbreak
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
do|while
condition|(
name|int_mask_value
operator|!=
literal|0
condition|)
do|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * @brief This is the method provided to handle an MSIX interrupt message  *        when there is just a single MSIX message being provided by the  *        hardware.  This mode of operation is single vector mode.  *  * @param[in] controller  *  * @return BOOL  * @retval TRUE if an interrupt is processed  *         FALSE if no interrupt was processed  */
end_comment

begin_function
specifier|static
name|BOOL
name|scic_sds_controller_single_vector_interrupt_handler
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|U32
name|interrupt_status
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
comment|// Mask the interrupts
comment|// There is a race in the hardware that could cause us not to be notified
comment|// of an interrupt completion if we do not take this step.  We will unmask
comment|// the interrupts in the completion routine.
name|SMU_IMR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|interrupt_status
operator|=
name|SMU_ISR_READ
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|interrupt_status
operator|&=
operator|(
name|SMU_ISR_QUEUE_ERROR
operator||
name|SMU_ISR_QUEUE_SUSPEND
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|interrupt_status
operator|==
literal|0
operator|)
operator|&&
name|scic_sds_controller_completion_queue_has_entries
argument_list|(
name|this_controller
argument_list|)
condition|)
block|{
comment|// There is at least one completion queue entry to process so we can
comment|// return a success and ignore for now the case of an error interrupt
name|SMU_ISR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|SMU_ISR_COMPLETION
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|interrupt_status
operator|!=
literal|0
condition|)
block|{
comment|// There is an error interrupt pending so let it through and handle
comment|// in the callback
return|return
name|TRUE
return|;
block|}
comment|// Clear any offending interrupts since we could not find any to handle
comment|// and unmask them all
name|SMU_ISR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|SMU_IMR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This is the method provided to handle completions for a single  *        MSIX message.  *  * @param[in] controller  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_single_vector_completion_handler
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|U32
name|interrupt_status
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_sds_controller_single_vector_completion_handler(0x%d) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
name|interrupt_status
operator|=
name|SMU_ISR_READ
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|interrupt_status
operator|&=
operator|(
name|SMU_ISR_QUEUE_ERROR
operator||
name|SMU_ISR_QUEUE_SUSPEND
operator|)
expr_stmt|;
if|if
condition|(
name|interrupt_status
operator|&
name|SMU_ISR_QUEUE_ERROR
condition|)
block|{
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller has encountered a fatal error.\n"
operator|)
argument_list|)
expr_stmt|;
comment|// We have a fatal condition and must reset the controller
comment|// Leave the interrupt mask in place and get the controller reset
name|sci_base_state_machine_change_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_FAILED
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|interrupt_status
operator|&
name|SMU_ISR_QUEUE_SUSPEND
operator|)
operator|&&
operator|!
name|scic_sds_controller_completion_queue_has_entries
argument_list|(
name|this_controller
argument_list|)
condition|)
block|{
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller has encountered a fatal error.\n"
operator|)
argument_list|)
expr_stmt|;
comment|// We have a fatal condtion and must reset the controller
comment|// Leave the interrupt mask in place and get the controller reset
name|sci_base_state_machine_change_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_FAILED
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scic_sds_controller_completion_queue_has_entries
argument_list|(
name|this_controller
argument_list|)
condition|)
block|{
name|scic_sds_controller_process_completions
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
comment|// We dont care which interrupt got us to processing the completion queu
comment|// so clear them both.
name|SMU_ISR_WRITE
argument_list|(
name|this_controller
argument_list|,
operator|(
name|SMU_ISR_COMPLETION
operator||
name|SMU_ISR_QUEUE_SUSPEND
operator|)
argument_list|)
expr_stmt|;
block|}
name|SMU_IMR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This is the method provided to handle a MSIX message for a normal  *        completion.  *  * @param[in] controller  *  * @return BOOL  * @retval TRUE if an interrupt is processed  *         FALSE if no interrupt was processed  */
end_comment

begin_function
specifier|static
name|BOOL
name|scic_sds_controller_normal_vector_interrupt_handler
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
if|if
condition|(
name|scic_sds_controller_completion_queue_has_entries
argument_list|(
name|this_controller
argument_list|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|else
block|{
comment|// we have a spurious interrupt it could be that we have already
comment|// emptied the completion queue from a previous interrupt
name|SMU_ISR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|SMU_ISR_COMPLETION
argument_list|)
expr_stmt|;
comment|// There is a race in the hardware that could cause us not to be notified
comment|// of an interrupt completion if we do not take this step.  We will mask
comment|// then unmask the interrupts so if there is another interrupt pending
comment|// the clearing of the interrupt source we get the next interrupt message.
name|SMU_IMR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0xFF000000
argument_list|)
expr_stmt|;
name|SMU_IMR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This is the method provided to handle the completions for a  *        normal MSIX message.  *  * @param[in] controller  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_normal_vector_completion_handler
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_sds_controller_normal_vector_completion_handler(0x%d) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
comment|// Empty out the completion queue
if|if
condition|(
name|scic_sds_controller_completion_queue_has_entries
argument_list|(
name|this_controller
argument_list|)
condition|)
block|{
name|scic_sds_controller_process_completions
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
block|}
comment|// Clear the interrupt and enable all interrupts again
name|SMU_ISR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|SMU_ISR_COMPLETION
argument_list|)
expr_stmt|;
comment|// Could we write the value of SMU_ISR_COMPLETION?
name|SMU_IMR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0xFF000000
argument_list|)
expr_stmt|;
name|SMU_IMR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This is the method provided to handle the error MSIX message  *        interrupt.  This is the normal operating mode for the hardware if  *        MSIX is enabled.  *  * @param[in] controller  *  * @return BOOL  * @retval TRUE if an interrupt is processed  *         FALSE if no interrupt was processed  */
end_comment

begin_function
specifier|static
name|BOOL
name|scic_sds_controller_error_vector_interrupt_handler
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|U32
name|interrupt_status
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|interrupt_status
operator|=
name|SMU_ISR_READ
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|interrupt_status
operator|&=
operator|(
name|SMU_ISR_QUEUE_ERROR
operator||
name|SMU_ISR_QUEUE_SUSPEND
operator|)
expr_stmt|;
if|if
condition|(
name|interrupt_status
operator|!=
literal|0
condition|)
block|{
comment|// There is an error interrupt pending so let it through and handle
comment|// in the callback
return|return
name|TRUE
return|;
block|}
comment|// There is a race in the hardware that could cause us not to be notified
comment|// of an interrupt completion if we do not take this step.  We will mask
comment|// then unmask the error interrupts so if there was another interrupt
comment|// pending we will be notified.
comment|// Could we write the value of (SMU_ISR_QUEUE_ERROR | SMU_ISR_QUEUE_SUSPEND)?
name|SMU_IMR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x000000FF
argument_list|)
expr_stmt|;
name|SMU_IMR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This is the method provided to handle the error completions when  *        the hardware is using two MSIX messages.  *  * @param[in] controller  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_error_vector_completion_handler
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|U32
name|interrupt_status
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_sds_controller_error_vector_completion_handler(0x%d) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
name|interrupt_status
operator|=
name|SMU_ISR_READ
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|interrupt_status
operator|&
name|SMU_ISR_QUEUE_SUSPEND
operator|)
operator|&&
name|scic_sds_controller_completion_queue_has_entries
argument_list|(
name|this_controller
argument_list|)
condition|)
block|{
name|scic_sds_controller_process_completions
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|SMU_ISR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|SMU_ISR_QUEUE_SUSPEND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller reports CRC error on completion ISR %x\n"
operator|,
name|interrupt_status
operator|)
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_FAILED
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// If we dont process any completions I am not sure that we want to do this.
comment|// We are in the middle of a hardware fault and should probably be reset.
name|SMU_IMR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !defined(DISABLE_INTERRUPTS)
end_comment

begin_comment
comment|//****************************************************************************-
end_comment

begin_comment
comment|//* SCIC SDS Controller External Methods
end_comment

begin_comment
comment|//****************************************************************************-
end_comment

begin_comment
comment|/**  * @brief This method returns the sizeof the SCIC SDS Controller Object  *  * @return U32  */
end_comment

begin_function
name|U32
name|scic_sds_controller_get_object_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|SCIC_SDS_CONTROLLER_T
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * This method returns the minimum number of timers that are required by the  * controller object.  This will include required timers for phys and ports.  *  * @return U32  * @retval The minimum number of timers that are required to make this  *         controller operational.  */
end_comment

begin_function
name|U32
name|scic_sds_controller_get_min_timer_count
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|SCIC_SDS_CONTROLLER_MIN_TIMER_COUNT
operator|+
name|scic_sds_port_get_min_timer_count
argument_list|()
operator|+
name|scic_sds_phy_get_min_timer_count
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**  * This method returns the maximum number of timers that are required by the  * controller object.  This will include required timers for phys and ports.  *  * @return U32  * @retval The maximum number of timers that will be used by the controller  *         object  */
end_comment

begin_function
name|U32
name|scic_sds_controller_get_max_timer_count
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|SCIC_SDS_CONTROLLER_MAX_TIMER_COUNT
operator|+
name|scic_sds_port_get_max_timer_count
argument_list|()
operator|+
name|scic_sds_phy_get_max_timer_count
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**  * @brief  *  * @param[in] this_controller  * @param[in] the_port  * @param[in] the_phy  *  * @return none  */
end_comment

begin_function
name|void
name|scic_sds_controller_link_up
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCIC_SDS_PORT_T
modifier|*
name|the_port
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|the_phy
parameter_list|)
block|{
if|if
condition|(
name|this_controller
operator|->
name|state_handlers
operator|->
name|link_up_handler
operator|!=
name|NULL
condition|)
block|{
name|this_controller
operator|->
name|state_handlers
operator|->
name|link_up_handler
argument_list|(
name|this_controller
argument_list|,
name|the_port
argument_list|,
name|the_phy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_INFO
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller linkup event from phy %d in unexpected state %d\n"
operator|,
name|the_phy
operator|->
name|phy_index
operator|,
name|sci_base_state_machine_get_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief  *  * @param[in] this_controller  * @param[in] the_port  * @param[in] the_phy  */
end_comment

begin_function
name|void
name|scic_sds_controller_link_down
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCIC_SDS_PORT_T
modifier|*
name|the_port
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|the_phy
parameter_list|)
block|{
if|if
condition|(
name|this_controller
operator|->
name|state_handlers
operator|->
name|link_down_handler
operator|!=
name|NULL
condition|)
block|{
name|this_controller
operator|->
name|state_handlers
operator|->
name|link_down_handler
argument_list|(
name|this_controller
argument_list|,
name|the_port
argument_list|,
name|the_phy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_INFO
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller linkdown event from phy %d in unexpected state %d\n"
operator|,
name|the_phy
operator|->
name|phy_index
operator|,
name|sci_base_state_machine_get_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method is called by the remote device to inform the controller  *        that this remote device has started.  *  * @param[in] this_controller  * @param[in] the_device  */
end_comment

begin_function
name|void
name|scic_sds_controller_remote_device_started
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCIC_SDS_REMOTE_DEVICE_T
modifier|*
name|the_device
parameter_list|)
block|{
if|if
condition|(
name|this_controller
operator|->
name|state_handlers
operator|->
name|remote_device_started_handler
operator|!=
name|NULL
condition|)
block|{
name|this_controller
operator|->
name|state_handlers
operator|->
name|remote_device_started_handler
argument_list|(
name|this_controller
argument_list|,
name|the_device
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_INFO
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller 0x%x remote device started event from device 0x%x in unexpected state %d\n"
operator|,
name|this_controller
operator|,
name|the_device
operator|,
name|sci_base_state_machine_get_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This is a helper method to determine if any remote devices on this  *        controller are still in the stopping state.  *  * @param[in] this_controller  */
end_comment

begin_function
name|BOOL
name|scic_sds_controller_has_remote_devices_stopping
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U32
name|index
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|this_controller
operator|->
name|remote_node_entries
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|this_controller
operator|->
name|device_table
index|[
name|index
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|this_controller
operator|->
name|device_table
index|[
name|index
index|]
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_REMOTE_DEVICE_STATE_STOPPING
operator|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method is called by the remote device to inform the controller  *        object that the remote device has stopped.  *  * @param[in] this_controller  * @param[in] the_device  */
end_comment

begin_function
name|void
name|scic_sds_controller_remote_device_stopped
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCIC_SDS_REMOTE_DEVICE_T
modifier|*
name|the_device
parameter_list|)
block|{
if|if
condition|(
name|this_controller
operator|->
name|state_handlers
operator|->
name|remote_device_stopped_handler
operator|!=
name|NULL
condition|)
block|{
name|this_controller
operator|->
name|state_handlers
operator|->
name|remote_device_stopped_handler
argument_list|(
name|this_controller
argument_list|,
name|the_device
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_INFO
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller 0x%x remote device stopped event from device 0x%x in unexpected state %d\n"
operator|,
name|this_controller
operator|,
name|the_device
operator|,
name|sci_base_state_machine_get_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method will write to the SCU PCP register the request value.  *        The method is used to suspend/resume ports, devices, and phys.  *  * @param[in] this_controller  * @param[in] request  */
end_comment

begin_function
name|void
name|scic_sds_controller_post_request
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|U32
name|request
parameter_list|)
block|{
name|SCIC_LOG_INFO
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_COMPLETION_QUEUE
operator|,
literal|"SCIC Controller 0x%08x post request 0x%08x\n"
operator|,
name|this_controller
operator|,
name|request
operator|)
argument_list|)
expr_stmt|;
name|SMU_PCP_WRITE
argument_list|(
name|this_controller
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will copy the soft copy of the task context into  *        the physical memory accessible by the controller.  *  * @note After this call is made the SCIC_SDS_IO_REQUEST object will  *       always point to the physical memory version of the task context.  *       Thus, all subsequent updates to the task context are performed in  *       the TC table (i.e. DMAable memory).  *  * @param[in]  this_controller This parameter specifies the controller for  *             which to copy the task context.  * @param[in]  this_request This parameter specifies the request for which  *             the task context is being copied.  *  * @return none  */
end_comment

begin_function
name|void
name|scic_sds_controller_copy_task_context
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
parameter_list|)
block|{
name|SCU_TASK_CONTEXT_T
modifier|*
name|task_context_buffer
decl_stmt|;
name|task_context_buffer
operator|=
name|scic_sds_controller_get_task_context_buffer
argument_list|(
name|this_controller
argument_list|,
name|this_request
operator|->
name|io_tag
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|task_context_buffer
argument_list|,
name|this_request
operator|->
name|task_context_buffer
argument_list|,
name|SCI_FIELD_OFFSET
argument_list|(
name|SCU_TASK_CONTEXT_T
argument_list|,
name|sgl_snapshot_ac
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now that the soft copy of the TC has been copied into the TC
comment|// table accessible by the silicon.  Thus, any further changes to
comment|// the TC (e.g. TC termination) occur in the appropriate location.
name|this_request
operator|->
name|task_context_buffer
operator|=
name|task_context_buffer
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method returns the task context buffer for the given io tag.  *  * @param[in] this_controller  * @param[in] io_tag  *  * @return struct SCU_TASK_CONTEXT*  */
end_comment

begin_function
name|SCU_TASK_CONTEXT_T
modifier|*
name|scic_sds_controller_get_task_context_buffer
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|U16
name|task_index
init|=
name|scic_sds_io_tag_get_index
argument_list|(
name|io_tag
argument_list|)
decl_stmt|;
if|if
condition|(
name|task_index
operator|<
name|this_controller
operator|->
name|task_context_entries
condition|)
block|{
return|return
operator|&
name|this_controller
operator|->
name|task_context_table
index|[
name|task_index
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method returnst the sequence value from the io tag value  *  * @param[in] this_controller  * @param[in] io_tag  *  * @return U16  */
end_comment

begin_function
name|U16
name|scic_sds_controller_get_io_sequence_from_tag
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
return|return
name|scic_sds_io_tag_get_sequence
argument_list|(
name|io_tag
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method returns the IO request associated with the tag value  *  * @param[in] this_controller  * @param[in] io_tag  *  * @return SCIC_SDS_IO_REQUEST_T*  * @retval NULL if there is no valid IO request at the tag value  */
end_comment

begin_function
name|SCIC_SDS_REQUEST_T
modifier|*
name|scic_sds_controller_get_io_request_from_tag
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|U16
name|task_index
decl_stmt|;
name|U16
name|task_sequence
decl_stmt|;
name|task_index
operator|=
name|scic_sds_io_tag_get_index
argument_list|(
name|io_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|task_index
operator|<
name|this_controller
operator|->
name|task_context_entries
condition|)
block|{
if|if
condition|(
name|this_controller
operator|->
name|io_request_table
index|[
name|task_index
index|]
operator|!=
name|SCI_INVALID_HANDLE
condition|)
block|{
name|task_sequence
operator|=
name|scic_sds_io_tag_get_sequence
argument_list|(
name|io_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|task_sequence
operator|==
name|this_controller
operator|->
name|io_request_sequence
index|[
name|task_index
index|]
condition|)
block|{
return|return
name|this_controller
operator|->
name|io_request_table
index|[
name|task_index
index|]
return|;
block|}
block|}
block|}
return|return
name|SCI_INVALID_HANDLE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method allocates remote node index and the reserves the  *        remote node context space for use. This method can fail if there  *        are no more remote node index available.  *  * @param[in] this_controller This is the controller object which contains  *            the set of free remote node ids  * @param[in] the_devce This is the device object which is requesting the a  *            remote node id  * @param[out] node_id This is the remote node id that is assinged to the  *             device if one is available  *  * @return SCI_STATUS  * @retval SCI_FAILURE_OUT_OF_RESOURCES if there are no available remote  *         node index available.  */
end_comment

begin_function
name|SCI_STATUS
name|scic_sds_controller_allocate_remote_node_context
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCIC_SDS_REMOTE_DEVICE_T
modifier|*
name|the_device
parameter_list|,
name|U16
modifier|*
name|node_id
parameter_list|)
block|{
name|U16
name|node_index
decl_stmt|;
name|U32
name|remote_node_count
init|=
name|scic_sds_remote_device_node_count
argument_list|(
name|the_device
argument_list|)
decl_stmt|;
name|node_index
operator|=
name|scic_sds_remote_node_table_allocate_remote_node
argument_list|(
operator|&
name|this_controller
operator|->
name|available_remote_nodes
argument_list|,
name|remote_node_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_index
operator|!=
name|SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX
condition|)
block|{
name|this_controller
operator|->
name|device_table
index|[
name|node_index
index|]
operator|=
name|the_device
expr_stmt|;
operator|*
name|node_id
operator|=
name|node_index
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
return|return
name|SCI_FAILURE_INSUFFICIENT_RESOURCES
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method frees the remote node index back to the available  *        pool.  Once this is done the remote node context buffer is no  *        longer valid and can not be used.  *  * @param[in] this_controller  * @param[in] the_device  * @param[in] node_id  *  * @return none  */
end_comment

begin_function
name|void
name|scic_sds_controller_free_remote_node_context
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCIC_SDS_REMOTE_DEVICE_T
modifier|*
name|the_device
parameter_list|,
name|U16
name|node_id
parameter_list|)
block|{
name|U32
name|remote_node_count
init|=
name|scic_sds_remote_device_node_count
argument_list|(
name|the_device
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|device_table
index|[
name|node_id
index|]
operator|==
name|the_device
condition|)
block|{
name|this_controller
operator|->
name|device_table
index|[
name|node_id
index|]
operator|=
name|SCI_INVALID_HANDLE
expr_stmt|;
name|scic_sds_remote_node_table_release_remote_node_index
argument_list|(
operator|&
name|this_controller
operator|->
name|available_remote_nodes
argument_list|,
name|remote_node_count
argument_list|,
name|node_id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method returns the SCU_REMOTE_NODE_CONTEXT for the specified  *        remote node id.  *  * @param[in] this_controller  * @param[in] node_id  *  * @return SCU_REMOTE_NODE_CONTEXT_T*  */
end_comment

begin_function
name|SCU_REMOTE_NODE_CONTEXT_T
modifier|*
name|scic_sds_controller_get_remote_node_context_buffer
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|U16
name|node_id
parameter_list|)
block|{
if|if
condition|(
operator|(
name|node_id
operator|<
name|this_controller
operator|->
name|remote_node_entries
operator|)
operator|&&
operator|(
name|this_controller
operator|->
name|device_table
index|[
name|node_id
index|]
operator|!=
name|SCI_INVALID_HANDLE
operator|)
condition|)
block|{
return|return
operator|&
name|this_controller
operator|->
name|remote_node_context_table
index|[
name|node_id
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * This method will combind the frame header and frame buffer to create  * a SATA D2H register FIS  *  * @param[out] resposne_buffer This is the buffer into which the D2H register  *             FIS will be constructed.  * @param[in]  frame_header This is the frame header returned by the hardware.  * @param[in]  frame_buffer This is the frame buffer returned by the hardware.  *  * @erturn none  */
end_comment

begin_function
name|void
name|scic_sds_controller_copy_sata_response
parameter_list|(
name|void
modifier|*
name|response_buffer
parameter_list|,
name|void
modifier|*
name|frame_header
parameter_list|,
name|void
modifier|*
name|frame_buffer
parameter_list|)
block|{
name|memcpy
argument_list|(
name|response_buffer
argument_list|,
name|frame_header
argument_list|,
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|response_buffer
operator|+
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
argument_list|,
name|frame_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|SATA_FIS_REG_D2H_T
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method releases the frame once this is done the frame is  *        available for re-use by the hardware.  The data contained in the  *        frame header and frame buffer is no longer valid.  *        The UF queue get pointer is only updated if UF control indicates  *        this is appropriate.  *  * @param[in] this_controller  * @param[in] frame_index  *  * @return none  */
end_comment

begin_function
name|void
name|scic_sds_controller_release_frame
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|U32
name|frame_index
parameter_list|)
block|{
if|if
condition|(
name|scic_sds_unsolicited_frame_control_release_frame
argument_list|(
operator|&
name|this_controller
operator|->
name|uf_control
argument_list|,
name|frame_index
argument_list|)
operator|==
name|TRUE
condition|)
name|SCU_UFQGP_WRITE
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|uf_control
operator|.
name|get
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCI_LOGGING
end_ifdef

begin_function
name|void
name|scic_sds_controller_initialize_state_logging
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|sci_base_state_machine_logger_initialize
argument_list|(
operator|&
name|this_controller
operator|->
name|parent
operator|.
name|state_machine_logger
argument_list|,
operator|&
name|this_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
operator|&
name|this_controller
operator|->
name|parent
operator|.
name|parent
argument_list|,
name|scic_cb_logger_log_states
argument_list|,
literal|"SCIC_SDS_CONTROLLER_T"
argument_list|,
literal|"base state machine"
argument_list|,
name|SCIC_LOG_OBJECT_CONTROLLER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scic_sds_controller_deinitialize_state_logging
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|sci_base_state_machine_logger_deinitialize
argument_list|(
operator|&
name|this_controller
operator|->
name|parent
operator|.
name|state_machine_logger
argument_list|,
operator|&
name|this_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @brief This method sets user parameters and OEM parameters to  *        default values.  Users can override these values utilizing  *        the scic_user_parameters_set() and scic_oem_parameters_set()  *        methods.  *  * @param[in] controller This parameter specifies the controller for  *            which to set the configuration parameters to their  *            default values.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_set_default_config_parameters
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|U16
name|index
decl_stmt|;
comment|// Default to APC mode.
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|controller
operator|.
name|mode_type
operator|=
name|SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE
expr_stmt|;
comment|// Default to 1
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|controller
operator|.
name|max_number_concurrent_device_spin_up
operator|=
literal|1
expr_stmt|;
comment|// Default to no SSC operation.
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|controller
operator|.
name|ssc_sata_tx_spread_level
operator|=
literal|0
expr_stmt|;
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|controller
operator|.
name|ssc_sas_tx_spread_level
operator|=
literal|0
expr_stmt|;
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|controller
operator|.
name|ssc_sas_tx_type
operator|=
literal|0
expr_stmt|;
comment|// Default to all phys to using short cables
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|controller
operator|.
name|cable_selection_mask
operator|=
literal|0
expr_stmt|;
comment|// Initialize all of the port parameter information to narrow ports.
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PORTS
condition|;
name|index
operator|++
control|)
block|{
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|ports
index|[
name|index
index|]
operator|.
name|phy_mask
operator|=
literal|0
expr_stmt|;
block|}
comment|// Initialize all of the phy parameter information.
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PHYS
condition|;
name|index
operator|++
control|)
block|{
comment|// Default to 6G (i.e. Gen 3) for now.  User can override if
comment|// they choose.
name|this_controller
operator|->
name|user_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|max_speed_generation
operator|=
literal|2
expr_stmt|;
comment|//the frequencies cannot be 0
name|this_controller
operator|->
name|user_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|align_insertion_frequency
operator|=
literal|0x7f
expr_stmt|;
name|this_controller
operator|->
name|user_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|in_connection_align_insertion_frequency
operator|=
literal|0xff
expr_stmt|;
name|this_controller
operator|->
name|user_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|notify_enable_spin_up_insertion_frequency
operator|=
literal|0x33
expr_stmt|;
comment|// Previous Vitesse based expanders had a arbitration issue that
comment|// is worked around by having the upper 32-bits of SAS address
comment|// with a value greater then the Vitesse company identifier.
comment|// Hence, usage of 0x5FCFFFFF.
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|sas_address
operator|.
name|sci_format
operator|.
name|high
operator|=
literal|0x5FCFFFFF
expr_stmt|;
comment|// Add in controller index to ensure each controller will have unique SAS addresses by default.
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|sas_address
operator|.
name|sci_format
operator|.
name|low
operator|=
literal|0x00000001
operator|+
name|this_controller
operator|->
name|controller_index
expr_stmt|;
if|if
condition|(
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A0
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_A2
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|pci_revision
operator|==
name|SCIC_SDS_PCI_REVISION_B0
operator|)
condition|)
block|{
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|afe_tx_amp_control0
operator|=
literal|0x000E7C03
expr_stmt|;
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|afe_tx_amp_control1
operator|=
literal|0x000E7C03
expr_stmt|;
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|afe_tx_amp_control2
operator|=
literal|0x000E7C03
expr_stmt|;
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|afe_tx_amp_control3
operator|=
literal|0x000E7C03
expr_stmt|;
block|}
else|else
comment|// This must be SCIC_SDS_PCI_REVISION_C0
block|{
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|afe_tx_amp_control0
operator|=
literal|0x000BDD08
expr_stmt|;
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|afe_tx_amp_control1
operator|=
literal|0x000B7069
expr_stmt|;
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|afe_tx_amp_control2
operator|=
literal|0x000B7C09
expr_stmt|;
name|this_controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|afe_tx_amp_control3
operator|=
literal|0x000AFC6E
expr_stmt|;
block|}
block|}
name|this_controller
operator|->
name|user_parameters
operator|.
name|sds1
operator|.
name|stp_inactivity_timeout
operator|=
literal|5
expr_stmt|;
name|this_controller
operator|->
name|user_parameters
operator|.
name|sds1
operator|.
name|ssp_inactivity_timeout
operator|=
literal|5
expr_stmt|;
name|this_controller
operator|->
name|user_parameters
operator|.
name|sds1
operator|.
name|stp_max_occupancy_timeout
operator|=
literal|5
expr_stmt|;
name|this_controller
operator|->
name|user_parameters
operator|.
name|sds1
operator|.
name|ssp_max_occupancy_timeout
operator|=
literal|20
expr_stmt|;
name|this_controller
operator|->
name|user_parameters
operator|.
name|sds1
operator|.
name|no_outbound_task_timeout
operator|=
literal|20
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method release resources in SCI controller.  *  * @param[in] this_controller This parameter specifies the core  *            controller and associated objects whose resources are to be  *            released.  *  * @return This method returns a value indicating if the operation succeeded.  * @retval SCI_SUCCESS This value indicates that all the timers are destroyed.  * @retval SCI_FAILURE This value indicates certain failure during the process  *            of cleaning timer resource.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_release_resource
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|SCIC_SDS_PORT_T
modifier|*
name|port
decl_stmt|;
name|SCIC_SDS_PHY_T
modifier|*
name|phy
decl_stmt|;
name|U8
name|index
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_INITIALIZATION
operator|,
literal|"scic_sds_controller_release_resource(0x%x) enter\n"
operator|,
name|this_controller
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|phy_startup_timer
operator|!=
name|NULL
condition|)
block|{
name|scic_cb_timer_destroy
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|phy_startup_timer
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|phy_startup_timer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|this_controller
operator|->
name|power_control
operator|.
name|timer
operator|!=
name|NULL
condition|)
block|{
name|scic_cb_timer_destroy
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|power_control
operator|.
name|timer
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|power_control
operator|.
name|timer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|this_controller
operator|->
name|timeout_timer
operator|!=
name|NULL
condition|)
block|{
name|scic_cb_timer_destroy
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|timeout_timer
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|timeout_timer
operator|=
name|NULL
expr_stmt|;
block|}
name|scic_sds_port_configuration_agent_release_resource
argument_list|(
name|this_controller
argument_list|,
operator|&
name|this_controller
operator|->
name|port_agent
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PORTS
operator|+
literal|1
condition|;
name|index
operator|++
control|)
block|{
name|port
operator|=
operator|&
name|this_controller
operator|->
name|port_table
index|[
name|index
index|]
expr_stmt|;
name|scic_sds_port_release_resource
argument_list|(
name|this_controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PHYS
condition|;
name|index
operator|++
control|)
block|{
name|phy
operator|=
operator|&
name|this_controller
operator|->
name|phy_table
index|[
name|index
index|]
expr_stmt|;
name|scic_sds_phy_release_resource
argument_list|(
name|this_controller
argument_list|,
name|phy
argument_list|)
expr_stmt|;
block|}
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method process the ports configured message from port configuration  *           agent.  *  * @param[in] this_controller This parameter specifies the core  *            controller that its ports are configured.  *  * @return None.  */
end_comment

begin_function
name|void
name|scic_sds_controller_port_agent_configured_ports
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
comment|//simply transit to ready. The function below checks the controller state
name|scic_sds_controller_transition_to_ready
argument_list|(
name|this_controller
argument_list|,
name|SCI_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//****************************************************************************-
end_comment

begin_comment
comment|//* SCIC Controller Public Methods
end_comment

begin_comment
comment|//****************************************************************************-
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_construct
parameter_list|(
name|SCI_LIBRARY_HANDLE_T
name|library
parameter_list|,
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|void
modifier|*
name|user_object
parameter_list|)
block|{
name|SCIC_SDS_LIBRARY_T
modifier|*
name|my_library
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|my_library
operator|=
operator|(
name|SCIC_SDS_LIBRARY_T
operator|*
operator|)
name|library
expr_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|library
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_INITIALIZATION
operator|,
literal|"scic_controller_construct(0x%x, 0x%x) enter\n"
operator|,
name|library
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
comment|// Just clear out the memory of the structure to be safe.
name|memset
argument_list|(
name|this_controller
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SCIC_SDS_CONTROLLER_T
argument_list|)
argument_list|)
expr_stmt|;
comment|// Make sure that the static data is assigned before moving onto the
comment|// base constroller construct as this will cause the controller to
comment|// enter its initial state and the controller_index and pci_revision
comment|// will be required to complete those operations correctly
name|this_controller
operator|->
name|controller_index
operator|=
name|scic_sds_library_get_controller_index
argument_list|(
name|my_library
argument_list|,
name|this_controller
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|pci_revision
operator|=
name|my_library
operator|->
name|pci_revision
expr_stmt|;
name|sci_base_controller_construct
argument_list|(
operator|&
name|this_controller
operator|->
name|parent
argument_list|,
name|sci_base_object_get_logger
argument_list|(
name|my_library
argument_list|)
argument_list|,
name|scic_sds_controller_state_table
argument_list|,
name|this_controller
operator|->
name|memory_descriptors
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|this_controller
operator|->
name|memory_descriptors
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sci_object_set_association
argument_list|(
name|controller
argument_list|,
name|user_object
argument_list|)
expr_stmt|;
name|scic_sds_controller_initialize_state_logging
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|scic_sds_pci_bar_initialization
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_initialize
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_FAILURE_INVALID_STATE
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_initialize(0x%x, 0x%d) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|initialize_handler
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|this_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|initialize_handler
argument_list|(
operator|(
name|SCI_BASE_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller initialize operation requested in invalid state %d\n"
operator|,
name|sci_base_state_machine_get_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|U32
name|scic_controller_get_suggested_start_timeout
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
comment|// Validate the user supplied parameters.
if|if
condition|(
name|controller
operator|==
name|SCI_INVALID_HANDLE
condition|)
return|return
literal|0
return|;
comment|// The suggested minimum timeout value for a controller start operation:
comment|//
comment|//     Signature FIS Timeout
comment|//   + Phy Start Timeout
comment|//   + Number of Phy Spin Up Intervals
comment|//   ---------------------------------
comment|//   Number of milliseconds for the controller start operation.
comment|//
comment|// NOTE: The number of phy spin up intervals will be equivalent
comment|//       to the number of phys divided by the number phys allowed
comment|//       per interval - 1 (once OEM parameters are supported).
comment|//       Currently we assume only 1 phy per interval.
return|return
operator|(
name|SCIC_SDS_SIGNATURE_FIS_TIMEOUT
operator|+
name|SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT
operator|+
operator|(
operator|(
name|SCI_MAX_PHYS
operator|-
literal|1
operator|)
operator|*
name|SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_start
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U32
name|timeout
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_FAILURE_INVALID_STATE
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_start(0x%x, 0x%d) enter\n"
operator|,
name|controller
operator|,
name|timeout
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|start_handler
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|this_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|start_handler
argument_list|(
operator|(
name|SCI_BASE_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller start operation requested in invalid state %d\n"
operator|,
name|sci_base_state_machine_get_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_stop
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U32
name|timeout
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_FAILURE_INVALID_STATE
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_stop(0x%x, 0x%d) enter\n"
operator|,
name|controller
operator|,
name|timeout
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|stop_handler
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|this_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|stop_handler
argument_list|(
operator|(
name|SCI_BASE_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller stop operation requested in invalid state %d\n"
operator|,
name|sci_base_state_machine_get_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_reset
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_FAILURE_INVALID_STATE
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_reset(0x%x) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|reset_handler
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|this_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|reset_handler
argument_list|(
operator|(
name|SCI_BASE_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller reset operation requested in invalid state %d\n"
operator|,
name|sci_base_state_machine_get_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_get_handler_methods
parameter_list|(
name|SCIC_INTERRUPT_TYPE
name|interrupt_type
parameter_list|,
name|U16
name|message_count
parameter_list|,
name|SCIC_CONTROLLER_HANDLER_METHODS_T
modifier|*
name|handler_methods
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_FAILURE_UNSUPPORTED_MESSAGE_COUNT
decl_stmt|;
switch|switch
condition|(
name|interrupt_type
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_INTERRUPTS
argument_list|)
case|case
name|SCIC_LEGACY_LINE_INTERRUPT_TYPE
case|:
if|if
condition|(
name|message_count
operator|==
literal|0
condition|)
block|{
name|handler_methods
index|[
literal|0
index|]
operator|.
name|interrupt_handler
operator|=
name|scic_sds_controller_legacy_interrupt_handler
expr_stmt|;
name|handler_methods
index|[
literal|0
index|]
operator|.
name|completion_handler
operator|=
name|scic_sds_controller_legacy_completion_handler
expr_stmt|;
name|status
operator|=
name|SCI_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|SCIC_MSIX_INTERRUPT_TYPE
case|:
if|if
condition|(
name|message_count
operator|==
literal|1
condition|)
block|{
name|handler_methods
index|[
literal|0
index|]
operator|.
name|interrupt_handler
operator|=
name|scic_sds_controller_single_vector_interrupt_handler
expr_stmt|;
name|handler_methods
index|[
literal|0
index|]
operator|.
name|completion_handler
operator|=
name|scic_sds_controller_single_vector_completion_handler
expr_stmt|;
name|status
operator|=
name|SCI_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|message_count
operator|==
literal|2
condition|)
block|{
name|handler_methods
index|[
literal|0
index|]
operator|.
name|interrupt_handler
operator|=
name|scic_sds_controller_normal_vector_interrupt_handler
expr_stmt|;
name|handler_methods
index|[
literal|0
index|]
operator|.
name|completion_handler
operator|=
name|scic_sds_controller_normal_vector_completion_handler
expr_stmt|;
name|handler_methods
index|[
literal|1
index|]
operator|.
name|interrupt_handler
operator|=
name|scic_sds_controller_error_vector_interrupt_handler
expr_stmt|;
name|handler_methods
index|[
literal|1
index|]
operator|.
name|completion_handler
operator|=
name|scic_sds_controller_error_vector_completion_handler
expr_stmt|;
name|status
operator|=
name|SCI_SUCCESS
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|// !defined(DISABLE_INTERRUPTS)
case|case
name|SCIC_NO_INTERRUPTS
case|:
if|if
condition|(
name|message_count
operator|==
literal|0
condition|)
block|{
name|handler_methods
index|[
literal|0
index|]
operator|.
name|interrupt_handler
operator|=
name|scic_sds_controller_polling_interrupt_handler
expr_stmt|;
name|handler_methods
index|[
literal|0
index|]
operator|.
name|completion_handler
operator|=
name|scic_sds_controller_polling_completion_handler
expr_stmt|;
name|status
operator|=
name|SCI_SUCCESS
expr_stmt|;
block|}
break|break;
default|default:
name|status
operator|=
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
expr_stmt|;
break|break;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_IO_STATUS
name|scic_controller_start_io
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_REMOTE_DEVICE_HANDLE_T
name|remote_device
parameter_list|,
name|SCI_IO_REQUEST_HANDLE_T
name|io_request
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_start_io(0x%x, 0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|io_request
operator|,
name|io_tag
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|this_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|start_io_handler
argument_list|(
operator|&
name|this_controller
operator|->
name|parent
argument_list|,
operator|(
name|SCI_BASE_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
argument_list|,
operator|(
name|SCI_BASE_REQUEST_T
operator|*
operator|)
name|io_request
argument_list|,
name|io_tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCI_IO_STATUS
operator|)
name|status
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_terminate_request
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_REMOTE_DEVICE_HANDLE_T
name|remote_device
parameter_list|,
name|SCI_IO_REQUEST_HANDLE_T
name|request
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_terminate_request(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|request
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|this_controller
operator|->
name|state_handlers
operator|->
name|terminate_request_handler
argument_list|(
operator|&
name|this_controller
operator|->
name|parent
argument_list|,
operator|(
name|SCI_BASE_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
argument_list|,
operator|(
name|SCI_BASE_REQUEST_T
operator|*
operator|)
name|request
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_complete_io
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_REMOTE_DEVICE_HANDLE_T
name|remote_device
parameter_list|,
name|SCI_IO_REQUEST_HANDLE_T
name|io_request
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_complete_io(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|io_request
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|this_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|complete_io_handler
argument_list|(
operator|&
name|this_controller
operator|->
name|parent
argument_list|,
operator|(
name|SCI_BASE_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
argument_list|,
operator|(
name|SCI_BASE_REQUEST_T
operator|*
operator|)
name|io_request
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_TASK_MANAGEMENT
argument_list|)
end_if

begin_function
name|SCI_TASK_STATUS
name|scic_controller_start_task
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_REMOTE_DEVICE_HANDLE_T
name|remote_device
parameter_list|,
name|SCI_TASK_REQUEST_HANDLE_T
name|task_request
parameter_list|,
name|U16
name|task_tag
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_FAILURE_INVALID_STATE
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_start_task(0x%x, 0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|task_request
operator|,
name|task_tag
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|start_task_handler
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|this_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|start_task_handler
argument_list|(
operator|&
name|this_controller
operator|->
name|parent
argument_list|,
operator|(
name|SCI_BASE_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
argument_list|,
operator|(
name|SCI_BASE_REQUEST_T
operator|*
operator|)
name|task_request
argument_list|,
name|task_tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_INFO
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller starting task from invalid state\n"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SCI_TASK_STATUS
operator|)
name|status
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_complete_task
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_REMOTE_DEVICE_HANDLE_T
name|remote_device
parameter_list|,
name|SCI_TASK_REQUEST_HANDLE_T
name|task_request
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_FAILURE_INVALID_STATE
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_complete_task(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|task_request
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|complete_task_handler
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|this_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|complete_task_handler
argument_list|(
operator|&
name|this_controller
operator|->
name|parent
argument_list|,
operator|(
name|SCI_BASE_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
argument_list|,
operator|(
name|SCI_BASE_REQUEST_T
operator|*
operator|)
name|task_request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_INFO
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller completing task from invalid state\n"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !defined(DISABLE_TASK_MANAGEMENT)
end_comment

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_get_port_handle
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U8
name|port_index
parameter_list|,
name|SCI_PORT_HANDLE_T
modifier|*
name|port_handle
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_get_port_handle(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|port_index
operator|,
name|port_handle
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_index
operator|<
name|this_controller
operator|->
name|logical_port_entries
condition|)
block|{
operator|*
name|port_handle
operator|=
operator|&
name|this_controller
operator|->
name|port_table
index|[
name|port_index
index|]
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
return|return
name|SCI_FAILURE_INVALID_PORT
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_get_phy_handle
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U8
name|phy_index
parameter_list|,
name|SCI_PHY_HANDLE_T
modifier|*
name|phy_handle
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_get_phy_handle(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|phy_index
operator|,
name|phy_handle
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_index
operator|<
name|ARRAY_SIZE
argument_list|(
name|this_controller
operator|->
name|phy_table
argument_list|)
condition|)
block|{
operator|*
name|phy_handle
operator|=
operator|&
name|this_controller
operator|->
name|phy_table
index|[
name|phy_index
index|]
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_PORT
operator||
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x PhyId:0x%x invalid phy index\n"
operator|,
name|this_controller
operator|,
name|phy_index
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_INVALID_PHY
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|U16
name|scic_controller_allocate_io_tag
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|U16
name|task_context
decl_stmt|;
name|U16
name|sequence_count
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_allocate_io_tag(0x%x) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sci_pool_empty
argument_list|(
name|this_controller
operator|->
name|tci_pool
argument_list|)
condition|)
block|{
name|sci_pool_get
argument_list|(
name|this_controller
operator|->
name|tci_pool
argument_list|,
name|task_context
argument_list|)
expr_stmt|;
name|sequence_count
operator|=
name|this_controller
operator|->
name|io_request_sequence
index|[
name|task_context
index|]
expr_stmt|;
return|return
name|scic_sds_io_tag_construct
argument_list|(
name|sequence_count
argument_list|,
name|task_context
argument_list|)
return|;
block|}
return|return
name|SCI_CONTROLLER_INVALID_IO_TAG
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_free_io_tag
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|U16
name|sequence
decl_stmt|;
name|U16
name|index
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|ASSERT
argument_list|(
name|io_tag
operator|!=
name|SCI_CONTROLLER_INVALID_IO_TAG
argument_list|)
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_free_io_tag(0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|io_tag
operator|)
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|scic_sds_io_tag_get_sequence
argument_list|(
name|io_tag
argument_list|)
expr_stmt|;
name|index
operator|=
name|scic_sds_io_tag_get_index
argument_list|(
name|io_tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sci_pool_full
argument_list|(
name|this_controller
operator|->
name|tci_pool
argument_list|)
condition|)
block|{
if|if
condition|(
name|sequence
operator|==
name|this_controller
operator|->
name|io_request_sequence
index|[
name|index
index|]
condition|)
block|{
name|scic_sds_io_sequence_increment
argument_list|(
name|this_controller
operator|->
name|io_request_sequence
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|sci_pool_put
argument_list|(
name|this_controller
operator|->
name|tci_pool
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
block|}
return|return
name|SCI_FAILURE_INVALID_IO_TAG
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_controller_enable_interrupts
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|ASSERT
argument_list|(
name|this_controller
operator|->
name|smu_registers
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SMU_IMR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_controller_disable_interrupts
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|ASSERT
argument_list|(
name|this_controller
operator|->
name|smu_registers
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SMU_IMR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_set_mode
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_CONTROLLER_MODE
name|operating_mode
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_set_mode(0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|operating_mode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|this_controller
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_CONTROLLER_STATE_INITIALIZING
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_CONTROLLER_STATE_INITIALIZED
operator|)
condition|)
block|{
switch|switch
condition|(
name|operating_mode
condition|)
block|{
case|case
name|SCI_MODE_SPEED
case|:
name|this_controller
operator|->
name|remote_node_entries
operator|=
name|MIN
argument_list|(
name|this_controller
operator|->
name|remote_node_entries
argument_list|,
name|SCI_MAX_REMOTE_DEVICES
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|task_context_entries
operator|=
name|MIN
argument_list|(
name|this_controller
operator|->
name|task_context_entries
argument_list|,
name|SCU_IO_REQUEST_COUNT
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|uf_control
operator|.
name|buffers
operator|.
name|count
operator|=
name|MIN
argument_list|(
name|this_controller
operator|->
name|uf_control
operator|.
name|buffers
operator|.
name|count
argument_list|,
name|SCU_UNSOLICITED_FRAME_COUNT
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|completion_event_entries
operator|=
name|MIN
argument_list|(
name|this_controller
operator|->
name|completion_event_entries
argument_list|,
name|SCU_EVENT_COUNT
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|completion_queue_entries
operator|=
name|MIN
argument_list|(
name|this_controller
operator|->
name|completion_queue_entries
argument_list|,
name|SCU_COMPLETION_QUEUE_COUNT
argument_list|)
expr_stmt|;
name|scic_sds_controller_build_memory_descriptor_table
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCI_MODE_SIZE
case|:
name|this_controller
operator|->
name|remote_node_entries
operator|=
name|MIN
argument_list|(
name|this_controller
operator|->
name|remote_node_entries
argument_list|,
name|SCI_MIN_REMOTE_DEVICES
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|task_context_entries
operator|=
name|MIN
argument_list|(
name|this_controller
operator|->
name|task_context_entries
argument_list|,
name|SCI_MIN_IO_REQUESTS
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|uf_control
operator|.
name|buffers
operator|.
name|count
operator|=
name|MIN
argument_list|(
name|this_controller
operator|->
name|uf_control
operator|.
name|buffers
operator|.
name|count
argument_list|,
name|SCU_MIN_UNSOLICITED_FRAMES
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|completion_event_entries
operator|=
name|MIN
argument_list|(
name|this_controller
operator|->
name|completion_event_entries
argument_list|,
name|SCU_MIN_EVENTS
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|completion_queue_entries
operator|=
name|MIN
argument_list|(
name|this_controller
operator|->
name|completion_queue_entries
argument_list|,
name|SCU_MIN_COMPLETION_QUEUE_ENTRIES
argument_list|)
expr_stmt|;
name|scic_sds_controller_build_memory_descriptor_table
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
expr_stmt|;
break|break;
block|}
block|}
else|else
name|status
operator|=
name|SCI_FAILURE_INVALID_STATE
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * This method will reset the controller hardware.  *  * @param[in] this_controller The controller that is to be reset.  */
end_comment

begin_function
name|void
name|scic_sds_controller_reset_hardware
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
comment|// Disable interrupts so we dont take any spurious interrupts
name|scic_controller_disable_interrupts
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
comment|// Reset the SCU
name|SMU_SMUSRCR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|// Delay for 1ms to before clearing the CQP and UFQPR.
name|scic_cb_stall_execution
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|// The write to the CQGR clears the CQP
name|SMU_CQGR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
comment|// The write to the UFQGP clears the UFQPR
name|SCU_UFQGP_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_user_parameters_set
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCIC_USER_PARAMETERS_T
modifier|*
name|scic_parms
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
if|if
condition|(
operator|(
name|this_controller
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_CONTROLLER_STATE_RESET
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_CONTROLLER_STATE_INITIALIZING
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_CONTROLLER_STATE_INITIALIZED
operator|)
condition|)
block|{
name|U16
name|index
decl_stmt|;
comment|// Validate the user parameters.  If they are not legal, then
comment|// return a failure.
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PHYS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|scic_parms
operator|->
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|max_speed_generation
operator|<=
name|SCIC_SDS_PARM_MAX_SPEED
operator|&&
name|scic_parms
operator|->
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|max_speed_generation
operator|>
name|SCIC_SDS_PARM_NO_SPEED
operator|)
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
if|if
condition|(
operator|(
name|scic_parms
operator|->
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|in_connection_align_insertion_frequency
operator|<
literal|3
operator|)
operator|||
operator|(
name|scic_parms
operator|->
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|align_insertion_frequency
operator|==
literal|0
operator|)
operator|||
operator|(
name|scic_parms
operator|->
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|notify_enable_spin_up_insertion_frequency
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
block|}
if|if
condition|(
operator|(
name|scic_parms
operator|->
name|sds1
operator|.
name|stp_inactivity_timeout
operator|==
literal|0
operator|)
operator|||
operator|(
name|scic_parms
operator|->
name|sds1
operator|.
name|ssp_inactivity_timeout
operator|==
literal|0
operator|)
operator|||
operator|(
name|scic_parms
operator|->
name|sds1
operator|.
name|stp_max_occupancy_timeout
operator|==
literal|0
operator|)
operator|||
operator|(
name|scic_parms
operator|->
name|sds1
operator|.
name|ssp_max_occupancy_timeout
operator|==
literal|0
operator|)
operator|||
operator|(
name|scic_parms
operator|->
name|sds1
operator|.
name|no_outbound_task_timeout
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
name|memcpy
argument_list|(
operator|(
operator|&
name|this_controller
operator|->
name|user_parameters
operator|)
argument_list|,
name|scic_parms
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scic_parms
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
return|return
name|SCI_FAILURE_INVALID_STATE
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_user_parameters_get
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCIC_USER_PARAMETERS_T
modifier|*
name|scic_parms
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|memcpy
argument_list|(
name|scic_parms
argument_list|,
operator|(
operator|&
name|this_controller
operator|->
name|user_parameters
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scic_parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_oem_parameters_set
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCIC_OEM_PARAMETERS_T
modifier|*
name|scic_parms
parameter_list|,
name|U8
name|scic_parms_version
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCI_BIOS_OEM_PARAM_ELEMENT_T
modifier|*
name|old_oem_params
init|=
operator|(
name|SCI_BIOS_OEM_PARAM_ELEMENT_T
operator|*
operator|)
operator|(
operator|&
operator|(
name|scic_parms
operator|->
name|sds1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|this_controller
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_CONTROLLER_STATE_RESET
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_CONTROLLER_STATE_INITIALIZING
operator|)
operator|||
operator|(
name|this_controller
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_CONTROLLER_STATE_INITIALIZED
operator|)
condition|)
block|{
name|U16
name|index
decl_stmt|;
name|U8
name|combined_phy_mask
init|=
literal|0
decl_stmt|;
comment|/*        * Set the OEM parameter version for the controller. This comes        * from the OEM parameter block header or the registry depending        * on what WCDL is set to retrieve.        */
name|this_controller
operator|->
name|oem_parameters_version
operator|=
name|scic_parms_version
expr_stmt|;
comment|// Validate the oem parameters.  If they are not legal, then
comment|// return a failure.
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PORTS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|scic_parms
operator|->
name|sds1
operator|.
name|ports
index|[
name|index
index|]
operator|.
name|phy_mask
operator|>
name|SCIC_SDS_PARM_PHY_MASK_MAX
condition|)
block|{
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PHYS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|scic_parms
operator|->
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|sas_address
operator|.
name|sci_format
operator|.
name|high
operator|==
literal|0
operator|&&
name|scic_parms
operator|->
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|sas_address
operator|.
name|sci_format
operator|.
name|low
operator|==
literal|0
condition|)
block|{
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PBG_HBA_A0_BUILD
argument_list|)
operator|||
name|defined
argument_list|(
name|PBG_HBA_A2_BUILD
argument_list|)
operator|||
name|defined
argument_list|(
name|PBG_HBA_BETA_BUILD
argument_list|)
operator|||
name|defined
argument_list|(
name|PBG_BUILD
argument_list|)
if|if
condition|(
operator|(
name|scic_parms
operator|->
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|afe_tx_amp_control0
operator|==
literal|0
operator|)
operator|||
operator|(
name|scic_parms
operator|->
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|afe_tx_amp_control1
operator|==
literal|0
operator|)
operator|||
operator|(
name|scic_parms
operator|->
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|afe_tx_amp_control2
operator|==
literal|0
operator|)
operator|||
operator|(
name|scic_parms
operator|->
name|sds1
operator|.
name|phys
index|[
name|index
index|]
operator|.
name|afe_tx_amp_control3
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|scic_parms
operator|->
name|sds1
operator|.
name|controller
operator|.
name|mode_type
operator|==
name|SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE
condition|)
block|{
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PHYS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|scic_parms
operator|->
name|sds1
operator|.
name|ports
index|[
name|index
index|]
operator|.
name|phy_mask
operator|!=
literal|0
condition|)
block|{
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|scic_parms
operator|->
name|sds1
operator|.
name|controller
operator|.
name|mode_type
operator|==
name|SCIC_PORT_MANUAL_CONFIGURATION_MODE
condition|)
block|{
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PHYS
condition|;
name|index
operator|++
control|)
block|{
name|combined_phy_mask
operator||=
name|scic_parms
operator|->
name|sds1
operator|.
name|ports
index|[
name|index
index|]
operator|.
name|phy_mask
expr_stmt|;
block|}
if|if
condition|(
name|combined_phy_mask
operator|==
literal|0
condition|)
block|{
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
block|}
else|else
block|{
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
if|if
condition|(
name|scic_parms
operator|->
name|sds1
operator|.
name|controller
operator|.
name|max_number_concurrent_device_spin_up
operator|>
name|MAX_CONCURRENT_DEVICE_SPIN_UP_COUNT
condition|)
block|{
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
if|if
condition|(
name|old_oem_params
operator|->
name|controller
operator|.
name|do_enable_ssc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scic_parms_version
operator|==
name|SCI_OEM_PARAM_VER_1_0
operator|)
operator|&&
operator|(
name|old_oem_params
operator|->
name|controller
operator|.
name|do_enable_ssc
operator|!=
literal|0x01
operator|)
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
if|if
condition|(
name|scic_parms_version
operator|>=
name|SCI_OEM_PARAM_VER_1_1
condition|)
block|{
name|SCI_BIOS_OEM_PARAM_ELEMENT_v_1_1_T
modifier|*
name|oem_params
init|=
operator|(
name|SCI_BIOS_OEM_PARAM_ELEMENT_v_1_1_T
operator|*
operator|)
operator|(
operator|&
operator|(
name|scic_parms
operator|->
name|sds1
operator|)
operator|)
decl_stmt|;
name|U8
name|test
init|=
name|oem_params
operator|->
name|controller
operator|.
name|ssc_sata_tx_spread_level
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|test
operator|==
literal|0x0
operator|)
operator|||
operator|(
name|test
operator|==
literal|0x2
operator|)
operator|||
operator|(
name|test
operator|==
literal|0x3
operator|)
operator|||
operator|(
name|test
operator|==
literal|0x6
operator|)
operator|||
operator|(
name|test
operator|==
literal|0x7
operator|)
operator|)
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
name|test
operator|=
name|oem_params
operator|->
name|controller
operator|.
name|ssc_sas_tx_spread_level
expr_stmt|;
if|if
condition|(
name|oem_params
operator|->
name|controller
operator|.
name|ssc_sas_tx_type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|test
operator|==
literal|0x0
operator|)
operator|||
operator|(
name|test
operator|==
literal|0x2
operator|)
operator|||
operator|(
name|test
operator|==
literal|0x3
operator|)
operator|)
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
elseif|else
if|if
condition|(
name|oem_params
operator|->
name|controller
operator|.
name|ssc_sas_tx_type
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|test
operator|==
literal|0x0
operator|)
operator|||
operator|(
name|test
operator|==
literal|0x3
operator|)
operator|||
operator|(
name|test
operator|==
literal|0x6
operator|)
operator|)
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
block|}
block|}
name|memcpy
argument_list|(
operator|(
operator|&
name|this_controller
operator|->
name|oem_parameters
operator|)
argument_list|,
name|scic_parms
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scic_parms
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
return|return
name|SCI_FAILURE_INVALID_STATE
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_oem_parameters_get
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCIC_OEM_PARAMETERS_T
modifier|*
name|scic_parms
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|memcpy
argument_list|(
name|scic_parms
argument_list|,
operator|(
operator|&
name|this_controller
operator|->
name|oem_parameters
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scic_parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_INTERRUPTS
argument_list|)
end_if

begin_define
define|#
directive|define
name|INTERRUPT_COALESCE_TIMEOUT_BASE_RANGE_LOWER_BOUND_NS
value|853
end_define

begin_define
define|#
directive|define
name|INTERRUPT_COALESCE_TIMEOUT_BASE_RANGE_UPPER_BOUND_NS
value|1280
end_define

begin_define
define|#
directive|define
name|INTERRUPT_COALESCE_TIMEOUT_MAX_US
value|2700000
end_define

begin_define
define|#
directive|define
name|INTERRUPT_COALESCE_NUMBER_MAX
value|256
end_define

begin_define
define|#
directive|define
name|INTERRUPT_COALESCE_TIMEOUT_ENCODE_MIN
value|7
end_define

begin_define
define|#
directive|define
name|INTERRUPT_COALESCE_TIMEOUT_ENCODE_MAX
value|28
end_define

begin_function
name|SCI_STATUS
name|scic_controller_set_interrupt_coalescence
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U32
name|coalesce_number
parameter_list|,
name|U32
name|coalesce_timeout
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|scic_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|U8
name|timeout_encode
init|=
literal|0
decl_stmt|;
name|U32
name|min
init|=
literal|0
decl_stmt|;
name|U32
name|max
init|=
literal|0
decl_stmt|;
comment|//Check if the input parameters fall in the range.
if|if
condition|(
name|coalesce_number
operator|>
name|INTERRUPT_COALESCE_NUMBER_MAX
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
comment|//  Defined encoding for interrupt coalescing timeout:
comment|//              Value   Min      Max     Units
comment|//              -----   ---      ---     -----
comment|//              0       -        -       Disabled
comment|//              1       13.3     20.0    ns
comment|//              2       26.7     40.0
comment|//              3       53.3     80.0
comment|//              4       106.7    160.0
comment|//              5       213.3    320.0
comment|//              6       426.7    640.0
comment|//              7       853.3    1280.0
comment|//              8       1.7      2.6     us
comment|//              9       3.4      5.1
comment|//              10      6.8      10.2
comment|//              11      13.7     20.5
comment|//              12      27.3     41.0
comment|//              13      54.6     81.9
comment|//              14      109.2    163.8
comment|//              15      218.5    327.7
comment|//              16      436.9    655.4
comment|//              17      873.8    1310.7
comment|//              18      1.7      2.6     ms
comment|//              19      3.5      5.2
comment|//              20      7.0      10.5
comment|//              21      14.0     21.0
comment|//              22      28.0     41.9
comment|//              23      55.9     83.9
comment|//              24      111.8    167.8
comment|//              25      223.7    335.5
comment|//              26      447.4    671.1
comment|//              27      894.8    1342.2
comment|//              28      1.8      2.7     s
comment|//              Others Undefined
comment|//Use the table above to decide the encode of interrupt coalescing timeout
comment|//value for register writing.
if|if
condition|(
name|coalesce_timeout
operator|==
literal|0
condition|)
name|timeout_encode
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|//make the timeout value in unit of (10 ns).
name|coalesce_timeout
operator|=
name|coalesce_timeout
operator|*
literal|100
expr_stmt|;
name|min
operator|=
name|INTERRUPT_COALESCE_TIMEOUT_BASE_RANGE_LOWER_BOUND_NS
operator|/
literal|10
expr_stmt|;
name|max
operator|=
name|INTERRUPT_COALESCE_TIMEOUT_BASE_RANGE_UPPER_BOUND_NS
operator|/
literal|10
expr_stmt|;
comment|//get the encode of timeout for register writing.
for|for
control|(
name|timeout_encode
operator|=
name|INTERRUPT_COALESCE_TIMEOUT_ENCODE_MIN
init|;
name|timeout_encode
operator|<=
name|INTERRUPT_COALESCE_TIMEOUT_ENCODE_MAX
condition|;
name|timeout_encode
operator|++
control|)
block|{
if|if
condition|(
name|min
operator|<=
name|coalesce_timeout
operator|&&
name|max
operator|>
name|coalesce_timeout
condition|)
break|break;
elseif|else
if|if
condition|(
name|coalesce_timeout
operator|>=
name|max
operator|&&
name|coalesce_timeout
operator|<
name|min
operator|*
literal|2
operator|&&
name|coalesce_timeout
operator|<=
name|INTERRUPT_COALESCE_TIMEOUT_MAX_US
operator|*
literal|100
condition|)
block|{
if|if
condition|(
operator|(
name|coalesce_timeout
operator|-
name|max
operator|)
operator|<
operator|(
literal|2
operator|*
name|min
operator|-
name|coalesce_timeout
operator|)
condition|)
break|break;
else|else
block|{
name|timeout_encode
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|max
operator|=
name|max
operator|*
literal|2
expr_stmt|;
name|min
operator|=
name|min
operator|*
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|timeout_encode
operator|==
name|INTERRUPT_COALESCE_TIMEOUT_ENCODE_MAX
operator|+
literal|1
condition|)
comment|//the value is out of range.
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
name|SMU_ICC_WRITE
argument_list|(
name|scic_controller
argument_list|,
operator|(
name|SMU_ICC_GEN_VAL
argument_list|(
name|NUMBER
argument_list|,
name|coalesce_number
argument_list|)
operator||
name|SMU_ICC_GEN_VAL
argument_list|(
name|TIMER
argument_list|,
name|timeout_encode
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|scic_controller
operator|->
name|interrupt_coalesce_number
operator|=
operator|(
name|U16
operator|)
name|coalesce_number
expr_stmt|;
name|scic_controller
operator|->
name|interrupt_coalesce_timeout
operator|=
name|coalesce_timeout
operator|/
literal|100
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_controller_get_interrupt_coalescence
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U32
modifier|*
name|coalesce_number
parameter_list|,
name|U32
modifier|*
name|coalesce_timeout
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|scic_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
operator|*
name|coalesce_number
operator|=
name|scic_controller
operator|->
name|interrupt_coalesce_number
expr_stmt|;
operator|*
name|coalesce_timeout
operator|=
name|scic_controller
operator|->
name|interrupt_coalesce_timeout
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !defined(DISABLE_INTERRUPTS)
end_comment

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|U32
name|scic_controller_get_scratch_ram_size
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
return|return
name|SCU_SCRATCH_RAM_SIZE_IN_DWORDS
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_read_scratch_ram_dword
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U32
name|offset
parameter_list|,
name|U32
modifier|*
name|value
parameter_list|)
block|{
name|U32
name|zpt_index
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|scic_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|U32
name|status
init|=
name|SMU_SMUCSR_READ
argument_list|(
name|scic_controller
argument_list|)
decl_stmt|;
comment|//Check if the SCU Scratch RAM been initialized, if not return zeros
if|if
condition|(
operator|(
name|status
operator|&
name|SCU_RAM_INIT_COMPLETED
operator|)
operator|!=
name|SCU_RAM_INIT_COMPLETED
condition|)
block|{
operator|*
name|value
operator|=
literal|0x00000000
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
if|if
condition|(
name|offset
operator|<
name|scic_controller_get_scratch_ram_size
argument_list|(
name|controller
argument_list|)
condition|)
block|{
if|if
condition|(
name|offset
operator|<=
name|SCU_MAX_ZPT_DWORD_INDEX
condition|)
block|{
name|zpt_index
operator|=
name|offset
operator|+
operator|(
name|offset
operator|-
operator|(
name|offset
operator|%
literal|4
operator|)
operator|)
operator|+
literal|4
expr_stmt|;
operator|*
name|value
operator|=
name|scu_controller_scratch_ram_register_read
argument_list|(
name|scic_controller
argument_list|,
name|zpt_index
argument_list|)
expr_stmt|;
block|}
else|else
comment|//offset> SCU_MAX_ZPT_DWORD_INDEX
block|{
name|offset
operator|=
name|offset
operator|-
literal|132
expr_stmt|;
name|zpt_index
operator|=
name|offset
operator|+
operator|(
name|offset
operator|-
operator|(
name|offset
operator|%
literal|4
operator|)
operator|)
operator|+
literal|4
expr_stmt|;
operator|*
name|value
operator|=
name|scu_controller_scratch_ram_register_read_ext
argument_list|(
name|scic_controller
argument_list|,
name|zpt_index
argument_list|)
expr_stmt|;
block|}
return|return
name|SCI_SUCCESS
return|;
block|}
else|else
block|{
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_write_scratch_ram_dword
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U32
name|offset
parameter_list|,
name|U32
name|value
parameter_list|)
block|{
name|U32
name|zpt_index
decl_stmt|;
if|if
condition|(
name|offset
operator|<
name|scic_controller_get_scratch_ram_size
argument_list|(
name|controller
argument_list|)
condition|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|scic_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
if|if
condition|(
name|offset
operator|<=
name|SCU_MAX_ZPT_DWORD_INDEX
condition|)
block|{
name|zpt_index
operator|=
name|offset
operator|+
operator|(
name|offset
operator|-
operator|(
name|offset
operator|%
literal|4
operator|)
operator|)
operator|+
literal|4
expr_stmt|;
name|scu_controller_scratch_ram_register_write
argument_list|(
name|scic_controller
argument_list|,
name|zpt_index
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
comment|//offset> SCU_MAX_ZPT_DWORD_INDEX
block|{
name|offset
operator|=
name|offset
operator|-
literal|132
expr_stmt|;
name|zpt_index
operator|=
name|offset
operator|+
operator|(
name|offset
operator|-
operator|(
name|offset
operator|%
literal|4
operator|)
operator|)
operator|+
literal|4
expr_stmt|;
name|scu_controller_scratch_ram_register_write_ext
argument_list|(
name|scic_controller
argument_list|,
name|zpt_index
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|SCI_SUCCESS
return|;
block|}
else|else
block|{
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_suspend
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|U8
name|index
decl_stmt|;
comment|// As a precaution, disable interrupts.  The user is required
comment|// to re-enable interrupts if so desired after the call.
name|scic_controller_disable_interrupts
argument_list|(
name|controller
argument_list|)
expr_stmt|;
comment|// Stop all the timers
comment|// Maybe change the states of the objects to avoid processing stuff.
comment|// Suspend the Ports in order to ensure no unexpected
comment|// frame reception occurs on the links from the target
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PORTS
condition|;
name|index
operator|++
control|)
name|scic_sds_port_suspend_port_task_scheduler
argument_list|(
operator|&
operator|(
name|this_controller
operator|->
name|port_table
index|[
name|index
index|]
operator|)
argument_list|)
expr_stmt|;
comment|// Disable/Reset the completion queue and unsolicited frame
comment|// queue.
name|SMU_CQGR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|SCU_UFQGP_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
comment|// Clear any interrupts that may be pending or may have been generated
comment|// by setting CQGR and CQPR back to 0
name|SMU_ISR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|//reset the software get pointer to completion queue.
name|this_controller
operator|->
name|completion_queue_get
operator|=
literal|0
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_resume
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|U8
name|index
decl_stmt|;
comment|// Initialize the completion queue and unsolicited frame queue.
name|scic_sds_controller_initialize_completion_queue
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|scic_sds_controller_initialize_unsolicited_frame_queue
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|restrict_completions
operator|=
name|FALSE
expr_stmt|;
comment|// Release the port suspensions to allow for further successful
comment|// operation.
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PORTS
condition|;
name|index
operator|++
control|)
name|scic_sds_port_resume_port_task_scheduler
argument_list|(
operator|&
operator|(
name|this_controller
operator|->
name|port_table
index|[
name|index
index|]
operator|)
argument_list|)
expr_stmt|;
comment|//check the link layer status register DWORD sync acquired bit to detect
comment|//link down event. If there is any link down event happened during controller
comment|//suspension, restart phy state machine.
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PHYS
condition|;
name|index
operator|++
control|)
block|{
name|SCIC_SDS_PHY_T
modifier|*
name|curr_phy
init|=
operator|&
name|this_controller
operator|->
name|phy_table
index|[
name|index
index|]
decl_stmt|;
name|U32
name|link_layer_status
init|=
name|SCU_SAS_LLSTA_READ
argument_list|(
name|curr_phy
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|link_layer_status
operator|&
name|SCU_SAS_LLSTA_DWORD_SYNCA_BIT
operator|)
operator|==
literal|0
condition|)
block|{
comment|//Need to put the phy back to start OOB. Then an appropriate link event
comment|//message will be send to scic user.
name|scic_sds_phy_restart_starting_state
argument_list|(
name|curr_phy
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_transition
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|BOOL
name|restrict_completions
parameter_list|)
block|{
name|SCI_STATUS
name|result
init|=
name|SCI_FAILURE_INVALID_STATE
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|U8
name|index
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_controller_transition(0x%x) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_CONTROLLER_STATE_READY
condition|)
block|{
comment|// Ensure that there are no outstanding IO operations at this
comment|// time.
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PORTS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|this_controller
operator|->
name|port_table
index|[
name|index
index|]
operator|.
name|started_request_count
operator|!=
literal|0
condition|)
return|return
name|result
return|;
block|}
name|scic_controller_suspend
argument_list|(
name|controller
argument_list|)
expr_stmt|;
comment|// Loop through the memory descriptor list and reprogram
comment|// the silicon memory registers accordingly.
name|result
operator|=
name|scic_sds_controller_validate_memory_descriptor_table
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|scic_sds_controller_ram_initialization
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|restrict_completions
operator|=
name|restrict_completions
expr_stmt|;
block|}
name|scic_controller_resume
argument_list|(
name|controller
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_get_max_ports
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U8
modifier|*
name|count
parameter_list|)
block|{
operator|*
name|count
operator|=
name|SCI_MAX_PORTS
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scic_controller_get_max_phys
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U8
modifier|*
name|count
parameter_list|)
block|{
operator|*
name|count
operator|=
name|SCI_MAX_PHYS
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* CONTROLLER STATE MACHINE
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * This macro returns the maximum number of logical ports supported by the  * hardware. The caller passes in the value read from the device context  * capacity register and this macro will mash and shift the value  * appropriately.  */
end_comment

begin_define
define|#
directive|define
name|smu_dcc_get_max_ports
parameter_list|(
name|dcc_value
parameter_list|)
define|\
value|( \      (    ((U32)((dcc_value)& SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_MASK)) \>> SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_SHIFT ) + 1\    )
end_define

begin_comment
comment|/**  * This macro returns the maximum number of task contexts supported by the  * hardware. The caller passes in the value read from the device context  * capacity register and this macro will mash and shift the value  * appropriately.  */
end_comment

begin_define
define|#
directive|define
name|smu_dcc_get_max_task_context
parameter_list|(
name|dcc_value
parameter_list|)
define|\
value|( \      (   ((U32)((dcc_value)& SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_MASK)) \>> SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_SHIFT ) + 1\    )
end_define

begin_comment
comment|/**  * This macro returns the maximum number of remote node contexts supported  * by the hardware. The caller passes in the value read from the device  * context capacity register and this macro will mash and shift the value  * appropriately.  */
end_comment

begin_define
define|#
directive|define
name|smu_dcc_get_max_remote_node_context
parameter_list|(
name|dcc_value
parameter_list|)
define|\
value|( \      (  ( (U32)((dcc_value)& SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_MASK) )\>> SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_SHIFT ) + 1\    )
end_define

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|//* DEFAULT STATE HANDLERS
end_comment

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER default start  * io/task handler is in place.  *    - Issue a warning message  *  * @param[in] controller This is SCI_BASE_CONTROLLER object which is cast  *       into a SCIC_SDS_CONTROLLER object.  * @param[in] remote_device This is SCI_BASE_REMOTE_DEVICE which, if it was  *       used, would be cast to a SCIC_SDS_REMOTE_DEVICE.  * @param[in] io_request This is the SCI_BASE_REQUEST which, if it was used,  *       would be cast to a SCIC_SDS_IO_REQUEST.  * @param[in] io_tag This is the IO tag to be assigned to the IO request or  *       SCI_CONTROLLER_INVALID_IO_TAG.  *  * @return SCI_STATUS  * @retval SCI_FAILURE_INVALID_STATE  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_default_start_operation_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller requested to start an io/task from invalid state %d\n"
operator|,
name|sci_base_state_machine_get_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_INVALID_STATE
return|;
block|}
end_function

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER default  * request handler is in place.  *    - Issue a warning message  *  * @param[in] controller This is SCI_BASE_CONTROLLER object which is cast  *       into a SCIC_SDS_CONTROLLER object.  * @param[in] remote_device This is SCI_BASE_REMOTE_DEVICE which, if it was  *       used, would be cast to a SCIC_SDS_REMOTE_DEVICE.  * @param[in] io_request This is the SCI_BASE_REQUEST which, if it was used,  *       would be cast to a SCIC_SDS_IO_REQUEST.  *  * @return SCI_STATUS  * @retval SCI_FAILURE_INVALID_STATE  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_default_request_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller request operation from invalid state %d\n"
operator|,
name|sci_base_state_machine_get_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_INVALID_STATE
return|;
block|}
end_function

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|//* GENERAL (COMMON) STATE HANDLERS
end_comment

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in the ready state  * reset handler is in place.  *    - Transition to SCI_BASE_CONTROLLER_STATE_RESETTING  *  * @param[in] controller The SCI_BASE_CONTROLLER object which is cast into a  *       SCIC_SDS_CONTROLLER object.  *  * @return SCI_STATUS  * @retval SCI_SUCCESS  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_general_reset_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_sds_controller_resetting_state_enter(0x%x) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
comment|//Release resource. So far only resource to be released are timers.
name|scic_sds_controller_release_resource
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
comment|// The reset operation is not a graceful cleanup just perform the state
comment|// transition.
name|sci_base_state_machine_change_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_RESETTING
argument_list|)
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|//* RESET STATE HANDLERS
end_comment

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|/**  * This method is the SCIC_SDS_CONTROLLER initialize handler for the reset  * state.  *    - Currently this function does nothing  *  * @param[in] controller This is the SCI_BASE_CONTROLLER object which is cast  *       into a SCIC_SDS_CONTROLLER object.  *  * @return SCI_STATUS  * @retval SCI_FAILURE  *  * @todo This function is not yet implemented and is a valid request from the  *       reset state.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_reset_state_initialize_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|)
block|{
name|U32
name|index
decl_stmt|;
name|SCI_STATUS
name|result
init|=
name|SCI_SUCCESS
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_INITIALIZATION
operator|,
literal|"scic_sds_controller_reset_state_initialize_handler(0x%x) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_INITIALIZING
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|timeout_timer
operator|=
name|scic_cb_timer_create
argument_list|(
name|controller
argument_list|,
name|scic_sds_controller_timeout_handler
argument_list|,
name|controller
argument_list|)
expr_stmt|;
name|scic_sds_controller_initialize_power_control
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
comment|/// todo: This should really be done in the reset state enter but
comment|///       the controller has not yet been initialized before getting
comment|///       to the reset enter state so the PCI BAR is not yet assigned
name|scic_sds_controller_reset_hardware
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ARLINGTON_BUILD
argument_list|)
name|scic_sds_controller_lex_atux_initialization
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|PLEASANT_RIDGE_BUILD
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|PBG_HBA_A0_BUILD
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|PBG_HBA_A2_BUILD
argument_list|)
name|scic_sds_controller_afe_initialization
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|PBG_HBA_BETA_BUILD
argument_list|)
operator|||
name|defined
argument_list|(
name|PBG_BUILD
argument_list|)
comment|// There is nothing to do here for B0 since we do not have to
comment|// program the AFE registers.
comment|/// @todo The AFE settings are supposed to be correct for the B0 but
comment|///       presently they seem to be wrong.
name|scic_sds_controller_afe_initialization
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// !defined(ARLINGTON_BUILD)&& !defined(PLEASANT_RIDGE_BUILD)
comment|// What other systems do we want to add here?
endif|#
directive|endif
comment|// !defined(ARLINGTON_BUILD)&& !defined(PLEASANT_RIDGE_BUILD)
if|if
condition|(
name|SCI_SUCCESS
operator|==
name|result
condition|)
block|{
name|U32
name|status
decl_stmt|;
name|U32
name|terminate_loop
decl_stmt|;
comment|// Take the hardware out of reset
name|SMU_SMUSRCR_WRITE
argument_list|(
name|this_controller
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
comment|/// @todo Provide meaningfull error code for hardware failure
comment|//result = SCI_FAILURE_CONTROLLER_HARDWARE;
name|result
operator|=
name|SCI_FAILURE
expr_stmt|;
name|terminate_loop
operator|=
literal|100
expr_stmt|;
while|while
condition|(
name|terminate_loop
operator|--
operator|&&
operator|(
name|result
operator|!=
name|SCI_SUCCESS
operator|)
condition|)
block|{
comment|// Loop until the hardware reports success
name|scic_cb_stall_execution
argument_list|(
name|SCU_CONTEXT_RAM_INIT_STALL_TIME
argument_list|)
expr_stmt|;
name|status
operator|=
name|SMU_SMUCSR_READ
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|SCU_RAM_INIT_COMPLETED
operator|)
operator|==
name|SCU_RAM_INIT_COMPLETED
condition|)
block|{
name|result
operator|=
name|SCI_SUCCESS
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|ARLINGTON_BUILD
name|scic_sds_controller_enable_chipwatch
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|result
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|U32
name|max_supported_ports
decl_stmt|;
name|U32
name|max_supported_devices
decl_stmt|;
name|U32
name|max_supported_io_requests
decl_stmt|;
name|U32
name|device_context_capacity
decl_stmt|;
comment|// Determine what are the actaul device capacities that the
comment|// hardware will support
name|device_context_capacity
operator|=
name|SMU_DCC_READ
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|max_supported_ports
operator|=
name|smu_dcc_get_max_ports
argument_list|(
name|device_context_capacity
argument_list|)
expr_stmt|;
name|max_supported_devices
operator|=
name|smu_dcc_get_max_remote_node_context
argument_list|(
name|device_context_capacity
argument_list|)
expr_stmt|;
name|max_supported_io_requests
operator|=
name|smu_dcc_get_max_task_context
argument_list|(
name|device_context_capacity
argument_list|)
expr_stmt|;
comment|// Make all PEs that are unassigned match up with the logical ports
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|max_supported_ports
condition|;
name|index
operator|++
control|)
block|{
name|scu_register_write
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|scu_registers
operator|->
name|peg0
operator|.
name|ptsg
operator|.
name|protocol_engine
index|[
name|index
index|]
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|// Now that we have the correct hardware reported minimum values
comment|// build the MDL for the controller.  Default to a performance
comment|// configuration.
name|scic_controller_set_mode
argument_list|(
name|this_controller
argument_list|,
name|SCI_MODE_SPEED
argument_list|)
expr_stmt|;
comment|// Record the smaller of the two capacity values
name|this_controller
operator|->
name|logical_port_entries
operator|=
name|MIN
argument_list|(
name|max_supported_ports
argument_list|,
name|this_controller
operator|->
name|logical_port_entries
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|task_context_entries
operator|=
name|MIN
argument_list|(
name|max_supported_io_requests
argument_list|,
name|this_controller
operator|->
name|task_context_entries
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|remote_node_entries
operator|=
name|MIN
argument_list|(
name|max_supported_devices
argument_list|,
name|this_controller
operator|->
name|remote_node_entries
argument_list|)
expr_stmt|;
block|}
comment|// Initialize hardware PCI Relaxed ordering in DMA engines
if|if
condition|(
name|result
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|U32
name|dma_configuration
decl_stmt|;
comment|// Configure the payload DMA
name|dma_configuration
operator|=
name|SCU_PDMACR_READ
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|dma_configuration
operator||=
name|SCU_PDMACR_GEN_BIT
argument_list|(
name|PCI_RELAXED_ORDERING_ENABLE
argument_list|)
expr_stmt|;
name|SCU_PDMACR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|dma_configuration
argument_list|)
expr_stmt|;
comment|// Configure the control DMA
name|dma_configuration
operator|=
name|SCU_CDMACR_READ
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|dma_configuration
operator||=
name|SCU_CDMACR_GEN_BIT
argument_list|(
name|PCI_RELAXED_ORDERING_ENABLE
argument_list|)
expr_stmt|;
name|SCU_CDMACR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|dma_configuration
argument_list|)
expr_stmt|;
block|}
comment|// Initialize the PHYs before the PORTs because the PHY registers
comment|// are accessed during the port initialization.
if|if
condition|(
name|result
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// Initialize the phys
for|for
control|(
name|index
operator|=
literal|0
init|;
operator|(
name|result
operator|==
name|SCI_SUCCESS
operator|)
operator|&&
operator|(
name|index
operator|<
name|SCI_MAX_PHYS
operator|)
condition|;
name|index
operator|++
control|)
block|{
name|result
operator|=
name|scic_sds_phy_initialize
argument_list|(
operator|&
name|this_controller
operator|->
name|phy_table
index|[
name|index
index|]
argument_list|,
operator|&
name|this_controller
operator|->
name|scu_registers
operator|->
name|peg0
operator|.
name|pe
index|[
name|index
index|]
operator|.
name|tl
argument_list|,
operator|&
name|this_controller
operator|->
name|scu_registers
operator|->
name|peg0
operator|.
name|pe
index|[
name|index
index|]
operator|.
name|ll
argument_list|)
expr_stmt|;
block|}
block|}
comment|//Initialize the SGPIO Unit for HARDWARE controlled SGPIO
if|if
condition|(
name|result
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|scic_sgpio_hardware_initialize
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// Initialize the logical ports
for|for
control|(
name|index
operator|=
literal|0
init|;
operator|(
name|index
operator|<
name|this_controller
operator|->
name|logical_port_entries
operator|)
operator|&&
operator|(
name|result
operator|==
name|SCI_SUCCESS
operator|)
condition|;
name|index
operator|++
control|)
block|{
name|result
operator|=
name|scic_sds_port_initialize
argument_list|(
operator|&
name|this_controller
operator|->
name|port_table
index|[
name|index
index|]
argument_list|,
operator|&
name|this_controller
operator|->
name|scu_registers
operator|->
name|peg0
operator|.
name|ptsg
operator|.
name|port
index|[
name|index
index|]
argument_list|,
operator|&
name|this_controller
operator|->
name|scu_registers
operator|->
name|peg0
operator|.
name|ptsg
operator|.
name|protocol_engine
argument_list|,
operator|&
name|this_controller
operator|->
name|scu_registers
operator|->
name|peg0
operator|.
name|viit
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCI_SUCCESS
operator|==
name|result
condition|)
block|{
name|result
operator|=
name|scic_sds_port_configuration_agent_initialize
argument_list|(
name|this_controller
argument_list|,
operator|&
name|this_controller
operator|->
name|port_agent
argument_list|)
expr_stmt|;
block|}
comment|// Advance the controller state machine
if|if
condition|(
name|result
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|sci_base_state_machine_change_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_INITIALIZED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//stay in the same state and release the resource
name|scic_sds_controller_release_resource
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_INITIALIZATION
operator|,
literal|"Invalid Port Configuration from scic_sds_controller_reset_state_initialize_handler(0x%x) \n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|//* INITIALIZED STATE HANDLERS
end_comment

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|/**  * This method is the SCIC_SDS_CONTROLLER start handler for the initialized  * state.  *    - Validate we have a good memory descriptor table  *    - Initialze the physical memory before programming the hardware  *    - Program the SCU hardware with the physical memory addresses passed in  *      the memory descriptor table.  *    - Initialzie the TCi pool  *    - Initialize the RNi pool  *    - Initialize the completion queue  *    - Initialize the unsolicited frame data  *    - Take the SCU port task scheduler out of reset  *    - Start the first phy object.  *    - Transition to SCI_BASE_CONTROLLER_STATE_STARTING.  *  * @param[in] controller This is the SCI_BASE_CONTROLLER object which is cast  *       into a SCIC_SDS_CONTROLLER object.  * @param[in] timeout This is the allowed time for the controller object to  *       reach the started state.  *  * @return SCI_STATUS  * @retval SCI_SUCCESS if all of the controller start operations complete  * @retval SCI_FAILURE_UNSUPPORTED_INFORMATION_FIELD if one or more of the  *         memory descriptor fields is invalid.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_initialized_state_start_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|U32
name|timeout
parameter_list|)
block|{
name|U16
name|index
decl_stmt|;
name|SCI_STATUS
name|result
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
comment|// Make sure that the SCI User filled in the memory descriptor table correctly
name|result
operator|=
name|scic_sds_controller_validate_memory_descriptor_table
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// The memory descriptor list looks good so program the hardware
name|scic_sds_controller_ram_initialization
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCI_SUCCESS
operator|==
name|result
condition|)
block|{
comment|// Build the TCi free pool
name|sci_pool_initialize
argument_list|(
name|this_controller
operator|->
name|tci_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|this_controller
operator|->
name|task_context_entries
condition|;
name|index
operator|++
control|)
block|{
name|sci_pool_put
argument_list|(
name|this_controller
operator|->
name|tci_pool
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|// Build the RNi free pool
name|scic_sds_remote_node_table_initialize
argument_list|(
operator|&
name|this_controller
operator|->
name|available_remote_nodes
argument_list|,
name|this_controller
operator|->
name|remote_node_entries
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCI_SUCCESS
operator|==
name|result
condition|)
block|{
comment|// Before anything else lets make sure we will not be interrupted
comment|// by the hardware.
name|scic_controller_disable_interrupts
argument_list|(
name|controller
argument_list|)
expr_stmt|;
comment|// Enable the port task scheduler
name|scic_sds_controller_enable_port_task_scheduler
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
comment|// Assign all the task entries to this controller physical function
name|scic_sds_controller_assign_task_entries
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
comment|// Now initialze the completion queue
name|scic_sds_controller_initialize_completion_queue
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
comment|// Initialize the unsolicited frame queue for use
name|scic_sds_controller_initialize_unsolicited_frame_queue
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
comment|// Setup the phy start timer
name|result
operator|=
name|scic_sds_controller_initialize_phy_startup
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
block|}
comment|// Start all of the ports on this controller
for|for
control|(
name|index
operator|=
literal|0
init|;
operator|(
name|index
operator|<
name|this_controller
operator|->
name|logical_port_entries
operator|)
operator|&&
operator|(
name|result
operator|==
name|SCI_SUCCESS
operator|)
condition|;
name|index
operator|++
control|)
block|{
name|result
operator|=
name|this_controller
operator|->
name|port_table
index|[
name|index
index|]
operator|.
name|state_handlers
operator|->
name|parent
operator|.
name|start_handler
argument_list|(
operator|&
name|this_controller
operator|->
name|port_table
index|[
name|index
index|]
operator|.
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCI_SUCCESS
operator|==
name|result
condition|)
block|{
name|scic_sds_controller_start_next_phy
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
comment|// See if the user requested to timeout this operation.
if|if
condition|(
name|timeout
operator|!=
literal|0
condition|)
name|scic_cb_timer_start
argument_list|(
name|controller
argument_list|,
name|this_controller
operator|->
name|timeout_timer
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_STARTING
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|//* STARTING STATE HANDLERS
end_comment

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in the starting state  * link up handler is called.  This method will perform the following:  *    - Stop the phy timer  *    - Start the next phy  *    - Report the link up condition to the port object  *  * @param[in] controller This is SCIC_SDS_CONTROLLER which receives the link up  *       notification.  * @param[in] port This is SCIC_SDS_PORT with which the phy is associated.  * @param[in] phy This is the SCIC_SDS_PHY which has gone link up.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_starting_state_link_up_handler
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCIC_SDS_PORT_T
modifier|*
name|port
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|phy
parameter_list|)
block|{
name|scic_sds_controller_phy_timer_stop
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|port_agent
operator|.
name|link_up_handler
argument_list|(
name|this_controller
argument_list|,
operator|&
name|this_controller
operator|->
name|port_agent
argument_list|,
name|port
argument_list|,
name|phy
argument_list|)
expr_stmt|;
comment|//scic_sds_port_link_up(port, phy);
name|scic_sds_controller_start_next_phy
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in the starting state  * link down handler is called.  *    - Report the link down condition to the port object  *  * @param[in] controller This is SCIC_SDS_CONTROLLER which receives the  *       link down notification.  * @param[in] port This is SCIC_SDS_PORT with which the phy is associated.  * @param[in] phy This is the SCIC_SDS_PHY which has gone link down.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_starting_state_link_down_handler
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCIC_SDS_PORT_T
modifier|*
name|port
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|phy
parameter_list|)
block|{
name|this_controller
operator|->
name|port_agent
operator|.
name|link_down_handler
argument_list|(
name|this_controller
argument_list|,
operator|&
name|this_controller
operator|->
name|port_agent
argument_list|,
name|port
argument_list|,
name|phy
argument_list|)
expr_stmt|;
comment|//scic_sds_port_link_down(port, phy);
block|}
end_function

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|//* READY STATE HANDLERS
end_comment

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in the ready state  * stop handler is called.  *    - Start the timeout timer  *    - Transition to SCI_BASE_CONTROLLER_STATE_STOPPING.  *  * @param[in] controller The SCI_BASE_CONTROLLER object which is cast into a  *       SCIC_SDS_CONTROLLER object.  * @param[in] timeout The timeout for when the stop operation should report a  *       failure.  *  * @return SCI_STATUS  * @retval SCI_SUCCESS  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_ready_state_stop_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|U32
name|timeout
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
comment|// See if the user requested to timeout this operation
if|if
condition|(
name|timeout
operator|!=
literal|0
condition|)
name|scic_cb_timer_start
argument_list|(
name|controller
argument_list|,
name|this_controller
operator|->
name|timeout_timer
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_STOPPING
argument_list|)
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in the ready state  * and the start io handler is called.  *    - Start the io request on the remote device  *    - if successful  *       - assign the io_request to the io_request_table  *       - post the request to the hardware  *  * @param[in] controller This is SCI_BASE_CONTROLLER object which is cast  *       into a SCIC_SDS_CONTROLLER object.  * @param[in] remote_device This is SCI_BASE_REMOTE_DEVICE which is cast to a  *       SCIC_SDS_REMOTE_DEVICE object.  * @param[in] io_request This is the SCI_BASE_REQUEST which is cast to a  *       SCIC_SDS_IO_REQUEST object.  * @param[in] io_tag This is the IO tag to be assigned to the IO request or  *       SCI_CONTROLLER_INVALID_IO_TAG.  *  * @return SCI_STATUS  * @retval SCI_SUCCESS if the start io operation succeeds  * @retval SCI_FAILURE_INSUFFICIENT_RESOURCES if the IO tag could not be  *         allocated for the io request.  * @retval SCI_FAILURE_INVALID_STATE if one or more objects are not in a valid  *         state to accept io requests.  *  * @todo How does the io_tag parameter get assigned to the io request?  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_ready_state_start_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|SCIC_SDS_REQUEST_T
modifier|*
name|the_request
decl_stmt|;
name|SCIC_SDS_REMOTE_DEVICE_T
modifier|*
name|the_device
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|the_request
operator|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|io_request
expr_stmt|;
name|the_device
operator|=
operator|(
name|SCIC_SDS_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
expr_stmt|;
name|status
operator|=
name|scic_sds_remote_device_start_io
argument_list|(
name|this_controller
argument_list|,
name|the_device
argument_list|,
name|the_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|this_controller
operator|->
name|io_request_table
index|[
name|scic_sds_io_tag_get_index
argument_list|(
name|the_request
operator|->
name|io_tag
argument_list|)
index|]
operator|=
name|the_request
expr_stmt|;
name|scic_sds_controller_post_request
argument_list|(
name|this_controller
argument_list|,
name|scic_sds_request_get_post_context
argument_list|(
name|the_request
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in the ready state  * and the complete io handler is called.  *    - Complete the io request on the remote device  *    - if successful  *       - remove the io_request to the io_request_table  *  * @param[in] controller This is SCI_BASE_CONTROLLER object which is cast  *       into a SCIC_SDS_CONTROLLER object.  * @param[in] remote_device This is SCI_BASE_REMOTE_DEVICE which is cast to a  *       SCIC_SDS_REMOTE_DEVICE object.  * @param[in] io_request This is the SCI_BASE_REQUEST which is cast to a  *       SCIC_SDS_IO_REQUEST object.  *  * @return SCI_STATUS  * @retval SCI_SUCCESS if the start io operation succeeds  * @retval SCI_FAILURE_INVALID_STATE if one or more objects are not in a valid  *         state to accept io requests.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_ready_state_complete_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|)
block|{
name|U16
name|index
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|SCIC_SDS_REQUEST_T
modifier|*
name|the_request
decl_stmt|;
name|SCIC_SDS_REMOTE_DEVICE_T
modifier|*
name|the_device
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|the_request
operator|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|io_request
expr_stmt|;
name|the_device
operator|=
operator|(
name|SCIC_SDS_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
expr_stmt|;
name|status
operator|=
name|scic_sds_remote_device_complete_io
argument_list|(
name|this_controller
argument_list|,
name|the_device
argument_list|,
name|the_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|index
operator|=
name|scic_sds_io_tag_get_index
argument_list|(
name|the_request
operator|->
name|io_tag
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|io_request_table
index|[
name|index
index|]
operator|=
name|SCI_INVALID_HANDLE
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in the ready state  * and the continue io handler is called.  *  * @param[in] controller This is SCI_BASE_CONTROLLER object which is cast  *       into a SCIC_SDS_CONTROLLER object.  * @param[in] remote_device This is SCI_BASE_REMOTE_DEVICE which is cast to a  *       SCIC_SDS_REMOTE_DEVICE object.  * @param[in] io_request This is the SCI_BASE_REQUEST which is cast to a  *       SCIC_SDS_IO_REQUEST object.  *  * @return SCI_STATUS  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_ready_state_continue_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|SCIC_SDS_REQUEST_T
modifier|*
name|the_request
decl_stmt|;
name|the_request
operator|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|io_request
expr_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|this_controller
operator|->
name|io_request_table
index|[
name|scic_sds_io_tag_get_index
argument_list|(
name|the_request
operator|->
name|io_tag
argument_list|)
index|]
operator|=
name|the_request
expr_stmt|;
name|scic_sds_controller_post_request
argument_list|(
name|this_controller
argument_list|,
name|scic_sds_request_get_post_context
argument_list|(
name|the_request
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in the ready state  * and the start task handler is called.  *    - The remote device is requested to start the task request  *    - if successful  *       - assign the task to the io_request_table  *       - post the request to the SCU hardware  *  * @param[in] controller This is SCI_BASE_CONTROLLER object which is cast  *       into a SCIC_SDS_CONTROLLER object.  * @param[in] remote_device This is SCI_BASE_REMOTE_DEVICE which is cast to a  *       SCIC_SDS_REMOTE_DEVICE object.  * @param[in] io_request This is the SCI_BASE_REQUEST which is cast to a  *       SCIC_SDS_IO_REQUEST object.  * @param[in] task_tag This is the task tag to be assigned to the task request  *       or SCI_CONTROLLER_INVALID_IO_TAG.  *  * @return SCI_STATUS  * @retval SCI_SUCCESS if the start io operation succeeds  * @retval SCI_FAILURE_INSUFFICIENT_RESOURCES if the IO tag could not be  *         allocated for the io request.  * @retval SCI_FAILURE_INVALID_STATE if one or more objects are not in a valid  *         state to accept io requests.  *  * @todo How does the io tag get assigned in this code path?  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_ready_state_start_task_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|,
name|U16
name|task_tag
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCIC_SDS_REQUEST_T
modifier|*
name|the_request
init|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|io_request
decl_stmt|;
name|SCIC_SDS_REMOTE_DEVICE_T
modifier|*
name|the_device
init|=
operator|(
name|SCIC_SDS_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|status
operator|=
name|scic_sds_remote_device_start_task
argument_list|(
name|this_controller
argument_list|,
name|the_device
argument_list|,
name|the_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|this_controller
operator|->
name|io_request_table
index|[
name|scic_sds_io_tag_get_index
argument_list|(
name|the_request
operator|->
name|io_tag
argument_list|)
index|]
operator|=
name|the_request
expr_stmt|;
name|scic_sds_controller_post_request
argument_list|(
name|this_controller
argument_list|,
name|scic_sds_request_get_post_context
argument_list|(
name|the_request
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS
condition|)
block|{
name|this_controller
operator|->
name|io_request_table
index|[
name|scic_sds_io_tag_get_index
argument_list|(
name|the_request
operator|->
name|io_tag
argument_list|)
index|]
operator|=
name|the_request
expr_stmt|;
comment|//We will let framework know this task request started successfully,
comment|//although core is still woring on starting the request (to post tc when
comment|//RNC is resumed.)
name|status
operator|=
name|SCI_SUCCESS
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in the ready state  * and the terminate request handler is called.  *    - call the io request terminate function  *    - if successful  *       - post the terminate request to the SCU hardware  *  * @param[in] controller This is SCI_BASE_CONTROLLER object which is cast  *       into a SCIC_SDS_CONTROLLER object.  * @param[in] remote_device This is SCI_BASE_REMOTE_DEVICE which is cast to a  *       SCIC_SDS_REMOTE_DEVICE object.  * @param[in] io_request This is the SCI_BASE_REQUEST which is cast to a  *       SCIC_SDS_IO_REQUEST object.  *  * @return SCI_STATUS  * @retval SCI_SUCCESS if the start io operation succeeds  * @retval SCI_FAILURE_INVALID_STATE if one or more objects are not in a valid  *         state to accept io requests.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_ready_state_terminate_request_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCIC_SDS_REQUEST_T
modifier|*
name|the_request
init|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|io_request
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|status
operator|=
name|scic_sds_io_request_terminate
argument_list|(
name|the_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// Utilize the original post context command and or in the POST_TC_ABORT
comment|// request sub-type.
name|scic_sds_controller_post_request
argument_list|(
name|this_controller
argument_list|,
name|scic_sds_request_get_post_context
argument_list|(
name|the_request
argument_list|)
operator||
name|SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in the starting state  * link up handler is called.  This method will perform the following:  *    - Stop the phy timer  *    - Start the next phy  *    - Report the link up condition to the port object  *  * @param[in] controller This is SCIC_SDS_CONTROLLER which receives the link up  *       notification.  * @param[in] port This is SCIC_SDS_PORT with which the phy is associated.  * @param[in] phy This is the SCIC_SDS_PHY which has gone link up.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_ready_state_link_up_handler
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCIC_SDS_PORT_T
modifier|*
name|port
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|phy
parameter_list|)
block|{
name|this_controller
operator|->
name|port_agent
operator|.
name|link_up_handler
argument_list|(
name|this_controller
argument_list|,
operator|&
name|this_controller
operator|->
name|port_agent
argument_list|,
name|port
argument_list|,
name|phy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in the starting state  * link down handler is called.  *    - Report the link down condition to the port object  *  * @param[in] controller This is SCIC_SDS_CONTROLLER which receives the  *       link down notification.  * @param[in] port This is SCIC_SDS_PORT with which the phy is associated.  * @param[in] phy This is the SCIC_SDS_PHY which has gone link down.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_ready_state_link_down_handler
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCIC_SDS_PORT_T
modifier|*
name|port
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|phy
parameter_list|)
block|{
name|this_controller
operator|->
name|port_agent
operator|.
name|link_down_handler
argument_list|(
name|this_controller
argument_list|,
operator|&
name|this_controller
operator|->
name|port_agent
argument_list|,
name|port
argument_list|,
name|phy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|//* STOPPING STATE HANDLERS
end_comment

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in a stopping state  * and the complete io handler is called.  *    - This function is not yet implemented  *  * @param[in] controller This is SCI_BASE_CONTROLLER object which is cast  *       into a SCIC_SDS_CONTROLLER object.  * @param[in] remote_device This is SCI_BASE_REMOTE_DEVICE which is cast to a  *       SCIC_SDS_REMOTE_DEVICE object.  * @param[in] io_request This is the SCI_BASE_REQUEST which is cast to a  *       SCIC_SDS_IO_REQUEST object.  *  * @return SCI_STATUS  * @retval SCI_FAILURE  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_stopping_state_complete_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
comment|/// @todo Implement this function
return|return
name|SCI_FAILURE
return|;
block|}
end_function

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in a stopping state  * and the a remote device has stopped.  *  * @param[in] controller This is SCI_BASE_CONTROLLER object which is cast  *       into a SCIC_SDS_CONTROLLER object.  * @param[in] remote_device This is SCI_BASE_REMOTE_DEVICE which is cast to a  *       SCIC_SDS_REMOTE_DEVICE object.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_stopping_state_device_stopped_handler
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|)
block|{
if|if
condition|(
operator|!
name|scic_sds_controller_has_remote_devices_stopping
argument_list|(
name|controller
argument_list|)
condition|)
block|{
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_STOPPED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|//* STOPPED STATE HANDLERS
end_comment

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|//* FAILED STATE HANDLERS
end_comment

begin_comment
comment|//*****************************************************************************
end_comment

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER failed state start  * io/task handler is in place.  *    - Issue a warning message  *  * @param[in] controller This is SCI_BASE_CONTROLLER object which is cast  *       into a SCIC_SDS_CONTROLLER object.  * @param[in] remote_device This is SCI_BASE_REMOTE_DEVICE which, if it was  *       used, would be cast to a SCIC_SDS_REMOTE_DEVICE.  * @param[in] io_request This is the SCI_BASE_REQUEST which, if it was used,  *       would be cast to a SCIC_SDS_IO_REQUEST.  * @param[in] io_tag This is the IO tag to be assigned to the IO request or  *       SCI_CONTROLLER_INVALID_IO_TAG.  *  * @return SCI_FAILURE  * @retval SCI_FAILURE  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_failed_state_start_operation_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
name|SCIC_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"SCIC Controller requested to start an io/task from failed state %d\n"
operator|,
name|sci_base_state_machine_get_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE
return|;
block|}
end_function

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in the failed state  * reset handler is in place.  *    - Transition to SCI_BASE_CONTROLLER_STATE_RESETTING  *  * @param[in] controller The SCI_BASE_CONTROLLER object which is cast into a  *       SCIC_SDS_CONTROLLER object.  *  * @return SCI_STATUS  * @retval SCI_FAILURE if fatal memory error occurred  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_failed_state_reset_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|controller
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|parent
operator|.
name|error
operator|==
name|SCI_CONTROLLER_FATAL_MEMORY_ERROR
condition|)
block|{
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_sds_controller_resetting_state_enter(0x%x) enter\n not allowed with fatal memory error"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE
return|;
block|}
else|else
block|{
return|return
name|scic_sds_controller_general_reset_handler
argument_list|(
name|controller
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * This method is called when the SCIC_SDS_CONTROLLER is in the failed state  * and the terminate request handler is called.  *    - call the io request terminate function  *    - if successful  *       - post the terminate request to the SCU hardware  *  * @param[in] controller This is SCI_BASE_CONTROLLER object which is cast  *       into a SCIC_SDS_CONTROLLER object.  * @param[in] remote_device This is SCI_BASE_REMOTE_DEVICE which is cast to a  *       SCIC_SDS_REMOTE_DEVICE object.  * @param[in] io_request This is the SCI_BASE_REQUEST which is cast to a  *       SCIC_SDS_IO_REQUEST object.  *  * @return SCI_STATUS  * @retval SCI_SUCCESS if the start io operation succeeds  * @retval SCI_FAILURE_INVALID_STATE if one or more objects are not in a valid  *         state to accept io requests.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_controller_failed_state_terminate_request_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|)
block|{
name|SCIC_SDS_REQUEST_T
modifier|*
name|the_request
init|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|io_request
decl_stmt|;
return|return
name|scic_sds_io_request_terminate
argument_list|(
name|the_request
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|SCIC_SDS_CONTROLLER_STATE_HANDLER_T
name|scic_sds_controller_state_handler_table
index|[
name|SCI_BASE_CONTROLLER_MAX_STATES
index|]
init|=
block|{
comment|// SCI_BASE_CONTROLLER_STATE_INITIAL
block|{
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|}
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_RESET
block|{
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|scic_sds_controller_reset_state_initialize_handler
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|}
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_INITIALIZING
block|{
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|}
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_INITIALIZED
block|{
block|{
name|scic_sds_controller_initialized_state_start_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|}
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_STARTING
block|{
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|}
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_starting_state_link_up_handler
block|,
name|scic_sds_controller_starting_state_link_down_handler
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_READY
block|{
block|{
name|NULL
block|,
name|scic_sds_controller_ready_state_stop_handler
block|,
name|scic_sds_controller_general_reset_handler
block|,
name|NULL
block|,
name|scic_sds_controller_ready_state_start_io_handler
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_ready_state_complete_io_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_ready_state_continue_io_handler
block|,
name|scic_sds_controller_ready_state_start_task_handler
block|,
name|scic_sds_controller_ready_state_complete_io_handler
block|}
block|,
name|scic_sds_controller_ready_state_terminate_request_handler
block|,
name|scic_sds_controller_ready_state_link_up_handler
block|,
name|scic_sds_controller_ready_state_link_down_handler
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_RESETTING
block|{
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|}
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_STOPPING
block|{
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_stopping_state_complete_io_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|}
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|scic_sds_controller_stopping_state_device_stopped_handler
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_STOPPED
block|{
block|{
name|NULL
block|,
name|NULL
block|,
name|scic_sds_controller_failed_state_reset_handler
block|,
name|NULL
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_start_operation_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|}
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_FAILED
block|{
block|{
name|NULL
block|,
name|NULL
block|,
name|scic_sds_controller_general_reset_handler
block|,
name|NULL
block|,
name|scic_sds_controller_failed_state_start_operation_handler
block|,
name|scic_sds_controller_failed_state_start_operation_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|scic_sds_controller_default_request_handler
block|,
name|NULL
block|,
name|NULL
block|}
block|,
name|scic_sds_controller_failed_state_terminate_request_handler
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * This method implements the actions taken by the SCIC_SDS_CONTROLLER on  * entry to the SCI_BASE_CONTROLLER_STATE_INITIAL.  *    - Set the state handlers to the controllers initial state.  *  * @param[in] object This is the SCI_BASE_OBJECT which is cast to a  *       SCIC_SDS_CONTROLLER object.  *  * @return none  *  * @todo This function should initialze the controller object.  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_initial_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
expr_stmt|;
name|scic_sds_controller_set_base_state_handlers
argument_list|(
name|this_controller
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_INITIAL
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method implements the actions taken by the SCIC_SDS_CONTROLLER on  * entry to the SCI_BASE_CONTROLLER_STATE_RESET.  *    - Set the state handlers to the controllers reset state.  *  * @param[in] object This is the SCI_BASE_OBJECT which is cast to a  *       SCIC_SDS_CONTROLLER object.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_reset_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|U8
name|index
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
expr_stmt|;
name|scic_sds_controller_set_base_state_handlers
argument_list|(
name|this_controller
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_RESET
argument_list|)
expr_stmt|;
name|scic_sds_port_configuration_agent_construct
argument_list|(
operator|&
name|this_controller
operator|->
name|port_agent
argument_list|)
expr_stmt|;
comment|// Construct the ports for this controller
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
operator|(
name|SCI_MAX_PORTS
operator|+
literal|1
operator|)
condition|;
name|index
operator|++
control|)
block|{
name|scic_sds_port_construct
argument_list|(
operator|&
name|this_controller
operator|->
name|port_table
index|[
name|index
index|]
argument_list|,
operator|(
name|index
operator|==
name|SCI_MAX_PORTS
operator|)
condition|?
name|SCIC_SDS_DUMMY_PORT
else|:
name|index
argument_list|,
name|this_controller
argument_list|)
expr_stmt|;
block|}
comment|// Construct the phys for this controller
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PHYS
condition|;
name|index
operator|++
control|)
block|{
comment|// Add all the PHYs to the dummy port
name|scic_sds_phy_construct
argument_list|(
operator|&
name|this_controller
operator|->
name|phy_table
index|[
name|index
index|]
argument_list|,
operator|&
name|this_controller
operator|->
name|port_table
index|[
name|SCI_MAX_PORTS
index|]
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|this_controller
operator|->
name|invalid_phy_mask
operator|=
literal|0
expr_stmt|;
comment|// Set the default maximum values
name|this_controller
operator|->
name|completion_event_entries
operator|=
name|SCU_EVENT_COUNT
expr_stmt|;
name|this_controller
operator|->
name|completion_queue_entries
operator|=
name|SCU_COMPLETION_QUEUE_COUNT
expr_stmt|;
name|this_controller
operator|->
name|remote_node_entries
operator|=
name|SCI_MAX_REMOTE_DEVICES
expr_stmt|;
name|this_controller
operator|->
name|logical_port_entries
operator|=
name|SCI_MAX_PORTS
expr_stmt|;
name|this_controller
operator|->
name|task_context_entries
operator|=
name|SCU_IO_REQUEST_COUNT
expr_stmt|;
name|this_controller
operator|->
name|uf_control
operator|.
name|buffers
operator|.
name|count
operator|=
name|SCU_UNSOLICITED_FRAME_COUNT
expr_stmt|;
name|this_controller
operator|->
name|uf_control
operator|.
name|address_table
operator|.
name|count
operator|=
name|SCU_UNSOLICITED_FRAME_COUNT
expr_stmt|;
comment|// Initialize the User and OEM parameters to default values.
name|scic_sds_controller_set_default_config_parameters
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method implements the actions taken by the SCIC_SDS_CONTROLLER on  * entry to the SCI_BASE_CONTROLLER_STATE_INITIALIZING.  *    - Set the state handlers to the controllers initializing state.  *  * @param[in] object This is the SCI_BASE_OBJECT which is cast to a  *       SCIC_SDS_CONTROLLER object.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_initializing_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
expr_stmt|;
name|scic_sds_controller_set_base_state_handlers
argument_list|(
name|this_controller
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_INITIALIZING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method implements the actions taken by the SCIC_SDS_CONTROLLER on  * entry to the SCI_BASE_CONTROLLER_STATE_INITIALIZED.  *    - Set the state handlers to the controllers initialized state.  *  * @param[in] object This is the SCI_BASE_OBJECT which is cast to a  *       SCIC_SDS_CONTROLLER object.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_initialized_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
expr_stmt|;
name|scic_sds_controller_set_base_state_handlers
argument_list|(
name|this_controller
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_INITIALIZED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method implements the actions taken by the SCIC_SDS_CONTROLLER on  * entry to the SCI_BASE_CONTROLLER_STATE_STARTING.  *    - Set the state handlers to the controllers starting state.  *  * @param[in] object This is the SCI_BASE_OBJECT which is cast to a  *       SCIC_SDS_CONTROLLER object.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_starting_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
expr_stmt|;
name|scic_sds_controller_set_base_state_handlers
argument_list|(
name|this_controller
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_STARTING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method implements the actions taken by the SCIC_SDS_CONTROLLER on exit  * from the SCI_BASE_CONTROLLER_STATE_STARTING.  *    - This function stops the controller starting timeout timer.  *  * @param[in] object This is the SCI_BASE_OBJECT which is cast to a  *       SCIC_SDS_CONTROLLER object.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_starting_state_exit
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
expr_stmt|;
name|scic_cb_timer_stop
argument_list|(
name|object
argument_list|,
name|this_controller
operator|->
name|timeout_timer
argument_list|)
expr_stmt|;
comment|// We are done with this timer since we are exiting the starting
comment|// state so remove it
name|scic_cb_timer_destroy
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|phy_startup_timer
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|phy_startup_timer
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method implements the actions taken by the SCIC_SDS_CONTROLLER on  * entry to the SCI_BASE_CONTROLLER_STATE_READY.  *    - Set the state handlers to the controllers ready state.  *  * @param[in] object This is the SCI_BASE_OBJECT which is cast to a  *       SCIC_SDS_CONTROLLER object.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_ready_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|U32
name|clock_gating_unit_value
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
expr_stmt|;
name|scic_sds_controller_set_base_state_handlers
argument_list|(
name|this_controller
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_READY
argument_list|)
expr_stmt|;
comment|/**     * enable clock gating for power control of the scu unit     */
name|clock_gating_unit_value
operator|=
name|SMU_CGUCR_READ
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|clock_gating_unit_value
operator|&=
operator|~
operator|(
name|SMU_CGUCR_GEN_BIT
argument_list|(
name|REGCLK_ENABLE
argument_list|)
operator||
name|SMU_CGUCR_GEN_BIT
argument_list|(
name|TXCLK_ENABLE
argument_list|)
operator||
name|SMU_CGUCR_GEN_BIT
argument_list|(
name|XCLK_ENABLE
argument_list|)
operator|)
expr_stmt|;
name|clock_gating_unit_value
operator||=
name|SMU_CGUCR_GEN_BIT
argument_list|(
name|IDLE_ENABLE
argument_list|)
expr_stmt|;
name|SMU_CGUCR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|clock_gating_unit_value
argument_list|)
expr_stmt|;
comment|//set the default interrupt coalescence number and timeout value.
name|scic_controller_set_interrupt_coalescence
argument_list|(
name|this_controller
argument_list|,
literal|0x10
argument_list|,
literal|250
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method implements the actions taken by the SCIC_SDS_CONTROLLER on exit  * from the SCI_BASE_CONTROLLER_STATE_READY.  *    - This function does nothing.  *  * @param[in] object This is the SCI_BASE_OBJECT which is cast to a  *       SCIC_SDS_CONTROLLER object.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_ready_state_exit
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|U32
name|clock_gating_unit_value
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
expr_stmt|;
comment|/**     * restore clock gating for power control of the scu unit     */
name|clock_gating_unit_value
operator|=
name|SMU_CGUCR_READ
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|clock_gating_unit_value
operator|&=
operator|~
name|SMU_CGUCR_GEN_BIT
argument_list|(
name|IDLE_ENABLE
argument_list|)
expr_stmt|;
name|clock_gating_unit_value
operator||=
operator|(
name|SMU_CGUCR_GEN_BIT
argument_list|(
name|REGCLK_ENABLE
argument_list|)
operator||
name|SMU_CGUCR_GEN_BIT
argument_list|(
name|TXCLK_ENABLE
argument_list|)
operator||
name|SMU_CGUCR_GEN_BIT
argument_list|(
name|XCLK_ENABLE
argument_list|)
operator|)
expr_stmt|;
name|SMU_CGUCR_WRITE
argument_list|(
name|this_controller
argument_list|,
name|clock_gating_unit_value
argument_list|)
expr_stmt|;
comment|//disable interrupt coalescence.
name|scic_controller_set_interrupt_coalescence
argument_list|(
name|this_controller
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method implements the actions taken by the SCIC_SDS_CONTROLLER on  * entry to the SCI_BASE_CONTROLLER_STATE_READY.  *    - Set the state handlers to the controllers ready state.  *    - Stop all of the remote devices on this controller  *    - Stop the ports on this controller  *    - Stop the phys on this controller  *  * @param[in] object This is the SCI_BASE_OBJECT which is cast to a  *       SCIC_SDS_CONTROLLER object.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_stopping_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
expr_stmt|;
name|scic_sds_controller_set_base_state_handlers
argument_list|(
name|this_controller
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_STOPPING
argument_list|)
expr_stmt|;
comment|// Stop all of the components for this controller in the reverse order
comment|// from which they are initialized.
name|scic_sds_controller_stop_devices
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|scic_sds_controller_stop_ports
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scic_sds_controller_has_remote_devices_stopping
argument_list|(
name|this_controller
argument_list|)
condition|)
block|{
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_STOPPED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * This method implements the actions taken by the SCIC_SDS_CONTROLLER on exit  * from the SCI_BASE_CONTROLLER_STATE_STOPPING.  *    - This function stops the controller stopping timeout timer.  *  * @param[in] object This is the SCI_BASE_OBJECT which is cast to a  *       SCIC_SDS_CONTROLLER object.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_stopping_state_exit
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
expr_stmt|;
name|scic_cb_timer_stop
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|timeout_timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method implements the actions taken by the SCIC_SDS_CONTROLLER on  * entry to the SCI_BASE_CONTROLLER_STATE_STOPPED.  *    - Set the state handlers to the controllers stopped state.  *  * @param[in] object This is the SCI_BASE_OBJECT which is cast to a  *       SCIC_SDS_CONTROLLER object.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_stopped_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
expr_stmt|;
name|scic_sds_controller_set_base_state_handlers
argument_list|(
name|this_controller
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_STOPPED
argument_list|)
expr_stmt|;
comment|// We are done with this timer until the next timer we initialize
name|scic_cb_timer_destroy
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|timeout_timer
argument_list|)
expr_stmt|;
name|this_controller
operator|->
name|timeout_timer
operator|=
name|NULL
expr_stmt|;
comment|// Controller has stopped so disable all the phys on this controller
name|scic_sds_controller_stop_phys
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|scic_sds_port_configuration_agent_destroy
argument_list|(
name|this_controller
argument_list|,
operator|&
name|this_controller
operator|->
name|port_agent
argument_list|)
expr_stmt|;
name|scic_cb_controller_stop_complete
argument_list|(
name|this_controller
argument_list|,
name|SCI_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method implements the actions taken by the SCIC_SDS_CONTROLLER on  * entry to the SCI_BASE_CONTROLLER_STATE_RESETTING.  *    - Set the state handlers to the controllers resetting state.  *    - Write to the SCU hardware reset register to force a reset  *    - Transition to the SCI_BASE_CONTROLLER_STATE_RESET  *  * @param[in] object This is the SCI_BASE_OBJECT which is cast to a  *       SCIC_SDS_CONTROLLER object.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_resetting_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"scic_sds_controller_resetting_state_enter(0x%x) enter\n"
operator|,
name|this_controller
operator|)
argument_list|)
expr_stmt|;
name|scic_sds_controller_set_base_state_handlers
argument_list|(
name|this_controller
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_RESETTING
argument_list|)
expr_stmt|;
name|scic_sds_controller_reset_hardware
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
name|scic_sds_controller_get_base_state_machine
argument_list|(
name|this_controller
argument_list|)
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_abort_reqests
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCIC_SDS_PORT_T
modifier|*
name|port
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|SCI_STATUS
name|terminate_status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|SCIC_SDS_REQUEST_T
modifier|*
name|the_request
decl_stmt|;
name|U32
name|index
decl_stmt|;
name|U32
name|request_count
decl_stmt|;
if|if
condition|(
name|remote_device
operator|!=
name|NULL
condition|)
name|request_count
operator|=
name|remote_device
operator|->
name|started_request_count
expr_stmt|;
elseif|else
if|if
condition|(
name|port
operator|!=
name|NULL
condition|)
name|request_count
operator|=
name|port
operator|->
name|started_request_count
expr_stmt|;
else|else
name|request_count
operator|=
name|SCI_MAX_IO_REQUESTS
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
operator|(
name|index
operator|<
name|SCI_MAX_IO_REQUESTS
operator|)
operator|&&
operator|(
name|request_count
operator|>
literal|0
operator|)
condition|;
name|index
operator|++
control|)
block|{
name|the_request
operator|=
name|controller
operator|->
name|io_request_table
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|the_request
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|the_request
operator|->
name|target_device
operator|==
name|remote_device
operator|||
name|the_request
operator|->
name|target_device
operator|->
name|owning_port
operator|==
name|port
operator|||
operator|(
name|remote_device
operator|==
name|NULL
operator|&&
name|port
operator|==
name|NULL
operator|)
condition|)
block|{
name|terminate_status
operator|=
name|scic_controller_terminate_request
argument_list|(
name|controller
argument_list|,
name|the_request
operator|->
name|target_device
argument_list|,
name|the_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminate_status
operator|!=
name|SCI_SUCCESS
condition|)
name|status
operator|=
name|terminate_status
expr_stmt|;
name|request_count
operator|--
expr_stmt|;
block|}
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
name|SCI_STATUS
name|scic_sds_terminate_reqests
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|,
name|SCIC_SDS_REMOTE_DEVICE_T
modifier|*
name|this_remote_device
parameter_list|,
name|SCIC_SDS_PORT_T
modifier|*
name|this_port
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|SCI_STATUS
name|abort_status
init|=
name|SCI_SUCCESS
decl_stmt|;
comment|// move all request to abort state
name|abort_status
operator|=
name|scic_sds_abort_reqests
argument_list|(
name|this_controller
argument_list|,
name|this_remote_device
argument_list|,
name|this_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_status
operator|!=
name|SCI_SUCCESS
condition|)
name|status
operator|=
name|abort_status
expr_stmt|;
comment|//move all request to complete state
if|if
condition|(
name|this_controller
operator|->
name|parent
operator|.
name|error
operator|==
name|SCI_CONTROLLER_FATAL_MEMORY_ERROR
condition|)
name|abort_status
operator|=
name|scic_sds_abort_reqests
argument_list|(
name|this_controller
argument_list|,
name|this_remote_device
argument_list|,
name|this_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_status
operator|!=
name|SCI_SUCCESS
condition|)
name|status
operator|=
name|abort_status
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_terminate_all_requests
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|)
block|{
return|return
name|scic_sds_terminate_reqests
argument_list|(
name|controller
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * This method implements the actions taken by the SCIC_SDS_CONTROLLER on  * entry to the SCI_BASE_CONTROLLER_STATE_FAILED.  *    - Set the state handlers to the controllers failed state.  *  * @param[in] object This is the SCI_BASE_OBJECT which is cast to a  *       SCIC_SDS_CONTROLLER object.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_controller_failed_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|this_controller
decl_stmt|;
name|this_controller
operator|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
expr_stmt|;
name|scic_sds_controller_set_base_state_handlers
argument_list|(
name|this_controller
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_FAILED
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_controller
operator|->
name|parent
operator|.
name|error
operator|==
name|SCI_CONTROLLER_FATAL_MEMORY_ERROR
condition|)
name|scic_sds_terminate_all_requests
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
else|else
name|scic_sds_controller_release_resource
argument_list|(
name|this_controller
argument_list|)
expr_stmt|;
comment|//notify framework the controller failed.
name|scic_cb_controller_error
argument_list|(
name|this_controller
argument_list|,
name|this_controller
operator|->
name|parent
operator|.
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_decl_stmt
name|SCI_BASE_STATE_T
name|scic_sds_controller_state_table
index|[
name|SCI_BASE_CONTROLLER_MAX_STATES
index|]
init|=
block|{
block|{
name|SCI_BASE_CONTROLLER_STATE_INITIAL
block|,
name|scic_sds_controller_initial_state_enter
block|,
name|NULL
block|,    }
block|,
block|{
name|SCI_BASE_CONTROLLER_STATE_RESET
block|,
name|scic_sds_controller_reset_state_enter
block|,
name|NULL
block|,    }
block|,
block|{
name|SCI_BASE_CONTROLLER_STATE_INITIALIZING
block|,
name|scic_sds_controller_initializing_state_enter
block|,
name|NULL
block|,    }
block|,
block|{
name|SCI_BASE_CONTROLLER_STATE_INITIALIZED
block|,
name|scic_sds_controller_initialized_state_enter
block|,
name|NULL
block|,    }
block|,
block|{
name|SCI_BASE_CONTROLLER_STATE_STARTING
block|,
name|scic_sds_controller_starting_state_enter
block|,
name|scic_sds_controller_starting_state_exit
block|,    }
block|,
block|{
name|SCI_BASE_CONTROLLER_STATE_READY
block|,
name|scic_sds_controller_ready_state_enter
block|,
name|scic_sds_controller_ready_state_exit
block|,    }
block|,
block|{
name|SCI_BASE_CONTROLLER_STATE_RESETTING
block|,
name|scic_sds_controller_resetting_state_enter
block|,
name|NULL
block|,    }
block|,
block|{
name|SCI_BASE_CONTROLLER_STATE_STOPPING
block|,
name|scic_sds_controller_stopping_state_enter
block|,
name|scic_sds_controller_stopping_state_exit
block|,    }
block|,
block|{
name|SCI_BASE_CONTROLLER_STATE_STOPPED
block|,
name|scic_sds_controller_stopped_state_enter
block|,
name|NULL
block|,    }
block|,
block|{
name|SCI_BASE_CONTROLLER_STATE_FAILED
block|,
name|scic_sds_controller_failed_state_enter
block|,
name|NULL
block|,    }
block|}
decl_stmt|;
end_decl_stmt

end_unit

