begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_ATAPI
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_stp_packet_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_logger.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_sas.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_ata.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_sata.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_user_callback.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/sci_environment.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_sat.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scu_completion_codes.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scu_task_context.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_stp_packet_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_base_state.h>
end_include

begin_comment
comment|/**  * @brief This method will fill in the SCU Task Context for a PACKET fis. And  *           construct the request STARTED sub-state machine for Packet Protocol  *           IO.  *  * @param[in] this_request This parameter specifies the stp packet request object  *            being constructed.  *  * @return none  */
end_comment

begin_function
name|SCI_STATUS
name|scic_sds_stp_packet_request_construct
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
parameter_list|)
block|{
name|SATA_FIS_REG_H2D_T
modifier|*
name|h2d_fis
init|=
name|scic_stp_io_request_get_h2d_reg_address
argument_list|(
name|this_request
argument_list|)
decl_stmt|;
comment|// Work around, we currently only support PACKET DMA protocol, so we
comment|// need to make change to Packet Fis features field.
name|h2d_fis
operator|->
name|features
operator|=
name|h2d_fis
operator|->
name|features
operator||
name|ATA_PACKET_FEATURE_DMA
expr_stmt|;
name|scic_sds_stp_non_ncq_request_construct
argument_list|(
name|this_request
argument_list|)
expr_stmt|;
comment|// Build the Packet Fis task context structure
name|scu_stp_raw_request_construct_task_context
argument_list|(
operator|(
name|SCIC_SDS_STP_REQUEST_T
operator|*
operator|)
name|this_request
argument_list|,
name|this_request
operator|->
name|task_context_buffer
argument_list|)
expr_stmt|;
name|sci_base_state_machine_construct
argument_list|(
operator|&
name|this_request
operator|->
name|started_substate_machine
argument_list|,
operator|&
name|this_request
operator|->
name|parent
operator|.
name|parent
argument_list|,
name|scic_sds_stp_packet_request_started_substate_table
argument_list|,
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
argument_list|)
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will fill in the SCU Task Context for a Packet request  *        command phase in PACKET DMA DATA (IN/OUT) type. The following  *        important settings are utilized:  *  *          -# task_type == SCU_TASK_TYPE_PACKET_DMA.  This simply indicates  *             that a normal request type (i.e. non-raw frame) is being  *             utilized to perform task management.  *          -# control_frame == 1.  This ensures that the proper endianess  *             is set so that the bytes are transmitted in the right order  *             for a smp request frame.  *  * @param[in] this_request This parameter specifies the smp request object  *            being constructed.  * @param[in] task_context The task_context to be reconstruct for packet  *            request command phase.  * @return none  */
end_comment

begin_function
name|void
name|scu_stp_packet_request_command_phase_construct_task_context
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
parameter_list|,
name|SCU_TASK_CONTEXT_T
modifier|*
name|task_context
parameter_list|)
block|{
name|void
modifier|*
name|atapi_cdb
decl_stmt|;
name|U32
name|atapi_cdb_length
decl_stmt|;
name|SCIC_SDS_STP_REQUEST_T
modifier|*
name|stp_request
init|=
operator|(
name|SCIC_SDS_STP_REQUEST_T
operator|*
operator|)
name|this_request
decl_stmt|;
comment|// reference: SSTL 1.13.4.2
comment|// task_type, sata_direction
if|if
condition|(
name|scic_cb_io_request_get_data_direction
argument_list|(
name|this_request
operator|->
name|user_request
argument_list|)
operator|==
name|SCI_IO_REQUEST_DATA_OUT
condition|)
block|{
name|task_context
operator|->
name|task_type
operator|=
name|SCU_TASK_TYPE_PACKET_DMA_OUT
expr_stmt|;
name|task_context
operator|->
name|sata_direction
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|// todo: for NO_DATA command, we need to send out raw frame.
block|{
name|task_context
operator|->
name|task_type
operator|=
name|SCU_TASK_TYPE_PACKET_DMA_IN
expr_stmt|;
name|task_context
operator|->
name|sata_direction
operator|=
literal|1
expr_stmt|;
block|}
comment|// sata header
name|memset
argument_list|(
operator|&
operator|(
name|task_context
operator|->
name|type
operator|.
name|stp
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|STP_TASK_CONTEXT
argument_list|)
argument_list|)
expr_stmt|;
name|task_context
operator|->
name|type
operator|.
name|stp
operator|.
name|fis_type
operator|=
name|SATA_FIS_TYPE_DATA
expr_stmt|;
comment|// Copy in the command IU with CDB so that the commandIU address doesn't
comment|// change.
name|memset
argument_list|(
name|this_request
operator|->
name|command_buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SATA_FIS_REG_H2D_T
argument_list|)
argument_list|)
expr_stmt|;
name|atapi_cdb
operator|=
name|scic_cb_stp_packet_io_request_get_cdb_address
argument_list|(
name|this_request
operator|->
name|user_request
argument_list|)
expr_stmt|;
name|atapi_cdb_length
operator|=
name|scic_cb_stp_packet_io_request_get_cdb_length
argument_list|(
name|this_request
operator|->
name|user_request
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|(
name|U8
operator|*
operator|)
name|this_request
operator|->
name|command_buffer
operator|+
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
argument_list|,
name|atapi_cdb
argument_list|,
name|atapi_cdb_length
argument_list|)
expr_stmt|;
name|atapi_cdb_length
operator|=
name|MAX
argument_list|(
name|atapi_cdb_length
argument_list|,
name|stp_request
operator|->
name|type
operator|.
name|packet
operator|.
name|device_preferred_cdb_length
argument_list|)
expr_stmt|;
name|task_context
operator|->
name|ssp_command_iu_length
operator|=
operator|(
operator|(
name|atapi_cdb_length
operator|%
literal|4
operator|)
operator|==
literal|0
operator|)
condition|?
operator|(
name|atapi_cdb_length
operator|/
literal|4
operator|)
else|:
operator|(
operator|(
name|atapi_cdb_length
operator|/
literal|4
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
comment|// task phase is set to TX_CMD
name|task_context
operator|->
name|task_phase
operator|=
literal|0x1
expr_stmt|;
comment|// retry counter
name|task_context
operator|->
name|stp_retry_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scic_cb_request_is_initial_construction
argument_list|(
name|this_request
operator|->
name|user_request
argument_list|)
condition|)
block|{
comment|// data transfer size.
name|task_context
operator|->
name|transfer_length_bytes
operator|=
name|scic_cb_io_request_get_transfer_length
argument_list|(
name|this_request
operator|->
name|user_request
argument_list|)
expr_stmt|;
comment|// sgls were already built when request was constructed, so don't need to
comment|//  to do it here
block|}
else|else
block|{
comment|// data transfer size, need to be 4 bytes aligned.
name|task_context
operator|->
name|transfer_length_bytes
operator|=
operator|(
name|SCSI_FIXED_SENSE_DATA_BASE_LENGTH
operator|+
literal|2
operator|)
expr_stmt|;
name|scic_sds_stp_packet_internal_request_sense_build_sgl
argument_list|(
name|this_request
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method will fill in the SCU Task Context for a DATA fis  *        containing CDB in Raw Frame type. The TC for previous Packet  *        fis was already there, we only need to change the H2D fis content.  *  * @param[in] this_request This parameter specifies the smp request object  *            being constructed.  * @param[in] task_context The task_context to be reconstruct for packet  *            request command phase.  * @return none  */
end_comment

begin_function
name|void
name|scu_stp_packet_request_command_phase_reconstruct_raw_frame_task_context
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
parameter_list|,
name|SCU_TASK_CONTEXT_T
modifier|*
name|task_context
parameter_list|)
block|{
name|void
modifier|*
name|atapi_cdb
init|=
name|scic_cb_stp_packet_io_request_get_cdb_address
argument_list|(
name|this_request
operator|->
name|user_request
argument_list|)
decl_stmt|;
name|U32
name|atapi_cdb_length
init|=
name|scic_cb_stp_packet_io_request_get_cdb_length
argument_list|(
name|this_request
operator|->
name|user_request
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|this_request
operator|->
name|command_buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SATA_FIS_REG_H2D_T
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|(
name|U8
operator|*
operator|)
name|this_request
operator|->
name|command_buffer
operator|+
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
argument_list|,
name|atapi_cdb
argument_list|,
name|atapi_cdb_length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|task_context
operator|->
name|type
operator|.
name|stp
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|STP_TASK_CONTEXT
argument_list|)
argument_list|)
expr_stmt|;
name|task_context
operator|->
name|type
operator|.
name|stp
operator|.
name|fis_type
operator|=
name|SATA_FIS_TYPE_DATA
expr_stmt|;
comment|//Note the data send out has to be 4 bytes aligned. Or else out hardware will
comment|//patch non-zero bytes and cause the target device unhappy.
name|task_context
operator|->
name|transfer_length_bytes
operator|=
literal|12
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *@brief This methods decode the D2H status FIS and retrieve the sense data,  *          then pass the sense data to user request.  *  *@param[in] this_request The request receive D2H status FIS.  *@param[in] status_fis The D2H status fis to be processed.  *  */
end_comment

begin_function
name|SCI_STATUS
name|scic_sds_stp_packet_request_process_status_fis
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
parameter_list|,
name|SATA_FIS_REG_D2H_T
modifier|*
name|status_fis
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
comment|//TODO: Process the error status fis, retrieve sense data.
if|if
condition|(
name|status_fis
operator|->
name|status
operator|&
name|ATA_STATUS_REG_ERROR_BIT
condition|)
name|status
operator|=
name|SCI_FAILURE_IO_RESPONSE_VALID
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  *@brief This methods builds sgl for internal REQUEST SENSE stp packet  *          command using this request response buffer, only one sge is  *          needed.  *  *@param[in] this_request The request receive request sense data.  *  */
end_comment

begin_function
name|void
name|scic_sds_stp_packet_internal_request_sense_build_sgl
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
parameter_list|)
block|{
name|void
modifier|*
name|sge
decl_stmt|;
name|SCU_SGL_ELEMENT_PAIR_T
modifier|*
name|scu_sgl_list
init|=
name|NULL
decl_stmt|;
name|SCU_TASK_CONTEXT_T
modifier|*
name|task_context
decl_stmt|;
name|SCI_PHYSICAL_ADDRESS
name|physical_address
decl_stmt|;
name|SCI_SSP_RESPONSE_IU_T
modifier|*
name|rsp_iu
init|=
operator|(
name|SCI_SSP_RESPONSE_IU_T
operator|*
operator|)
name|this_request
operator|->
name|response_buffer
decl_stmt|;
name|sge
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|rsp_iu
operator|->
name|data
index|[
literal|0
index|]
expr_stmt|;
name|task_context
operator|=
operator|(
name|SCU_TASK_CONTEXT_T
operator|*
operator|)
name|this_request
operator|->
name|task_context_buffer
expr_stmt|;
name|scu_sgl_list
operator|=
operator|&
name|task_context
operator|->
name|sgl_pair_ab
expr_stmt|;
name|scic_cb_io_request_get_physical_address
argument_list|(
name|scic_sds_request_get_controller
argument_list|(
name|this_request
argument_list|)
argument_list|,
name|this_request
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|sge
operator|)
argument_list|,
operator|&
name|physical_address
argument_list|)
expr_stmt|;
name|scu_sgl_list
operator|->
name|A
operator|.
name|address_upper
operator|=
name|sci_cb_physical_address_upper
argument_list|(
name|physical_address
argument_list|)
expr_stmt|;
name|scu_sgl_list
operator|->
name|A
operator|.
name|address_lower
operator|=
name|sci_cb_physical_address_lower
argument_list|(
name|physical_address
argument_list|)
expr_stmt|;
name|scu_sgl_list
operator|->
name|A
operator|.
name|length
operator|=
name|task_context
operator|->
name|transfer_length_bytes
expr_stmt|;
name|scu_sgl_list
operator|->
name|A
operator|.
name|address_modifier
operator|=
literal|0
expr_stmt|;
name|SCU_SGL_ZERO
argument_list|(
name|scu_sgl_list
operator|->
name|B
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* STP PACKET REQUEST STATE MACHINES
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/** * @brief This method processes the completions transport layer (TL) status *        to determine if the Packet FIS was sent successfully. If the Packet *        FIS was sent successfully, then the state for the Packet request *        transits to waiting for a PIO SETUP frame. * * @param[in] this_request This parameter specifies the request for which *            the TC completion was received. * @param[in] completion_code This parameter indicates the completion status *            information for the TC. * * @return Indicate if the tc completion handler was successful. * @retval SCI_SUCCESS currently this method always returns success. */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_stp_packet_request_packet_phase_await_tc_completion_tc_completion_handler
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
parameter_list|,
name|U32
name|completion_code
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_request
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_STP_IO_REQUEST
operator|,
literal|"scic_sds_stp_packet_request_packet_phase_await_tc_completion_tc_completion_handler(0x%x, 0x%x) enter\n"
operator|,
name|this_request
operator|,
name|completion_code
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SCU_GET_COMPLETION_TL_STATUS
argument_list|(
name|completion_code
argument_list|)
condition|)
block|{
case|case
name|SCU_MAKE_COMPLETION_STATUS
argument_list|(
name|SCU_TASK_DONE_GOOD
argument_list|)
case|:
name|scic_sds_request_set_status
argument_list|(
name|this_request
argument_list|,
name|SCU_TASK_DONE_GOOD
argument_list|,
name|SCI_SUCCESS
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|started_substate_machine
argument_list|,
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_PIO_SETUP_SUBSTATE
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// All other completion status cause the IO to be complete.  If a NAK
comment|// was received, then it is up to the user to retry the request.
name|scic_sds_request_set_status
argument_list|(
name|this_request
argument_list|,
name|SCU_NORMALIZE_COMPLETION_STATUS
argument_list|(
name|completion_code
argument_list|)
argument_list|,
name|SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_COMPLETED
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method processes an unsolicited frame while the Packet request  *        is waiting for a PIO SETUP FIS.  It will release  *        the unsolicited frame, and transition the request to the  *        COMMAND_PHASE_AWAIT_TC_COMPLETION_SUBSTATE state.  *  * @param[in] this_request This parameter specifies the request for which  *            the unsolicited frame was received.  * @param[in] frame_index This parameter indicates the unsolicited frame  *            index that should contain the response.  *  * @return This method returns an indication of whether the pio setup  *         frame was handled successfully or not.  * @retval SCI_SUCCESS Currently this value is always returned and indicates  *         successful processing of the TC response.  *  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_stp_packet_request_packet_phase_await_pio_setup_frame_handler
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|request
parameter_list|,
name|U32
name|frame_index
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|SATA_FIS_HEADER_T
modifier|*
name|frame_header
decl_stmt|;
name|U32
modifier|*
name|frame_buffer
decl_stmt|;
name|SCIC_SDS_STP_REQUEST_T
modifier|*
name|this_request
decl_stmt|;
name|this_request
operator|=
operator|(
name|SCIC_SDS_STP_REQUEST_T
operator|*
operator|)
name|request
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_request
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_STP_IO_REQUEST
operator|,
literal|"scic_sds_stp_packet_request_packet_phase_await_pio_setup_frame_handler(0x%x, 0x%x) enter\n"
operator|,
name|this_request
operator|,
name|frame_index
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|scic_sds_unsolicited_frame_control_get_header
argument_list|(
operator|&
operator|(
name|this_request
operator|->
name|parent
operator|.
name|owning_controller
operator|->
name|uf_control
operator|)
argument_list|,
name|frame_index
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|frame_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|ASSERT
argument_list|(
name|frame_header
operator|->
name|fis_type
operator|==
name|SATA_FIS_TYPE_PIO_SETUP
argument_list|)
expr_stmt|;
comment|// Get from the frame buffer the PIO Setup Data, although we don't need
comment|// any info from this pio setup fis.
name|scic_sds_unsolicited_frame_control_get_buffer
argument_list|(
operator|&
operator|(
name|this_request
operator|->
name|parent
operator|.
name|owning_controller
operator|->
name|uf_control
operator|)
argument_list|,
name|frame_index
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|frame_buffer
argument_list|)
expr_stmt|;
comment|// Get the data from the PIO Setup
comment|// The SCU Hardware returns first word in the frame_header and the rest
comment|// of the data is in the frame buffer so we need to back up one dword
name|this_request
operator|->
name|type
operator|.
name|packet
operator|.
name|device_preferred_cdb_length
operator|=
call|(
name|U16
call|)
argument_list|(
operator|(
name|SATA_FIS_PIO_SETUP_T
operator|*
operator|)
operator|(
operator|&
name|frame_buffer
index|[
operator|-
literal|1
index|]
operator|)
argument_list|)
operator|->
name|transfter_count
expr_stmt|;
comment|// Frame has been decoded return it to the controller
name|scic_sds_controller_release_frame
argument_list|(
name|this_request
operator|->
name|parent
operator|.
name|owning_controller
argument_list|,
name|frame_index
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|parent
operator|.
name|started_substate_machine
argument_list|,
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_request
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_STP_IO_REQUEST
operator|,
literal|"SCIC IO Request 0x%x could not get frame header for frame index %d, status %x\n"
operator|,
name|this_request
operator|,
name|frame_index
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method processes the completions transport layer (TL) status  *        to determine if the PACKET command data FIS was sent successfully.  *        If successfully, then the state for the packet request  *        transits to COMPLETE state. If not successfuly, the request transits  *        to COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE.  *  * @param[in] this_request This parameter specifies the request for which  *            the TC completion was received.  * @param[in] completion_code This parameter indicates the completion status  *            information for the TC.  *  * @return Indicate if the tc completion handler was successful.  * @retval SCI_SUCCESS currently this method always returns success.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_stp_packet_request_command_phase_await_tc_completion_tc_completion_handler
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
parameter_list|,
name|U32
name|completion_code
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|U8
name|sat_packet_protocol
init|=
name|this_request
operator|->
name|sat_protocol
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_request
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_STP_IO_REQUEST
operator|,
literal|"scic_sds_stp_packet_request_command_phase_await_tc_completion_tc_completion_handler(0x%x, 0x%x) enter\n"
operator|,
name|this_request
operator|,
name|completion_code
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SCU_GET_COMPLETION_TL_STATUS
argument_list|(
name|completion_code
argument_list|)
condition|)
block|{
case|case
operator|(
name|SCU_TASK_DONE_GOOD
operator|<<
name|SCU_COMPLETION_TL_STATUS_SHIFT
operator|)
case|:
name|scic_sds_request_set_status
argument_list|(
name|this_request
argument_list|,
name|SCU_TASK_DONE_GOOD
argument_list|,
name|SCI_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sat_packet_protocol
operator|==
name|SAT_PROTOCOL_PACKET_DMA_DATA_IN
operator|||
name|sat_packet_protocol
operator|==
name|SAT_PROTOCOL_PACKET_DMA_DATA_OUT
condition|)
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_COMPLETED
argument_list|)
expr_stmt|;
else|else
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|started_substate_machine
argument_list|,
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|SCU_TASK_DONE_UNEXP_FIS
operator|<<
name|SCU_COMPLETION_TL_STATUS_SHIFT
operator|)
case|:
if|if
condition|(
name|scic_io_request_get_number_of_bytes_transferred
argument_list|(
name|this_request
argument_list|)
operator|<
name|scic_cb_io_request_get_transfer_length
argument_list|(
name|this_request
operator|->
name|user_request
argument_list|)
condition|)
block|{
name|scic_sds_request_set_status
argument_list|(
name|this_request
argument_list|,
name|SCU_TASK_DONE_GOOD
argument_list|,
name|SCI_SUCCESS_IO_DONE_EARLY
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|started_substate_machine
argument_list|,
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMPLETION_DELAY_SUBSTATE
argument_list|)
expr_stmt|;
comment|//change the device state to ATAPI_ERROR.
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|target_device
operator|->
name|ready_substate_machine
argument_list|,
name|SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR
argument_list|)
expr_stmt|;
name|status
operator|=
name|this_request
operator|->
name|sci_status
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|SCU_TASK_DONE_EXCESS_DATA
operator|<<
name|SCU_COMPLETION_TL_STATUS_SHIFT
operator|)
case|:
comment|//In this case, there is no UF coming after. compelte the IO now.
name|scic_sds_request_set_status
argument_list|(
name|this_request
argument_list|,
name|SCU_TASK_DONE_GOOD
argument_list|,
name|SCI_SUCCESS
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_COMPLETED
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|this_request
operator|->
name|sci_status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
comment|//The io status was set already. This means an UF for the status
comment|//fis was received already.
comment|//A device suspension event is expected, we need to have the device
comment|//coming out of suspension, then complete the IO.
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|started_substate_machine
argument_list|,
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMPLETION_DELAY_SUBSTATE
argument_list|)
expr_stmt|;
comment|//change the device state to ATAPI_ERROR.
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|target_device
operator|->
name|ready_substate_machine
argument_list|,
name|SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR
argument_list|)
expr_stmt|;
name|status
operator|=
name|this_request
operator|->
name|sci_status
expr_stmt|;
block|}
else|else
block|{
comment|//If receiving any non-sucess TC status, no UF received yet, then an UF for
comment|//the status fis is coming after.
name|scic_sds_request_set_status
argument_list|(
name|this_request
argument_list|,
name|SCU_TASK_DONE_CHECK_RESPONSE
argument_list|,
name|SCI_FAILURE_IO_RESPONSE_VALID
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|started_substate_machine
argument_list|,
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/** * @brief This method processes an unsolicited frame. * * @param[in] this_request This parameter specifies the request for which *            the unsolicited frame was received. * @param[in] frame_index This parameter indicates the unsolicited frame *            index that should contain the response. * * @return This method returns an indication of whether the UF *         frame was handled successfully or not. * @retval SCI_SUCCESS Currently this value is always returned and indicates *         successful processing of the TC response. * */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_stp_packet_request_command_phase_common_frame_handler
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|request
parameter_list|,
name|U32
name|frame_index
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|SATA_FIS_HEADER_T
modifier|*
name|frame_header
decl_stmt|;
name|U32
modifier|*
name|frame_buffer
decl_stmt|;
name|SCIC_SDS_STP_REQUEST_T
modifier|*
name|this_request
decl_stmt|;
name|this_request
operator|=
operator|(
name|SCIC_SDS_STP_REQUEST_T
operator|*
operator|)
name|request
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_request
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_STP_IO_REQUEST
operator|,
literal|"scic_sds_stp_packet_request_command_phase_await_d2h_frame_handler(0x%x, 0x%x) enter\n"
operator|,
name|this_request
operator|,
name|frame_index
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|scic_sds_unsolicited_frame_control_get_header
argument_list|(
operator|&
operator|(
name|this_request
operator|->
name|parent
operator|.
name|owning_controller
operator|->
name|uf_control
operator|)
argument_list|,
name|frame_index
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|frame_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|ASSERT
argument_list|(
name|frame_header
operator|->
name|fis_type
operator|==
name|SATA_FIS_TYPE_REGD2H
argument_list|)
expr_stmt|;
comment|// Get from the frame buffer the PIO Setup Data, although we don't need
comment|// any info from this pio setup fis.
name|scic_sds_unsolicited_frame_control_get_buffer
argument_list|(
operator|&
operator|(
name|this_request
operator|->
name|parent
operator|.
name|owning_controller
operator|->
name|uf_control
operator|)
argument_list|,
name|frame_index
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|frame_buffer
argument_list|)
expr_stmt|;
name|scic_sds_controller_copy_sata_response
argument_list|(
operator|&
name|this_request
operator|->
name|d2h_reg_fis
argument_list|,
operator|(
name|U32
operator|*
operator|)
name|frame_header
argument_list|,
name|frame_buffer
argument_list|)
expr_stmt|;
comment|// Frame has been decoded return it to the controller
name|scic_sds_controller_release_frame
argument_list|(
name|this_request
operator|->
name|parent
operator|.
name|owning_controller
argument_list|,
name|frame_index
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/** * @brief This method processes an unsolicited frame while the packet request is *        expecting TC completion. It will process the FIS and construct sense *        data. * * @param[in] this_request This parameter specifies the request for which *            the unsolicited frame was received. * @param[in] frame_index This parameter indicates the unsolicited frame *            index that should contain the response. * * @return This method returns an indication of whether the UF *         frame was handled successfully or not. * @retval SCI_SUCCESS Currently this value is always returned and indicates *         successful processing of the TC response. * */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_stp_packet_request_command_phase_await_tc_completion_frame_handler
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|request
parameter_list|,
name|U32
name|frame_index
parameter_list|)
block|{
name|SCIC_SDS_STP_REQUEST_T
modifier|*
name|this_request
init|=
operator|(
name|SCIC_SDS_STP_REQUEST_T
operator|*
operator|)
name|request
decl_stmt|;
name|SCI_STATUS
name|status
init|=
name|scic_sds_stp_packet_request_command_phase_common_frame_handler
argument_list|(
name|request
argument_list|,
name|frame_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// The command has completed with error status from target device.
name|status
operator|=
name|scic_sds_stp_packet_request_process_status_fis
argument_list|(
name|request
argument_list|,
operator|&
name|this_request
operator|->
name|d2h_reg_fis
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|scic_sds_request_set_status
argument_list|(
operator|&
name|this_request
operator|->
name|parent
argument_list|,
name|SCU_TASK_DONE_CHECK_RESPONSE
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
name|scic_sds_request_set_status
argument_list|(
operator|&
name|this_request
operator|->
name|parent
argument_list|,
name|SCU_TASK_DONE_GOOD
argument_list|,
name|SCI_SUCCESS
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/** * @brief This method processes an unsolicited frame while the packet request is *        expecting TC completion. It will process the FIS and construct sense *        data. * * @param[in] this_request This parameter specifies the request for which *            the unsolicited frame was received. * @param[in] frame_index This parameter indicates the unsolicited frame *            index that should contain the response. * * @return This method returns an indication of whether the UF *         frame was handled successfully or not. * @retval SCI_SUCCESS Currently this value is always returned and indicates *         successful processing of the TC response. * */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_stp_packet_request_command_phase_await_d2h_fis_frame_handler
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|request
parameter_list|,
name|U32
name|frame_index
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|scic_sds_stp_packet_request_command_phase_common_frame_handler
argument_list|(
name|request
argument_list|,
name|frame_index
argument_list|)
decl_stmt|;
name|SCIC_SDS_STP_REQUEST_T
modifier|*
name|this_request
init|=
operator|(
name|SCIC_SDS_STP_REQUEST_T
operator|*
operator|)
name|request
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// The command has completed with error status from target device.
name|status
operator|=
name|scic_sds_stp_packet_request_process_status_fis
argument_list|(
name|request
argument_list|,
operator|&
name|this_request
operator|->
name|d2h_reg_fis
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|scic_sds_request_set_status
argument_list|(
name|request
argument_list|,
name|SCU_TASK_DONE_CHECK_RESPONSE
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
name|scic_sds_request_set_status
argument_list|(
name|request
argument_list|,
name|SCU_TASK_DONE_GOOD
argument_list|,
name|SCI_SUCCESS
argument_list|)
expr_stmt|;
comment|//Always complete the NON_DATA command right away, no need to delay completion
comment|//even an error status fis came from target device.
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|request
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_COMPLETED
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_stp_packet_request_started_completion_delay_complete_handler
parameter_list|(
name|SCI_BASE_REQUEST_T
modifier|*
name|request
parameter_list|)
block|{
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
init|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|request
decl_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_COMPLETED
argument_list|)
expr_stmt|;
return|return
name|this_request
operator|->
name|sci_status
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_decl_stmt
name|SCIC_SDS_IO_REQUEST_STATE_HANDLER_T
name|scic_sds_stp_packet_request_started_substate_handler_table
index|[
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_MAX_SUBSTATES
index|]
init|=
block|{
comment|// SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
block|{
block|{
name|scic_sds_request_default_start_handler
block|,
name|scic_sds_request_started_state_abort_handler
block|,
name|scic_sds_request_default_complete_handler
block|,
name|scic_sds_request_default_destruct_handler
block|}
block|,
name|scic_sds_stp_packet_request_packet_phase_await_tc_completion_tc_completion_handler
block|,
name|scic_sds_request_default_event_handler
block|,
name|scic_sds_request_default_frame_handler
block|}
block|,
comment|// SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_PIO_SETUP_SUBSTATE
block|{
block|{
name|scic_sds_request_default_start_handler
block|,
name|scic_sds_request_started_state_abort_handler
block|,
name|scic_sds_request_default_complete_handler
block|,
name|scic_sds_request_default_destruct_handler
block|}
block|,
name|scic_sds_request_default_tc_completion_handler
block|,
name|scic_sds_request_default_event_handler
block|,
name|scic_sds_stp_packet_request_packet_phase_await_pio_setup_frame_handler
block|}
block|,
comment|// SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
block|{
block|{
name|scic_sds_request_default_start_handler
block|,
name|scic_sds_request_started_state_abort_handler
block|,
name|scic_sds_request_default_complete_handler
block|,
name|scic_sds_request_default_destruct_handler
block|}
block|,
name|scic_sds_stp_packet_request_command_phase_await_tc_completion_tc_completion_handler
block|,
name|scic_sds_request_default_event_handler
block|,
name|scic_sds_stp_packet_request_command_phase_await_tc_completion_frame_handler
block|}
block|,
comment|// SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE
block|{
block|{
name|scic_sds_request_default_start_handler
block|,
name|scic_sds_request_started_state_abort_handler
block|,
name|scic_sds_request_default_complete_handler
block|,
name|scic_sds_request_default_destruct_handler
block|}
block|,
name|scic_sds_request_default_tc_completion_handler
block|,
name|scic_sds_request_default_event_handler
block|,
name|scic_sds_stp_packet_request_command_phase_await_d2h_fis_frame_handler
block|}
block|,
comment|// SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMPLETION_DELAY_SUBSTATE
block|{
block|{
name|scic_sds_request_default_start_handler
block|,
name|scic_sds_request_started_state_abort_handler
block|,
name|scic_sds_stp_packet_request_started_completion_delay_complete_handler
block|,
name|scic_sds_request_default_destruct_handler
block|}
block|,
name|scic_sds_request_default_tc_completion_handler
block|,
name|scic_sds_request_default_event_handler
block|,
name|scic_sds_request_default_frame_handler
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * @file  *  * @brief This file contains the Packet IO started substate machine  *        for the SCIC_SDS_IO_REQUEST object.  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_stp_packet_request_started_packet_phase_await_tc_completion_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
init|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|object
decl_stmt|;
name|SET_STATE_HANDLER
argument_list|(
name|this_request
argument_list|,
name|scic_sds_stp_packet_request_started_substate_handler_table
argument_list|,
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
argument_list|)
expr_stmt|;
name|scic_sds_remote_device_set_working_request
argument_list|(
name|this_request
operator|->
name|target_device
argument_list|,
name|this_request
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scic_sds_stp_packet_request_started_packet_phase_await_pio_setup_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
init|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|object
decl_stmt|;
name|SET_STATE_HANDLER
argument_list|(
name|this_request
argument_list|,
name|scic_sds_stp_packet_request_started_substate_handler_table
argument_list|,
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_PIO_SETUP_SUBSTATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scic_sds_stp_packet_request_started_command_phase_await_tc_completion_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
init|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|object
decl_stmt|;
name|U8
name|sat_packet_protocol
init|=
name|this_request
operator|->
name|sat_protocol
decl_stmt|;
name|SCU_TASK_CONTEXT_T
modifier|*
name|task_context
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
comment|// Recycle the TC and reconstruct it for sending out data fis containing
comment|// CDB.
name|task_context
operator|=
name|scic_sds_controller_get_task_context_buffer
argument_list|(
name|this_request
operator|->
name|owning_controller
argument_list|,
name|this_request
operator|->
name|io_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sat_packet_protocol
operator|==
name|SAT_PROTOCOL_PACKET_NON_DATA
condition|)
name|scu_stp_packet_request_command_phase_reconstruct_raw_frame_task_context
argument_list|(
name|this_request
argument_list|,
name|task_context
argument_list|)
expr_stmt|;
else|else
name|scu_stp_packet_request_command_phase_construct_task_context
argument_list|(
name|this_request
argument_list|,
name|task_context
argument_list|)
expr_stmt|;
comment|// send the new TC out.
name|status
operator|=
name|this_request
operator|->
name|owning_controller
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|continue_io_handler
argument_list|(
operator|&
name|this_request
operator|->
name|owning_controller
operator|->
name|parent
argument_list|,
operator|&
name|this_request
operator|->
name|target_device
operator|->
name|parent
argument_list|,
operator|&
name|this_request
operator|->
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
name|SET_STATE_HANDLER
argument_list|(
name|this_request
argument_list|,
name|scic_sds_stp_packet_request_started_substate_handler_table
argument_list|,
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scic_sds_stp_packet_request_started_command_phase_await_d2h_fis_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
init|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|object
decl_stmt|;
name|SET_STATE_HANDLER
argument_list|(
name|this_request
argument_list|,
name|scic_sds_stp_packet_request_started_substate_handler_table
argument_list|,
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scic_sds_stp_packet_request_started_completion_delay_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
init|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|object
decl_stmt|;
name|SET_STATE_HANDLER
argument_list|(
name|this_request
argument_list|,
name|scic_sds_stp_packet_request_started_substate_handler_table
argument_list|,
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMPLETION_DELAY_SUBSTATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_decl_stmt
name|SCI_BASE_STATE_T
name|scic_sds_stp_packet_request_started_substate_table
index|[
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_MAX_SUBSTATES
index|]
init|=
block|{
block|{
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
block|,
name|scic_sds_stp_packet_request_started_packet_phase_await_tc_completion_enter
block|,
name|NULL
block|}
block|,
block|{
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_PIO_SETUP_SUBSTATE
block|,
name|scic_sds_stp_packet_request_started_packet_phase_await_pio_setup_enter
block|,
name|NULL
block|}
block|,
block|{
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
block|,
name|scic_sds_stp_packet_request_started_command_phase_await_tc_completion_enter
block|,
name|NULL
block|}
block|,
block|{
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE
block|,
name|scic_sds_stp_packet_request_started_command_phase_await_d2h_fis_enter
block|,
name|NULL
block|}
block|,
block|{
name|SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMPLETION_DELAY_SUBSTATE
block|,
name|scic_sds_stp_packet_request_started_completion_delay_enter
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//#if !defined(DISABLE_ATAPI)
end_comment

end_unit

