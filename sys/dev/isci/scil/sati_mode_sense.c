begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  * @brief This file contains the method implementations required to  *        translate the SCSI mode sense (6 and 10-byte) commands.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_MODE_SENSE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/isci/scil/sati_mode_sense.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sati_mode_pages.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sati_callbacks.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sati_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_scsi.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_ata.h>
end_include

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* P R I V A T E   M E T H O D S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_define
define|#
directive|define
name|STANDBY_TIMER_DISABLED
value|0x00
end_define

begin_define
define|#
directive|define
name|STANDBY_TIMER_ENABLED
value|0x01
end_define

begin_define
define|#
directive|define
name|STANDBY_TIMER_SUPPORTED
value|0x2000
end_define

begin_comment
comment|/**  * @brief This method indicates if the supplied page control is supported  *        by this translation implementation.  Currently savable parameters  *        (i.e. non-volatile) are not supported.  *        For more information on the parameters passed to this method,  *        please reference sati_translate_command().  *  * @return This method returns an indication of whether the page control  *         specified in the SCSI CDB is supported.  * @retval SATI_SUCCESS This value is returned if the page control is  *         supported.  * @retval SATI_FAILURE_CHECK_RESPONSE_DATA This value is returned if the  *         page control is not supported.  */
end_comment

begin_function
specifier|static
name|SATI_STATUS
name|sati_mode_sense_is_page_control_supported
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|)
block|{
name|U8
modifier|*
name|cdb
init|=
name|sati_cb_get_cdb_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|2
argument_list|)
operator|>>
name|SCSI_MODE_SENSE_PC_SHIFT
condition|)
block|{
case|case
name|SCSI_MODE_SENSE_PC_CURRENT
case|:
case|case
name|SCSI_MODE_SENSE_PC_DEFAULT
case|:
case|case
name|SCSI_MODE_SENSE_PC_CHANGEABLE
case|:
return|return
name|SATI_SUCCESS
return|;
break|break;
default|default:
case|case
name|SCSI_MODE_SENSE_PC_SAVED
case|:
name|sati_scsi_sense_data_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|SCSI_STATUS_CHECK_CONDITION
argument_list|,
name|SCSI_SENSE_ILLEGAL_REQUEST
argument_list|,
name|SCSI_ASC_SAVING_PARMS_NOT_SUPPORTED
argument_list|,
name|SCSI_ASCQ_SAVING_PARMS_NOT_SUPPORTED
argument_list|)
expr_stmt|;
return|return
name|SATI_FAILURE_CHECK_RESPONSE_DATA
return|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method indicates if the page code field in the SCSI CDB  *        is supported by this translation.  *        For more information on the parameters passed to this method,  *        please reference sati_translate_command().  *  * @param[in] cdb_length This parameter specifies the length of the SCSI  *            CDB being translated (e.g. 6-byte, 10-byte, 12-byte, etc.)  *  * @return This method returns an indication as to whether the page code  *         in the CDB is supported.  * @retval SATI_SUCCESS This value is returned if the page code is  *         supported.  * @retval SATI_FAILURE_CHECK_RESPONSE_DATA This value is returned if the  *         page code is not supported.  */
end_comment

begin_function
specifier|static
name|SATI_STATUS
name|sati_mode_sense_is_page_code_supported
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|U8
name|cdb_length
parameter_list|)
block|{
name|U8
modifier|*
name|cdb
init|=
name|sati_cb_get_cdb_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|2
argument_list|)
operator|&
name|SCSI_MODE_SENSE_PAGE_CODE_ENABLE
condition|)
block|{
case|case
name|SCSI_MODE_PAGE_CACHING
case|:
if|if
condition|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|)
operator|==
name|SCSI_MODE_SENSE_6
condition|)
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SENSE_6_CACHING
expr_stmt|;
else|else
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SENSE_10_CACHING
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_ALL_PAGES
case|:
if|if
condition|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|)
operator|==
name|SCSI_MODE_SENSE_6
condition|)
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SENSE_6_ALL_PAGES
expr_stmt|;
else|else
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SENSE_10_ALL_PAGES
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_READ_WRITE_ERROR
case|:
if|if
condition|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|)
operator|==
name|SCSI_MODE_SENSE_6
condition|)
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SENSE_6_READ_WRITE_ERROR
expr_stmt|;
else|else
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SENSE_10_READ_WRITE_ERROR
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_DISCONNECT_RECONNECT
case|:
if|if
condition|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|)
operator|==
name|SCSI_MODE_SENSE_6
condition|)
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SENSE_6_DISCONNECT_RECONNECT
expr_stmt|;
else|else
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SENSE_10_DISCONNECT_RECONNECT
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_CONTROL
case|:
if|if
condition|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|)
operator|==
name|SCSI_MODE_SENSE_6
condition|)
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SENSE_6_CONTROL
expr_stmt|;
else|else
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SENSE_10_CONTROL
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_POWER_CONDITION
case|:
if|if
condition|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|)
operator|==
name|SCSI_MODE_SENSE_6
condition|)
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SENSE_6_POWER_CONDITION
expr_stmt|;
else|else
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SENSE_10_POWER_CONDITION
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_INFORMATIONAL_EXCP_CONTROL
case|:
comment|// The informational exceptions control page is only useful
comment|// if SMART is supported.
if|if
condition|(
operator|(
name|sequence
operator|->
name|device
operator|->
name|capabilities
operator||
name|SATI_DEVICE_CAP_SMART_SUPPORT
operator|)
operator|==
literal|0
condition|)
block|{
comment|// For a MODE SENSE, utilize INVALID FIELD IN CDB,
comment|// For a MODE SELECT, utilize INVALID FIELD IN PARAMETER LIST.
if|if
condition|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|)
operator|==
name|SCSI_MODE_SENSE_6
condition|)
block|{
name|sati_scsi_sense_data_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|SCSI_STATUS_CHECK_CONDITION
argument_list|,
name|SCSI_SENSE_ILLEGAL_REQUEST
argument_list|,
name|SCSI_ASC_INVALID_FIELD_IN_CDB
argument_list|,
name|SCSI_ASCQ_INVALID_FIELD_IN_CDB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sati_scsi_sense_data_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|SCSI_STATUS_CHECK_CONDITION
argument_list|,
name|SCSI_SENSE_ILLEGAL_REQUEST
argument_list|,
name|SCSI_ASC_INVALID_FIELD_IN_PARM_LIST
argument_list|,
name|SCSI_ASCQ_INVALID_FIELD_IN_PARM_LIST
argument_list|)
expr_stmt|;
block|}
return|return
name|SATI_FAILURE_CHECK_RESPONSE_DATA
return|;
block|}
if|if
condition|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|)
operator|==
name|SCSI_MODE_SENSE_6
condition|)
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SENSE_6_INFORMATIONAL_EXCP_CONTROL
expr_stmt|;
else|else
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SENSE_10_INFORMATIONAL_EXCP_CONTROL
expr_stmt|;
break|break;
default|default:
name|sati_scsi_sense_data_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|SCSI_STATUS_CHECK_CONDITION
argument_list|,
name|SCSI_SENSE_ILLEGAL_REQUEST
argument_list|,
name|SCSI_ASC_INVALID_FIELD_IN_CDB
argument_list|,
name|SCSI_ASCQ_INVALID_FIELD_IN_CDB
argument_list|)
expr_stmt|;
return|return
name|SATI_FAILURE_CHECK_RESPONSE_DATA
return|;
break|break;
block|}
return|return
name|SATI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* P R O T E C T E D   M E T H O D S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method will calculate the size of the mode sense data header.  *        This includes the block descriptor if one is requested.  *  * @param[in] scsi_io This parameter specifies the user's SCSI IO object  *            for which to calculate the mode page header.  * @param[in] cdb_size This parameter specifies the number of bytes  *            associated with the CDB for which to calculate the header.  *  * @return This method returns the size, in bytes, for the mode page header.  */
end_comment

begin_function
name|U16
name|sati_mode_sense_calculate_page_header
parameter_list|(
name|void
modifier|*
name|scsi_io
parameter_list|,
name|U8
name|cdb_size
parameter_list|)
block|{
name|U8
modifier|*
name|cdb
init|=
name|sati_cb_get_cdb_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
name|U16
name|page_length
init|=
literal|0
decl_stmt|;
comment|// The Mode page header length is different for 6-byte vs. 10-byte CDBs.
if|if
condition|(
name|cdb_size
operator|==
literal|6
condition|)
name|page_length
operator|+=
name|SCSI_MODE_SENSE_6_HEADER_LENGTH
expr_stmt|;
else|else
name|page_length
operator|+=
name|SCSI_MODE_SENSE_10_HEADER_LENGTH
expr_stmt|;
comment|// Are block descriptors disabled (DBD)?  0 indicates they are enabled.
if|if
condition|(
operator|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|1
argument_list|)
operator|&
name|SCSI_MODE_SENSE_DBD_ENABLE
operator|)
operator|==
literal|0
condition|)
block|{
comment|// The LLBAA bit is not defined for 6-byte mode sense requests.
if|if
condition|(
operator|(
name|cdb_size
operator|==
literal|10
operator|)
operator|&&
operator|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|1
argument_list|)
operator|&
name|SCSI_MODE_SENSE_LLBAA_ENABLE
operator|)
condition|)
name|page_length
operator|+=
name|SCSI_MODE_SENSE_LLBA_BLOCK_DESCRIPTOR_LENGTH
expr_stmt|;
else|else
name|page_length
operator|+=
name|SCSI_MODE_SENSE_STD_BLOCK_DESCRIPTOR_LENGTH
expr_stmt|;
block|}
return|return
name|page_length
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method performs command translation common to all mode sense  *        requests (6 or 10 byte).  *        For more information on the parameters passed to this method,  *        please reference sati_translate_command().  *  * @param[in] cdb_length This parameter specifies the number of bytes  *            in the CDB (6 or 10).  *  * @return This method returns an indication as to whether the translation  *         succeeded.  * @retval SCI_SUCCESS This value is returned if translation succeeded.  * @see sati_mode_sense_is_page_control_supported() or  *      sati_mode_sense_is_page_code_supported() for more information.  */
end_comment

begin_function
name|SATI_STATUS
name|sati_mode_sense_translate_command
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_io
parameter_list|,
name|U8
name|cdb_length
parameter_list|)
block|{
name|SATI_STATUS
name|status
decl_stmt|;
comment|/**     * Validate that the supplied page control (PC) field is supported.     */
name|status
operator|=
name|sati_mode_sense_is_page_control_supported
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SATI_SUCCESS
condition|)
return|return
name|status
return|;
comment|/**     * Validate that the supplied page code is supported.     */
name|status
operator|=
name|sati_mode_sense_is_page_code_supported
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|cdb_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SATI_SUCCESS
condition|)
return|return
name|status
return|;
name|sati_ata_identify_device_construct
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
return|return
name|SATI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will build the standard block descriptor for a MODE  *        SENSE 6 or 10 byte request.  *        For more information on the parameters passed to this method,  *        please reference sati_translate_command().  *  * @param[in] identify This parameter specifies the IDENTIFY DEVICE data  *            associated with the SCSI IO.  * @param[in] offset This parameter specifies the offset into the data  *            buffer at which to build the block descriptor.  *  * @return This method returns the size of the block descriptor built.  */
end_comment

begin_function
name|U32
name|sati_mode_sense_build_std_block_descriptor
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|ATA_IDENTIFY_DEVICE_DATA_T
modifier|*
name|identify
parameter_list|,
name|U32
name|offset
parameter_list|)
block|{
name|U32
name|lba_low
init|=
literal|0
decl_stmt|;
name|U32
name|lba_high
init|=
literal|0
decl_stmt|;
name|U32
name|sector_size
init|=
literal|0
decl_stmt|;
comment|// Extract the sector information (sector size, logical blocks) from
comment|// the retrieved ATA identify device data.
name|sati_ata_identify_device_get_sector_info
argument_list|(
name|identify
argument_list|,
operator|&
name|lba_high
argument_list|,
operator|&
name|lba_low
argument_list|,
operator|&
name|sector_size
argument_list|)
expr_stmt|;
comment|// Fill in the 4-byte logical block address field.
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
argument_list|,
call|(
name|U8
call|)
argument_list|(
operator|(
name|lba_low
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|1
argument_list|,
call|(
name|U8
call|)
argument_list|(
operator|(
name|lba_low
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|2
argument_list|,
call|(
name|U8
call|)
argument_list|(
operator|(
name|lba_low
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|3
argument_list|,
call|(
name|U8
call|)
argument_list|(
name|lba_low
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
comment|// Clear the reserved field.
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Fill in the three byte Block Length field
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|5
argument_list|,
call|(
name|U8
call|)
argument_list|(
operator|(
name|sector_size
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|6
argument_list|,
call|(
name|U8
call|)
argument_list|(
operator|(
name|sector_size
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|7
argument_list|,
call|(
name|U8
call|)
argument_list|(
name|sector_size
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SCSI_MODE_SENSE_STD_BLOCK_DESCRIPTOR_LENGTH
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method simply copies the mode sense data into the buffer  *        at the location specified by page_start.  The buffer copied is  *        determined by page_control (e.g. current, default, or changeable  *        values).  *        For more information on the parameters passed to this method,  *        please reference sati_translate_command().  *  * @param[in] page_start This parameter specifies the starting offset at  *            which to copy the mode page data.  * @param[in] page_control This parameter specifies the page control  *            indicating the source buffer to be copied.  * @param[in] page_code This specifies the mode sense page to copy.  *  * @return This method returns the size of the mode page data being copied.  */
end_comment

begin_function
name|U32
name|sati_mode_sense_copy_initial_data
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|U32
name|page_start
parameter_list|,
name|U8
name|page_control
parameter_list|,
name|U8
name|page_code
parameter_list|)
block|{
name|U16
name|page_index
init|=
name|sati_mode_page_get_page_index
argument_list|(
name|page_code
argument_list|)
decl_stmt|;
name|U32
name|page_length
init|=
name|sat_mode_page_sizes
index|[
name|page_index
index|]
decl_stmt|;
comment|// Find out if the current values are requested or if the default
comment|// values are being requested.
if|if
condition|(
name|page_control
operator|==
name|SCSI_MODE_SENSE_PC_CHANGEABLE
condition|)
block|{
comment|// Copy the changeable mode page information.
name|sati_copy_data
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|page_start
argument_list|,
name|sat_changeable_mode_pages
index|[
name|page_index
index|]
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Copy the default static values template to the user data area.
name|sati_copy_data
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|page_start
argument_list|,
name|sat_default_mode_pages
index|[
name|page_index
index|]
argument_list|,
name|page_length
argument_list|)
expr_stmt|;
block|}
return|return
name|page_length
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method performs the read/write error recovery mode page  *        specific data translation based upon the contents of the remote  *        device IDENTIFY DEVICE data.  *        For more information on the parameters passed to this method,  *        please reference sati_translate_command().  *  * @param[in] identify This parameter specifies the remote device's  *            IDENTIFY DEVICE data received as part of the IO request.  * @param[in] offset This parameter specifies the offset into the data  *            buffer where the translated data is to be written.  *  * @return This method returns the size of the mode page data that was  *         translated.  */
end_comment

begin_function
name|U32
name|sati_mode_sense_read_write_error_translate_data
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|ATA_IDENTIFY_DEVICE_DATA_T
modifier|*
name|identify
parameter_list|,
name|U32
name|offset
parameter_list|)
block|{
name|U8
modifier|*
name|cdb
init|=
name|sati_cb_get_cdb_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
name|U8
name|page_control
init|=
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|2
argument_list|)
operator|>>
name|SCSI_MODE_SENSE_PC_SHIFT
decl_stmt|;
name|U32
name|page_length
decl_stmt|;
name|page_length
operator|=
name|sati_mode_sense_copy_initial_data
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
argument_list|,
name|page_control
argument_list|,
name|SCSI_MODE_PAGE_READ_WRITE_ERROR
argument_list|)
expr_stmt|;
comment|// Currently we do not override any bits in this mode page from the
comment|// identify data.
return|return
name|page_length
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method performs the disconnect/reconnect mode page  *        specific data translation based upon the contents of the remote  *        device IDENTIFY DEVICE data.  *        For more information on the parameters passed to this method,  *        please reference sati_translate_command().  *  * @param[in] identify This parameter specifies the remote device's  *            IDENTIFY DEVICE data received as part of the IO request.  * @param[in] offset This parameter specifies the offset into the data  *            buffer where the translated data is to be written.  *  * @return This method returns the size of the mode page data that was  *         translated.  */
end_comment

begin_function
name|U32
name|sati_mode_sense_disconnect_reconnect_translate_data
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|ATA_IDENTIFY_DEVICE_DATA_T
modifier|*
name|identify
parameter_list|,
name|U32
name|offset
parameter_list|)
block|{
name|U8
modifier|*
name|cdb
init|=
name|sati_cb_get_cdb_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
name|U8
name|page_control
init|=
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|2
argument_list|)
operator|>>
name|SCSI_MODE_SENSE_PC_SHIFT
decl_stmt|;
name|U32
name|page_length
decl_stmt|;
name|page_length
operator|=
name|sati_mode_sense_copy_initial_data
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
argument_list|,
name|page_control
argument_list|,
name|SCSI_MODE_PAGE_DISCONNECT_RECONNECT
argument_list|)
expr_stmt|;
comment|// Currently we do not override any bits in this mode page from the
comment|// identify data.
return|return
name|page_length
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method performs the caching mode page specific data  *        translation based upon the contents of the remote device IDENTIFY  *        DEVICE data.  *        For more information on the parameters passed to this method,  *        please reference sati_translate_command().  *  * @param[in] identify This parameter specifies the remote device's  *            IDENTIFY DEVICE data received as part of the IO request.  * @param[in] offset This parameter specifies the offset into the data  *            buffer where the translated data is to be written.  *  * @return This method returns the size of the mode page data that was  *         translated.  */
end_comment

begin_function
name|U32
name|sati_mode_sense_caching_translate_data
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|ATA_IDENTIFY_DEVICE_DATA_T
modifier|*
name|identify
parameter_list|,
name|U32
name|offset
parameter_list|)
block|{
name|U8
modifier|*
name|cdb
init|=
name|sati_cb_get_cdb_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
name|U8
name|page_control
init|=
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|2
argument_list|)
operator|>>
name|SCSI_MODE_SENSE_PC_SHIFT
decl_stmt|;
name|U32
name|page_length
decl_stmt|;
name|page_length
operator|=
name|sati_mode_sense_copy_initial_data
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
argument_list|,
name|page_control
argument_list|,
name|SCSI_MODE_PAGE_CACHING
argument_list|)
expr_stmt|;
comment|// If the request queried for the current values, then
comment|// we need to translate the data from the IDENTIFY DEVICE request.
if|if
condition|(
name|page_control
operator|==
name|SCSI_MODE_SENSE_PC_CURRENT
condition|)
block|{
name|U8
name|value
decl_stmt|;
comment|// Update the Write Cache Enabled (WCE) bit in the mode page data
comment|// buffer based on the identify response.
if|if
condition|(
operator|(
name|identify
operator|->
name|command_set_enabled0
operator|&
name|ATA_IDENTIFY_DEVICE_WCE_ENABLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|2
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|value
operator||=
name|SCSI_MODE_PAGE_CACHE_PAGE_WCE_BIT
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|2
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|//This byte has been set twice and needs to be decremented
name|sequence
operator|->
name|number_data_bytes_set
operator|--
expr_stmt|;
block|}
comment|// Update the Disable Read Ahead (DRA) bit in the mode page data
comment|// buffer based on the identify response.
if|if
condition|(
operator|(
name|identify
operator|->
name|command_set_enabled0
operator|&
name|ATA_IDENTIFY_DEVICE_RA_ENABLE
operator|)
operator|==
literal|0
condition|)
block|{
comment|// In SATA the polarity of the bits is inverse.
comment|// - SCSI = Disable Read Ahead
comment|// - ATA = Read Ahead
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|12
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|value
operator||=
name|SCSI_MODE_PAGE_CACHE_PAGE_DRA_BIT
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|12
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|//This byte has been set twice, the first time in
comment|//sati_mode_sense_copy_initial_data. number_data_bytes_set
comment|//needs to be decremented
name|sequence
operator|->
name|number_data_bytes_set
operator|--
expr_stmt|;
block|}
block|}
return|return
name|page_length
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method performs the control mode page specific data  *        translation based upon the contents of the remote device  *        IDENTIFY DEVICE data.  *        For more information on the parameters passed to this method,  *        please reference sati_translate_command().  *  * @param[in] identify This parameter specifies the remote device's  *            IDENTIFY DEVICE data received as part of the IO request.  * @param[in] offset This parameter specifies the offset into the data  *            buffer where the translated data is to be written.  *  * @return This method returns the size of the mode page data that was  *         translated.  */
end_comment

begin_function
name|U32
name|sati_mode_sense_control_translate_data
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|ATA_IDENTIFY_DEVICE_DATA_T
modifier|*
name|identify
parameter_list|,
name|U32
name|offset
parameter_list|)
block|{
name|U8
modifier|*
name|cdb
init|=
name|sati_cb_get_cdb_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
name|U8
name|page_control
init|=
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|2
argument_list|)
operator|>>
name|SCSI_MODE_SENSE_PC_SHIFT
decl_stmt|;
name|U32
name|page_length
decl_stmt|;
name|U8
name|value
decl_stmt|;
name|page_length
operator|=
name|sati_mode_sense_copy_initial_data
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
argument_list|,
name|page_control
argument_list|,
name|SCSI_MODE_PAGE_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sequence
operator|->
name|device
operator|->
name|descriptor_sense_enable
condition|)
block|{
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|2
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|2
argument_list|,
name|value
operator||
name|SCSI_MODE_SELECT_MODE_PAGE_D_SENSE
argument_list|)
expr_stmt|;
block|}
return|return
name|page_length
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method performs the informational exceptions control mode  *        page specific data translation based upon the contents of the  *        remote device IDENTIFY DEVICE data.  *        For more information on the parameters passed to this method,  *        please reference sati_translate_command().  *  * @param[in] identify This parameter specifies the remote device's  *            IDENTIFY DEVICE data received as part of the IO request.  * @param[in] offset This parameter specifies the offset into the data  *            buffer where the translated data is to be written.  *  * @return This method returns the size of the mode page data that was  *         translated.  */
end_comment

begin_function
name|U32
name|sati_mode_sense_informational_excp_control_translate_data
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|ATA_IDENTIFY_DEVICE_DATA_T
modifier|*
name|identify
parameter_list|,
name|U32
name|offset
parameter_list|)
block|{
name|U8
modifier|*
name|cdb
init|=
name|sati_cb_get_cdb_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
name|U8
name|page_control
init|=
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|2
argument_list|)
operator|>>
name|SCSI_MODE_SENSE_PC_SHIFT
decl_stmt|;
name|U32
name|page_length
decl_stmt|;
name|page_length
operator|=
name|sati_mode_sense_copy_initial_data
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
argument_list|,
name|page_control
argument_list|,
name|SCSI_MODE_PAGE_INFORMATIONAL_EXCP_CONTROL
argument_list|)
expr_stmt|;
comment|// If the request queried for the current values, then
comment|// we need to translate the data from the IDENTIFY DEVICE request.
if|if
condition|(
name|page_control
operator|==
name|SCSI_MODE_SENSE_PC_CURRENT
condition|)
block|{
name|U8
name|value
decl_stmt|;
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|2
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|// Determine if the SMART feature set is supported and enabled.
if|if
condition|(
operator|(
name|identify
operator|->
name|command_set_supported0
operator|&
name|ATA_IDENTIFY_COMMAND_SET_SUPPORTED0_SMART_ENABLE
operator|)
operator|&&
operator|(
name|identify
operator|->
name|command_set_enabled0
operator|&
name|ATA_IDENTIFY_COMMAND_SET_ENABLED0_SMART_ENABLE
operator|)
condition|)
block|{
comment|// Clear the DXCPT field since the SMART feature is supported/enabled.
name|value
operator|&=
operator|~
name|SCSI_MODE_PAGE_INFORMATIONAL_EXCP_DXCPT_ENABLE
expr_stmt|;
block|}
else|else
block|{
comment|// Set the Disable Exception Control (DXCPT) field since the SMART
comment|// feature is not supported or enabled.
name|value
operator||=
name|SCSI_MODE_PAGE_INFORMATIONAL_EXCP_DXCPT_ENABLE
expr_stmt|;
block|}
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|2
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|//This byte has been set twice, the first time in
comment|//sati_mode_sense_copy_initial_data. number_data_bytes_set
comment|//needs to be decremented
name|sequence
operator|->
name|number_data_bytes_set
operator|--
expr_stmt|;
block|}
return|return
name|page_length
return|;
block|}
end_function

begin_comment
comment|/** * @brief This method performs the Power Condition mode page *        specific data translation based upon the contents of the *        remote device IDENTIFY DEVICE data. *        For more information on the parameters passed to this method, *        please reference sati_translate_command(). * * @param[in] identify This parameter specifies the remote device's *            IDENTIFY DEVICE data received as part of the IO request. * @param[in] offset This parameter specifies the offset into the data *            buffer where the translated data is to be written. * * @return This method returns the size of the mode page data that was *         translated. */
end_comment

begin_function
name|U32
name|sati_mode_sense_power_condition_translate_data
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|ATA_IDENTIFY_DEVICE_DATA_T
modifier|*
name|identify
parameter_list|,
name|U32
name|offset
parameter_list|)
block|{
name|U8
modifier|*
name|cdb
init|=
name|sati_cb_get_cdb_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
name|U8
name|page_control
init|=
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|2
argument_list|)
operator|>>
name|SCSI_MODE_SENSE_PC_SHIFT
decl_stmt|;
name|U8
name|ata_sb_timer
decl_stmt|;
comment|//Represents tenths of seconds
name|U32
name|standby_timer
init|=
literal|0x00000000
decl_stmt|;
name|U8
name|standby_enabled
init|=
name|STANDBY_TIMER_DISABLED
decl_stmt|;
if|if
condition|(
operator|(
name|page_control
operator|==
name|SCSI_MODE_SENSE_PC_CURRENT
operator|)
operator|&&
operator|(
name|identify
operator|->
name|capabilities1
operator|&
name|STANDBY_TIMER_SUPPORTED
operator|)
condition|)
block|{
name|standby_enabled
operator|=
name|STANDBY_TIMER_ENABLED
expr_stmt|;
name|ata_sb_timer
operator|=
name|sequence
operator|->
name|device
operator|->
name|ata_standby_timer
expr_stmt|;
comment|//converting ATA timer values into SCSI timer values
if|if
condition|(
name|ata_sb_timer
operator|<=
literal|0xF0
condition|)
block|{
name|standby_timer
operator|=
name|ata_sb_timer
operator|*
literal|50
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ata_sb_timer
operator|<=
literal|0xFB
condition|)
block|{
name|standby_timer
operator|=
operator|(
operator|(
name|ata_sb_timer
operator|-
literal|240
operator|)
operator|*
literal|18000
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ata_sb_timer
operator|==
literal|0xFC
condition|)
block|{
name|standby_timer
operator|=
literal|12600
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ata_sb_timer
operator|==
literal|0xFD
condition|)
block|{
name|standby_timer
operator|=
literal|432000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ata_sb_timer
operator|==
literal|0xFF
condition|)
block|{
name|standby_timer
operator|=
literal|12750
expr_stmt|;
block|}
else|else
block|{
name|standby_timer
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
block|}
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
argument_list|,
name|SCSI_MODE_PAGE_POWER_CONDITION
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|1
argument_list|,
operator|(
name|SCSI_MODE_PAGE_1A_LENGTH
operator|-
literal|2
operator|)
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|2
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|3
argument_list|,
name|standby_enabled
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|4
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|5
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|6
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|7
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|8
argument_list|,
call|(
name|U8
call|)
argument_list|(
name|standby_timer
operator|>>
literal|24
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|9
argument_list|,
call|(
name|U8
call|)
argument_list|(
name|standby_timer
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|10
argument_list|,
call|(
name|U8
call|)
argument_list|(
name|standby_timer
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|offset
operator|+
literal|11
argument_list|,
operator|(
name|U8
operator|)
name|standby_timer
argument_list|)
expr_stmt|;
return|return
name|SCSI_MODE_PAGE_1A_LENGTH
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method performs the all pages mode page specific data  *        translation based upon the contents of the remote device  *        IDENTIFY DEVICE data.  The ALL PAGES mode sense request asks  *        for all of mode pages and sub-pages in a single page.  *        The mode pages are added in ascending order.  *        For more information on the parameters passed to this method,  *        please reference sati_translate_command().  *  * @param[in] identify This parameter specifies the remote device's  *            IDENTIFY DEVICE data received as part of the IO request.  * @param[in] offset This parameter specifies the offset into the data  *            buffer where the translated data is to be written.  *  * @return This method returns the size of the mode page data that was  *         translated.  */
end_comment

begin_function
name|U32
name|sati_mode_sense_all_pages_translate_data
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|ATA_IDENTIFY_DEVICE_DATA_T
modifier|*
name|identify
parameter_list|,
name|U32
name|offset
parameter_list|)
block|{
name|offset
operator|+=
name|sati_mode_sense_read_write_error_translate_data
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|identify
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|sati_mode_sense_disconnect_reconnect_translate_data
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|identify
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|sati_mode_sense_caching_translate_data
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|identify
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|sati_mode_sense_control_translate_data
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|identify
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|sati_mode_sense_informational_excp_control_translate_data
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|identify
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !defined(DISABLE_SATI_MODE_SENSE)
end_comment

end_unit

