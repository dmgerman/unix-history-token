begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  *  * @brief This file contains the implementation of the SCIF_SAS_CONTROLLER  *        object.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_status.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_user_callback.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_user_callback.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_library.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_logger.h>
end_include

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* P U B L I C   M E T H O D S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_function
name|SCI_STATUS
name|scif_controller_construct
parameter_list|(
name|SCI_LIBRARY_HANDLE_T
name|library
parameter_list|,
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|void
modifier|*
name|user_object
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|SCIF_SAS_LIBRARY_T
modifier|*
name|fw_library
init|=
operator|(
name|SCIF_SAS_LIBRARY_T
operator|*
operator|)
name|library
decl_stmt|;
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
comment|// Validate the user supplied parameters.
if|if
condition|(
operator|(
name|library
operator|==
name|SCI_INVALID_HANDLE
operator|)
operator|||
operator|(
name|controller
operator|==
name|SCI_INVALID_HANDLE
operator|)
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|library
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_INITIALIZATION
operator|,
literal|"scif_controller_construct(0x%x, 0x%x) enter\n"
operator|,
name|library
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
comment|// Construct the base controller.  As part of constructing the base
comment|// controller we ask it to also manage the MDL iteration for the Core.
name|sci_base_controller_construct
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
argument_list|,
name|sci_base_object_get_logger
argument_list|(
name|fw_library
argument_list|)
argument_list|,
name|scif_sas_controller_state_table
argument_list|,
name|fw_controller
operator|->
name|mdes
argument_list|,
name|SCIF_SAS_MAX_MEMORY_DESCRIPTORS
argument_list|,
name|sci_controller_get_memory_descriptor_list_handle
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|)
argument_list|)
expr_stmt|;
name|scif_sas_controller_initialize_state_logging
argument_list|(
name|fw_controller
argument_list|)
expr_stmt|;
name|sci_object_set_association
argument_list|(
name|fw_controller
argument_list|,
name|user_object
argument_list|)
expr_stmt|;
name|status
operator|=
name|scic_controller_construct
argument_list|(
name|fw_library
operator|->
name|core_object
argument_list|,
name|fw_controller
operator|->
name|core_object
argument_list|,
name|fw_controller
argument_list|)
expr_stmt|;
comment|// If the core controller was successfully constructed, then
comment|// finish construction of the framework controller.
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// Set the association in the core controller to this framework
comment|// controller.
name|sci_object_set_association
argument_list|(
operator|(
name|SCI_OBJECT_HANDLE_T
operator|)
name|fw_controller
operator|->
name|core_object
argument_list|,
name|fw_controller
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_RESET
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scif_controller_initialize
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
comment|// Validate the user supplied parameters.
if|if
condition|(
name|controller
operator|==
name|SCI_INVALID_HANDLE
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_INITIALIZATION
operator|,
literal|"scif_controller_initialize(0x%x) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
return|return
name|fw_controller
operator|->
name|state_handlers
operator|->
name|initialize_handler
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|U32
name|scif_controller_get_suggested_start_timeout
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
comment|// Validate the user supplied parameters.
if|if
condition|(
name|controller
operator|==
name|SCI_INVALID_HANDLE
condition|)
return|return
literal|0
return|;
comment|// Currently we aren't adding any additional time into the suggested
comment|// timeout value for the start operation.  Simply utilize the core
comment|// value.
return|return
name|scic_controller_get_suggested_start_timeout
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scif_controller_start
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U32
name|timeout
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
comment|// Validate the user supplied parameters.
if|if
condition|(
name|controller
operator|==
name|SCI_INVALID_HANDLE
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_INITIALIZATION
operator|,
literal|"scif_controller_start(0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|timeout
operator|)
argument_list|)
expr_stmt|;
return|return
name|fw_controller
operator|->
name|state_handlers
operator|->
name|start_handler
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
argument_list|,
name|timeout
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scif_controller_stop
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U32
name|timeout
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
comment|// Validate the user supplied parameters.
if|if
condition|(
name|controller
operator|==
name|SCI_INVALID_HANDLE
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_SHUTDOWN
operator|,
literal|"scif_controller_stop(0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|timeout
operator|)
argument_list|)
expr_stmt|;
return|return
name|fw_controller
operator|->
name|state_handlers
operator|->
name|stop_handler
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
argument_list|,
name|timeout
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scif_controller_reset
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
comment|// Validate the user supplied parameters.
if|if
condition|(
name|controller
operator|==
name|SCI_INVALID_HANDLE
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_CONTROLLER_RESET
operator|,
literal|"scif_controller_reset(0x%x) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
return|return
name|fw_controller
operator|->
name|state_handlers
operator|->
name|reset_handler
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_CONTROLLER_HANDLE_T
name|scif_controller_get_scic_handle
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
return|return
name|fw_controller
operator|->
name|core_object
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_IO_STATUS
name|scif_controller_start_io
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_REMOTE_DEVICE_HANDLE_T
name|remote_device
parameter_list|,
name|SCI_IO_REQUEST_HANDLE_T
name|io_request
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_controller_start_io(0x%x, 0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|io_request
operator|,
name|io_tag
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sci_pool_empty
argument_list|(
name|fw_controller
operator|->
name|hprq
operator|.
name|pool
argument_list|)
operator|||
name|scif_sas_controller_sufficient_resource
argument_list|(
name|controller
argument_list|)
condition|)
block|{
name|status
operator|=
name|fw_controller
operator|->
name|state_handlers
operator|->
name|start_io_handler
argument_list|(
operator|(
name|SCI_BASE_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|,
operator|(
name|SCI_BASE_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
argument_list|,
operator|(
name|SCI_BASE_REQUEST_T
operator|*
operator|)
name|io_request
argument_list|,
name|io_tag
argument_list|)
expr_stmt|;
block|}
else|else
name|status
operator|=
name|SCI_FAILURE_INSUFFICIENT_RESOURCES
expr_stmt|;
return|return
operator|(
name|SCI_IO_STATUS
operator|)
name|status
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_TASK_STATUS
name|scif_controller_start_task
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_REMOTE_DEVICE_HANDLE_T
name|remote_device
parameter_list|,
name|SCI_TASK_REQUEST_HANDLE_T
name|task_request
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
comment|// Validate the user supplied parameters.
if|if
condition|(
operator|(
name|controller
operator|==
name|SCI_INVALID_HANDLE
operator|)
operator|||
operator|(
name|remote_device
operator|==
name|SCI_INVALID_HANDLE
operator|)
operator|||
operator|(
name|task_request
operator|==
name|SCI_INVALID_HANDLE
operator|)
condition|)
block|{
return|return
name|SCI_TASK_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_TASK_MANAGEMENT
operator|,
literal|"scif_controller_start_task(0x%x, 0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|task_request
operator|,
name|io_tag
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scif_sas_controller_sufficient_resource
argument_list|(
name|controller
argument_list|)
condition|)
block|{
name|status
operator|=
name|fw_controller
operator|->
name|state_handlers
operator|->
name|start_task_handler
argument_list|(
operator|(
name|SCI_BASE_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|,
operator|(
name|SCI_BASE_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
argument_list|,
operator|(
name|SCI_BASE_REQUEST_T
operator|*
operator|)
name|task_request
argument_list|,
name|io_tag
argument_list|)
expr_stmt|;
block|}
else|else
name|status
operator|=
name|SCI_FAILURE_INSUFFICIENT_RESOURCES
expr_stmt|;
return|return
operator|(
name|SCI_TASK_STATUS
operator|)
name|status
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scif_controller_complete_io
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_REMOTE_DEVICE_HANDLE_T
name|remote_device
parameter_list|,
name|SCI_IO_REQUEST_HANDLE_T
name|io_request
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_controller_complete_io(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|io_request
operator|)
argument_list|)
expr_stmt|;
return|return
name|fw_controller
operator|->
name|state_handlers
operator|->
name|complete_io_handler
argument_list|(
operator|(
name|SCI_BASE_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|,
operator|(
name|SCI_BASE_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
argument_list|,
operator|(
name|SCI_BASE_REQUEST_T
operator|*
operator|)
name|io_request
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scif_controller_complete_task
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_REMOTE_DEVICE_HANDLE_T
name|remote_device
parameter_list|,
name|SCI_TASK_REQUEST_HANDLE_T
name|task_request
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
comment|// Validate the user supplied parameters.
if|if
condition|(
operator|(
name|controller
operator|==
name|SCI_INVALID_HANDLE
operator|)
operator|||
operator|(
name|remote_device
operator|==
name|SCI_INVALID_HANDLE
operator|)
operator|||
operator|(
name|task_request
operator|==
name|SCI_INVALID_HANDLE
operator|)
condition|)
block|{
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_TASK_MANAGEMENT
operator|,
literal|"scif_controller_complete_task(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|task_request
operator|)
argument_list|)
expr_stmt|;
return|return
name|fw_controller
operator|->
name|state_handlers
operator|->
name|complete_task_handler
argument_list|(
operator|(
name|SCI_BASE_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|,
operator|(
name|SCI_BASE_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
argument_list|,
operator|(
name|SCI_BASE_REQUEST_T
operator|*
operator|)
name|task_request
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scif_controller_get_domain_handle
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U8
name|port_index
parameter_list|,
name|SCI_DOMAIN_HANDLE_T
modifier|*
name|domain_handle
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
comment|// Validate the user supplied parameters.
if|if
condition|(
name|controller
operator|==
name|SCI_INVALID_HANDLE
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
comment|// Retrieve the domain handle if the supplied index is legitimate.
if|if
condition|(
name|port_index
operator|<
name|SCI_MAX_PORTS
condition|)
block|{
operator|*
name|domain_handle
operator|=
operator|&
name|fw_controller
operator|->
name|domains
index|[
name|port_index
index|]
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
return|return
name|SCI_FAILURE_INVALID_PORT
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method builds the memory descriptor list for this  *        controller.  *  * @param[in] fw_controller This parameter specifies the framework  *            controller object for which to build the MDL.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_controller_build_mdl
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
comment|// one internal request for each domain.
name|sci_base_mde_construct
argument_list|(
operator|&
name|fw_controller
operator|->
name|mdes
index|[
name|SCIF_SAS_MDE_INTERNAL_IO
index|]
argument_list|,
literal|4
argument_list|,
name|fw_controller
operator|->
name|internal_request_entries
operator|*
name|scif_sas_internal_request_get_object_size
argument_list|()
argument_list|,
name|SCI_MDE_ATTRIBUTE_PHYSICALLY_CONTIGUOUS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scif_controller_set_mode
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_CONTROLLER_MODE
name|mode
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
if|if
condition|(
operator|(
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_CONTROLLER_STATE_INITIALIZING
operator|)
operator|||
operator|(
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_CONTROLLER_STATE_INITIALIZED
operator|)
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SCI_MODE_SPEED
case|:
name|fw_controller
operator|->
name|internal_request_entries
operator|=
name|MIN
argument_list|(
name|fw_controller
operator|->
name|internal_request_entries
argument_list|,
name|SCIF_SAS_MAX_INTERNAL_REQUEST_COUNT
argument_list|)
expr_stmt|;
name|scif_sas_controller_build_mdl
argument_list|(
name|fw_controller
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCI_MODE_SIZE
case|:
name|fw_controller
operator|->
name|internal_request_entries
operator|=
name|MIN
argument_list|(
name|fw_controller
operator|->
name|internal_request_entries
argument_list|,
name|SCIF_SAS_MIN_INTERNAL_REQUEST_COUNT
argument_list|)
expr_stmt|;
name|scif_sas_controller_build_mdl
argument_list|(
name|fw_controller
argument_list|)
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
expr_stmt|;
break|break;
block|}
block|}
else|else
name|status
operator|=
name|SCI_FAILURE_INVALID_STATE
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
return|return
name|status
return|;
block|}
else|else
block|{
comment|// Currently, the framework doesn't change any configurations for
comment|// speed or size modes.  Default to speed mode basically.
return|return
name|scic_controller_set_mode
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
name|mode
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|U32
name|scif_controller_get_sat_compliance_version
parameter_list|(
name|void
parameter_list|)
block|{
comment|/// @todo Fix return of SAT compliance version.
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|U32
name|scif_controller_get_sat_compliance_version_revision
parameter_list|(
name|void
parameter_list|)
block|{
comment|/// @todo Fix return of SAT compliance revision.
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scif_user_parameters_set
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCIF_USER_PARAMETERS_T
modifier|*
name|scif_parms
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
comment|//validate all the registry entries before overwriting the default parameter
comment|//values.
if|if
condition|(
name|scif_parms
operator|->
name|sas
operator|.
name|is_sata_ncq_enabled
operator|!=
literal|1
operator|&&
name|scif_parms
operator|->
name|sas
operator|.
name|is_sata_ncq_enabled
operator|!=
literal|0
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
if|if
condition|(
name|scif_parms
operator|->
name|sas
operator|.
name|max_ncq_depth
operator|<
literal|1
operator|&&
name|scif_parms
operator|->
name|sas
operator|.
name|max_ncq_depth
operator|>
literal|32
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
if|if
condition|(
name|scif_parms
operator|->
name|sas
operator|.
name|is_sata_standby_timer_enabled
operator|!=
literal|1
operator|&&
name|scif_parms
operator|->
name|sas
operator|.
name|is_sata_standby_timer_enabled
operator|!=
literal|0
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
if|if
condition|(
name|scif_parms
operator|->
name|sas
operator|.
name|is_non_zero_buffer_offsets_enabled
operator|!=
literal|1
operator|&&
name|scif_parms
operator|->
name|sas
operator|.
name|is_non_zero_buffer_offsets_enabled
operator|!=
literal|0
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
if|if
condition|(
name|scif_parms
operator|->
name|sas
operator|.
name|reset_type
operator|!=
name|SCI_SAS_ABORT_TASK
operator|&&
name|scif_parms
operator|->
name|sas
operator|.
name|reset_type
operator|!=
name|SCI_SAS_ABORT_TASK_SET
operator|&&
name|scif_parms
operator|->
name|sas
operator|.
name|reset_type
operator|!=
name|SCI_SAS_CLEAR_TASK_SET
operator|&&
name|scif_parms
operator|->
name|sas
operator|.
name|reset_type
operator|!=
name|SCI_SAS_LOGICAL_UNIT_RESET
operator|&&
name|scif_parms
operator|->
name|sas
operator|.
name|reset_type
operator|!=
name|SCI_SAS_I_T_NEXUS_RESET
operator|&&
name|scif_parms
operator|->
name|sas
operator|.
name|reset_type
operator|!=
name|SCI_SAS_CLEAR_ACA
operator|&&
name|scif_parms
operator|->
name|sas
operator|.
name|reset_type
operator|!=
name|SCI_SAS_QUERY_TASK
operator|&&
name|scif_parms
operator|->
name|sas
operator|.
name|reset_type
operator|!=
name|SCI_SAS_QUERY_TASK_SET
operator|&&
name|scif_parms
operator|->
name|sas
operator|.
name|reset_type
operator|!=
name|SCI_SAS_QUERY_ASYNCHRONOUS_EVENT
operator|&&
name|scif_parms
operator|->
name|sas
operator|.
name|reset_type
operator|!=
name|SCI_SAS_HARD_RESET
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
if|if
condition|(
name|scif_parms
operator|->
name|sas
operator|.
name|clear_affiliation_during_controller_stop
operator|!=
literal|1
operator|&&
name|scif_parms
operator|->
name|sas
operator|.
name|clear_affiliation_during_controller_stop
operator|!=
literal|0
condition|)
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
name|memcpy
argument_list|(
operator|(
operator|&
name|fw_controller
operator|->
name|user_parameters
operator|)
argument_list|,
name|scif_parms
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scif_parms
argument_list|)
argument_list|)
expr_stmt|;
comment|// In the future more could be done to prevent setting parameters at the
comment|// wrong time, but for now we'll simply set the values even if it is too
comment|// late for them to take affect.
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_INTERRUPTS
argument_list|)
end_if

begin_comment
comment|/**  * @brief This routine check each domain of the controller to see if  *           any domain is overriding interrupt coalescence.  *  * @param[in] fw_controller frame controller  * @param[in] fw_smp_phy The smp phy to be freed.  *  * @return none  */
end_comment

begin_function
specifier|static
name|BOOL
name|scif_sas_controller_is_overriding_interrupt_coalescence
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|U8
name|index
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_DOMAINS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|fw_controller
operator|->
name|domains
index|[
name|index
index|]
operator|.
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_DOMAIN_STATE_DISCOVERING
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|SCI_STATUS
name|scif_controller_set_interrupt_coalescence
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U32
name|coalesce_number
parameter_list|,
name|U32
name|coalesce_timeout
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
comment|///when framework is in the middle of temporarily overriding the interrupt
comment|///coalescence values, user's request of setting interrupt coalescence
comment|///will be saved. As soon as the framework done the temporary overriding,
comment|///it will serve user's request to set new interrupt coalescence.
if|if
condition|(
name|scif_sas_controller_is_overriding_interrupt_coalescence
argument_list|(
name|fw_controller
argument_list|)
condition|)
block|{
name|U32
name|curr_coalesce_number
decl_stmt|;
name|U32
name|curr_coalesce_timeout
decl_stmt|;
name|SCI_STATUS
name|core_status
decl_stmt|;
comment|// save current interrupt coalescence info.
name|scic_controller_get_interrupt_coalescence
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
operator|&
name|curr_coalesce_number
argument_list|,
operator|&
name|curr_coalesce_timeout
argument_list|)
expr_stmt|;
comment|//try user's request out in the core, but immediately restore core's
comment|//current setting.
name|core_status
operator|=
name|scic_controller_set_interrupt_coalescence
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
name|coalesce_number
argument_list|,
name|coalesce_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_status
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|fw_controller
operator|->
name|saved_interrupt_coalesce_number
operator|=
operator|(
name|U16
operator|)
name|coalesce_number
expr_stmt|;
name|fw_controller
operator|->
name|saved_interrupt_coalesce_timeout
operator|=
name|coalesce_timeout
expr_stmt|;
block|}
comment|//restore current interrupt coalescence.
name|scic_controller_set_interrupt_coalescence
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
name|curr_coalesce_number
argument_list|,
name|curr_coalesce_timeout
argument_list|)
expr_stmt|;
return|return
name|core_status
return|;
block|}
else|else
block|{
comment|///If framework is not internally overriding the interrupt coalescence,
comment|///serve user's request immediately by passing the reqeust to core.
return|return
name|scic_controller_set_interrupt_coalescence
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
name|coalesce_number
argument_list|,
name|coalesce_timeout
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scif_controller_get_interrupt_coalescence
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|U32
modifier|*
name|coalesce_number
parameter_list|,
name|U32
modifier|*
name|coalesce_timeout
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|scif_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|scic_controller_get_interrupt_coalescence
argument_list|(
name|scif_controller
operator|->
name|core_object
argument_list|,
name|coalesce_number
argument_list|,
name|coalesce_timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will save the interrupt coalescence values.  If  *        the interrupt coalescence values have already been saved,  *        then this method performs no operations.  *  * @param[in,out] fw_controller This parameter specifies the controller  *                for which to save the interrupt coalescence values.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_controller_save_interrupt_coalescence
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
if|if
condition|(
operator|!
name|scif_sas_controller_is_overriding_interrupt_coalescence
argument_list|(
name|fw_controller
argument_list|)
condition|)
block|{
comment|// Override core's interrupt coalescing settings during SMP
comment|// DISCOVER process cause' there is only 1 outstanding SMP
comment|// request per domain is allowed.
name|scic_controller_get_interrupt_coalescence
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
operator|(
name|U32
operator|*
operator|)
operator|&
operator|(
name|fw_controller
operator|->
name|saved_interrupt_coalesce_number
operator|)
argument_list|,
operator|&
operator|(
name|fw_controller
operator|->
name|saved_interrupt_coalesce_timeout
operator|)
argument_list|)
expr_stmt|;
comment|// Temporarily disable the interrupt coalescing.
name|scic_controller_set_interrupt_coalescence
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method will restore the interrupt coalescence values.  If  *        the interrupt coalescence values have not already been saved,  *        then this method performs no operations.  *  * @param[in,out] fw_controller This parameter specifies the controller  *                for which to restore the interrupt coalescence values.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_controller_restore_interrupt_coalescence
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
if|if
condition|(
operator|!
name|scif_sas_controller_is_overriding_interrupt_coalescence
argument_list|(
name|fw_controller
argument_list|)
condition|)
name|scic_controller_set_interrupt_coalescence
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
name|fw_controller
operator|->
name|saved_interrupt_coalesce_number
argument_list|,
name|fw_controller
operator|->
name|saved_interrupt_coalesce_timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !defined(DISABLE_INTERRUPTS)
end_comment

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_cb_controller_start_complete
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_STATUS
name|completion_status
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|controller
argument_list|)
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_INITIALIZATION
operator|,
literal|"scic_cb_controller_start_complete(0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|completion_status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|completion_status
operator|==
name|SCI_SUCCESS
operator|||
name|completion_status
operator|==
name|SCI_FAILURE_TIMEOUT
condition|)
block|{
comment|// Even the initialization of the core controller timed out, framework
comment|// controller should still transit to READY state.
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_READY
argument_list|)
expr_stmt|;
block|}
name|scif_cb_controller_start_complete
argument_list|(
name|fw_controller
argument_list|,
name|completion_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_cb_controller_stop_complete
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_STATUS
name|completion_status
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|controller
argument_list|)
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_SHUTDOWN
operator|,
literal|"scic_cb_controller_stop_complete(0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|completion_status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|completion_status
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_STOPPED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_FAILED
argument_list|)
expr_stmt|;
block|}
name|scif_cb_controller_stop_complete
argument_list|(
name|fw_controller
argument_list|,
name|completion_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_cb_controller_error
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_CONTROLLER_ERROR
name|error
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|controller
argument_list|)
decl_stmt|;
name|fw_controller
operator|->
name|parent
operator|.
name|error
operator|=
name|error
expr_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_SHUTDOWN
operator|,
literal|"scic_cb_controller_not_ready(0x%x) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_FAILED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* P R O T E C T E D    M E T H O D S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method is utilized to continue an internal IO operation  *        on the controller.  This method is utilized for SAT translated  *        requests that generate multiple ATA commands in order to fulfill  *        the original SCSI request.  *  * @param[in]  controller This parameter specifies the controller on which  *             to continue an internal IO request.  * @param[in]  remote_device This parameter specifies the remote device  *             on which to continue an internal IO request.  * @param[in]  io_request This parameter specifies the IO request to be  *             continue.  *  * @return Indicate if the continue operation was successful.  * @retval SCI_SUCCESS This value is returned if the operation succeeded.  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_controller_continue_io
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_REMOTE_DEVICE_HANDLE_T
name|remote_device
parameter_list|,
name|SCI_IO_REQUEST_HANDLE_T
name|io_request
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
return|return
name|fw_controller
operator|->
name|state_handlers
operator|->
name|continue_io_handler
argument_list|(
operator|(
name|SCI_BASE_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|,
operator|(
name|SCI_BASE_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
argument_list|,
operator|(
name|SCI_BASE_REQUEST_T
operator|*
operator|)
name|io_request
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will attempt to destruct a framework controller.  *        This includes free any resources retreived from the user (e.g.  *        timers).  *  * @param[in]  fw_controller This parameter specifies the framework  *             controller to destructed.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_controller_destruct
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_SHUTDOWN
operator|,
literal|"scif_sas_controller_destruct(0x%x) enter\n"
operator|,
name|fw_controller
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//-----------------------------------------------------------------------------
end_comment

begin_comment
comment|// INTERNAL REQUEST RELATED METHODS
end_comment

begin_comment
comment|//-----------------------------------------------------------------------------
end_comment

begin_comment
comment|/**  * @brief This routine is to allocate the memory for creating a new internal  *        request.  *  * @param[in] scif_controller handle to frame controller  *  * @return void* address to internal request memory  */
end_comment

begin_function
name|void
modifier|*
name|scif_sas_controller_allocate_internal_request
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|POINTER_UINT
name|internal_io_address
decl_stmt|;
if|if
condition|(
operator|!
name|sci_pool_empty
argument_list|(
name|fw_controller
operator|->
name|internal_request_memory_pool
argument_list|)
condition|)
block|{
name|sci_pool_get
argument_list|(
name|fw_controller
operator|->
name|internal_request_memory_pool
argument_list|,
name|internal_io_address
argument_list|)
expr_stmt|;
comment|//clean the memory.
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|internal_io_address
argument_list|,
literal|0
argument_list|,
name|scif_sas_internal_request_get_object_size
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|internal_io_address
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This routine is to free the memory for a completed internal request.  *  * @param[in] scif_controller handle to frame controller  * @param[in] fw_internal_io The internal IO to be freed.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_controller_free_internal_request
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|,
name|void
modifier|*
name|fw_internal_request_buffer
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_controller_free_internal_request(0x%x, 0x%x) enter\n"
operator|,
name|fw_controller
operator|,
name|fw_internal_request_buffer
operator|)
argument_list|)
expr_stmt|;
comment|//return the memory to to pool.
if|if
condition|(
operator|!
name|sci_pool_full
argument_list|(
name|fw_controller
operator|->
name|internal_request_memory_pool
argument_list|)
condition|)
block|{
name|sci_pool_put
argument_list|(
name|fw_controller
operator|->
name|internal_request_memory_pool
argument_list|,
operator|(
name|POINTER_UINT
operator|)
name|fw_internal_request_buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief this routine is called by OS' DPC to start io requests from internal  *        high priority request queue  * @param[in] fw_controller The framework controller.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_controller_start_high_priority_io
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|POINTER_UINT
name|io_address
decl_stmt|;
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_controller_start_high_priority_io(0x%x) enter\n"
operator|,
name|fw_controller
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|sci_pool_empty
argument_list|(
name|fw_controller
operator|->
name|hprq
operator|.
name|pool
argument_list|)
condition|)
block|{
name|sci_pool_get
argument_list|(
name|fw_controller
operator|->
name|hprq
operator|.
name|pool
argument_list|,
name|io_address
argument_list|)
expr_stmt|;
name|fw_io
operator|=
operator|(
name|SCIF_SAS_IO_REQUEST_T
operator|*
operator|)
name|io_address
expr_stmt|;
name|status
operator|=
name|fw_controller
operator|->
name|state_handlers
operator|->
name|start_high_priority_io_handler
argument_list|(
operator|(
name|SCI_BASE_CONTROLLER_T
operator|*
operator|)
name|fw_controller
argument_list|,
operator|(
name|SCI_BASE_REMOTE_DEVICE_T
operator|*
operator|)
name|fw_io
operator|->
name|parent
operator|.
name|device
argument_list|,
operator|(
name|SCI_BASE_REQUEST_T
operator|*
operator|)
name|fw_io
argument_list|,
name|SCI_CONTROLLER_INVALID_IO_TAG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method will check how many outstanding IOs currently and number  * of IOs in high priority queue, if the overall number exceeds the max_tc,  * return FALSE.  *  * @param[in] fw_controller The framework controller.  *  * @return BOOL Indicate whether there is sufficient resource to start an IO.  * @retvalue TRUE The controller has sufficient resource.  * @retvalue FALSE There is not sufficient resource available.  */
end_comment

begin_function
name|BOOL
name|scif_sas_controller_sufficient_resource
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
decl_stmt|;
name|U32
name|domain_index
decl_stmt|;
name|U32
name|outstanding_io_count
init|=
literal|0
decl_stmt|;
name|U32
name|high_priority_io_count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|domain_index
operator|=
literal|0
init|;
name|domain_index
operator|<
name|SCI_MAX_DOMAINS
condition|;
name|domain_index
operator|++
control|)
block|{
name|fw_domain
operator|=
operator|&
name|fw_controller
operator|->
name|domains
index|[
name|domain_index
index|]
expr_stmt|;
name|outstanding_io_count
operator|+=
name|fw_domain
operator|->
name|request_list
operator|.
name|element_count
expr_stmt|;
block|}
name|high_priority_io_count
operator|=
name|sci_pool_count
argument_list|(
name|fw_controller
operator|->
name|hprq
operator|.
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|outstanding_io_count
operator|+
name|high_priority_io_count
operator|)
operator|>
name|SCI_MAX_IO_REQUESTS
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method is the starting point to complete high prority io for a  *        controller then down to domain, device.  *  * @param[in] fw_controller The framework controller  * @param[in] remote_device  The framework remote device.  * @param[in] io_request The high priority io request to be completed.  *  * @return SCI_STATUS indicate the completion status from framework down to the  *         core.  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_controller_complete_high_priority_io
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|,
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCIF_SAS_REQUEST_T
modifier|*
name|io_request
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_sas_controller_complete_high_priority_io(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|fw_controller
operator|,
name|remote_device
operator|,
name|io_request
operator|)
argument_list|)
expr_stmt|;
comment|//call controller's new added complete_high_priority_io_handler
return|return
name|fw_controller
operator|->
name|state_handlers
operator|->
name|complete_high_priority_io_handler
argument_list|(
operator|(
name|SCI_BASE_CONTROLLER_T
operator|*
operator|)
name|fw_controller
argument_list|,
operator|(
name|SCI_BASE_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
argument_list|,
operator|(
name|SCI_BASE_REQUEST_T
operator|*
operator|)
name|io_request
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**   * @brief This routine is to allocate the memory for creating a smp phy object.  *  * @param[in] scif_controller handle to frame controller  *  * @return SCIF_SAS_SMP_PHY_T * An allocated space for smp phy. If failed to allocate,  *            return NULL.  */
end_comment

begin_function
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|scif_sas_controller_allocate_smp_phy
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|smp_phy
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"scif_controller_allocate_smp_phy(0x%x) enter\n"
operator|,
name|fw_controller
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sci_fast_list_is_empty
argument_list|(
operator|&
name|fw_controller
operator|->
name|smp_phy_memory_list
argument_list|)
condition|)
block|{
name|smp_phy
operator|=
operator|(
name|SCIF_SAS_SMP_PHY_T
operator|*
operator|)
name|sci_fast_list_remove_head
argument_list|(
operator|&
name|fw_controller
operator|->
name|smp_phy_memory_list
argument_list|)
expr_stmt|;
comment|//clean the memory.
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|smp_phy
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SCIF_SAS_SMP_PHY_T
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|smp_phy
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This routine is to free the memory for a released smp phy.  *  * @param[in] fw_controller The framework controller, a smp phy is released  *                to its memory.  * @param[in] fw_smp_phy The smp phy to be freed.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_controller_free_smp_phy
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|,
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|smp_phy
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"scif_controller_free_smp_phy(0x%x, 0x%x) enter\n"
operator|,
name|fw_controller
operator|,
name|smp_phy
operator|)
argument_list|)
expr_stmt|;
comment|//return the memory to the list.
name|sci_fast_list_insert_tail
argument_list|(
operator|&
name|fw_controller
operator|->
name|smp_phy_memory_list
argument_list|,
operator|&
name|smp_phy
operator|->
name|list_element
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method clear affiliation for all the EA SATA devices associated  *        to this controller.  *  * @param[in] fw_controller This parameter specifies the framework  *            controller object for whose remote devices are to be stopped.  *  * @return This method returns a value indicating if the operation completed.  * @retval SCI_COMPLETE This value indicates that all the EA SATA devices'  *         affiliation was cleared.  * @retval SCI_INCOMPLETE This value indicates clear affiliation activity is  *         yet to be completed.  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_controller_clear_affiliation
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|U8
name|index
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"scif_sas_controller_clear_affiliation(0x%x) enter\n"
operator|,
name|fw_controller
operator|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|fw_controller
operator|->
name|current_domain_to_clear_affiliation
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|SCI_MAX_DOMAINS
condition|)
block|{
name|fw_domain
operator|=
operator|&
name|fw_controller
operator|->
name|domains
index|[
name|index
index|]
expr_stmt|;
comment|//Need to stop all the on-going smp activities before clearing affiliation.
name|scif_sas_domain_cancel_smp_activities
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
name|scif_sas_domain_start_clear_affiliation
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
name|status
operator|=
name|SCI_WARNING_SEQUENCE_INCOMPLETE
expr_stmt|;
block|}
else|else
block|{
comment|//the controller has done clear affiliation work to all its domains.
name|scif_sas_controller_continue_to_stop
argument_list|(
name|fw_controller
argument_list|)
expr_stmt|;
name|status
operator|=
name|SCI_SUCCESS
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method sets SCIF user parameters to  *        default values.  Users can override these values utilizing  *        the sciF_user_parameters_set() methods.  *  * @param[in] controller This parameter specifies the controller for  *            which to set the configuration parameters to their  *            default values.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_controller_set_default_config_parameters
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|this_controller
parameter_list|)
block|{
name|SCIF_USER_PARAMETERS_T
modifier|*
name|scif_parms
init|=
operator|&
operator|(
name|this_controller
operator|->
name|user_parameters
operator|)
decl_stmt|;
name|scif_parms
operator|->
name|sas
operator|.
name|is_sata_ncq_enabled
operator|=
name|TRUE
expr_stmt|;
name|scif_parms
operator|->
name|sas
operator|.
name|max_ncq_depth
operator|=
literal|32
expr_stmt|;
name|scif_parms
operator|->
name|sas
operator|.
name|is_sata_standby_timer_enabled
operator|=
name|FALSE
expr_stmt|;
name|scif_parms
operator|->
name|sas
operator|.
name|is_non_zero_buffer_offsets_enabled
operator|=
name|FALSE
expr_stmt|;
name|scif_parms
operator|->
name|sas
operator|.
name|reset_type
operator|=
name|SCI_SAS_LOGICAL_UNIT_RESET
expr_stmt|;
name|scif_parms
operator|->
name|sas
operator|.
name|clear_affiliation_during_controller_stop
operator|=
name|TRUE
expr_stmt|;
name|scif_parms
operator|->
name|sas
operator|.
name|ignore_fua
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method releases resource for framework controller and associated  *        objects.  *  * @param[in] fw_controller This parameter specifies the framework  *            controller and associated objects whose resources are to be released.  *  * @return This method returns a value indicating if the operation succeeded.  * @retval SCI_SUCCESS This value indicates that resource release succeeded.  * @retval SCI_FAILURE This value indicates certain failure during the process  *            of resource release.  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_controller_release_resource
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|U8
name|index
decl_stmt|;
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"scif_sas_controller_release_resource(0x%x) enter\n"
operator|,
name|fw_controller
operator|)
argument_list|)
expr_stmt|;
comment|//currently the only resource to be released is domain's timer.
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_DOMAINS
condition|;
name|index
operator|++
control|)
block|{
name|fw_domain
operator|=
operator|&
name|fw_controller
operator|->
name|domains
index|[
name|index
index|]
expr_stmt|;
name|scif_sas_domain_release_resource
argument_list|(
name|fw_controller
argument_list|,
name|fw_domain
argument_list|)
expr_stmt|;
block|}
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCI_LOGGING
end_ifdef

begin_comment
comment|/**  * This method will start state transition logging for the framework  * controller object.  *  * @param[in] fw_controller The framework controller object on which to  *       observe state changes.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_controller_initialize_state_logging
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|sci_base_state_machine_logger_initialize
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine_logger
argument_list|,
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|parent
argument_list|,
name|scif_cb_logger_log_states
argument_list|,
literal|"SCIF_SAS_CONTROLLER_T"
argument_list|,
literal|"base state machine"
argument_list|,
name|SCIF_LOG_OBJECT_CONTROLLER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method will remove the logging of state transitions from the framework  * controller object.  *  * @param[in] fw_controller The framework controller to change.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_controller_deinitialize_state_logging
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|sci_base_state_machine_logger_deinitialize
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine_logger
argument_list|,
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// SCI_LOGGING
end_comment

end_unit

