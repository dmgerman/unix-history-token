begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  * @brief This file contains the method implementations required to  *        translate the SCSI mode select (6 and 10-byte) commands with 5  *        supported mode parameter pages (0x01, 0x02, 0x08, 0x0A, 0x1C).  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_MODE_SELECT
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/isci/scil/sati_mode_select.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sati_mode_pages.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sati_callbacks.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_object.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sati_translator_sequence.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sati_util.h>
end_include

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* P R I V A T E   M E T H O D S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method will get medium type parameter field per CDB size.  *  * @param[in] scsi_io This parameter specifies the user's SCSI IO object  *            for which to calculate the mode page header.  * @param[in] cdb_size This parameter specifies the number of bytes  *            associated with the CDB for which to calculate the header.  *  * @return This method returns the medium type for the mode page header.  */
end_comment

begin_function
specifier|static
name|U8
name|sati_mode_select_get_medium_type
parameter_list|(
name|U8
modifier|*
name|mode_parameters
parameter_list|,
name|U32
name|cdb_size
parameter_list|)
block|{
name|U8
name|medium_type
init|=
literal|0xFF
decl_stmt|;
name|SCSI_MODE_SELECT_MODE_PARAMETER_HEADER_6_T
modifier|*
name|mode_parameters_6
decl_stmt|;
name|SCSI_MODE_SELECT_MODE_PARAMETER_HEADER_10_T
modifier|*
name|mode_parameters_10
decl_stmt|;
if|if
condition|(
name|cdb_size
operator|==
literal|6
condition|)
block|{
name|mode_parameters_6
operator|=
operator|(
name|SCSI_MODE_SELECT_MODE_PARAMETER_HEADER_6_T
operator|*
operator|)
name|mode_parameters
expr_stmt|;
name|medium_type
operator|=
name|mode_parameters_6
operator|->
name|medium_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cdb_size
operator|==
literal|10
condition|)
block|{
name|mode_parameters_10
operator|=
operator|(
name|SCSI_MODE_SELECT_MODE_PARAMETER_HEADER_10_T
operator|*
operator|)
name|mode_parameters
expr_stmt|;
name|medium_type
operator|=
name|mode_parameters_10
operator|->
name|medium_type
expr_stmt|;
block|}
return|return
name|medium_type
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will retrieve Block Descriptor Length.  *  * @param[in] mode_parameters This parameter contains the address to the mode parameters.  * @param[in] cdb_size This parameter specifies the number of bytes  *            associated with the CDB for which to process the block descriptor.  *  * @return This method returns the size, in bytes, for the mode parameter block descriptor.  */
end_comment

begin_function
specifier|static
name|U32
name|sati_mode_select_get_mode_block_descriptor_length
parameter_list|(
name|U8
modifier|*
name|mode_parameters
parameter_list|,
name|U32
name|cdb_size
parameter_list|)
block|{
name|U32
name|mode_block_descriptor_length
init|=
literal|0
decl_stmt|;
name|SCSI_MODE_SELECT_MODE_PARAMETER_HEADER_6_T
modifier|*
name|mode_parameters_6
decl_stmt|;
name|SCSI_MODE_SELECT_MODE_PARAMETER_HEADER_10_T
modifier|*
name|mode_parameters_10
decl_stmt|;
if|if
condition|(
name|cdb_size
operator|==
literal|6
condition|)
block|{
name|mode_parameters_6
operator|=
operator|(
name|SCSI_MODE_SELECT_MODE_PARAMETER_HEADER_6_T
operator|*
operator|)
name|mode_parameters
expr_stmt|;
name|mode_block_descriptor_length
operator|=
name|mode_parameters_6
operator|->
name|block_descriptor_length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cdb_size
operator|==
literal|10
condition|)
block|{
name|mode_parameters_10
operator|=
operator|(
name|SCSI_MODE_SELECT_MODE_PARAMETER_HEADER_10_T
operator|*
operator|)
name|mode_parameters
expr_stmt|;
comment|//Long LBA bit is the bit0 of the byte
comment|//Spec says another way to get the block descriptor length to multiply the block number
comment|//   with block length (8 or 16), but we can get it directly.
name|mode_block_descriptor_length
operator|=
operator|(
operator|(
operator|(
name|U16
operator|)
name|mode_parameters_10
operator|->
name|block_descriptor_length
index|[
literal|0
index|]
operator|)
operator|<<
literal|8
operator|)
operator|+
name|mode_parameters_10
operator|->
name|block_descriptor_length
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
name|mode_block_descriptor_length
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will find the starting byte location for a page.  *  * @param[in] block_descriptor_length This parameter passes in the length of  *            block descriptor.  * @param[in] cdb_size This parameter specifies the number of bytes  *            associated with the CDB for which to calculate the header.  *  * @return This method returns the offset, for the mode page.  */
end_comment

begin_function
specifier|static
name|U32
name|sati_mode_select_get_mode_page_offset
parameter_list|(
name|U32
name|block_descriptor_length
parameter_list|,
name|U32
name|cdb_size
parameter_list|)
block|{
name|U32
name|mode_page_offset
decl_stmt|;
if|if
condition|(
name|cdb_size
operator|==
literal|6
condition|)
block|{
name|mode_page_offset
operator|=
sizeof|sizeof
argument_list|(
name|SCSI_MODE_SELECT_MODE_PARAMETER_HEADER_6_T
argument_list|)
operator|+
name|block_descriptor_length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cdb_size
operator|==
literal|10
condition|)
block|{
name|mode_page_offset
operator|=
sizeof|sizeof
argument_list|(
name|SCSI_MODE_SELECT_MODE_PARAMETER_HEADER_10_T
argument_list|)
operator|+
name|block_descriptor_length
expr_stmt|;
block|}
else|else
block|{
name|mode_page_offset
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|mode_page_offset
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will set the initial Mode Select processing state.  */
end_comment

begin_function
specifier|static
name|void
name|sati_mode_select_initialize_mode_sel_processing_state
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_io
parameter_list|,
name|U32
name|data_transfer_length
parameter_list|,
name|U32
name|mode_page_offset
parameter_list|)
block|{
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|ata_command_sent_for_cmp
operator|=
literal|0
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_page_offset
operator|=
name|mode_page_offset
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_pages_size
operator|=
name|data_transfer_length
operator|-
name|mode_page_offset
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|size_of_data_processed
operator|=
literal|0
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|current_mode_page_processed
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will get mode page size.  *  * @param[in] page_code This parameter contains page code for the current mode page.  *  * @return This method returns the size of current mode page.  */
end_comment

begin_function
specifier|static
name|U32
name|sati_mode_select_get_mode_page_size
parameter_list|(
name|U8
name|page_code
parameter_list|)
block|{
name|U32
name|page_size
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|page_code
condition|)
block|{
case|case
name|SCSI_MODE_PAGE_READ_WRITE_ERROR
case|:
name|page_size
operator|=
name|SCSI_MODE_PAGE_01_LENGTH
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_DISCONNECT_RECONNECT
case|:
name|page_size
operator|=
name|SCSI_MODE_PAGE_02_LENGTH
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_CACHING
case|:
name|page_size
operator|=
name|SCSI_MODE_PAGE_08_LENGTH
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_CONTROL
case|:
name|page_size
operator|=
name|SCSI_MODE_PAGE_0A_LENGTH
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_INFORMATIONAL_EXCP_CONTROL
case|:
name|page_size
operator|=
name|SCSI_MODE_PAGE_1C_LENGTH
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_POWER_CONDITION
case|:
name|page_size
operator|=
name|SCSI_MODE_PAGE_1A_LENGTH
expr_stmt|;
break|break;
default|default:
name|page_size
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|page_size
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will check the validity of parameter data of Read Write Error Recovery  *            page and further processing the page data if necessary.  *  * @param[in] page_size This parameter specifies page size of current mode page.  *  * @return Indicate if the translation was successful.  * @retval SATI_SUCCESS  * @retval SATI_COMPLETE  * @retval SATI_FAILURE_CHECK_RESPONSE_DATA  */
end_comment

begin_function
specifier|static
name|SATI_STATUS
name|sati_mode_select_process_mode_page_read_write_error_recovery
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|U32
name|page_size
parameter_list|)
block|{
name|SATI_STATUS
name|status
init|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
decl_stmt|;
name|U8
name|current_mode_page
index|[
name|SCSI_MODE_PAGE_01_LENGTH
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|U32
name|mode_page_offset
decl_stmt|;
name|mode_page_offset
operator|=
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_page_offset
expr_stmt|;
comment|//Check all the defined bits for this page
comment|//SPF(0b); Page length 0x0A;AWRE 1; ARRE 0; Error recovery bits 0; RC 0;
comment|//Recovery time limit last two bytes 0
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|mode_page_offset
argument_list|,
operator|&
name|current_mode_page
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|mode_page_offset
operator|+
literal|1
argument_list|,
operator|&
name|current_mode_page
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|mode_page_offset
operator|+
literal|2
argument_list|,
operator|&
name|current_mode_page
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|mode_page_offset
operator|+
literal|10
argument_list|,
operator|&
name|current_mode_page
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|mode_page_offset
operator|+
literal|11
argument_list|,
operator|&
name|current_mode_page
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|current_mode_page
index|[
literal|0
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_SPF_MASK
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|1
index|]
operator|!=
operator|(
name|SCSI_MODE_PAGE_01_LENGTH
operator|-
literal|2
operator|)
operator|)
operator|||
operator|(
operator|(
name|current_mode_page
index|[
literal|2
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_01_AWRE_MASK
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|current_mode_page
index|[
literal|2
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_01_ARRE_MASK
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|current_mode_page
index|[
literal|2
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_01_RC_ERBITS_MASK
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|10
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|11
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|status
operator|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
expr_stmt|;
return|return
name|status
return|;
block|}
comment|//no need to send any command
block|{
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|size_of_data_processed
operator|+=
name|page_size
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_page_offset
operator|+=
name|page_size
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|current_mode_page_processed
operator|=
name|TRUE
expr_stmt|;
block|}
name|status
operator|=
name|SATI_COMPLETE
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will check the validity of parameter data of Disconnect Reconnect mode  *            page and further processing the page data if necessary.  *  * @param[in] page_size This parameter specifies page size of current mode page.  *  * @return Indicate if the translation was successful.  * @retval SATI_SUCCESS  * @retval SATI_COMPLETE  * @retval SATI_FAILURE_CHECK_RESPONSE_DATA  */
end_comment

begin_function
specifier|static
name|SATI_STATUS
name|sati_mode_select_process_mode_page_disconnect_reconnect
parameter_list|(
name|SATI_MODE_SELECT_PROCESSING_STATE_T
modifier|*
name|mode_select_process_state
parameter_list|,
name|U32
name|page_size
parameter_list|)
block|{
name|SATI_STATUS
name|status
init|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
decl_stmt|;
comment|// No need to check data for valid or invalid this page (undefined)
comment|// No ata command to send
block|{
name|mode_select_process_state
operator|->
name|size_of_data_processed
operator|+=
name|page_size
expr_stmt|;
name|mode_select_process_state
operator|->
name|mode_page_offset
operator|+=
name|page_size
expr_stmt|;
name|mode_select_process_state
operator|->
name|current_mode_page_processed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|// No further interaction with remote devices
name|status
operator|=
name|SATI_COMPLETE
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will check the validity of parameter data of Caching mode  *            page and issue multiple ATA set feature commands to complete the translation.  *  * @param[in] page_size This parameter specifies page size of current mode page.  *  * @return Indicate if the translation was successful.  * @retval SATI_SUCCESS  * @retval SATI_COMPLETE  * @retval SATI_FAILURE_CHECK_RESPONSE_DATA  */
end_comment

begin_function
specifier|static
name|SATI_STATUS
name|sati_mode_select_process_mode_page_caching
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_io
parameter_list|,
name|U32
name|page_size
parameter_list|)
block|{
name|SATI_STATUS
name|status
init|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
decl_stmt|;
comment|//SCSI_MODE_PAGE_08_LENGTH 0x14= 20
name|U8
name|current_mode_page
index|[
name|SCSI_MODE_PAGE_08_LENGTH
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|U32
name|mode_page_offset
decl_stmt|;
name|U32
name|index
decl_stmt|;
name|mode_page_offset
operator|=
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_page_offset
expr_stmt|;
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SELECT_MODE_PAGE_CACHING
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCSI_MODE_PAGE_08_LENGTH
condition|;
name|index
operator|++
control|)
block|{
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|mode_page_offset
operator|+
name|index
argument_list|,
operator|&
name|current_mode_page
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
comment|//Check for data validity
comment|//SPF(0b); Page length 0x12;Byte2 to Byte15 all 0 with exception DRA and WCE changeable
if|if
condition|(
operator|(
operator|(
name|current_mode_page
index|[
literal|0
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_SPF_MASK
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|1
index|]
operator|!=
operator|(
name|SCSI_MODE_PAGE_08_LENGTH
operator|-
literal|2
operator|)
operator|)
operator|||
operator|(
operator|(
name|current_mode_page
index|[
literal|2
index|]
operator||
name|SCSI_MODE_PAGE_CACHE_PAGE_WCE_BIT
operator|)
operator|!=
name|SCSI_MODE_PAGE_CACHE_PAGE_WCE_BIT
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|3
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|4
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|5
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|6
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|7
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|8
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|9
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|10
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|11
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|current_mode_page
index|[
literal|12
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_08_FSW_LBCSS_NVDIS
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|13
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|14
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|15
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
comment|//parameter data passed in containing data that doesn't meet the SAT-2 requirement
return|return
name|SATI_FAILURE_CHECK_RESPONSE_DATA
return|;
block|}
if|if
condition|(
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|ata_command_sent_for_cmp
operator|==
literal|0
condition|)
block|{
comment|//byte2 bit2 WCE==0 disable write cache WCE==1 enable write cache
comment|//SCSI_MODE_PAGE_CACHE_PAGE_WCE_BIT ==0x4,
if|if
condition|(
operator|(
name|current_mode_page
index|[
literal|2
index|]
operator|&
name|SCSI_MODE_PAGE_CACHE_PAGE_WCE_BIT
operator|)
operator|==
literal|0
condition|)
name|sati_ata_set_features_construct
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|,
name|ATA_SET_FEATURES_SUB_CMD_DISABLE_CACHE
argument_list|)
expr_stmt|;
else|else
name|sati_ata_set_features_construct
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|,
name|ATA_SET_FEATURES_SUB_CMD_ENABLE_CACHE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|ata_command_sent_for_cmp
operator|==
literal|1
condition|)
block|{
comment|// DRA bit is set to 0, enable Read look ahead AAh;
comment|// DRA bit is set to 1, disable with set feature command 55h
comment|// SCSI_MODE_PAGE_CACHE_PAGE_DRA_BIT== 0x20
if|if
condition|(
operator|(
name|current_mode_page
index|[
literal|12
index|]
operator|&
name|SCSI_MODE_PAGE_CACHE_PAGE_DRA_BIT
operator|)
operator|==
literal|0
condition|)
name|sati_ata_set_features_construct
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|,
name|ATA_SET_FEATURES_SUB_CMD_ENABLE_READ_AHEAD
argument_list|)
expr_stmt|;
else|else
name|sati_ata_set_features_construct
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|,
name|ATA_SET_FEATURES_SUB_CMD_DISABLE_READ_AHEAD
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|size_of_data_processed
operator|+=
name|page_size
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_page_offset
operator|+=
name|page_size
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|current_mode_page_processed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|// No more ata commands to send
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|ata_command_sent_for_cmp
operator|++
expr_stmt|;
name|status
operator|=
name|SATI_SUCCESS
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will check the validity of parameter data of Control mode  *            page and further processing the page data if necessary.  *  * @param[in] mode_select_process_state This parameter points to the processing state fields  *            of current mode page.  * @param[in] page_size This parameter specifies page size of current mode page.  *  * @return Indicate if the translation was successful.  * @retval SATI_SUCCESS  * @retval SATI_COMPLETE  * @retval SATI_FAILURE_CHECK_RESPONSE_DATA  */
end_comment

begin_function
specifier|static
name|SATI_STATUS
name|sati_mode_select_process_mode_page_control
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_io
parameter_list|,
name|U32
name|page_size
parameter_list|)
block|{
name|SATI_STATUS
name|status
init|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
decl_stmt|;
comment|//SCSI_MODE_PAGE_0A_LENGTH 12
name|U8
name|current_mode_page
index|[
name|SCSI_MODE_PAGE_0A_LENGTH
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|U32
name|mode_page_offset
decl_stmt|;
name|U32
name|index
decl_stmt|;
name|mode_page_offset
operator|=
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_page_offset
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCSI_MODE_PAGE_0A_LENGTH
condition|;
name|index
operator|++
control|)
block|{
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|mode_page_offset
operator|+
name|index
argument_list|,
operator|&
name|current_mode_page
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
comment|//bit 1 and 2 of byte3 Qerr full task management model etc. then both bits 0
comment|//byte 8 and 9 busy time out period variable if not ffff setable?
comment|//check for page data validity
comment|//Byte2: 0000???0b  Byte3: Queued Algorithm Modifier should be set to 1 QErr?
comment|//Byte4: ??000???   Byte5: ?0???000
if|if
condition|(
operator|(
operator|(
name|current_mode_page
index|[
literal|0
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_SPF_MASK
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|1
index|]
operator|!=
operator|(
name|SCSI_MODE_PAGE_0A_LENGTH
operator|-
literal|2
operator|)
operator|)
operator|||
operator|(
operator|(
name|current_mode_page
index|[
literal|2
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_0A_TST_TMF_RLEC
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|current_mode_page
index|[
literal|3
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_0A_MODIFIER
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|current_mode_page
index|[
literal|4
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_0A_UA_SWP
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|current_mode_page
index|[
literal|5
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_0A_TAS_AUTO
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
name|SATI_FAILURE_CHECK_RESPONSE_DATA
return|;
block|}
if|if
condition|(
operator|(
name|current_mode_page
index|[
literal|2
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_D_SENSE
operator|)
operator|!=
literal|0
condition|)
name|sequence
operator|->
name|device
operator|->
name|descriptor_sense_enable
operator|=
name|SCSI_MODE_PAGE_CONTROL_D_SENSE_ENABLE
expr_stmt|;
else|else
name|sequence
operator|->
name|device
operator|->
name|descriptor_sense_enable
operator|=
name|SCSI_MODE_PAGE_CONTROL_D_SENSE_DISABLE
expr_stmt|;
comment|// no ata command need to be comfirmed
block|{
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|size_of_data_processed
operator|+=
name|page_size
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_page_offset
operator|+=
name|page_size
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|current_mode_page_processed
operator|=
name|TRUE
expr_stmt|;
block|}
name|status
operator|=
name|SATI_COMPLETE
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will check the validity of parameter data of Information Exception Control  *            mode page and further processing the page data if necessary.  *  * @param[in] page_size This parameter specifies page size of current mode page.  *  * @return Indicate if the translation was successful.  * @retval SATI_SUCCESS  * @retval SATI_COMPLETE  * @retval SATI_FAILURE_CHECK_RESPONSE_DATA  */
end_comment

begin_function
specifier|static
name|SATI_STATUS
name|sati_mode_select_process_mode_page_informational_exception_control
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_io
parameter_list|,
name|U32
name|page_size
parameter_list|)
block|{
name|SATI_STATUS
name|status
init|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
decl_stmt|;
comment|//SCSI_MODE_PAGE_1C_LENGTH 12
name|U8
name|current_mode_page
index|[
name|SCSI_MODE_PAGE_1C_LENGTH
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|U32
name|mode_page_offset
decl_stmt|;
name|U32
name|index
decl_stmt|;
name|mode_page_offset
operator|=
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_page_offset
expr_stmt|;
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SELECT_MODE_INFORMATION_EXCEPT_CONTROL
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|4
condition|;
name|index
operator|++
control|)
block|{
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|mode_page_offset
operator|+
name|index
argument_list|,
operator|&
name|current_mode_page
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
comment|//Check for data validity
comment|//SPF(0b); Page length 0x0A; Byte2 0????0?? Byte3: ????1100
comment|//SCSI_MODE_SELECT_MODE_PAGE_MRIE_BYTE same as REPORT_INFO_EXCEPTION_CONDITION_ON_REQUEST 0x6
comment|//SCSI_MODE_PAGE_DEXCPT_ENABLE
if|if
condition|(
operator|(
operator|(
name|current_mode_page
index|[
literal|0
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_SPF_MASK
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|1
index|]
operator|!=
operator|(
name|SCSI_MODE_PAGE_1C_LENGTH
operator|-
literal|2
operator|)
operator|)
operator|||
operator|(
operator|(
name|current_mode_page
index|[
literal|2
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_1C_PERF_TEST
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|current_mode_page
index|[
literal|3
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_MRIE_MASK
operator|)
operator|!=
name|SCSI_MODE_SELECT_MODE_PAGE_MRIE_BYTE
operator|)
condition|)
block|{
return|return
name|SATI_FAILURE_CHECK_RESPONSE_DATA
return|;
block|}
comment|// DEXCPT bit is set to 0, enable SMART reporting D8h;
comment|// DEXCPT bit is set to 1, disable SMART reporting D9h
comment|// SCSI_MODE_PAGE_DEXCPT_ENABLE== 0x08
if|if
condition|(
operator|(
name|current_mode_page
index|[
literal|2
index|]
operator|&
name|SCSI_MODE_PAGE_DEXCPT_ENABLE
operator|)
operator|==
literal|0
condition|)
name|sati_ata_smart_return_status_construct
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|,
name|ATA_SMART_SUB_CMD_ENABLE
argument_list|)
expr_stmt|;
else|else
name|sati_ata_smart_return_status_construct
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|,
name|ATA_SMART_SUB_CMD_DISABLE
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|size_of_data_processed
operator|+=
name|page_size
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_page_offset
operator|+=
name|page_size
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|current_mode_page_processed
operator|=
name|TRUE
expr_stmt|;
comment|// No more ata commands to send
name|status
operator|=
name|SATI_SUCCESS
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will check the validity of parameter data of Power Condition mode  *            page and issue multiple ATA set feature commands to complete the translation.  *  * @param[in] mode_select_process_state This parameter points to the processing state fields  *            of current mode page.  * @param[in] page_size This parameter specifies page size of current mode page.  *  * @return Indicate if the translation was successful.  * @retval SATI_SUCCESS  * @retval SATI_COMPLETE  * @retval SATI_FAILURE_CHECK_RESPONSE_DATA  */
end_comment

begin_function
specifier|static
name|SATI_STATUS
name|sati_mode_select_process_mode_page_power_condition
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_io
parameter_list|,
name|U32
name|page_size
parameter_list|)
block|{
name|SATI_STATUS
name|status
init|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
decl_stmt|;
comment|//SCSI_MODE_PAGE_1A_LENGTH 10
name|U8
name|current_mode_page
index|[
name|SCSI_MODE_PAGE_1A_LENGTH
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|U32
name|mode_page_offset
decl_stmt|;
name|U32
name|index
decl_stmt|;
name|U32
name|timer
init|=
literal|0
decl_stmt|;
name|U16
name|count
init|=
literal|0
decl_stmt|;
name|mode_page_offset
operator|=
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_page_offset
expr_stmt|;
name|sequence
operator|->
name|type
operator|=
name|SATI_SEQUENCE_MODE_SELECT_MODE_POWER_CONDITION
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCSI_MODE_PAGE_1A_LENGTH
condition|;
name|index
operator|++
control|)
block|{
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|mode_page_offset
operator|+
name|index
argument_list|,
operator|&
name|current_mode_page
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
comment|//Check for data validity
comment|//SPF(0b); Page length 0x0A;
if|if
condition|(
operator|(
operator|(
name|current_mode_page
index|[
literal|0
index|]
operator|&
name|SCSI_MODE_SELECT_MODE_PAGE_SPF_MASK
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|current_mode_page
index|[
literal|1
index|]
operator|!=
operator|(
name|SCSI_MODE_PAGE_1A_LENGTH
operator|-
literal|2
operator|)
operator|)
operator|||
operator|(
operator|(
name|current_mode_page
index|[
literal|3
index|]
operator|&
name|SCSI_MODE_PAGE_POWER_CONDITION_IDLE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|//parameter data passed in containing data that doesn't meet the SAT-2 requirement
return|return
name|SATI_FAILURE_CHECK_RESPONSE_DATA
return|;
block|}
comment|// STANDBY bit is set to 0, do nothing since the standby timer can't be set;
comment|// STANDBY bit is set to 1, translate the standby timer
comment|// SCSI_MODE_PAGE_POWER_CONDITION_STANDBY== 0x01
if|if
condition|(
name|current_mode_page
index|[
literal|3
index|]
operator|&
name|SCSI_MODE_PAGE_POWER_CONDITION_STANDBY
condition|)
block|{
name|timer
operator|=
operator|(
name|current_mode_page
index|[
literal|8
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|current_mode_page
index|[
literal|9
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|current_mode_page
index|[
literal|10
index|]
operator|<<
literal|8
operator|)
operator|+
name|current_mode_page
index|[
literal|11
index|]
expr_stmt|;
comment|//If the ATA IDENTIFY DEVICE data word 49, bit 13 is set to one,
if|if
condition|(
name|sequence
operator|->
name|device
operator|->
name|capabilities
operator|&
name|SATI_DEVICE_CAP_STANDBY_ENABLE
condition|)
block|{
if|if
condition|(
name|timer
operator|==
literal|0
condition|)
block|{
comment|//TPV=0 send ATA STANDBY_IMMEDIATE
name|sati_ata_standby_immediate_construct
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|translated_command
operator|=
name|ATA_STANDBY_IMMED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|timer
operator|>
literal|0
operator|)
operator|&&
operator|(
name|timer
operator|<=
literal|12000
operator|)
condition|)
block|{
comment|//1 to 12 000 INT((z - 1) / 50) + 1
name|count
operator|=
call|(
name|U16
call|)
argument_list|(
operator|(
name|timer
operator|-
literal|1
operator|)
operator|/
literal|50
argument_list|)
operator|+
literal|1
expr_stmt|;
name|sati_ata_standby_construct
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|timer
operator|>
literal|12000
operator|)
operator|&&
operator|(
name|timer
operator|<=
literal|12600
operator|)
condition|)
block|{
comment|//12 001 to 12 600 FCh
name|sati_ata_standby_construct
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|,
literal|0xFC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|timer
operator|>
literal|12600
operator|)
operator|&&
operator|(
name|timer
operator|<=
literal|12750
operator|)
condition|)
block|{
comment|//12 601 to 12 750 FFh
name|sati_ata_standby_construct
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|timer
operator|>
literal|12750
operator|)
operator|&&
operator|(
name|timer
operator|<
literal|18000
operator|)
condition|)
block|{
comment|//12 751 to 17 999 F1h
name|sati_ata_standby_construct
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|,
literal|0xF1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|timer
operator|>=
literal|18000
operator|)
operator|&&
operator|(
name|timer
operator|<=
literal|198000
operator|)
condition|)
block|{
comment|//18 000 to 198 000 INT(z / 18 000) + 240
name|count
operator|=
call|(
name|U16
call|)
argument_list|(
name|timer
operator|/
literal|18000
argument_list|)
operator|+
literal|240
expr_stmt|;
name|sati_ata_standby_construct
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//All other values FDh
name|sati_ata_standby_construct
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|,
literal|0xFD
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|SATI_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
expr_stmt|;
comment|//If the ATA IDENTIFY DEVICE data word 49, bit 13 is set to 0
block|}
block|}
else|else
block|{
name|status
operator|=
name|SATI_COMPLETE
expr_stmt|;
block|}
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|size_of_data_processed
operator|+=
name|page_size
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_page_offset
operator|+=
name|page_size
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|current_mode_page_processed
operator|=
name|TRUE
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will process the mode page.  *  *  * @return Indicate if the translation was successful.  * @retval SATI_SUCCESS  * @retval SATI_COMPLETE  * @retval SATI_FAILURE_CHECK_RESPONSE_DATA  */
end_comment

begin_function
specifier|static
name|SATI_STATUS
name|sati_mode_select_process_mode_page
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_io
parameter_list|)
block|{
name|SATI_STATUS
name|status
init|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
decl_stmt|;
name|U8
name|page_code
decl_stmt|;
name|U32
name|page_size
init|=
literal|0
decl_stmt|;
comment|// in bytes
name|U32
name|size_of_data_to_be_processed
decl_stmt|;
name|U8
name|page_code_byte
decl_stmt|;
name|U32
name|mode_page_offset
decl_stmt|;
name|mode_page_offset
operator|=
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_page_offset
expr_stmt|;
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|mode_page_offset
argument_list|,
operator|&
name|page_code_byte
argument_list|)
expr_stmt|;
comment|// No more pages.
if|if
condition|(
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_pages_size
operator|>
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|size_of_data_processed
condition|)
block|{
comment|//SCSI_MODE_SENSE_PAGE_CODE_ENABLE==0x3f same for Mode Select
name|page_code
operator|=
name|page_code_byte
operator|&
name|SCSI_MODE_SENSE_PAGE_CODE_ENABLE
expr_stmt|;
name|page_size
operator|=
name|sati_mode_select_get_mode_page_size
argument_list|(
name|page_code
argument_list|)
expr_stmt|;
name|size_of_data_to_be_processed
operator|=
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|mode_pages_size
operator|-
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|size_of_data_processed
expr_stmt|;
if|if
condition|(
name|page_size
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
expr_stmt|;
block|}
else|else
block|{
comment|// process mode page
switch|switch
condition|(
name|page_code
condition|)
block|{
case|case
name|SCSI_MODE_PAGE_READ_WRITE_ERROR
case|:
name|status
operator|=
name|sati_mode_select_process_mode_page_read_write_error_recovery
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_DISCONNECT_RECONNECT
case|:
name|status
operator|=
name|sati_mode_select_process_mode_page_disconnect_reconnect
argument_list|(
operator|&
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_CACHING
case|:
name|status
operator|=
name|sati_mode_select_process_mode_page_caching
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|ata_io
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_CONTROL
case|:
name|status
operator|=
name|sati_mode_select_process_mode_page_control
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|ata_io
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_INFORMATIONAL_EXCP_CONTROL
case|:
name|status
operator|=
name|sati_mode_select_process_mode_page_informational_exception_control
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|ata_io
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_MODE_PAGE_POWER_CONDITION
case|:
name|status
operator|=
name|sati_mode_select_process_mode_page_power_condition
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|ata_io
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* P U B L I C   M E T H O D S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method will translate the SCSI Mode Select 6 byte or 10 byte command  *        into corresponding ATA commands.  Depending upon the capabilities  *        supported by the target different ATA commands can be selected.  *        Additionally, in some cases more than a single ATA command may  *        be required.  *  * @return Indicate if the command translation succeeded.  * @retval SCI_SUCCESS This is returned if the command translation was  *         successful.  * @retval SCI_COMPLETE This is returned if the command translation was  *         successful and no ATA commands need to be set.  * @retval SATI_FAILURE_CHECK_RESPONSE_DATA This value is returned if  *         sense data has been created as a result of something specified  *         in the parameter data fields.  */
end_comment

begin_function
specifier|static
name|SATI_STATUS
name|sati_mode_select_translate_command
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_io
parameter_list|,
name|U32
name|cdb_size
parameter_list|)
block|{
name|SATI_STATUS
name|status
init|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
decl_stmt|;
name|U32
name|mode_page_offset
decl_stmt|;
name|U32
name|block_descriptor_length
decl_stmt|;
name|U32
name|index
decl_stmt|;
name|U16
name|data_transfer_length
decl_stmt|;
name|U8
name|current_mode_parameters
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|U8
modifier|*
name|cdb
init|=
name|sati_cb_get_cdb_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
comment|// cdb_size must be 6 or 10
if|if
condition|(
name|FALSE
operator|==
operator|(
name|cdb_size
operator|==
literal|6
operator|||
name|cdb_size
operator|==
literal|10
operator|)
condition|)
block|{
return|return
name|status
return|;
block|}
if|if
condition|(
name|sequence
operator|->
name|state
operator|==
name|SATI_SEQUENCE_STATE_INITIAL
condition|)
block|{
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|ata_command_sent_for_cmp
operator|=
literal|0
expr_stmt|;
name|sequence
operator|->
name|state
operator|=
name|SATI_SEQUENCE_STATE_TRANSLATE_DATA
expr_stmt|;
block|}
comment|//First, initializes mode_sel_processing_state
if|if
condition|(
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|ata_command_sent_for_cmp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cdb_size
operator|==
literal|6
condition|)
block|{
comment|//CDB byte 4 is the parameter length
name|data_transfer_length
operator|=
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//CDB byte 7 and 8 for Mode Select 10
name|data_transfer_length
operator|=
operator|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|7
argument_list|)
operator|<<
literal|8
operator|)
operator|+
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|sequence
operator|->
name|allocation_length
operator|=
name|data_transfer_length
expr_stmt|;
comment|//Get 8 bytes for headers (4 bytes for Mode Select 6 and 8 bytes for Mode Select 10)
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|8
condition|;
name|index
operator|++
control|)
block|{
name|sati_get_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|index
argument_list|,
operator|&
name|current_mode_parameters
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
comment|//medium type should be 0
if|if
condition|(
name|sati_mode_select_get_medium_type
argument_list|(
name|current_mode_parameters
argument_list|,
name|cdb_size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sati_scsi_sense_data_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|SCSI_STATUS_CHECK_CONDITION
argument_list|,
name|SCSI_SENSE_ILLEGAL_REQUEST
argument_list|,
name|SCSI_ASC_INVALID_FIELD_IN_PARM_LIST
argument_list|,
name|SCSI_ASCQ_INVALID_FIELD_IN_PARM_LIST
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|block_descriptor_length
operator|=
name|sati_mode_select_get_mode_block_descriptor_length
argument_list|(
name|current_mode_parameters
argument_list|,
name|cdb_size
argument_list|)
expr_stmt|;
name|mode_page_offset
operator|=
name|sati_mode_select_get_mode_page_offset
argument_list|(
name|block_descriptor_length
argument_list|,
name|cdb_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_page_offset
operator|>
name|data_transfer_length
condition|)
block|{
name|sequence
operator|->
name|state
operator|=
name|SATI_SEQUENCE_STATE_FINAL
expr_stmt|;
name|status
operator|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
expr_stmt|;
block|}
else|else
block|{
name|sati_mode_select_initialize_mode_sel_processing_state
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|ata_io
argument_list|,
name|data_transfer_length
argument_list|,
name|mode_page_offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|// move to next mode page
if|if
condition|(
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|current_mode_page_processed
condition|)
block|{
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|ata_command_sent_for_cmp
operator|=
literal|0
expr_stmt|;
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|current_mode_page_processed
operator|=
name|FALSE
expr_stmt|;
block|}
name|status
operator|=
name|sati_mode_select_process_mode_page
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|ata_io
argument_list|)
expr_stmt|;
if|if
condition|(
name|sequence
operator|->
name|command_specific_data
operator|.
name|process_state
operator|.
name|current_mode_page_processed
operator|!=
name|FALSE
condition|)
block|{
comment|// Done this page
name|sequence
operator|->
name|state
operator|=
name|SATI_SEQUENCE_STATE_FINAL
expr_stmt|;
block|}
else|else
block|{
name|sequence
operator|->
name|state
operator|=
name|SATI_SEQUENCE_STATE_INCOMPLETE
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|SATI_FAILURE_CHECK_RESPONSE_DATA
condition|)
block|{
name|sequence
operator|->
name|state
operator|=
name|SATI_SEQUENCE_STATE_FINAL
expr_stmt|;
name|sati_scsi_sense_data_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|SCSI_STATUS_CHECK_CONDITION
argument_list|,
name|SCSI_SENSE_ILLEGAL_REQUEST
argument_list|,
name|SCSI_ASC_INVALID_FIELD_IN_PARM_LIST
argument_list|,
name|SCSI_ASCQ_INVALID_FIELD_IN_PARM_LIST
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will call Mode Select 6 Translation command  *        For more information on the parameters passed to this method,  *        please reference sati_translate_command().  *  * @return Indicate if the command translation succeeded.  * @retval SCI_SUCCESS This is returned if the command translation was  *         successful.  * @retval SCI_COMPLETE This is returned if the command translation was  *         successful and no ATA commands need to be set.  * @retval SATI_FAILURE_CHECK_RESPONSE_DATA This value is returned if  *         sense data has been created as a result of something specified  *         in the parameter data fields.  */
end_comment

begin_function
name|SATI_STATUS
name|sati_mode_select_6_translate_command
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_io
parameter_list|)
block|{
name|SATI_STATUS
name|status
init|=
name|SATI_FAILURE
decl_stmt|;
name|U8
modifier|*
name|cdb
init|=
name|sati_cb_get_cdb_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
comment|//PF bit needs to be 1 byte1 bit ???1????
if|if
condition|(
operator|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|1
argument_list|)
operator|&
name|SCSI_MODE_SELECT_PF_MASK
operator|)
operator|==
operator|!
name|SCSI_MODE_SELECT_PF_BIT
condition|)
block|{
name|sati_scsi_sense_data_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|SCSI_STATUS_CHECK_CONDITION
argument_list|,
name|SCSI_SENSE_ILLEGAL_REQUEST
argument_list|,
name|SCSI_ASC_INVALID_FIELD_IN_CDB
argument_list|,
name|SCSI_ASCQ_INVALID_FIELD_IN_CDB
argument_list|)
expr_stmt|;
name|status
operator|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|sati_mode_select_translate_command
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|ata_io
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SATI_FAILURE_CHECK_RESPONSE_DATA
condition|)
block|{
name|sati_scsi_sense_data_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|SCSI_STATUS_CHECK_CONDITION
argument_list|,
name|SCSI_SENSE_ILLEGAL_REQUEST
argument_list|,
name|SCSI_ASC_INVALID_FIELD_IN_PARM_LIST
argument_list|,
name|SCSI_ASCQ_INVALID_FIELD_IN_PARM_LIST
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will call Mode Select 10 translation command  *        For more information on the parameters passed to this method,  *        please reference sati_translate_command().  *  * @return Indicate if the command translation succeeded.  * @retval SCI_SUCCESS This is returned if the command translation was  *         successful.  * @retval SCI_COMPLETE This is returned if the command translation was  *         successful and no ATA commands need to be set.  * @retval SATI_FAILURE_CHECK_RESPONSE_DATA This value is returned if  *         sense data has been created as a result of something specified  *         in the parameter data fields.  */
end_comment

begin_function
name|SATI_STATUS
name|sati_mode_select_10_translate_command
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_io
parameter_list|)
block|{
name|SATI_STATUS
name|status
init|=
name|SATI_FAILURE
decl_stmt|;
name|U8
modifier|*
name|cdb
init|=
name|sati_cb_get_cdb_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
comment|//PF bit needs to be 1 byte1 bit ???1????
if|if
condition|(
operator|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|1
argument_list|)
operator|&
name|SCSI_MODE_SELECT_PF_MASK
operator|)
operator|==
operator|!
name|SCSI_MODE_SELECT_PF_BIT
condition|)
block|{
name|sati_scsi_sense_data_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|SCSI_STATUS_CHECK_CONDITION
argument_list|,
name|SCSI_SENSE_ILLEGAL_REQUEST
argument_list|,
name|SCSI_ASC_INVALID_FIELD_IN_CDB
argument_list|,
name|SCSI_ASCQ_INVALID_FIELD_IN_CDB
argument_list|)
expr_stmt|;
name|status
operator|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|sati_mode_select_translate_command
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|ata_io
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SATI_FAILURE_CHECK_RESPONSE_DATA
condition|)
block|{
name|sati_scsi_sense_data_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|SCSI_STATUS_CHECK_CONDITION
argument_list|,
name|SCSI_SENSE_ILLEGAL_REQUEST
argument_list|,
name|SCSI_ASC_INVALID_FIELD_IN_PARM_LIST
argument_list|,
name|SCSI_ASCQ_INVALID_FIELD_IN_PARM_LIST
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/** * @brief This method will conduct error handling for the ATA Set Features command *        that is issued during a Mode Select translation for the Caching Mode *        page. * * * @return Indicate if the command translation succeeded. * * @retval SCI_COMPLETE This is returned if the command translation was *         successful and no additional ATA commands need to be set. * @retval SATI_FAILURE_CHECK_RESPONSE_DATA This value is returned if *         sense data has been created as a result of an error returned */
end_comment

begin_function
name|SATI_STATUS
name|sati_mode_select_translate_response
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_io
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_d2h_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|SATI_STATUS
name|status
init|=
name|SATI_FAILURE
decl_stmt|;
if|if
condition|(
name|sati_get_ata_status
argument_list|(
name|register_fis
argument_list|)
operator|&
name|ATA_STATUS_REG_ERROR_BIT
condition|)
block|{
name|sati_scsi_sense_data_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|SCSI_STATUS_CHECK_CONDITION
argument_list|,
name|SCSI_SENSE_ABORTED_COMMAND
argument_list|,
name|SCSI_ASC_NO_ADDITIONAL_SENSE
argument_list|,
name|SCSI_ASCQ_NO_ADDITIONAL_SENSE
argument_list|)
expr_stmt|;
name|status
operator|=
name|SATI_FAILURE_CHECK_RESPONSE_DATA
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sequence
operator|->
name|state
operator|==
name|SATI_SEQUENCE_STATE_INCOMPLETE
condition|)
block|{
name|status
operator|=
name|SATI_SEQUENCE_INCOMPLETE
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|SATI_COMPLETE
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !defined(DISABLE_SATI_MODE_SELECT)
end_comment

end_unit

