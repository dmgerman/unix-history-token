begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  *  * @brief This file contains the implementation of the SCIF_SAS_SMP_PHY  *        object.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_smp_phy.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_smp_remote_device.h>
end_include

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//*
end_comment

begin_comment
comment|//*     P U B L I C   M E T H O D S
end_comment

begin_comment
comment|//*
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This routine constructs a smp phy object for an expander phy and insert  *           to owning expander device's smp_phy_list.  * @param[in] this_smp_phy The memory space to store a phy  * @param[in] owning_device The smp remote device that owns this smp phy.  * @param[in] expander_phy_id The expander phy id for this_smp_phy.  * @return None  */
end_comment

begin_function
name|void
name|scif_sas_smp_phy_construct
parameter_list|(
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|this_smp_phy
parameter_list|,
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|owning_device
parameter_list|,
name|U8
name|expander_phy_id
parameter_list|)
block|{
name|memset
argument_list|(
name|this_smp_phy
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SCIF_SAS_SMP_PHY_T
argument_list|)
argument_list|)
expr_stmt|;
name|this_smp_phy
operator|->
name|phy_identifier
operator|=
name|expander_phy_id
expr_stmt|;
name|this_smp_phy
operator|->
name|owning_device
operator|=
name|owning_device
expr_stmt|;
name|sci_fast_list_element_init
argument_list|(
operator|(
name|this_smp_phy
operator|)
argument_list|,
operator|(
operator|&
name|this_smp_phy
operator|->
name|list_element
operator|)
argument_list|)
expr_stmt|;
comment|//insert to owning device's smp phy list.
name|sci_fast_list_insert_tail
argument_list|(
operator|(
operator|&
name|owning_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_phy_list
operator|)
argument_list|,
operator|(
operator|&
name|this_smp_phy
operator|->
name|list_element
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This routine destructs a smp phy object for an expander phy and free the smp  *           phy to controller's smp phy memory.  * @param[in] this_smp_phy The smp phy to be destructed.  *  * @return None  */
end_comment

begin_function
name|void
name|scif_sas_smp_phy_destruct
parameter_list|(
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|this_smp_phy
parameter_list|)
block|{
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|owning_device
init|=
name|this_smp_phy
operator|->
name|owning_device
decl_stmt|;
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
name|owning_device
operator|->
name|domain
operator|->
name|controller
decl_stmt|;
if|if
condition|(
operator|(
name|this_smp_phy
operator|->
name|attached_device_type
operator|==
name|SMP_EDGE_EXPANDER_DEVICE
operator|||
name|this_smp_phy
operator|->
name|attached_device_type
operator|==
name|SMP_FANOUT_EXPANDER_DEVICE
operator|)
operator|&&
name|this_smp_phy
operator|->
name|u
operator|.
name|attached_phy
operator|!=
name|NULL
condition|)
block|{
comment|//update the counterpart phy from the other smp phy list.
name|this_smp_phy
operator|->
name|u
operator|.
name|attached_phy
operator|->
name|attached_device_type
operator|=
name|SMP_NO_DEVICE_ATTACHED
expr_stmt|;
name|this_smp_phy
operator|->
name|u
operator|.
name|attached_phy
operator|->
name|u
operator|.
name|attached_phy
operator|=
name|NULL
expr_stmt|;
block|}
comment|//remove curr_smp_phy
name|sci_fast_list_remove_element
argument_list|(
operator|&
name|this_smp_phy
operator|->
name|list_element
argument_list|)
expr_stmt|;
name|scif_sas_controller_free_smp_phy
argument_list|(
name|fw_controller
argument_list|,
name|this_smp_phy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This routine save a smp phy information based on discover response.  *  * @param[in] this_smp_phy The memory space to store a phy  * @param[in] attached_device A possible direct attached device to this phy.  *  * @param[in] discover_response The smp DISCOVER response for this_smp_phy.  * @return None  */
end_comment

begin_function
name|void
name|scif_sas_smp_phy_save_information
parameter_list|(
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|this_smp_phy
parameter_list|,
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|attached_device
parameter_list|,
name|SMP_RESPONSE_DISCOVER_T
modifier|*
name|discover_response
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|this_smp_phy
operator|->
name|owning_device
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|this_smp_phy
operator|->
name|phy_identifier
operator|==
name|discover_response
operator|->
name|phy_identifier
argument_list|)
expr_stmt|;
name|this_smp_phy
operator|->
name|attached_device_type
operator|=
operator|(
name|U8
operator|)
name|discover_response
operator|->
name|u2
operator|.
name|sas1_1
operator|.
name|attached_device_type
expr_stmt|;
name|this_smp_phy
operator|->
name|routing_attribute
operator|=
operator|(
name|U8
operator|)
name|discover_response
operator|->
name|routing_attribute
expr_stmt|;
name|this_smp_phy
operator|->
name|attached_sas_address
operator|=
name|discover_response
operator|->
name|attached_sas_address
expr_stmt|;
name|this_smp_phy
operator|->
name|config_route_table_index_anchor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|this_smp_phy
operator|->
name|attached_device_type
operator|!=
name|SMP_EDGE_EXPANDER_DEVICE
operator|&&
name|this_smp_phy
operator|->
name|attached_device_type
operator|!=
name|SMP_FANOUT_EXPANDER_DEVICE
condition|)
block|{
comment|//note, end_device field could be an end device, or a NULL value, but can't be expander device.
name|this_smp_phy
operator|->
name|u
operator|.
name|end_device
operator|=
name|attached_device
expr_stmt|;
block|}
else|else
block|{
comment|//if attached device type is expander, we will set u.attached_phy later when the
comment|//the attached expander finish its discover on attached_phy.
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This routine constructs a smp phy object for an expander phy.  * @param[in] this_smp_phy The memory space to store a phy  * @param[in] owning_device The smp remote device that owns this smp phy.  * @param[in] discover_response The smp DISCOVER response for this_smp_phy.  *  * @return Whether a smp phy has an attached phy and the pair of phy are set  *            set to each other as attached phy successfully.  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_smp_phy_set_attached_phy
parameter_list|(
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|this_smp_phy
parameter_list|,
name|U8
name|attached_phy_identifier
parameter_list|,
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|attached_remote_device
parameter_list|)
block|{
comment|//find the attached phy from its owning device by attached_phy_id.
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|attached_smp_phy
init|=
operator|(
name|SCIF_SAS_SMP_PHY_T
operator|*
operator|)
name|scif_sas_smp_remote_device_find_smp_phy_by_id
argument_list|(
name|attached_phy_identifier
argument_list|,
operator|&
name|attached_remote_device
operator|->
name|protocol_device
operator|.
name|smp_device
argument_list|)
decl_stmt|;
if|if
condition|(
name|attached_smp_phy
operator|!=
name|NULL
condition|)
block|{
name|this_smp_phy
operator|->
name|u
operator|.
name|attached_phy
operator|=
name|attached_smp_phy
expr_stmt|;
name|attached_smp_phy
operator|->
name|u
operator|.
name|attached_phy
operator|=
name|this_smp_phy
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
return|return
name|SCI_FAILURE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method verify the routing attributes of a phy connection per  *        specification.  *  * @param[in] this_smp_phy One smp phy belongs to a smp phy connection.  * @param[in] attached_smp_phy One smp phy belongs to a smp phy connection.  *  * @return Whether routing attributes of a phy connection is legal.  * @retval SCI_SUCCESS indicates a good phy connection.  *         SCI_FAILURE indicates a illegal phy connection.  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_smp_phy_verify_routing_attribute
parameter_list|(
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|this_smp_phy
parameter_list|,
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|attached_smp_phy
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
comment|//expander phy with direct routing attribute can only connect to
comment|//phy with direct routing attribute.
if|if
condition|(
name|this_smp_phy
operator|->
name|routing_attribute
operator|==
name|DIRECT_ROUTING_ATTRIBUTE
operator|||
name|attached_smp_phy
operator|->
name|routing_attribute
operator|==
name|DIRECT_ROUTING_ATTRIBUTE
condition|)
block|{
if|if
condition|(
operator|(
name|this_smp_phy
operator|->
name|routing_attribute
operator||
name|attached_smp_phy
operator|->
name|routing_attribute
operator|)
operator|!=
name|DIRECT_ROUTING_ATTRIBUTE
condition|)
name|status
operator|=
name|SCI_FAILURE
expr_stmt|;
block|}
if|if
condition|(
name|this_smp_phy
operator|->
name|routing_attribute
operator|==
name|TABLE_ROUTING_ATTRIBUTE
operator|&&
name|attached_smp_phy
operator|->
name|routing_attribute
operator|==
name|TABLE_ROUTING_ATTRIBUTE
condition|)
block|{
if|if
condition|(
operator|!
name|this_smp_phy
operator|->
name|owning_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_table_to_table_supported
operator|||
operator|!
name|attached_smp_phy
operator|->
name|owning_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_table_to_table_supported
condition|)
name|status
operator|=
name|SCI_FAILURE
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method find The next smp phy that is in the smp phy list and  *           resides in the same wide port as this_smp_phy.  *  * @param[in] this_smp_phy The smp phy whose neighbor phy that is in the same  *               same wide port is to be find.  *  * @return The next smp phy that is in the smp phy list and resides in the same  *            wide port as this_smp_phy.  */
end_comment

begin_function
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|scif_sas_smp_phy_find_next_phy_in_wide_port
parameter_list|(
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|this_smp_phy
parameter_list|)
block|{
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|next_phy_element
init|=
name|sci_fast_list_get_next
argument_list|(
operator|&
operator|(
name|this_smp_phy
operator|->
name|list_element
operator|)
argument_list|)
decl_stmt|;
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|next_phy
decl_stmt|;
while|while
condition|(
name|next_phy_element
operator|!=
name|NULL
condition|)
block|{
name|next_phy
operator|=
operator|(
name|SCIF_SAS_SMP_PHY_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|next_phy_element
argument_list|)
expr_stmt|;
name|next_phy_element
operator|=
name|sci_fast_list_get_next
argument_list|(
operator|&
operator|(
name|next_phy
operator|->
name|list_element
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_phy
operator|->
name|attached_sas_address
operator|.
name|high
operator|==
name|this_smp_phy
operator|->
name|attached_sas_address
operator|.
name|high
operator|&&
name|next_phy
operator|->
name|attached_sas_address
operator|.
name|low
operator|==
name|this_smp_phy
operator|->
name|attached_sas_address
operator|.
name|low
condition|)
return|return
name|next_phy
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method find the smp phy that resides in the middle of the same  *        wide port as this_smp_phy.  *  * @param[in] this_smp_phy The smp phy who is the lowest order phy in a wide  *       port .  *  * @return The next smp phy that is in the smp phy list and resides in the same  *            wide port as this_smp_phy.  */
end_comment

begin_function
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|scif_sas_smp_phy_find_middle_phy_in_wide_port
parameter_list|(
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|this_smp_phy
parameter_list|)
block|{
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|next_phy
init|=
name|scif_sas_smp_phy_find_next_phy_in_wide_port
argument_list|(
name|this_smp_phy
argument_list|)
decl_stmt|;
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|middle_phy
init|=
name|this_smp_phy
decl_stmt|;
comment|//currently we assume a wide port could not be wider than X4. so the
comment|//second phy is always the correct answer for x2, x3 or x4 wide port.
comment|//For a narrow port, phy0 is the middle phy.
if|if
condition|(
name|next_phy
operator|!=
name|NULL
condition|)
block|{
name|middle_phy
operator|=
name|next_phy
expr_stmt|;
name|next_phy
operator|=
name|scif_sas_smp_phy_find_next_phy_in_wide_port
argument_list|(
name|next_phy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next_phy
operator|!=
name|NULL
condition|)
name|middle_phy
operator|=
name|next_phy
expr_stmt|;
return|return
name|middle_phy
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method find the smp phy that is the hishest order phy  *           in the same wide port as this_smp_phy.  *  * @param[in] this_smp_phy The smp phy who is the lowest order phy in a wide  *       port.  *  * @return The next smp phy that is in the smp phy list and resides in the same  *            wide port as this_smp_phy.  */
end_comment

begin_function
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|scif_sas_smp_phy_find_highest_phy_in_wide_port
parameter_list|(
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|this_smp_phy
parameter_list|)
block|{
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|next_phy
init|=
name|scif_sas_smp_phy_find_next_phy_in_wide_port
argument_list|(
name|this_smp_phy
argument_list|)
decl_stmt|;
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|highest_phy
init|=
name|this_smp_phy
decl_stmt|;
while|while
condition|(
name|next_phy
operator|!=
name|NULL
condition|)
block|{
name|highest_phy
operator|=
name|next_phy
expr_stmt|;
name|next_phy
operator|=
name|scif_sas_smp_phy_find_next_phy_in_wide_port
argument_list|(
name|next_phy
argument_list|)
expr_stmt|;
block|}
return|return
name|highest_phy
return|;
block|}
end_function

end_unit

