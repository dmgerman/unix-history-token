begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  *  * @brief This file contains all of the entrance and exit methods for each  *        of the domain states defined by the SCI_BASE_DOMAIN state  *        machine.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_sas.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_port.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_logger.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_domain.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_controller.h>
end_include

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* P R O T E C T E D    M E T H O D S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method will attempt to transition to the stopped state.  *        The transition will only occur if the criteria for transition is  *        met (i.e. all IOs are complete and all devices are stopped).  *  * @param[in]  fw_domain This parameter specifies the domain in which to  *             to attempt to perform the transition.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_domain_transition_to_stopped_state
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_domain_transition_to_stopped_state(0x%x) enter\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
comment|// If IOs are quiesced, and all remote devices are stopped,
comment|// then transition directly to the STOPPED state.
if|if
condition|(
operator|(
name|fw_domain
operator|->
name|request_list
operator|.
name|element_count
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fw_domain
operator|->
name|device_start_count
operator|==
literal|0
operator|)
condition|)
block|{
name|SCIF_LOG_INFO
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"Domain:0x%x immediate transition to STOPPED\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_DOMAIN_STATE_STOPPED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method is called upon entrance to all states where the  *        previous state may have been the DISCOVERING state.  *        We issue the scif_cb_domain_discovery_complete() notification  *        from this method, assuming pre-requisites are met, as opposed  *        to in the exit handler of the DISCOVERING state, so that the  *        appropriate state handlers are in place should the user decide  *        to call scif_domain_discover() again.  *  * @param[in]  fw_domain This parameter specifies the domain for which  *             the state transition has occurred.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scif_sas_domain_transition_from_discovering_state
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_domain_transition_from_discovering_state(0x%x) enter\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|previous_state_id
operator|==
name|SCI_BASE_DOMAIN_STATE_DISCOVERING
condition|)
block|{
name|scif_sas_controller_restore_interrupt_coalescence
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|)
expr_stmt|;
name|scif_cb_timer_stop
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
operator|->
name|operation
operator|.
name|timer
argument_list|)
expr_stmt|;
name|scif_cb_domain_discovery_complete
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|,
name|fw_domain
operator|->
name|operation
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method is called upon entrance to DISCOVERING state. Right before  *           transitioning to DISCOVERING state, we temporarily change interrupt  *           coalescence scheme.  *  * @param[in]  fw_domain This parameter specifies the domain for which  *             the state transition has occurred.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_domain_transition_to_discovering_state
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|scif_sas_controller_save_interrupt_coalescence
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_DOMAIN_STATE_DISCOVERING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method implements the actions taken when entering the  *        INITIAL state.  *  * @param[in]  object This parameter specifies the base object for which  *             the state transition is occurring.  This is cast into a  *             SCIF_SAS_DOMAIN object in the method implementation.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scif_sas_domain_initial_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|object
decl_stmt|;
name|SET_STATE_HANDLER
argument_list|(
name|fw_domain
argument_list|,
name|scif_sas_domain_state_handler_table
argument_list|,
name|SCI_BASE_DOMAIN_STATE_INITIAL
argument_list|)
expr_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"scif_sas_domain_initial_state_enter(0x%x) enter\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method implements the actions taken when entering the  *        STARTING state.  This includes setting the state handlers and  *        checking to see if the core port has already become READY.  *  * @param[in]  object This parameter specifies the base object for which  *             the state transition is occurring.  This is cast into a  *             SCIF_SAS_DOMAIN object in the method implementation.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scif_sas_domain_starting_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|object
decl_stmt|;
name|SET_STATE_HANDLER
argument_list|(
name|fw_domain
argument_list|,
name|scif_sas_domain_state_handler_table
argument_list|,
name|SCI_BASE_DOMAIN_STATE_STARTING
argument_list|)
expr_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_domain_starting_state_enter(0x%x) enter\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
name|scif_sas_domain_transition_from_discovering_state
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
comment|// If we entered the STARTING state and the core port is actually ready,
comment|// then directly transition into the READY state.  This can occur
comment|// if we were in the middle of discovery when the port failed
comment|// (causing a transition to STOPPING), then before reaching STOPPED
comment|// the port becomes ready again.
if|if
condition|(
name|fw_domain
operator|->
name|is_port_ready
operator|==
name|TRUE
condition|)
block|{
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_DOMAIN_STATE_READY
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method implements the actions taken when entering the  *        READY state.  If the transition into this state came from:  *        - the STARTING state, then alert the user via a  *          scif_cb_domain_change_notification() that the domain  *          has at least 1 device ready for discovery.  *        - the DISCOVERING state, then alert the user that  *          discovery is complete via the  *          scif_cb_domain_discovery_complete() notification that  *          discovery is finished.  *  * @param[in]  object This parameter specifies the base object for which  *             the state transition is occurring.  This is cast into a  *             SCIF_SAS_DOMAIN object in the method implementation.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scif_sas_domain_ready_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|object
decl_stmt|;
name|SET_STATE_HANDLER
argument_list|(
name|fw_domain
argument_list|,
name|scif_sas_domain_state_handler_table
argument_list|,
name|SCI_BASE_DOMAIN_STATE_READY
argument_list|)
expr_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_domain_ready_state_enter(0x%x) enter\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|previous_state_id
operator|==
name|SCI_BASE_DOMAIN_STATE_STARTING
condition|)
block|{
name|scif_cb_domain_ready
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|)
expr_stmt|;
comment|// Only indicate the domain change notification if the previous
comment|// state was the STARTING state.  We issue the notification here
comment|// as opposed to exit of the STARTING state so that the appropriate
comment|// state handlers are in place should the user call
comment|// scif_domain_discover() from scif_cb_domain_change_notification()
name|scif_cb_domain_change_notification
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|previous_state_id
operator|==
name|SCI_BASE_DOMAIN_STATE_DISCOVERING
condition|)
block|{
comment|//if domain discovery timed out, we will NOT go back to discover even
comment|//the broadcast change count is not zero. Instead we finish the discovery
comment|//back to user. User can check the operation status and decide to
comment|//retry discover all over again.
if|if
condition|(
name|fw_domain
operator|->
name|operation
operator|.
name|status
operator|==
name|SCI_FAILURE_TIMEOUT
condition|)
name|fw_domain
operator|->
name|broadcast_change_count
operator|=
literal|0
expr_stmt|;
comment|// Check the broadcast change count to determine if discovery
comment|// is indeed complete.
if|if
condition|(
name|fw_domain
operator|->
name|broadcast_change_count
operator|==
literal|0
condition|)
block|{
name|scif_sas_domain_transition_from_discovering_state
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
name|scif_cb_domain_ready
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The broadcast change count indicates something my have
comment|// changed in the domain, while a discovery was ongoing.
comment|// Thus, we should start discovery over again.
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_DOMAIN_STATE_DISCOVERING
argument_list|)
expr_stmt|;
block|}
comment|// Enable the BCN because underneath hardware may disabled any further
comment|// BCN.
name|scic_port_enable_broadcast_change_notification
argument_list|(
name|fw_domain
operator|->
name|core_object
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method implements the actions taken when exiting the  *        READY state.  *  * @param[in]  object This parameter specifies the base object for which  *             the state transition is occurring.  This is cast into a  *             SCIF_SAS_DOMAIN object in the method implementation.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scif_sas_domain_ready_state_exit
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|object
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_domain_ready_state_exit(0x%x) enter\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
name|scif_cb_domain_not_ready
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method implements the actions taken when entering the  *        STOPPING state.  *  * @param[in]  object This parameter specifies the base object for which  *             the state transition is occurring.  This is cast into a  *             SCIF_SAS_DOMAIN object in the method implementation.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scif_sas_domain_stopping_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
decl_stmt|;
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|object
decl_stmt|;
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|element
init|=
name|sci_abstract_list_get_front
argument_list|(
operator|&
name|fw_domain
operator|->
name|remote_device_list
argument_list|)
decl_stmt|;
name|SET_STATE_HANDLER
argument_list|(
name|fw_domain
argument_list|,
name|scif_sas_domain_state_handler_table
argument_list|,
name|SCI_BASE_DOMAIN_STATE_STOPPING
argument_list|)
expr_stmt|;
comment|// This must be invoked after the state handlers are set to ensure
comment|// appropriate processing will occur if the user attempts to perform
comment|// additional actions.
name|scif_sas_domain_transition_from_discovering_state
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_domain_stopping_state_enter(0x%x) enter\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
name|scif_sas_high_priority_request_queue_purge_domain
argument_list|(
operator|&
name|fw_domain
operator|->
name|controller
operator|->
name|hprq
argument_list|,
name|fw_domain
argument_list|)
expr_stmt|;
comment|// Search the domain's list of devices and put them all in the STOPPING
comment|// state.
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|fw_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|sci_abstract_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|// This method will stop the core device.  The core will terminate
comment|// all IO requests currently outstanding.
name|fw_device
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|stop_handler
argument_list|(
operator|&
name|fw_device
operator|->
name|parent
argument_list|)
expr_stmt|;
name|element
operator|=
name|sci_abstract_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
comment|// Attempt to transition to the stopped state.
name|scif_sas_domain_transition_to_stopped_state
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method implements the actions taken when entering the  *        STOPPED state.  *  * @param[in]  object This parameter specifies the base object for which  *             the state transition is occurring.  This is cast into a  *             SCIF_SAS_DOMAIN object in the method implementation.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scif_sas_domain_stopped_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|object
decl_stmt|;
name|SET_STATE_HANDLER
argument_list|(
name|fw_domain
argument_list|,
name|scif_sas_domain_state_handler_table
argument_list|,
name|SCI_BASE_DOMAIN_STATE_STOPPED
argument_list|)
expr_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_domain_stopped_state_enter(0x%x) enter\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
comment|// A hot unplug of the direct attached device has occurred.  Thus,
comment|// notify the user. Note, if the controller is not in READY state,
comment|// mostly likely the controller is in STOPPING or STOPPED state,
comment|// meaning the controller is in the process of stopping, we should
comment|// not call back to user in the middle of controller stopping.
if|if
condition|(
name|fw_domain
operator|->
name|controller
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_CONTROLLER_STATE_READY
condition|)
name|scif_cb_domain_change_notification
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method implements the actions taken when entering the  *        DISCOVERING state.  This includes determining from which  *        state we entered.  If we entered from stopping that some sort  *        of hot-remove of the port occurred.  In the hot-remove case  *        all devices should be in the STOPPED state already and, as  *        a result, are removed from the domain with a notification sent  *        to the framework user.  *  * @note This method currently only handles hot-insert/hot-remove of  *       direct attached SSP devices.  *  * @param[in]  object This parameter specifies the base object for which  *             the state transition is occurring.  This is cast into a  *             SCIF_SAS_DOMAIN object in the method implementation.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scif_sas_domain_discovering_state_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|object
decl_stmt|;
name|SET_STATE_HANDLER
argument_list|(
name|fw_domain
argument_list|,
name|scif_sas_domain_state_handler_table
argument_list|,
name|SCI_BASE_DOMAIN_STATE_DISCOVERING
argument_list|)
expr_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_domain_discovering_state_enter(0x%x) enter\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
name|fw_domain
operator|->
name|broadcast_change_count
operator|=
literal|0
expr_stmt|;
comment|// Did the domain just go through a port not ready action?  If it did,
comment|// then we will be entering from the STOPPED state.
if|if
condition|(
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|previous_state_id
operator|!=
name|SCI_BASE_DOMAIN_STATE_STOPPED
condition|)
block|{
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|remote_device
decl_stmt|;
name|SCIC_PORT_PROPERTIES_T
name|properties
decl_stmt|;
name|scic_port_get_properties
argument_list|(
name|fw_domain
operator|->
name|core_object
argument_list|,
operator|&
name|properties
argument_list|)
expr_stmt|;
comment|// If the device has not yet been added to the domain, then
comment|// inform the user that the device is new.
name|remote_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|scif_domain_get_device_by_sas_address
argument_list|(
name|fw_domain
argument_list|,
operator|&
name|properties
operator|.
name|remote
operator|.
name|sas_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_device
operator|==
name|SCI_INVALID_HANDLE
condition|)
block|{
comment|// simply notify the user of the new DA device and be done
comment|// with discovery.
name|scif_cb_domain_da_device_added
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|,
operator|&
name|properties
operator|.
name|remote
operator|.
name|sas_address
argument_list|,
operator|&
name|properties
operator|.
name|remote
operator|.
name|protocols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|properties
operator|.
name|remote
operator|.
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|smp_target
condition|)
comment|//kick off the smp discover process.
name|scif_sas_domain_start_smp_discover
argument_list|(
name|fw_domain
argument_list|,
name|remote_device
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|//entered from STOPPED state.
block|{
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|current_element
init|=
name|sci_abstract_list_get_front
argument_list|(
operator|&
operator|(
name|fw_domain
operator|->
name|remote_device_list
operator|)
argument_list|)
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
decl_stmt|;
while|while
condition|(
name|current_element
operator|!=
name|NULL
condition|)
block|{
name|fw_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|sci_abstract_list_get_object
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fw_device
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_REMOTE_DEVICE_STATE_STOPPED
argument_list|)
expr_stmt|;
name|current_element
operator|=
name|sci_abstract_list_get_next
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
name|SCIF_LOG_INFO
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"Controller:0x%x Domain:0x%x Device:0x%x removed\n"
operator|,
name|fw_domain
operator|->
name|controller
operator|,
name|fw_domain
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
comment|// Notify the framework user of the device removal.
name|scif_cb_domain_device_removed
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|,
name|fw_device
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|fw_domain
operator|->
name|request_list
operator|.
name|element_count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|sci_abstract_list_size
argument_list|(
operator|&
name|fw_domain
operator|->
name|remote_device_list
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_DOMAIN_STATE_STARTING
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|SCI_BASE_STATE_T
name|scif_sas_domain_state_table
index|[
name|SCI_BASE_DOMAIN_MAX_STATES
index|]
init|=
block|{
block|{
name|SCI_BASE_DOMAIN_STATE_INITIAL
block|,
name|scif_sas_domain_initial_state_enter
block|,
name|NULL
block|,    }
block|,
block|{
name|SCI_BASE_DOMAIN_STATE_STARTING
block|,
name|scif_sas_domain_starting_state_enter
block|,
name|NULL
block|,    }
block|,
block|{
name|SCI_BASE_DOMAIN_STATE_READY
block|,
name|scif_sas_domain_ready_state_enter
block|,
name|scif_sas_domain_ready_state_exit
block|,    }
block|,
block|{
name|SCI_BASE_DOMAIN_STATE_STOPPING
block|,
name|scif_sas_domain_stopping_state_enter
block|,
name|NULL
block|,    }
block|,
block|{
name|SCI_BASE_DOMAIN_STATE_STOPPED
block|,
name|scif_sas_domain_stopped_state_enter
block|,
name|NULL
block|,    }
block|,
block|{
name|SCI_BASE_DOMAIN_STATE_DISCOVERING
block|,
name|scif_sas_domain_discovering_state_enter
block|,
name|NULL
block|,    }
block|}
decl_stmt|;
end_decl_stmt

end_unit

