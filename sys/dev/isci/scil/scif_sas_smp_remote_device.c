begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  *  * @brief This file contains the methods for the SCIF_SAS_SMP_REMOTE_DEVICE object.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_logger.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_smp_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_smp_io_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_sas.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_io_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_smp_phy.h>
end_include

begin_comment
comment|/**  * @brief This method resets all fields for a smp remote device. This is a  *        private method.  *  * @param[in] fw_device the framework SMP device that is being  *            constructed.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_clear
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
comment|//reset all fields in smp_device, indicate that the smp device is not
comment|//in discovery process.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_NONE
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|=
name|NOT_IN_SMP_ACTIVITY
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
operator|=
literal|0
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_index
operator|=
literal|0
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
operator|=
name|NULL
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_route_table_cleaned
operator|=
name|FALSE
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_destination_smp_phy
operator|=
name|NULL
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|scheduled_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_NONE
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|io_retry_count
operator|=
literal|0
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_clear_affiliation_phy
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
operator|!=
name|NULL
condition|)
block|{
comment|//stop the timer
name|scif_cb_timer_stop
argument_list|(
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
argument_list|)
expr_stmt|;
comment|//destroy the timer
name|scif_cb_timer_destroy
argument_list|(
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
argument_list|)
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method intializes a smp remote device.  *  * @param[in] fw_device the framework SMP device that is being  *            constructed.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_construct
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator|,
literal|"scif_sas_smp_remote_device_construct(0x%x) enter\n"
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|number_of_phys
operator|=
literal|0
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|expander_route_indexes
operator|=
literal|0
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_table_to_table_supported
operator|=
name|FALSE
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_externally_configurable
operator|=
name|FALSE
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_able_to_config_others
operator|=
name|FALSE
expr_stmt|;
name|sci_fast_list_init
argument_list|(
operator|&
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_phy_list
argument_list|)
expr_stmt|;
name|scif_sas_smp_remote_device_clear
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method decodes a smp response to this smp device and then  *        continue the smp discover process.  *  * @param[in] fw_device The framework device that a SMP response targets to.  * @param[in] fw_request The pointer to an smp request whose response  *       is to be decoded.  * @param[in] response_data The response data passed in.  *  * @return none  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_smp_remote_device_decode_smp_response
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SCIF_SAS_REQUEST_T
modifier|*
name|fw_request
parameter_list|,
name|void
modifier|*
name|response_data
parameter_list|,
name|SCI_IO_STATUS
name|completion_status
parameter_list|)
block|{
name|SMP_RESPONSE_T
modifier|*
name|smp_response
init|=
operator|(
name|SMP_RESPONSE_T
operator|*
operator|)
name|response_data
decl_stmt|;
name|SCI_STATUS
name|status
init|=
name|SCI_FAILURE_UNSUPPORTED_INFORMATION_TYPE
decl_stmt|;
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
operator|!=
name|NULL
condition|)
block|{
comment|//if there is a timer being used, recycle it now. Since we may
comment|//use the timer for other purpose next.
name|scif_cb_timer_destroy
argument_list|(
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
argument_list|)
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
operator|=
name|NULL
expr_stmt|;
block|}
comment|//if Core set the status of this io to be RETRY_REQUIRED, we should
comment|//retry the IO without even decode the response.
if|if
condition|(
name|completion_status
operator|==
name|SCI_FAILURE_RETRY_REQUIRED
condition|)
block|{
name|scif_sas_smp_remote_device_continue_current_activity
argument_list|(
name|fw_device
argument_list|,
name|fw_request
argument_list|,
name|SCI_FAILURE_RETRY_REQUIRED
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_RETRY_REQUIRED
return|;
block|}
comment|//check the current smp request, decide what's next smp request to issue.
switch|switch
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
condition|)
block|{
case|case
name|SMP_FUNCTION_REPORT_GENERAL
case|:
block|{
comment|//interpret REPORT GENERAL response.
name|status
operator|=
name|scif_sas_smp_remote_device_decode_report_general_response
argument_list|(
name|fw_device
argument_list|,
name|smp_response
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SMP_FUNCTION_REPORT_MANUFACTURER_INFORMATION
case|:
block|{
comment|// No need to perform any parsing.  Just want to see
comment|// the information in a trace if necessary.
name|status
operator|=
name|SCI_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|SMP_FUNCTION_DISCOVER
case|:
block|{
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|==
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_DISCOVER
condition|)
block|{
comment|//decode discover response
name|status
operator|=
name|scif_sas_smp_remote_device_decode_initial_discover_response
argument_list|(
name|fw_device
argument_list|,
name|smp_response
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|==
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_TARGET_RESET
condition|)
block|{
comment|//decode discover response as a polling result for a remote device
comment|//target reset.
name|status
operator|=
name|scif_sas_smp_remote_device_decode_target_reset_discover_response
argument_list|(
name|fw_device
argument_list|,
name|smp_response
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|==
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_SATA_SPINUP_HOLD_RELEASE
condition|)
block|{
comment|//decode discover response
name|status
operator|=
name|scif_sas_smp_remote_device_decode_spinup_hold_release_discover_response
argument_list|(
name|fw_device
argument_list|,
name|smp_response
argument_list|)
expr_stmt|;
block|}
else|else
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SMP_FUNCTION_REPORT_PHY_SATA
case|:
block|{
comment|//decode the report phy sata response.
name|status
operator|=
name|scif_sas_smp_remote_device_decode_report_phy_sata_response
argument_list|(
name|fw_device
argument_list|,
name|smp_response
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SMP_FUNCTION_PHY_CONTROL
case|:
block|{
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|==
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_DISCOVER
condition|)
block|{
comment|//decode the phy control response.
name|status
operator|=
name|scif_sas_smp_remote_device_decode_discover_phy_control_response
argument_list|(
name|fw_device
argument_list|,
name|smp_response
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|==
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_TARGET_RESET
condition|)
block|{
comment|//decode discover response as a polling result for a remote device
comment|//target reset.
name|status
operator|=
name|scif_sas_smp_remote_device_decode_target_reset_phy_control_response
argument_list|(
name|fw_device
argument_list|,
name|smp_response
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|==
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_CLEAR_AFFILIATION
condition|)
block|{
comment|//currently don't care about the status.
name|status
operator|=
name|SCI_SUCCESS
expr_stmt|;
block|}
else|else
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SMP_FUNCTION_CONFIGURE_ROUTE_INFORMATION
case|:
block|{
comment|//Note, currently we don't expect any abnormal status from config route info response,
comment|//but there is a possibility that we exceed the maximum route index. We will take care
comment|//of errors later.
name|status
operator|=
name|scif_sas_smp_remote_device_decode_config_route_info_response
argument_list|(
name|fw_device
argument_list|,
name|smp_response
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|//unsupported case, TBD
name|status
operator|=
name|SCI_FAILURE_UNSUPPORTED_INFORMATION_TYPE
expr_stmt|;
break|break;
block|}
comment|//end of switch
comment|//Continue current activity based on response's decoding status.
name|scif_sas_smp_remote_device_continue_current_activity
argument_list|(
name|fw_device
argument_list|,
name|fw_request
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method decodes a smp Report Genernal response to this smp device  *        and then continue the smp discover process.  *  * @param[in] fw_device The framework device that the REPORT GENERAL command  *       targets to.  * @param[in] report_general_response The pointer to a report general response  *  * @return none  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_smp_remote_device_decode_report_general_response
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SMP_RESPONSE_T
modifier|*
name|smp_response
parameter_list|)
block|{
name|SMP_RESPONSE_REPORT_GENERAL_T
modifier|*
name|report_general_response
init|=
operator|&
name|smp_response
operator|->
name|response
operator|.
name|report_general
decl_stmt|;
name|SMP_RESPONSE_HEADER_T
modifier|*
name|response_header
init|=
operator|&
name|smp_response
operator|->
name|header
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_decode_report_general_response(0x%x, 0x%x) enter\n"
operator|,
name|fw_device
operator|,
name|smp_response
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|response_header
operator|->
name|function_result
operator|!=
name|SMP_RESULT_FUNCTION_ACCEPTED
condition|)
block|{
comment|/// @todo: more decoding work needed when the function_result is not
comment|/// SMP_RESULT_FUNCTION_ACCEPTED. Retry might be the option for some
comment|/// function result.
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"Report General function result(0x%x)\n"
operator|,
name|response_header
operator|->
name|function_result
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE
return|;
block|}
comment|//get info from report general response.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|number_of_phys
operator|=
operator|(
name|U8
operator|)
name|report_general_response
operator|->
name|number_of_phys
expr_stmt|;
comment|//currently there is byte swap issue in U16 data.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|expander_route_indexes
operator|=
operator|(
operator|(
name|report_general_response
operator|->
name|expander_route_indexes
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|report_general_response
operator|->
name|expander_route_indexes
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_table_to_table_supported
operator|=
operator|(
name|BOOL
operator|)
name|report_general_response
operator|->
name|table_to_table_supported
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_externally_configurable
operator|=
operator|(
name|BOOL
operator|)
name|report_general_response
operator|->
name|configurable_route_table
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_able_to_config_others
operator|=
operator|(
name|BOOL
operator|)
name|report_general_response
operator|->
name|configures_others
expr_stmt|;
comment|//If the top level expander of a domain is able to configure others,
comment|//no config route table is needed in the domain. Or else,
comment|//we'll let all the externally configurable expanders in the damain
comment|//configure route table.
if|if
condition|(
name|fw_device
operator|->
name|containing_device
operator|==
name|NULL
operator|&&
operator|!
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_able_to_config_others
condition|)
name|fw_device
operator|->
name|domain
operator|->
name|is_config_route_table_needed
operator|=
name|TRUE
expr_stmt|;
comment|//knowing number of phys this expander has, we can allocate all the smp phys for
comment|//this expander now if it is not done already.
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_phy_list
operator|.
name|element_count
operator|==
literal|0
condition|)
name|scif_sas_smp_remote_device_populate_smp_phy_list
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
if|if
condition|(
name|report_general_response
operator|->
name|configuring
condition|)
return|return
name|SCI_FAILURE_RETRY_REQUIRED
return|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method decodes a smp Discover response to this smp device  *        and then continue the smp discover process. This is only ever  *        called for the very first discover stage during a given domain  *        discovery process.  *  * @param[in] fw_device The framework device that the DISCOVER command  *       targets to.  * @param[in] discover_response The pointer to a DISCOVER response  *  * @return none  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_smp_remote_device_decode_initial_discover_response
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SMP_RESPONSE_T
modifier|*
name|smp_response
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
name|fw_device
operator|->
name|domain
decl_stmt|;
name|SCI_SAS_ADDRESS_T
name|attached_device_address
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|attached_remote_device
decl_stmt|;
name|SMP_RESPONSE_DISCOVER_T
modifier|*
name|discover_response
init|=
operator|&
name|smp_response
operator|->
name|response
operator|.
name|discover
decl_stmt|;
name|SMP_RESPONSE_HEADER_T
modifier|*
name|response_header
init|=
operator|&
name|smp_response
operator|->
name|header
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_decode_initial_discover_response(0x%x, 0x%x) enter\n"
operator|,
name|fw_device
operator|,
name|smp_response
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|response_header
operator|->
name|function_result
operator|==
name|SMP_RESULT_PHY_VACANT
condition|)
block|{
return|return
name|SCI_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
name|response_header
operator|->
name|function_result
operator|!=
name|SMP_RESULT_FUNCTION_ACCEPTED
condition|)
block|{
comment|/// @todo: more decoding work needed when the function_result is not
comment|/// SMP_RESULT_FUNCTION_ACCEPTED. Retry might be the option for some
comment|/// function result.
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"Discover function result(0x%x)\n"
operator|,
name|response_header
operator|->
name|function_result
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE
return|;
block|}
comment|//only if there is target device attached. We don't add device that is
comment|//initiator only.
if|if
condition|(
operator|(
name|discover_response
operator|->
name|u2
operator|.
name|sas1_1
operator|.
name|attached_device_type
operator|!=
name|SMP_NO_DEVICE_ATTACHED
operator|)
operator|&&
operator|(
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_ssp_target
operator|||
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_stp_target
operator|||
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_smp_target
operator|||
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_sata_device
operator|)
condition|)
block|{
name|attached_device_address
operator|=
name|discover_response
operator|->
name|attached_sas_address
expr_stmt|;
name|attached_remote_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|scif_domain_get_device_by_sas_address
argument_list|(
name|fw_domain
argument_list|,
operator|&
name|attached_device_address
argument_list|)
expr_stmt|;
comment|//need to check if the device already existed in the domian.
if|if
condition|(
name|attached_remote_device
operator|!=
name|SCI_INVALID_HANDLE
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_WIDE_PORTED_TARGETS
argument_list|)
if|if
condition|(
name|attached_remote_device
operator|->
name|is_currently_discovered
operator|==
name|TRUE
operator|&&
name|attached_remote_device
operator|!=
name|fw_device
operator|->
name|containing_device
condition|)
block|{
comment|//a downstream wide port target is found.
name|attached_remote_device
operator|->
name|device_port_width
operator|++
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|//#if !defined(DISABLE_WIDE_PORTED_TARGETS)
block|{
comment|//The device already existed. Mark the device as discovered.
name|attached_remote_device
operator|->
name|is_currently_discovered
operator|=
name|TRUE
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_WIDE_PORTED_TARGETS
argument_list|)
if|if
condition|(
name|attached_remote_device
operator|->
name|device_port_width
operator|!=
name|scic_remote_device_get_port_width
argument_list|(
name|attached_remote_device
operator|->
name|core_object
argument_list|)
operator|&&
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_ssp_target
condition|)
block|{
name|scif_sas_remote_device_update_port_width
argument_list|(
name|attached_remote_device
argument_list|,
name|attached_remote_device
operator|->
name|device_port_width
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//#if !defined(DISABLE_WIDE_PORTED_TARGETS)
if|if
condition|(
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_smp_target
operator|&&
name|attached_remote_device
operator|!=
name|fw_device
operator|->
name|containing_device
condition|)
block|{
comment|//another expander device is discovered. Its own smp discover will starts after
comment|//this discover finishes.
name|attached_remote_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|scheduled_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_DISCOVER
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//report the discovery of a disk for all types of end device.
name|scif_cb_domain_ea_device_added
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|,
name|fw_device
argument_list|,
name|discover_response
argument_list|)
expr_stmt|;
comment|//get info from discover response to see what we found. And do
comment|//extra work according to end device's protocol type.
if|if
condition|(
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_ssp_target
operator|||
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_smp_target
condition|)
block|{
comment|//for SSP or SMP target, no extra work.
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_stp_target
operator|)
operator|||
operator|(
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_sata_device
operator|)
condition|)
block|{
comment|// We treat a SATA Device bit the same as an attached STP
comment|// target.
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_stp_target
operator|=
literal|1
expr_stmt|;
comment|//kick off REPORT PHY SATA to the same phy.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|=
name|SMP_FUNCTION_REPORT_PHY_SATA
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|discover_response
operator|->
name|u2
operator|.
name|sas1_1
operator|.
name|negotiated_physical_link_rate
operator|==
name|SCI_SATA_SPINUP_HOLD
operator|||
name|discover_response
operator|->
name|u4
operator|.
name|sas2
operator|.
name|negotiated_physical_link_rate
operator|==
name|SCI_SATA_SPINUP_HOLD
operator|)
operator|&&
operator|(
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_stp_target
operator|||
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_sata_device
operator|)
condition|)
block|{
name|attached_remote_device
operator|=
name|scif_sas_domain_get_device_by_containing_device
argument_list|(
name|fw_domain
argument_list|,
name|fw_device
argument_list|,
name|discover_response
operator|->
name|phy_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|attached_remote_device
operator|!=
name|SCI_INVALID_HANDLE
condition|)
block|{
comment|//Here, the only reason a device already existed in domain but
comment|//the initial discover rersponse shows it in SPINUP_HOLD, is that
comment|//a device has been removed and coming back in SPINUP_HOLD before
comment|//we detected. The possibility of this situation is very very rare.
comment|//we need to remove the device then add it back using the new
comment|//discover response.
name|scif_cb_domain_device_removed
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|,
name|attached_remote_device
argument_list|)
expr_stmt|;
block|}
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_stp_target
operator|=
literal|1
expr_stmt|;
comment|//still report ea_device_added(). But this device will not be
comment|//started during scif_remote_device_ea_construct().
name|scif_cb_domain_ea_device_added
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|,
name|fw_device
argument_list|,
name|discover_response
argument_list|)
expr_stmt|;
comment|//need to send Phy Control (RESET) to release the phy from spinup hold
comment|//condition.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|=
name|SMP_FUNCTION_PHY_CONTROL
expr_stmt|;
block|}
comment|//update the smp phy info based on this DISCOVER response.
return|return
name|scif_sas_smp_remote_device_save_smp_phy_info
argument_list|(
name|fw_device
argument_list|,
name|discover_response
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method decodes a smp Report Phy Sata response to this  *        smp device and then continue the smp discover process.  *  * @param[in] fw_device The framework device that the REPORT PHY SATA  *       command targets to.  * @param[in] report_phy_sata_response The pointer to a REPORT PHY  *       SATA response  *  * @return none  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_smp_remote_device_decode_report_phy_sata_response
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SMP_RESPONSE_T
modifier|*
name|smp_response
parameter_list|)
block|{
name|SMP_RESPONSE_REPORT_PHY_SATA_T
modifier|*
name|report_phy_sata_response
init|=
operator|&
name|smp_response
operator|->
name|response
operator|.
name|report_phy_sata
decl_stmt|;
name|SMP_RESPONSE_HEADER_T
modifier|*
name|response_header
init|=
operator|&
name|smp_response
operator|->
name|header
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_decode_report_phy_sata_response(0x%x, 0x%x) enter\n"
operator|,
name|fw_device
operator|,
name|smp_response
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|response_header
operator|->
name|function_result
operator|!=
name|SMP_RESULT_FUNCTION_ACCEPTED
condition|)
block|{
comment|/// @todo: more decoding work needed when the function_result is not
comment|/// SMP_RESULT_FUNCTION_ACCEPTED. Retry might be the option for some
comment|/// function result.
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"Report Phy Sata function result(0x%x)\n"
operator|,
name|response_header
operator|->
name|function_result
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE
return|;
block|}
name|scif_sas_remote_device_save_report_phy_sata_information
argument_list|(
name|report_phy_sata_response
argument_list|)
expr_stmt|;
comment|// continue the discover process.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|=
name|SMP_FUNCTION_DISCOVER
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method decodes a smp Phy Control response to this smp device and  *        then continue the smp TARGET RESET process.  *  * @param[in] fw_device The framework device that the Phy Control command  *       targets to.  * @param[in] smp_response The pointer to a Phy Control response  * @param[in] fw_io The scif IO request that associates to this smp response.  *  * @return none  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_smp_remote_device_decode_target_reset_phy_control_response
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SMP_RESPONSE_T
modifier|*
name|smp_response
parameter_list|)
block|{
name|SMP_RESPONSE_HEADER_T
modifier|*
name|response_header
init|=
operator|&
name|smp_response
operator|->
name|header
decl_stmt|;
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_decode_target_reset_phy_control_response(0x%x, 0x%x) enter\n"
operator|,
name|fw_device
operator|,
name|smp_response
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|response_header
operator|->
name|function_result
operator|!=
name|SMP_RESULT_FUNCTION_ACCEPTED
condition|)
block|{
comment|/// @todo: more decoding work needed when the function_result is not
comment|/// SMP_RESULT_FUNCTION_ACCEPTED. Retry might be the option for some
comment|/// function result.
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"Phy Control function unaccepted result(0x%x)\n"
operator|,
name|response_header
operator|->
name|function_result
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|SCI_FAILURE_RETRY_REQUIRED
expr_stmt|;
block|}
comment|// phy Control succeeded.
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method decodes a smp Phy Control response to this smp device and  *        then continue the smp DISCOVER process.  *  * @param[in] fw_device The framework device that the Phy Control command  *       targets to.  * @param[in] smp_response The pointer to a Phy Control response  *  * @return Almost always SCI_SUCCESS  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_smp_remote_device_decode_discover_phy_control_response
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SMP_RESPONSE_T
modifier|*
name|smp_response
parameter_list|)
block|{
name|SMP_RESPONSE_HEADER_T
modifier|*
name|response_header
init|=
operator|&
name|smp_response
operator|->
name|header
decl_stmt|;
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_decode_discover_phy_control_response(0x%x, 0x%x) enter\n"
operator|,
name|fw_device
operator|,
name|smp_response
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|response_header
operator|->
name|function_result
operator|!=
name|SMP_RESULT_FUNCTION_ACCEPTED
condition|)
block|{
comment|/// @todo: more decoding work needed when the function_result is not
comment|/// SMP_RESULT_FUNCTION_ACCEPTED. Retry might be the option for some
comment|/// function result.
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"Phy Control function unaccepted result(0x%x)\n"
operator|,
name|response_header
operator|->
name|function_result
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_RETRY_REQUIRED
return|;
block|}
comment|// continue the discover process.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|=
name|SMP_FUNCTION_DISCOVER
expr_stmt|;
comment|// phy Control succeeded.
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method decodes a smp Discover response to this smp device  *        and then continue the smp discover process.  *  * @param[in] fw_device The framework device that the DISCOVER command  *       targets to.  * @param[in] discover_response The pointer to a DISCOVER response  *  * @return none  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_smp_remote_device_decode_target_reset_discover_response
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SMP_RESPONSE_T
modifier|*
name|smp_response
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
decl_stmt|;
name|SCI_SAS_ADDRESS_T
name|attached_device_address
decl_stmt|;
name|SMP_RESPONSE_DISCOVER_T
modifier|*
name|discover_response
init|=
operator|&
name|smp_response
operator|->
name|response
operator|.
name|discover
decl_stmt|;
name|SMP_RESPONSE_HEADER_T
modifier|*
name|response_header
init|=
operator|&
name|smp_response
operator|->
name|header
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_decode_target_reset_discover_response(0x%x, 0x%x) enter\n"
operator|,
name|fw_device
operator|,
name|smp_response
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|response_header
operator|->
name|function_result
operator|!=
name|SMP_RESULT_FUNCTION_ACCEPTED
condition|)
block|{
comment|/// @todo: more decoding work needed when the function_result is not
comment|/// SMP_RESULT_FUNCTION_ACCEPTED. Retry might be the option for some
comment|/// function result.
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"Discover function result(0x%x)\n"
operator|,
name|response_header
operator|->
name|function_result
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_RETRY_REQUIRED
return|;
block|}
comment|//only if there is device attached.
if|if
condition|(
name|discover_response
operator|->
name|u2
operator|.
name|sas1_1
operator|.
name|attached_device_type
operator|!=
name|SMP_NO_DEVICE_ATTACHED
condition|)
block|{
name|fw_domain
operator|=
name|fw_device
operator|->
name|domain
expr_stmt|;
name|attached_device_address
operator|=
name|discover_response
operator|->
name|attached_sas_address
expr_stmt|;
comment|// the device should have already existed in the domian.
name|ASSERT
argument_list|(
name|scif_domain_get_device_by_sas_address
argument_list|(
name|fw_domain
argument_list|,
operator|&
name|attached_device_address
argument_list|)
operator|!=
name|SCI_INVALID_HANDLE
argument_list|)
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
else|else
return|return
name|SCI_FAILURE_RETRY_REQUIRED
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method decodes a smp Discover response to this smp device  *        for SPINUP_HOLD_RELEASE activity. If a DISCOVER response says  *        SATA DEVICE ATTACHED and has a valid NPL value, we call fw_device's  *        start_handler(). But if a DISCOVER response still shows SPINUP  *        in NPL state, we need to return retry_required status  *  * @param[in] fw_device The framework device that the DISCOVER command  *       targets to.  * @param[in] discover_response The pointer to a DISCOVER response  *  * @return SCI_SUCCESS  *         SCI_FAILURE_RETRY_REQUIRED  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_smp_remote_device_decode_spinup_hold_release_discover_response
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SMP_RESPONSE_T
modifier|*
name|smp_response
parameter_list|)
block|{
name|SMP_RESPONSE_DISCOVER_T
modifier|*
name|discover_response
init|=
operator|&
name|smp_response
operator|->
name|response
operator|.
name|discover
decl_stmt|;
name|SMP_RESPONSE_HEADER_T
modifier|*
name|response_header
init|=
operator|&
name|smp_response
operator|->
name|header
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_decode_spinup_hold_release_discover_response(0x%x, 0x%x) enter\n"
operator|,
name|fw_device
operator|,
name|smp_response
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|response_header
operator|->
name|function_result
operator|!=
name|SMP_RESULT_FUNCTION_ACCEPTED
condition|)
block|{
comment|/// @todo: more decoding work needed when the function_result is not
comment|/// SMP_RESULT_FUNCTION_ACCEPTED. Retry might be the option for some
comment|/// function result.
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"Discover function result(0x%x)\n"
operator|,
name|response_header
operator|->
name|function_result
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE
return|;
block|}
if|if
condition|(
name|discover_response
operator|->
name|u2
operator|.
name|sas1_1
operator|.
name|attached_device_type
operator|!=
name|SMP_NO_DEVICE_ATTACHED
condition|)
block|{
if|if
condition|(
name|discover_response
operator|->
name|u2
operator|.
name|sas1_1
operator|.
name|negotiated_physical_link_rate
operator|!=
name|SCI_SATA_SPINUP_HOLD
operator|&&
name|discover_response
operator|->
name|u4
operator|.
name|sas2
operator|.
name|negotiated_physical_link_rate
operator|!=
name|SCI_SATA_SPINUP_HOLD
operator|&&
operator|(
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_stp_target
operator|||
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_sata_device
operator|)
condition|)
block|{
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|target_device
init|=
name|scif_sas_domain_get_device_by_containing_device
argument_list|(
name|fw_device
operator|->
name|domain
argument_list|,
name|fw_device
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
argument_list|)
decl_stmt|;
comment|//Need to update the device's connection rate. Its connection rate was SPINIP_HOLD.
name|scic_remote_device_set_max_connection_rate
argument_list|(
name|target_device
operator|->
name|core_object
argument_list|,
name|discover_response
operator|->
name|u2
operator|.
name|sas1_1
operator|.
name|negotiated_physical_link_rate
argument_list|)
expr_stmt|;
comment|//Need to update the smp phy info too.
name|scif_sas_smp_remote_device_save_smp_phy_info
argument_list|(
name|fw_device
argument_list|,
name|discover_response
argument_list|)
expr_stmt|;
comment|//This device has already constructed, only need to call start_handler
comment|//of this device here.
return|return
name|target_device
operator|->
name|state_handlers
operator|->
name|parent
operator|.
name|start_handler
argument_list|(
operator|&
name|target_device
operator|->
name|parent
argument_list|)
return|;
block|}
else|else
return|return
name|SCI_FAILURE_RETRY_REQUIRED
return|;
block|}
else|else
return|return
name|SCI_FAILURE_RETRY_REQUIRED
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method decodes a smp CONFIG ROUTE INFO response to this smp  *        device and then continue to config route table.  *  * @param[in] fw_device The framework device that the CONFIG ROUTE INFO command  *       targets to.  * @param[in] smp_response The pointer to a CONFIG ROUTE INFO response  *  * @return none  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_smp_remote_device_decode_config_route_info_response
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SMP_RESPONSE_T
modifier|*
name|smp_response
parameter_list|)
block|{
name|SMP_RESPONSE_HEADER_T
modifier|*
name|response_header
init|=
operator|&
name|smp_response
operator|->
name|header
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_decode_config_route_info_response(0x%x, 0x%x) enter\n"
operator|,
name|fw_device
operator|,
name|smp_response
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|response_header
operator|->
name|function_result
operator|==
name|SMP_RESULT_INDEX_DOES_NOT_EXIST
condition|)
block|{
comment|//case of exceeding max route index. We need to remove the devices that are not
comment|//able to be edit to route table. The destination config route smp phy
comment|//is used to remove devices.
name|scif_sas_smp_remote_device_cancel_config_route_table_activity
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_EXCEED_MAX_ROUTE_INDEX
return|;
block|}
elseif|else
if|if
condition|(
name|response_header
operator|->
name|function_result
operator|!=
name|SMP_RESULT_FUNCTION_ACCEPTED
condition|)
block|{
comment|/// @todo: more decoding work needed when the function_result is not
comment|/// SMP_RESULT_FUNCTION_ACCEPTED. Retry might be the option for some
comment|/// function result.
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"Discover function result(0x%x)\n"
operator|,
name|response_header
operator|->
name|function_result
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE
return|;
block|}
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method starts the smp Discover process for an expander by  *        sending Report General request.  *  * @param[in] fw_device The framework smp device that a  command  *       targets to.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_start_discover
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
name|fw_device
operator|->
name|domain
operator|->
name|controller
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_start_discover(0x%x) enter\n"
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
comment|//For safety, clear the device again, there may be some config route table
comment|//related info are not cleared yet.
name|scif_sas_smp_remote_device_clear
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
comment|//set current activity
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_DISCOVER
expr_stmt|;
comment|//Set current_smp_request to REPORT GENERAL.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|=
name|SMP_FUNCTION_REPORT_GENERAL
expr_stmt|;
comment|//reset discover_to_start flag.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|scheduled_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_NONE
expr_stmt|;
comment|//build the first smp request Report Genernal.
name|scif_sas_smp_request_construct_report_general
argument_list|(
name|fw_controller
argument_list|,
name|fw_device
argument_list|)
expr_stmt|;
comment|//issue DPC to start this request.
name|scif_cb_start_internal_io_task_schedule
argument_list|(
name|fw_controller
argument_list|,
name|scif_sas_controller_start_high_priority_io
argument_list|,
name|fw_controller
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method continues the smp Discover process.  *  * @param[in] fw_device The framework smp device that a DISCOVER command  *       targets to.  * @param[in] fw_request The pointer to an smp request whose response  *       has been decoded.  * @param[in] status The decoding status of the smp request's response  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_continue_current_activity
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SCIF_SAS_REQUEST_T
modifier|*
name|fw_request
parameter_list|,
name|SCI_STATUS
name|status
parameter_list|)
block|{
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
init|=
operator|(
name|SCIF_SAS_IO_REQUEST_T
operator|*
operator|)
name|fw_request
decl_stmt|;
comment|// save the retry count.
name|U8
name|io_retry_count
init|=
name|fw_io
operator|->
name|retry_count
decl_stmt|;
if|if
condition|(
name|fw_request
operator|->
name|is_internal
condition|)
block|{
comment|// Complete this internal io request now. We want to free this io before
comment|// we create another SMP request, which is going to happen soon.
name|scif_sas_internal_io_request_complete
argument_list|(
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
operator|(
name|SCIF_SAS_INTERNAL_IO_REQUEST_T
operator|*
operator|)
name|fw_request
argument_list|,
name|SCI_SUCCESS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|==
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_DISCOVER
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|//continue the discover process.
name|scif_sas_smp_remote_device_continue_discover
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|SCI_FAILURE_RETRY_REQUIRED
condition|)
block|{
comment|//Retry the smp request. Since we are in the middle of Discover
comment|//process, all the smp requests are internal. A new smp request
comment|//will be created for retry.
name|U32
name|retry_wait_duration
init|=
operator|(
name|SCIF_DOMAIN_DISCOVER_TIMEOUT
operator|/
literal|2
operator|)
operator|/
name|SCIF_SAS_IO_RETRY_LIMIT
decl_stmt|;
if|if
condition|(
name|io_retry_count
operator|<
name|SCIF_SAS_IO_RETRY_LIMIT
condition|)
name|scif_sas_smp_remote_device_retry_internal_io
argument_list|(
name|fw_device
argument_list|,
name|io_retry_count
argument_list|,
name|retry_wait_duration
argument_list|)
expr_stmt|;
else|else
name|scif_sas_smp_remote_device_fail_discover
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|SCI_FAILURE_ILLEGAL_ROUTING_ATTRIBUTE_CONFIGURATION
condition|)
block|{
comment|//remove this expander device and its child devices. No need to
comment|//continue the discover on this device.
name|scif_sas_domain_remove_expander_device
argument_list|(
name|fw_device
operator|->
name|domain
argument_list|,
name|fw_device
argument_list|)
expr_stmt|;
comment|//continue the domain's smp discover.
name|scif_sas_domain_continue_discover
argument_list|(
name|fw_device
operator|->
name|domain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//terminate the discover process.
name|scif_sas_smp_remote_device_fail_discover
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|==
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_TARGET_RESET
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|//continue the target reset process.
name|scif_sas_smp_remote_device_continue_target_reset
argument_list|(
name|fw_device
argument_list|,
name|fw_request
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|SCI_FAILURE_RETRY_REQUIRED
condition|)
block|{
comment|//Retry the same smp request. Since we are in the middle of Target
comment|//reset process, all the smp requests are using external resource.
comment|//We will use the exactly same memory to retry.
if|if
condition|(
name|io_retry_count
operator|<
name|SCIF_SAS_IO_RETRY_LIMIT
condition|)
block|{
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
operator|==
name|NULL
condition|)
block|{
comment|//create the timer to wait before retry.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
operator|=
name|scif_cb_timer_create
argument_list|(
operator|(
name|SCI_CONTROLLER_HANDLE_T
operator|*
operator|)
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
operator|(
name|SCI_TIMER_CALLBACK_T
operator|)
name|scif_sas_smp_external_request_retry
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fw_request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//start the timer to wait
name|scif_cb_timer_start
argument_list|(
operator|(
name|SCI_CONTROLLER_HANDLE_T
operator|)
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
argument_list|,
name|SMP_REQUEST_RETRY_WAIT_DURATION
comment|//20 miliseconds
argument_list|)
expr_stmt|;
block|}
else|else
name|scif_sas_smp_remote_device_fail_target_reset
argument_list|(
name|fw_device
argument_list|,
name|fw_request
argument_list|)
expr_stmt|;
block|}
else|else
comment|//terminate the discover process.
name|scif_sas_smp_remote_device_fail_target_reset
argument_list|(
name|fw_device
argument_list|,
name|fw_request
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|==
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_SATA_SPINUP_HOLD_RELEASE
condition|)
block|{
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|target_device
init|=
name|scif_sas_domain_get_device_by_containing_device
argument_list|(
name|fw_device
operator|->
name|domain
argument_list|,
name|fw_device
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|//move on to next round of SPINUP_HOLD_REALSE activity.
name|scif_sas_smp_remote_device_sata_spinup_hold_release
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|SCI_FAILURE_RETRY_REQUIRED
condition|)
block|{
name|U32
name|delay
init|=
operator|(
name|scic_remote_device_get_suggested_reset_timeout
argument_list|(
name|target_device
operator|->
name|core_object
argument_list|)
operator|/
name|SCIF_SAS_IO_RETRY_LIMIT
operator|)
decl_stmt|;
comment|//Retry the smp request. Since we are in the middle of Discover
comment|//process, all the smp requests are internal. A new smp request
comment|//will be created for retry.
if|if
condition|(
name|io_retry_count
operator|<
name|SCIF_SAS_IO_RETRY_LIMIT
condition|)
block|{
name|scif_sas_smp_remote_device_retry_internal_io
argument_list|(
name|fw_device
argument_list|,
name|io_retry_count
argument_list|,
name|delay
argument_list|)
expr_stmt|;
block|}
else|else
comment|//give up on this target device.
block|{
name|scif_sas_smp_remote_device_fail_target_spinup_hold_release
argument_list|(
name|fw_device
argument_list|,
name|target_device
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|//give up on this target device.
name|scif_sas_smp_remote_device_fail_target_spinup_hold_release
argument_list|(
name|fw_device
argument_list|,
name|target_device
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|==
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_CONFIG_ROUTE_TABLE
condition|)
block|{
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|next_phy_element
init|=
name|sci_fast_list_get_next
argument_list|(
operator|&
operator|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_destination_smp_phy
operator|->
name|list_element
operator|)
argument_list|)
decl_stmt|;
name|SCI_FAST_LIST_T
modifier|*
name|destination_smp_phy_list
init|=
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_destination_smp_phy
operator|->
name|list_element
operator|.
name|owning_list
decl_stmt|;
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|next_phy_in_wide_port
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|next_phy_element
operator|!=
name|NULL
operator|&&
name|status
operator|!=
name|SCI_FAILURE_EXCEED_MAX_ROUTE_INDEX
condition|)
block|{
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_index
operator|++
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_destination_smp_phy
operator|=
operator|(
name|SCIF_SAS_SMP_PHY_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|next_phy_element
argument_list|)
expr_stmt|;
comment|// Update the anchor for config route index.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
operator|->
name|config_route_table_index_anchor
operator|=
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_index
expr_stmt|;
name|scif_sas_smp_remote_device_configure_route_table
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scif_sas_smp_remote_device_get_config_route_table_method
argument_list|(
name|fw_device
argument_list|)
operator|==
name|SCIF_SAS_CONFIG_ROUTE_TABLE_ALL_PHYS
operator|&&
operator|(
name|next_phy_in_wide_port
operator|=
name|scif_sas_smp_phy_find_next_phy_in_wide_port
argument_list|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|//config the other phy in the same wide port
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
operator|=
name|next_phy_in_wide_port
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
operator|=
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
operator|->
name|phy_identifier
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_destination_smp_phy
operator|=
name|sci_fast_list_get_head
argument_list|(
name|destination_smp_phy_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
operator|->
name|config_route_table_index_anchor
operator|!=
literal|0
condition|)
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_index
operator|=
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
operator|->
name|config_route_table_index_anchor
operator|+
literal|1
expr_stmt|;
else|else
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_index
operator|=
literal|0
expr_stmt|;
name|scif_sas_smp_remote_device_configure_route_table
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_route_table_cleaned
operator|==
name|FALSE
condition|)
block|{
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_CLEAN_ROUTE_TABLE
expr_stmt|;
name|scif_sas_smp_remote_device_clean_route_table
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//set this device's activity to NON.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_NONE
expr_stmt|;
comment|//we need to notify domain that this device finished config route table, domain
comment|//may pick up other activities (i.e. Discover) for other expanders.
name|scif_sas_domain_continue_discover
argument_list|(
name|fw_device
operator|->
name|domain
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|==
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_CLEAN_ROUTE_TABLE
condition|)
block|{
name|scif_sas_smp_remote_device_clean_route_table
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|==
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_CLEAR_AFFILIATION
condition|)
block|{
name|scif_sas_smp_remote_device_continue_clear_affiliation
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method continues the smp Discover process.  *  * @param[in] fw_device The framework smp device that a DISCOVER command  *       targets to.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_continue_discover
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
name|fw_device
operator|->
name|domain
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_continue_discover(0x%x) enter\n"
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
condition|)
block|{
case|case
name|SMP_FUNCTION_REPORT_GENERAL
case|:
comment|// send the REPORT MANUFACTURER_INFO request
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|=
name|SMP_FUNCTION_REPORT_MANUFACTURER_INFORMATION
expr_stmt|;
name|scif_sas_smp_request_construct_report_manufacturer_info
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_device
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMP_FUNCTION_REPORT_MANUFACTURER_INFORMATION
case|:
comment|//send the first SMP DISCOVER request.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
operator|=
literal|0
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|=
name|SMP_FUNCTION_DISCOVER
expr_stmt|;
name|scif_sas_smp_request_construct_discover
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_device
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMP_FUNCTION_DISCOVER
case|:
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
operator|<
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|number_of_phys
operator|)
condition|)
block|{
name|scif_sas_smp_request_construct_discover
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_device
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|scif_sas_smp_remote_device_finish_initial_discover
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMP_FUNCTION_REPORT_PHY_SATA
case|:
name|scif_sas_smp_request_construct_report_phy_sata
argument_list|(
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
name|fw_device
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMP_FUNCTION_PHY_CONTROL
case|:
name|scif_sas_smp_request_construct_phy_control
argument_list|(
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
name|fw_device
argument_list|,
name|PHY_OPERATION_HARD_RESET
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method finishes the initial smp DISCOVER process. There  *        may be a spinup_hold release phase following of initial discover,  *        depending on whether there are SATA device in the domain  *        in SATA_SPINUP_HOLD condition.  *  * @param[in] fw_device The framework smp device that finishes all the  *       DISCOVER requests.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_finish_initial_discover
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|device_in_sata_spinup_hold
init|=
name|scif_sas_domain_find_device_in_spinup_hold
argument_list|(
name|fw_device
operator|->
name|domain
argument_list|)
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_finish_initial_discover(0x%x) enter\n"
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_in_sata_spinup_hold
operator|!=
name|NULL
condition|)
block|{
comment|//call the common private routine to reset all fields of this smp device.
name|scif_sas_smp_remote_device_clear
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
comment|//Move on to next activity SPINUP_HOLD_RELEASE
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_SATA_SPINUP_HOLD_RELEASE
expr_stmt|;
comment|//create the timer to delay a little bit before going to
comment|//sata spinup hold release activity.
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
operator|==
name|NULL
condition|)
block|{
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
operator|=
name|scif_cb_timer_create
argument_list|(
operator|(
name|SCI_CONTROLLER_HANDLE_T
operator|*
operator|)
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
operator|(
name|SCI_TIMER_CALLBACK_T
operator|)
name|scif_sas_smp_remote_device_sata_spinup_hold_release
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fw_device
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|scif_cb_timer_start
argument_list|(
operator|(
name|SCI_CONTROLLER_HANDLE_T
operator|)
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
argument_list|,
name|SMP_SPINUP_HOLD_RELEASE_WAIT_DURATION
argument_list|)
expr_stmt|;
block|}
else|else
name|scif_sas_smp_remote_device_finish_discover
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method finishes the smp DISCOVER process.  *  * @param[in] fw_device The framework smp device that finishes all the  *       DISCOVER requests.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_finish_discover
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
name|fw_device
operator|->
name|domain
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_finish_discover(0x%x) enter\n"
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_domain
operator|->
name|is_config_route_table_needed
operator|&&
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_phy_list
operator|.
name|list_head
operator|!=
name|NULL
condition|)
name|scif_sas_smp_remote_device_configure_upstream_expander_route_info
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
comment|//call the common private routine to reset all fields of this smp device.
name|scif_sas_smp_remote_device_clear
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCI_SMP_PHY_LIST_DEBUG_PRINT
name|scif_sas_smp_remote_device_print_smp_phy_list
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//notify domain this smp device's discover finishes, it's up to domain
comment|//to continue the discover process in a bigger scope.
name|scif_sas_domain_continue_discover
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method continues the smp Target Reset (Phy Control) process.  *  * @param[in] fw_device The framework smp device that a smp reset targets to.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_continue_target_reset
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SCIF_SAS_REQUEST_T
modifier|*
name|fw_request
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
name|fw_device
operator|->
name|domain
operator|->
name|controller
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|target_device
init|=
name|scif_sas_domain_get_device_by_containing_device
argument_list|(
name|fw_device
operator|->
name|domain
argument_list|,
name|fw_device
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
argument_list|)
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_continue_target_reset(0x%x, 0x%x) enter\n"
operator|,
name|fw_device
operator|,
name|fw_request
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|==
name|SMP_FUNCTION_PHY_CONTROL
condition|)
block|{
comment|//query the core remote device to get suggested reset timeout value
comment|//then scale down by factor of 8 to get the duration of the pause
comment|//before sending out Discover command to poll.
name|U32
name|delay
init|=
operator|(
name|scic_remote_device_get_suggested_reset_timeout
argument_list|(
name|target_device
operator|->
name|core_object
argument_list|)
operator|/
literal|8
operator|)
decl_stmt|;
comment|//create the timer to send Discover command polling target device's
comment|//coming back.
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
operator|==
name|NULL
condition|)
block|{
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
operator|=
name|scif_cb_timer_create
argument_list|(
operator|(
name|SCI_CONTROLLER_HANDLE_T
operator|*
operator|)
name|fw_controller
argument_list|,
operator|(
name|SCI_TIMER_CALLBACK_T
operator|)
name|scif_sas_smp_remote_device_target_reset_poll
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fw_request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//start the timer
name|scif_cb_timer_start
argument_list|(
operator|(
name|SCI_CONTROLLER_HANDLE_T
operator|)
name|fw_controller
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
argument_list|,
name|delay
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|==
name|SMP_FUNCTION_DISCOVER
condition|)
block|{
comment|//tell target reset successful
name|scif_sas_remote_device_target_reset_complete
argument_list|(
name|target_device
argument_list|,
name|fw_request
argument_list|,
name|SCI_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This routine is invoked by timer or when 2 BCN are received  *        after Phy Control command. This routine will construct a  *        Discover command to the same expander phy to poll the target  *        device's coming back. This new request is then put into  *        high priority queue and will be started by a DPC soon.  *  * @param[in] fw_request The scif request for smp activities.  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_target_reset_poll
parameter_list|(
name|SCIF_SAS_REQUEST_T
modifier|*
name|fw_request
parameter_list|)
block|{
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
init|=
name|fw_request
operator|->
name|device
decl_stmt|;
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
name|fw_device
operator|->
name|domain
operator|->
name|controller
decl_stmt|;
name|void
modifier|*
name|new_command_handle
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_target_reset_poll(0x%x) enter\n"
operator|,
name|fw_request
operator|)
argument_list|)
expr_stmt|;
comment|// Before we construct new io using the same memory, we need to
comment|// remove the IO from the list of outstanding requests on the domain
comment|// so that we don't damage the domain's fast list of request.
name|sci_fast_list_remove_element
argument_list|(
operator|&
name|fw_request
operator|->
name|list_element
argument_list|)
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|=
name|SMP_FUNCTION_DISCOVER
expr_stmt|;
comment|//sent smp discover request to poll on remote device's coming back.
comment|//construct Discover command using the same memory as fw_request.
name|new_command_handle
operator|=
name|scif_sas_smp_request_construct_discover
argument_list|(
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
name|fw_device
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|fw_request
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fw_request
argument_list|)
expr_stmt|;
comment|//put into the high priority queue.
name|sci_pool_put
argument_list|(
name|fw_controller
operator|->
name|hprq
operator|.
name|pool
argument_list|,
operator|(
name|POINTER_UINT
operator|)
name|new_command_handle
argument_list|)
expr_stmt|;
comment|//schedule the DPC to start new Discover command.
name|scif_cb_start_internal_io_task_schedule
argument_list|(
name|fw_controller
argument_list|,
name|scif_sas_controller_start_high_priority_io
argument_list|,
name|fw_controller
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method fails discover process.  *  * @param[in] fw_device The framework smp device that failed at current  *       activity.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_fail_discover
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_fail_discover(0x%x) enter\n"
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
condition|)
block|{
case|case
name|SMP_FUNCTION_REPORT_GENERAL
case|:
case|case
name|SMP_FUNCTION_REPORT_MANUFACTURER_INFORMATION
case|:
name|scif_sas_smp_remote_device_finish_discover
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMP_FUNCTION_DISCOVER
case|:
case|case
name|SMP_FUNCTION_REPORT_PHY_SATA
case|:
comment|//Retry limit reached, we will continue to send DISCOVER to next phy.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|=
name|SMP_FUNCTION_DISCOVER
expr_stmt|;
name|scif_sas_smp_remote_device_continue_discover
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method fails Target Reset.  *  * @param[in] fw_device The framework smp device that failed at current  *       activity.  * @param[in] fw_request The smp request created for target reset  *       using external resource.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_fail_target_reset
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SCIF_SAS_REQUEST_T
modifier|*
name|fw_request
parameter_list|)
block|{
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|target_device
init|=
name|scif_sas_domain_get_device_by_containing_device
argument_list|(
name|fw_device
operator|->
name|domain
argument_list|,
name|fw_device
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
argument_list|)
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_fail_target_reset(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|fw_device
operator|,
name|target_device
operator|,
name|fw_request
operator|)
argument_list|)
expr_stmt|;
comment|//tell target reset failed
name|scif_sas_remote_device_target_reset_complete
argument_list|(
name|target_device
argument_list|,
name|fw_request
argument_list|,
name|SCI_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method init or continue the SATA SPINUP_HOLD RELEASE activity.  * This function searches domain's device list, find a device in STOPPED STATE  * and its connection_rate is SPINIP, then send DISCOVER command to its expander  * phy id to poll. But if searching the domain's device list for SATA devices on  * SPINUP_HOLD finds no device, the activity SPINUP_HOLD_RELEASE is finished.  * We then call fw_domain->device_start_complete_handler() for this smp-device.  *  * @param[in] fw_device The framework smp device that is on SATA SPINUP_HOLD_RELEASE  *       activity.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_sata_spinup_hold_release
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
name|fw_device
operator|->
name|domain
decl_stmt|;
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
name|fw_domain
operator|->
name|controller
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|device_to_poll
init|=
name|NULL
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_sata_spinup_hold_release(0x%x) enter\n"
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
comment|//search throught domain's device list to find a sata device on spinup_hold
comment|//state to poll.
name|device_to_poll
operator|=
name|scif_sas_domain_find_device_in_spinup_hold
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_to_poll
operator|!=
name|NULL
condition|)
block|{
comment|//send DISCOVER command to this device's expaner phy.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|=
name|SMP_FUNCTION_DISCOVER
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
operator|=
name|device_to_poll
operator|->
name|expander_phy_identifier
expr_stmt|;
name|scif_sas_smp_request_construct_discover
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_device
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|//schedule the DPC to start new Discover command.
name|scif_cb_start_internal_io_task_schedule
argument_list|(
name|fw_controller
argument_list|,
name|scif_sas_controller_start_high_priority_io
argument_list|,
name|fw_controller
argument_list|)
expr_stmt|;
block|}
else|else
comment|//SATA SPINUP HOLD RELEASE activity is done.
name|scif_sas_smp_remote_device_finish_discover
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method fail an action of SATA SPINUP_HOLD RELEASE on a single EA  *        SATA device. It will remove a remote_device object for a sata device  *        that fails to come out of spinup_hold.  *  * @param[in] fw_device The framework smp device that is on SATA SPINUP_HOLD_RELEASE  *       activity.  * @param[in] target_device The expander attached device failed being brought out  *       of SPINUP_HOLD state.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_fail_target_spinup_hold_release
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|target_device
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
name|fw_device
operator|->
name|domain
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_fail_target_spinup_hold_release(0x%x, 0x%x) enter\n"
operator|,
name|fw_device
operator|,
name|target_device
operator|)
argument_list|)
expr_stmt|;
comment|//need to remove the device, since we have to give up on spinup_hold_release
comment|//activity on this device.
name|scif_cb_domain_device_removed
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|,
name|target_device
argument_list|)
expr_stmt|;
comment|//move on to next round of SPINUP_HOLD_REALSE activity.
name|scif_sas_smp_remote_device_sata_spinup_hold_release
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method retry only internal IO for the smp device.  *  * @param[in] fw_device The framework smp device that has an smp request to retry.  * @param[in] io_retry_count current count for times the IO being retried.  * @param[in] delay The time delay before the io gets retried.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_retry_internal_io
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|U8
name|io_retry_count
parameter_list|,
name|U32
name|delay
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_retry_internal_io(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|fw_device
operator|,
name|io_retry_count
operator|,
name|delay
operator|)
argument_list|)
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|io_retry_count
operator|=
name|io_retry_count
expr_stmt|;
comment|//create the timer for poll target device's coming back.
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
operator|==
name|NULL
condition|)
block|{
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
operator|=
name|scif_cb_timer_create
argument_list|(
operator|(
name|SCI_CONTROLLER_HANDLE_T
operator|*
operator|)
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
operator|(
name|SCI_TIMER_CALLBACK_T
operator|)
name|scif_sas_smp_internal_request_retry
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fw_device
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//start the timer for a purpose of waiting.
name|scif_cb_timer_start
argument_list|(
operator|(
name|SCI_CONTROLLER_HANDLE_T
operator|)
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
argument_list|,
name|delay
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method indicates whether an expander device is in Discover  *        process.  *  * @param[in] fw_device The framework smp device.  *  * @return Whether an expander device is in the middle of discovery process.  */
end_comment

begin_function
name|BOOL
name|scif_sas_smp_remote_device_is_in_activity
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
return|return
operator|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|!=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_NONE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method search through the smp phy list of an expander to  *        find a smp phy by its phy id of the expander.  *  * @param[in] phy_identifier The search criteria.  * @param[in] smp_remote_device The expander that owns the smp phy list.  *  * @return The found smp phy or a NULL pointer to indicate no smp phy is found.  */
end_comment

begin_function
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|scif_sas_smp_remote_device_find_smp_phy_by_id
parameter_list|(
name|U8
name|phy_identifier
parameter_list|,
name|SCIF_SAS_SMP_REMOTE_DEVICE_T
modifier|*
name|smp_remote_device
parameter_list|)
block|{
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|element
init|=
name|smp_remote_device
operator|->
name|smp_phy_list
operator|.
name|list_head
decl_stmt|;
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|curr_smp_phy
init|=
name|NULL
decl_stmt|;
name|ASSERT
argument_list|(
name|phy_identifier
operator|<
name|smp_remote_device
operator|->
name|smp_phy_list
operator|.
name|number_of_phys
argument_list|)
expr_stmt|;
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|curr_smp_phy
operator|=
operator|(
name|SCIF_SAS_SMP_PHY_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|element
operator|=
name|sci_fast_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_smp_phy
operator|->
name|phy_identifier
operator|==
name|phy_identifier
condition|)
return|return
name|curr_smp_phy
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method takes care of removing smp phy list of a smp devcie, which is  *           about to be removed.  *  * @param[in] fw_device The expander device that is about to be removed.  *  * @return none.  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_removed
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|this_device
parameter_list|)
block|{
name|SCIF_SAS_SMP_REMOTE_DEVICE_T
modifier|*
name|smp_remote_device
init|=
operator|&
name|this_device
operator|->
name|protocol_device
operator|.
name|smp_device
decl_stmt|;
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|element
init|=
name|smp_remote_device
operator|->
name|smp_phy_list
operator|.
name|list_head
decl_stmt|;
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|curr_smp_phy
init|=
name|NULL
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_removed(0x%x) enter\n"
operator|,
name|this_device
operator|)
argument_list|)
expr_stmt|;
comment|//remove all the smp phys in this device's smp_phy_list, and the conterpart smp phys
comment|//in phy connections.
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|curr_smp_phy
operator|=
operator|(
name|SCIF_SAS_SMP_PHY_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|element
operator|=
name|sci_fast_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|scif_sas_smp_phy_destruct
argument_list|(
name|curr_smp_phy
argument_list|)
expr_stmt|;
block|}
name|this_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|number_of_phys
operator|=
literal|0
expr_stmt|;
name|this_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|expander_route_indexes
operator|=
literal|0
expr_stmt|;
name|this_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_table_to_table_supported
operator|=
name|FALSE
expr_stmt|;
name|this_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_externally_configurable
operator|=
name|FALSE
expr_stmt|;
name|this_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_able_to_config_others
operator|=
name|FALSE
expr_stmt|;
name|scif_sas_smp_remote_device_clear
argument_list|(
name|this_device
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method takes care of terminated smp request to a smp device. The  *        terminated smp request is most likely timeout and being aborted. A timeout  *        maybe due to OPEN REJECT (NO DESTINATION).  *  * @param[in] fw_device The expander device that a timed out smp request towards to.  * @param[in] fw_request A failed smp request that is terminated by scic.  *  * @return none.  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_terminated_request_handler
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SCIF_SAS_REQUEST_T
modifier|*
name|fw_request
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_terminated_request_handler(0x%x, 0x%x) enter\n"
operator|,
name|fw_device
operator|,
name|fw_request
operator|)
argument_list|)
expr_stmt|;
name|scif_sas_smp_remote_device_decode_smp_response
argument_list|(
name|fw_device
argument_list|,
name|fw_request
argument_list|,
name|NULL
argument_list|,
name|SCI_IO_FAILURE_RETRY_REQUIRED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method allocates and populates the smp phy list of a expander device.  *  * @param[in] fw_device The expander device, whose smp phy list is to be populated after  *                      getting REPORT GENERAL response.  *  * @return none.  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_populate_smp_phy_list
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|this_smp_phy
init|=
name|NULL
decl_stmt|;
name|U8
name|expander_phy_id
init|=
literal|0
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_populate_smp_phy_list(0x%x) enter\n"
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|expander_phy_id
operator|=
literal|0
init|;
name|expander_phy_id
operator|<
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|number_of_phys
condition|;
name|expander_phy_id
operator|++
control|)
block|{
name|this_smp_phy
operator|=
name|scif_sas_controller_allocate_smp_phy
argument_list|(
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|this_smp_phy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_smp_phy
operator|!=
name|NULL
condition|)
name|scif_sas_smp_phy_construct
argument_list|(
name|this_smp_phy
argument_list|,
name|fw_device
argument_list|,
name|expander_phy_id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method updates a smp phy of a expander device based on DISCOVER response.  *  * @param[in] fw_device The expander device, one of whose smp phys is to be updated.  * @param[in] discover_response The smp DISCOVER response.  *  * @return SCI_STATUS If a smp phy pair between expanders has invalid routing attribute,  *                    return SCI_FAILURE_ILLEGAL_ROUTING_ATTRIBUTE_CONFIGURATION, otherwise,  *                    return SCI_SUCCESS  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_smp_remote_device_save_smp_phy_info
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SMP_RESPONSE_DISCOVER_T
modifier|*
name|discover_response
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|smp_phy
init|=
name|NULL
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|attached_device
init|=
name|NULL
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_save_smp_phy_info(0x%x, 0x%x) enter\n"
operator|,
name|fw_device
operator|,
name|discover_response
operator|)
argument_list|)
expr_stmt|;
name|smp_phy
operator|=
name|scif_sas_smp_remote_device_find_smp_phy_by_id
argument_list|(
name|discover_response
operator|->
name|phy_identifier
argument_list|,
operator|&
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|smp_phy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|//Note, attached_device could be NULL, not all the smp phy have to connected to a device.
name|attached_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|scif_domain_get_device_by_sas_address
argument_list|(
name|fw_device
operator|->
name|domain
argument_list|,
operator|&
name|discover_response
operator|->
name|attached_sas_address
argument_list|)
expr_stmt|;
name|scif_sas_smp_phy_save_information
argument_list|(
name|smp_phy
argument_list|,
name|attached_device
argument_list|,
name|discover_response
argument_list|)
expr_stmt|;
comment|//handle the special case of smp phys between expanders.
if|if
condition|(
name|discover_response
operator|->
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_smp_target
condition|)
block|{
comment|//this fw_device is a child expander, just found its parent expander.
comment|//And there is no smp_phy constructed yet, record this phy connection.
if|if
condition|(
name|attached_device
operator|!=
name|NULL
operator|&&
name|attached_device
operator|==
name|fw_device
operator|->
name|containing_device
condition|)
block|{
comment|//record the smp phy info, for this phy connects to a upstream smp device.
comment|//the connection of a pair of smp phys are completed.
name|status
operator|=
name|scif_sas_smp_phy_set_attached_phy
argument_list|(
name|smp_phy
argument_list|,
name|discover_response
operator|->
name|attached_phy_identifier
argument_list|,
name|attached_device
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|//check the routing attribute for this phy and its containing device's
comment|//expander_phy_routing_attribute.
if|if
condition|(
name|scif_sas_smp_phy_verify_routing_attribute
argument_list|(
name|smp_phy
argument_list|,
name|smp_phy
operator|->
name|u
operator|.
name|attached_phy
argument_list|)
operator|!=
name|SCI_SUCCESS
condition|)
return|return
name|SCI_FAILURE_ILLEGAL_ROUTING_ATTRIBUTE_CONFIGURATION
return|;
block|}
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCI_SMP_PHY_LIST_DEBUG_PRINT
end_ifdef

begin_function
name|void
name|scif_sas_smp_remote_device_print_smp_phy_list
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|SCIF_SAS_SMP_REMOTE_DEVICE_T
modifier|*
name|smp_remote_device
init|=
operator|&
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
decl_stmt|;
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|element
init|=
name|smp_remote_device
operator|->
name|smp_phy_list
operator|.
name|list_head
decl_stmt|;
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|curr_smp_phy
init|=
name|NULL
decl_stmt|;
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator|,
literal|"==========EXPANDER DEVICE (0x%x) smp phy list========== \n"
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|curr_smp_phy
operator|=
operator|(
name|SCIF_SAS_SMP_PHY_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|element
operator|=
name|sci_fast_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|//print every thing about a smp phy
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator|,
literal|"SMP_PHY_%d (0x%x), attached device(0x%x), attached_sas_address(%x%x) attached_device_type(%d), routing_attribute(%d)\n"
operator|,
name|curr_smp_phy
operator|->
name|phy_identifier
operator|,
name|curr_smp_phy
operator|,
name|curr_smp_phy
operator|->
name|u
operator|.
name|end_device
operator|,
name|curr_smp_phy
operator|->
name|attached_sas_address
operator|.
name|high
operator|,
name|curr_smp_phy
operator|->
name|attached_sas_address
operator|.
name|low
operator|,
name|curr_smp_phy
operator|->
name|attached_device_type
operator|,
name|curr_smp_phy
operator|->
name|routing_attribute
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @brief This method configure upstream expander(s)' (if there is any) route info.  *  * @param[in] this_device The expander device that is currently in discover process.  *  * @return none.  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_configure_upstream_expander_route_info
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|this_device
parameter_list|)
block|{
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|curr_child_expander
init|=
name|this_device
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|curr_parent_expander
init|=
name|scif_sas_remote_device_find_upstream_expander
argument_list|(
name|this_device
argument_list|)
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|curr_config_route_info_expander
init|=
name|NULL
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_configure_upstream_expander_route_info(0x%x) enter\n"
operator|,
name|this_device
operator|)
argument_list|)
expr_stmt|;
comment|//traverse back to find root device.
while|while
condition|(
name|curr_parent_expander
operator|!=
name|NULL
condition|)
block|{
comment|//must set destination_smp_phy outside of find_upstream_expander() using the device
comment|//that is just about to finish the discovery.
name|curr_parent_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_destination_smp_phy
operator|=
operator|(
name|SCIF_SAS_SMP_PHY_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|this_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_phy_list
operator|.
name|list_head
argument_list|)
expr_stmt|;
name|curr_child_expander
operator|=
name|curr_parent_expander
expr_stmt|;
name|curr_parent_expander
operator|=
name|scif_sas_remote_device_find_upstream_expander
argument_list|(
name|curr_child_expander
argument_list|)
expr_stmt|;
block|}
comment|//found the root device: curr_child_expander. configure it and its downstream expander(s) till
comment|//this_device or a self-configuring expander that configures others;
name|curr_config_route_info_expander
operator|=
name|curr_child_expander
expr_stmt|;
while|while
condition|(
name|curr_config_route_info_expander
operator|!=
name|NULL
operator|&&
name|curr_config_route_info_expander
operator|!=
name|this_device
operator|&&
name|curr_config_route_info_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|scheduled_activity
operator|==
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_NONE
condition|)
block|{
if|if
condition|(
name|curr_config_route_info_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_externally_configurable
condition|)
block|{
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|phy_being_config
init|=
name|curr_config_route_info_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
decl_stmt|;
name|curr_config_route_info_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_index
operator|=
name|phy_being_config
operator|->
name|config_route_table_index_anchor
expr_stmt|;
if|if
condition|(
name|curr_config_route_info_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_index
operator|!=
literal|0
condition|)
name|curr_config_route_info_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_index
operator|++
expr_stmt|;
name|curr_config_route_info_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|scheduled_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_CONFIG_ROUTE_TABLE
expr_stmt|;
comment|//Find a downstream expander that has curr_config_route_destination_smp_phy.owning device
comment|//same as curr_config_route_info_expander.
name|curr_config_route_info_expander
operator|=
name|scif_sas_remote_device_find_downstream_expander
argument_list|(
name|curr_config_route_info_expander
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curr_config_route_info_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_able_to_config_others
condition|)
block|{
comment|//no need to config route table to this expander and its children.
comment|//find its downstream expander and clear the planned config route table activity.
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|curr_downstream_expander
init|=
name|scif_sas_remote_device_find_downstream_expander
argument_list|(
name|curr_config_route_info_expander
argument_list|)
decl_stmt|;
name|scif_sas_smp_remote_device_clear
argument_list|(
name|curr_config_route_info_expander
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr_downstream_expander
operator|!=
name|NULL
operator|&&
name|curr_downstream_expander
operator|!=
name|this_device
condition|)
block|{
name|scif_sas_smp_remote_device_clear
argument_list|(
name|curr_downstream_expander
argument_list|)
expr_stmt|;
name|curr_downstream_expander
operator|=
name|scif_sas_remote_device_find_downstream_expander
argument_list|(
name|curr_config_route_info_expander
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|// current expander is a self-configuring expander, which is not externally
comment|// configurable, and doesn't config others. we need to simply skip this expander.
name|curr_config_route_info_expander
operator|=
name|scif_sas_remote_device_find_downstream_expander
argument_list|(
name|curr_config_route_info_expander
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method finds the immediate upstream expander of a given expander device.  *  * @param[in] this_device The given expander device, whose upstream expander is to be found.  *  * @return The immediate upstream expander. Or a NULL pointer if this_device is root already.  */
end_comment

begin_function
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|scif_sas_remote_device_find_upstream_expander
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|this_device
parameter_list|)
block|{
name|SCIF_SAS_SMP_REMOTE_DEVICE_T
modifier|*
name|smp_remote_device
init|=
operator|&
name|this_device
operator|->
name|protocol_device
operator|.
name|smp_device
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|upstream_expander
init|=
name|NULL
decl_stmt|;
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|element
init|=
name|smp_remote_device
operator|->
name|smp_phy_list
operator|.
name|list_head
decl_stmt|;
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|curr_smp_phy
init|=
name|NULL
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_configure_upstream_expander_route_info(0x%x) enter\n"
operator|,
name|this_device
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|curr_smp_phy
operator|=
operator|(
name|SCIF_SAS_SMP_PHY_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|element
operator|=
name|sci_fast_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_smp_phy
operator|->
name|routing_attribute
operator|==
name|SUBTRACTIVE_ROUTING_ATTRIBUTE
operator|&&
operator|(
name|curr_smp_phy
operator|->
name|attached_device_type
operator|==
name|SMP_EDGE_EXPANDER_DEVICE
operator|||
name|curr_smp_phy
operator|->
name|attached_device_type
operator|==
name|SMP_FANOUT_EXPANDER_DEVICE
operator|)
operator|&&
name|curr_smp_phy
operator|->
name|u
operator|.
name|attached_phy
operator|!=
name|NULL
operator|&&
name|curr_smp_phy
operator|->
name|u
operator|.
name|attached_phy
operator|->
name|routing_attribute
operator|==
name|TABLE_ROUTING_ATTRIBUTE
condition|)
block|{
comment|//set the current_activity and current_config_route_index for that
comment|//upstream expander.
name|upstream_expander
operator|=
name|curr_smp_phy
operator|->
name|u
operator|.
name|attached_phy
operator|->
name|owning_device
expr_stmt|;
name|upstream_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|=
name|SMP_FUNCTION_CONFIGURE_ROUTE_INFORMATION
expr_stmt|;
comment|//if the upstream_expander's config route table method is config phy0 only or
comment|//config all phys, the current activity phy is found.
name|upstream_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
operator|=
name|scif_sas_smp_remote_device_find_smp_phy_by_id
argument_list|(
name|curr_smp_phy
operator|->
name|u
operator|.
name|attached_phy
operator|->
name|phy_identifier
argument_list|,
operator|&
operator|(
name|curr_smp_phy
operator|->
name|u
operator|.
name|attached_phy
operator|->
name|owning_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|)
argument_list|)
expr_stmt|;
comment|//if the upstream_expander's config route table method is config middle phy only
comment|//config highest phy only, the current activity phy needs a update.
if|if
condition|(
name|scif_sas_smp_remote_device_get_config_route_table_method
argument_list|(
name|upstream_expander
argument_list|)
operator|==
name|SCIF_SAS_CONFIG_ROUTE_TABLE_MIDDLE_PHY_ONLY
condition|)
block|{
name|upstream_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
operator|=
name|scif_sas_smp_phy_find_middle_phy_in_wide_port
argument_list|(
name|upstream_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scif_sas_smp_remote_device_get_config_route_table_method
argument_list|(
name|upstream_expander
argument_list|)
operator|==
name|SCIF_SAS_CONFIG_ROUTE_TABLE_HIGHEST_PHY_ONLY
condition|)
block|{
name|upstream_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
operator|=
name|scif_sas_smp_phy_find_highest_phy_in_wide_port
argument_list|(
name|upstream_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
argument_list|)
expr_stmt|;
block|}
name|upstream_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
operator|=
name|upstream_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
operator|->
name|phy_identifier
expr_stmt|;
return|return
name|upstream_expander
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method finds the immediate downstream expander of a given expander device.  *  * @param[in] this_device The given expander device, whose downstream expander is to be found.  *  * @return The immediate downstream expander. Or a NULL pointer if there is none.  */
end_comment

begin_function
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|scif_sas_remote_device_find_downstream_expander
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|this_device
parameter_list|)
block|{
name|SCIF_SAS_SMP_REMOTE_DEVICE_T
modifier|*
name|this_smp_remote_device
init|=
operator|&
name|this_device
operator|->
name|protocol_device
operator|.
name|smp_device
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|downstream_expander
init|=
name|NULL
decl_stmt|;
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|element
init|=
name|this_smp_remote_device
operator|->
name|smp_phy_list
operator|.
name|list_head
decl_stmt|;
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|curr_smp_phy
init|=
name|NULL
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_remote_device_find_downstream_expander(0x%x) enter\n"
operator|,
name|this_device
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|curr_smp_phy
operator|=
operator|(
name|SCIF_SAS_SMP_PHY_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|element
operator|=
name|sci_fast_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_smp_phy
operator|->
name|routing_attribute
operator|==
name|TABLE_ROUTING_ATTRIBUTE
operator|&&
name|curr_smp_phy
operator|->
name|attached_device_type
operator|==
name|SMP_EDGE_EXPANDER_DEVICE
operator|&&
name|curr_smp_phy
operator|->
name|u
operator|.
name|attached_phy
operator|!=
name|NULL
condition|)
block|{
comment|//set the current_activity and current_config_route_index for that
comment|//upstream expander.
name|downstream_expander
operator|=
name|curr_smp_phy
operator|->
name|u
operator|.
name|attached_phy
operator|->
name|owning_device
expr_stmt|;
if|if
condition|(
name|downstream_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_destination_smp_phy
operator|!=
name|NULL
operator|&&
name|downstream_expander
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_destination_smp_phy
operator|->
name|owning_device
operator|==
name|this_smp_remote_device
operator|->
name|curr_config_route_destination_smp_phy
operator|->
name|owning_device
condition|)
return|return
name|downstream_expander
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method follows route table optimization rule to check if a destination_device  *        should be recorded in the device_being_config's route table  *  * @param[in] device_being_config The upstream expander device, whose route table is being configured.  * @param[in] destination_smp_phy A smp phy whose attached device is potentially to be  *               recorded in route table.  *  * @return BOOL This method returns TRUE if a destination_device should be recorded in route table.  *              This method returns FALSE if a destination_device need not to be recorded  *              in route table.  */
end_comment

begin_function
name|BOOL
name|scif_sas_smp_remote_device_do_config_route_info
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|device_being_config
parameter_list|,
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|destination_smp_phy
parameter_list|)
block|{
name|SCI_SAS_ADDRESS_T
name|device_being_config_sas_address
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|device_being_config
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_do_config_route_info(0x%x, 0x%x) enter\n"
operator|,
name|device_being_config
operator|,
name|destination_smp_phy
operator|)
argument_list|)
expr_stmt|;
name|scic_remote_device_get_sas_address
argument_list|(
name|device_being_config
operator|->
name|core_object
argument_list|,
operator|&
name|device_being_config_sas_address
argument_list|)
expr_stmt|;
comment|//refer to SAS-2 spec 4.8.3, rule (b)
if|if
condition|(
operator|(
name|destination_smp_phy
operator|->
name|attached_sas_address
operator|.
name|low
operator|==
literal|0
operator|&&
name|destination_smp_phy
operator|->
name|attached_sas_address
operator|.
name|high
operator|==
literal|0
operator|)
operator|&&
operator|(
name|destination_smp_phy
operator|->
name|attached_device_type
operator|==
name|SMP_NO_DEVICE_ATTACHED
operator|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
comment|//refer to SAS-2 spec 4.8.3, rule (c), self-referencing.
if|if
condition|(
name|destination_smp_phy
operator|->
name|attached_sas_address
operator|.
name|high
operator|==
name|device_being_config_sas_address
operator|.
name|high
operator|&&
name|destination_smp_phy
operator|->
name|attached_sas_address
operator|.
name|low
operator|==
name|device_being_config_sas_address
operator|.
name|low
condition|)
block|{
return|return
name|FALSE
return|;
block|}
comment|//There will be no cases that falling into rule (a), (d), (e) to be excluded,
comment|//based on our current mechanism of cofig route table.
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method configures device_being_config's route table for all the enclosed devices in  *           a downstream smp device, destination_device.  *  * @param[in] device_being_config The upstream expander device, whose route table is being configured.  *  * @return None  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_configure_route_table
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|device_being_config
parameter_list|)
block|{
comment|//go through the smp phy list of this_device.
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|element
init|=
operator|&
operator|(
name|device_being_config
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_destination_smp_phy
operator|->
name|list_element
operator|)
decl_stmt|;
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|curr_smp_phy
init|=
name|NULL
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|device_being_config
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_configure_route_table(0x%x) enter\n"
operator|,
name|device_being_config
operator|)
argument_list|)
expr_stmt|;
name|device_being_config
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_CONFIG_ROUTE_TABLE
expr_stmt|;
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|curr_smp_phy
operator|=
operator|(
name|SCIF_SAS_SMP_PHY_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|element
operator|=
name|sci_fast_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|//check if this phy needs to be added to the expander's route table.
if|if
condition|(
name|scif_sas_smp_remote_device_do_config_route_info
argument_list|(
name|device_being_config
argument_list|,
name|curr_smp_phy
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|SCIF_SAS_SMP_REMOTE_DEVICE_T
modifier|*
name|smp_remote_device
init|=
operator|&
name|device_being_config
operator|->
name|protocol_device
operator|.
name|smp_device
decl_stmt|;
name|smp_remote_device
operator|->
name|curr_config_route_destination_smp_phy
operator|=
name|curr_smp_phy
expr_stmt|;
comment|//Then config this_device's route table entry at the phy and next route_index.
comment|//send config_route_info using curr_smp_phy.phy_identifier and sas_address.
name|scif_sas_smp_request_construct_config_route_info
argument_list|(
name|device_being_config
operator|->
name|domain
operator|->
name|controller
argument_list|,
name|device_being_config
argument_list|,
name|smp_remote_device
operator|->
name|current_activity_phy_index
argument_list|,
name|smp_remote_device
operator|->
name|curr_config_route_index
argument_list|,
name|curr_smp_phy
operator|->
name|attached_sas_address
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|//schedule the DPC.
name|scif_cb_start_internal_io_task_schedule
argument_list|(
name|device_being_config
operator|->
name|domain
operator|->
name|controller
argument_list|,
name|scif_sas_controller_start_high_priority_io
argument_list|,
name|device_being_config
operator|->
name|domain
operator|->
name|controller
argument_list|)
expr_stmt|;
comment|//stop here, we need to wait for config route info's response then send
comment|//the next one.
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method walks through an expander's route table to clean table  *           attribute phys' route entries. This routine finds one table entry  *           to clean and will be called repeatly till it finishes cleanning the  *           whole table.  *  * @param[in] fw_device The expander device, whose route table entry is to be cleaned.  *  * @return None.  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_clean_route_table
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|smp_phy_being_config
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_clean_route_table(0x%x) enter\n"
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
comment|//from anchors, start to clean all the other route table entries.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_index
operator|++
expr_stmt|;
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_index
operator|>=
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|expander_route_indexes
condition|)
block|{
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_index
operator|=
literal|0
expr_stmt|;
do|do
comment|//find next table attribute PHY.
block|{
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
operator|++
expr_stmt|;
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
operator|==
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|number_of_phys
condition|)
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
operator|=
literal|0
expr_stmt|;
comment|//phy_index changed, so update the smp_phy_being_config.
name|smp_phy_being_config
operator|=
name|scif_sas_smp_remote_device_find_smp_phy_by_id
argument_list|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
argument_list|,
operator|&
operator|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|smp_phy_being_config
operator|->
name|routing_attribute
operator|!=
name|TABLE_ROUTING_ATTRIBUTE
condition|)
do|;
if|if
condition|(
name|smp_phy_being_config
operator|->
name|phy_identifier
operator|!=
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
operator|->
name|phy_identifier
condition|)
block|{
if|if
condition|(
name|smp_phy_being_config
operator|->
name|config_route_table_index_anchor
operator|!=
literal|0
condition|)
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_index
operator|=
name|smp_phy_being_config
operator|->
name|config_route_table_index_anchor
operator|+
literal|1
expr_stmt|;
else|else
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
operator|==
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|config_route_smp_phy_anchor
operator|->
name|phy_identifier
operator|&&
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_index
operator|==
literal|0
operator|)
condition|)
block|{
comment|//clean this route entry.
name|scif_sas_smp_remote_device_clean_route_table_entry
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|is_route_table_cleaned
operator|=
name|TRUE
expr_stmt|;
comment|//set this device's activity to NON.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_NONE
expr_stmt|;
comment|//we need to notify domain that this device finished config route table, domain
comment|//may pick up other activities (i.e. Discover) for other expanders.
name|scif_sas_domain_continue_discover
argument_list|(
name|fw_device
operator|->
name|domain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method cleans a device's route table antry.  *  * @param[in] fw_device The expander device, whose route table entry is to be cleaned.  *  * @return None.  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_clean_route_table_entry
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|SCI_SAS_ADDRESS_T
name|empty_sas_address
decl_stmt|;
name|SCIF_SAS_SMP_REMOTE_DEVICE_T
modifier|*
name|smp_remote_device
init|=
operator|&
operator|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|)
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_clean_route_table(0x%x) enter\n"
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
name|empty_sas_address
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|empty_sas_address
operator|.
name|low
operator|=
literal|0
expr_stmt|;
name|scif_sas_smp_request_construct_config_route_info
argument_list|(
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
name|fw_device
argument_list|,
name|smp_remote_device
operator|->
name|current_activity_phy_index
argument_list|,
name|smp_remote_device
operator|->
name|curr_config_route_index
argument_list|,
name|empty_sas_address
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|//schedule the DPC.
name|scif_cb_start_internal_io_task_schedule
argument_list|(
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
name|scif_sas_controller_start_high_priority_io
argument_list|,
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method handles the case of exceeding route index when config route table  *           for a device, by removing the attached device of current config route  *           destination smp phy and the rest of smp phys in the same smp phy list.  *  * @param[in] fw_device The expander device, whose route table to be edited but failed  *               with a SMP function result of INDEX DOES NOT EXIST.  *  * @return None.  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_cancel_config_route_table_activity
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
comment|//go through the rest of the smp phy list of destination device.
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|element
init|=
operator|&
operator|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|curr_config_route_destination_smp_phy
operator|->
name|list_element
operator|)
decl_stmt|;
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|curr_smp_phy
init|=
name|NULL
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|curr_attached_device
init|=
name|NULL
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_cancel_config_route_table_activity(0x%x) enter\n"
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|curr_smp_phy
operator|=
operator|(
name|SCIF_SAS_SMP_PHY_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|element
operator|=
name|sci_fast_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|//check if this phy needs to be added to the expander's route table but can't due to
comment|//exceeding max route index.
if|if
condition|(
name|scif_sas_smp_remote_device_do_config_route_info
argument_list|(
name|fw_device
argument_list|,
name|curr_smp_phy
argument_list|)
operator|==
name|TRUE
condition|)
block|{
comment|//set the is_currently_discovered to FALSE for attached device. Then when
comment|//domain finish discover, domain will remove this device.
name|curr_attached_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|scif_domain_get_device_by_sas_address
argument_list|(
name|fw_device
operator|->
name|domain
argument_list|,
operator|&
operator|(
name|curr_smp_phy
operator|->
name|attached_sas_address
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_attached_device
operator|!=
name|NULL
condition|)
name|curr_attached_device
operator|->
name|is_currently_discovered
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method cancel current activity and terminate the outstanding internal IO  *           if there is one.  *  * @param[in] fw_device The expander device, whose smp activity is to be canceled.  *  * @return None.  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_cancel_smp_activity
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_device
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_REMOTE_DEVICE
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_smp_remote_device_cancel_smp_activity(0x%x) enter\n"
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
comment|//Terminate all of the requests in the silicon for this device.
name|scif_sas_domain_terminate_requests
argument_list|(
name|fw_device
operator|->
name|domain
argument_list|,
name|fw_device
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|==
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_CONFIG_ROUTE_TABLE
condition|)
name|scif_sas_smp_remote_device_cancel_config_route_table_activity
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
comment|//Clear the device to stop the smp sctivity.
name|scif_sas_smp_remote_device_clear
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method tells the way to configure route table for a expander. The  *          possible ways are: configure phy 0's route table, configure middle  *          phy's route table, configure highest order phy's route table,  *          configure all phys.  *  * @param[in] fw_device The expander device, whose config route table method is  *               to be chosen.  *  * @return one in 4 possible options.  */
end_comment

begin_function
name|U8
name|scif_sas_smp_remote_device_get_config_route_table_method
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|U8
name|config_route_table_method
decl_stmt|;
comment|//config_route_table_method = SCIF_SAS_CONFIG_ROUTE_TABLE_MIDDLE_PHY_ONLY;
name|config_route_table_method
operator|=
name|SCIF_SAS_CONFIG_ROUTE_TABLE_ALL_PHYS
expr_stmt|;
return|return
name|config_route_table_method
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method starts the EA target reset process by constructing  *           and starting a PHY CONTROL (hard reset) smp request.  *  * @param[in] expander_device The expander device, to which a PHY Control smp command is  *               sent.  * @param[in] target_device The expander attahced target device, to which the target reset  *               request is sent.  * @param[in] fw_request The target reset task request.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_smp_remote_device_start_target_reset
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|expander_device
parameter_list|,
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|target_device
parameter_list|,
name|SCIF_SAS_REQUEST_T
modifier|*
name|fw_request
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
name|expander_device
operator|->
name|domain
operator|->
name|controller
decl_stmt|;
comment|//set current_activity and current_smp_request to expander device.
name|expander_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_TARGET_RESET
expr_stmt|;
name|expander_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_smp_request
operator|=
name|SMP_FUNCTION_PHY_CONTROL
expr_stmt|;
name|expander_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|current_activity_phy_index
operator|=
name|target_device
operator|->
name|expander_phy_identifier
expr_stmt|;
comment|//A Phy Control smp request has been constructed towards parent device.
comment|//Walk the high priority io path.
name|fw_controller
operator|->
name|state_handlers
operator|->
name|start_high_priority_io_handler
argument_list|(
operator|(
name|SCI_BASE_CONTROLLER_T
operator|*
operator|)
name|fw_controller
argument_list|,
operator|(
name|SCI_BASE_REMOTE_DEVICE_T
operator|*
operator|)
name|expander_device
argument_list|,
operator|(
name|SCI_BASE_REQUEST_T
operator|*
operator|)
name|fw_request
argument_list|,
name|SCI_CONTROLLER_INVALID_IO_TAG
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

