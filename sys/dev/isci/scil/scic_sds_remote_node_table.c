begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  *  * @brief This file contains the implementation of the  *        SCIC_SDS_REMOTE_NODE_TABLE public, protected, and private methods.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_remote_node_table.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_remote_node_context.h>
end_include

begin_comment
comment|/**  * This routine will find the bit position in absolute bit terms of the next  * available bit for selection.  The absolute bit is index * 32 + bit  * position.  If there are available bits in the first U32 then it is just bit  * position.  *  @param[in] remote_node_table This is the remote node index table from  *       which the selection will be made.  * @param[in] group_table_index This is the index to the group table from  *       which to search for an available selection.  *  * @return U32 This is the absolute bit position for an available group.  */
end_comment

begin_function
specifier|static
name|U32
name|scic_sds_remote_node_table_get_group_index
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U32
name|group_table_index
parameter_list|)
block|{
name|U32
name|dword_index
decl_stmt|;
name|U32
modifier|*
name|group_table
decl_stmt|;
name|U32
name|bit_index
decl_stmt|;
name|group_table
operator|=
name|remote_node_table
operator|->
name|remote_node_groups
index|[
name|group_table_index
index|]
expr_stmt|;
for|for
control|(
name|dword_index
operator|=
literal|0
init|;
name|dword_index
operator|<
name|remote_node_table
operator|->
name|group_array_size
condition|;
name|dword_index
operator|++
control|)
block|{
if|if
condition|(
name|group_table
index|[
name|dword_index
index|]
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|bit_index
operator|=
literal|0
init|;
name|bit_index
operator|<
literal|32
condition|;
name|bit_index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|group_table
index|[
name|dword_index
index|]
operator|&
operator|(
literal|1
operator|<<
name|bit_index
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|dword_index
operator|*
literal|32
operator|)
operator|+
name|bit_index
return|;
block|}
block|}
block|}
block|}
return|return
name|SCIC_SDS_REMOTE_NODE_TABLE_INVALID_INDEX
return|;
block|}
end_function

begin_comment
comment|/**  * This method will clear the group index entry in the specified group index  * table.  *  * @param[in out] remote_node_table This the remote node table in which to  *       clear the selector.  * @param[in] set_index This is the remote node selector in which the change  *       will be made.  * @param[in] group_index This is the bit index in the table to be modified.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_remote_node_table_clear_group_index
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U32
name|group_table_index
parameter_list|,
name|U32
name|group_index
parameter_list|)
block|{
name|U32
name|dword_index
decl_stmt|;
name|U32
name|bit_index
decl_stmt|;
name|U32
modifier|*
name|group_table
decl_stmt|;
name|ASSERT
argument_list|(
name|group_table_index
operator|<
name|SCU_STP_REMOTE_NODE_COUNT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|group_index
operator|<
call|(
name|U32
call|)
argument_list|(
name|remote_node_table
operator|->
name|group_array_size
operator|*
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|dword_index
operator|=
name|group_index
operator|/
literal|32
expr_stmt|;
name|bit_index
operator|=
name|group_index
operator|%
literal|32
expr_stmt|;
name|group_table
operator|=
name|remote_node_table
operator|->
name|remote_node_groups
index|[
name|group_table_index
index|]
expr_stmt|;
name|group_table
index|[
name|dword_index
index|]
operator|=
name|group_table
index|[
name|dword_index
index|]
operator|&
operator|~
operator|(
literal|1
operator|<<
name|bit_index
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method will set the group index bit entry in the specified gropu index  * table.  *  * @param[in out] remote_node_table This the remote node table in which to set  *       the selector.  * @param[in] group_table_index This is the remote node selector in which the  *       change will be made.  * @param[in] group_index This is the bit position in the table to be  *       modified.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_remote_node_table_set_group_index
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U32
name|group_table_index
parameter_list|,
name|U32
name|group_index
parameter_list|)
block|{
name|U32
name|dword_index
decl_stmt|;
name|U32
name|bit_index
decl_stmt|;
name|U32
modifier|*
name|group_table
decl_stmt|;
name|ASSERT
argument_list|(
name|group_table_index
operator|<
name|SCU_STP_REMOTE_NODE_COUNT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|group_index
operator|<
call|(
name|U32
call|)
argument_list|(
name|remote_node_table
operator|->
name|group_array_size
operator|*
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|dword_index
operator|=
name|group_index
operator|/
literal|32
expr_stmt|;
name|bit_index
operator|=
name|group_index
operator|%
literal|32
expr_stmt|;
name|group_table
operator|=
name|remote_node_table
operator|->
name|remote_node_groups
index|[
name|group_table_index
index|]
expr_stmt|;
name|group_table
index|[
name|dword_index
index|]
operator|=
name|group_table
index|[
name|dword_index
index|]
operator||
operator|(
literal|1
operator|<<
name|bit_index
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method will set the remote to available in the remote node allocation  * table.  *  * @param[in out] remote_node_table This is the remote node table in which to  *       modify the remote node availability.  * @param[in] remote_node_index This is the remote node index that is being  *       returned to the table.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_remote_node_table_set_node_index
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U32
name|remote_node_index
parameter_list|)
block|{
name|U32
name|dword_location
decl_stmt|;
name|U32
name|dword_remainder
decl_stmt|;
name|U32
name|slot_normalized
decl_stmt|;
name|U32
name|slot_position
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|remote_node_table
operator|->
name|available_nodes_array_size
operator|*
name|SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD
operator|)
operator|>
operator|(
name|remote_node_index
operator|/
name|SCU_STP_REMOTE_NODE_COUNT
operator|)
argument_list|)
expr_stmt|;
name|dword_location
operator|=
name|remote_node_index
operator|/
name|SCIC_SDS_REMOTE_NODES_PER_DWORD
expr_stmt|;
name|dword_remainder
operator|=
name|remote_node_index
operator|%
name|SCIC_SDS_REMOTE_NODES_PER_DWORD
expr_stmt|;
name|slot_normalized
operator|=
operator|(
name|dword_remainder
operator|/
name|SCU_STP_REMOTE_NODE_COUNT
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
expr_stmt|;
name|slot_position
operator|=
name|remote_node_index
operator|%
name|SCU_STP_REMOTE_NODE_COUNT
expr_stmt|;
name|remote_node_table
operator|->
name|available_remote_nodes
index|[
name|dword_location
index|]
operator||=
literal|1
operator|<<
operator|(
name|slot_normalized
operator|+
name|slot_position
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method clears the remote node index from the table of available remote  * nodes.  *  * @param[in out] remote_node_table This is the remote node table from which  *       to clear the available remote node bit.  * @param[in] remote_node_index This is the remote node index which is to be  *       cleared from the table.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_remote_node_table_clear_node_index
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U32
name|remote_node_index
parameter_list|)
block|{
name|U32
name|dword_location
decl_stmt|;
name|U32
name|dword_remainder
decl_stmt|;
name|U32
name|slot_position
decl_stmt|;
name|U32
name|slot_normalized
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|remote_node_table
operator|->
name|available_nodes_array_size
operator|*
name|SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD
operator|)
operator|>
operator|(
name|remote_node_index
operator|/
name|SCU_STP_REMOTE_NODE_COUNT
operator|)
argument_list|)
expr_stmt|;
name|dword_location
operator|=
name|remote_node_index
operator|/
name|SCIC_SDS_REMOTE_NODES_PER_DWORD
expr_stmt|;
name|dword_remainder
operator|=
name|remote_node_index
operator|%
name|SCIC_SDS_REMOTE_NODES_PER_DWORD
expr_stmt|;
name|slot_normalized
operator|=
operator|(
name|dword_remainder
operator|/
name|SCU_STP_REMOTE_NODE_COUNT
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
expr_stmt|;
name|slot_position
operator|=
name|remote_node_index
operator|%
name|SCU_STP_REMOTE_NODE_COUNT
expr_stmt|;
name|remote_node_table
operator|->
name|available_remote_nodes
index|[
name|dword_location
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|slot_normalized
operator|+
name|slot_position
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method clears the entire table slot at the specified slot index.  *  * @param[in out] remote_node_table The remote node table from which the slot  *       will be cleared.  * @param[in] group_index The index for the slot that is to be cleared.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_remote_node_table_clear_group
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U32
name|group_index
parameter_list|)
block|{
name|U32
name|dword_location
decl_stmt|;
name|U32
name|dword_remainder
decl_stmt|;
name|U32
name|dword_value
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|remote_node_table
operator|->
name|available_nodes_array_size
operator|*
name|SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD
operator|)
operator|>
operator|(
name|group_index
operator|/
name|SCU_STP_REMOTE_NODE_COUNT
operator|)
argument_list|)
expr_stmt|;
name|dword_location
operator|=
name|group_index
operator|/
name|SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD
expr_stmt|;
name|dword_remainder
operator|=
name|group_index
operator|%
name|SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD
expr_stmt|;
name|dword_value
operator|=
name|remote_node_table
operator|->
name|available_remote_nodes
index|[
name|dword_location
index|]
expr_stmt|;
name|dword_value
operator|&=
operator|~
operator|(
name|SCIC_SDS_REMOTE_NODE_TABLE_FULL_SLOT_VALUE
operator|<<
operator|(
name|dword_remainder
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|remote_node_table
operator|->
name|available_remote_nodes
index|[
name|dword_location
index|]
operator|=
name|dword_value
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * THis method sets an entire remote node group in the remote node table.  *  * @param[in] remote_node_table  * @param[in] group_index  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_remote_node_table_set_group
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U32
name|group_index
parameter_list|)
block|{
name|U32
name|dword_location
decl_stmt|;
name|U32
name|dword_remainder
decl_stmt|;
name|U32
name|dword_value
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|remote_node_table
operator|->
name|available_nodes_array_size
operator|*
name|SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD
operator|)
operator|>
operator|(
name|group_index
operator|/
name|SCU_STP_REMOTE_NODE_COUNT
operator|)
argument_list|)
expr_stmt|;
name|dword_location
operator|=
name|group_index
operator|/
name|SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD
expr_stmt|;
name|dword_remainder
operator|=
name|group_index
operator|%
name|SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD
expr_stmt|;
name|dword_value
operator|=
name|remote_node_table
operator|->
name|available_remote_nodes
index|[
name|dword_location
index|]
expr_stmt|;
name|dword_value
operator||=
operator|(
name|SCIC_SDS_REMOTE_NODE_TABLE_FULL_SLOT_VALUE
operator|<<
operator|(
name|dword_remainder
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|remote_node_table
operator|->
name|available_remote_nodes
index|[
name|dword_location
index|]
operator|=
name|dword_value
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method will return the group value for the specified group index.  *  * @param[in] remote_node_table This is the remote node table that for which  *       the group value is to be returned.  * @param[in] group_index This is the group index to use to find the group  *       value.  *  * @return The bit values at the specified remote node group index.  */
end_comment

begin_function
specifier|static
name|U8
name|scic_sds_remote_node_table_get_group_value
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U32
name|group_index
parameter_list|)
block|{
name|U32
name|dword_location
decl_stmt|;
name|U32
name|dword_remainder
decl_stmt|;
name|U32
name|dword_value
decl_stmt|;
name|dword_location
operator|=
name|group_index
operator|/
name|SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD
expr_stmt|;
name|dword_remainder
operator|=
name|group_index
operator|%
name|SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD
expr_stmt|;
name|dword_value
operator|=
name|remote_node_table
operator|->
name|available_remote_nodes
index|[
name|dword_location
index|]
expr_stmt|;
name|dword_value
operator|&=
operator|(
name|SCIC_SDS_REMOTE_NODE_TABLE_FULL_SLOT_VALUE
operator|<<
operator|(
name|dword_remainder
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|dword_value
operator|=
name|dword_value
operator|>>
operator|(
name|dword_remainder
operator|*
literal|4
operator|)
expr_stmt|;
return|return
operator|(
name|U8
operator|)
name|dword_value
return|;
block|}
end_function

begin_comment
comment|/**  * This method will initialize the remote node table for use.  *  * @param[in out] remote_node_table The remote that which is to be  *       initialized.  * @param[in] remote_node_entries The number of entries to put in the table.  *  * @return none  */
end_comment

begin_function
name|void
name|scic_sds_remote_node_table_initialize
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U32
name|remote_node_entries
parameter_list|)
block|{
name|U32
name|index
decl_stmt|;
comment|// Initialize the raw data we could improve the speed by only initializing
comment|// those entries that we are actually going to be used
name|memset
argument_list|(
name|remote_node_table
operator|->
name|available_remote_nodes
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
name|remote_node_table
operator|->
name|available_remote_nodes
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|remote_node_table
operator|->
name|remote_node_groups
argument_list|,
literal|0x00
argument_list|,
sizeof|sizeof
argument_list|(
name|remote_node_table
operator|->
name|remote_node_groups
argument_list|)
argument_list|)
expr_stmt|;
comment|// Initialize the available remote node sets
name|remote_node_table
operator|->
name|available_nodes_array_size
operator|=
call|(
name|U16
call|)
argument_list|(
name|remote_node_entries
operator|/
name|SCIC_SDS_REMOTE_NODES_PER_DWORD
argument_list|)
operator|+
operator|(
operator|(
name|remote_node_entries
operator|%
name|SCIC_SDS_REMOTE_NODES_PER_DWORD
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|// Initialize each full DWORD to a FULL SET of remote nodes
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|remote_node_entries
condition|;
name|index
operator|++
control|)
block|{
name|scic_sds_remote_node_table_set_node_index
argument_list|(
name|remote_node_table
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|remote_node_table
operator|->
name|group_array_size
operator|=
call|(
name|U16
call|)
argument_list|(
name|remote_node_entries
operator|/
operator|(
name|SCU_STP_REMOTE_NODE_COUNT
operator|*
literal|32
operator|)
argument_list|)
operator|+
operator|(
operator|(
name|remote_node_entries
operator|%
operator|(
name|SCU_STP_REMOTE_NODE_COUNT
operator|*
literal|32
operator|)
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
operator|(
name|remote_node_entries
operator|/
name|SCU_STP_REMOTE_NODE_COUNT
operator|)
condition|;
name|index
operator|++
control|)
block|{
comment|// These are all guaranteed to be full slot values so fill them in the
comment|// available sets of 3 remote nodes
name|scic_sds_remote_node_table_set_group_index
argument_list|(
name|remote_node_table
argument_list|,
literal|2
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|// Now fill in any remainders that we may find
if|if
condition|(
operator|(
name|remote_node_entries
operator|%
name|SCU_STP_REMOTE_NODE_COUNT
operator|)
operator|==
literal|2
condition|)
block|{
name|scic_sds_remote_node_table_set_group_index
argument_list|(
name|remote_node_table
argument_list|,
literal|1
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|remote_node_entries
operator|%
name|SCU_STP_REMOTE_NODE_COUNT
operator|)
operator|==
literal|1
condition|)
block|{
name|scic_sds_remote_node_table_set_group_index
argument_list|(
name|remote_node_table
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * This method will allocate a single RNi from the remote node table.  The  * table index will determine from which remote node group table to search.  * This search may fail and another group node table can be specified.  The  * function is designed to allow a serach of the available single remote node  * group up to the triple remote node group.  If an entry is found in the  * specified table the remote node is removed and the remote node groups are  * updated.  *  * @param[in out] remote_node_table The remote node table from which to  *       allocate a remote node.  * @param[in] table_index The group index that is to be used for the search.  *  * @return The RNi value or an invalid remote node context if an RNi can not  *         be found.  */
end_comment

begin_function
specifier|static
name|U16
name|scic_sds_remote_node_table_allocate_single_remote_node
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U32
name|group_table_index
parameter_list|)
block|{
name|U8
name|index
decl_stmt|;
name|U8
name|group_value
decl_stmt|;
name|U32
name|group_index
decl_stmt|;
name|U16
name|remote_node_index
init|=
name|SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX
decl_stmt|;
name|group_index
operator|=
name|scic_sds_remote_node_table_get_group_index
argument_list|(
name|remote_node_table
argument_list|,
name|group_table_index
argument_list|)
expr_stmt|;
comment|// We could not find an available slot in the table selector 0
if|if
condition|(
name|group_index
operator|!=
name|SCIC_SDS_REMOTE_NODE_TABLE_INVALID_INDEX
condition|)
block|{
name|group_value
operator|=
name|scic_sds_remote_node_table_get_group_value
argument_list|(
name|remote_node_table
argument_list|,
name|group_index
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCU_STP_REMOTE_NODE_COUNT
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|index
operator|)
operator|&
name|group_value
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// We have selected a bit now clear it
name|remote_node_index
operator|=
call|(
name|U16
call|)
argument_list|(
name|group_index
operator|*
name|SCU_STP_REMOTE_NODE_COUNT
operator|+
name|index
argument_list|)
expr_stmt|;
name|scic_sds_remote_node_table_clear_group_index
argument_list|(
name|remote_node_table
argument_list|,
name|group_table_index
argument_list|,
name|group_index
argument_list|)
expr_stmt|;
name|scic_sds_remote_node_table_clear_node_index
argument_list|(
name|remote_node_table
argument_list|,
name|remote_node_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|group_table_index
operator|>
literal|0
condition|)
block|{
name|scic_sds_remote_node_table_set_group_index
argument_list|(
name|remote_node_table
argument_list|,
name|group_table_index
operator|-
literal|1
argument_list|,
name|group_index
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|remote_node_index
return|;
block|}
end_function

begin_comment
comment|/**  * This method will allocate three consecutive remote node context entries. If  * there are no remaining triple entries the function will return a failure.  *  * @param[in] remote_node_table This is the remote node table from which to  *       allocate the remote node entries.  * @param[in] group_table_index THis is the group table index which must equal  *       two (2) for this operation.  *  * @return The remote node index that represents three consecutive remote node  *         entries or an invalid remote node context if none can be found.  */
end_comment

begin_function
specifier|static
name|U16
name|scic_sds_remote_node_table_allocate_triple_remote_node
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U32
name|group_table_index
parameter_list|)
block|{
name|U32
name|group_index
decl_stmt|;
name|U16
name|remote_node_index
init|=
name|SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX
decl_stmt|;
name|group_index
operator|=
name|scic_sds_remote_node_table_get_group_index
argument_list|(
name|remote_node_table
argument_list|,
name|group_table_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|group_index
operator|!=
name|SCIC_SDS_REMOTE_NODE_TABLE_INVALID_INDEX
condition|)
block|{
name|remote_node_index
operator|=
operator|(
name|U16
operator|)
name|group_index
operator|*
name|SCU_STP_REMOTE_NODE_COUNT
expr_stmt|;
name|scic_sds_remote_node_table_clear_group_index
argument_list|(
name|remote_node_table
argument_list|,
name|group_table_index
argument_list|,
name|group_index
argument_list|)
expr_stmt|;
name|scic_sds_remote_node_table_clear_group
argument_list|(
name|remote_node_table
argument_list|,
name|group_index
argument_list|)
expr_stmt|;
block|}
return|return
name|remote_node_index
return|;
block|}
end_function

begin_comment
comment|/**  * This method will allocate a remote node that mataches the remote node count  * specified by the caller.  Valid values for remote node count is  * SCU_SSP_REMOTE_NODE_COUNT(1) or SCU_STP_REMOTE_NODE_COUNT(3).  *  * @param[in] remote_node_table This is the remote node table from which the  *       remote node allocation is to take place.  * @param[in] remote_node_count This is ther remote node count which is one of  *       SCU_SSP_REMOTE_NODE_COUNT(1) or SCU_STP_REMOTE_NODE_COUNT(3).  *  * @return U16 This is the remote node index that is returned or an invalid  *         remote node context.  */
end_comment

begin_function
name|U16
name|scic_sds_remote_node_table_allocate_remote_node
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U32
name|remote_node_count
parameter_list|)
block|{
name|U16
name|remote_node_index
init|=
name|SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX
decl_stmt|;
if|if
condition|(
name|remote_node_count
operator|==
name|SCU_SSP_REMOTE_NODE_COUNT
condition|)
block|{
name|remote_node_index
operator|=
name|scic_sds_remote_node_table_allocate_single_remote_node
argument_list|(
name|remote_node_table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_node_index
operator|==
name|SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX
condition|)
block|{
name|remote_node_index
operator|=
name|scic_sds_remote_node_table_allocate_single_remote_node
argument_list|(
name|remote_node_table
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remote_node_index
operator|==
name|SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX
condition|)
block|{
name|remote_node_index
operator|=
name|scic_sds_remote_node_table_allocate_single_remote_node
argument_list|(
name|remote_node_table
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|remote_node_count
operator|==
name|SCU_STP_REMOTE_NODE_COUNT
condition|)
block|{
name|remote_node_index
operator|=
name|scic_sds_remote_node_table_allocate_triple_remote_node
argument_list|(
name|remote_node_table
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|remote_node_index
return|;
block|}
end_function

begin_comment
comment|/**  * This method will free a single remote node index back to the remote node  * table.  This routine will update the remote node groups  *  * @param[in] remote_node_table  * @param[in] remote_node_index  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_remote_node_table_release_single_remote_node
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U16
name|remote_node_index
parameter_list|)
block|{
name|U32
name|group_index
decl_stmt|;
name|U8
name|group_value
decl_stmt|;
name|group_index
operator|=
name|remote_node_index
operator|/
name|SCU_STP_REMOTE_NODE_COUNT
expr_stmt|;
name|group_value
operator|=
name|scic_sds_remote_node_table_get_group_value
argument_list|(
name|remote_node_table
argument_list|,
name|group_index
argument_list|)
expr_stmt|;
comment|// Assert that we are not trying to add an entry to a slot that is already
comment|// full.
name|ASSERT
argument_list|(
name|group_value
operator|!=
name|SCIC_SDS_REMOTE_NODE_TABLE_FULL_SLOT_VALUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|group_value
operator|==
literal|0x00
condition|)
block|{
comment|// There are no entries in this slot so it must be added to the single
comment|// slot table.
name|scic_sds_remote_node_table_set_group_index
argument_list|(
name|remote_node_table
argument_list|,
literal|0
argument_list|,
name|group_index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|group_value
operator|&
operator|(
name|group_value
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|// There is only one entry in this slot so it must be moved from the
comment|// single slot table to the dual slot table
name|scic_sds_remote_node_table_clear_group_index
argument_list|(
name|remote_node_table
argument_list|,
literal|0
argument_list|,
name|group_index
argument_list|)
expr_stmt|;
name|scic_sds_remote_node_table_set_group_index
argument_list|(
name|remote_node_table
argument_list|,
literal|1
argument_list|,
name|group_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// There are two entries in the slot so it must be moved from the dual
comment|// slot table to the tripple slot table.
name|scic_sds_remote_node_table_clear_group_index
argument_list|(
name|remote_node_table
argument_list|,
literal|1
argument_list|,
name|group_index
argument_list|)
expr_stmt|;
name|scic_sds_remote_node_table_set_group_index
argument_list|(
name|remote_node_table
argument_list|,
literal|2
argument_list|,
name|group_index
argument_list|)
expr_stmt|;
block|}
name|scic_sds_remote_node_table_set_node_index
argument_list|(
name|remote_node_table
argument_list|,
name|remote_node_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method will release a group of three consecutive remote nodes back to  * the free remote nodes.  *  * @param[in] remote_node_table This is the remote node table to which the  *       remote node index is to be freed.  * @param[in] remote_node_index This is the remote node index which is being  *       freed.  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_remote_node_table_release_triple_remote_node
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U16
name|remote_node_index
parameter_list|)
block|{
name|U32
name|group_index
decl_stmt|;
name|group_index
operator|=
name|remote_node_index
operator|/
name|SCU_STP_REMOTE_NODE_COUNT
expr_stmt|;
name|scic_sds_remote_node_table_set_group_index
argument_list|(
name|remote_node_table
argument_list|,
literal|2
argument_list|,
name|group_index
argument_list|)
expr_stmt|;
name|scic_sds_remote_node_table_set_group
argument_list|(
name|remote_node_table
argument_list|,
name|group_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method will release the remote node index back into the remote node  * table free pool.  *  * @param[in] remote_node_table The remote node table to which the remote node  *       index is to be freed.  * @param[in] remote_node_count This is the count of consecutive remote nodes  *       that are to be freed.  * @param[in] remote_node_index This is the remote node index of the start of  *       the number of remote nodes to be freed.  */
end_comment

begin_function
name|void
name|scic_sds_remote_node_table_release_remote_node_index
parameter_list|(
name|SCIC_REMOTE_NODE_TABLE_T
modifier|*
name|remote_node_table
parameter_list|,
name|U32
name|remote_node_count
parameter_list|,
name|U16
name|remote_node_index
parameter_list|)
block|{
if|if
condition|(
name|remote_node_count
operator|==
name|SCU_SSP_REMOTE_NODE_COUNT
condition|)
block|{
name|scic_sds_remote_node_table_release_single_remote_node
argument_list|(
name|remote_node_table
argument_list|,
name|remote_node_index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|remote_node_count
operator|==
name|SCU_STP_REMOTE_NODE_COUNT
condition|)
block|{
name|scic_sds_remote_node_table_release_triple_remote_node
argument_list|(
name|remote_node_table
argument_list|,
name|remote_node_index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

