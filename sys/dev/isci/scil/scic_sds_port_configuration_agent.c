begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  *  * @brief This file contains the implementation for the public and protected  *        methods for the port configuration agent.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_logger.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_port_configuration_agent.h>
end_include

begin_define
define|#
directive|define
name|SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT
value|(10)
end_define

begin_define
define|#
directive|define
name|SCIC_SDS_APC_RECONFIGURATION_TIMEOUT
value|(10)
end_define

begin_define
define|#
directive|define
name|SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION
value|(250)
end_define

begin_enum
enum|enum
name|SCIC_SDS_APC_ACTIVITY
block|{
name|SCIC_SDS_APC_SKIP_PHY
block|,
name|SCIC_SDS_APC_ADD_PHY
block|,
name|SCIC_SDS_APC_START_TIMER
block|,
name|SCIC_SDS_APC_ACTIVITY_MAX
block|}
enum|;
end_enum

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|// General port configuration agent routines
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * Compare the two SAS Address and  * if SAS Address One is greater than SAS Address Two then return> 0  * else if SAS Address One is less than SAS Address Two return< 0  * Otherwise they are the same return 0  *  * @param[in] address_one A SAS Address to be compared.  * @param[in] address_two A SAS Address to be compared.  *  * @return A signed value of x> 0> y where  *         x is returned for Address One> Address Two  *         y is returned for Address One< Address Two  *         0 is returned ofr Address One = Address Two  */
end_comment

begin_function
specifier|static
name|S32
name|sci_sas_address_compare
parameter_list|(
name|SCI_SAS_ADDRESS_T
name|address_one
parameter_list|,
name|SCI_SAS_ADDRESS_T
name|address_two
parameter_list|)
block|{
if|if
condition|(
name|address_one
operator|.
name|high
operator|>
name|address_two
operator|.
name|high
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|address_one
operator|.
name|high
operator|<
name|address_two
operator|.
name|high
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|address_one
operator|.
name|low
operator|>
name|address_two
operator|.
name|low
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|address_one
operator|.
name|low
operator|<
name|address_two
operator|.
name|low
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// The two SAS Address must be identical
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * This routine will find a matching port for the phy.  This means that the  * port and phy both have the same broadcast sas address and same received  * sas address.  *  * @param[in] controller The controller object used for the port search.  * @param[in] phy The phy object to match.  *  * @return The port address or the SCI_INVALID_HANDLE if there is no matching  *         port.  *  * @retvalue port address if the port can be found to match the phy.  * @retvalue SCI_INVALID_HANDLE if there is no matching port for the phy.  */
end_comment

begin_function
specifier|static
name|SCIC_SDS_PORT_T
modifier|*
name|scic_sds_port_configuration_agent_find_port
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|phy
parameter_list|)
block|{
name|U8
name|port_index
decl_stmt|;
name|SCI_PORT_HANDLE_T
name|port_handle
decl_stmt|;
name|SCI_SAS_ADDRESS_T
name|port_sas_address
decl_stmt|;
name|SCI_SAS_ADDRESS_T
name|port_attached_device_address
decl_stmt|;
name|SCI_SAS_ADDRESS_T
name|phy_sas_address
decl_stmt|;
name|SCI_SAS_ADDRESS_T
name|phy_attached_device_address
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PORT
operator||
name|SCIC_LOG_OBJECT_PHY
operator|,
literal|"scic_sds_port_confgiruation_agent_find_port(0x%08x, 0x%08x) enter\n"
operator|,
name|controller
operator|,
name|phy
operator|)
argument_list|)
expr_stmt|;
comment|// Since this phy can be a member of a wide port check to see if one or
comment|// more phys match the sent and received SAS address as this phy in which
comment|// case it should participate in the same port.
name|scic_sds_phy_get_sas_address
argument_list|(
name|phy
argument_list|,
operator|&
name|phy_sas_address
argument_list|)
expr_stmt|;
name|scic_sds_phy_get_attached_sas_address
argument_list|(
name|phy
argument_list|,
operator|&
name|phy_attached_device_address
argument_list|)
expr_stmt|;
for|for
control|(
name|port_index
operator|=
literal|0
init|;
name|port_index
operator|<
name|SCI_MAX_PORTS
condition|;
name|port_index
operator|++
control|)
block|{
if|if
condition|(
name|scic_controller_get_port_handle
argument_list|(
name|controller
argument_list|,
name|port_index
argument_list|,
operator|&
name|port_handle
argument_list|)
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|SCIC_SDS_PORT_T
modifier|*
name|port
init|=
operator|(
name|SCIC_SDS_PORT_T
operator|*
operator|)
name|port_handle
decl_stmt|;
name|scic_sds_port_get_sas_address
argument_list|(
name|port
argument_list|,
operator|&
name|port_sas_address
argument_list|)
expr_stmt|;
name|scic_sds_port_get_attached_sas_address
argument_list|(
name|port
argument_list|,
operator|&
name|port_attached_device_address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sci_sas_address_compare
argument_list|(
name|port_sas_address
argument_list|,
name|phy_sas_address
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sci_sas_address_compare
argument_list|(
name|port_attached_device_address
argument_list|,
name|phy_attached_device_address
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|port
return|;
block|}
block|}
block|}
return|return
name|SCI_INVALID_HANDLE
return|;
block|}
end_function

begin_comment
comment|/**  * This routine will validate the port configuration is correct for the SCU  * hardware.  The SCU hardware allows for port configurations as follows.  *    LP0 -> (PE0), (PE0, PE1), (PE0, PE1, PE2, PE3)  *    LP1 -> (PE1)  *    LP2 -> (PE2), (PE2, PE3)  *    LP3 -> (PE3)  *  * @param[in] controller This is the controller object that contains the  *            port agent  * @param[in] port_agent This is the port configruation agent for  *            the controller.  *  * @return SCI_STATUS  * @retval SCI_SUCCESS the port configuration is valid for this  *         port configuration agent.  * @retval SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION the port configuration  *         is not valid for this port configuration agent.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_port_configuration_agent_validate_ports
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ARLINGTON_BUILD
argument_list|)
name|SCI_SAS_ADDRESS_T
name|first_address
decl_stmt|;
name|SCI_SAS_ADDRESS_T
name|second_address
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PORT
operator|,
literal|"scic_sds_port_configuration_agent_validate_ports(0x%08x, 0x%08x) enter\n"
operator|,
name|controller
operator|,
name|port_agent
operator|)
argument_list|)
expr_stmt|;
comment|// Sanity check the max ranges for all the phys the max index
comment|// is always equal to the port range index
if|if
condition|(
operator|(
name|port_agent
operator|->
name|phy_valid_port_range
index|[
literal|0
index|]
operator|.
name|max_index
operator|!=
literal|0
operator|)
operator|||
operator|(
name|port_agent
operator|->
name|phy_valid_port_range
index|[
literal|1
index|]
operator|.
name|max_index
operator|!=
literal|1
operator|)
operator|||
operator|(
name|port_agent
operator|->
name|phy_valid_port_range
index|[
literal|2
index|]
operator|.
name|max_index
operator|!=
literal|2
operator|)
operator|||
operator|(
name|port_agent
operator|->
name|phy_valid_port_range
index|[
literal|3
index|]
operator|.
name|max_index
operator|!=
literal|3
operator|)
condition|)
block|{
return|return
name|SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
return|;
block|}
comment|// This is a request to configure a single x4 port or at least attempt
comment|// to make all the phys into a single port
if|if
condition|(
operator|(
name|port_agent
operator|->
name|phy_valid_port_range
index|[
literal|0
index|]
operator|.
name|min_index
operator|==
literal|0
operator|)
operator|&&
operator|(
name|port_agent
operator|->
name|phy_valid_port_range
index|[
literal|1
index|]
operator|.
name|min_index
operator|==
literal|0
operator|)
operator|&&
operator|(
name|port_agent
operator|->
name|phy_valid_port_range
index|[
literal|2
index|]
operator|.
name|min_index
operator|==
literal|0
operator|)
operator|&&
operator|(
name|port_agent
operator|->
name|phy_valid_port_range
index|[
literal|3
index|]
operator|.
name|min_index
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|SCI_SUCCESS
return|;
block|}
comment|// This is a degenerate case where phy 1 and phy 2 are assigned
comment|// to the same port this is explicitly disallowed by the hardware
comment|// unless they are part of the same x4 port and this condition was
comment|// already checked above.
if|if
condition|(
name|port_agent
operator|->
name|phy_valid_port_range
index|[
literal|2
index|]
operator|.
name|min_index
operator|==
literal|1
condition|)
block|{
return|return
name|SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
return|;
block|}
comment|// PE0 and PE3 can never have the same SAS Address unless they
comment|// are part of the same x4 wide port and we have already checked
comment|// for this condition.
name|scic_sds_phy_get_sas_address
argument_list|(
operator|&
name|controller
operator|->
name|phy_table
index|[
literal|0
index|]
argument_list|,
operator|&
name|first_address
argument_list|)
expr_stmt|;
name|scic_sds_phy_get_sas_address
argument_list|(
operator|&
name|controller
operator|->
name|phy_table
index|[
literal|3
index|]
argument_list|,
operator|&
name|second_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|sci_sas_address_compare
argument_list|(
name|first_address
argument_list|,
name|second_address
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
return|;
block|}
comment|// PE0 and PE1 are configured into a 2x1 ports make sure that the
comment|// SAS Address for PE0 and PE2 are different since they can not be
comment|// part of the same port.
if|if
condition|(
operator|(
name|port_agent
operator|->
name|phy_valid_port_range
index|[
literal|0
index|]
operator|.
name|min_index
operator|==
literal|0
operator|)
operator|&&
operator|(
name|port_agent
operator|->
name|phy_valid_port_range
index|[
literal|1
index|]
operator|.
name|min_index
operator|==
literal|1
operator|)
condition|)
block|{
name|scic_sds_phy_get_sas_address
argument_list|(
operator|&
name|controller
operator|->
name|phy_table
index|[
literal|0
index|]
argument_list|,
operator|&
name|first_address
argument_list|)
expr_stmt|;
name|scic_sds_phy_get_sas_address
argument_list|(
operator|&
name|controller
operator|->
name|phy_table
index|[
literal|2
index|]
argument_list|,
operator|&
name|second_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|sci_sas_address_compare
argument_list|(
name|first_address
argument_list|,
name|second_address
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
return|;
block|}
block|}
comment|// PE2 and PE3 are configured into a 2x1 ports make sure that the
comment|// SAS Address for PE1 and PE3 are different since they can not be
comment|// part of the same port.
if|if
condition|(
operator|(
name|port_agent
operator|->
name|phy_valid_port_range
index|[
literal|2
index|]
operator|.
name|min_index
operator|==
literal|2
operator|)
operator|&&
operator|(
name|port_agent
operator|->
name|phy_valid_port_range
index|[
literal|3
index|]
operator|.
name|min_index
operator|==
literal|3
operator|)
condition|)
block|{
name|scic_sds_phy_get_sas_address
argument_list|(
operator|&
name|controller
operator|->
name|phy_table
index|[
literal|1
index|]
argument_list|,
operator|&
name|first_address
argument_list|)
expr_stmt|;
name|scic_sds_phy_get_sas_address
argument_list|(
operator|&
name|controller
operator|->
name|phy_table
index|[
literal|3
index|]
argument_list|,
operator|&
name|second_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|sci_sas_address_compare
argument_list|(
name|first_address
argument_list|,
name|second_address
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
return|;
block|}
block|}
endif|#
directive|endif
comment|// !defined(ARLINGTON_BUILD)
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|// Manual port configuration agent routines
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * This routine will verify that all of the phys in the same port are using  * the same SAS address.  *  * @param[in] controller This is the controller that contains the PHYs to  *            be verified.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_mpc_agent_validate_phy_configuration
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
parameter_list|)
block|{
name|U32
name|phy_mask
decl_stmt|;
name|U32
name|assigned_phy_mask
decl_stmt|;
name|SCI_SAS_ADDRESS_T
name|sas_address
decl_stmt|;
name|SCI_SAS_ADDRESS_T
name|phy_assigned_address
decl_stmt|;
name|U8
name|port_index
decl_stmt|;
name|U8
name|phy_index
decl_stmt|;
name|assigned_phy_mask
operator|=
literal|0
expr_stmt|;
name|sas_address
operator|.
name|high
operator|=
literal|0
expr_stmt|;
name|sas_address
operator|.
name|low
operator|=
literal|0
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PORT
operator|,
literal|"scic_sds_mpc_agent_validate_phy_configuration(0x%08x, 0x%08x) enter\n"
operator|,
name|controller
operator|,
name|port_agent
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|port_index
operator|=
literal|0
init|;
name|port_index
operator|<
name|SCI_MAX_PORTS
condition|;
name|port_index
operator|++
control|)
block|{
name|phy_mask
operator|=
name|controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|ports
index|[
name|port_index
index|]
operator|.
name|phy_mask
expr_stmt|;
if|if
condition|(
name|phy_mask
operator|!=
literal|0
condition|)
block|{
comment|// Make sure that one or more of the phys were not already assinged to
comment|// a different port.
if|if
condition|(
operator|(
name|phy_mask
operator|&
operator|~
name|assigned_phy_mask
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
return|;
block|}
comment|// Find the starting phy index for this round through the loop
for|for
control|(
name|phy_index
operator|=
literal|0
init|;
name|phy_index
operator|<
name|SCI_MAX_PHYS
condition|;
name|phy_index
operator|++
control|)
block|{
if|if
condition|(
operator|(
literal|1
operator|<<
name|phy_index
operator|)
operator|&
name|phy_mask
condition|)
block|{
name|scic_sds_phy_get_sas_address
argument_list|(
operator|&
name|controller
operator|->
name|phy_table
index|[
name|phy_index
index|]
argument_list|,
operator|&
name|sas_address
argument_list|)
expr_stmt|;
comment|// The phy_index can be used as the starting point for the
comment|// port range since the hardware starts all logical ports
comment|// the same as the PE index.
name|port_agent
operator|->
name|phy_valid_port_range
index|[
name|phy_index
index|]
operator|.
name|min_index
operator|=
name|port_index
expr_stmt|;
name|port_agent
operator|->
name|phy_valid_port_range
index|[
name|phy_index
index|]
operator|.
name|max_index
operator|=
name|phy_index
expr_stmt|;
if|if
condition|(
name|phy_index
operator|!=
name|port_index
condition|)
block|{
return|return
name|SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
return|;
block|}
break|break;
block|}
block|}
comment|// See how many additional phys are being added to this logical port.
comment|// Note: We have not moved the current phy_index so we will actually
comment|//       compare the startting phy with itself.
comment|//       This is expected and required to add the phy to the port.
while|while
condition|(
name|phy_index
operator|<
name|SCI_MAX_PHYS
condition|)
block|{
if|if
condition|(
operator|(
literal|1
operator|<<
name|phy_index
operator|)
operator|&
name|phy_mask
condition|)
block|{
name|scic_sds_phy_get_sas_address
argument_list|(
operator|&
name|controller
operator|->
name|phy_table
index|[
name|phy_index
index|]
argument_list|,
operator|&
name|phy_assigned_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|sci_sas_address_compare
argument_list|(
name|sas_address
argument_list|,
name|phy_assigned_address
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|// The phy mask specified that this phy is part of the same port
comment|// as the starting phy and it is not so fail this configuration
return|return
name|SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
return|;
block|}
name|port_agent
operator|->
name|phy_valid_port_range
index|[
name|phy_index
index|]
operator|.
name|min_index
operator|=
name|port_index
expr_stmt|;
name|port_agent
operator|->
name|phy_valid_port_range
index|[
name|phy_index
index|]
operator|.
name|max_index
operator|=
name|phy_index
expr_stmt|;
name|scic_sds_port_add_phy
argument_list|(
operator|&
name|controller
operator|->
name|port_table
index|[
name|port_index
index|]
argument_list|,
operator|&
name|controller
operator|->
name|phy_table
index|[
name|phy_index
index|]
argument_list|)
expr_stmt|;
name|assigned_phy_mask
operator||=
operator|(
literal|1
operator|<<
name|phy_index
operator|)
expr_stmt|;
block|}
name|phy_index
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|scic_sds_port_configuration_agent_validate_ports
argument_list|(
name|controller
argument_list|,
name|port_agent
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * This timer routine is used to allow the SCI User to rediscover or change  * device objects before a new series of link up notifications because a  * link down has allowed a better port configuration.  *  * @param[in] controller This is the core controller object which is used  *            to obtain the port configuration agent.  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_mpc_agent_timeout_handler
parameter_list|(
name|void
modifier|*
name|object
parameter_list|)
block|{
name|U8
name|index
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
decl_stmt|;
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
init|=
operator|&
name|controller
operator|->
name|port_agent
decl_stmt|;
name|U16
name|configure_phy_mask
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PORT
operator|,
literal|"scic_sds_mpc_agent_timeout_handler(0x%08x) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
name|port_agent
operator|->
name|timer_pending
operator|=
name|FALSE
expr_stmt|;
comment|// Find the mask of phys that are reported read but as yet unconfigured into a port
name|configure_phy_mask
operator|=
operator|~
name|port_agent
operator|->
name|phy_configured_mask
operator|&
name|port_agent
operator|->
name|phy_ready_mask
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PHYS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|configure_phy_mask
operator|&
operator|(
literal|1
operator|<<
name|index
operator|)
condition|)
block|{
name|port_agent
operator|->
name|link_up_handler
argument_list|(
name|controller
argument_list|,
name|port_agent
argument_list|,
name|scic_sds_phy_get_port
argument_list|(
operator|&
name|controller
operator|->
name|phy_table
index|[
name|index
index|]
argument_list|)
argument_list|,
operator|&
name|controller
operator|->
name|phy_table
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * This method handles the manual port configuration link up notifications.  * Since all ports and phys are associate at initialization time we just turn  * around and notifiy the port object that there is a link up.  If this PHY is  * not associated with a port there is no action taken.  *  * @param[in] controller This is the controller object that receives the  *            link up notification.  * @param[in] port This is the port object associated with the phy.  If the  *            is no associated port this is an SCI_INVALID_HANDLE.  * @param[in] phy This is the phy object which has gone ready.  *  * @note Is it possible to get a link up notification from a phy that has  *       no assocoated port?  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_mpc_agent_link_up
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
parameter_list|,
name|SCIC_SDS_PORT_T
modifier|*
name|port
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|phy
parameter_list|)
block|{
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PORT
operator||
name|SCIC_LOG_OBJECT_PHY
operator|,
literal|"scic_sds_mpc_agent_link_up(0x%08x, 0x%08x, 0x%08x, 0x%08x) enter\n"
operator|,
name|controller
operator|,
name|port_agent
operator|,
name|port
operator|,
name|phy
operator|)
argument_list|)
expr_stmt|;
comment|// If the port has an invalid handle then the phy was not assigned to
comment|// a port.  This is because the phy was not given the same SAS Address
comment|// as the other PHYs in the port.
if|if
condition|(
name|port
operator|!=
name|SCI_INVALID_HANDLE
condition|)
block|{
name|port_agent
operator|->
name|phy_ready_mask
operator||=
operator|(
literal|1
operator|<<
name|scic_sds_phy_get_index
argument_list|(
name|phy
argument_list|)
operator|)
expr_stmt|;
name|scic_sds_port_link_up
argument_list|(
name|port
argument_list|,
name|phy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|port
operator|->
name|active_phy_mask
operator|&
operator|(
literal|1
operator|<<
name|scic_sds_phy_get_index
argument_list|(
name|phy
argument_list|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|port_agent
operator|->
name|phy_configured_mask
operator||=
operator|(
literal|1
operator|<<
name|scic_sds_phy_get_index
argument_list|(
name|phy
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * This method handles the manual port configuration link down notifications.  * Since all ports and phys are associated at initialization time we just turn  * around and notifiy the port object of the link down event.  If this PHY is  * not associated with a port there is no action taken.  *  * @param[in] controller This is the controller object that receives the  *            link down notification.  * @param[in] port This is the port object associated with the phy.  If the  *            is no associated port this is an SCI_INVALID_HANDLE.  The port  *            is an invalid handle only if the phy was never port of this  *            port.  This happens when the phy is not broadcasting the same  *            SAS address as the other phys in the assigned port.  * @param[in] phy This is the phy object which has gone link down.  *  * @note Is it possible to get a link down notification from a phy that has  *       no assocoated port?  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_mpc_agent_link_down
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
parameter_list|,
name|SCIC_SDS_PORT_T
modifier|*
name|port
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|phy
parameter_list|)
block|{
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PORT
operator||
name|SCIC_LOG_OBJECT_PHY
operator|,
literal|"scic_sds_mpc_agent_link_down(0x%08x, 0x%08x, 0x%08x, 0x%08x) enter\n"
operator|,
name|controller
operator|,
name|port_agent
operator|,
name|port
operator|,
name|phy
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|!=
name|SCI_INVALID_HANDLE
condition|)
block|{
comment|// If we can form a new port from the remainder of the phys then we want
comment|// to start the timer to allow the SCI User to cleanup old devices and
comment|// rediscover the port before rebuilding the port with the phys that
comment|// remain in the ready state.
name|port_agent
operator|->
name|phy_ready_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|scic_sds_phy_get_index
argument_list|(
name|phy
argument_list|)
operator|)
expr_stmt|;
name|port_agent
operator|->
name|phy_configured_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|scic_sds_phy_get_index
argument_list|(
name|phy
argument_list|)
operator|)
expr_stmt|;
comment|// Check to see if there are more phys waiting to be configured into a port.
comment|// If there are allow the SCI User to tear down this port, if necessary, and
comment|// then reconstruc the port after the timeout.
if|if
condition|(
operator|(
name|port_agent
operator|->
name|phy_configured_mask
operator|==
literal|0x0000
operator|)
operator|&&
operator|(
name|port_agent
operator|->
name|phy_ready_mask
operator|!=
literal|0x0000
operator|)
operator|&&
operator|!
name|port_agent
operator|->
name|timer_pending
condition|)
block|{
name|port_agent
operator|->
name|timer_pending
operator|=
name|TRUE
expr_stmt|;
name|scic_cb_timer_start
argument_list|(
name|controller
argument_list|,
name|port_agent
operator|->
name|timer
argument_list|,
name|SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT
argument_list|)
expr_stmt|;
block|}
name|scic_sds_port_link_down
argument_list|(
name|port
argument_list|,
name|phy
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|// Automatic port configuration agent routines
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * This routine will verify that the phys are assigned a valid SAS address for  * automatic port configuration mode.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_apc_agent_validate_phy_configuration
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
parameter_list|)
block|{
name|U8
name|phy_index
decl_stmt|;
name|U8
name|port_index
decl_stmt|;
name|SCI_SAS_ADDRESS_T
name|sas_address
decl_stmt|;
name|SCI_SAS_ADDRESS_T
name|phy_assigned_address
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PORT
operator|,
literal|"scic_sds_apc_agent_validate_phy_configuration(0x%08x, 0x%08x) enter\n"
operator|,
name|controller
operator|,
name|port_agent
operator|)
argument_list|)
expr_stmt|;
name|phy_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|phy_index
operator|<
name|SCI_MAX_PHYS
condition|)
block|{
name|port_index
operator|=
name|phy_index
expr_stmt|;
comment|// Get the assigned SAS Address for the first PHY on the controller.
name|scic_sds_phy_get_sas_address
argument_list|(
operator|&
name|controller
operator|->
name|phy_table
index|[
name|phy_index
index|]
argument_list|,
operator|&
name|sas_address
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|phy_index
operator|<
name|SCI_MAX_PHYS
condition|)
block|{
name|scic_sds_phy_get_sas_address
argument_list|(
operator|&
name|controller
operator|->
name|phy_table
index|[
name|phy_index
index|]
argument_list|,
operator|&
name|phy_assigned_address
argument_list|)
expr_stmt|;
comment|// Verify each of the SAS address are all the same for every PHY
if|if
condition|(
name|sci_sas_address_compare
argument_list|(
name|sas_address
argument_list|,
name|phy_assigned_address
argument_list|)
operator|==
literal|0
condition|)
block|{
name|port_agent
operator|->
name|phy_valid_port_range
index|[
name|phy_index
index|]
operator|.
name|min_index
operator|=
name|port_index
expr_stmt|;
name|port_agent
operator|->
name|phy_valid_port_range
index|[
name|phy_index
index|]
operator|.
name|max_index
operator|=
name|phy_index
expr_stmt|;
block|}
else|else
block|{
name|port_agent
operator|->
name|phy_valid_port_range
index|[
name|phy_index
index|]
operator|.
name|min_index
operator|=
name|phy_index
expr_stmt|;
name|port_agent
operator|->
name|phy_valid_port_range
index|[
name|phy_index
index|]
operator|.
name|max_index
operator|=
name|phy_index
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|scic_sds_port_configuration_agent_validate_ports
argument_list|(
name|controller
argument_list|,
name|port_agent
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * This routine will restart the automatic port configuration timeout  * timer for the next time period.  This could be caused by either a  * link down event or a link up event where we can not yet tell to which  * port a phy belongs.  *  * @param[in] controller This is the controller that to which the port  *            agent is assigned.  * @param[in] port_agent This is the port agent that is requesting the  *            timer start operation.  * @param[in] phy This is the phy that has caused the timer operation to  *            be scheduled.  * @param[in] timeout This is the timeout in ms.  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_apc_agent_start_timer
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|phy
parameter_list|,
name|U32
name|timeout
parameter_list|)
block|{
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PORT
operator||
name|SCIC_LOG_OBJECT_PHY
operator|,
literal|"scic_sds_apc_agent_start_timer(0x%08x, 0x%08x, 0x%08x, 0x%08x) enter\n"
operator|,
name|controller
operator|,
name|port_agent
operator|,
name|phy
operator|,
name|timeout
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_agent
operator|->
name|timer_pending
condition|)
block|{
name|scic_cb_timer_stop
argument_list|(
name|controller
argument_list|,
name|port_agent
operator|->
name|timer
argument_list|)
expr_stmt|;
block|}
name|port_agent
operator|->
name|timer_pending
operator|=
name|TRUE
expr_stmt|;
name|scic_cb_timer_start
argument_list|(
name|controller
argument_list|,
name|port_agent
operator|->
name|timer
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method handles the automatic port configuration for link up notifications.  *  * @param[in] controller This is the controller object that receives the  *            link up notification.  * @param[in] phy This is the phy object which has gone link up.  * @param[in] start_timer This tells the routine if it should start the timer for  *            any phys that might be added to a port in the future.  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_apc_agent_configure_ports
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|phy
parameter_list|,
name|BOOL
name|start_timer
parameter_list|)
block|{
name|U8
name|port_index
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIC_SDS_PORT_T
modifier|*
name|port
decl_stmt|;
name|SCI_PORT_HANDLE_T
name|port_handle
decl_stmt|;
name|enum
name|SCIC_SDS_APC_ACTIVITY
name|apc_activity
init|=
name|SCIC_SDS_APC_SKIP_PHY
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PORT
operator||
name|SCIC_LOG_OBJECT_PHY
operator|,
literal|"scic_sds_apc_agent_configure_ports(0x%08x, 0x%08x, 0x%08x, %d) enter\n"
operator|,
name|controller
operator|,
name|port_agent
operator|,
name|phy
operator|,
name|start_timer
operator|)
argument_list|)
expr_stmt|;
name|port
operator|=
name|scic_sds_port_configuration_agent_find_port
argument_list|(
name|controller
argument_list|,
name|phy
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|!=
name|SCI_INVALID_HANDLE
condition|)
block|{
if|if
condition|(
name|scic_sds_port_is_valid_phy_assignment
argument_list|(
name|port
argument_list|,
name|phy
operator|->
name|phy_index
argument_list|)
condition|)
name|apc_activity
operator|=
name|SCIC_SDS_APC_ADD_PHY
expr_stmt|;
else|else
name|apc_activity
operator|=
name|SCIC_SDS_APC_SKIP_PHY
expr_stmt|;
block|}
else|else
block|{
comment|// There is no matching Port for this PHY so lets search through the
comment|// Ports and see if we can add the PHY to its own port or maybe start
comment|// the timer and wait to see if a wider port can be made.
comment|//
comment|// Note the break when we reach the condition of the port id == phy id
for|for
control|(
name|port_index
operator|=
name|port_agent
operator|->
name|phy_valid_port_range
index|[
name|phy
operator|->
name|phy_index
index|]
operator|.
name|min_index
init|;
name|port_index
operator|<=
name|port_agent
operator|->
name|phy_valid_port_range
index|[
name|phy
operator|->
name|phy_index
index|]
operator|.
name|max_index
condition|;
name|port_index
operator|++
control|)
block|{
name|scic_controller_get_port_handle
argument_list|(
name|controller
argument_list|,
name|port_index
argument_list|,
operator|&
name|port_handle
argument_list|)
expr_stmt|;
name|port
operator|=
operator|(
name|SCIC_SDS_PORT_T
operator|*
operator|)
name|port_handle
expr_stmt|;
comment|// First we must make sure that this PHY can be added to this Port.
if|if
condition|(
name|scic_sds_port_is_valid_phy_assignment
argument_list|(
name|port
argument_list|,
name|phy
operator|->
name|phy_index
argument_list|)
condition|)
block|{
comment|// Port contains a PHY with a greater PHY ID than the current
comment|// PHY that has gone link up.  This phy can not be part of any
comment|// port so skip it and move on.
if|if
condition|(
name|port
operator|->
name|active_phy_mask
operator|>
operator|(
literal|1
operator|<<
name|phy
operator|->
name|phy_index
operator|)
condition|)
block|{
name|apc_activity
operator|=
name|SCIC_SDS_APC_SKIP_PHY
expr_stmt|;
break|break;
block|}
comment|// We have reached the end of our Port list and have not found
comment|// any reason why we should not either add the PHY to the port
comment|// or wait for more phys to become active.
if|if
condition|(
name|port
operator|->
name|physical_port_index
operator|==
name|phy
operator|->
name|phy_index
condition|)
block|{
comment|// The Port either has no active PHYs.
comment|// Consider that if the port had any active PHYs we would have
comment|// or active PHYs with
comment|// a lower PHY Id than this PHY.
if|if
condition|(
name|apc_activity
operator|!=
name|SCIC_SDS_APC_START_TIMER
condition|)
block|{
name|apc_activity
operator|=
name|SCIC_SDS_APC_ADD_PHY
expr_stmt|;
block|}
break|break;
block|}
comment|// The current Port has no active PHYs and this PHY could be part
comment|// of this Port.  Since we dont know as yet setup to start the
comment|// timer and see if there is a better configuration.
if|if
condition|(
name|port
operator|->
name|active_phy_mask
operator|==
literal|0
condition|)
block|{
name|apc_activity
operator|=
name|SCIC_SDS_APC_START_TIMER
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|port
operator|->
name|active_phy_mask
operator|!=
literal|0
condition|)
block|{
comment|// The Port has an active phy and the current Phy can not
comment|// participate in this port so skip the PHY and see if
comment|// there is a better configuration.
name|apc_activity
operator|=
name|SCIC_SDS_APC_SKIP_PHY
expr_stmt|;
block|}
block|}
block|}
comment|// Check to see if the start timer operations should instead map to an
comment|// add phy operation.  This is caused because we have been waiting to
comment|// add a phy to a port but could not becuase the automatic port
comment|// configuration engine had a choice of possible ports for the phy.
comment|// Since we have gone through a timeout we are going to restrict the
comment|// choice to the smallest possible port.
if|if
condition|(
operator|(
name|start_timer
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|apc_activity
operator|==
name|SCIC_SDS_APC_START_TIMER
operator|)
condition|)
block|{
name|apc_activity
operator|=
name|SCIC_SDS_APC_ADD_PHY
expr_stmt|;
block|}
switch|switch
condition|(
name|apc_activity
condition|)
block|{
case|case
name|SCIC_SDS_APC_ADD_PHY
case|:
name|status
operator|=
name|scic_sds_port_add_phy
argument_list|(
name|port
argument_list|,
name|phy
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|port_agent
operator|->
name|phy_configured_mask
operator||=
operator|(
literal|1
operator|<<
name|phy
operator|->
name|phy_index
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|SCIC_SDS_APC_START_TIMER
case|:
name|scic_sds_apc_agent_start_timer
argument_list|(
name|controller
argument_list|,
name|port_agent
argument_list|,
name|phy
argument_list|,
name|SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCIC_SDS_APC_SKIP_PHY
case|:
default|default:
comment|// do nothing the PHY can not be made part of a port at this time.
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * This method handles the automatic port configuration for link up notifications.  *  * @param[in] controller This is the controller object that receives the  *            link up notification.  * @param[in] port This is the port object associated with the phy.  If the  *            is no associated port this is an SCI_INVALID_HANDLE.  * @param[in] phy This is the phy object which has gone link up.  *  * @note Is it possible to get a link down notification from a phy that has  *       no assocoated port?  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_apc_agent_link_up
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
parameter_list|,
name|SCIC_SDS_PORT_T
modifier|*
name|port
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|phy
parameter_list|)
block|{
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PORT
operator||
name|SCIC_LOG_OBJECT_PHY
operator|,
literal|"scic_sds_apc_agent_link_up(0x%08x, 0x%08x, 0x%08x, 0x%08x) enter\n"
operator|,
name|controller
operator|,
name|port_agent
operator|,
name|port
operator|,
name|phy
operator|)
argument_list|)
expr_stmt|;
comment|//the phy is not the part of this port, configure the port with this phy
if|if
condition|(
name|port
operator|==
name|SCI_INVALID_HANDLE
condition|)
block|{
name|port_agent
operator|->
name|phy_ready_mask
operator||=
operator|(
literal|1
operator|<<
name|scic_sds_phy_get_index
argument_list|(
name|phy
argument_list|)
operator|)
expr_stmt|;
name|scic_sds_apc_agent_start_timer
argument_list|(
name|controller
argument_list|,
name|port_agent
argument_list|,
name|phy
argument_list|,
name|SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//the phy is already the part of the port
comment|//if the PORT'S state is resetting then the link up is from port hard reset
comment|//in this case, we need to tell the port that link up is recieved
if|if
condition|(
name|SCI_BASE_PORT_STATE_RESETTING
operator|==
name|port
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
condition|)
block|{
comment|//notify the port that port needs to be ready
name|port_agent
operator|->
name|phy_ready_mask
operator||=
operator|(
literal|1
operator|<<
name|scic_sds_phy_get_index
argument_list|(
name|phy
argument_list|)
operator|)
expr_stmt|;
name|scic_sds_port_link_up
argument_list|(
name|port
argument_list|,
name|phy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * This method handles the automatic port configuration link down notifications.  * If this PHY is * not associated with a port there is no action taken.  *  * @param[in] controller This is the controller object that receives the  *            link down notification.  * @param[in] port This is the port object associated with the phy.  If the  *            is no associated port this is an SCI_INVALID_HANDLE.  * @param[in] phy This is the phy object which has gone link down.  *  * @note Is it possible to get a link down notification from a phy that has  *       no assocoated port?  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_apc_agent_link_down
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
parameter_list|,
name|SCIC_SDS_PORT_T
modifier|*
name|port
parameter_list|,
name|SCIC_SDS_PHY_T
modifier|*
name|phy
parameter_list|)
block|{
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PORT
operator||
name|SCIC_LOG_OBJECT_PHY
operator|,
literal|"scic_sds_apc_agent_link_down(0x%08x, 0x%08x, 0x%08x, 0x%08x) enter\n"
operator|,
name|controller
operator|,
name|port_agent
operator|,
name|port
operator|,
name|phy
operator|)
argument_list|)
expr_stmt|;
name|port_agent
operator|->
name|phy_ready_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|scic_sds_phy_get_index
argument_list|(
name|phy
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|port
operator|!=
name|SCI_INVALID_HANDLE
condition|)
block|{
if|if
condition|(
name|port_agent
operator|->
name|phy_configured_mask
operator|&
operator|(
literal|1
operator|<<
name|phy
operator|->
name|phy_index
operator|)
condition|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|status
operator|=
name|scic_sds_port_remove_phy
argument_list|(
name|port
argument_list|,
name|phy
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|port_agent
operator|->
name|phy_configured_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|phy
operator|->
name|phy_index
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * This routine will try to configure the phys into ports when the timer fires.  *  * @param[in] object This is actually the controller that needs to have the  *            pending phys configured.  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_apc_agent_timeout_handler
parameter_list|(
name|void
modifier|*
name|object
parameter_list|)
block|{
name|U32
name|index
decl_stmt|;
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
init|=
operator|(
name|SCIC_SDS_CONTROLLER_T
operator|*
operator|)
name|object
decl_stmt|;
name|U16
name|configure_phy_mask
decl_stmt|;
name|port_agent
operator|=
name|scic_sds_controller_get_port_configuration_agent
argument_list|(
name|controller
argument_list|)
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PORT
operator|,
literal|"scic_sds_apc_agent_timeout_handler(0x%08x) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
name|port_agent
operator|->
name|timer_pending
operator|=
name|FALSE
expr_stmt|;
name|configure_phy_mask
operator|=
operator|~
name|port_agent
operator|->
name|phy_configured_mask
operator|&
name|port_agent
operator|->
name|phy_ready_mask
expr_stmt|;
if|if
condition|(
name|configure_phy_mask
operator|!=
literal|0x00
condition|)
block|{
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PHYS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|configure_phy_mask
operator|&
operator|(
literal|1
operator|<<
name|index
operator|)
condition|)
block|{
name|scic_sds_apc_agent_configure_ports
argument_list|(
name|controller
argument_list|,
name|port_agent
argument_list|,
operator|&
name|controller
operator|->
name|phy_table
index|[
name|index
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
comment|//Notify the controller ports are configured.
if|if
condition|(
operator|(
name|port_agent
operator|->
name|phy_ready_mask
operator|==
name|port_agent
operator|->
name|phy_configured_mask
operator|)
operator|&&
operator|(
name|controller
operator|->
name|next_phy_to_start
operator|==
name|SCI_MAX_PHYS
operator|)
operator|&&
operator|(
name|controller
operator|->
name|phy_startup_timer_pending
operator|==
name|FALSE
operator|)
condition|)
block|{
comment|// The controller has successfully finished the start process.
comment|// Inform the SCI Core user and transition to the READY state.
if|if
condition|(
name|scic_sds_controller_is_start_complete
argument_list|(
name|controller
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|scic_sds_controller_port_agent_configured_ports
argument_list|(
name|controller
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|// Public port configuration agent routines
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * This method will construct the port configuration agent for operation.  * This call is universal for both manual port configuration and automatic  * port configuration modes.  *  * @param[in] port_agent This is the port configuration agent for this  *            controller object.  */
end_comment

begin_function
name|void
name|scic_sds_port_configuration_agent_construct
parameter_list|(
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
parameter_list|)
block|{
name|U32
name|index
decl_stmt|;
name|port_agent
operator|->
name|phy_configured_mask
operator|=
literal|0x00
expr_stmt|;
name|port_agent
operator|->
name|phy_ready_mask
operator|=
literal|0x00
expr_stmt|;
name|port_agent
operator|->
name|link_up_handler
operator|=
name|NULL
expr_stmt|;
name|port_agent
operator|->
name|link_down_handler
operator|=
name|NULL
expr_stmt|;
name|port_agent
operator|->
name|timer_pending
operator|=
name|FALSE
expr_stmt|;
name|port_agent
operator|->
name|timer
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_PORTS
condition|;
name|index
operator|++
control|)
block|{
name|port_agent
operator|->
name|phy_valid_port_range
index|[
name|index
index|]
operator|.
name|min_index
operator|=
literal|0
expr_stmt|;
name|port_agent
operator|->
name|phy_valid_port_range
index|[
name|index
index|]
operator|.
name|max_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * This method will construct the port configuration agent for this controller.  *  * @param[in] controller This is the controller object for which the port  *            agent is being initialized.  *  * @param[in] port_agent This is the port configuration agent that is being  *            initialized.  The initialization path is handled differntly  *            for the automatic port configuration agent and the manual port  *            configuration agent.  *  * @return  */
end_comment

begin_function
name|SCI_STATUS
name|scic_sds_port_configuration_agent_initialize
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|enum
name|SCIC_PORT_CONFIGURATION_MODE
name|mode
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator||
name|SCIC_LOG_OBJECT_PORT
operator|,
literal|"scic_sds_port_configuration_agent_initialize(0x%08x, 0x%08x) enter\n"
operator|,
name|controller
operator|,
name|port_agent
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|controller
operator|->
name|oem_parameters
operator|.
name|sds1
operator|.
name|controller
operator|.
name|mode_type
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SCIC_PORT_MANUAL_CONFIGURATION_MODE
condition|)
block|{
name|status
operator|=
name|scic_sds_mpc_agent_validate_phy_configuration
argument_list|(
name|controller
argument_list|,
name|port_agent
argument_list|)
expr_stmt|;
name|port_agent
operator|->
name|link_up_handler
operator|=
name|scic_sds_mpc_agent_link_up
expr_stmt|;
name|port_agent
operator|->
name|link_down_handler
operator|=
name|scic_sds_mpc_agent_link_down
expr_stmt|;
name|port_agent
operator|->
name|timer
operator|=
name|scic_cb_timer_create
argument_list|(
name|controller
argument_list|,
name|scic_sds_mpc_agent_timeout_handler
argument_list|,
name|controller
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|scic_sds_apc_agent_validate_phy_configuration
argument_list|(
name|controller
argument_list|,
name|port_agent
argument_list|)
expr_stmt|;
name|port_agent
operator|->
name|link_up_handler
operator|=
name|scic_sds_apc_agent_link_up
expr_stmt|;
name|port_agent
operator|->
name|link_down_handler
operator|=
name|scic_sds_apc_agent_link_down
expr_stmt|;
name|port_agent
operator|->
name|timer
operator|=
name|scic_cb_timer_create
argument_list|(
name|controller
argument_list|,
name|scic_sds_apc_agent_timeout_handler
argument_list|,
name|controller
argument_list|)
expr_stmt|;
block|}
comment|// Make sure we have actually gotten a timer
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
operator|&&
name|port_agent
operator|->
name|timer
operator|==
name|NULL
condition|)
block|{
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller 0x%x automatic port configuration agent could not get timer.\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|SCI_FAILURE
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * This method will destroy the port configuration agent for this controller.  *  * @param[in] controller This is the controller object for which the port  *            agent is being destroyed.  *  * @param[in] port_agent This is the port configuration agent that is being  *            destroyed.  *  * @return  */
end_comment

begin_function
name|void
name|scic_sds_port_configuration_agent_destroy
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
parameter_list|)
block|{
if|if
condition|(
name|port_agent
operator|->
name|timer_pending
operator|==
name|TRUE
condition|)
block|{
name|scic_cb_timer_stop
argument_list|(
name|controller
argument_list|,
name|port_agent
operator|->
name|timer
argument_list|)
expr_stmt|;
block|}
name|scic_cb_timer_destroy
argument_list|(
name|controller
argument_list|,
name|port_agent
operator|->
name|timer
argument_list|)
expr_stmt|;
name|port_agent
operator|->
name|timer_pending
operator|=
name|FALSE
expr_stmt|;
name|port_agent
operator|->
name|timer
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method release resources in for a scic port configuration agent.  *  * @param[in] controller This parameter specifies the core controller, one of  *            its phy's resources are to be released.  * @param[in] this_phy This parameter specifies the phy whose resource is to  *            be released.  */
end_comment

begin_function
name|void
name|scic_sds_port_configuration_agent_release_resource
parameter_list|(
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCIC_SDS_PORT_CONFIGURATION_AGENT_T
modifier|*
name|port_agent
parameter_list|)
block|{
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_PORT
operator|,
literal|"scic_sds_port_configuration_agent_release_resource(0x%x, 0x%x)\n"
operator|,
name|controller
operator|,
name|port_agent
operator|)
argument_list|)
expr_stmt|;
comment|//Currently, the only resource to be released is a timer.
if|if
condition|(
name|port_agent
operator|->
name|timer
operator|!=
name|NULL
condition|)
block|{
name|scic_cb_timer_destroy
argument_list|(
name|controller
argument_list|,
name|port_agent
operator|->
name|timer
argument_list|)
expr_stmt|;
name|port_agent
operator|->
name|timer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

end_unit

