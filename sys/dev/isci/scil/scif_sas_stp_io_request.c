begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  *  * @brief This file contains the method implementations for the  *        SCIF_SAS_STP_IO_REQUEST object.  The contents will implement  *        SATA/STP specific functionality.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_stp_io_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_stp_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_logger.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_status.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_io_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sati.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sati_atapi.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_sat.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sati_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sati_callbacks.h>
end_include

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|// P R I V A T E   M E T H O D S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method provides SATA/STP CONSTRUCTED state specific handling  *        for when the user attempts to start the supplied IO request.  It  *        will allocate NCQ tags if necessary.  *  * @param[in] io_request This parameter specifies the IO request object  *            to be started.  *  * @return This method returns a value indicating if the IO request was  *         successfully started or not.  * @retval SCI_SUCCESS This return value indicates successful starting  *         of the IO request.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_stp_io_request_constructed_start_handler
parameter_list|(
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|)
block|{
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
init|=
operator|(
name|SCIF_SAS_IO_REQUEST_T
operator|*
operator|)
name|io_request
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|io_request
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_sas_stp_io_request_constructed_start_handler(0x%x) enter\n"
operator|,
name|io_request
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
operator|.
name|protocol
operator|==
name|SAT_PROTOCOL_FPDMA
condition|)
block|{
name|SATA_FIS_REG_H2D_T
modifier|*
name|fis
decl_stmt|;
comment|// For NCQ, we need to attempt to allocate an available tag.
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|ncq_tag
operator|=
name|scif_sas_stp_remote_device_allocate_ncq_tag
argument_list|(
name|fw_io
operator|->
name|parent
operator|.
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|ncq_tag
operator|==
name|SCIF_SAS_INVALID_NCQ_TAG
condition|)
return|return
name|SCI_FAILURE_NO_NCQ_TAG_AVAILABLE
return|;
comment|// Set the NCQ tag in the host to device register FIS (upper 5 bits
comment|// of the 8-bit sector count register).
name|fis
operator|=
name|scic_stp_io_request_get_h2d_reg_address
argument_list|(
name|fw_io
operator|->
name|parent
operator|.
name|core_object
argument_list|)
expr_stmt|;
name|fis
operator|->
name|sector_count
operator|=
operator|(
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|ncq_tag
operator|<<
literal|3
operator|)
expr_stmt|;
comment|// The Core also requires that we inform it separately regarding the
comment|// NCQ tag for this IO.
name|scic_stp_io_request_set_ncq_tag
argument_list|(
name|fw_io
operator|->
name|parent
operator|.
name|core_object
argument_list|,
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|ncq_tag
argument_list|)
expr_stmt|;
block|}
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides SATA/STP CONSTRUCTED state specific handling  *        for when the user attempts to complete the supplied IO request.  *        This method will be invoked in the event the call to start the  *        core IO request fails for some reason.  In this situation, the  *        NCQ tag will be freed.  *  * @param[in] io_request This parameter specifies the IO request object  *            to be started.  *  * @return This method returns a value indicating if the IO request was  *         successfully started or not.  * @retval SCI_SUCCESS This return value indicates successful starting  *         of the IO request.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_stp_io_request_constructed_complete_handler
parameter_list|(
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|)
block|{
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
init|=
operator|(
name|SCIF_SAS_IO_REQUEST_T
operator|*
operator|)
name|io_request
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|io_request
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_sas_stp_io_request_constructed_complete_handler(0x%x) enter\n"
operator|,
name|io_request
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
operator|.
name|protocol
operator|==
name|SAT_PROTOCOL_FPDMA
condition|)
block|{
comment|// For NCQ, we need to return the tag back to the free pool.
if|if
condition|(
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|ncq_tag
operator|!=
name|SCIF_SAS_INVALID_NCQ_TAG
condition|)
name|scif_sas_stp_remote_device_free_ncq_tag
argument_list|(
name|fw_io
operator|->
name|parent
operator|.
name|device
argument_list|,
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|ncq_tag
argument_list|)
expr_stmt|;
block|}
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides SATA/STP STARTED state specific handling for  *        when the user attempts to complete the supplied IO request.  *        It will perform data/response translation and free NCQ tags  *        if necessary.  *  * @param[in] io_request This parameter specifies the IO request object  *            to be started.  *  * @return This method returns a value indicating if the IO request was  *         successfully completed or not.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_stp_core_cb_io_request_complete_handler
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|,
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SCIF_SAS_REQUEST_T
modifier|*
name|fw_request
parameter_list|,
name|SCI_STATUS
modifier|*
name|completion_status
parameter_list|)
block|{
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
init|=
operator|(
name|SCIF_SAS_IO_REQUEST_T
operator|*
operator|)
name|fw_request
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_sas_stp_core_cb_io_request_complete_handler(0x%x, 0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|fw_controller
operator|,
name|fw_device
operator|,
name|fw_request
operator|,
operator|*
name|completion_status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
operator|.
name|protocol
operator|==
name|SAT_PROTOCOL_FPDMA
condition|)
name|scif_sas_stp_remote_device_free_ncq_tag
argument_list|(
name|fw_request
operator|->
name|device
argument_list|,
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|ncq_tag
argument_list|)
expr_stmt|;
comment|// Translating the response is only necessary if:
comment|// - some sort of error occurred resulting in having the error bit
comment|//   set in the ATA status register and values to decode in the
comment|//   ATA error register.
comment|// - the command returns information in the register FIS itself,
comment|//   which requires translation.
comment|// - the request completed ok but the sequence requires a callback
comment|//   to possibly continue the translation
if|if
condition|(
operator|(
operator|*
name|completion_status
operator|==
name|SCI_FAILURE_IO_RESPONSE_VALID
operator|)
operator|||
operator|(
operator|(
name|sati_cb_do_translate_response
argument_list|(
name|fw_request
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|completion_status
operator|!=
name|SCI_FAILURE_IO_TERMINATED
operator|)
operator|)
condition|)
block|{
name|SATI_STATUS
name|sati_status
init|=
name|sati_translate_command_response
argument_list|(
operator|&
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
argument_list|,
name|fw_io
argument_list|,
name|fw_io
argument_list|)
decl_stmt|;
if|if
condition|(
name|sati_status
operator|==
name|SATI_COMPLETE
condition|)
operator|*
name|completion_status
operator|=
name|SCI_SUCCESS
expr_stmt|;
elseif|else
if|if
condition|(
name|sati_status
operator|==
name|SATI_FAILURE_CHECK_RESPONSE_DATA
condition|)
operator|*
name|completion_status
operator|=
name|SCI_FAILURE_IO_RESPONSE_VALID
expr_stmt|;
elseif|else
if|if
condition|(
name|sati_status
operator|==
name|SATI_SEQUENCE_INCOMPLETE
condition|)
block|{
comment|// The translation indicates that additional SATA requests are
comment|// necessary to finish the original SCSI request.  As a result,
comment|// do not complete the IO and begin the next stage of the
comment|// translation.
return|return
name|SCI_WARNING_SEQUENCE_INCOMPLETE
return|;
block|}
elseif|else
if|if
condition|(
name|sati_status
operator|==
name|SATI_COMPLETE_IO_DONE_EARLY
condition|)
operator|*
name|completion_status
operator|=
name|SCI_SUCCESS_IO_DONE_EARLY
expr_stmt|;
else|else
block|{
comment|// Something unexpected occurred during translation.  Fail the
comment|// IO request to the user.
operator|*
name|completion_status
operator|=
name|SCI_FAILURE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|completion_status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|SCIF_LOG_INFO
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"Sequence Terminated(0x%x, 0x%x, 0x%x)\n"
operator|,
name|fw_controller
operator|,
name|fw_device
operator|,
name|fw_request
operator|)
argument_list|)
expr_stmt|;
name|sati_sequence_terminate
argument_list|(
operator|&
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
argument_list|,
name|fw_io
argument_list|,
name|fw_io
argument_list|)
expr_stmt|;
block|}
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_ATAPI
argument_list|)
end_if

begin_comment
comment|/**  * @brief This method provides STP PACKET io request STARTED state specific handling for  *        when the user attempts to complete the supplied IO request.  *        It will perform data/response translation.  *  * @param[in] io_request This parameter specifies the IO request object  *            to be started.  *  * @return This method returns a value indicating if the IO request was  *         successfully completed or not.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_stp_core_cb_packet_io_request_complete_handler
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|,
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SCIF_SAS_REQUEST_T
modifier|*
name|fw_request
parameter_list|,
name|SCI_STATUS
modifier|*
name|completion_status
parameter_list|)
block|{
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
init|=
operator|(
name|SCIF_SAS_IO_REQUEST_T
operator|*
operator|)
name|fw_request
decl_stmt|;
name|SATI_STATUS
name|sati_status
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_sas_stp_packet_core_cb_io_request_complete_handler(0x%x, 0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|fw_controller
operator|,
name|fw_device
operator|,
name|fw_request
operator|,
operator|*
name|completion_status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|completion_status
operator|==
name|SCI_FAILURE_IO_RESPONSE_VALID
condition|)
block|{
name|sati_status
operator|=
name|sati_atapi_translate_command_response
argument_list|(
operator|&
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
argument_list|,
name|fw_io
argument_list|,
name|fw_io
argument_list|)
expr_stmt|;
if|if
condition|(
name|sati_status
operator|==
name|SATI_COMPLETE
condition|)
operator|*
name|completion_status
operator|=
name|SCI_SUCCESS
expr_stmt|;
elseif|else
if|if
condition|(
name|sati_status
operator|==
name|SATI_FAILURE_CHECK_RESPONSE_DATA
condition|)
operator|*
name|completion_status
operator|=
name|SCI_FAILURE_IO_RESPONSE_VALID
expr_stmt|;
elseif|else
if|if
condition|(
name|sati_status
operator|==
name|SATI_SEQUENCE_INCOMPLETE
condition|)
block|{
comment|// The translation indicates that additional REQUEST SENSE command is
comment|// necessary to finish the original SCSI request.  As a result,
comment|// do not complete the IO and begin the next stage of the IO.
return|return
name|SCI_WARNING_SEQUENCE_INCOMPLETE
return|;
block|}
else|else
block|{
comment|// Something unexpected occurred during translation.  Fail the
comment|// IO request to the user.
operator|*
name|completion_status
operator|=
name|SCI_FAILURE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|completion_status
operator|==
name|SCI_SUCCESS
operator|&&
name|fw_request
operator|->
name|stp
operator|.
name|sequence
operator|.
name|state
operator|==
name|SATI_SEQUENCE_STATE_INCOMPLETE
condition|)
block|{
comment|//The internal Request Sense command is completed successfully.
name|sati_atapi_translate_request_sense_response
argument_list|(
operator|&
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
argument_list|,
name|fw_io
argument_list|,
name|fw_io
argument_list|)
expr_stmt|;
operator|*
name|completion_status
operator|=
name|SCI_FAILURE_IO_RESPONSE_VALID
expr_stmt|;
block|}
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !defined(DISABLE_ATAPI)
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|// P R O T E C T E D   M E T H O D S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method will construct the SATA/STP specific IO request  *        object utilizing the SATI.  *  * @pre The scif_sas_request_construct() method should be invoked before  *      calling this method.  *  * @param[in,out] stp_io_request This parameter specifies the stp_io_request  *                to be constructed.  *  * @return Indicate if the construction was successful.  * @return SCI_FAILURE_NO_NCQ_TAG_AVAILABLE  * @return SCI_SUCCESS_IO_COMPLETE_BEFORE_START  * @return SCI_FAILURE_IO_RESPONSE_VALID  * @return SCI_FAILURE This return value indicates a change in the translator  *         where a new return code has been given, but is not yet understood  *         by this routine.  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_stp_io_request_construct
parameter_list|(
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
parameter_list|)
block|{
name|SATI_STATUS
name|sati_status
decl_stmt|;
name|SCI_STATUS
name|sci_status
init|=
name|SCI_FAILURE
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
init|=
name|fw_io
operator|->
name|parent
operator|.
name|device
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_io
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_sas_stp_io_request_construct(0x%x) enter\n"
operator|,
name|fw_io
operator|)
argument_list|)
expr_stmt|;
comment|// The translator will indirectly invoke core methods to set the fields
comment|// of the ATA register FIS inside of this method.
name|sati_status
operator|=
name|sati_translate_command
argument_list|(
operator|&
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
argument_list|,
operator|&
name|fw_device
operator|->
name|protocol_device
operator|.
name|stp_device
operator|.
name|sati_device
argument_list|,
name|fw_io
argument_list|,
name|fw_io
argument_list|)
expr_stmt|;
if|if
condition|(
name|sati_status
operator|==
name|SATI_SUCCESS
condition|)
block|{
comment|// Allow the core to finish construction of the IO request.
name|sci_status
operator|=
name|scic_io_request_construct_basic_sata
argument_list|(
name|fw_io
operator|->
name|parent
operator|.
name|core_object
argument_list|)
expr_stmt|;
name|fw_io
operator|->
name|parent
operator|.
name|state_handlers
operator|=
operator|&
name|stp_io_request_constructed_handlers
expr_stmt|;
name|fw_io
operator|->
name|parent
operator|.
name|protocol_complete_handler
operator|=
name|scif_sas_stp_core_cb_io_request_complete_handler
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sati_status
operator|==
name|SATI_SUCCESS_SGL_TRANSLATED
condition|)
block|{
name|SCIC_IO_SATA_PARAMETERS_T
name|parms
decl_stmt|;
name|parms
operator|.
name|do_translate_sgl
operator|=
name|FALSE
expr_stmt|;
comment|// The translation actually already caused translation of the
comment|// scatter gather list.  So, call into the core through an API
comment|// that will not attempt to translate the SGL.
name|scic_io_request_construct_advanced_sata
argument_list|(
name|fw_io
operator|->
name|parent
operator|.
name|core_object
argument_list|,
operator|&
name|parms
argument_list|)
expr_stmt|;
name|fw_io
operator|->
name|parent
operator|.
name|state_handlers
operator|=
operator|&
name|stp_io_request_constructed_handlers
expr_stmt|;
name|fw_io
operator|->
name|parent
operator|.
name|protocol_complete_handler
operator|=
name|scif_sas_stp_core_cb_io_request_complete_handler
expr_stmt|;
comment|// Done with translation
name|sci_status
operator|=
name|SCI_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sati_status
operator|==
name|SATI_COMPLETE
condition|)
name|sci_status
operator|=
name|SCI_SUCCESS_IO_COMPLETE_BEFORE_START
expr_stmt|;
elseif|else
if|if
condition|(
name|sati_status
operator|==
name|SATI_FAILURE_CHECK_RESPONSE_DATA
condition|)
name|sci_status
operator|=
name|SCI_FAILURE_IO_RESPONSE_VALID
expr_stmt|;
else|else
block|{
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_io
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"Unexpected SAT translation failure 0x%x\n"
operator|,
name|fw_io
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sci_status
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_ATAPI
argument_list|)
end_if

begin_comment
comment|/**  * @brief This method will construct the STP PACKET protocol specific IO  *        request object.  *  * @pre The scif_sas_request_construct() method should be invoked before  *      calling this method.  *  * @param[in,out] fw_io This parameter specifies the stp packet io request  *                to be constructed.  *  * @return Indicate if the construction was successful.  * @return SCI_SUCCESS_IO_COMPLETE_BEFORE_START  * @return SCI_FAILURE_IO_RESPONSE_VALID  * @return SCI_FAILURE This return value indicates a change in the translator  *         where a new return code has been given, but is not yet understood  *         by this routine.  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_stp_packet_io_request_construct
parameter_list|(
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
parameter_list|)
block|{
name|SATI_STATUS
name|sati_status
decl_stmt|;
name|SCI_STATUS
name|sci_status
init|=
name|SCI_FAILURE
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
init|=
name|fw_io
operator|->
name|parent
operator|.
name|device
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_io
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_sas_stp_packet_io_request_construct(0x%x) enter\n"
operator|,
name|fw_io
operator|)
argument_list|)
expr_stmt|;
name|sati_status
operator|=
name|sati_atapi_translate_command
argument_list|(
operator|&
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
argument_list|,
operator|&
name|fw_device
operator|->
name|protocol_device
operator|.
name|stp_device
operator|.
name|sati_device
argument_list|,
name|fw_io
argument_list|,
name|fw_io
argument_list|)
expr_stmt|;
if|if
condition|(
name|sati_status
operator|==
name|SATI_SUCCESS
condition|)
block|{
comment|// Allow the core to finish construction of the IO request.
name|sci_status
operator|=
name|scic_io_request_construct_basic_sata
argument_list|(
name|fw_io
operator|->
name|parent
operator|.
name|core_object
argument_list|)
expr_stmt|;
name|fw_io
operator|->
name|parent
operator|.
name|protocol_complete_handler
operator|=
name|scif_sas_stp_core_cb_packet_io_request_complete_handler
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sati_status
operator|==
name|SATI_COMPLETE
condition|)
name|sci_status
operator|=
name|SCI_SUCCESS_IO_COMPLETE_BEFORE_START
expr_stmt|;
elseif|else
if|if
condition|(
name|sati_status
operator|==
name|SATI_FAILURE_CHECK_RESPONSE_DATA
condition|)
name|sci_status
operator|=
name|SCI_FAILURE_IO_RESPONSE_VALID
expr_stmt|;
else|else
block|{
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_io
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"Unexpected SAT ATAPI translation failure 0x%x\n"
operator|,
name|fw_io
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sci_status
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_ATAPI
argument_list|)
end_if

begin_comment
comment|/**  * @brief This method will get the number of bytes transferred in an packet IO.  *  * @param[in] fw_io This parameter specifies the stp packet io request whose  *                     actual transferred length is to be retrieved.  *  * @return Actual length of transferred data.  */
end_comment

begin_function
name|U32
name|scif_sas_stp_packet_io_request_get_number_of_bytes_transferred
parameter_list|(
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
parameter_list|)
block|{
name|SCI_IO_REQUEST_HANDLE_T
name|scic_io
init|=
name|scif_io_request_get_scic_handle
argument_list|(
name|fw_io
argument_list|)
decl_stmt|;
name|SCI_IO_STATUS
name|io_status
init|=
name|scic_request_get_sci_status
argument_list|(
name|scic_io
argument_list|)
decl_stmt|;
name|U32
name|actual_data_length
decl_stmt|;
if|if
condition|(
name|io_status
operator|==
name|SCI_IO_FAILURE_RESPONSE_VALID
condition|)
name|actual_data_length
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|io_status
operator|==
name|SCI_IO_SUCCESS_IO_DONE_EARLY
condition|)
block|{
name|actual_data_length
operator|=
name|sati_atapi_translate_number_of_bytes_transferred
argument_list|(
operator|&
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
argument_list|,
name|fw_io
argument_list|,
name|fw_io
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_data_length
operator|==
literal|0
condition|)
name|actual_data_length
operator|=
name|scic_io_request_get_number_of_bytes_transferred
argument_list|(
name|scic_io
argument_list|)
expr_stmt|;
block|}
else|else
name|actual_data_length
operator|=
name|scic_io_request_get_number_of_bytes_transferred
argument_list|(
name|scic_io
argument_list|)
expr_stmt|;
return|return
name|actual_data_length
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|// P U B L I C   M E T H O D S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_function
name|BOOL
name|scic_cb_io_request_do_copy_rx_frames
parameter_list|(
name|void
modifier|*
name|scic_user_io_request
parameter_list|)
block|{
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
init|=
operator|(
name|SCIF_SAS_IO_REQUEST_T
operator|*
operator|)
name|scic_user_io_request
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_io
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scic_cb_io_request_do_copy_rx_frames(0x%x) enter\n"
operator|,
name|fw_io
operator|)
argument_list|)
expr_stmt|;
comment|// If the translation was a PIO DATA IN (i.e. read) and the request
comment|// was actually a READ payload operation, then copy the data, since
comment|// there will be SGL space allocated for the transfer.
if|if
condition|(
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
operator|.
name|protocol
operator|==
name|SAT_PROTOCOL_PIO_DATA_IN
condition|)
block|{
if|if
condition|(
operator|(
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
operator|.
name|type
operator|==
name|SATI_SEQUENCE_ATA_PASSTHROUGH_12
operator|)
operator|||
operator|(
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
operator|.
name|type
operator|==
name|SATI_SEQUENCE_ATA_PASSTHROUGH_16
operator|)
operator|||
operator|(
operator|(
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
operator|.
name|type
operator|>=
name|SATI_SEQUENCE_TYPE_READ_MIN
operator|)
operator|&&
operator|(
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
operator|.
name|type
operator|<=
name|SATI_SEQUENCE_TYPE_READ_MAX
operator|)
operator|)
condition|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_io
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scic_cb_io_request_do_copy_rx_frames(0x%x) TRUE\n"
operator|,
name|fw_io
operator|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
comment|// For all other requests we leave the data in the core buffers.
comment|// This allows the translation to translate without having to have
comment|// separate space allocated into which to copy the data.
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|U8
name|scic_cb_request_get_sat_protocol
parameter_list|(
name|void
modifier|*
name|scic_user_io_request
parameter_list|)
block|{
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
init|=
operator|(
name|SCIF_SAS_IO_REQUEST_T
operator|*
operator|)
name|scic_user_io_request
decl_stmt|;
return|return
name|fw_io
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
operator|.
name|protocol
return|;
block|}
end_function

begin_function
name|U8
modifier|*
name|scic_cb_io_request_get_virtual_address_from_sgl
parameter_list|(
name|void
modifier|*
name|scic_user_io_request
parameter_list|,
name|U32
name|byte_offset
parameter_list|)
block|{
name|SCIF_SAS_REQUEST_T
modifier|*
name|fw_request
init|=
operator|(
name|SCIF_SAS_REQUEST_T
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|scic_user_io_request
argument_list|)
decl_stmt|;
return|return
name|scif_cb_io_request_get_virtual_address_from_sgl
argument_list|(
name|sci_object_get_association
argument_list|(
name|fw_request
argument_list|)
argument_list|,
name|byte_offset
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_OSSL_COPY_BUFFER
end_ifdef

begin_function
name|void
name|scic_cb_io_request_copy_buffer
parameter_list|(
name|void
modifier|*
name|scic_user_io_request
parameter_list|,
name|U8
modifier|*
name|source_addr
parameter_list|,
name|U32
name|offset
parameter_list|,
name|U32
name|length
parameter_list|)
block|{
name|SCIF_SAS_REQUEST_T
modifier|*
name|fw_request
init|=
operator|(
name|SCIF_SAS_REQUEST_T
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|scic_user_io_request
argument_list|)
decl_stmt|;
return|return
name|scif_cb_io_request_copy_buffer
argument_list|(
name|sci_object_get_association
argument_list|(
name|fw_request
argument_list|)
argument_list|,
name|source_addr
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_decl_stmt
name|SCI_BASE_REQUEST_STATE_HANDLER_T
name|stp_io_request_constructed_handlers
init|=
block|{
name|scif_sas_stp_io_request_constructed_start_handler
block|,
name|scif_sas_io_request_constructed_abort_handler
block|,
name|scif_sas_stp_io_request_constructed_complete_handler
block|,
name|scif_sas_io_request_default_destruct_handler
block|}
decl_stmt|;
end_decl_stmt

end_unit

