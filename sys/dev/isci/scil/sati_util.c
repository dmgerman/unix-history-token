begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  * @brief This file contains all of the method implementations that  *        provide generic support for SATI.  Some methods can be utilized  *        by a user to construct ATA/ATAPI commands, copy ATA device  *        structure data, fill in sense data, etc.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isci/scil/sati_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sati_callbacks.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_scsi.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_ata.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_sat.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_sas.h>
end_include

begin_comment
comment|/**  * @brief This method will set the data direction, protocol, and transfer  *        kength for an ATA non-data command.  *  * @pre It is expected that the user will use this method for setting these  *      values in a non-data ATA command constuct.  *  * @param[out] ata_io This parameter specifies the ATA IO request structure  *             for which to build the IDENTIFY DEVICE command.  * @param[in]  sequence This parameter specifies the translator sequence  *             for which the command is being constructed.  *  * @return none.  */
end_comment

begin_function
name|void
name|sati_ata_non_data_command
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|)
block|{
name|sequence
operator|->
name|data_direction
operator|=
name|SATI_DATA_DIRECTION_NONE
expr_stmt|;
name|sequence
operator|->
name|protocol
operator|=
name|SAT_PROTOCOL_NON_DATA
expr_stmt|;
name|sequence
operator|->
name|ata_transfer_length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the ATA identify device command.  *  * @pre It is expected that the user has properly set the current contents  *      of the register FIS to 0.  *  * @param[out] ata_io This parameter specifies the ATA IO request structure  *             for which to build the IDENTIFY DEVICE command.  * @param[in]  sequence This parameter specifies the translator sequence  *             for which the command is being constructed.  *  * @return none.  */
end_comment

begin_function
name|void
name|sati_ata_identify_device_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_IDENTIFY_DEVICE
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|data_direction
operator|=
name|SATI_DATA_DIRECTION_IN
expr_stmt|;
name|sequence
operator|->
name|protocol
operator|=
name|SAT_PROTOCOL_PIO_DATA_IN
expr_stmt|;
name|sequence
operator|->
name|ata_transfer_length
operator|=
sizeof|sizeof
argument_list|(
name|ATA_IDENTIFY_DEVICE_DATA_T
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** * @brief This method will construct the ATA Execute Device Diagnostic command. * * @param[out] ata_io This parameter specifies the ATA IO request structure *             for which to build the IDENTIFY DEVICE command. * @param[in]  sequence This parameter specifies the translator sequence *             for which the command is being constructed. * * @return none. */
end_comment

begin_function
name|void
name|sati_ata_execute_device_diagnostic_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_EXECUTE_DEVICE_DIAG
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|data_direction
operator|=
name|SATI_DATA_DIRECTION_IN
expr_stmt|;
name|sequence
operator|->
name|protocol
operator|=
name|SAT_PROTOCOL_DEVICE_DIAGNOSTIC
expr_stmt|;
name|sequence
operator|->
name|ata_transfer_length
operator|=
literal|16
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will set data bytes in the user data area.  If the  *        caller requests it, the data written will be forced to ascii  *        printable characters if it isn't already a printable character.  *        A printable character is considered to be>= 0x20 and<= 0x70.  *  * @param[in]  sequence This parameter specifies the translation sequence  *             for which to copy and swap the data.  * @param[out] destination_scsi_io This parameter specifies the SCSI IO  *             request containing the destination buffer into which to copy.  * @param[in]  destination_offset This parameter specifies the offset into  *             the data buffer where the information will be copied to.  * @param[in]  source_value This parameter specifies the value retrieved  *             from the source buffer that is to be copied into the user  *             buffer area.  * @param[in]  use_printable_chars This parameter indicates if the copy should  *             ensure that the value copied is considered an ASCII printable  *             character (e.g. A, B, " ", etc.).  These characters reside  *             in the 0x20 - 0x7E ASCII range.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|sati_set_ascii_data_byte
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|destination_scsi_io
parameter_list|,
name|U32
name|destination_offset
parameter_list|,
name|U8
name|source_value
parameter_list|,
name|BOOL
name|use_printable_chars
parameter_list|)
block|{
comment|// if the user requests that the copied data be ascii printable, then
comment|// default to " " (i.e. 0x20) for all non-ascii printable characters.
if|if
condition|(
operator|(
name|use_printable_chars
operator|==
name|TRUE
operator|)
operator|&&
operator|(
operator|(
name|source_value
operator|<
literal|0x20
operator|)
operator|||
operator|(
name|source_value
operator|>
literal|0x7E
operator|)
operator|)
condition|)
block|{
name|source_value
operator|=
literal|0x20
expr_stmt|;
block|}
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|destination_scsi_io
argument_list|,
name|destination_offset
argument_list|,
name|source_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method performs a copy operation using an offset into the  *        source buffer, an offset into the destination buffer, and a length.  *        It will perform the byte swap from the 16-bit identify field  *        into the network byte order SCSI location.  *  * @param[in]  sequence This parameter specifies the translation sequence  *             for which to copy and swap the data.  * @param[out] destination_scsi_io This parameter specifies the SCSI IO  *             request containing the destination buffer into which to copy.  * @param[in]  destination_offset This parameter specifies the offset into  *             the data buffer where the information will be copied to.  * @param[in]  source_buffer This parameter specifies the source buffer from  *             which the data will be copied.  * @param[in]  source_offset This parameter specifies the offset into the  *             source buffer where the copy shall begin.  * @param[in]  length This parameter specifies the number of bytes to copy  *             during this operation.  * @param[in]  use_printable_chars This parameter indicates if the copy should  *             ensure that the value copied is considered an ASCII printable  *             character (e.g. A, B, " ", etc.).  These characters reside  *             in the 0x20 - 0x7E ASCII range.  *  * @return none  */
end_comment

begin_function
name|void
name|sati_ata_identify_device_copy_data
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|destination_scsi_io
parameter_list|,
name|U32
name|destination_offset
parameter_list|,
name|U8
modifier|*
name|source_buffer
parameter_list|,
name|U32
name|source_offset
parameter_list|,
name|U32
name|length
parameter_list|,
name|BOOL
name|use_printable_chars
parameter_list|)
block|{
name|source_buffer
operator|+=
name|source_offset
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|sati_set_ascii_data_byte
argument_list|(
name|sequence
argument_list|,
name|destination_scsi_io
argument_list|,
name|destination_offset
argument_list|,
operator|*
operator|(
name|source_buffer
operator|+
literal|1
operator|)
argument_list|,
name|use_printable_chars
argument_list|)
expr_stmt|;
name|sati_set_ascii_data_byte
argument_list|(
name|sequence
argument_list|,
name|destination_scsi_io
argument_list|,
name|destination_offset
operator|+
literal|1
argument_list|,
operator|*
name|source_buffer
argument_list|,
name|use_printable_chars
argument_list|)
expr_stmt|;
name|destination_offset
operator|+=
literal|2
expr_stmt|;
name|source_buffer
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method performs a copy operation using a source buffer,  *        an offset into the destination buffer, and a length.  *  * @param[in]  sequence This parameter specifies the translation sequence  *             for which to copy and swap the data.  * @param[out] destination_scsi_io This parameter specifies the SCSI IO  *             request containing the destination buffer into which to copy.  * @param[in]  destination_offset This parameter specifies the offset into  *             the data buffer where the information will be copied to.  * @param[in]  source_buffer This parameter specifies the source buffer from  *             which the data will be copied.  * @param[in]  length This parameter specifies the number of bytes to copy  *             during this operation.  *  * @return none  */
end_comment

begin_function
name|void
name|sati_copy_data
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|destination_scsi_io
parameter_list|,
name|U32
name|destination_offset
parameter_list|,
name|U8
modifier|*
name|source_buffer
parameter_list|,
name|U32
name|length
parameter_list|)
block|{
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|destination_scsi_io
argument_list|,
name|destination_offset
argument_list|,
operator|*
name|source_buffer
argument_list|)
expr_stmt|;
name|destination_offset
operator|++
expr_stmt|;
name|source_buffer
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method extracts the Logical Block Address high and low 32-bit  *        values and the sector count 32-bit value from the ATA identify  *        device data.  *  * @param[in]  identify This parameter specifies the ATA_IDENTIFY_DEVICE_DATA  *             from which to extract the sector information.  * @param[out] lba_high This parameter specifies the upper 32 bits for the  *             number of logical block addresses for the device. The upper  *             16-bits should always be 0, since 48-bits of LBA is the most  *             supported by an ATA device.  * @param[out] lba_low This parameter specifies the lower 32 bits for the  *             number of logical block addresses for the device.  * @param[out] sector_size This parameter specifies the 32-bits of sector  *             size.  If the ATA device doesn't support reporting it's  *             sector size, then 512 bytes is utilized as the default value.  *  * @return none  */
end_comment

begin_function
name|void
name|sati_ata_identify_device_get_sector_info
parameter_list|(
name|ATA_IDENTIFY_DEVICE_DATA_T
modifier|*
name|identify
parameter_list|,
name|U32
modifier|*
name|lba_high
parameter_list|,
name|U32
modifier|*
name|lba_low
parameter_list|,
name|U32
modifier|*
name|sector_size
parameter_list|)
block|{
comment|// Calculate the values to be returned
comment|// Calculation will be different if the SATA device supports
comment|// 48-bit addressing.  Bit 10 of Word 86 of ATA Identify
if|if
condition|(
name|identify
operator|->
name|command_set_enabled1
operator|&
name|ATA_IDENTIFY_COMMAND_SET_SUPPORTED1_48BIT_ENABLE
condition|)
block|{
comment|// This drive supports 48-bit addressing
operator|*
name|lba_high
operator|=
name|identify
operator|->
name|max_48bit_lba
index|[
literal|7
index|]
operator|<<
literal|24
expr_stmt|;
operator|*
name|lba_high
operator||=
name|identify
operator|->
name|max_48bit_lba
index|[
literal|6
index|]
operator|<<
literal|16
expr_stmt|;
operator|*
name|lba_high
operator||=
name|identify
operator|->
name|max_48bit_lba
index|[
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|lba_high
operator||=
name|identify
operator|->
name|max_48bit_lba
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|lba_low
operator|=
name|identify
operator|->
name|max_48bit_lba
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
operator|*
name|lba_low
operator||=
name|identify
operator|->
name|max_48bit_lba
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
operator|*
name|lba_low
operator||=
name|identify
operator|->
name|max_48bit_lba
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|lba_low
operator||=
name|identify
operator|->
name|max_48bit_lba
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// This device doesn't support 48-bit addressing
comment|// Pull out the largest LBA from words 60 and 61.
operator|*
name|lba_high
operator|=
literal|0
expr_stmt|;
operator|*
name|lba_low
operator|=
name|identify
operator|->
name|total_num_sectors
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
operator|*
name|lba_low
operator||=
name|identify
operator|->
name|total_num_sectors
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
operator|*
name|lba_low
operator||=
name|identify
operator|->
name|total_num_sectors
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|lba_low
operator||=
name|identify
operator|->
name|total_num_sectors
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|// If the ATA device reports its sector size (bit 12 of Word 106),
comment|// then use that instead.
if|if
condition|(
name|identify
operator|->
name|physical_logical_sector_info
operator|&
name|ATA_IDENTIFY_SECTOR_LARGER_THEN_512_ENABLE
condition|)
block|{
operator|*
name|sector_size
operator|=
name|identify
operator|->
name|words_per_logical_sector
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
operator|*
name|sector_size
operator||=
name|identify
operator|->
name|words_per_logical_sector
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
operator|*
name|sector_size
operator||=
name|identify
operator|->
name|words_per_logical_sector
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
operator|*
name|sector_size
operator||=
name|identify
operator|->
name|words_per_logical_sector
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// Default the sector size to 512 bytes
operator|*
name|sector_size
operator|=
literal|512
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the ATA check power mode command.  *  * @pre It is expected that the user has properly set the current contents  *      of the register FIS to 0.  *  * @param[out] ata_io This parameter specifies the ATA IO request structure  *             for which to build the CHECK POWER MODE command.  * @param[in]  sequence This parameter specifies the translator sequence  *             for which the command is being constructed.  *  * @return none.  */
end_comment

begin_function
name|void
name|sati_ata_check_power_mode_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_CHECK_POWER_MODE
argument_list|)
expr_stmt|;
name|sati_ata_non_data_command
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method is utilized to set a specific byte in the sense  *        data area.  It will ensure that the supplied byte offset  *        isn't larger then the length of the requested sense data.  *  * @param[in] scsi_io This parameter specifies the user SCSI IO request  *            for which to set the sense data byte.  * @param[in] byte_offset This parameter specifies the byte offset into  *            the sense data buffer where the data should be written.  * @param[in] value This parameter specifies the 8-bit value to be written  *            into the sense data area.  *  * @return none  */
end_comment

begin_function
name|void
name|sati_set_sense_data_byte
parameter_list|(
name|U8
modifier|*
name|sense_data
parameter_list|,
name|U32
name|max_sense_data_len
parameter_list|,
name|U32
name|byte_offset
parameter_list|,
name|U8
name|value
parameter_list|)
block|{
comment|// Ensure that we don't attempt to write past the end of the sense
comment|// data buffer.
if|if
condition|(
name|byte_offset
operator|<
name|max_sense_data_len
condition|)
name|sense_data
index|[
name|byte_offset
index|]
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the common response IU in the user  *           request's response IU location.  *  * @param[out] rsp_iu This parameter specifies the user request's  *                response IU to be constructed.  * @param[in]  scsi_status This parameter specifies the SCSI status  *                value for the user's IO request.  * @param[in]  sense_data_length This parameter specifies the sense data  *                length for response IU.  * @param[in]  data_present The parameter specifies the specific  *                data present value for response IU.  *  * @return none  */
end_comment

begin_function
name|void
name|sati_scsi_common_response_iu_construct
parameter_list|(
name|SCI_SSP_RESPONSE_IU_T
modifier|*
name|rsp_iu
parameter_list|,
name|U8
name|scsi_status
parameter_list|,
name|U8
name|sense_data_length
parameter_list|,
name|U8
name|data_present
parameter_list|)
block|{
name|rsp_iu
operator|->
name|sense_data_length
index|[
literal|3
index|]
operator|=
name|sense_data_length
expr_stmt|;
name|rsp_iu
operator|->
name|sense_data_length
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|rsp_iu
operator|->
name|sense_data_length
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rsp_iu
operator|->
name|sense_data_length
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rsp_iu
operator|->
name|status
operator|=
name|scsi_status
expr_stmt|;
name|rsp_iu
operator|->
name|data_present
operator|=
name|data_present
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the buffer for sense data  *        sense data buffer location.  Additionally, it will set the user's  *        SCSI status.  *  * @param[in,out] scsi_io This parameter specifies the user's IO request  *                for which to construct the buffer for sense data.  * @param[in]     scsi_status This parameter specifies the SCSI status  *                value for the user's IO request.  * @param[out]    sense_data This paramater  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|sati_scsi_get_sense_data_buffer
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|U8
name|scsi_status
parameter_list|,
name|U8
modifier|*
modifier|*
name|sense_data
parameter_list|,
name|U32
modifier|*
name|sense_len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SATI_TRANSPORT_SUPPORTS_SAS
name|SCI_SSP_RESPONSE_IU_T
modifier|*
name|rsp_iu
init|=
operator|(
name|SCI_SSP_RESPONSE_IU_T
operator|*
operator|)
name|sati_cb_get_response_iu_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
name|sati_scsi_common_response_iu_construct
argument_list|(
name|rsp_iu
argument_list|,
name|scsi_status
argument_list|,
name|sati_scsi_get_sense_data_length
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|)
argument_list|,
name|SCSI_RESPONSE_DATA_PRES_SENSE_DATA
argument_list|)
expr_stmt|;
operator|*
name|sense_data
operator|=
operator|(
name|U8
operator|*
operator|)
name|rsp_iu
operator|->
name|data
expr_stmt|;
operator|*
name|sense_len
operator|=
name|SSP_RESPONSE_IU_MAX_DATA
operator|*
literal|4
expr_stmt|;
comment|// dwords to bytes
else|#
directive|else
operator|*
name|sense_data
operator|=
name|sati_cb_get_sense_data_address
argument_list|(
name|scsi_io
argument_list|)
expr_stmt|;
operator|*
name|sense_len
operator|=
name|sati_cb_get_sense_data_length
argument_list|(
name|scsi_io
argument_list|)
expr_stmt|;
name|sati_cb_set_scsi_status
argument_list|(
name|scsi_io
argument_list|,
name|scsi_status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// SATI_TRANSPORT_SUPPORTS_SAS
block|}
end_function

begin_comment
comment|/**  * @brief This method extract response code based on on device settings.  *  * @return response code  */
end_comment

begin_function
specifier|static
name|U8
name|sati_scsi_get_sense_data_response_code
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|)
block|{
if|if
condition|(
name|sequence
operator|->
name|device
operator|->
name|descriptor_sense_enable
condition|)
block|{
return|return
name|SCSI_DESCRIPTOR_CURRENT_RESPONSE_CODE
return|;
block|}
else|else
block|{
return|return
name|SCSI_FIXED_CURRENT_RESPONSE_CODE
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method will return length of descriptor sense data for executed command.  *  * @return sense data length  */
end_comment

begin_function
specifier|static
name|U8
name|sati_scsi_get_descriptor_sense_data_length
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|)
block|{
name|U8
modifier|*
name|cdb
init|=
name|sati_cb_get_cdb_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
comment|//Initial value is descriptor header length
name|U8
name|length
init|=
literal|8
decl_stmt|;
switch|switch
condition|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_WRITE_LONG
argument_list|)
case|case
name|SCSI_WRITE_LONG_10
case|:
case|case
name|SCSI_WRITE_LONG_16
case|:
name|length
operator|+=
name|SCSI_BLOCK_DESCRIPTOR_LENGTH
operator|+
name|SCSI_INFORMATION_DESCRIPTOR_LENGTH
expr_stmt|;
break|break;
endif|#
directive|endif
comment|// !defined(DISABLE_SATI_WRITE_LONG)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_REASSIGN_BLOCKS
argument_list|)
case|case
name|SCSI_REASSIGN_BLOCKS
case|:
name|length
operator|+=
name|SCSI_CMD_SPECIFIC_DESCRIPTOR_LENGTH
operator|+
name|SCSI_INFORMATION_DESCRIPTOR_LENGTH
expr_stmt|;
break|break;
endif|#
directive|endif
comment|// !defined(DISABLE_SATI_REASSIGN_BLOCKS)
case|case
name|SCSI_READ_6
case|:
case|case
name|SCSI_READ_10
case|:
case|case
name|SCSI_READ_12
case|:
case|case
name|SCSI_READ_16
case|:
case|case
name|SCSI_WRITE_6
case|:
case|case
name|SCSI_WRITE_10
case|:
case|case
name|SCSI_WRITE_12
case|:
case|case
name|SCSI_WRITE_16
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_VERIFY
argument_list|)
case|case
name|SCSI_VERIFY_10
case|:
case|case
name|SCSI_VERIFY_12
case|:
case|case
name|SCSI_VERIFY_16
case|:
endif|#
directive|endif
comment|// !defined(DISABLE_SATI_VERIFY)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_WRITE_AND_VERIFY
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_VERIFY
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_WRITE
argument_list|)
case|case
name|SCSI_WRITE_AND_VERIFY_10
case|:
case|case
name|SCSI_WRITE_AND_VERIFY_12
case|:
case|case
name|SCSI_WRITE_AND_VERIFY_16
case|:
endif|#
directive|endif
comment|//    !defined(DISABLE_SATI_WRITE_AND_VERIFY)
comment|//&& !defined(DISABLE_SATI_VERIFY)
comment|//&& !defined(DISABLE_SATI_WRITE)
name|length
operator|+=
name|SCSI_INFORMATION_DESCRIPTOR_LENGTH
expr_stmt|;
break|break;
block|}
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will return length of sense data.  *  * @return sense data length  */
end_comment

begin_function
name|U8
name|sati_scsi_get_sense_data_length
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|)
block|{
name|U8
name|response_code
decl_stmt|;
name|response_code
operator|=
name|sati_scsi_get_sense_data_response_code
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|response_code
condition|)
block|{
case|case
name|SCSI_FIXED_CURRENT_RESPONSE_CODE
case|:
case|case
name|SCSI_FIXED_DEFERRED_RESPONSE_CODE
case|:
return|return
name|SCSI_FIXED_SENSE_DATA_BASE_LENGTH
return|;
break|break;
case|case
name|SCSI_DESCRIPTOR_CURRENT_RESPONSE_CODE
case|:
case|case
name|SCSI_DESCRIPTOR_DEFERRED_RESPONSE_CODE
case|:
return|return
name|sati_scsi_get_descriptor_sense_data_length
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|)
return|;
break|break;
block|}
return|return
name|SCSI_FIXED_SENSE_DATA_BASE_LENGTH
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the sense data buffer in the user's  *        sense data buffer location.  Additionally, it will set the user's  *        SCSI status.  *  * @param[in]     sequence This parameter specifies the translation sequence  *                for which to construct the sense data.  * @param[in,out] scsi_io This parameter specifies the user's IO request  *                for which to construct the sense data.  * @param[in]     scsi_status This parameter specifies the SCSI status  *                value for the user's IO request.  * @param[in]     sense_key This parameter specifies the sense key to  *                be set for the user's IO request.  * @param[in]     additional_sense_code This parameter specifies the  *                additional sense code (ASC) key to be set for the user's  *                IO request.  * @param[in]     additional_sense_code_qualifier This parameter specifies  *                the additional sense code qualifier (ASCQ) key to be set  *                for the user's IO request.  *  * @return none  */
end_comment

begin_function
name|void
name|sati_scsi_sense_data_construct
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|U8
name|scsi_status
parameter_list|,
name|U8
name|sense_key
parameter_list|,
name|U8
name|additional_sense_code
parameter_list|,
name|U8
name|additional_sense_code_qualifier
parameter_list|)
block|{
name|U8
name|response_code
decl_stmt|;
name|response_code
operator|=
name|sati_scsi_get_sense_data_response_code
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|response_code
condition|)
block|{
case|case
name|SCSI_FIXED_CURRENT_RESPONSE_CODE
case|:
case|case
name|SCSI_FIXED_DEFERRED_RESPONSE_CODE
case|:
name|sati_scsi_fixed_sense_data_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|scsi_status
argument_list|,
name|response_code
argument_list|,
name|sense_key
argument_list|,
name|additional_sense_code
argument_list|,
name|additional_sense_code_qualifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_DESCRIPTOR_CURRENT_RESPONSE_CODE
case|:
case|case
name|SCSI_DESCRIPTOR_DEFERRED_RESPONSE_CODE
case|:
name|sati_scsi_descriptor_sense_data_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|scsi_status
argument_list|,
name|response_code
argument_list|,
name|sense_key
argument_list|,
name|additional_sense_code
argument_list|,
name|additional_sense_code_qualifier
argument_list|)
expr_stmt|;
break|break;
block|}
name|sequence
operator|->
name|is_sense_response_set
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the block descriptor in the user's descriptor  *            sense data buffer location.  *  * @param[in]     sense_data This parameter specifies the user SCSI IO request  *                for which to set the sense data byte.  * @param[in]     sense_len This parameter specifies length of the sense data  *                to be returned by SATI.  * @param[out]    descriptor_len This parameter returns the length of constructed  *                descriptor.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|sati_scsi_block_descriptor_construct
parameter_list|(
name|U8
modifier|*
name|sense_data
parameter_list|,
name|U32
name|sense_len
parameter_list|)
block|{
name|U8
name|ili
init|=
literal|1
decl_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|0
argument_list|,
name|SCSI_BLOCK_DESCRIPTOR_TYPE
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|1
argument_list|,
name|SCSI_BLOCK_DESCRIPTOR_ADDITIONAL_LENGTH
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|3
argument_list|,
operator|(
name|ili
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the command-specific descriptor for  *           the descriptor sense data buffer in the user's sense data buffer  *           location.  *  * @param[in]     sense_data This parameter specifies the user SCSI IO request  *                for which to set the sense data byte.  * @param[in]     sense_len This parameter specifies length of the sense data  *                to be returned by SATI.  * @param[out]    descriptor_len This parameter returns the length of constructed  *                descriptor.  * @param[in]     information_buff This parameter specifies the address for which  *                to set the command-specific information buffer.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|sati_scsi_command_specific_descriptor_construct
parameter_list|(
name|U8
modifier|*
name|sense_data
parameter_list|,
name|U32
name|sense_len
parameter_list|,
name|U8
modifier|*
name|information_buff
parameter_list|)
block|{
name|U8
name|i
decl_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|0
argument_list|,
name|SCSI_CMD_SPECIFIC_DESCRIPTOR_TYPE
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|1
argument_list|,
name|SCSI_CMD_SPECIFIC_DESCRIPTOR_ADDITIONAL_LENGTH
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// fill information buffer
comment|// SBC 5.20.1 REASSIGN BLOCKS command overview
comment|// If information about the first LBA not reassigned is not available
comment|// COMMAND-SPECIFIC INFORMATION field shall be set to FFFF_FFFF_FFFF_FFFFh
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|4
operator|+
name|i
argument_list|,
name|information_buff
operator|==
name|NULL
condition|?
literal|0xFF
else|:
name|information_buff
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the information descriptor for  *           the descriptor sense data buffer in the user's sense data buffer  *           location.  *  * @param[in]     sense_data This parameter specifies the user SCSI IO request  *                for which to set the sense data byte.  * @param[in]     sense_len This parameter specifies length of the sense data  *                to be returned by SATI.  * @param[out]    descriptor_len This parameter returns the length of constructed  *                descriptor.  * @param[in]     information_buff This parameter specifies the address for which  *                to set the information buffer.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|sati_scsi_information_descriptor_construct
parameter_list|(
name|U8
modifier|*
name|sense_data
parameter_list|,
name|U32
name|sense_len
parameter_list|,
name|U8
modifier|*
name|information_buff
parameter_list|)
block|{
name|U8
name|i
decl_stmt|;
name|U8
name|valid
init|=
literal|1
decl_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|0
argument_list|,
name|SCSI_INFORMATION_DESCRIPTOR_TYPE
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|1
argument_list|,
name|SCSI_INFORMATION_DESCRIPTOR_ADDITIONAL_LENGTH
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|2
argument_list|,
operator|(
name|valid
operator|<<
literal|7
operator|)
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// fill information buffer
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|4
operator|+
name|i
argument_list|,
name|information_buff
operator|==
name|NULL
condition|?
literal|0
else|:
name|information_buff
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the descriptors in the user's descriptor  *           sense data buffer location.  *  * @param[in,out] scsi_io This parameter specifies the user's IO request  *                for which to construct the sense data.  * @param[in]     sense_data This parameter specifies the user SCSI IO request  *                for which to set the sense data byte.  * @param[in]     sense_len This parameter specifies length of the sense data  *                to be returned by SATI.  * @param[out]    descriptor_len This parameter returns the length of constructed  *                descriptor.  * @param[in]     information_buff This parameter specifies the address for which  *                to set the information buffer.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|sati_scsi_common_descriptors_construct
parameter_list|(
name|void
modifier|*
name|scsi_io
parameter_list|,
name|U8
modifier|*
name|sense_data
parameter_list|,
name|U32
name|sense_len
parameter_list|,
name|U8
modifier|*
name|information_buff
parameter_list|)
block|{
name|U8
modifier|*
name|cdb
init|=
name|sati_cb_get_cdb_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
name|U8
name|offset
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|sati_get_cdb_byte
argument_list|(
name|cdb
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_WRITE_LONG
argument_list|)
case|case
name|SCSI_WRITE_LONG_10
case|:
case|case
name|SCSI_WRITE_LONG_16
case|:
name|sati_scsi_block_descriptor_construct
argument_list|(
name|sense_data
operator|+
name|offset
argument_list|,
name|sense_len
operator|-
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|SCSI_BLOCK_DESCRIPTOR_LENGTH
expr_stmt|;
name|sati_scsi_information_descriptor_construct
argument_list|(
name|sense_data
operator|+
name|offset
argument_list|,
name|sense_len
operator|-
name|offset
argument_list|,
name|information_buff
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|SCSI_INFORMATION_DESCRIPTOR_LENGTH
expr_stmt|;
break|break;
endif|#
directive|endif
comment|// !defined(DISABLE_SATI_WRITE_LONG)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_REASSIGN_BLOCKS
argument_list|)
case|case
name|SCSI_REASSIGN_BLOCKS
case|:
name|sati_scsi_command_specific_descriptor_construct
argument_list|(
name|sense_data
operator|+
name|offset
argument_list|,
name|sense_len
operator|-
name|offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|SCSI_CMD_SPECIFIC_DESCRIPTOR_LENGTH
expr_stmt|;
name|sati_scsi_information_descriptor_construct
argument_list|(
name|sense_data
operator|+
name|offset
argument_list|,
name|sense_len
operator|-
name|offset
argument_list|,
name|information_buff
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|SCSI_INFORMATION_DESCRIPTOR_LENGTH
expr_stmt|;
break|break;
endif|#
directive|endif
comment|// !defined(DISABLE_SATI_REASSIGN_BLOCKS)
case|case
name|SCSI_READ_6
case|:
case|case
name|SCSI_READ_10
case|:
case|case
name|SCSI_READ_12
case|:
case|case
name|SCSI_READ_16
case|:
case|case
name|SCSI_WRITE_6
case|:
case|case
name|SCSI_WRITE_10
case|:
case|case
name|SCSI_WRITE_12
case|:
case|case
name|SCSI_WRITE_16
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_VERIFY
argument_list|)
case|case
name|SCSI_VERIFY_10
case|:
case|case
name|SCSI_VERIFY_12
case|:
case|case
name|SCSI_VERIFY_16
case|:
endif|#
directive|endif
comment|// !defined(DISABLE_SATI_VERIFY)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_WRITE_AND_VERIFY
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_VERIFY
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_WRITE
argument_list|)
case|case
name|SCSI_WRITE_AND_VERIFY_10
case|:
case|case
name|SCSI_WRITE_AND_VERIFY_12
case|:
case|case
name|SCSI_WRITE_AND_VERIFY_16
case|:
endif|#
directive|endif
comment|//    !defined(DISABLE_SATI_WRITE_AND_VERIFY)
comment|//&& !defined(DISABLE_SATI_VERIFY)
comment|//&& !defined(DISABLE_SATI_WRITE)
name|sati_scsi_information_descriptor_construct
argument_list|(
name|sense_data
operator|+
name|offset
argument_list|,
name|sense_len
operator|-
name|offset
argument_list|,
name|information_buff
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|SCSI_INFORMATION_DESCRIPTOR_LENGTH
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the descriptor sense data buffer in  *           the user's sense data buffer location.  Additionally, it will set  *           the user's SCSI status.  *  * @param[in]     sequence This parameter specifies the translation sequence  *                for which to construct the sense data.  * @param[in,out] scsi_io This parameter specifies the user's IO request  *                for which to construct the sense data.  * @param[in]     scsi_status This parameter specifies the SCSI status  *                value for the user's IO request.  * @param[in]     sense_key This parameter specifies the sense key to  *                be set for the user's IO request.  * @param[in]     additional_sense_code This parameter specifies the  *                additional sense code (ASC) key to be set for the user's  *                IO request.  * @param[in]     additional_sense_code_qualifier This parameter specifies  *                the additional sense code qualifier (ASCQ) key to be set  *                for the user's IO request.  *  * @return none  */
end_comment

begin_function
name|void
name|sati_scsi_descriptor_sense_data_construct
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|U8
name|scsi_status
parameter_list|,
name|U8
name|response_code
parameter_list|,
name|U8
name|sense_key
parameter_list|,
name|U8
name|additional_sense_code
parameter_list|,
name|U8
name|additional_sense_code_qualifier
parameter_list|)
block|{
name|U8
modifier|*
name|sense_data
decl_stmt|;
name|U32
name|sense_len
decl_stmt|;
name|sati_scsi_get_sense_data_buffer
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|scsi_status
argument_list|,
operator|&
name|sense_data
argument_list|,
operator|&
name|sense_len
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|0
argument_list|,
name|response_code
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|1
argument_list|,
name|sense_key
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|2
argument_list|,
name|additional_sense_code
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|3
argument_list|,
name|additional_sense_code_qualifier
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_scsi_common_descriptors_construct
argument_list|(
name|scsi_io
argument_list|,
name|sense_data
operator|+
literal|8
argument_list|,
name|sense_len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|7
argument_list|,
name|sati_scsi_get_descriptor_sense_data_length
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|)
operator|-
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the fixed format sense data buffer  *           in the user's sense data buffer location.  Additionally, it will  *          set the user's SCSI status.  *  * @param[in]     sequence This parameter specifies the translation sequence  *                for which to construct the sense data.  * @param[in,out] scsi_io This parameter specifies the user's IO request  *                for which to construct the sense data.  * @param[in]     scsi_status This parameter specifies the SCSI status  *                value for the user's IO request.  * @param[in]     sense_key This parameter specifies the sense key to  *                be set for the user's IO request.  * @param[in]     additional_sense_code This parameter specifies the  *                additional sense code (ASC) key to be set for the user's  *                IO request.  * @param[in]     additional_sense_code_qualifier This parameter specifies  *                the additional sense code qualifier (ASCQ) key to be set  *                for the user's IO request.  *  * @return none  */
end_comment

begin_function
name|void
name|sati_scsi_fixed_sense_data_construct
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|U8
name|scsi_status
parameter_list|,
name|U8
name|response_code
parameter_list|,
name|U8
name|sense_key
parameter_list|,
name|U8
name|additional_sense_code
parameter_list|,
name|U8
name|additional_sense_code_qualifier
parameter_list|)
block|{
name|U8
modifier|*
name|sense_data
decl_stmt|;
name|U32
name|sense_len
decl_stmt|;
name|sati_scsi_get_sense_data_buffer
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|scsi_status
argument_list|,
operator|&
name|sense_data
argument_list|,
operator|&
name|sense_len
argument_list|)
expr_stmt|;
comment|// Write out the sense data format per SPC-4.
comment|// We utilize the fixed format sense data format.
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|0
argument_list|,
name|response_code
operator||
name|SCSI_FIXED_SENSE_DATA_VALID_BIT
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|2
argument_list|,
name|sense_key
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|7
argument_list|,
operator|(
name|sense_len
operator|<
literal|18
condition|?
name|sense_len
operator|-
literal|1
else|:
literal|17
operator|)
operator|-
literal|7
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|9
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|11
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|12
argument_list|,
name|additional_sense_code
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|13
argument_list|,
name|additional_sense_code_qualifier
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|14
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|17
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** * @brief This method will construct common sense data that will be identical in *        both read error sense construct functions. *        sati_scsi_read_ncq_error_sense_construct, *        sati_scsi_read_error_sense_construct *  * @param[in]    sense_data This parameter specifies the user SCSI IO request  *               for which to set the sense data byte. * @param[in]     sense_len This parameter specifies length of the sense data *                to be returned by SATI. * @param[in]     sense_key This parameter specifies the sense key to *                be set for the user's IO request. * @param[in]     additional_sense_code This parameter specifies the *                additional sense code (ASC) key to be set for the user's *                IO request. * @param[in]     additional_sense_code_qualifier This parameter specifies *                the additional sense code qualifier (ASCQ) key to be set *                for the user's IO request. * * @return none */
end_comment

begin_function
specifier|static
name|void
name|sati_scsi_common_fixed_sense_construct
parameter_list|(
name|U8
modifier|*
name|sense_data
parameter_list|,
name|U32
name|sense_len
parameter_list|,
name|U8
name|sense_key
parameter_list|,
name|U8
name|additional_sense_code
parameter_list|,
name|U8
name|additional_sense_code_qualifier
parameter_list|)
block|{
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|2
argument_list|,
name|sense_key
argument_list|)
expr_stmt|;
comment|//Bytes 3, 4, 5, 6 are set in read_error_sense_construct functions
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|7
argument_list|,
operator|(
name|sense_len
operator|<
literal|18
condition|?
name|sense_len
operator|-
literal|1
else|:
literal|17
operator|)
operator|-
literal|7
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|9
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|11
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|12
argument_list|,
name|additional_sense_code
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|13
argument_list|,
name|additional_sense_code_qualifier
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|14
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|15
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|17
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the descriptor sense data buffer in  *           the user's sense data buffer location.  Additionally, it will set  *           the user's SCSI status.  *  * @param[in]     sequence This parameter specifies the translation sequence  *                for which to construct the sense data.  * @param[in,out] scsi_io This parameter specifies the user's IO request  *                for which to construct the sense data.  * @param[in]     scsi_status This parameter specifies the SCSI status  *                value for the user's IO request.  * @param[in]     sense_key This parameter specifies the sense key to  *                be set for the user's IO request.  * @param[in]     additional_sense_code This parameter specifies the  *                additional sense code (ASC) key to be set for the user's  *                IO request.  * @param[in]     additional_sense_code_qualifier This parameter specifies  *                the additional sense code qualifier (ASCQ) key to be set  *                for the user's IO request.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|sati_scsi_common_descriptor_sense_construct
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|U8
modifier|*
name|sense_data
parameter_list|,
name|U32
name|sense_len
parameter_list|,
name|U8
name|sense_key
parameter_list|,
name|U8
name|additional_sense_code
parameter_list|,
name|U8
name|additional_sense_code_qualifier
parameter_list|,
name|U8
modifier|*
name|information_buff
parameter_list|)
block|{
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|1
argument_list|,
name|sense_key
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|2
argument_list|,
name|additional_sense_code
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|3
argument_list|,
name|additional_sense_code_qualifier
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sati_scsi_common_descriptors_construct
argument_list|(
name|scsi_io
argument_list|,
name|sense_data
operator|+
literal|8
argument_list|,
name|sense_len
argument_list|,
name|information_buff
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|7
argument_list|,
name|sati_scsi_get_descriptor_sense_data_length
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|)
operator|-
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** * @brief This method will construct the sense data buffer in the user's *        descriptor sense data buffer location.  Additionally, it will set *        the user's SCSI status. This is only used for NCQ uncorrectable *        read errors * * @param[in]     sequence This parameter specifies the translation sequence *                for which to construct the sense data. * @param[in,out] scsi_io This parameter specifies the user's IO request *                for which to construct the sense data. * @param[in]     ata_input_data This parameter specifies the user's ATA IO *                response from a Read Log Ext command. * @param[in]     scsi_status This parameter specifies the SCSI status *                value for the user's IO request. * @param[in]     sense_key This parameter specifies the sense key to *                be set for the user's IO request. * @param[in]     additional_sense_code This parameter specifies the *                additional sense code (ASC) key to be set for the user's *                IO request. * @param[in]     additional_sense_code_qualifier This parameter specifies *                the additional sense code qualifier (ASCQ) key to be set *                for the user's IO request. * * @return none */
end_comment

begin_function
specifier|static
name|void
name|sati_scsi_read_ncq_error_descriptor_sense_construct
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_input_data
parameter_list|,
name|U8
name|scsi_status
parameter_list|,
name|U8
name|response_code
parameter_list|,
name|U8
name|sense_key
parameter_list|,
name|U8
name|additional_sense_code
parameter_list|,
name|U8
name|additional_sense_code_qualifier
parameter_list|)
block|{
name|U8
modifier|*
name|sense_data
decl_stmt|;
name|U32
name|sense_len
decl_stmt|;
name|U8
name|information_buff
index|[
literal|8
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ATA_NCQ_COMMAND_ERROR_LOG_T
modifier|*
name|ncq_log
init|=
operator|(
name|ATA_NCQ_COMMAND_ERROR_LOG_T
operator|*
operator|)
name|ata_input_data
decl_stmt|;
name|sati_scsi_get_sense_data_buffer
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|scsi_status
argument_list|,
operator|&
name|sense_data
argument_list|,
operator|&
name|sense_len
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|0
argument_list|,
name|response_code
argument_list|)
expr_stmt|;
name|information_buff
index|[
literal|2
index|]
operator|=
name|ncq_log
operator|->
name|lba_47_40
expr_stmt|;
name|information_buff
index|[
literal|3
index|]
operator|=
name|ncq_log
operator|->
name|lba_39_32
expr_stmt|;
name|information_buff
index|[
literal|4
index|]
operator|=
name|ncq_log
operator|->
name|lba_31_24
expr_stmt|;
name|information_buff
index|[
literal|5
index|]
operator|=
name|ncq_log
operator|->
name|lba_23_16
expr_stmt|;
name|information_buff
index|[
literal|6
index|]
operator|=
name|ncq_log
operator|->
name|lba_15_8
expr_stmt|;
name|information_buff
index|[
literal|7
index|]
operator|=
name|ncq_log
operator|->
name|lba_7_0
expr_stmt|;
name|sati_scsi_common_descriptor_sense_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|sense_data
argument_list|,
name|sense_len
argument_list|,
name|sense_key
argument_list|,
name|additional_sense_code
argument_list|,
name|additional_sense_code_qualifier
argument_list|,
name|information_buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** * @brief This method will construct the sense data buffer in the user's *        sense data buffer location.  Additionally, it will set the user's *        SCSI status. This is only used for NCQ uncorrectable read errors * * @param[in]     sequence This parameter specifies the translation sequence *                for which to construct the sense data. * @param[in,out] scsi_io This parameter specifies the user's IO request *                for which to construct the sense data. * @param[in]     ata_input_data This parameter specifies the user's ATA IO *                response from a Read Log Ext command. * @param[in]     scsi_status This parameter specifies the SCSI status *                value for the user's IO request. * @param[in]     sense_key This parameter specifies the sense key to *                be set for the user's IO request. * @param[in]     additional_sense_code This parameter specifies the *                additional sense code (ASC) key to be set for the user's *                IO request. * @param[in]     additional_sense_code_qualifier This parameter specifies *                the additional sense code qualifier (ASCQ) key to be set *                for the user's IO request. * * @return none */
end_comment

begin_function
specifier|static
name|void
name|sati_scsi_read_ncq_error_fixed_sense_construct
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_input_data
parameter_list|,
name|U8
name|scsi_status
parameter_list|,
name|U8
name|response_code
parameter_list|,
name|U8
name|sense_key
parameter_list|,
name|U8
name|additional_sense_code
parameter_list|,
name|U8
name|additional_sense_code_qualifier
parameter_list|)
block|{
name|U8
modifier|*
name|sense_data
decl_stmt|;
name|U32
name|sense_len
decl_stmt|;
name|U8
name|valid
init|=
name|TRUE
decl_stmt|;
name|ATA_NCQ_COMMAND_ERROR_LOG_T
modifier|*
name|ncq_log
init|=
operator|(
name|ATA_NCQ_COMMAND_ERROR_LOG_T
operator|*
operator|)
name|ata_input_data
decl_stmt|;
name|sati_scsi_get_sense_data_buffer
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|scsi_status
argument_list|,
operator|&
name|sense_data
argument_list|,
operator|&
name|sense_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncq_log
operator|->
name|lba_39_32
operator|>
literal|0
condition|)
block|{
name|valid
operator|=
name|FALSE
expr_stmt|;
block|}
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|0
argument_list|,
operator|(
name|valid
operator|<<
literal|7
operator|)
operator||
name|response_code
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|3
argument_list|,
name|ncq_log
operator|->
name|lba_31_24
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|4
argument_list|,
name|ncq_log
operator|->
name|lba_23_16
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|5
argument_list|,
name|ncq_log
operator|->
name|lba_15_8
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|6
argument_list|,
name|ncq_log
operator|->
name|lba_7_0
argument_list|)
expr_stmt|;
name|sati_scsi_common_fixed_sense_construct
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
name|sense_key
argument_list|,
name|additional_sense_code
argument_list|,
name|additional_sense_code_qualifier
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sati_scsi_read_ncq_error_sense_construct
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_input_data
parameter_list|,
name|U8
name|scsi_status
parameter_list|,
name|U8
name|sense_key
parameter_list|,
name|U8
name|additional_sense_code
parameter_list|,
name|U8
name|additional_sense_code_qualifier
parameter_list|)
block|{
name|U8
name|response_code
decl_stmt|;
name|response_code
operator|=
name|sati_scsi_get_sense_data_response_code
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|response_code
condition|)
block|{
case|case
name|SCSI_FIXED_CURRENT_RESPONSE_CODE
case|:
case|case
name|SCSI_FIXED_DEFERRED_RESPONSE_CODE
case|:
name|sati_scsi_read_ncq_error_fixed_sense_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|ata_input_data
argument_list|,
name|scsi_status
argument_list|,
name|response_code
argument_list|,
name|sense_key
argument_list|,
name|additional_sense_code
argument_list|,
name|additional_sense_code_qualifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_DESCRIPTOR_CURRENT_RESPONSE_CODE
case|:
case|case
name|SCSI_DESCRIPTOR_DEFERRED_RESPONSE_CODE
case|:
name|sati_scsi_read_ncq_error_descriptor_sense_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|ata_input_data
argument_list|,
name|scsi_status
argument_list|,
name|response_code
argument_list|,
name|sense_key
argument_list|,
name|additional_sense_code
argument_list|,
name|additional_sense_code_qualifier
argument_list|)
expr_stmt|;
break|break;
block|}
name|sequence
operator|->
name|is_sense_response_set
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/** * @brief This method will construct the sense data buffer in the user's *        sense data buffer location.  Additionally, it will set the user's *        SCSI status. This is used for uncorrectable read errors. * * @param[in]     sequence This parameter specifies the translation sequence *                for which to construct the sense data. * @param[in,out] scsi_io This parameter specifies the user's IO request *                for which to construct the sense data. * @param[in]     ata_io This parameter is a pointer to the ATA IO data used *                to get the ATA register fis. * @param[in]     scsi_status This parameter specifies the SCSI status *                value for the user's IO request. * @param[in]     sense_key This parameter specifies the sense key to *                be set for the user's IO request. * @param[in]     additional_sense_code This parameter specifies the *                additional sense code (ASC) key to be set for the user's *                IO request. * @param[in]     additional_sense_code_qualifier This parameter specifies *                the additional sense code qualifier (ASCQ) key to be set *                for the user's IO request. * * @return none */
end_comment

begin_function
specifier|static
name|void
name|sati_scsi_read_error_descriptor_sense_construct
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_io
parameter_list|,
name|U8
name|scsi_status
parameter_list|,
name|U8
name|response_code
parameter_list|,
name|U8
name|sense_key
parameter_list|,
name|U8
name|additional_sense_code
parameter_list|,
name|U8
name|additional_sense_code_qualifier
parameter_list|)
block|{
name|U8
modifier|*
name|sense_data
decl_stmt|;
name|U32
name|sense_len
decl_stmt|;
name|U8
name|information_buff
index|[
literal|8
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_d2h_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_scsi_get_sense_data_buffer
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|scsi_status
argument_list|,
operator|&
name|sense_data
argument_list|,
operator|&
name|sense_len
argument_list|)
expr_stmt|;
name|information_buff
index|[
literal|2
index|]
operator|=
name|sati_get_ata_lba_high_ext
argument_list|(
name|register_fis
argument_list|)
expr_stmt|;
name|information_buff
index|[
literal|3
index|]
operator|=
name|sati_get_ata_lba_mid_ext
argument_list|(
name|register_fis
argument_list|)
expr_stmt|;
name|information_buff
index|[
literal|4
index|]
operator|=
name|sati_get_ata_lba_low_ext
argument_list|(
name|register_fis
argument_list|)
expr_stmt|;
name|information_buff
index|[
literal|5
index|]
operator|=
name|sati_get_ata_lba_high
argument_list|(
name|register_fis
argument_list|)
expr_stmt|;
name|information_buff
index|[
literal|6
index|]
operator|=
name|sati_get_ata_lba_mid
argument_list|(
name|register_fis
argument_list|)
expr_stmt|;
name|information_buff
index|[
literal|7
index|]
operator|=
name|sati_get_ata_lba_low
argument_list|(
name|register_fis
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|0
argument_list|,
name|SCSI_DESCRIPTOR_CURRENT_RESPONSE_CODE
argument_list|)
expr_stmt|;
name|sati_scsi_common_descriptor_sense_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|sense_data
argument_list|,
name|sense_len
argument_list|,
name|sense_key
argument_list|,
name|additional_sense_code
argument_list|,
name|additional_sense_code_qualifier
argument_list|,
name|information_buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** * @brief This method will construct the sense data buffer in the user's *        sense data buffer location.  Additionally, it will set the user's *        SCSI status. This is used for uncorrectable read errors. * * @param[in]     sequence This parameter specifies the translation sequence *                for which to construct the sense data. * @param[in,out] scsi_io This parameter specifies the user's IO request *                for which to construct the sense data. * @param[in]     ata_io This parameter is a pointer to the ATA IO data used *                to get the ATA register fis. * @param[in]     scsi_status This parameter specifies the SCSI status *                value for the user's IO request. * @param[in]     sense_key This parameter specifies the sense key to *                be set for the user's IO request. * @param[in]     additional_sense_code This parameter specifies the *                additional sense code (ASC) key to be set for the user's *                IO request. * @param[in]     additional_sense_code_qualifier This parameter specifies *                the additional sense code qualifier (ASCQ) key to be set *                for the user's IO request. * * @return none */
end_comment

begin_function
specifier|static
name|void
name|sati_scsi_read_error_fixed_sense_construct
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_io
parameter_list|,
name|U8
name|scsi_status
parameter_list|,
name|U8
name|response_code
parameter_list|,
name|U8
name|sense_key
parameter_list|,
name|U8
name|additional_sense_code
parameter_list|,
name|U8
name|additional_sense_code_qualifier
parameter_list|)
block|{
name|U8
modifier|*
name|sense_data
decl_stmt|;
name|U32
name|sense_len
decl_stmt|;
name|U8
name|valid
init|=
name|TRUE
decl_stmt|;
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_d2h_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_scsi_get_sense_data_buffer
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|scsi_status
argument_list|,
operator|&
name|sense_data
argument_list|,
operator|&
name|sense_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sati_get_ata_lba_mid_ext
argument_list|(
name|register_fis
argument_list|)
operator|>
literal|0
condition|)
block|{
name|valid
operator|=
name|FALSE
expr_stmt|;
block|}
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|3
argument_list|,
name|sati_get_ata_lba_low_ext
argument_list|(
name|register_fis
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|4
argument_list|,
name|sati_get_ata_lba_high
argument_list|(
name|register_fis
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|5
argument_list|,
name|sati_get_ata_lba_mid
argument_list|(
name|register_fis
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|6
argument_list|,
name|sati_get_ata_lba_low
argument_list|(
name|register_fis
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_sense_data_byte
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
literal|0
argument_list|,
operator|(
name|valid
operator|<<
literal|7
operator|)
operator||
name|SCSI_FIXED_CURRENT_RESPONSE_CODE
argument_list|)
expr_stmt|;
name|sati_scsi_common_fixed_sense_construct
argument_list|(
name|sense_data
argument_list|,
name|sense_len
argument_list|,
name|sense_key
argument_list|,
name|additional_sense_code
argument_list|,
name|additional_sense_code_qualifier
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sati_scsi_read_error_sense_construct
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|void
modifier|*
name|ata_input_data
parameter_list|,
name|U8
name|scsi_status
parameter_list|,
name|U8
name|sense_key
parameter_list|,
name|U8
name|additional_sense_code
parameter_list|,
name|U8
name|additional_sense_code_qualifier
parameter_list|)
block|{
name|U8
name|response_code
decl_stmt|;
name|response_code
operator|=
name|sati_scsi_get_sense_data_response_code
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|response_code
condition|)
block|{
case|case
name|SCSI_FIXED_CURRENT_RESPONSE_CODE
case|:
case|case
name|SCSI_FIXED_DEFERRED_RESPONSE_CODE
case|:
name|sati_scsi_read_error_fixed_sense_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|ata_input_data
argument_list|,
name|scsi_status
argument_list|,
name|response_code
argument_list|,
name|sense_key
argument_list|,
name|additional_sense_code
argument_list|,
name|additional_sense_code_qualifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_DESCRIPTOR_CURRENT_RESPONSE_CODE
case|:
case|case
name|SCSI_DESCRIPTOR_DEFERRED_RESPONSE_CODE
case|:
name|sati_scsi_read_error_descriptor_sense_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|ata_input_data
argument_list|,
name|scsi_status
argument_list|,
name|response_code
argument_list|,
name|sense_key
argument_list|,
name|additional_sense_code
argument_list|,
name|additional_sense_code_qualifier
argument_list|)
expr_stmt|;
break|break;
block|}
name|sequence
operator|->
name|is_sense_response_set
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * @brief This method builds the scsi response data for a sata task management  *        request.  *  * @param[in]     sequence This parameter specifies the translation sequence  *                for which to construct the sense data.  * @param[in,out] scsi_io This parameter specifies the user's IO request  *                for which to construct the sense data.  * @param[in]     response_data The response status for the task management  *                request.  */
end_comment

begin_function
name|void
name|sati_scsi_response_data_construct
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|U8
name|response_data
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SATI_TRANSPORT_SUPPORTS_SAS
name|SCI_SSP_RESPONSE_IU_T
modifier|*
name|rsp_iu
init|=
operator|(
name|SCI_SSP_RESPONSE_IU_T
operator|*
operator|)
name|sati_cb_get_response_iu_address
argument_list|(
name|scsi_io
argument_list|)
decl_stmt|;
name|rsp_iu
operator|->
name|data_present
operator|=
literal|0x01
expr_stmt|;
name|rsp_iu
operator|->
name|response_data_length
index|[
literal|3
index|]
operator|=
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
expr_stmt|;
name|rsp_iu
operator|->
name|status
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|U8
operator|*
operator|)
name|rsp_iu
operator|->
name|data
operator|)
index|[
literal|3
index|]
operator|=
name|response_data
expr_stmt|;
else|#
directive|else
endif|#
directive|endif
comment|// SATI_TRANSPORT_SUPPORTS_SAS
block|}
end_function

begin_comment
comment|/**  * @brief This method checks to make sure that the translation isn't  *        exceeding the allocation length specified in the CDB prior  *        to retrieving the payload data byte from the user's buffer.  *  * @param[in,out] scsi_io This parameter specifies the user's IO request  *                for which to set the user payload data byte.  * @param[in]     byte_offset This parameter specifies the offset into  *                the user's payload buffer at which to write the supplied  *                value.  * @param[in]     value This parameter specifies the memory location into  *                which to read the value from the user's payload buffer.  *  * @return none  */
end_comment

begin_function
name|void
name|sati_get_data_byte
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|U32
name|byte_offset
parameter_list|,
name|U8
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|byte_offset
operator|<
name|sequence
operator|->
name|allocation_length
condition|)
name|sati_cb_get_data_byte
argument_list|(
name|scsi_io
argument_list|,
name|byte_offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method checks to make sure that the translation isn't  *        exceeding the allocation length specified in the CDB while  *        translating payload data into the user's buffer.  *  * @param[in]     sequence This parameter specifies the translation sequence  *                for which to set the user payload data byte.  * @param[in,out] scsi_io This parameter specifies the user's IO request  *                for which to set the user payload data byte.  * @param[in]     byte_offset This parameter specifies the offset into  *                the user's payload buffer at which to write the supplied  *                value.  * @param[in]     value This parameter specifies the new value to be  *                written out into the user's payload buffer.  *  * @return none  */
end_comment

begin_function
name|void
name|sati_set_data_byte
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|U32
name|byte_offset
parameter_list|,
name|U8
name|value
parameter_list|)
block|{
if|if
condition|(
name|byte_offset
operator|<
name|sequence
operator|->
name|allocation_length
condition|)
block|{
name|sequence
operator|->
name|number_data_bytes_set
operator|++
expr_stmt|;
name|sati_cb_set_data_byte
argument_list|(
name|scsi_io
argument_list|,
name|byte_offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method checks to make sure that the translation isn't  *        exceeding the allocation length specified in the CDB while  *        translating payload data into the user's buffer.  *  * @param[in]     sequence This parameter specifies the translation sequence  *                for which to set the user payload data dword.  * @param[in,out] scsi_io This parameter specifies the user's IO request  *                for which to set the user payload data dword.  * @param[in]     byte_offset This parameter specifies the offset into  *                the user's payload buffer at which to write the supplied  *                value.  * @param[in]     value This parameter specifies the new value to be  *                written out into the user's payload buffer.  *  * @return none  */
end_comment

begin_function
name|void
name|sati_set_data_dword
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|,
name|U32
name|byte_offset
parameter_list|,
name|U32
name|value
parameter_list|)
block|{
comment|/// @todo Check to ensure that the bytes appear correctly (SAS Address).
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|byte_offset
argument_list|,
operator|(
name|U8
operator|)
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|byte_offset
operator|++
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|byte_offset
argument_list|,
call|(
name|U8
call|)
argument_list|(
name|value
operator|>>
literal|8
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|byte_offset
operator|++
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|byte_offset
argument_list|,
call|(
name|U8
call|)
argument_list|(
name|value
operator|>>
literal|16
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|byte_offset
operator|++
expr_stmt|;
name|sati_set_data_byte
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|byte_offset
argument_list|,
call|(
name|U8
call|)
argument_list|(
name|value
operator|>>
literal|24
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the ATA flush cache command.  *  * @pre It is expected that the user has properly set the current contents  *      of the register FIS to 0.  *  * @param[out] ata_io This parameter specifies the ATA IO request structure  *             for which to build the FLUSH CACHE command.  * @param[in]  sequence This parameter specifies the translator sequence  *             for which the command is being constructed.  *  * @return none.  */
end_comment

begin_function
name|void
name|sati_ata_flush_cache_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_FLUSH_CACHE
argument_list|)
expr_stmt|;
name|sati_ata_non_data_command
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the ATA standby immediate command.  *  * @pre It is expected that the user has properly set the current contents  *      of the register FIS to 0.  *  * @param[out] ata_io This parameter specifies the ATA IO request structure  *             for which to build the STANDBY IMMEDIATE command.  * @param[in]  sequence This parameter specifies the translator sequence  *             for which the command is being constructed.  *  * @param[in]  count This parameter specifies the time period programmed  *             into the Standby Timer. See ATA8 spec for more details  * @return none.  */
end_comment

begin_function
name|void
name|sati_ata_standby_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|U16
name|count
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_STANDBY
argument_list|)
expr_stmt|;
name|sati_set_ata_sector_count
argument_list|(
name|register_fis
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|device
operator|->
name|ata_standby_timer
operator|=
operator|(
name|U8
operator|)
name|count
expr_stmt|;
name|sati_ata_non_data_command
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the ATA standby immediate command.  *  * @pre It is expected that the user has properly set the current contents  *      of the register FIS to 0.  *  * @param[out] ata_io This parameter specifies the ATA IO request structure  *             for which to build the STANDBY IMMEDIATE command.  * @param[in]  sequence This parameter specifies the translator sequence  *             for which the command is being constructed.  *  * @return none.  */
end_comment

begin_function
name|void
name|sati_ata_standby_immediate_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_STANDBY_IMMED
argument_list|)
expr_stmt|;
name|sati_ata_non_data_command
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the ATA idle immediate command.  *  * @pre It is expected that the user has properly set the current contents  *      of the register FIS to 0.  *  * @param[out] ata_io This parameter specifies the ATA IO request structure  *             for which to build the IDLE IMMEDIATE command.  * @param[in]  sequence This parameter specifies the translator sequence  *             for which the command is being constructed.  *  * @return none.  */
end_comment

begin_function
name|void
name|sati_ata_idle_immediate_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_IDLE_IMMED
argument_list|)
expr_stmt|;
name|sati_set_ata_features
argument_list|(
name|register_fis
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_ata_sector_count
argument_list|(
name|register_fis
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_high
argument_list|(
name|register_fis
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_mid
argument_list|(
name|register_fis
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_low
argument_list|(
name|register_fis
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_ata_non_data_command
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the ATA idle immediate command           for Unload Features.  *  * @pre It is expected that the user has properly set the current contents  *      of the register FIS to 0.  *  * @param[out] ata_io This parameter specifies the ATA IO request structure  *             for which to build the IDLE IMMEDIATE command.  * @param[in]  sequence This parameter specifies the translator sequence  *             for which the command is being constructed.  *  * @return none.  */
end_comment

begin_function
name|void
name|sati_ata_idle_immediate_unload_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_IDLE_IMMED
argument_list|)
expr_stmt|;
name|sati_set_ata_features
argument_list|(
name|register_fis
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
name|sati_set_ata_sector_count
argument_list|(
name|register_fis
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_high
argument_list|(
name|register_fis
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_mid
argument_list|(
name|register_fis
argument_list|,
literal|0x4E
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_low
argument_list|(
name|register_fis
argument_list|,
literal|0x4C
argument_list|)
expr_stmt|;
name|sati_ata_non_data_command
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the ATA IDLE command.\  *  * @pre It is expected that the user has properly set the current contents  *      of the register FIS to 0.  *  * @param[out] ata_io This parameter specifies the ATA IO request structure  *             for which to build the ATA IDLE command.  * @param[in]  sequence This parameter specifies the translator sequence  *             for which the command is being constructed.  *  * @return none.  */
end_comment

begin_function
name|void
name|sati_ata_idle_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_IDLE
argument_list|)
expr_stmt|;
name|sati_set_ata_features
argument_list|(
name|register_fis
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_ata_sector_count
argument_list|(
name|register_fis
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|device
operator|->
name|ata_standby_timer
operator|=
literal|0x00
expr_stmt|;
name|sati_set_ata_lba_high
argument_list|(
name|register_fis
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_mid
argument_list|(
name|register_fis
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_low
argument_list|(
name|register_fis
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_ata_non_data_command
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the ATA MEDIA EJECT command.  *  * @pre It is expected that the user has properly set the current contents  *      of the register FIS to 0.  *  * @param[out] ata_io This parameter specifies the ATA IO request structure  *             for which to build the MEDIA EJCT command.  * @param[in]  sequence This parameter specifies the translator sequence  *             for which the command is being constructed.  *  * @return none.  */
end_comment

begin_function
name|void
name|sati_ata_media_eject_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_MEDIA_EJECT
argument_list|)
expr_stmt|;
name|sati_ata_non_data_command
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct the ATA read verify sector(s) command.  *  * @pre It is expected that the user has properly set the current contents  *      of the register FIS to 0.  *  * @param[out] ata_io This parameter specifies the ATA IO request structure  *             for which to build the ATA READ VERIFY SECTOR(S) command.  * @param[in]  sequence This parameter specifies the translator sequence  *             for which the command is being constructed.  *  * @return none.  */
end_comment

begin_function
name|void
name|sati_ata_read_verify_sectors_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_READ_VERIFY_SECTORS
argument_list|)
expr_stmt|;
comment|//According to SAT-2 (v7) 9.11.3
name|sati_set_ata_sector_count
argument_list|(
name|register_fis
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|//According to SAT-2 (v7) 9.11.3, set LBA to a value between zero and the
comment|//maximum LBA supported by the ATA device in its current configuration.
comment|//From the unit test, it seems we have to set LBA to a non-zero value.
name|sati_set_ata_lba_low
argument_list|(
name|register_fis
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sati_ata_non_data_command
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct a ATA SMART Return Status command so the  *        status of the ATA device can be returned. The status of the SMART  *        threshold will be returned by this command.  *  * @return N/A  *  */
end_comment

begin_function
name|void
name|sati_ata_smart_return_status_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|U8
name|feature_value
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_SMART
argument_list|)
expr_stmt|;
name|sati_set_ata_features
argument_list|(
name|register_fis
argument_list|,
name|feature_value
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_high
argument_list|(
name|register_fis
argument_list|,
literal|0xC2
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_mid
argument_list|(
name|register_fis
argument_list|,
literal|0x4F
argument_list|)
expr_stmt|;
name|sati_ata_non_data_command
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct a ATA SMART Return Status command so the  *        status of the ATA device can be returned. The status of the SMART  *        threshold will be returned by this command.  *  * @return N/A  *  */
end_comment

begin_function
name|void
name|sati_ata_smart_read_log_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|U8
name|log_address
parameter_list|,
name|U32
name|transfer_length
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_SMART
argument_list|)
expr_stmt|;
name|sati_set_ata_features
argument_list|(
name|register_fis
argument_list|,
name|ATA_SMART_SUB_CMD_READ_LOG
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_high
argument_list|(
name|register_fis
argument_list|,
literal|0xC2
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_mid
argument_list|(
name|register_fis
argument_list|,
literal|0x4F
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_low
argument_list|(
name|register_fis
argument_list|,
name|log_address
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|data_direction
operator|=
name|SATI_DATA_DIRECTION_IN
expr_stmt|;
name|sequence
operator|->
name|protocol
operator|=
name|SAT_PROTOCOL_PIO_DATA_IN
expr_stmt|;
name|sequence
operator|->
name|ata_transfer_length
operator|=
name|transfer_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct a Write Uncorrectable ATA command that  *        will write one sector with a pseudo or flagged error. The type of  *        error is specified by the feature value.  *  * @return N/A  *  */
end_comment

begin_function
name|void
name|sati_ata_write_uncorrectable_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|U8
name|feature_value
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_WRITE_UNCORRECTABLE
argument_list|)
expr_stmt|;
name|sati_set_ata_features
argument_list|(
name|register_fis
argument_list|,
name|feature_value
argument_list|)
expr_stmt|;
name|sati_set_ata_sector_count
argument_list|(
name|register_fis
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|sati_ata_non_data_command
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct a Mode Select ATA SET FEATURES command  *        For example, Enable/Disable Write Cache, Enable/Disable Read Ahead  *  * @return N/A  *  */
end_comment

begin_function
name|void
name|sati_ata_set_features_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|U8
name|feature
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_SET_FEATURES
argument_list|)
expr_stmt|;
name|sati_set_ata_features
argument_list|(
name|register_fis
argument_list|,
name|feature
argument_list|)
expr_stmt|;
name|sati_ata_non_data_command
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will construct a Read Log ext ATA command that  *        will request a log page based on the log_address.  *  * @param[in]  log_address This parameter specifies the log page  *             to be returned from Read Log Ext.  *  * @param[in]  transfer_length This parameter specifies the size of the  *             log page response returned by Read Log Ext.  *  * @return N/A  *  */
end_comment

begin_function
name|void
name|sati_ata_read_log_ext_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|U8
name|log_address
parameter_list|,
name|U32
name|transfer_length
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_READ_LOG_EXT
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_low
argument_list|(
name|register_fis
argument_list|,
name|log_address
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_mid
argument_list|(
name|register_fis
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_mid_exp
argument_list|(
name|register_fis
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sati_set_ata_sector_count
argument_list|(
name|register_fis
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|data_direction
operator|=
name|SATI_DATA_DIRECTION_IN
expr_stmt|;
name|sequence
operator|->
name|protocol
operator|=
name|SAT_PROTOCOL_PIO_DATA_IN
expr_stmt|;
name|sequence
operator|->
name|ata_transfer_length
operator|=
name|transfer_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/** * @brief This method will check if the ATA device is in the stopped power *        state. This is used for all medium access commands for SAT *        compliance. See SAT2r07 section 9.11.1 * * @param[in] sequence - SATI sequence data with the device state. * * @return TRUE If device is stopped * */
end_comment

begin_function
name|BOOL
name|sati_device_state_stopped
parameter_list|(
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|void
modifier|*
name|scsi_io
parameter_list|)
block|{
if|if
condition|(
name|sequence
operator|->
name|device
operator|->
name|state
operator|==
name|SATI_DEVICE_STATE_STOPPED
condition|)
block|{
name|sati_scsi_sense_data_construct
argument_list|(
name|sequence
argument_list|,
name|scsi_io
argument_list|,
name|SCSI_STATUS_CHECK_CONDITION
argument_list|,
name|SCSI_SENSE_NOT_READY
argument_list|,
name|SCSI_ASC_INITIALIZING_COMMAND_REQUIRED
argument_list|,
name|SCSI_ASCQ_INITIALIZING_COMMAND_REQUIRED
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/** * @brief This method will construct a ATA Read Buffer command that *        will request PIO in data containing the target device's buffer. * * @param[out] ata_io This parameter specifies the ATA IO request structure *             for which to build the ATA READ VERIFY SECTOR(S) command. * @param[in]  sequence This parameter specifies the translator sequence *             for which the command is being constructed. * @return N/A * */
end_comment

begin_function
name|void
name|sati_ata_read_buffer_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_READ_BUFFER
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|data_direction
operator|=
name|SATI_DATA_DIRECTION_IN
expr_stmt|;
name|sequence
operator|->
name|protocol
operator|=
name|SAT_PROTOCOL_PIO_DATA_IN
expr_stmt|;
name|sequence
operator|->
name|ata_transfer_length
operator|=
literal|512
expr_stmt|;
block|}
end_function

begin_comment
comment|/** * @brief This method will construct a ATA Write Buffer command that *        will send PIO out data to the target device's buffer. * * @param[out] ata_io This parameter specifies the ATA IO request structure *             for which to build the ATA READ VERIFY SECTOR(S) command. * @param[in]  sequence This parameter specifies the translator sequence *             for which the command is being constructed. * @return N/A * */
end_comment

begin_function
name|void
name|sati_ata_write_buffer_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_WRITE_BUFFER
argument_list|)
expr_stmt|;
name|sequence
operator|->
name|data_direction
operator|=
name|SATI_DATA_DIRECTION_OUT
expr_stmt|;
name|sequence
operator|->
name|protocol
operator|=
name|SAT_PROTOCOL_PIO_DATA_OUT
expr_stmt|;
name|sequence
operator|->
name|ata_transfer_length
operator|=
literal|512
expr_stmt|;
block|}
end_function

begin_comment
comment|/** * @brief This method will construct a ATA Download Microcode command that *        will send PIO out data containing new firmware for the target drive. * * @param[out] ata_io This parameter specifies the ATA IO request structure *             for which to build the ATA READ VERIFY SECTOR(S) command. * @param[in]  sequence This parameter specifies the translator sequence *             for which the command is being constructed. * @param[in]  mode This parameter specifies the download microcode sub-command *             code. * @param[in]  allocation_length This parameter specifies the number of bytes *             being sent to the target device. * @param[in]  buffer_offset This parameter specifies the buffer offset for the *             data sent to the target device. * * @return N/A * */
end_comment

begin_function
name|void
name|sati_ata_download_microcode_construct
parameter_list|(
name|void
modifier|*
name|ata_io
parameter_list|,
name|SATI_TRANSLATOR_SEQUENCE_T
modifier|*
name|sequence
parameter_list|,
name|U8
name|mode
parameter_list|,
name|U32
name|allocation_length
parameter_list|,
name|U32
name|buffer_offset
parameter_list|)
block|{
name|U8
modifier|*
name|register_fis
init|=
name|sati_cb_get_h2d_register_fis_address
argument_list|(
name|ata_io
argument_list|)
decl_stmt|;
name|U32
name|allocation_blocks
init|=
name|allocation_length
operator|>>
literal|9
decl_stmt|;
name|U32
name|buffer_blkoffset
init|=
name|buffer_offset
operator|>>
literal|9
decl_stmt|;
name|sati_set_ata_command
argument_list|(
name|register_fis
argument_list|,
name|ATA_DOWNLOAD_MICROCODE
argument_list|)
expr_stmt|;
name|sati_set_ata_features
argument_list|(
name|register_fis
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|ATA_MICROCODE_DOWNLOAD_SAVE
condition|)
block|{
name|sati_set_ata_sector_count
argument_list|(
name|register_fis
argument_list|,
call|(
name|U8
call|)
argument_list|(
name|allocation_length
operator|>>
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_low
argument_list|(
name|register_fis
argument_list|,
call|(
name|U8
call|)
argument_list|(
name|allocation_length
operator|>>
literal|17
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|//mode == 0x03
block|{
name|sati_set_ata_sector_count
argument_list|(
name|register_fis
argument_list|,
call|(
name|U8
call|)
argument_list|(
name|allocation_blocks
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_low
argument_list|(
name|register_fis
argument_list|,
call|(
name|U8
call|)
argument_list|(
operator|(
name|allocation_blocks
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_mid
argument_list|(
name|register_fis
argument_list|,
call|(
name|U8
call|)
argument_list|(
name|buffer_blkoffset
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|sati_set_ata_lba_high
argument_list|(
name|register_fis
argument_list|,
call|(
name|U8
call|)
argument_list|(
operator|(
name|buffer_blkoffset
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|allocation_length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|buffer_offset
operator|==
literal|0
operator|)
condition|)
block|{
name|sati_ata_non_data_command
argument_list|(
name|ata_io
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sequence
operator|->
name|data_direction
operator|=
name|SATI_DATA_DIRECTION_OUT
expr_stmt|;
name|sequence
operator|->
name|protocol
operator|=
name|SAT_PROTOCOL_PIO_DATA_OUT
expr_stmt|;
name|sequence
operator|->
name|ata_transfer_length
operator|=
name|allocation_length
expr_stmt|;
block|}
block|}
end_function

end_unit

