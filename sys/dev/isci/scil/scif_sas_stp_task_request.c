begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/isci/scil/sati.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_logger.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_task_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_stp_task_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_task_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_controller.h>
end_include

begin_comment
comment|/**  * @brief This method provides SATA/STP STARTED state specific handling for  *        when the user attempts to complete the supplied IO request.  *        It will perform data/response translation and free NCQ tags  *        if necessary.  *  * @param[in] io_request This parameter specifies the IO request object  *            to be started.  *  * @return This method returns a value indicating if the IO request was  *         successfully completed or not.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_stp_core_cb_task_request_complete_handler
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|,
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SCIF_SAS_REQUEST_T
modifier|*
name|fw_request
parameter_list|,
name|SCI_STATUS
modifier|*
name|completion_status
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_TASK_MANAGEMENT
argument_list|)
name|SCIF_SAS_TASK_REQUEST_T
modifier|*
name|fw_task
init|=
operator|(
name|SCIF_SAS_TASK_REQUEST_T
operator|*
operator|)
name|fw_request
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_TASK_MANAGEMENT
operator|,
literal|"scif_sas_stp_core_cb_task_request_complete_handler(0x%x, 0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|fw_controller
operator|,
name|fw_device
operator|,
name|fw_request
operator|,
operator|*
name|completion_status
operator|)
argument_list|)
expr_stmt|;
comment|// Translating the response is only necessary if some sort of error
comment|// occurred resulting in having the error bit set in the ATA status
comment|// register and values to decode in the ATA error register.
if|if
condition|(
operator|(
operator|*
name|completion_status
operator|==
name|SCI_SUCCESS
operator|)
operator|||
operator|(
operator|*
name|completion_status
operator|==
name|SCI_FAILURE_IO_RESPONSE_VALID
operator|)
condition|)
block|{
name|SATI_STATUS
name|sati_status
init|=
name|sati_translate_task_response
argument_list|(
operator|&
name|fw_task
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
argument_list|,
name|fw_task
argument_list|,
name|fw_task
argument_list|)
decl_stmt|;
if|if
condition|(
name|sati_status
operator|==
name|SATI_COMPLETE
condition|)
operator|*
name|completion_status
operator|=
name|SCI_SUCCESS
expr_stmt|;
elseif|else
if|if
condition|(
name|sati_status
operator|==
name|SATI_FAILURE_CHECK_RESPONSE_DATA
condition|)
operator|*
name|completion_status
operator|=
name|SCI_FAILURE_IO_RESPONSE_VALID
expr_stmt|;
elseif|else
if|if
condition|(
name|sati_status
operator|==
name|SATI_SEQUENCE_INCOMPLETE
condition|)
block|{
comment|// The translation indicates that additional SATA requests are
comment|// necessary to finish the original SCSI request.  As a result,
comment|// do not complete the IO and begin the next stage of the
comment|// translation.
comment|/// @todo multiple ATA commands are required, but not supported yet.
return|return
name|SCI_FAILURE
return|;
block|}
else|else
block|{
comment|// Something unexpected occurred during translation.  Fail the
comment|// IO request to the user.
operator|*
name|completion_status
operator|=
name|SCI_FAILURE
expr_stmt|;
block|}
block|}
else|else
comment|//A stp task request sometimes fails.
block|{
if|if
condition|(
name|scif_sas_task_request_get_function
argument_list|(
name|fw_task
argument_list|)
operator|==
name|SCI_SAS_ABORT_TASK_SET
condition|)
block|{
name|scif_sas_stp_task_request_abort_task_set_failure_handler
argument_list|(
name|fw_device
argument_list|,
name|fw_task
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SCI_SUCCESS
return|;
else|#
directive|else
comment|// !defined(DISABLE_SATI_TASK_MANAGEMENT)
return|return
name|SCI_FAILURE
return|;
endif|#
directive|endif
comment|// !defined(DISABLE_SATI_TASK_MANAGEMENT)
block|}
end_function

begin_comment
comment|/**  * @file  *  * @brief This file contains the method implementations for the  *        SCIF_SAS_STP_TASK_REQUEST object.  The contents will implement  *        SATA/STP specific functionality.  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_stp_task_request_construct
parameter_list|(
name|SCIF_SAS_TASK_REQUEST_T
modifier|*
name|fw_task
parameter_list|)
block|{
name|SCI_STATUS
name|sci_status
init|=
name|SCI_FAILURE
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_TASK_MANAGEMENT
argument_list|)
name|SATI_STATUS
name|sati_status
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
init|=
name|fw_task
operator|->
name|parent
operator|.
name|device
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_task
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_TASK_MANAGEMENT
operator|,
literal|"scif_sas_stp_task_request_construct(0x%x) enter\n"
operator|,
name|fw_task
operator|)
argument_list|)
expr_stmt|;
comment|// The translator will indirectly invoke core methods to set the fields
comment|// of the ATA register FIS inside of this method.
name|sati_status
operator|=
name|sati_translate_task_management
argument_list|(
operator|&
name|fw_task
operator|->
name|parent
operator|.
name|stp
operator|.
name|sequence
argument_list|,
operator|&
name|fw_device
operator|->
name|protocol_device
operator|.
name|stp_device
operator|.
name|sati_device
argument_list|,
name|fw_task
argument_list|,
name|fw_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|sati_status
operator|==
name|SATI_SUCCESS
condition|)
block|{
name|sci_status
operator|=
name|scic_task_request_construct_sata
argument_list|(
name|fw_task
operator|->
name|parent
operator|.
name|core_object
argument_list|)
expr_stmt|;
comment|//fw_task->parent.state_handlers =&stp_io_request_constructed_handlers;
name|fw_task
operator|->
name|parent
operator|.
name|protocol_complete_handler
operator|=
name|scif_sas_stp_core_cb_task_request_complete_handler
expr_stmt|;
block|}
else|else
block|{
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_task
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_TASK_MANAGEMENT
operator|,
literal|"Task 0x%x received unexpected SAT translation failure 0x%x\n"
operator|,
name|fw_task
operator|,
name|sati_status
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// !defined(DISABLE_SATI_TASK_MANAGEMENT)
return|return
name|sci_status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides handling for failed stp TASK MANAGEMENT  *           request.  *  * @param[in] fw_device This parameter specifies the target device the  *            task management request towards to.  * @param[in] fw_request This parameter specifies the failed task management  *            request.  * @param[in] completion_status This parameter sprecifies the completion  *            status of the task management request's core status.  *  * @return None.  */
end_comment

begin_function
name|void
name|scif_sas_stp_task_request_abort_task_set_failure_handler
parameter_list|(
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SCIF_SAS_TASK_REQUEST_T
modifier|*
name|fw_task
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SATI_TASK_MANAGEMENT
argument_list|)
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
name|fw_device
operator|->
name|domain
decl_stmt|;
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|pending_request_element
decl_stmt|;
name|SCIF_SAS_REQUEST_T
modifier|*
name|pending_request
init|=
name|NULL
decl_stmt|;
name|pending_request_element
operator|=
name|fw_domain
operator|->
name|request_list
operator|.
name|list_head
expr_stmt|;
comment|// Cycle through the list of IO requests. search all the
comment|// outstanding IOs with "waiting for abort task set" flag,
comment|// completes them now.
while|while
condition|(
name|pending_request_element
operator|!=
name|NULL
condition|)
block|{
name|pending_request
operator|=
operator|(
name|SCIF_SAS_REQUEST_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|pending_request_element
argument_list|)
expr_stmt|;
comment|// The current element may be deleted from the list because of
comment|// IO completion so advance to the next element early
name|pending_request_element
operator|=
name|sci_fast_list_get_next
argument_list|(
name|pending_request_element
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_request
operator|->
name|device
operator|==
name|fw_device
operator|&&
name|pending_request
operator|->
name|is_waiting_for_abort_task_set
operator|==
name|TRUE
condition|)
block|{
comment|//In case the pending_request is still in the middle of aborting.
comment|//abort it again to the core.
name|SCI_STATUS
name|abort_status
decl_stmt|;
comment|//Reset the flag now since we are process the read log ext command now.
name|pending_request
operator|->
name|is_waiting_for_abort_task_set
operator|=
name|FALSE
expr_stmt|;
name|abort_status
operator|=
name|scic_controller_terminate_request
argument_list|(
name|fw_domain
operator|->
name|controller
operator|->
name|core_object
argument_list|,
name|fw_device
operator|->
name|core_object
argument_list|,
name|pending_request
operator|->
name|core_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_status
operator|==
name|SCI_FAILURE_INVALID_STATE
condition|)
block|{
comment|//the request must have not be in aborting state anymore, complete it now.
name|scif_cb_io_request_complete
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_device
argument_list|,
name|pending_request
argument_list|,
name|SCI_IO_FAILURE_TERMINATED
argument_list|)
expr_stmt|;
block|}
comment|//otherwise, the abort succeeded. Since the waiting flag is cleared,
comment|//the pending request will be completed later.
block|}
block|}
endif|#
directive|endif
comment|//#if !defined(DISABLE_SATI_TASK_MANAGEMENT)
block|}
end_function

end_unit

