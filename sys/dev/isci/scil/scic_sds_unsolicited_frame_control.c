begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  *  * @brief This file contains the implementation of the  *        SCIC_SDS_UNSOLICITED_FRAME_CONTROL object and it's public,  *        protected, and private methods.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_unsolicited_frame_control.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scu_registers.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_user_callback.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_util.h>
end_include

begin_comment
comment|/**  * @brief The UF buffer address table size must be programmed to a power  *        of 2.  Find the first power of 2 that is equal to or greater then  *        the number of unsolicited frame buffers to be utilized.  *  * @param[in,out] uf_control This parameter specifies the UF control  *                object for which to update the address table count.  *  * @return none  */
end_comment

begin_function
name|void
name|scic_sds_unsolicited_frame_control_set_address_table_count
parameter_list|(
name|SCIC_SDS_UNSOLICITED_FRAME_CONTROL_T
modifier|*
name|uf_control
parameter_list|)
block|{
name|uf_control
operator|->
name|address_table
operator|.
name|count
operator|=
name|SCU_MIN_UF_TABLE_ENTRIES
expr_stmt|;
while|while
condition|(
operator|(
name|uf_control
operator|->
name|address_table
operator|.
name|count
operator|<
name|uf_control
operator|->
name|buffers
operator|.
name|count
operator|)
operator|&&
operator|(
name|uf_control
operator|->
name|address_table
operator|.
name|count
operator|<
name|SCU_ABSOLUTE_MAX_UNSOLICITED_FRAMES
operator|)
condition|)
block|{
name|uf_control
operator|->
name|address_table
operator|.
name|count
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method will program the unsolicited frames (UFs) into  *        the UF address table and construct the UF frame structure  *        being modeled in the core.  It will handle the case where  *        some of the UFs are not being used and thus should have  *        entries programmed to zero in the address table.  *  * @param[in,out] uf_control This parameter specifies the unsolicted  *                frame control object for which to construct the  *                unsolicited frames objects.  * @param[in]     uf_buffer_phys_address This parameter specifies the  *                physical address for the first unsolicited frame  *                buffer.  * @param[in]     uf_buffer_virt_address This parameter specifies the  *                virtual address for the first unsolicited frame  *                buffer.  * @param[in]     unused_uf_header_entries This parameter specifies  *                the number of unused UF headers.  This value can  *                be non-zero when there are a non-power of 2 number  *                of unsolicited frames being supported.  * @param[in]     used_uf_header_entries This parameter specifies  *                the number of actually utilized UF headers.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_unsolicited_frame_control_construct_frames
parameter_list|(
name|SCIC_SDS_UNSOLICITED_FRAME_CONTROL_T
modifier|*
name|uf_control
parameter_list|,
name|SCI_PHYSICAL_ADDRESS
name|uf_buffer_phys_address
parameter_list|,
name|POINTER_UINT
name|uf_buffer_virt_address
parameter_list|,
name|U32
name|unused_uf_header_entries
parameter_list|,
name|U32
name|used_uf_header_entries
parameter_list|)
block|{
name|U32
name|index
decl_stmt|;
name|SCIC_SDS_UNSOLICITED_FRAME_T
modifier|*
name|uf
decl_stmt|;
comment|// Program the unused buffers into the UF address table and the
comment|// controller's array of UFs.
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|unused_uf_header_entries
condition|;
name|index
operator|++
control|)
block|{
name|uf
operator|=
operator|&
name|uf_control
operator|->
name|buffers
operator|.
name|array
index|[
name|index
index|]
expr_stmt|;
name|sci_cb_make_physical_address
argument_list|(
name|uf_control
operator|->
name|address_table
operator|.
name|array
index|[
name|index
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uf
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|uf
operator|->
name|header
operator|=
operator|&
name|uf_control
operator|->
name|headers
operator|.
name|array
index|[
name|index
index|]
expr_stmt|;
name|uf
operator|->
name|state
operator|=
name|UNSOLICITED_FRAME_EMPTY
expr_stmt|;
block|}
comment|// Program the actual used UF buffers into the UF address table and
comment|// the controller's array of UFs.
for|for
control|(
name|index
operator|=
name|unused_uf_header_entries
init|;
name|index
operator|<
name|unused_uf_header_entries
operator|+
name|used_uf_header_entries
condition|;
name|index
operator|++
control|)
block|{
name|uf
operator|=
operator|&
name|uf_control
operator|->
name|buffers
operator|.
name|array
index|[
name|index
index|]
expr_stmt|;
name|uf_control
operator|->
name|address_table
operator|.
name|array
index|[
name|index
index|]
operator|=
name|uf_buffer_phys_address
expr_stmt|;
name|uf
operator|->
name|buffer
operator|=
operator|(
name|void
operator|*
operator|)
name|uf_buffer_virt_address
expr_stmt|;
name|uf
operator|->
name|header
operator|=
operator|&
name|uf_control
operator|->
name|headers
operator|.
name|array
index|[
name|index
index|]
expr_stmt|;
name|uf
operator|->
name|state
operator|=
name|UNSOLICITED_FRAME_EMPTY
expr_stmt|;
comment|// Increment the address of the physical and virtual memory pointers
comment|// Everything is aligned on 1k boundary with an increment of 1k
name|uf_buffer_virt_address
operator|+=
name|SCU_UNSOLICITED_FRAME_BUFFER_SIZE
expr_stmt|;
name|sci_physical_address_add
argument_list|(
name|uf_buffer_phys_address
argument_list|,
name|SCU_UNSOLICITED_FRAME_BUFFER_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method constructs the various members of the unsolicted  *        frame control object (buffers, headers, address, table, etc).  *  * @param[in,out] uf_control This parameter specifies the unsolicited  *                frame control object to construct.  * @param[in]     mde This parameter specifies the memory descriptor  *                from which to derive all of the address information  *                needed to get the unsolicited frame functionality  *                working.  * @param[in]     controller This parameter specifies the controller  *                object associated with the uf_control being constructed.  *  * @return none  */
end_comment

begin_function
name|void
name|scic_sds_unsolicited_frame_control_construct
parameter_list|(
name|SCIC_SDS_UNSOLICITED_FRAME_CONTROL_T
modifier|*
name|uf_control
parameter_list|,
name|SCI_PHYSICAL_MEMORY_DESCRIPTOR_T
modifier|*
name|mde
parameter_list|,
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
parameter_list|)
block|{
name|U32
name|unused_uf_header_entries
decl_stmt|;
name|U32
name|used_uf_header_entries
decl_stmt|;
name|U32
name|used_uf_buffer_bytes
decl_stmt|;
name|U32
name|unused_uf_header_bytes
decl_stmt|;
name|U32
name|used_uf_header_bytes
decl_stmt|;
name|SCI_PHYSICAL_ADDRESS
name|uf_buffer_phys_address
decl_stmt|;
comment|// Prepare all of the memory sizes for the UF headers, UF address
comment|// table, and UF buffers themselves.
name|used_uf_buffer_bytes
operator|=
name|uf_control
operator|->
name|buffers
operator|.
name|count
operator|*
name|SCU_UNSOLICITED_FRAME_BUFFER_SIZE
expr_stmt|;
name|unused_uf_header_entries
operator|=
name|uf_control
operator|->
name|address_table
operator|.
name|count
operator|-
name|uf_control
operator|->
name|buffers
operator|.
name|count
expr_stmt|;
name|used_uf_header_entries
operator|=
name|uf_control
operator|->
name|buffers
operator|.
name|count
expr_stmt|;
name|unused_uf_header_bytes
operator|=
name|unused_uf_header_entries
operator|*
sizeof|sizeof
argument_list|(
name|SCU_UNSOLICITED_FRAME_HEADER_T
argument_list|)
expr_stmt|;
name|used_uf_header_bytes
operator|=
name|used_uf_header_entries
operator|*
sizeof|sizeof
argument_list|(
name|SCU_UNSOLICITED_FRAME_HEADER_T
argument_list|)
expr_stmt|;
comment|// The Unsolicited Frame buffers are set at the start of the UF
comment|// memory descriptor entry.  The headers and address table will be
comment|// placed after the buffers.
name|uf_buffer_phys_address
operator|=
name|mde
operator|->
name|physical_address
expr_stmt|;
comment|// Program the location of the UF header table into the SCU.
comment|// Notes:
comment|// - The address must align on a 64-byte boundary. Guaranteed to be
comment|//   on 64-byte boundary already 1KB boundary for unsolicited frames.
comment|// - Program unused header entries to overlap with the last
comment|//   unsolicited frame.  The silicon will never DMA to these unused
comment|//   headers, since we program the UF address table pointers to
comment|//   NULL.
name|uf_control
operator|->
name|headers
operator|.
name|physical_address
operator|=
name|uf_buffer_phys_address
expr_stmt|;
name|sci_physical_address_add
argument_list|(
name|uf_control
operator|->
name|headers
operator|.
name|physical_address
argument_list|,
name|used_uf_buffer_bytes
argument_list|)
expr_stmt|;
name|sci_physical_address_subtract
argument_list|(
name|uf_control
operator|->
name|headers
operator|.
name|physical_address
argument_list|,
name|unused_uf_header_bytes
argument_list|)
expr_stmt|;
name|uf_control
operator|->
name|headers
operator|.
name|array
operator|=
operator|(
name|SCU_UNSOLICITED_FRAME_HEADER_T
operator|*
operator|)
operator|(
operator|(
name|U8
operator|*
operator|)
name|mde
operator|->
name|virtual_address
operator|+
name|used_uf_buffer_bytes
operator|-
name|unused_uf_header_bytes
operator|)
expr_stmt|;
comment|// Program the location of the UF address table into the SCU.
comment|// Notes:
comment|// - The address must align on a 64-bit boundary. Guaranteed to be on 64
comment|//   byte boundary already due to above programming headers being on a
comment|//   64-bit boundary and headers are on a 64-bytes in size.
name|uf_control
operator|->
name|address_table
operator|.
name|physical_address
operator|=
name|uf_buffer_phys_address
expr_stmt|;
name|sci_physical_address_add
argument_list|(
name|uf_control
operator|->
name|address_table
operator|.
name|physical_address
argument_list|,
name|used_uf_buffer_bytes
argument_list|)
expr_stmt|;
name|sci_physical_address_add
argument_list|(
name|uf_control
operator|->
name|address_table
operator|.
name|physical_address
argument_list|,
name|used_uf_header_bytes
argument_list|)
expr_stmt|;
name|uf_control
operator|->
name|address_table
operator|.
name|array
operator|=
operator|(
name|SCI_PHYSICAL_ADDRESS
operator|*
operator|)
operator|(
operator|(
name|U8
operator|*
operator|)
name|mde
operator|->
name|virtual_address
operator|+
name|used_uf_buffer_bytes
operator|+
name|used_uf_header_bytes
operator|)
expr_stmt|;
name|uf_control
operator|->
name|get
operator|=
literal|0
expr_stmt|;
comment|// UF buffer requirements are:
comment|// - The last entry in the UF queue is not NULL.
comment|// - There is a power of 2 number of entries (NULL or not-NULL)
comment|//   programmed into the queue.
comment|// - Aligned on a 1KB boundary.
comment|// If the user provided less then the maximum amount of memory,
comment|// then be sure that we programm the first entries in the UF
comment|// address table to NULL.
name|scic_sds_unsolicited_frame_control_construct_frames
argument_list|(
name|uf_control
argument_list|,
name|uf_buffer_phys_address
argument_list|,
operator|(
name|POINTER_UINT
operator|)
name|mde
operator|->
name|virtual_address
argument_list|,
name|unused_uf_header_entries
argument_list|,
name|used_uf_header_entries
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method returns the frame header for the specified frame  *        index.  *  * @param[in] uf_control  * @param[in] frame_index  * @param[out] frame_header  *  * @return SCI_STATUS  */
end_comment

begin_function
name|SCI_STATUS
name|scic_sds_unsolicited_frame_control_get_header
parameter_list|(
name|SCIC_SDS_UNSOLICITED_FRAME_CONTROL_T
modifier|*
name|uf_control
parameter_list|,
name|U32
name|frame_index
parameter_list|,
name|void
modifier|*
modifier|*
name|frame_header
parameter_list|)
block|{
if|if
condition|(
name|frame_index
operator|<
name|uf_control
operator|->
name|address_table
operator|.
name|count
condition|)
block|{
comment|// Skip the first word in the frame since this is a controll word used
comment|// by the hardware.
operator|*
name|frame_header
operator|=
operator|&
name|uf_control
operator|->
name|buffers
operator|.
name|array
index|[
name|frame_index
index|]
operator|.
name|header
operator|->
name|data
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method returns the frame buffer for the specified frame  *        index.  *  * @param[in] uf_control  * @param[in] frame_index  * @param[out] frame_buffer  *  * @return SCI_STATUS  */
end_comment

begin_function
name|SCI_STATUS
name|scic_sds_unsolicited_frame_control_get_buffer
parameter_list|(
name|SCIC_SDS_UNSOLICITED_FRAME_CONTROL_T
modifier|*
name|uf_control
parameter_list|,
name|U32
name|frame_index
parameter_list|,
name|void
modifier|*
modifier|*
name|frame_buffer
parameter_list|)
block|{
if|if
condition|(
name|frame_index
operator|<
name|uf_control
operator|->
name|address_table
operator|.
name|count
condition|)
block|{
operator|*
name|frame_buffer
operator|=
name|uf_control
operator|->
name|buffers
operator|.
name|array
index|[
name|frame_index
index|]
operator|.
name|buffer
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
return|return
name|SCI_FAILURE_INVALID_PARAMETER_VALUE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method releases the frame once this is done the frame is  *        available for re-use by the hardware.  The data contained in the  *        frame header and frame buffer is no longer valid.  *  * @param[in] uf_control This parameter specifies the UF control object  * @param[in] frame_index This parameter specifies the frame index to  *            attempt to release.  *  * @return This method returns an indication to the caller as to whether  *         the unsolicited frame get pointer should be updated.  * @retval TRUE This value indicates the unsolicited frame get pointer  *         should be updated (i.e. write SCU_UFQGP_WRITE).  * @retval FALSE This value indicates the get pointer should not be  *         updated.  */
end_comment

begin_function
name|BOOL
name|scic_sds_unsolicited_frame_control_release_frame
parameter_list|(
name|SCIC_SDS_UNSOLICITED_FRAME_CONTROL_T
modifier|*
name|uf_control
parameter_list|,
name|U32
name|frame_index
parameter_list|)
block|{
name|U32
name|frame_get
decl_stmt|;
name|U32
name|frame_cycle
decl_stmt|;
name|frame_get
operator|=
name|uf_control
operator|->
name|get
operator|&
operator|(
name|uf_control
operator|->
name|address_table
operator|.
name|count
operator|-
literal|1
operator|)
expr_stmt|;
name|frame_cycle
operator|=
name|uf_control
operator|->
name|get
operator|&
name|uf_control
operator|->
name|address_table
operator|.
name|count
expr_stmt|;
comment|// In the event there are NULL entries in the UF table, we need to
comment|// advance the get pointer in order to find out if this frame should
comment|// be released (i.e. update the get pointer).
while|while
condition|(
operator|(
operator|(
name|sci_cb_physical_address_lower
argument_list|(
name|uf_control
operator|->
name|address_table
operator|.
name|array
index|[
name|frame_get
index|]
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sci_cb_physical_address_upper
argument_list|(
name|uf_control
operator|->
name|address_table
operator|.
name|array
index|[
name|frame_get
index|]
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
name|frame_get
operator|<
name|uf_control
operator|->
name|address_table
operator|.
name|count
operator|)
condition|)
block|{
name|frame_get
operator|++
expr_stmt|;
block|}
comment|// The table has a NULL entry as it's last element.  This is
comment|// illegal.
name|ASSERT
argument_list|(
name|frame_get
operator|<
name|uf_control
operator|->
name|address_table
operator|.
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_index
operator|<
name|uf_control
operator|->
name|address_table
operator|.
name|count
condition|)
block|{
name|uf_control
operator|->
name|buffers
operator|.
name|array
index|[
name|frame_index
index|]
operator|.
name|state
operator|=
name|UNSOLICITED_FRAME_RELEASED
expr_stmt|;
comment|// The frame index is equal to the current get pointer so we
comment|// can now free up all of the frame entries that
if|if
condition|(
name|frame_get
operator|==
name|frame_index
condition|)
block|{
while|while
condition|(
name|uf_control
operator|->
name|buffers
operator|.
name|array
index|[
name|frame_get
index|]
operator|.
name|state
operator|==
name|UNSOLICITED_FRAME_RELEASED
condition|)
block|{
name|uf_control
operator|->
name|buffers
operator|.
name|array
index|[
name|frame_get
index|]
operator|.
name|state
operator|=
name|UNSOLICITED_FRAME_EMPTY
expr_stmt|;
name|INCREMENT_QUEUE_GET
argument_list|(
name|frame_get
argument_list|,
name|frame_cycle
argument_list|,
name|uf_control
operator|->
name|address_table
operator|.
name|count
operator|-
literal|1
argument_list|,
name|uf_control
operator|->
name|address_table
operator|.
name|count
argument_list|)
expr_stmt|;
block|}
name|uf_control
operator|->
name|get
operator|=
operator|(
name|SCU_UFQGP_GEN_BIT
argument_list|(
name|ENABLE_BIT
argument_list|)
operator||
name|frame_cycle
operator||
name|frame_get
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
comment|// Frames remain in use until we advance the get pointer
comment|// so there is nothing we can do here
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

end_unit

