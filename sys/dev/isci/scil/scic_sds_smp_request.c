begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_smp_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_logger.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/sci_environment.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_sas.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sds_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scu_completion_codes.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scu_task_context.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_base_state_machine.h>
end_include

begin_comment
comment|/**  * This method return the memory space required for STP PIO requests.  *  * @return U32  */
end_comment

begin_function
name|U32
name|scic_sds_smp_request_get_object_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|SCIC_SDS_REQUEST_T
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|SMP_REQUEST_T
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|SMP_RESPONSE_T
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|SCU_TASK_CONTEXT_T
argument_list|)
operator|+
name|CACHE_LINE_SIZE
return|;
block|}
end_function

begin_comment
comment|/**  * This macro returns the address of the smp command buffer in the smp request  * memory. No need to cast to SMP request type.  */
end_comment

begin_define
define|#
directive|define
name|scic_sds_smp_request_get_command_buffer_unaligned
parameter_list|(
name|memory
parameter_list|)
define|\
value|( ((char *)(memory)) + sizeof(SCIC_SDS_REQUEST_T) )
end_define

begin_comment
comment|/**  * This macro aligns the smp command buffer in DWORD alignment */
end_comment

begin_define
define|#
directive|define
name|scic_sds_smp_request_align_command_buffer
parameter_list|(
name|address
parameter_list|)
define|\
value|((char *)( \       (((POINTER_UINT)(address)) + (sizeof(U32) - 1)) \& ~(sizeof(U32)- 1) \    ))
end_define

begin_comment
comment|/**  * This macro returns the DWORD-aligned smp command buffer */
end_comment

begin_define
define|#
directive|define
name|scic_sds_smp_request_get_command_buffer
parameter_list|(
name|memory
parameter_list|)
define|\
value|((char *)  \       ((char *)scic_sds_smp_request_align_command_buffer( \          (char *) scic_sds_smp_request_get_command_buffer_unaligned(memory) \    )))
end_define

begin_comment
comment|/**  * This macro returns the address of the smp response buffer in the smp request  * memory.  */
end_comment

begin_define
define|#
directive|define
name|scic_sds_smp_request_get_response_buffer_unaligned
parameter_list|(
name|memory
parameter_list|)
define|\
value|( ((char *)(scic_sds_smp_request_get_command_buffer(memory))) \       + sizeof(SMP_REQUEST_T) )
end_define

begin_comment
comment|/**  * This macro aligns the smp command buffer in DWORD alignment */
end_comment

begin_define
define|#
directive|define
name|scic_sds_smp_request_align_response_buffer
parameter_list|(
name|address
parameter_list|)
define|\
value|((char *)( \       (((POINTER_UINT)(address)) + (sizeof(U32) - 1)) \& ~(sizeof(U32)- 1) \    ))
end_define

begin_comment
comment|/**  * This macro returns the DWORD-aligned smp resposne buffer */
end_comment

begin_define
define|#
directive|define
name|scic_sds_smp_request_get_response_buffer
parameter_list|(
name|memory
parameter_list|)
define|\
value|((char *)  \       ((char *)scic_sds_smp_request_align_response_buffer( \          (char *) scic_sds_smp_request_get_response_buffer_unaligned(memory) \    )))
end_define

begin_comment
comment|/**  * This macro returs the task context buffer for the SMP request.  */
end_comment

begin_define
define|#
directive|define
name|scic_sds_smp_request_get_task_context_buffer_unaligned
parameter_list|(
name|memory
parameter_list|)
define|\
value|((SCU_TASK_CONTEXT_T *)( \         ((char *)(scic_sds_smp_request_get_response_buffer(memory))) \       + sizeof(SMP_RESPONSE_T) \    ))
end_define

begin_comment
comment|/**  * This macro returns the dword-aligned smp task context buffer  */
end_comment

begin_define
define|#
directive|define
name|scic_sds_smp_request_get_task_context_buffer
parameter_list|(
name|memory
parameter_list|)
define|\
value|((SCU_TASK_CONTEXT_T *)( \       ((char *)scic_sds_request_align_task_context_buffer( \          (char *)scic_sds_smp_request_get_task_context_buffer_unaligned(memory)) \    )))
end_define

begin_comment
comment|/**  * @brief This method build the remainder of the IO request object.  *  * @pre The scic_sds_general_request_construct() must be called before this  *      call is valid.  *  * @param[in] this_request This parameter specifies the request object being  *            constructed.  *  * @return none  */
end_comment

begin_function
name|void
name|scic_sds_smp_request_assign_buffers
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
parameter_list|)
block|{
comment|// Assign all of the buffer pointers
name|this_request
operator|->
name|command_buffer
operator|=
name|scic_sds_smp_request_get_command_buffer
argument_list|(
name|this_request
argument_list|)
expr_stmt|;
name|this_request
operator|->
name|response_buffer
operator|=
name|scic_sds_smp_request_get_response_buffer
argument_list|(
name|this_request
argument_list|)
expr_stmt|;
name|this_request
operator|->
name|sgl_element_pair_buffer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|this_request
operator|->
name|was_tag_assigned_by_user
operator|==
name|FALSE
condition|)
block|{
name|this_request
operator|->
name|task_context_buffer
operator|=
name|scic_sds_smp_request_get_task_context_buffer
argument_list|(
name|this_request
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method is called by the SCI user to build an SMP  *        IO request.  *  * @pre  *        - The user must have previously called scic_io_request_construct()  *          on the supplied IO request.  *  * @param[in]  scic_io_request This parameter specifies the handle to the  *             io request object to be built.  *  * @return Indicate if the controller successfully built the IO request.  * @retval SCI_SUCCESS This value is returned if the IO request was  *         successfully built.  * @retval SCI_FAILURE_UNSUPPORTED_PROTOCOL This value is returned if the  *         remote_device does not support the SMP protocol.  * @retval SCI_FAILURE_INVALID_ASSOCIATION This value is returned if the  *         user did not properly set the association between the SCIC IO  *         request and the user's IO request.  Please refer to the  *         sci_object_set_association() routine for more  *         information.  */
end_comment

begin_function
name|SCI_STATUS
name|scic_io_request_construct_smp
parameter_list|(
name|SCI_IO_REQUEST_HANDLE_T
name|scic_smp_request
parameter_list|)
block|{
name|SMP_REQUEST_T
name|smp_request
decl_stmt|;
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
init|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|scic_smp_request
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_request
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_SMP_IO_REQUEST
operator|,
literal|"scic_io_request_construct_smp(0x%x) enter\n"
operator|,
name|this_request
operator|)
argument_list|)
expr_stmt|;
name|this_request
operator|->
name|protocol
operator|=
name|SCIC_SMP_PROTOCOL
expr_stmt|;
name|this_request
operator|->
name|has_started_substate_machine
operator|=
name|TRUE
expr_stmt|;
comment|// Construct the started sub-state machine.
name|sci_base_state_machine_construct
argument_list|(
operator|&
name|this_request
operator|->
name|started_substate_machine
argument_list|,
operator|&
name|this_request
operator|->
name|parent
operator|.
name|parent
argument_list|,
name|scic_sds_smp_request_started_substate_table
argument_list|,
name|SCIC_SDS_SMP_REQUEST_STARTED_SUBSTATE_AWAIT_RESPONSE
argument_list|)
expr_stmt|;
comment|// Construct the SMP SCU Task Context
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|smp_request
argument_list|,
name|this_request
operator|->
name|command_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|SMP_REQUEST_T
argument_list|)
argument_list|)
expr_stmt|;
comment|// Look at the SMP requests' header fields; for certain SAS 1.x SMP
comment|// functions under SAS 2.0, a zero request length really indicates
comment|// a non-zero default length.
if|if
condition|(
name|smp_request
operator|.
name|header
operator|.
name|request_length
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|smp_request
operator|.
name|header
operator|.
name|function
condition|)
block|{
case|case
name|SMP_FUNCTION_DISCOVER
case|:
case|case
name|SMP_FUNCTION_REPORT_PHY_ERROR_LOG
case|:
case|case
name|SMP_FUNCTION_REPORT_PHY_SATA
case|:
case|case
name|SMP_FUNCTION_REPORT_ROUTE_INFORMATION
case|:
name|smp_request
operator|.
name|header
operator|.
name|request_length
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|SMP_FUNCTION_CONFIGURE_ROUTE_INFORMATION
case|:
case|case
name|SMP_FUNCTION_PHY_CONTROL
case|:
case|case
name|SMP_FUNCTION_PHY_TEST
case|:
name|smp_request
operator|.
name|header
operator|.
name|request_length
operator|=
literal|9
expr_stmt|;
break|break;
comment|// Default - zero is a valid default for 2.0.
block|}
block|}
name|scu_smp_request_construct_task_context
argument_list|(
name|this_request
argument_list|,
operator|&
name|smp_request
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_CONSTRUCTED
argument_list|)
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method is called by the SCI user to build an SMP pass-through  *        IO request.  *  * @pre  *        - The user must have previously called scic_io_request_construct()  *          on the supplied IO request.  *  * @param[in]  scic_smp_request This parameter specifies the handle to the  *             io request object to be built.  *  * @param[in]  passthru_cb This parameter specifies the pointer to the callback  *             structure that contains the function pointers  *  * @return Indicate if the controller successfully built the IO request.  */
end_comment

begin_function
name|SCI_STATUS
name|scic_io_request_construct_smp_pass_through
parameter_list|(
name|SCI_IO_REQUEST_HANDLE_T
name|scic_smp_request
parameter_list|,
name|SCIC_SMP_PASSTHRU_REQUEST_CALLBACKS_T
modifier|*
name|passthru_cb
parameter_list|)
block|{
name|SMP_REQUEST_T
name|smp_request
decl_stmt|;
name|U8
modifier|*
name|request_buffer
decl_stmt|;
name|U32
name|request_buffer_length_in_bytes
decl_stmt|;
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
init|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|scic_smp_request
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_request
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_SMP_IO_REQUEST
operator|,
literal|"scic_io_request_construct_smp_pass_through(0x%x) enter\n"
operator|,
name|this_request
operator|)
argument_list|)
expr_stmt|;
name|this_request
operator|->
name|protocol
operator|=
name|SCIC_SMP_PROTOCOL
expr_stmt|;
name|this_request
operator|->
name|has_started_substate_machine
operator|=
name|TRUE
expr_stmt|;
comment|// Call the callback function to retrieve the SMP passthrough request
name|request_buffer_length_in_bytes
operator|=
name|passthru_cb
operator|->
name|scic_cb_smp_passthru_get_request
argument_list|(
operator|(
name|void
operator|*
operator|)
name|this_request
argument_list|,
operator|&
name|request_buffer
argument_list|)
expr_stmt|;
comment|//copy the request to smp request
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|smp_request
operator|.
name|request
operator|.
name|vendor_specific_request
argument_list|,
name|request_buffer
argument_list|,
name|request_buffer_length_in_bytes
argument_list|)
expr_stmt|;
comment|//the header length in smp_request is in dwords - the sas spec has similar way,
comment|//but the csmi header contains the number of bytes, so we need to convert the
comment|//number of bytes to number of dwords
name|smp_request
operator|.
name|header
operator|.
name|request_length
operator|=
call|(
name|U8
call|)
argument_list|(
name|request_buffer_length_in_bytes
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
comment|//Grab the other needed fields from the smp request using callbacks
name|smp_request
operator|.
name|header
operator|.
name|smp_frame_type
operator|=
name|passthru_cb
operator|->
name|scic_cb_smp_passthru_get_frame_type
argument_list|(
operator|(
name|void
operator|*
operator|)
name|this_request
argument_list|)
expr_stmt|;
name|smp_request
operator|.
name|header
operator|.
name|function
operator|=
name|passthru_cb
operator|->
name|scic_cb_smp_passthru_get_function
argument_list|(
operator|(
name|void
operator|*
operator|)
name|this_request
argument_list|)
expr_stmt|;
name|smp_request
operator|.
name|header
operator|.
name|allocated_response_length
operator|=
name|passthru_cb
operator|->
name|scic_cb_smp_passthru_get_allocated_response_length
argument_list|(
operator|(
name|void
operator|*
operator|)
name|this_request
argument_list|)
expr_stmt|;
comment|// Construct the started sub-state machine.
name|sci_base_state_machine_construct
argument_list|(
operator|&
name|this_request
operator|->
name|started_substate_machine
argument_list|,
operator|&
name|this_request
operator|->
name|parent
operator|.
name|parent
argument_list|,
name|scic_sds_smp_request_started_substate_table
argument_list|,
name|SCIC_SDS_SMP_REQUEST_STARTED_SUBSTATE_AWAIT_RESPONSE
argument_list|)
expr_stmt|;
comment|// Construct the SMP SCU Task Context
name|scu_smp_request_construct_task_context
argument_list|(
name|this_request
argument_list|,
operator|&
name|smp_request
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_CONSTRUCTED
argument_list|)
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will fill in the SCU Task Context for a SMP request. The  *        following important settings are utilized:  *  *          -# task_type == SCU_TASK_TYPE_SMP.  This simply indicates  *             that a normal request type (i.e. non-raw frame) is being  *             utilized to perform task management.  *          -# control_frame == 1.  This ensures that the proper endianness  *             is set so that the bytes are transmitted in the right order  *             for a smp request frame.  *  * @param[in] this_request This parameter specifies the smp request object  *            being constructed.  *  * @return none  */
end_comment

begin_function
name|void
name|scu_smp_request_construct_task_context
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
parameter_list|,
name|SMP_REQUEST_T
modifier|*
name|smp_request
parameter_list|)
block|{
name|SCI_PHYSICAL_ADDRESS
name|physical_address
decl_stmt|;
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|owning_controller
decl_stmt|;
name|SCIC_SDS_REMOTE_DEVICE_T
modifier|*
name|target_device
decl_stmt|;
name|SCIC_SDS_PORT_T
modifier|*
name|target_port
decl_stmt|;
name|SCU_TASK_CONTEXT_T
modifier|*
name|task_context
decl_stmt|;
comment|//byte swap the smp request.
name|scic_word_copy_with_swap
argument_list|(
name|this_request
operator|->
name|command_buffer
argument_list|,
operator|(
name|U32
operator|*
operator|)
name|smp_request
argument_list|,
sizeof|sizeof
argument_list|(
name|SMP_REQUEST_T
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
name|task_context
operator|=
name|scic_sds_request_get_task_context
argument_list|(
name|this_request
argument_list|)
expr_stmt|;
name|owning_controller
operator|=
name|scic_sds_request_get_controller
argument_list|(
name|this_request
argument_list|)
expr_stmt|;
name|target_device
operator|=
name|scic_sds_request_get_device
argument_list|(
name|this_request
argument_list|)
expr_stmt|;
name|target_port
operator|=
name|scic_sds_request_get_port
argument_list|(
name|this_request
argument_list|)
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_request
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_SMP_IO_REQUEST
operator|,
literal|"scu_smp_request_construct_task_context(0x%x) contents\n"
literal|"   reqlen=%x; function=%x;\n"
operator|,
name|this_request
operator|,
name|smp_request
operator|->
name|header
operator|.
name|request_length
operator|,
name|smp_request
operator|->
name|header
operator|.
name|function
operator|)
argument_list|)
expr_stmt|;
comment|// Fill in the TC with the its required data
comment|// 00h
name|task_context
operator|->
name|priority
operator|=
literal|0
expr_stmt|;
name|task_context
operator|->
name|initiator_request
operator|=
literal|1
expr_stmt|;
name|task_context
operator|->
name|connection_rate
operator|=
name|scic_remote_device_get_connection_rate
argument_list|(
name|target_device
argument_list|)
expr_stmt|;
name|task_context
operator|->
name|protocol_engine_index
operator|=
name|scic_sds_controller_get_protocol_engine_group
argument_list|(
name|owning_controller
argument_list|)
expr_stmt|;
name|task_context
operator|->
name|logical_port_index
operator|=
name|scic_sds_port_get_index
argument_list|(
name|target_port
argument_list|)
expr_stmt|;
name|task_context
operator|->
name|protocol_type
operator|=
name|SCU_TASK_CONTEXT_PROTOCOL_SMP
expr_stmt|;
name|task_context
operator|->
name|abort
operator|=
literal|0
expr_stmt|;
name|task_context
operator|->
name|valid
operator|=
name|SCU_TASK_CONTEXT_VALID
expr_stmt|;
name|task_context
operator|->
name|context_type
operator|=
name|SCU_TASK_CONTEXT_TYPE
expr_stmt|;
comment|//04h
name|task_context
operator|->
name|remote_node_index
operator|=
name|this_request
operator|->
name|target_device
operator|->
name|rnc
operator|->
name|remote_node_index
expr_stmt|;
name|task_context
operator|->
name|command_code
operator|=
literal|0
expr_stmt|;
name|task_context
operator|->
name|task_type
operator|=
name|SCU_TASK_TYPE_SMP_REQUEST
expr_stmt|;
comment|//08h
name|task_context
operator|->
name|link_layer_control
operator|=
literal|0
expr_stmt|;
name|task_context
operator|->
name|do_not_dma_ssp_good_response
operator|=
literal|1
expr_stmt|;
name|task_context
operator|->
name|strict_ordering
operator|=
literal|0
expr_stmt|;
name|task_context
operator|->
name|control_frame
operator|=
literal|1
expr_stmt|;
name|task_context
operator|->
name|timeout_enable
operator|=
literal|0
expr_stmt|;
name|task_context
operator|->
name|block_guard_enable
operator|=
literal|0
expr_stmt|;
comment|//0ch
name|task_context
operator|->
name|address_modifier
operator|=
literal|0
expr_stmt|;
comment|//10h
name|task_context
operator|->
name|ssp_command_iu_length
operator|=
name|smp_request
operator|->
name|header
operator|.
name|request_length
expr_stmt|;
comment|//14h
name|task_context
operator|->
name|transfer_length_bytes
operator|=
literal|0
expr_stmt|;
comment|//18h ~ 30h, protocol specific
comment|// since commandIU has been build by framework at this point, we just
comment|// copy the frist DWord from command IU to this location.
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|task_context
operator|->
name|type
operator|.
name|smp
operator|)
argument_list|,
name|this_request
operator|->
name|command_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
comment|//40h
comment|// "For SMP you could program it to zero. We would prefer that way so that
comment|// done code will be consistent." - Venki
name|task_context
operator|->
name|task_phase
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|this_request
operator|->
name|was_tag_assigned_by_user
condition|)
block|{
comment|// Build the task context now since we have already read the data
name|this_request
operator|->
name|post_context
operator|=
operator|(
name|SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC
operator||
operator|(
name|scic_sds_controller_get_protocol_engine_group
argument_list|(
name|owning_controller
argument_list|)
operator|<<
name|SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT
operator|)
operator||
operator|(
name|scic_sds_port_get_index
argument_list|(
name|target_port
argument_list|)
operator|<<
name|SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT
operator|)
operator||
name|scic_sds_io_tag_get_index
argument_list|(
name|this_request
operator|->
name|io_tag
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Build the task context now since we have already read the data
name|this_request
operator|->
name|post_context
operator|=
operator|(
name|SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC
operator||
operator|(
name|scic_sds_controller_get_protocol_engine_group
argument_list|(
name|owning_controller
argument_list|)
operator|<<
name|SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT
operator|)
operator||
operator|(
name|scic_sds_port_get_index
argument_list|(
name|target_port
argument_list|)
operator|<<
name|SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT
operator|)
comment|// This is not assigned because we have to wait until we get a TCi
operator|)
expr_stmt|;
block|}
comment|// Copy the physical address for the command buffer to the SCU Task Context
comment|// command buffer should not contain command header.
name|scic_cb_io_request_get_physical_address
argument_list|(
name|scic_sds_request_get_controller
argument_list|(
name|this_request
argument_list|)
argument_list|,
name|this_request
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|this_request
operator|->
name|command_buffer
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
argument_list|,
operator|&
name|physical_address
argument_list|)
expr_stmt|;
name|task_context
operator|->
name|command_iu_upper
operator|=
name|sci_cb_physical_address_upper
argument_list|(
name|physical_address
argument_list|)
expr_stmt|;
name|task_context
operator|->
name|command_iu_lower
operator|=
name|sci_cb_physical_address_lower
argument_list|(
name|physical_address
argument_list|)
expr_stmt|;
comment|//SMP response comes as UF, so no need to set response IU address.
name|task_context
operator|->
name|response_iu_upper
operator|=
literal|0
expr_stmt|;
name|task_context
operator|->
name|response_iu_lower
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* SMP REQUEST STATE MACHINE
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method processes an unsolicited frame while the SMP request is  *        waiting for a response frame.  It will copy the response data, release  *        the unsolicited frame, and transition the request to the  *        SCI_BASE_REQUEST_STATE_COMPLETED state.  *  * @param[in] this_request This parameter specifies the request for which  *            the unsolicited frame was received.  * @param[in] frame_index This parameter indicates the unsolicited frame  *            index that should contain the response.  *  * @return This method returns an indication of whether the response  *         frame was handled successfully or not.  * @retval SCI_SUCCESS Currently this value is always returned and indicates  *         successful processing of the TC response.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_smp_request_await_response_frame_handler
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
parameter_list|,
name|U32
name|frame_index
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|void
modifier|*
name|frame_header
decl_stmt|;
name|SMP_RESPONSE_HEADER_T
modifier|*
name|this_frame_header
decl_stmt|;
name|U8
modifier|*
name|user_smp_buffer
init|=
name|this_request
operator|->
name|response_buffer
decl_stmt|;
comment|// Save off the controller, so that we do not touch the request after it
comment|//  is completed.
name|SCIC_SDS_CONTROLLER_T
modifier|*
name|controller
init|=
name|scic_sds_request_get_controller
argument_list|(
name|this_request
argument_list|)
decl_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_request
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_SMP_IO_REQUEST
operator|,
literal|"scic_sds_smp_request_await_response_frame_handler(0x%x, 0x%x) enter\n"
operator|,
name|this_request
operator|,
name|frame_index
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|scic_sds_unsolicited_frame_control_get_header
argument_list|(
operator|&
operator|(
name|controller
operator|->
name|uf_control
operator|)
argument_list|,
name|frame_index
argument_list|,
operator|&
name|frame_header
argument_list|)
expr_stmt|;
comment|//byte swap the header.
name|scic_word_copy_with_swap
argument_list|(
operator|(
name|U32
operator|*
operator|)
name|user_smp_buffer
argument_list|,
name|frame_header
argument_list|,
sizeof|sizeof
argument_list|(
name|SMP_RESPONSE_HEADER_T
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
name|this_frame_header
operator|=
operator|(
name|SMP_RESPONSE_HEADER_T
operator|*
operator|)
name|user_smp_buffer
expr_stmt|;
if|if
condition|(
name|this_frame_header
operator|->
name|smp_frame_type
operator|==
name|SMP_FRAME_TYPE_RESPONSE
condition|)
block|{
name|void
modifier|*
name|smp_response_buffer
decl_stmt|;
name|status
operator|=
name|scic_sds_unsolicited_frame_control_get_buffer
argument_list|(
operator|&
operator|(
name|controller
operator|->
name|uf_control
operator|)
argument_list|,
name|frame_index
argument_list|,
operator|&
name|smp_response_buffer
argument_list|)
expr_stmt|;
name|scic_word_copy_with_swap
argument_list|(
operator|(
name|U32
operator|*
operator|)
operator|(
name|user_smp_buffer
operator|+
sizeof|sizeof
argument_list|(
name|SMP_RESPONSE_HEADER_T
argument_list|)
operator|)
argument_list|,
name|smp_response_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|SMP_RESPONSE_BODY_T
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_frame_header
operator|->
name|function
operator|==
name|SMP_FUNCTION_DISCOVER
condition|)
block|{
name|SMP_RESPONSE_T
modifier|*
name|this_smp_response
decl_stmt|;
name|this_smp_response
operator|=
operator|(
name|SMP_RESPONSE_T
operator|*
operator|)
name|user_smp_buffer
expr_stmt|;
comment|// Some expanders only report an attached SATA device, and
comment|// not an STP target.  Since the core depends on the STP
comment|// target attribute to correctly build I/O, set the bit now
comment|// if necessary.
if|if
condition|(
name|this_smp_response
operator|->
name|response
operator|.
name|discover
operator|.
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_sata_device
operator|&&
operator|!
name|this_smp_response
operator|->
name|response
operator|.
name|discover
operator|.
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_stp_target
condition|)
block|{
name|this_smp_response
operator|->
name|response
operator|.
name|discover
operator|.
name|protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_stp_target
operator|=
literal|1
expr_stmt|;
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_request
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_SMP_IO_REQUEST
operator|,
literal|"scic_sds_smp_request_await_response_frame_handler(0x%x) Found SATA dev, setting STP bit.\n"
operator|,
name|this_request
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//Don't need to copy to user space. User instead will refer to
comment|//core request's response buffer.
comment|//copy the smp response to framework smp request's response buffer.
comment|//scic_sds_smp_request_copy_response(this_request);
name|scic_sds_request_set_status
argument_list|(
name|this_request
argument_list|,
name|SCU_TASK_DONE_GOOD
argument_list|,
name|SCI_SUCCESS
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|started_substate_machine
argument_list|,
name|SCIC_SDS_SMP_REQUEST_STARTED_SUBSTATE_AWAIT_TC_COMPLETION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This was not a response frame why did it get forwarded?
name|SCIC_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_request
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_SMP_IO_REQUEST
operator|,
literal|"SCIC SMP Request 0x%08x received unexpected frame %d type 0x%02x\n"
operator|,
name|this_request
operator|,
name|frame_index
operator|,
name|this_frame_header
operator|->
name|smp_frame_type
operator|)
argument_list|)
expr_stmt|;
name|scic_sds_request_set_status
argument_list|(
name|this_request
argument_list|,
name|SCU_TASK_DONE_SMP_FRM_TYPE_ERR
argument_list|,
name|SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_COMPLETED
argument_list|)
expr_stmt|;
block|}
name|scic_sds_controller_release_frame
argument_list|(
name|controller
argument_list|,
name|frame_index
argument_list|)
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method processes an abnormal TC completion while the SMP  *        request is waiting for a response frame.  It decides what  *        happened to the IO based on TC completion status.  *  * @param[in] this_request This parameter specifies the request for which  *            the TC completion was received.  * @param[in] completion_code This parameter indicates the completion status  *            information for the TC.  *  * @return Indicate if the tc completion handler was successful.  * @retval SCI_SUCCESS currently this method always returns success.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_smp_request_await_response_tc_completion_handler
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
parameter_list|,
name|U32
name|completion_code
parameter_list|)
block|{
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_request
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_SMP_IO_REQUEST
operator|,
literal|"scic_sds_smp_request_await_response_tc_completion_handler(0x%x, 0x%x) enter\n"
operator|,
name|this_request
operator|,
name|completion_code
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SCU_GET_COMPLETION_TL_STATUS
argument_list|(
name|completion_code
argument_list|)
condition|)
block|{
case|case
name|SCU_MAKE_COMPLETION_STATUS
argument_list|(
name|SCU_TASK_DONE_GOOD
argument_list|)
case|:
comment|//In the AWAIT RESPONSE state, any TC completion is unexpected.
comment|//but if the TC has success status, we complete the IO anyway.
name|scic_sds_request_set_status
argument_list|(
name|this_request
argument_list|,
name|SCU_TASK_DONE_GOOD
argument_list|,
name|SCI_SUCCESS
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_COMPLETED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCU_MAKE_COMPLETION_STATUS
argument_list|(
name|SCU_TASK_DONE_SMP_RESP_TO_ERR
argument_list|)
case|:
case|case
name|SCU_MAKE_COMPLETION_STATUS
argument_list|(
name|SCU_TASK_DONE_SMP_UFI_ERR
argument_list|)
case|:
case|case
name|SCU_MAKE_COMPLETION_STATUS
argument_list|(
name|SCU_TASK_DONE_SMP_FRM_TYPE_ERR
argument_list|)
case|:
case|case
name|SCU_MAKE_COMPLETION_STATUS
argument_list|(
name|SCU_TASK_DONE_SMP_LL_RX_ERR
argument_list|)
case|:
comment|//These status has been seen in a specific LSI expander, which sometimes
comment|//is not able to send smp response within 2 ms. This causes our hardware
comment|//break the connection and set TC completion with one of these SMP_XXX_XX_ERR
comment|//status. For these type of error, we ask scic user to retry the request.
name|scic_sds_request_set_status
argument_list|(
name|this_request
argument_list|,
name|SCU_TASK_DONE_SMP_RESP_TO_ERR
argument_list|,
name|SCI_FAILURE_RETRY_REQUIRED
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_COMPLETED
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// All other completion status cause the IO to be complete.  If a NAK
comment|// was received, then it is up to the user to retry the request.
name|scic_sds_request_set_status
argument_list|(
name|this_request
argument_list|,
name|SCU_NORMALIZE_COMPLETION_STATUS
argument_list|(
name|completion_code
argument_list|)
argument_list|,
name|SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_COMPLETED
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method processes the completions transport layer (TL) status  *        to determine if the SMP request was sent successfully. If the SMP  *        request was sent successfully, then the state for the SMP request  *        transits to waiting for a response frame.  *  * @param[in] this_request This parameter specifies the request for which  *            the TC completion was received.  * @param[in] completion_code This parameter indicates the completion status  *            information for the TC.  *  * @return Indicate if the tc completion handler was successful.  * @retval SCI_SUCCESS currently this method always returns success.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scic_sds_smp_request_await_tc_completion_tc_completion_handler
parameter_list|(
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
parameter_list|,
name|U32
name|completion_code
parameter_list|)
block|{
name|SCIC_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|this_request
argument_list|)
operator|,
name|SCIC_LOG_OBJECT_SMP_IO_REQUEST
operator|,
literal|"scic_sds_smp_request_await_tc_completion_tc_completion_handler(0x%x, 0x%x) enter\n"
operator|,
name|this_request
operator|,
name|completion_code
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SCU_GET_COMPLETION_TL_STATUS
argument_list|(
name|completion_code
argument_list|)
condition|)
block|{
case|case
name|SCU_MAKE_COMPLETION_STATUS
argument_list|(
name|SCU_TASK_DONE_GOOD
argument_list|)
case|:
name|scic_sds_request_set_status
argument_list|(
name|this_request
argument_list|,
name|SCU_TASK_DONE_GOOD
argument_list|,
name|SCI_SUCCESS
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_COMPLETED
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// All other completion status cause the IO to be complete.  If a NAK
comment|// was received, then it is up to the user to retry the request.
name|scic_sds_request_set_status
argument_list|(
name|this_request
argument_list|,
name|SCU_NORMALIZE_COMPLETION_STATUS
argument_list|(
name|completion_code
argument_list|)
argument_list|,
name|SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|this_request
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_COMPLETED
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_decl_stmt
name|SCIC_SDS_IO_REQUEST_STATE_HANDLER_T
name|scic_sds_smp_request_started_substate_handler_table
index|[
name|SCIC_SDS_SMP_REQUEST_STARTED_MAX_SUBSTATES
index|]
init|=
block|{
comment|// SCIC_SDS_SMP_REQUEST_STARTED_SUBSTATE_AWAIT_RESPONSE
block|{
block|{
name|scic_sds_request_default_start_handler
block|,
name|scic_sds_request_started_state_abort_handler
block|,
name|scic_sds_request_default_complete_handler
block|,
name|scic_sds_request_default_destruct_handler
block|}
block|,
name|scic_sds_smp_request_await_response_tc_completion_handler
block|,
name|scic_sds_request_default_event_handler
block|,
name|scic_sds_smp_request_await_response_frame_handler
block|}
block|,
comment|// SCIC_SDS_SMP_REQUEST_STARTED_SUBSTATE_AWAIT_TC_COMPLETION
block|{
block|{
name|scic_sds_request_default_start_handler
block|,
name|scic_sds_request_started_state_abort_handler
block|,
name|scic_sds_request_default_complete_handler
block|,
name|scic_sds_request_default_destruct_handler
block|}
block|,
name|scic_sds_smp_request_await_tc_completion_tc_completion_handler
block|,
name|scic_sds_request_default_event_handler
block|,
name|scic_sds_request_default_frame_handler
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * @brief This method performs the actions required when entering the  *        SCIC_SDS_SMP_REQUEST_STARTED_SUBSTATE_AWAIT_TC_RESPONSE sub-state.  *        This includes setting the IO request state handlers for this  *        sub-state.  *  * @param[in]  object This parameter specifies the request object for which  *             the sub-state change is occurring.  *  * @return none.  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_smp_request_started_await_response_substate_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
init|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|object
decl_stmt|;
name|SET_STATE_HANDLER
argument_list|(
name|this_request
argument_list|,
name|scic_sds_smp_request_started_substate_handler_table
argument_list|,
name|SCIC_SDS_SMP_REQUEST_STARTED_SUBSTATE_AWAIT_RESPONSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method performs the actions required when entering the  *        SCIC_SDS_SMP_REQUEST_STARTED_SUBSTATE_AWAIT_TC_COMPLETION  *        sub-state.  This includes setting the SMP request state handlers for  *        this sub-state.  *  * @param[in]  object This parameter specifies the request object for which  *             the sub-state change is occurring.  *  * @return none.  */
end_comment

begin_function
specifier|static
name|void
name|scic_sds_smp_request_started_await_tc_completion_substate_enter
parameter_list|(
name|SCI_BASE_OBJECT_T
modifier|*
name|object
parameter_list|)
block|{
name|SCIC_SDS_REQUEST_T
modifier|*
name|this_request
init|=
operator|(
name|SCIC_SDS_REQUEST_T
operator|*
operator|)
name|object
decl_stmt|;
name|SET_STATE_HANDLER
argument_list|(
name|this_request
argument_list|,
name|scic_sds_smp_request_started_substate_handler_table
argument_list|,
name|SCIC_SDS_SMP_REQUEST_STARTED_SUBSTATE_AWAIT_TC_COMPLETION
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|SCI_BASE_STATE_T
name|scic_sds_smp_request_started_substate_table
index|[
name|SCIC_SDS_SMP_REQUEST_STARTED_MAX_SUBSTATES
index|]
init|=
block|{
block|{
name|SCIC_SDS_SMP_REQUEST_STARTED_SUBSTATE_AWAIT_RESPONSE
block|,
name|scic_sds_smp_request_started_await_response_substate_enter
block|,
name|NULL
block|}
block|,
block|{
name|SCIC_SDS_SMP_REQUEST_STARTED_SUBSTATE_AWAIT_TC_COMPLETION
block|,
name|scic_sds_smp_request_started_await_tc_completion_substate_enter
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

