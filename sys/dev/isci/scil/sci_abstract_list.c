begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  *  * @brief This file contains the implementation of an abstract list class.  *        This class will allow for the same item to occur multiple times in  *        the list.  It will provide an interface that is similar to the  *        C++ standard template list interface.  */
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//*
end_comment

begin_comment
comment|//*     I N C L U D E S
end_comment

begin_comment
comment|//*
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_abstract_list.h>
end_include

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//*
end_comment

begin_comment
comment|//*     P R I V A T E   M E M B E R S
end_comment

begin_comment
comment|//*
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//*
end_comment

begin_comment
comment|//*     P R O T E C T E D   M E T H O D S
end_comment

begin_comment
comment|//*
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief Initialize the abstract list  *  * @pre The supplied free pool should be constructed prior to utilization  *      of this abstract list.  It isn't mandatory for the free pool to be  *      constructed before invoking this method, but suggested.  *  * @param[in] list This parameter specifies the abstract list to be  *            constructed.  * @param[in] free_pool This parameter specifies the free pool to be  *            utilized as the repository of free elements for list usage.  *  * @return none  */
end_comment

begin_function
name|void
name|sci_abstract_list_construct
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list
parameter_list|,
name|SCI_ABSTRACT_ELEMENT_POOL_T
modifier|*
name|free_pool
parameter_list|)
block|{
name|memset
argument_list|(
name|list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SCI_ABSTRACT_LIST_T
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|->
name|free_pool
operator|=
name|free_pool
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Initialize the abstract list with its free pool  *  * @param[in] pool  *    the free pool from which the elements will be extracted  * @param[in] list_elements  *    the array of list elements to be added to the free list  * @param[in] element_count  *    the count of the elements to be added to the free list these should be  *    the same as the array size of list elements  *  * @return none  */
end_comment

begin_function
name|void
name|sci_abstract_element_pool_construct
parameter_list|(
name|SCI_ABSTRACT_ELEMENT_POOL_T
modifier|*
name|pool
parameter_list|,
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|list_elements
parameter_list|,
name|int
name|element_count
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|memset
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SCI_ABSTRACT_ELEMENT_POOL_T
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|list_elements
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SCI_ABSTRACT_ELEMENT_T
argument_list|)
operator|*
name|element_count
argument_list|)
expr_stmt|;
name|pool
operator|->
name|elements
operator|=
name|list_elements
expr_stmt|;
name|pool
operator|->
name|max_elements
operator|=
name|element_count
expr_stmt|;
comment|// Loop through all of the elements in the array and push them onto the
comment|// pool's free list.
for|for
control|(
name|index
operator|=
name|element_count
operator|-
literal|1
init|;
name|index
operator|>=
literal|0
condition|;
name|index
operator|--
control|)
block|{
name|private_pool_free
argument_list|(
name|pool
argument_list|,
operator|&
operator|(
name|list_elements
index|[
name|index
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ABSTRACT_LIST_FUNCTIONS
end_ifdef

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//*
end_comment

begin_comment
comment|//*     P U B L I C   M E T H O D S
end_comment

begin_comment
comment|//*
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * Simply return the front element pointer of the list.  This returns an element  * element as opposed to what the element is pointing to.  */
end_comment

begin_function
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|sci_abstract_list_get_front
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list_p
parameter_list|)
block|{
return|return
operator|(
name|list_p
operator|)
operator|->
name|elements
operator|.
name|front_p
return|;
block|}
end_function

begin_comment
comment|/**  * This method simply returns the object pointed to by the head (front) of  * the list.  */
end_comment

begin_function
name|void
modifier|*
name|sci_abstract_list_front
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list_p
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|list_p
operator|)
operator|->
name|elements
operator|.
name|front_p
operator|)
condition|?
operator|(
operator|(
name|list_p
operator|)
operator|->
name|elements
operator|.
name|front_p
operator|->
name|object_p
operator|)
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * This method simply returns the object pointed to by the tail (back) of  * the list.  */
end_comment

begin_function
name|void
modifier|*
name|sci_abstract_list_back
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list_p
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|list_p
operator|)
operator|->
name|elements
operator|.
name|back_p
operator|)
condition|?
operator|(
operator|(
name|list_p
operator|)
operator|->
name|elements
operator|.
name|back_p
operator|->
name|object_p
operator|)
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * This method will return FALSE if the list is not empty.  */
end_comment

begin_function
name|BOOL
name|sci_abstract_list_is_empty
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list_p
parameter_list|)
block|{
return|return
operator|(
operator|(
name|list_p
operator|)
operator|->
name|elements
operator|.
name|front_p
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * This method will return the number of elements queued in the list.  */
end_comment

begin_function
name|U32
name|sci_abstract_list_size
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list_p
parameter_list|)
block|{
return|return
operator|(
operator|(
name|list_p
operator|)
operator|->
name|elements
operator|.
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * This method simply returns the next list element in the list.  */
end_comment

begin_function
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|sci_abstract_list_get_next
parameter_list|(
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|alElement_p
parameter_list|)
block|{
return|return
operator|(
operator|(
name|alElement_p
operator|)
operator|->
name|next_p
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SCI_LOGGING
argument_list|)
end_if

begin_comment
comment|/**  * This method simply prints the contents of the list.  */
end_comment

begin_function
name|void
name|sci_abstract_list_print
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list_p
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|alElement_p
init|=
name|list_p
operator|->
name|elements
operator|.
name|front_p
decl_stmt|;
while|while
condition|(
name|alElement_p
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|UNIT_TEST_DEBUG
comment|/* Check to see if we found the object for which we are searching. */
name|printf
argument_list|(
literal|"ITEM next_p 0x%x prev_p 0x%x obj_p 0x%x, 0x%x\n"
argument_list|,
name|alElement_p
operator|->
name|next_p
argument_list|,
name|alElement_p
operator|->
name|previous_p
argument_list|,
operator|(
name|U32
operator|*
operator|)
operator|(
name|alElement_p
operator|->
name|object_p
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alElement_p
operator|=
name|alElement_p
operator|->
name|next_p
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// defined(SCI_LOGGING)
end_comment

begin_comment
comment|/**  * This method will simply search the supplied list for the desired object.  * It will return a pointer to the object, if it is found.  Otherwise  * it will return NULL.  */
end_comment

begin_function
name|void
modifier|*
name|sci_abstract_list_find
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list_p
parameter_list|,
name|void
modifier|*
name|obj_p
parameter_list|)
block|{
return|return
name|sci_abstract_list_get_object
argument_list|(
name|private_find
argument_list|(
operator|&
operator|(
name|list_p
operator|)
operator|->
name|elements
argument_list|,
operator|(
name|obj_p
operator|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * This method will simply remove the element at the back (tail) of the list.  * It will return a pointer to the object that was removed or NULL if not  * found.  */
end_comment

begin_function
name|void
modifier|*
name|sci_abstract_list_popback
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list_p
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_LIST_T
modifier|*
name|elem_list
init|=
operator|&
operator|(
name|list_p
operator|)
operator|->
name|elements
decl_stmt|;
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|alElement_p
init|=
name|elem_list
operator|->
name|back_p
decl_stmt|;
name|void
modifier|*
name|obj_p
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|alElement_p
operator|!=
name|NULL
condition|)
block|{
name|obj_p
operator|=
name|alElement_p
operator|->
name|object_p
expr_stmt|;
if|if
condition|(
name|elem_list
operator|->
name|back_p
operator|==
name|elem_list
operator|->
name|front_p
condition|)
block|{
name|elem_list
operator|->
name|back_p
operator|=
name|elem_list
operator|->
name|front_p
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|elem_list
operator|->
name|back_p
operator|=
name|elem_list
operator|->
name|back_p
operator|->
name|previous_p
expr_stmt|;
name|elem_list
operator|->
name|back_p
operator|->
name|next_p
operator|=
name|NULL
expr_stmt|;
block|}
name|elem_list
operator|->
name|size
operator|--
expr_stmt|;
name|private_pool_free
argument_list|(
operator|(
name|list_p
operator|)
operator|->
name|free_pool
argument_list|,
name|alElement_p
argument_list|)
expr_stmt|;
block|}
return|return
name|obj_p
return|;
block|}
end_function

begin_comment
comment|/**  * This method simply removes the list element at the head of the list  * and returns the pointer to the object that was removed.  */
end_comment

begin_function
name|void
modifier|*
name|sci_abstract_list_popfront
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list_p
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|alElement_p
init|=
name|private_pop_front
argument_list|(
operator|&
operator|(
name|list_p
operator|)
operator|->
name|elements
argument_list|)
decl_stmt|;
name|void
modifier|*
name|obj_p
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|alElement_p
operator|!=
name|NULL
condition|)
block|{
name|obj_p
operator|=
name|alElement_p
operator|->
name|object_p
expr_stmt|;
name|private_pool_free
argument_list|(
operator|(
name|list_p
operator|)
operator|->
name|free_pool
argument_list|,
name|alElement_p
argument_list|)
expr_stmt|;
block|}
return|return
name|obj_p
return|;
block|}
end_function

begin_comment
comment|/**  * This method will erase (remove) all instances of the supplied object from  * anywhere in the list.  */
end_comment

begin_function
name|void
name|sci_abstract_list_erase
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list_p
parameter_list|,
name|void
modifier|*
name|obj_p
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_LIST_T
modifier|*
name|elem_list
init|=
operator|&
operator|(
name|list_p
operator|)
operator|->
name|elements
decl_stmt|;
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|alElement_p
decl_stmt|;
while|while
condition|(
operator|(
name|alElement_p
operator|=
name|private_find
argument_list|(
name|elem_list
argument_list|,
operator|(
name|obj_p
operator|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|alElement_p
operator|==
name|elem_list
operator|->
name|front_p
condition|)
block|{
name|sci_abstract_list_popfront
argument_list|(
name|list_p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alElement_p
operator|==
name|elem_list
operator|->
name|back_p
condition|)
block|{
name|sci_abstract_list_popback
argument_list|(
name|list_p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alElement_p
operator|->
name|previous_p
operator|->
name|next_p
operator|=
name|alElement_p
operator|->
name|next_p
expr_stmt|;
name|alElement_p
operator|->
name|next_p
operator|->
name|previous_p
operator|=
name|alElement_p
operator|->
name|previous_p
expr_stmt|;
name|elem_list
operator|->
name|size
operator|--
expr_stmt|;
name|private_pool_free
argument_list|(
operator|(
name|list_p
operator|)
operator|->
name|free_pool
argument_list|,
name|alElement_p
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * This method simply adds a LIST_ELEMENT for the supplied object to the back  * (tail) of the supplied list.  */
end_comment

begin_function
name|void
name|sci_abstract_list_pushback
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list_p
parameter_list|,
name|void
modifier|*
name|obj_p
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_LIST_T
modifier|*
name|elem_list
init|=
operator|&
operator|(
name|list_p
operator|)
operator|->
name|elements
decl_stmt|;
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|alElement_p
init|=
name|private_pool_allocate
argument_list|(
operator|(
name|list_p
operator|)
operator|->
name|free_pool
argument_list|)
decl_stmt|;
comment|//   assert(alElement_p != NULL);
name|alElement_p
operator|->
name|object_p
operator|=
operator|(
name|obj_p
operator|)
expr_stmt|;
if|if
condition|(
name|elem_list
operator|->
name|front_p
operator|==
name|NULL
condition|)
block|{
name|elem_list
operator|->
name|front_p
operator|=
name|elem_list
operator|->
name|back_p
operator|=
name|alElement_p
expr_stmt|;
block|}
else|else
block|{
name|elem_list
operator|->
name|back_p
operator|->
name|next_p
operator|=
name|alElement_p
expr_stmt|;
name|alElement_p
operator|->
name|previous_p
operator|=
name|elem_list
operator|->
name|back_p
expr_stmt|;
name|elem_list
operator|->
name|back_p
operator|=
name|alElement_p
expr_stmt|;
block|}
name|elem_list
operator|->
name|size
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method simply adds a LIST_ELEMENT for the supplied object to the front  * (head) of the supplied list.  */
end_comment

begin_function
name|void
name|sci_abstract_list_pushfront
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list_p
parameter_list|,
name|void
modifier|*
name|obj_p
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|alElement_p
init|=
name|private_pool_allocate
argument_list|(
operator|(
name|list_p
operator|)
operator|->
name|free_pool
argument_list|)
decl_stmt|;
name|alElement_p
operator|->
name|object_p
operator|=
operator|(
name|obj_p
operator|)
expr_stmt|;
name|private_push_front
argument_list|(
operator|&
operator|(
name|list_p
operator|)
operator|->
name|elements
argument_list|,
name|alElement_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method will add the objToAdd_p object to the list before the obj_p.  *  */
end_comment

begin_function
name|void
name|sci_abstract_list_insert
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list_p
parameter_list|,
name|void
modifier|*
name|obj_p
parameter_list|,
name|void
modifier|*
name|objToAdd_p
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_LIST_T
modifier|*
name|elem_list
init|=
operator|&
operator|(
name|list_p
operator|)
operator|->
name|elements
decl_stmt|;
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|obj_element
init|=
name|private_find
argument_list|(
name|elem_list
argument_list|,
name|obj_p
argument_list|)
decl_stmt|;
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|objToAdd_element
init|=
name|private_pool_allocate
argument_list|(
operator|(
name|list_p
operator|)
operator|->
name|free_pool
argument_list|)
decl_stmt|;
name|objToAdd_element
operator|->
name|object_p
operator|=
name|objToAdd_p
expr_stmt|;
name|ASSERT
argument_list|(
name|obj_element
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|objToAdd_element
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_element
operator|==
name|elem_list
operator|->
name|front_p
condition|)
block|{
name|objToAdd_element
operator|->
name|object_p
operator|=
operator|(
name|objToAdd_p
operator|)
expr_stmt|;
name|private_push_front
argument_list|(
operator|&
operator|(
name|list_p
operator|)
operator|->
name|elements
argument_list|,
name|objToAdd_element
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|obj_element
operator|->
name|previous_p
operator|->
name|next_p
operator|=
name|objToAdd_element
expr_stmt|;
name|objToAdd_element
operator|->
name|previous_p
operator|=
name|obj_element
operator|->
name|previous_p
expr_stmt|;
name|obj_element
operator|->
name|previous_p
operator|=
name|objToAdd_element
expr_stmt|;
name|objToAdd_element
operator|->
name|next_p
operator|=
name|obj_element
expr_stmt|;
name|elem_list
operator|->
name|size
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * This method simply frees all the items from the list.  */
end_comment

begin_function
name|void
name|sci_abstract_list_clear
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|list_p
parameter_list|)
block|{
while|while
condition|(
operator|(
name|list_p
operator|)
operator|->
name|elements
operator|.
name|size
operator|>
literal|0
condition|)
name|sci_abstract_list_popfront
argument_list|(
operator|(
name|list_p
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method simply returns the object being pointed to by the list element  * (The item being listed).  */
end_comment

begin_function
name|void
modifier|*
name|sci_abstract_list_get_object
parameter_list|(
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|alElement_p
parameter_list|)
block|{
name|void
modifier|*
name|obj_p
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|alElement_p
operator|)
operator|!=
name|NULL
condition|)
name|obj_p
operator|=
operator|(
name|alElement_p
operator|)
operator|->
name|object_p
expr_stmt|;
return|return
name|obj_p
return|;
block|}
end_function

begin_comment
comment|/**  * This method is simply a wrapper to provide the number of elements in  * the free list.  */
end_comment

begin_function
name|U32
name|sci_abstract_list_freeList_size
parameter_list|(
name|SCI_ABSTRACT_LIST_T
modifier|*
name|freeList
parameter_list|)
block|{
return|return
operator|(
name|sci_abstract_list_size
argument_list|(
name|freeList
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//*
end_comment

begin_comment
comment|//*     P R I V A T E   M E T H O D S
end_comment

begin_comment
comment|//*
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * This method simply performs the common portion of pushing a list element  * onto a list.  *  * WARNING: This is a private helper method that should not be called directly  *          by any users.  */
end_comment

begin_function
name|void
name|private_push_front
parameter_list|(
name|SCI_ABSTRACT_ELEMENT_LIST_T
modifier|*
name|privateList_p
parameter_list|,
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|alElement_p
parameter_list|)
block|{
if|if
condition|(
operator|(
name|privateList_p
operator|)
operator|->
name|front_p
operator|==
name|NULL
condition|)
block|{
operator|(
name|privateList_p
operator|)
operator|->
name|front_p
operator|=
operator|(
name|privateList_p
operator|)
operator|->
name|back_p
operator|=
operator|(
name|alElement_p
operator|)
expr_stmt|;
operator|(
name|alElement_p
operator|)
operator|->
name|next_p
operator|=
operator|(
name|alElement_p
operator|)
operator|->
name|previous_p
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|(
name|alElement_p
operator|)
operator|->
name|next_p
operator|=
operator|(
name|privateList_p
operator|)
operator|->
name|front_p
expr_stmt|;
operator|(
name|alElement_p
operator|)
operator|->
name|previous_p
operator|=
name|NULL
expr_stmt|;
operator|(
name|privateList_p
operator|)
operator|->
name|front_p
operator|->
name|previous_p
operator|=
operator|(
name|alElement_p
operator|)
expr_stmt|;
operator|(
name|privateList_p
operator|)
operator|->
name|front_p
operator|=
operator|(
name|alElement_p
operator|)
expr_stmt|;
block|}
operator|(
name|privateList_p
operator|)
operator|->
name|size
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method simply performs the common portion of popping a list element  * from a list.  *  * WARNING: This is a private helper method that should not be called directly  *          by any users.  */
end_comment

begin_function
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|private_pop_front
parameter_list|(
name|SCI_ABSTRACT_ELEMENT_LIST_T
modifier|*
name|privateList_p
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|alElement_p
init|=
operator|(
name|privateList_p
operator|)
operator|->
name|front_p
decl_stmt|;
if|if
condition|(
name|alElement_p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|privateList_p
operator|)
operator|->
name|front_p
operator|==
operator|(
name|privateList_p
operator|)
operator|->
name|back_p
condition|)
block|{
operator|(
name|privateList_p
operator|)
operator|->
name|front_p
operator|=
operator|(
name|privateList_p
operator|)
operator|->
name|back_p
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|(
name|privateList_p
operator|)
operator|->
name|front_p
operator|=
operator|(
name|privateList_p
operator|)
operator|->
name|front_p
operator|->
name|next_p
expr_stmt|;
operator|(
name|privateList_p
operator|)
operator|->
name|front_p
operator|->
name|previous_p
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|privateList_p
operator|)
operator|->
name|size
operator|--
expr_stmt|;
block|}
return|return
name|alElement_p
return|;
block|}
end_function

begin_comment
comment|/**  * This method will simply search the supplied list for the desired object.  * It will return a pointer to the abstract_list_element if found, otherwise  * it will return NULL.  */
end_comment

begin_function
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|private_find
parameter_list|(
name|SCI_ABSTRACT_ELEMENT_LIST_T
modifier|*
name|list_p
parameter_list|,
name|void
modifier|*
name|obj_p
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|alElement_p
init|=
operator|(
name|list_p
operator|)
operator|->
name|front_p
decl_stmt|;
while|while
condition|(
name|alElement_p
operator|!=
name|NULL
condition|)
block|{
comment|/* Check to see if we found the object for which we are searching. */
if|if
condition|(
name|alElement_p
operator|->
name|object_p
operator|==
operator|(
name|void
operator|*
operator|)
operator|(
name|obj_p
operator|)
condition|)
block|{
break|break;
block|}
name|alElement_p
operator|=
name|alElement_p
operator|->
name|next_p
expr_stmt|;
block|}
return|return
name|alElement_p
return|;
block|}
end_function

begin_comment
comment|/**  * This private method will free the supplied list element back to the pool  * of free list elements.  */
end_comment

begin_function
name|void
name|private_pool_free
parameter_list|(
name|SCI_ABSTRACT_ELEMENT_POOL_T
modifier|*
name|free_pool
parameter_list|,
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|alElement_p
parameter_list|)
block|{
comment|/* Push the list element back to the head to get better locality of */
comment|/* reference with the cache.                                        */
name|private_push_front
argument_list|(
operator|&
operator|(
name|free_pool
operator|)
operator|->
name|free_list
argument_list|,
operator|(
name|alElement_p
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This private method will allocate a list element from the pool of free  * list elements.  */
end_comment

begin_function
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|private_pool_allocate
parameter_list|(
name|SCI_ABSTRACT_ELEMENT_POOL_T
modifier|*
name|free_pool
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|alElement_p
decl_stmt|;
name|alElement_p
operator|=
name|private_pop_front
argument_list|(
operator|&
operator|(
name|free_pool
operator|)
operator|->
name|free_list
argument_list|)
expr_stmt|;
name|alElement_p
operator|->
name|next_p
operator|=
name|NULL
expr_stmt|;
name|alElement_p
operator|->
name|previous_p
operator|=
name|NULL
expr_stmt|;
name|alElement_p
operator|->
name|object_p
operator|=
name|NULL
expr_stmt|;
return|return
name|alElement_p
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// USE_ABSTRACT_LIST_FUNCTIONS
end_comment

end_unit

