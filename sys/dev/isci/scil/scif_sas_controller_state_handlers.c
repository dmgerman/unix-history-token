begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  *  * @brief This file contains all of the state handler routines for each  *        of the controller states defined by the SCI_BASE_CONTROLLER state  *        machine.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_port.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_io_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_logger.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_smp_remote_device.h>
end_include

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* P R I V A T E   M E T H O D S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method simply executes the reset operation by entering  *        the reset state and allowing the state to perform it's work.  *  * @param[in]  fw_controller This parameter specifies the SAS framework  *             controller for execute the reset.  *  * @return Indicate the status of the reset operation.  Was it successful?  * @retval SCI_SUCCESS This value is returned if it was successfully reset.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_execute_reset
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_CONTROLLER_RESET
operator|,
literal|"scif_sas_controller_execute_reset(0x%x) enter\n"
operator|,
name|fw_controller
operator|)
argument_list|)
expr_stmt|;
comment|//clean the timer to avoid timer leak.
name|scif_sas_controller_release_resource
argument_list|(
name|fw_controller
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_RESETTING
argument_list|)
expr_stmt|;
comment|// Retrieve the status for the operations performed during the entrance
comment|// to the resetting state were executing successfully.
name|status
operator|=
name|fw_controller
operator|->
name|operation_status
expr_stmt|;
name|fw_controller
operator|->
name|operation_status
operator|=
name|SCI_SUCCESS
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method checks that the memory descriptor list is valid  *        and hasn't been corrupted in some way by the user.  *  * @param[in] fw_controller This parameter specifies the framework  *            controller object for which to validation the MDL.  *  * @return This method returns a value indicating if the operation succeeded.  * @retval SCI_SUCCESS This value indicates that MDL is valid.  * @retval SCI_FAILURE_UNSUPPORTED_INFORMATION_FIELD This value indicates  *         that some portion of the memory descriptor list is invalid.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_validate_mdl
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|BOOL
name|is_mde_list_valid
decl_stmt|;
comment|// Currently there is only a single MDE in the list.
name|is_mde_list_valid
operator|=
name|sci_base_mde_is_valid
argument_list|(
operator|&
name|fw_controller
operator|->
name|mdes
index|[
name|SCIF_SAS_MDE_INTERNAL_IO
index|]
argument_list|,
literal|4
argument_list|,
name|fw_controller
operator|->
name|internal_request_entries
operator|*
name|scif_sas_internal_request_get_object_size
argument_list|()
argument_list|,
name|SCI_MDE_ATTRIBUTE_PHYSICALLY_CONTIGUOUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_mde_list_valid
operator|==
name|FALSE
condition|)
return|return
name|SCI_FAILURE_UNSUPPORTED_INFORMATION_FIELD
return|;
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method stops all the domains associated to this  *           controller.  *  * @param[in] fw_controller This parameter specifies the framework  *            controller object for whose remote devices are to be stopped.  *  * @return This method returns a value indicating if the operation succeeded.  * @retval SCI_SUCCESS This value indicates that all the devices are stopped.  * @retval SCI_FAILURE This value indicates certain failure during the process  *            of stopping remote devices.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_stop_domains
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|U8
name|index
decl_stmt|;
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"scif_sas_controller_stop_domains(0x%x) enter\n"
operator|,
name|fw_controller
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_DOMAINS
operator|&&
name|status
operator|==
name|SCI_SUCCESS
condition|;
name|index
operator|++
control|)
block|{
name|fw_domain
operator|=
operator|&
name|fw_controller
operator|->
name|domains
index|[
name|index
index|]
expr_stmt|;
comment|//Change this domain to STOPPING state. All the remote devices will be
comment|//stopped subsquentially.
if|if
condition|(
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_DOMAIN_STATE_READY
operator|||
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_DOMAIN_STATE_DISCOVERING
condition|)
block|{
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_DOMAIN_STATE_STOPPING
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method continue to stop the controller after clear affiliation  *        is done.  *  * @param[in] fw_controller This parameter specifies the framework  *            controller object to be stopped.  *  * @return This method returns a value indicating if the operation succeeded.  * @retval SCI_SUCCESS This value indicates the controller_stop succeeds.  * @retval SCI_FAILURE This value indicates certain failure during the process  *            of stopping controller.  */
end_comment

begin_function
name|SCI_STATUS
name|scif_sas_controller_continue_to_stop
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_SHUTDOWN
operator|,
literal|"scif_sas_controller_continue_to_stop (0x%x).\n"
operator|,
name|fw_controller
operator|)
argument_list|)
expr_stmt|;
comment|//stop all the domains and their remote devices.
name|status
operator|=
name|scif_sas_controller_stop_domains
argument_list|(
name|fw_controller
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// Attempt to stop the core controller.
name|status
operator|=
name|scic_controller_stop
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_SHUTDOWN
operator|,
literal|"Controller:0x%x Status:0x%x unable to stop controller.\n"
operator|,
name|fw_controller
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_FAILED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_SHUTDOWN
operator|,
literal|"Controller:0x%x Status:0x%x unable to stop domains.\n"
operator|,
name|fw_controller
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_FAILED
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* R E S E T   H A N D L E R S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method provides RESET state specific handling for  *        when a user attempts to initialize a controller.  This is a legal  *        state in which to attempt an initialize call.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform an initialize  *             operation.  *  * @return This method returns an indication of whether the initialize  *         operation succeeded.  * @retval SCI_SUCCESS This value when the initialization completes  *         successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_reset_initialize_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|U32
name|index
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_INITIALIZATION
operator|,
literal|"scif_sas_controller_reset_initialize_handler(0x%x) enter\n"
operator|,
name|controller
operator|)
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_INITIALIZING
argument_list|)
expr_stmt|;
name|scif_sas_controller_build_mdl
argument_list|(
name|fw_controller
argument_list|)
expr_stmt|;
comment|// Perform any domain object initialization that is necessary.
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SCI_MAX_DOMAINS
condition|;
name|index
operator|++
control|)
name|scif_sas_domain_initialize
argument_list|(
operator|&
name|fw_controller
operator|->
name|domains
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|scif_cb_lock_associate
argument_list|(
name|fw_controller
argument_list|,
operator|&
name|fw_controller
operator|->
name|hprq
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|// Attempt to initialize the core controller.
name|status
operator|=
name|scic_controller_initialize
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_INITIALIZED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
comment|// Initialization failed, Release resources and do not change state
name|scif_sas_controller_release_resource
argument_list|(
name|fw_controller
argument_list|)
expr_stmt|;
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_INITIALIZATION
operator|,
literal|"Controller:0x%x Status:0x%x unable to successfully initialize.\n"
operator|,
name|fw_controller
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* I N I T I A L I Z E D   H A N D L E R S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method provides INITIALIZED state specific handling for  *        when a user attempts to start a controller.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a start  *             operation.  * @param[in]  timeout This parameter specifies the timeout value (in  *             milliseconds) to be utilized for this operation.  *  * @return This method returns an indication of whether the start operation  *         succeeded.  * @retval SCI_SUCCESS This value is returned when the start operation  *         begins successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_initialized_start_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|U32
name|timeout
parameter_list|)
block|{
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|U16
name|index
init|=
literal|0
decl_stmt|;
name|SCI_PHYSICAL_MEMORY_DESCRIPTOR_T
name|internal_reqeust_mde
init|=
name|fw_controller
operator|->
name|mdes
index|[
name|SCIF_SAS_MDE_INTERNAL_IO
index|]
decl_stmt|;
name|void
modifier|*
name|internal_request_virtual_address
init|=
name|internal_reqeust_mde
operator|.
name|virtual_address
decl_stmt|;
name|POINTER_UINT
name|address
init|=
operator|(
name|POINTER_UINT
operator|)
name|internal_request_virtual_address
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_INITIALIZATION
operator|,
literal|"scif_sas_controller_initialized_start_handler(0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|timeout
operator|)
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_STARTING
argument_list|)
expr_stmt|;
name|status
operator|=
name|scif_sas_controller_validate_mdl
argument_list|(
name|fw_controller
argument_list|)
expr_stmt|;
comment|// initialization work for internal request path. It must be done before
comment|// starting domain.
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// fill in the sci_pool for internal requests.
name|sci_pool_initialize
argument_list|(
name|fw_controller
operator|->
name|internal_request_memory_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|fw_controller
operator|->
name|internal_request_entries
condition|;
name|index
operator|++
control|)
block|{
name|sci_pool_put
argument_list|(
name|fw_controller
operator|->
name|internal_request_memory_pool
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|address
operator|+=
name|scif_sas_internal_request_get_object_size
argument_list|()
expr_stmt|;
block|}
comment|// Using DPC for starting internal IOs, if yes, we need to intialize
comment|// DPC here.
name|scif_cb_start_internal_io_task_create
argument_list|(
name|fw_controller
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// Kick-start the domain state machines and, by association, the
comment|// core port's.
comment|// This will ensure we get valid port objects supplied with link up
comment|// messages.
for|for
control|(
name|index
operator|=
literal|0
init|;
operator|(
name|index
operator|<
name|SCI_MAX_DOMAINS
operator|)
operator|&&
operator|(
name|status
operator|==
name|SCI_SUCCESS
operator|)
condition|;
name|index
operator|++
control|)
block|{
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_controller
operator|->
name|domains
index|[
name|index
index|]
operator|.
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_DOMAIN_STATE_STARTING
argument_list|)
expr_stmt|;
name|status
operator|=
name|fw_controller
operator|->
name|domains
index|[
name|index
index|]
operator|.
name|operation
operator|.
name|status
expr_stmt|;
block|}
block|}
comment|// Validate that all the domain state machines began successfully.
if|if
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_INITIALIZATION
operator|,
literal|"Controller:0x%x Domain:0x%x Status:0x%x unable to start\n"
operator|,
name|fw_controller
operator|,
name|index
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|// Attempt to start the core controller.
name|status
operator|=
name|scic_controller_start
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_INITIALIZATION
operator|,
literal|"Controller:0x%x Status:0x%x unable to start controller.\n"
operator|,
name|fw_controller
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_FAILED
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* R E A D Y   H A N D L E R S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method provides READY state specific handling for  *        when a user attempts to stop a controller.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a stop  *             operation.  * @param[in]  timeout This parameter specifies the timeout value (in  *             milliseconds) to be utilized for this operation.  *  * @return This method returns an indication of whether the stop operation  *         succeeded.  * @retval SCI_SUCCESS This value is returned when the stop operation  *         begins successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_ready_stop_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|U32
name|timeout
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_INITIALIZATION
operator|,
literal|"scif_sas_controller_ready_stop_handler(0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|timeout
operator|)
argument_list|)
expr_stmt|;
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_controller
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_CONTROLLER_STATE_STOPPING
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_controller
operator|->
name|user_parameters
operator|.
name|sas
operator|.
name|clear_affiliation_during_controller_stop
condition|)
block|{
name|fw_controller
operator|->
name|current_domain_to_clear_affiliation
operator|=
literal|0
expr_stmt|;
comment|//clear affiliation first. After the last domain finishes clearing
comment|//affiliation, it will call back to controller to continue to stop.
name|scif_sas_controller_clear_affiliation
argument_list|(
name|fw_controller
argument_list|)
expr_stmt|;
block|}
else|else
name|scif_sas_controller_continue_to_stop
argument_list|(
name|fw_controller
argument_list|)
expr_stmt|;
comment|//Must return SUCCESS at this point.
return|return
name|SCI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides READY state specific handling for  *        when a user attempts to reset a controller.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a reset  *             operation.  *  * @return This method returns an indication of whether the reset operation  *         succeeded.  * @retval SCI_SUCCESS This value is returned when the reset operation  *         completes successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_ready_reset_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|)
block|{
return|return
name|scif_sas_controller_execute_reset
argument_list|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides READY state specific handling for  *        when a user attempts to start an IO request.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a start IO  *             operation.  * @param[in]  remote_device This parameter specifies the remote deivce  *             object on which the user is attempting to perform a start IO  *             operation.  * @param[in]  io_request This parameter specifies the IO request to be  *             started.  * @param[in]  io_tag This parameter specifies the optional allocated  *             IO tag.  Please reference scif_controller_start_io() for  *             more information.  *  * @return This method returns an indication of whether the start IO  *         operation succeeded.  * @retval SCI_SUCCESS This value is returned when the start IO operation  *         begins successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_ready_start_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
init|=
operator|(
name|SCIF_SAS_IO_REQUEST_T
operator|*
operator|)
name|io_request
decl_stmt|;
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
init|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_sas_controller_ready_start_io_handler(0x%x, 0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|io_request
operator|,
name|io_tag
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|fw_device
operator|->
name|domain
operator|->
name|state_handlers
operator|->
name|start_io_handler
argument_list|(
operator|&
name|fw_device
operator|->
name|domain
operator|->
name|parent
argument_list|,
name|remote_device
argument_list|,
name|io_request
argument_list|)
expr_stmt|;
comment|// Check to see that the other objects in the framework allowed
comment|// this IO to be started.
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// Ask the core to start processing for this IO request.
name|status
operator|=
operator|(
name|SCI_STATUS
operator|)
name|scic_controller_start_io
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
name|fw_device
operator|->
name|core_object
argument_list|,
name|fw_io
operator|->
name|parent
operator|.
name|core_object
argument_list|,
name|io_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// We were able to start the core request. As a result,
comment|// commit to starting the request for the framework by changing
comment|// the state of the IO request.
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|io_request
operator|->
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_STARTED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We were unable to start the core IO request. As a result,
comment|// back out the start operation for the framework.  It's easier to
comment|// back out the framework start operation then to backout the core
comment|// start IO operation.
name|fw_device
operator|->
name|domain
operator|->
name|state_handlers
operator|->
name|complete_io_handler
argument_list|(
operator|&
name|fw_device
operator|->
name|domain
operator|->
name|parent
argument_list|,
name|remote_device
argument_list|,
name|io_request
argument_list|)
expr_stmt|;
comment|// Invoke the IO completion handler.  For most IOs, this does nothing
comment|// since we are still in the constructed state.  For NCQ, this will
comment|// the return of the NCQ tag back to the remote device free pool.
name|fw_io
operator|->
name|parent
operator|.
name|state_handlers
operator|->
name|complete_handler
argument_list|(
name|io_request
argument_list|)
expr_stmt|;
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x IORequest:0x%x Status:0x%x core IO start failed\n"
operator|,
name|fw_controller
operator|,
name|fw_io
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x IORequest:0x%x Status:0x%x IO start failed\n"
operator|,
name|fw_controller
operator|,
name|fw_io
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides READY state specific handling for  *        when a user attempts to complete an IO request.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a complete IO  *             operation.  * @param[in]  remote_device This parameter specifies the remote deivce  *             object on which the user is attempting to perform a start IO  *             operation.  * @param[in]  io_request This parameter specifies the IO request to be  *             started.  *  * @return This method returns an indication of whether the complete IO  *         operation succeeded.  * @retval SCI_SUCCESS This value is returned when the complete IO operation  *         begins successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_ready_complete_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
init|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
decl_stmt|;
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
init|=
operator|(
name|SCIF_SAS_IO_REQUEST_T
operator|*
operator|)
name|io_request
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|SCI_STATUS
name|core_status
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_sas_controller_ready_complete_io_handler(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|io_request
operator|)
argument_list|)
expr_stmt|;
name|fw_io
operator|->
name|parent
operator|.
name|state_handlers
operator|->
name|destruct_handler
argument_list|(
operator|&
name|fw_io
operator|->
name|parent
operator|.
name|parent
argument_list|)
expr_stmt|;
name|status
operator|=
name|fw_device
operator|->
name|domain
operator|->
name|state_handlers
operator|->
name|complete_io_handler
argument_list|(
operator|&
name|fw_device
operator|->
name|domain
operator|->
name|parent
argument_list|,
name|remote_device
argument_list|,
name|io_request
argument_list|)
expr_stmt|;
comment|// Ask the core to finish processing for this IO request.
name|core_status
operator|=
name|scic_controller_complete_io
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
name|fw_device
operator|->
name|core_object
argument_list|,
name|fw_io
operator|->
name|parent
operator|.
name|core_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
name|status
operator|=
name|core_status
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x IORequest:0x%x Status:0x%x CoreStatus:0x%x "
literal|"failure to complete IO\n"
operator|,
name|fw_controller
operator|,
name|fw_io
operator|,
name|status
operator|,
name|core_status
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides READY state specific handling for  *        when a user attempts to complete a high priority IO request.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a complete IO  *             operation.  * @param[in]  remote_device This parameter specifies the remote deivce  *             object on which the user is attempting to perform a start IO  *             operation.  * @param[in]  io_request This parameter specifies the IO request to be  *             started.  *  * @return This method returns an indication of whether the complete IO  *         operation succeeded.  * @retval SCI_SUCCESS This value is returned when the complete IO operation  *         begins successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_ready_complete_high_priority_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
init|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
decl_stmt|;
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
init|=
operator|(
name|SCIF_SAS_IO_REQUEST_T
operator|*
operator|)
name|io_request
decl_stmt|;
name|SCI_IO_STATUS
name|core_completion_status
init|=
name|scic_request_get_sci_status
argument_list|(
name|fw_io
operator|->
name|parent
operator|.
name|core_object
argument_list|)
decl_stmt|;
name|U8
name|response_data
index|[
name|SCIF_SAS_RESPONSE_DATA_LENGTH
index|]
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|SCI_STATUS
name|core_status
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_sas_controller_ready_complete_high_priority_io_handler(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|io_request
operator|)
argument_list|)
expr_stmt|;
comment|// In high priority path, we ask the core to finish IO request before framework.
comment|// retrieve and save io response from core now.
name|memcpy
argument_list|(
name|response_data
argument_list|,
name|scic_io_request_get_response_iu_address
argument_list|(
name|fw_io
operator|->
name|parent
operator|.
name|core_object
argument_list|)
argument_list|,
name|SCIF_SAS_RESPONSE_DATA_LENGTH
argument_list|)
expr_stmt|;
name|core_status
operator|=
name|scic_controller_complete_io
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
name|fw_device
operator|->
name|core_object
argument_list|,
name|fw_io
operator|->
name|parent
operator|.
name|core_object
argument_list|)
expr_stmt|;
name|fw_io
operator|->
name|parent
operator|.
name|state_handlers
operator|->
name|destruct_handler
argument_list|(
operator|&
name|fw_io
operator|->
name|parent
operator|.
name|parent
argument_list|)
expr_stmt|;
name|status
operator|=
name|fw_device
operator|->
name|domain
operator|->
name|state_handlers
operator|->
name|complete_high_priority_io_handler
argument_list|(
operator|&
name|fw_device
operator|->
name|domain
operator|->
name|parent
argument_list|,
name|remote_device
argument_list|,
name|io_request
argument_list|,
operator|(
name|void
operator|*
operator|)
name|response_data
argument_list|,
name|core_completion_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
name|status
operator|=
name|core_status
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|//issue DPC to start next internal io in high prioriy queue.
if|if
condition|(
operator|!
name|sci_pool_empty
argument_list|(
name|fw_controller
operator|->
name|hprq
operator|.
name|pool
argument_list|)
condition|)
name|scif_cb_start_internal_io_task_schedule
argument_list|(
name|fw_controller
argument_list|,
name|scif_sas_controller_start_high_priority_io
argument_list|,
name|fw_controller
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x IORequest:0x%x Status:0x%x CoreStatus:0x%x "
literal|"failure to complete IO\n"
operator|,
name|fw_controller
operator|,
name|fw_io
operator|,
name|status
operator|,
name|core_status
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides READY state specific handling for  *        when a user attempts to continue an IO request.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a continue IO  *             operation.  * @param[in]  remote_device This parameter specifies the remote deivce  *             object on which the user is attempting to perform a start IO  *             operation.  * @param[in]  io_request This parameter specifies the IO request to be  *             started.  *  * @return This method returns an indication of whether the continue IO  *         operation succeeded.  * @retval SCI_SUCCESS This value is returned when the continue IO operation  *         begins successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_ready_continue_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_sas_controller_ready_continue_io_handler(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|io_request
operator|)
argument_list|)
expr_stmt|;
comment|/// @todo Function unimplemented.  fix return code handling.
return|return
name|SCI_FAILURE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides READY state specific handling for  *        when a user attempts to start a task request.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a start task  *             operation.  * @param[in]  remote_device This parameter specifies the remote deivce  *             object on which the user is attempting to perform a start  *             task operation.  * @param[in]  task_request This parameter specifies the task management  *             request to be started.  * @param[in]  io_tag This parameter specifies the optional allocated  *             IO tag.  Please reference scif_controller_start_task() for  *             more information.  *  * @return This method returns an indication of whether the start task  *         operation succeeded.  * @retval SCI_SUCCESS This value is returned when the start task operation  *         begins successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_ready_start_task_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|task_request
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
init|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
decl_stmt|;
name|SCIF_SAS_TASK_REQUEST_T
modifier|*
name|fw_task
init|=
operator|(
name|SCIF_SAS_TASK_REQUEST_T
operator|*
operator|)
name|task_request
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_TASK_MANAGEMENT
operator|,
literal|"scif_sas_controller_ready_start_task_handler(0x%x, 0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|task_request
operator|,
name|io_tag
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|fw_device
operator|->
name|domain
operator|->
name|state_handlers
operator|->
name|start_task_handler
argument_list|(
operator|&
name|fw_device
operator|->
name|domain
operator|->
name|parent
argument_list|,
name|remote_device
argument_list|,
name|task_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
if|if
condition|(
name|scif_sas_task_request_get_function
argument_list|(
name|fw_task
argument_list|)
operator|==
name|SCI_SAS_HARD_RESET
condition|)
block|{
comment|// Go off to special target reset path. Don't start task to core.
name|scif_sas_remote_device_target_reset
argument_list|(
name|fw_device
argument_list|,
operator|(
name|SCIF_SAS_REQUEST_T
operator|*
operator|)
name|fw_task
argument_list|)
expr_stmt|;
return|return
name|SCI_SUCCESS
return|;
block|}
comment|// Ask the core to start processing for this task request.
name|status
operator|=
operator|(
name|SCI_STATUS
operator|)
name|scic_controller_start_task
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
name|fw_device
operator|->
name|core_object
argument_list|,
name|fw_task
operator|->
name|parent
operator|.
name|core_object
argument_list|,
name|io_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// We were able to start the core request. As a result,
comment|// commit to starting the request for the framework by changing
comment|// the state of the task request.
name|fw_task
operator|->
name|parent
operator|.
name|state_handlers
operator|->
name|start_handler
argument_list|(
operator|&
name|fw_task
operator|->
name|parent
operator|.
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We were unable to start the core task request. As a result,
comment|// back out the start operation for the framework.  It's easier to
comment|// back out the framework start operation then to backout the core
comment|// start task operation.
name|fw_device
operator|->
name|domain
operator|->
name|state_handlers
operator|->
name|complete_task_handler
argument_list|(
operator|&
name|fw_device
operator|->
name|domain
operator|->
name|parent
argument_list|,
name|remote_device
argument_list|,
name|task_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x TaskRequest:0x%x Status:0x%x core start failed\n"
operator|,
name|fw_controller
operator|,
name|fw_task
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x TaskRequest:0x%x Status:0x%x Task start failed\n"
operator|,
name|fw_controller
operator|,
name|fw_task
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides READY state specific handling for  *        when a user attempts to complete a task request.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a complete task  *             operation.  * @param[in]  remote_device This parameter specifies the remote deivce  *             object on which the user is attempting to perform a start  *             task operation.  * @param[in]  task_request This parameter specifies the task management  *             request to be started.  *  * @return This method returns an indication of whether the complete task  *         operation succeeded.  * @retval SCI_SUCCESS This value is returned when the complete task operation  *         begins successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_ready_complete_task_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|task_request
parameter_list|)
block|{
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
init|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
decl_stmt|;
name|SCIF_SAS_TASK_REQUEST_T
modifier|*
name|fw_task
init|=
operator|(
name|SCIF_SAS_TASK_REQUEST_T
operator|*
operator|)
name|task_request
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|SCI_STATUS
name|core_status
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_TASK_MANAGEMENT
operator|,
literal|"scif_sas_controller_ready_complete_task_handler(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|task_request
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|fw_device
operator|->
name|domain
operator|->
name|state_handlers
operator|->
name|complete_task_handler
argument_list|(
operator|&
name|fw_device
operator|->
name|domain
operator|->
name|parent
argument_list|,
name|remote_device
argument_list|,
name|task_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|scif_sas_task_request_get_function
argument_list|(
name|fw_task
argument_list|)
operator|==
name|SCI_SAS_HARD_RESET
condition|)
block|{
comment|//No more things to do in the core, since this task is for Target Reset.
return|return
name|status
return|;
block|}
name|fw_task
operator|->
name|parent
operator|.
name|state_handlers
operator|->
name|destruct_handler
argument_list|(
operator|&
name|fw_task
operator|->
name|parent
operator|.
name|parent
argument_list|)
expr_stmt|;
comment|// Ask the core to finish processing for this task request.
name|core_status
operator|=
name|scic_controller_complete_task
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
name|fw_device
operator|->
name|core_object
argument_list|,
name|fw_task
operator|->
name|parent
operator|.
name|core_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
name|status
operator|=
name|core_status
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x TaskRequest:0x%x Status:0x%x CoreStatus:0x%x "
literal|"failed to complete\n"
operator|,
name|fw_controller
operator|,
name|fw_task
operator|,
name|status
operator|,
name|core_status
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides common handling for several states  *        when a user attempts to start an internal request.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a start IO  *             operation.  * @param[in]  remote_device This parameter specifies the remote deivce  *             object on which the user is attempting to perform a start IO  *             operation.  * @param[in]  io_request This parameter specifies the IO request to be  *             started.  * @param[in]  io_tag This parameter specifies the optional allocated  *             IO tag.  Please reference scif_controller_start_io() for  *             more information.  *  * @return This method returns an indication of whether the start IO  *         operation succeeded.  * @retval SCI_SUCCESS This value is returned when the start IO operation  *         begins successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_common_start_high_priority_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
init|=
operator|(
name|SCIF_SAS_IO_REQUEST_T
operator|*
operator|)
name|io_request
decl_stmt|;
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
init|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
decl_stmt|;
name|status
operator|=
name|fw_device
operator|->
name|domain
operator|->
name|state_handlers
operator|->
name|start_high_priority_io_handler
argument_list|(
operator|&
name|fw_device
operator|->
name|domain
operator|->
name|parent
argument_list|,
name|remote_device
argument_list|,
name|io_request
argument_list|)
expr_stmt|;
comment|// Check to see that the other objects in the framework allowed
comment|// this IO to be started.
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// Ask the core to start processing for this IO request.
name|status
operator|=
operator|(
name|SCI_STATUS
operator|)
name|scic_controller_start_io
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
name|fw_device
operator|->
name|core_object
argument_list|,
name|fw_io
operator|->
name|parent
operator|.
name|core_object
argument_list|,
name|io_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|// We were able to start the core request. As a result,
comment|// commit to starting the request for the framework by changing
comment|// the state of the IO request.
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|io_request
operator|->
name|state_machine
argument_list|,
name|SCI_BASE_REQUEST_STATE_STARTED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We were unable to start the core IO request. As a result,
comment|// back out the start operation for the framework.  It's easier to
comment|// back out the framework start operation then to backout the core
comment|// start IO operation.
name|fw_device
operator|->
name|domain
operator|->
name|state_handlers
operator|->
name|complete_io_handler
argument_list|(
operator|&
name|fw_device
operator|->
name|domain
operator|->
name|parent
argument_list|,
name|remote_device
argument_list|,
name|io_request
argument_list|)
expr_stmt|;
comment|// Invoke the IO completion handler.  For most IOs, this does nothing
comment|// since we are still in the constructed state.  For NCQ, this will
comment|// the return of the NCQ tag back to the remote device free pool.
name|fw_io
operator|->
name|parent
operator|.
name|state_handlers
operator|->
name|complete_handler
argument_list|(
name|io_request
argument_list|)
expr_stmt|;
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x IORequest:0x%x Status:0x%x core IO start failed\n"
operator|,
name|fw_controller
operator|,
name|fw_io
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x IORequest:0x%x Status:0x%x IO start failed\n"
operator|,
name|fw_controller
operator|,
name|fw_io
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
comment|// Invoke the IO completion handler.  For most IOs, this does nothing
comment|// since we are still in the constructed state.  For NCQ, this will
comment|// the return of the NCQ tag back to the remote device free pool.
name|fw_io
operator|->
name|parent
operator|.
name|state_handlers
operator|->
name|complete_handler
argument_list|(
name|io_request
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fw_io
operator|->
name|parent
operator|.
name|is_internal
operator|&&
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|SCIC_TRANSPORT_PROTOCOL
name|protocol
init|=
name|scic_io_request_get_protocol
argument_list|(
name|fw_io
operator|->
name|parent
operator|.
name|core_object
argument_list|)
decl_stmt|;
name|U8
name|retry_count
init|=
name|fw_io
operator|->
name|retry_count
decl_stmt|;
name|scif_sas_internal_io_request_destruct
argument_list|(
name|fw_device
operator|->
name|domain
operator|->
name|controller
argument_list|,
operator|(
name|SCIF_SAS_INTERNAL_IO_REQUEST_T
operator|*
operator|)
name|fw_io
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol
operator|==
name|SCIC_SMP_PROTOCOL
condition|)
block|{
if|if
condition|(
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
operator|!=
name|NULL
condition|)
block|{
comment|//destroy the smp_activity_timer
name|scif_cb_timer_destroy
argument_list|(
name|fw_controller
argument_list|,
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
argument_list|)
expr_stmt|;
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|smp_activity_timer
operator|=
name|NULL
expr_stmt|;
block|}
comment|//we should retry for finite times
if|if
condition|(
name|retry_count
operator|<
name|SCIF_SAS_IO_RETRY_LIMIT
condition|)
block|{
comment|//An internal smp request failed being started, most likely due to remote device
comment|//is not in ready state, for example, UPDATING_PORT_WIDTH state. In this case,
comment|//we should retry the IO.
name|scif_sas_smp_remote_device_retry_internal_io
argument_list|(
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|remote_device
argument_list|,
name|retry_count
argument_list|,
name|SMP_REQUEST_RETRY_WAIT_DURATION
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides READY state specific handling for  *        when a user attempts to start an internal request. If the high  *        priority IO is also internal, this method will schedule its timer.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a start IO  *             operation.  * @param[in]  remote_device This parameter specifies the remote deivce  *             object on which the user is attempting to perform a start IO  *             operation.  * @param[in]  io_request This parameter specifies the IO request to be  *             started.  * @param[in]  io_tag This parameter specifies the optional allocated  *             IO tag.  Please reference scif_controller_start_io() for  *             more information.  *  * @return This method returns an indication of whether the start IO  *         operation succeeded.  * @retval SCI_SUCCESS This value is returned when the start IO operation  *         begins successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_ready_start_high_priority_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCI_STATUS
name|status
decl_stmt|;
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|fw_io
init|=
operator|(
name|SCIF_SAS_IO_REQUEST_T
operator|*
operator|)
name|io_request
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_sas_controller_ready_start_high_priority_io_handler(0x%x, 0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|io_request
operator|,
name|io_tag
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|scif_sas_controller_common_start_high_priority_io_handler
argument_list|(
name|controller
argument_list|,
name|remote_device
argument_list|,
name|io_request
argument_list|,
name|io_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCI_SUCCESS
condition|)
block|{
comment|//External io could also be put in high priority queue. i.e. the
comment|//smp request for EA Target Reset.
if|if
condition|(
name|fw_io
operator|->
name|parent
operator|.
name|is_internal
condition|)
block|{
name|SCIF_SAS_INTERNAL_IO_REQUEST_T
modifier|*
name|fw_internal_io
init|=
operator|(
name|SCIF_SAS_INTERNAL_IO_REQUEST_T
operator|*
operator|)
name|fw_io
decl_stmt|;
comment|//start the timer for internal io
name|scif_cb_timer_start
argument_list|(
operator|(
name|SCI_CONTROLLER_HANDLE_T
operator|)
name|controller
argument_list|,
name|fw_internal_io
operator|->
name|internal_io_timer
argument_list|,
name|SCIF_SAS_INTERNAL_REQUEST_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//If failed to start, most likely the device or domain is not in
comment|//correct state, and the IO has been cleaned up in controller's start
comment|//high priority IO handler. We should just continue to start the next
comment|//IO in the HP queue.
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_controller_start_high_priority_io(0x%x, 0x%x), starting io failed\n"
operator|,
name|controller
operator|,
name|fw_io
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* S T O P P I N G   H A N D L E R S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method provides STOPPING state specific handling for  *        when a user attempts to start an internal request. Note that we don't  *        start the timer for internal IO during controller stopping state.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a start IO  *             operation.  * @param[in]  remote_device This parameter specifies the remote deivce  *             object on which the user is attempting to perform a start IO  *             operation.  * @param[in]  io_request This parameter specifies the IO request to be  *             started.  * @param[in]  io_tag This parameter specifies the optional allocated  *             IO tag.  Please reference scif_controller_start_io() for  *             more information.  *  * @return This method returns an indication of whether the start IO  *         operation succeeded.  * @retval SCI_SUCCESS This value is returned when the start IO operation  *         begins successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_stopping_start_high_priority_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator||
name|SCIF_LOG_OBJECT_IO_REQUEST
operator|,
literal|"scif_sas_controller_stopping_start_high_priority_io_handler(0x%x, 0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|remote_device
operator|,
name|io_request
operator|,
name|io_tag
operator|)
argument_list|)
expr_stmt|;
return|return
name|scif_sas_controller_common_start_high_priority_io_handler
argument_list|(
name|controller
argument_list|,
name|remote_device
argument_list|,
name|io_request
argument_list|,
name|io_tag
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* S T O P P E D   H A N D L E R S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method provides STOPPED state specific handling for  *        when a user attempts to reset a controller.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a reset  *             operation.  *  * @return This method returns an indication of whether the reset operation  *         succeeded.  * @retval SCI_SUCCESS This value is returned when the reset operation  *         completes successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_stopped_reset_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|)
block|{
return|return
name|scif_sas_controller_execute_reset
argument_list|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* F A I L E D   H A N D L E R S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method provides FAILED state specific handling for  *        when a user attempts to reset a controller.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a reset  *             operation.  *  * @return This method returns an indication of whether the reset operation  *         succeeded.  * @retval SCI_SUCCESS This value is returned when the reset operation  *         completes successfully.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_failed_reset_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|)
block|{
return|return
name|scif_sas_controller_execute_reset
argument_list|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* D E F A U L T   H A N D L E R S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method provides default handling (i.e. returns an error)  *        when a user attempts to start a controller and a start operation  *        is not allowed.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a start operation.  * @param[in]  timeout This parameter specifies the timeout value (in  *             milliseconds) to be utilized for this operation.  *  * @return This method returns an indication that start operations are not  *         allowed.  * @retval SCI_FAILURE_INVALID_STATE This value is always returned.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_default_start_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|U32
name|timeout
parameter_list|)
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x State:0x%x invalid state to start controller.\n"
operator|,
name|controller
operator|,
name|sci_base_state_machine_get_state
argument_list|(
operator|&
operator|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
operator|)
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_INVALID_STATE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides default handling (i.e. returns an error)  *        when a user attempts to stop a controller and a stop operation  *        is not allowed.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a stop operation.  * @param[in]  timeout This parameter specifies the timeout value (in  *             milliseconds) to be utilized for this operation.  *  * @return This method returns an indication that stop operations are not  *         allowed.  * @retval SCI_FAILURE_INVALID_STATE This value is always returned.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_default_stop_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|U32
name|timeout
parameter_list|)
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x State:0x%x invalid state to stop controller.\n"
operator|,
name|controller
operator|,
name|sci_base_state_machine_get_state
argument_list|(
operator|&
operator|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
operator|)
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_INVALID_STATE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides default handling (i.e. returns an error)  *        when a user attempts to reset a controller and a reset operation  *        is not allowed.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a reset operation.  *  * @return This method returns an indication that reset operations are not  *         allowed.  * @retval SCI_FAILURE_INVALID_STATE This value is always returned.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_default_reset_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|)
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x State:0x%x invalid state to reset controller.\n"
operator|,
name|controller
operator|,
name|sci_base_state_machine_get_state
argument_list|(
operator|&
operator|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
operator|)
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_INVALID_STATE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides default handling (i.e. returns an error)  *        when a user attempts to initialize a controller and an initialize  *        operation is not allowed.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform an initialize  *             operation.  *  * @return This method returns an indication that initialize operations  *         are not allowed.  * @retval SCI_FAILURE_INVALID_STATE This value is always returned.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_default_initialize_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|)
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x State:0x%x invalid state to initialize controller.\n"
operator|,
name|controller
operator|,
name|sci_base_state_machine_get_state
argument_list|(
operator|&
operator|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
operator|)
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_INVALID_STATE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides default handling (i.e. returns an error)  *        when a user attempts to start an IO on a controller and a start  *        IO operation is not allowed.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a start IO  *             operation.  * @param[in]  remote_device This parameter specifies the remote deivce  *             object on which the user is attempting to perform a start IO  *             operation.  * @param[in]  io_request This parameter specifies the IO request to be  *             started.  * @param[in]  io_tag This parameter specifies the optional allocated  *             IO tag.  Please reference scif_controller_start_io() for  *             more information.  *  * @return This method returns an indication that start IO operations  *         are not allowed.  * @retval SCI_FAILURE_INVALID_STATE This value is always returned.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_default_start_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x State:0x%x invalid state to start IO.\n"
operator|,
name|controller
operator|,
name|sci_base_state_machine_get_state
argument_list|(
operator|&
operator|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
operator|)
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_INVALID_STATE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides default handling (i.e. returns an error)  *        when a user attempts to complete an IO on a controller and a  *        complete IO operation is not allowed.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a complete IO  *             operation.  * @param[in]  remote_device This parameter specifies the remote deivce  *             object on which the user is attempting to perform a start IO  *             operation.  * @param[in]  io_request This parameter specifies the IO request to be  *             started.  *  * @return This method returns an indication that complete IO operations  *         are not allowed.  * @retval SCI_FAILURE_INVALID_STATE This value is always returned.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_default_complete_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|)
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x State:0x%x invalid state to complete IO.\n"
operator|,
name|controller
operator|,
name|sci_base_state_machine_get_state
argument_list|(
operator|&
operator|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
operator|)
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_INVALID_STATE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides default handling (i.e. returns an error)  *        when a user attempts to continue an IO on a controller and a  *        continue IO operation is not allowed.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a continue IO  *             operation.  * @param[in]  remote_device This parameter specifies the remote deivce  *             object on which the user is attempting to perform a start IO  *             operation.  * @param[in]  io_request This parameter specifies the IO request to be  *             started.  *  * @return This method returns an indication that continue IO operations  *         are not allowed.  * @retval SCI_FAILURE_INVALID_STATE This value is always returned.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_default_continue_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|)
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x State:0x%x invalid state to continue IO.\n"
operator|,
name|controller
operator|,
name|sci_base_state_machine_get_state
argument_list|(
operator|&
operator|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
operator|)
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_INVALID_STATE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides default handling (i.e. returns an error)  *        when a user attempts to start a task on a controller and a start  *        task operation is not allowed.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a start task  *             operation.  * @param[in]  remote_device This parameter specifies the remote deivce  *             object on which the user is attempting to perform a start  *             task operation.  * @param[in]  task_request This parameter specifies the task management  *             request to be started.  * @param[in]  io_tag This parameter specifies the optional allocated  *             IO tag.  Please reference scif_controller_start_task() for  *             more information.  *  * @return This method returns an indication that start task operations  *         are not allowed.  * @retval SCI_FAILURE_INVALID_STATE This value is always returned.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_default_start_task_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|task_request
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x State:0x%x invalid state to start task mgmt.\n"
operator|,
name|controller
operator|,
name|sci_base_state_machine_get_state
argument_list|(
operator|&
operator|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
operator|)
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_INVALID_STATE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method provides default handling (i.e. returns an error)  *        when a user attempts to complete a task on a controller and a  *        complete task operation is not allowed.  *  * @param[in]  controller This parameter specifies the controller object  *             on which the user is attempting to perform a complete task  *             operation.  * @param[in]  remote_device This parameter specifies the remote deivce  *             object on which the user is attempting to perform a start  *             task operation.  * @param[in]  task_request This parameter specifies the task management  *             request to be started.  *  * @return This method returns an indication that complete task operations  *         are not allowed.  * @retval SCI_FAILURE_INVALID_STATE This value is always returned.  */
end_comment

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_default_complete_task_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|task_request
parameter_list|)
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x State:0x%x invalid state to complete task mgmt.\n"
operator|,
name|controller
operator|,
name|sci_base_state_machine_get_state
argument_list|(
operator|&
operator|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
operator|)
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE_INVALID_STATE
return|;
block|}
end_function

begin_function
specifier|static
name|SCI_STATUS
name|scif_sas_controller_failed_state_start_io_handler
parameter_list|(
name|SCI_BASE_CONTROLLER_T
modifier|*
name|controller
parameter_list|,
name|SCI_BASE_REMOTE_DEVICE_T
modifier|*
name|remote_device
parameter_list|,
name|SCI_BASE_REQUEST_T
modifier|*
name|io_request
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_CONTROLLER
operator|,
literal|"Controller:0x%x State:0x%x invalid state to start IO.\n"
operator|,
name|controller
operator|,
name|sci_base_state_machine_get_state
argument_list|(
operator|&
operator|(
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|controller
operator|)
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|SCI_FAILURE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|scif_sas_controller_stopping_complete_io_handler
define|\
value|scif_sas_controller_ready_complete_io_handler
end_define

begin_define
define|#
directive|define
name|scif_sas_controller_stopping_complete_task_handler
define|\
value|scif_sas_controller_ready_complete_task_handler
end_define

begin_define
define|#
directive|define
name|scif_sas_controller_default_start_high_priority_io_handler
define|\
value|scif_sas_controller_default_start_io_handler
end_define

begin_define
define|#
directive|define
name|scif_sas_controller_default_complete_high_priority_io_handler
define|\
value|scif_sas_controller_default_complete_io_handler
end_define

begin_define
define|#
directive|define
name|scif_sas_controller_stopping_complete_high_priority_io_handler
define|\
value|scif_sas_controller_ready_complete_high_priority_io_handler
end_define

begin_decl_stmt
name|SCI_BASE_CONTROLLER_STATE_HANDLER_T
name|scif_sas_controller_state_handler_table
index|[
name|SCI_BASE_CONTROLLER_MAX_STATES
index|]
init|=
block|{
comment|// SCI_BASE_CONTROLLER_STATE_INITIAL
block|{
name|scif_sas_controller_default_start_handler
block|,
name|scif_sas_controller_default_stop_handler
block|,
name|scif_sas_controller_default_reset_handler
block|,
name|scif_sas_controller_default_initialize_handler
block|,
name|scif_sas_controller_default_start_io_handler
block|,
name|scif_sas_controller_default_start_high_priority_io_handler
block|,
name|scif_sas_controller_default_complete_io_handler
block|,
name|scif_sas_controller_default_complete_high_priority_io_handler
block|,
name|scif_sas_controller_default_continue_io_handler
block|,
name|scif_sas_controller_default_start_task_handler
block|,
name|scif_sas_controller_default_complete_task_handler
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_RESET
block|{
name|scif_sas_controller_default_start_handler
block|,
name|scif_sas_controller_default_stop_handler
block|,
name|scif_sas_controller_default_reset_handler
block|,
name|scif_sas_controller_reset_initialize_handler
block|,
name|scif_sas_controller_default_start_io_handler
block|,
name|scif_sas_controller_default_start_high_priority_io_handler
block|,
name|scif_sas_controller_default_complete_io_handler
block|,
name|scif_sas_controller_default_complete_high_priority_io_handler
block|,
name|scif_sas_controller_default_continue_io_handler
block|,
name|scif_sas_controller_default_start_task_handler
block|,
name|scif_sas_controller_default_complete_task_handler
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_INITIALIZING
block|{
name|scif_sas_controller_default_start_handler
block|,
name|scif_sas_controller_default_stop_handler
block|,
name|scif_sas_controller_default_reset_handler
block|,
name|scif_sas_controller_default_initialize_handler
block|,
name|scif_sas_controller_default_start_io_handler
block|,
name|scif_sas_controller_default_start_high_priority_io_handler
block|,
name|scif_sas_controller_default_complete_io_handler
block|,
name|scif_sas_controller_default_complete_high_priority_io_handler
block|,
name|scif_sas_controller_default_continue_io_handler
block|,
name|scif_sas_controller_default_start_task_handler
block|,
name|scif_sas_controller_default_complete_task_handler
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_INITIALIZED
block|{
name|scif_sas_controller_initialized_start_handler
block|,
name|scif_sas_controller_default_stop_handler
block|,
name|scif_sas_controller_default_reset_handler
block|,
name|scif_sas_controller_default_initialize_handler
block|,
name|scif_sas_controller_default_start_io_handler
block|,
name|scif_sas_controller_default_start_high_priority_io_handler
block|,
name|scif_sas_controller_default_complete_io_handler
block|,
name|scif_sas_controller_default_complete_high_priority_io_handler
block|,
name|scif_sas_controller_default_continue_io_handler
block|,
name|scif_sas_controller_default_start_task_handler
block|,
name|scif_sas_controller_default_complete_task_handler
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_STARTING
block|{
name|scif_sas_controller_default_start_handler
block|,
name|scif_sas_controller_default_stop_handler
block|,
name|scif_sas_controller_default_reset_handler
block|,
name|scif_sas_controller_default_initialize_handler
block|,
name|scif_sas_controller_default_start_io_handler
block|,
name|scif_sas_controller_default_start_high_priority_io_handler
block|,
name|scif_sas_controller_default_complete_io_handler
block|,
name|scif_sas_controller_default_complete_high_priority_io_handler
block|,
name|scif_sas_controller_default_continue_io_handler
block|,
name|scif_sas_controller_default_start_task_handler
block|,
name|scif_sas_controller_default_complete_task_handler
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_READY
block|{
name|scif_sas_controller_default_start_handler
block|,
name|scif_sas_controller_ready_stop_handler
block|,
name|scif_sas_controller_ready_reset_handler
block|,
name|scif_sas_controller_default_initialize_handler
block|,
name|scif_sas_controller_ready_start_io_handler
block|,
name|scif_sas_controller_ready_start_high_priority_io_handler
block|,
name|scif_sas_controller_ready_complete_io_handler
block|,
name|scif_sas_controller_ready_complete_high_priority_io_handler
block|,
name|scif_sas_controller_ready_continue_io_handler
block|,
name|scif_sas_controller_ready_start_task_handler
block|,
name|scif_sas_controller_ready_complete_task_handler
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_RESETTING
block|{
name|scif_sas_controller_default_start_handler
block|,
name|scif_sas_controller_default_stop_handler
block|,
name|scif_sas_controller_default_reset_handler
block|,
name|scif_sas_controller_default_initialize_handler
block|,
name|scif_sas_controller_default_start_io_handler
block|,
name|scif_sas_controller_default_start_high_priority_io_handler
block|,
name|scif_sas_controller_default_complete_io_handler
block|,
name|scif_sas_controller_default_complete_high_priority_io_handler
block|,
name|scif_sas_controller_default_continue_io_handler
block|,
name|scif_sas_controller_default_start_task_handler
block|,
name|scif_sas_controller_default_complete_task_handler
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_STOPPING
block|{
name|scif_sas_controller_default_start_handler
block|,
name|scif_sas_controller_default_stop_handler
block|,
name|scif_sas_controller_default_reset_handler
block|,
name|scif_sas_controller_default_initialize_handler
block|,
name|scif_sas_controller_default_start_io_handler
block|,
name|scif_sas_controller_stopping_start_high_priority_io_handler
block|,
name|scif_sas_controller_stopping_complete_io_handler
block|,
name|scif_sas_controller_stopping_complete_high_priority_io_handler
block|,
name|scif_sas_controller_default_continue_io_handler
block|,
name|scif_sas_controller_default_start_task_handler
block|,
comment|/**@todo Allow in core?*/
name|scif_sas_controller_stopping_complete_task_handler
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_STOPPED
block|{
name|scif_sas_controller_default_start_handler
block|,
name|scif_sas_controller_default_stop_handler
block|,
name|scif_sas_controller_stopped_reset_handler
block|,
name|scif_sas_controller_default_initialize_handler
block|,
name|scif_sas_controller_default_start_io_handler
block|,
name|scif_sas_controller_default_start_high_priority_io_handler
block|,
name|scif_sas_controller_default_complete_io_handler
block|,
name|scif_sas_controller_default_complete_high_priority_io_handler
block|,
name|scif_sas_controller_default_continue_io_handler
block|,
name|scif_sas_controller_default_start_task_handler
block|,
name|scif_sas_controller_default_complete_task_handler
block|}
block|,
comment|// SCI_BASE_CONTROLLER_STATE_FAILED
block|{
name|scif_sas_controller_default_start_handler
block|,
name|scif_sas_controller_default_stop_handler
block|,
name|scif_sas_controller_failed_reset_handler
block|,
name|scif_sas_controller_default_initialize_handler
block|,
name|scif_sas_controller_failed_state_start_io_handler
block|,
name|scif_sas_controller_failed_state_start_io_handler
block|,
name|scif_sas_controller_default_complete_io_handler
block|,
name|scif_sas_controller_default_complete_high_priority_io_handler
block|,
name|scif_sas_controller_default_continue_io_handler
block|,
name|scif_sas_controller_default_start_task_handler
block|,
name|scif_sas_controller_default_complete_task_handler
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

