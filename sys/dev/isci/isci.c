begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/isci/isci.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<dev/led/led.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_logger.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_library.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_sgpio.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_user_callback.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_library.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_logger.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_user_callback.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ISCI
argument_list|,
literal|"isci"
argument_list|,
literal|"isci driver memory allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|isci_softc
modifier|*
name|g_isci
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|g_isci_debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|isci_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isci_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isci_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|isci_initialize
parameter_list|(
name|struct
name|isci_softc
modifier|*
name|isci
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|isci_allocate_dma_buffer_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|seg
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|devclass_t
name|isci_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|isci_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|isci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|isci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|isci_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|isci_pci_driver
init|=
block|{
literal|"isci"
block|,
name|isci_pci_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|isci_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|isci
argument_list|,
name|pci
argument_list|,
name|isci_pci_driver
argument_list|,
name|isci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
struct|struct
name|_pcsid
block|{
name|u_int32_t
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|pci_ids
index|[]
init|=
block|{
block|{
literal|0x1d608086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller"
block|}
block|,
block|{
literal|0x1d618086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller (SATA mode)"
block|}
block|,
block|{
literal|0x1d628086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller"
block|}
block|,
block|{
literal|0x1d638086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller"
block|}
block|,
block|{
literal|0x1d648086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller"
block|}
block|,
block|{
literal|0x1d658086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller"
block|}
block|,
block|{
literal|0x1d668086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller"
block|}
block|,
block|{
literal|0x1d678086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller"
block|}
block|,
block|{
literal|0x1d688086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller"
block|}
block|,
block|{
literal|0x1d698086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller"
block|}
block|,
block|{
literal|0x1d6a8086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller (SATA mode)"
block|}
block|,
block|{
literal|0x1d6b8086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller (SATA mode)"
block|}
block|,
block|{
literal|0x1d6c8086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller"
block|}
block|,
block|{
literal|0x1d6d8086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller"
block|}
block|,
block|{
literal|0x1d6e8086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller"
block|}
block|,
block|{
literal|0x1d6f8086
block|,
literal|"Intel(R) C600 Series Chipset SAS Controller (SATA mode)"
block|}
block|,
block|{
literal|0x00000000
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|isci_probe
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|u_int32_t
name|type
init|=
name|pci_get_devid
argument_list|(
name|device
argument_list|)
decl_stmt|;
name|struct
name|_pcsid
modifier|*
name|ep
init|=
name|pci_ids
decl_stmt|;
while|while
condition|(
name|ep
operator|->
name|type
operator|&&
name|ep
operator|->
name|type
operator|!=
name|type
condition|)
operator|++
name|ep
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|desc
condition|)
block|{
name|device_set_desc
argument_list|(
name|device
argument_list|,
name|ep
operator|->
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isci_allocate_pci_memory
parameter_list|(
name|struct
name|isci_softc
modifier|*
name|isci
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ISCI_NUM_PCI_BARS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ISCI_PCI_BAR
modifier|*
name|pci_bar
init|=
operator|&
name|isci
operator|->
name|pci_bar
index|[
name|i
index|]
decl_stmt|;
name|pci_bar
operator|->
name|resource_id
operator|=
name|PCIR_BAR
argument_list|(
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pci_bar
operator|->
name|resource
operator|=
name|bus_alloc_resource
argument_list|(
name|isci
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|pci_bar
operator|->
name|resource_id
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_bar
operator|->
name|resource
operator|==
name|NULL
condition|)
name|isci_log_message
argument_list|(
literal|0
argument_list|,
literal|"ISCI"
argument_list|,
literal|"unable to allocate pci resource\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|pci_bar
operator|->
name|bus_tag
operator|=
name|rman_get_bustag
argument_list|(
name|pci_bar
operator|->
name|resource
argument_list|)
expr_stmt|;
name|pci_bar
operator|->
name|bus_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|pci_bar
operator|->
name|resource
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isci_attach
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|isci_softc
modifier|*
name|isci
init|=
name|DEVICE2SOFTC
argument_list|(
name|device
argument_list|)
decl_stmt|;
name|g_isci
operator|=
name|isci
expr_stmt|;
name|isci
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|isci_allocate_pci_memory
argument_list|(
name|isci
argument_list|)
expr_stmt|;
name|error
operator|=
name|isci_initialize
argument_list|(
name|isci
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|isci_detach
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|isci_interrupt_setup
argument_list|(
name|isci
argument_list|)
expr_stmt|;
name|isci_sysctl_initialize
argument_list|(
name|isci
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isci_detach
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|struct
name|isci_softc
modifier|*
name|isci
init|=
name|DEVICE2SOFTC
argument_list|(
name|device
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|phy
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isci
operator|->
name|controller_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ISCI_CONTROLLER
modifier|*
name|controller
init|=
operator|&
name|isci
operator|->
name|controllers
index|[
name|i
index|]
decl_stmt|;
name|SCI_STATUS
name|status
decl_stmt|;
name|void
modifier|*
name|unmap_buffer
decl_stmt|;
if|if
condition|(
name|controller
operator|->
name|scif_controller_handle
operator|!=
name|NULL
condition|)
block|{
name|scic_controller_disable_interrupts
argument_list|(
name|scif_controller_get_scic_handle
argument_list|(
name|controller
operator|->
name|scif_controller_handle
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|controller
operator|->
name|lock
argument_list|)
expr_stmt|;
name|status
operator|=
name|scif_controller_stop
argument_list|(
name|controller
operator|->
name|scif_controller_handle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|controller
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|controller
operator|->
name|is_started
operator|==
name|TRUE
condition|)
block|{
comment|/* Now poll for interrupts until the controller stop complete 				 *  callback is received. 				 */
name|mtx_lock
argument_list|(
operator|&
name|controller
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isci_interrupt_poll_handler
argument_list|(
name|controller
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|controller
operator|->
name|lock
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"isci"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|controller
operator|->
name|sim
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|controller
operator|->
name|lock
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|controller
operator|->
name|path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|controller
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|controller
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|controller
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|controller
operator|->
name|timer_memory
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|controller
operator|->
name|timer_memory
argument_list|,
name|M_ISCI
argument_list|)
expr_stmt|;
if|if
condition|(
name|controller
operator|->
name|remote_device_memory
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|controller
operator|->
name|remote_device_memory
argument_list|,
name|M_ISCI
argument_list|)
expr_stmt|;
for|for
control|(
name|phy
operator|=
literal|0
init|;
name|phy
operator|<
name|SCI_MAX_PHYS
condition|;
name|phy
operator|++
control|)
block|{
if|if
condition|(
name|controller
operator|->
name|phys
index|[
name|phy
index|]
operator|.
name|cdev_fault
condition|)
name|led_destroy
argument_list|(
name|controller
operator|->
name|phys
index|[
name|phy
index|]
operator|.
name|cdev_fault
argument_list|)
expr_stmt|;
if|if
condition|(
name|controller
operator|->
name|phys
index|[
name|phy
index|]
operator|.
name|cdev_locate
condition|)
name|led_destroy
argument_list|(
name|controller
operator|->
name|phys
index|[
name|phy
index|]
operator|.
name|cdev_locate
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|sci_pool_get
argument_list|(
name|controller
operator|->
name|unmap_buffer_pool
argument_list|,
name|unmap_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmap_buffer
operator|==
name|NULL
condition|)
break|break;
name|contigfree
argument_list|(
name|unmap_buffer
argument_list|,
name|PAGE_SIZE
argument_list|,
name|M_ISCI
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The SCIF controllers have been stopped, so we can now 	 *  free the SCI library memory. 	 */
if|if
condition|(
name|isci
operator|->
name|sci_library_memory
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|isci
operator|->
name|sci_library_memory
argument_list|,
name|M_ISCI
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ISCI_NUM_PCI_BARS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ISCI_PCI_BAR
modifier|*
name|pci_bar
init|=
operator|&
name|isci
operator|->
name|pci_bar
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pci_bar
operator|->
name|resource
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|pci_bar
operator|->
name|resource_id
argument_list|,
name|pci_bar
operator|->
name|resource
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isci
operator|->
name|num_interrupts
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ISCI_INTERRUPT_INFO
modifier|*
name|interrupt_info
decl_stmt|;
name|interrupt_info
operator|=
operator|&
name|isci
operator|->
name|interrupt_info
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|interrupt_info
operator|->
name|tag
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|device
argument_list|,
name|interrupt_info
operator|->
name|res
argument_list|,
name|interrupt_info
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupt_info
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|interrupt_info
operator|->
name|res
argument_list|)
argument_list|,
name|interrupt_info
operator|->
name|res
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|device
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|isci_initialize
parameter_list|(
name|struct
name|isci_softc
modifier|*
name|isci
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint32_t
name|status
init|=
literal|0
decl_stmt|;
name|uint32_t
name|library_object_size
decl_stmt|;
name|uint32_t
name|verbosity_mask
decl_stmt|;
name|uint32_t
name|scic_log_object_mask
decl_stmt|;
name|uint32_t
name|scif_log_object_mask
decl_stmt|;
name|uint8_t
modifier|*
name|header_buffer
decl_stmt|;
name|library_object_size
operator|=
name|scif_library_get_object_size
argument_list|(
name|SCI_MAX_CONTROLLERS
argument_list|)
expr_stmt|;
name|isci
operator|->
name|sci_library_memory
operator|=
name|malloc
argument_list|(
name|library_object_size
argument_list|,
name|M_ISCI
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|isci
operator|->
name|sci_library_handle
operator|=
name|scif_library_construct
argument_list|(
name|isci
operator|->
name|sci_library_memory
argument_list|,
name|SCI_MAX_CONTROLLERS
argument_list|)
expr_stmt|;
name|sci_object_set_association
argument_list|(
name|isci
operator|->
name|sci_library_handle
argument_list|,
operator|(
name|void
operator|*
operator|)
name|isci
argument_list|)
expr_stmt|;
name|verbosity_mask
operator|=
operator|(
literal|1
operator|<<
name|SCI_LOG_VERBOSITY_ERROR
operator|)
operator||
operator|(
literal|1
operator|<<
name|SCI_LOG_VERBOSITY_WARNING
operator|)
operator||
operator|(
literal|1
operator|<<
name|SCI_LOG_VERBOSITY_INFO
operator|)
operator||
operator|(
literal|1
operator|<<
name|SCI_LOG_VERBOSITY_TRACE
operator|)
expr_stmt|;
name|scic_log_object_mask
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|scic_log_object_mask
operator|&=
operator|~
name|SCIC_LOG_OBJECT_COMPLETION_QUEUE
expr_stmt|;
name|scic_log_object_mask
operator|&=
operator|~
name|SCIC_LOG_OBJECT_SSP_IO_REQUEST
expr_stmt|;
name|scic_log_object_mask
operator|&=
operator|~
name|SCIC_LOG_OBJECT_STP_IO_REQUEST
expr_stmt|;
name|scic_log_object_mask
operator|&=
operator|~
name|SCIC_LOG_OBJECT_SMP_IO_REQUEST
expr_stmt|;
name|scic_log_object_mask
operator|&=
operator|~
name|SCIC_LOG_OBJECT_CONTROLLER
expr_stmt|;
name|scif_log_object_mask
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|scif_log_object_mask
operator|&=
operator|~
name|SCIF_LOG_OBJECT_CONTROLLER
expr_stmt|;
name|scif_log_object_mask
operator|&=
operator|~
name|SCIF_LOG_OBJECT_IO_REQUEST
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.isci.debug_level"
argument_list|,
operator|&
name|g_isci_debug_level
argument_list|)
expr_stmt|;
name|sci_logger_enable
argument_list|(
name|sci_object_get_logger
argument_list|(
name|isci
operator|->
name|sci_library_handle
argument_list|)
argument_list|,
name|scif_log_object_mask
argument_list|,
name|verbosity_mask
argument_list|)
expr_stmt|;
name|sci_logger_enable
argument_list|(
name|sci_object_get_logger
argument_list|(
name|scif_library_get_scic_handle
argument_list|(
name|isci
operator|->
name|sci_library_handle
argument_list|)
argument_list|)
argument_list|,
name|scic_log_object_mask
argument_list|,
name|verbosity_mask
argument_list|)
expr_stmt|;
name|header_buffer
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|isci
operator|->
name|pci_common_header
expr_stmt|;
for|for
control|(
name|uint8_t
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|isci
operator|->
name|pci_common_header
argument_list|)
condition|;
name|i
operator|++
control|)
name|header_buffer
index|[
name|i
index|]
operator|=
name|pci_read_config
argument_list|(
name|isci
operator|->
name|device
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scic_library_set_pci_info
argument_list|(
name|scif_library_get_scic_handle
argument_list|(
name|isci
operator|->
name|sci_library_handle
argument_list|)
argument_list|,
operator|&
name|isci
operator|->
name|pci_common_header
argument_list|)
expr_stmt|;
name|isci
operator|->
name|oem_parameters_found
operator|=
name|FALSE
expr_stmt|;
name|isci_get_oem_parameters
argument_list|(
name|isci
argument_list|)
expr_stmt|;
comment|/* trigger interrupt if 32 completions occur before timeout expires */
name|isci
operator|->
name|coalesce_number
operator|=
literal|32
expr_stmt|;
comment|/* trigger interrupt if 2 microseconds elapse after a completion occurs, 	 *  regardless if "coalesce_number" completions have occurred 	 */
name|isci
operator|->
name|coalesce_timeout
operator|=
literal|2
expr_stmt|;
name|isci
operator|->
name|controller_count
operator|=
name|scic_library_get_pci_device_controller_count
argument_list|(
name|scif_library_get_scic_handle
argument_list|(
name|isci
operator|->
name|sci_library_handle
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|isci
operator|->
name|controller_count
condition|;
name|index
operator|++
control|)
block|{
name|struct
name|ISCI_CONTROLLER
modifier|*
name|controller
init|=
operator|&
name|isci
operator|->
name|controllers
index|[
name|index
index|]
decl_stmt|;
name|SCI_CONTROLLER_HANDLE_T
name|scif_controller_handle
decl_stmt|;
name|controller
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|isci_controller_construct
argument_list|(
name|controller
argument_list|,
name|isci
argument_list|)
expr_stmt|;
name|scif_controller_handle
operator|=
name|controller
operator|->
name|scif_controller_handle
expr_stmt|;
name|status
operator|=
name|isci_controller_initialize
argument_list|(
name|controller
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SCI_SUCCESS
condition|)
block|{
name|isci_log_message
argument_list|(
literal|0
argument_list|,
literal|"ISCI"
argument_list|,
literal|"isci_controller_initialize FAILED: %x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|error
operator|=
name|isci_controller_allocate_memory
argument_list|(
name|controller
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|scif_controller_set_interrupt_coalescence
argument_list|(
name|scif_controller_handle
argument_list|,
name|isci
operator|->
name|coalesce_number
argument_list|,
name|isci
operator|->
name|coalesce_timeout
argument_list|)
expr_stmt|;
block|}
comment|/* FreeBSD provides us a hook to ensure we get a chance to start 	 *  our controllers and complete initial domain discovery before 	 *  it searches for the boot device.  Once we're done, we'll 	 *  disestablish the hook, signaling the kernel that is can proceed 	 *  with the boot process. 	 */
name|isci
operator|->
name|config_hook
operator|.
name|ich_func
operator|=
operator|&
name|isci_controller_start
expr_stmt|;
name|isci
operator|->
name|config_hook
operator|.
name|ich_arg
operator|=
operator|&
name|isci
operator|->
name|controllers
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|isci
operator|->
name|config_hook
argument_list|)
operator|!=
literal|0
condition|)
name|isci_log_message
argument_list|(
literal|0
argument_list|,
literal|"ISCI"
argument_list|,
literal|"config_intrhook_establish failed!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isci_allocate_dma_buffer_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|seg
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ISCI_MEMORY
modifier|*
name|memory
init|=
operator|(
expr|struct
name|ISCI_MEMORY
operator|*
operator|)
name|arg
decl_stmt|;
name|memory
operator|->
name|error
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|nseg
operator|!=
literal|1
operator|||
name|error
operator|!=
literal|0
condition|)
name|isci_log_message
argument_list|(
literal|0
argument_list|,
literal|"ISCI"
argument_list|,
literal|"Failed to allocate physically contiguous memory!\n"
argument_list|)
expr_stmt|;
else|else
name|memory
operator|->
name|physical_address
operator|=
name|seg
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
name|int
name|isci_allocate_dma_buffer
parameter_list|(
name|device_t
name|device
parameter_list|,
name|struct
name|ISCI_MEMORY
modifier|*
name|memory
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|status
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|device
argument_list|)
argument_list|,
literal|0x40
comment|/* cacheline alignment */
argument_list|,
literal|0x0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|memory
operator|->
name|size
argument_list|,
literal|0x1
comment|/* we want physically contiguous */
argument_list|,
name|memory
operator|->
name|size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|memory
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ENOMEM
condition|)
block|{
name|isci_log_message
argument_list|(
literal|0
argument_list|,
literal|"ISCI"
argument_list|,
literal|"bus_dma_tag_create failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|status
operator|=
name|bus_dmamem_alloc
argument_list|(
name|memory
operator|->
name|dma_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|memory
operator|->
name|virtual_address
argument_list|,
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|memory
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ENOMEM
condition|)
block|{
name|isci_log_message
argument_list|(
literal|0
argument_list|,
literal|"ISCI"
argument_list|,
literal|"bus_dmamem_alloc failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|status
operator|=
name|bus_dmamap_load
argument_list|(
name|memory
operator|->
name|dma_tag
argument_list|,
name|memory
operator|->
name|dma_map
argument_list|,
operator|(
name|void
operator|*
operator|)
name|memory
operator|->
name|virtual_address
argument_list|,
name|memory
operator|->
name|size
argument_list|,
name|isci_allocate_dma_buffer_callback
argument_list|,
name|memory
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EINVAL
condition|)
block|{
name|isci_log_message
argument_list|(
literal|0
argument_list|,
literal|"ISCI"
argument_list|,
literal|"bus_dmamap_load failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to associate the supplied  *        lock with an operating environment specific locking construct.  *  * @param[in]  controller This parameter specifies the controller with  *             which this lock is to be associated.  * @param[in]  lock This parameter specifies the lock for which the  *             user should associate an operating environment specific  *             locking object.  *  * @see The SCI_LOCK_LEVEL enumeration for more information.  *  * @return none.  */
end_comment

begin_function
name|void
name|scif_cb_lock_associate
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_LOCK_HANDLE_T
name|lock
parameter_list|)
block|{  }
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to de-associate the supplied  *        lock with an operating environment specific locking construct.  *  * @param[in]  controller This parameter specifies the controller with  *             which this lock is to be de-associated.  * @param[in]  lock This parameter specifies the lock for which the  *             user should de-associate an operating environment specific  *             locking object.  *  * @see The SCI_LOCK_LEVEL enumeration for more information.  *  * @return none.  */
end_comment

begin_function
name|void
name|scif_cb_lock_disassociate
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_LOCK_HANDLE_T
name|lock
parameter_list|)
block|{  }
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to acquire/get the lock.  *        This method should pend until the lock has been acquired.  *  * @param[in]  controller This parameter specifies the controller with  *             which this lock is associated.  * @param[in]  lock This parameter specifies the lock to be acquired.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_cb_lock_acquire
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_LOCK_HANDLE_T
name|lock
parameter_list|)
block|{  }
end_function

begin_comment
comment|/**  * @brief This callback method asks the user to release a lock.  *  * @param[in]  controller This parameter specifies the controller with  *             which this lock is associated.  * @param[in]  lock This parameter specifies the lock to be released.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_cb_lock_release
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_LOCK_HANDLE_T
name|lock
parameter_list|)
block|{ }
end_function

begin_comment
comment|/**  * @brief This callback method creates an OS specific deferred task  *        for internal usage. The handler to deferred task is stored by OS  *        driver.  *  * @param[in] controller This parameter specifies the controller object  *            with which this callback is associated.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_cb_start_internal_io_task_create
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|)
block|{  }
end_function

begin_comment
comment|/**  * @brief This callback method schedules a OS specific deferred task.  *  * @param[in] controller This parameter specifies the controller  *            object with which this callback is associated.  * @param[in] start_internal_io_task_routine This parameter specifies the  *            sci start_internal_io routine.  * @param[in] context This parameter specifies a handle to a parameter  *            that will be passed into the "start_internal_io_task_routine"  *            when it is invoked.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_cb_start_internal_io_task_schedule
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|scif_controller
parameter_list|,
name|FUNCPTR
name|start_internal_io_task_routine
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
comment|/** @todo Use FreeBSD tasklet to defer this routine to a later time, 	 *  rather than calling the routine inline. 	 */
name|SCI_START_INTERNAL_IO_ROUTINE
name|sci_start_internal_io_routine
init|=
operator|(
name|SCI_START_INTERNAL_IO_ROUTINE
operator|)
name|start_internal_io_task_routine
decl_stmt|;
name|sci_start_internal_io_routine
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief In this method the user must write to PCI memory via access.  *        This method is used for access to memory space and IO space.  *  * @param[in]  controller The controller for which to read a DWORD.  * @param[in]  address This parameter depicts the address into  *             which to write.  * @param[out] write_value This parameter depicts the value being written  *             into the PCI memory location.  *  * @todo These PCI memory access calls likely needs to be optimized into macros?  */
end_comment

begin_function
name|void
name|scic_cb_pci_write_dword
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|scic_controller
parameter_list|,
name|void
modifier|*
name|address
parameter_list|,
name|uint32_t
name|write_value
parameter_list|)
block|{
name|SCI_CONTROLLER_HANDLE_T
name|scif_controller
init|=
operator|(
name|SCI_CONTROLLER_HANDLE_T
operator|)
name|sci_object_get_association
argument_list|(
name|scic_controller
argument_list|)
decl_stmt|;
name|struct
name|ISCI_CONTROLLER
modifier|*
name|isci_controller
init|=
operator|(
expr|struct
name|ISCI_CONTROLLER
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|scif_controller
argument_list|)
decl_stmt|;
name|struct
name|isci_softc
modifier|*
name|isci
init|=
name|isci_controller
operator|->
name|isci
decl_stmt|;
name|uint32_t
name|bar
init|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
operator|(
name|POINTER_UINT
operator|)
name|address
operator|&
literal|0xF0000000
operator|)
operator|>>
literal|28
argument_list|)
decl_stmt|;
name|bus_size_t
name|offset
init|=
call|(
name|bus_size_t
call|)
argument_list|(
operator|(
name|POINTER_UINT
operator|)
name|address
operator|&
literal|0x0FFFFFFF
argument_list|)
decl_stmt|;
name|bus_space_write_4
argument_list|(
name|isci
operator|->
name|pci_bar
index|[
name|bar
index|]
operator|.
name|bus_tag
argument_list|,
name|isci
operator|->
name|pci_bar
index|[
name|bar
index|]
operator|.
name|bus_handle
argument_list|,
name|offset
argument_list|,
name|write_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief In this method the user must read from PCI memory via access.  *        This method is used for access to memory space and IO space.  *  * @param[in]  controller The controller for which to read a DWORD.  * @param[in]  address This parameter depicts the address from  *             which to read.  *  * @return The value being returned from the PCI memory location.  *  * @todo This PCI memory access calls likely need to be optimized into macro?  */
end_comment

begin_function
name|uint32_t
name|scic_cb_pci_read_dword
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|scic_controller
parameter_list|,
name|void
modifier|*
name|address
parameter_list|)
block|{
name|SCI_CONTROLLER_HANDLE_T
name|scif_controller
init|=
operator|(
name|SCI_CONTROLLER_HANDLE_T
operator|)
name|sci_object_get_association
argument_list|(
name|scic_controller
argument_list|)
decl_stmt|;
name|struct
name|ISCI_CONTROLLER
modifier|*
name|isci_controller
init|=
operator|(
expr|struct
name|ISCI_CONTROLLER
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|scif_controller
argument_list|)
decl_stmt|;
name|struct
name|isci_softc
modifier|*
name|isci
init|=
name|isci_controller
operator|->
name|isci
decl_stmt|;
name|uint32_t
name|bar
init|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
operator|(
name|POINTER_UINT
operator|)
name|address
operator|&
literal|0xF0000000
operator|)
operator|>>
literal|28
argument_list|)
decl_stmt|;
name|bus_size_t
name|offset
init|=
call|(
name|bus_size_t
call|)
argument_list|(
operator|(
name|POINTER_UINT
operator|)
name|address
operator|&
literal|0x0FFFFFFF
argument_list|)
decl_stmt|;
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|isci
operator|->
name|pci_bar
index|[
name|bar
index|]
operator|.
name|bus_tag
argument_list|,
name|isci
operator|->
name|pci_bar
index|[
name|bar
index|]
operator|.
name|bus_handle
argument_list|,
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method is called when the core requires the OS driver  *        to stall execution.  This method is utilized during initialization  *        or non-performance paths only.  *  * @param[in]  microseconds This parameter specifies the number of  *             microseconds for which to stall.  The operating system driver  *             is allowed to round this value up where necessary.  *  * @return none.  */
end_comment

begin_function
name|void
name|scic_cb_stall_execution
parameter_list|(
name|uint32_t
name|microseconds
parameter_list|)
block|{
name|DELAY
argument_list|(
name|microseconds
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief In this method the user must return the base address register (BAR)  *        value for the supplied base address register number.  *  * @param[in] controller The controller for which to retrieve the bar number.  * @param[in] bar_number This parameter depicts the BAR index/number to be read.  *  * @return Return a pointer value indicating the contents of the BAR.  * @retval NULL indicates an invalid BAR index/number was specified.  * @retval All other values indicate a valid VIRTUAL address from the BAR.  */
end_comment

begin_function
name|void
modifier|*
name|scic_cb_pci_get_bar
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|uint16_t
name|bar_number
parameter_list|)
block|{
return|return
operator|(
operator|(
name|void
operator|*
operator|)
call|(
name|POINTER_UINT
call|)
argument_list|(
operator|(
name|uint32_t
operator|)
name|bar_number
operator|<<
literal|28
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method informs the SCI Core user that a phy/link became  *        ready, but the phy is not allowed in the port.  In some  *        situations the underlying hardware only allows for certain phy  *        to port mappings.  If these mappings are violated, then this  *        API is invoked.  *  * @param[in] controller This parameter represents the controller which  *            contains the port.  * @param[in] port This parameter specifies the SCI port object for which  *            the callback is being invoked.  * @param[in] phy This parameter specifies the phy that came ready, but the  *            phy can't be a valid member of the port.  *  * @return none  */
end_comment

begin_function
name|void
name|scic_cb_port_invalid_link_up
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_PORT_HANDLE_T
name|port
parameter_list|,
name|SCI_PHY_HANDLE_T
name|phy
parameter_list|)
block|{  }
end_function

end_unit

