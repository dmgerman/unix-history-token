begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Texas A&M University  * All rights reserved.  *  * Developer: Wm. Daryl Hawkins  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Intel ICH Watchdog Timer (WDT) driver  *  * Originally developed by Wm. Daryl Hawkins of Texas A&M  * Heavily modified by<des@FreeBSD.org>  *  * This is a tricky one.  The ICH WDT can't be treated as a regular PCI  * device as it's actually an integrated function of the ICH LPC interface  * bridge.  Detection is also awkward, because we can only infer the  * presence of the watchdog timer from the fact that the machine has an  * ICH chipset, or, on ACPI 2.x systems, by the presence of the 'WDDT'  * ACPI table (although this driver does not support the ACPI detection  * method).  *  * There is one slight problem on non-ACPI or ACPI 1.x systems: we have no  * way of knowing if the WDT is permanently disabled (either by the BIOS  * or in hardware).  *  * The WDT is programmed through I/O registers in the ACPI I/O space.  * Intel swears it's always at offset 0x60, so we use that.  *  * For details about the ICH WDT, see Intel Application Note AP-725  * (document no. 292273-001).  The WDT is also described in the individual  * chipset datasheets, e.g. Intel82801EB ICH5 / 82801ER ICH5R Datasheet  * (document no. 252516-001) sections 9.10 and 9.11.  *  * ICH6/7/8 support by Takeharu KATO<takeharu1219@ybb.ne.jp>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/watchdog.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ichwd/ichwd.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|ichwd_device
name|ichwd_devices
index|[]
init|=
block|{
block|{
name|DEVICEID_82801AA
block|,
literal|"Intel 82801AA watchdog timer"
block|,
literal|1
block|}
block|,
block|{
name|DEVICEID_82801AB
block|,
literal|"Intel 82801AB watchdog timer"
block|,
literal|1
block|}
block|,
block|{
name|DEVICEID_82801BA
block|,
literal|"Intel 82801BA watchdog timer"
block|,
literal|2
block|}
block|,
block|{
name|DEVICEID_82801BAM
block|,
literal|"Intel 82801BAM watchdog timer"
block|,
literal|2
block|}
block|,
block|{
name|DEVICEID_82801CA
block|,
literal|"Intel 82801CA watchdog timer"
block|,
literal|3
block|}
block|,
block|{
name|DEVICEID_82801CAM
block|,
literal|"Intel 82801CAM watchdog timer"
block|,
literal|3
block|}
block|,
block|{
name|DEVICEID_82801DB
block|,
literal|"Intel 82801DB watchdog timer"
block|,
literal|4
block|}
block|,
block|{
name|DEVICEID_82801DBM
block|,
literal|"Intel 82801DBM watchdog timer"
block|,
literal|4
block|}
block|,
block|{
name|DEVICEID_82801E
block|,
literal|"Intel 82801E watchdog timer"
block|,
literal|5
block|}
block|,
block|{
name|DEVICEID_82801EB
block|,
literal|"Intel 82801EB watchdog timer"
block|,
literal|5
block|}
block|,
block|{
name|DEVICEID_82801EBR
block|,
literal|"Intel 82801EB/ER watchdog timer"
block|,
literal|5
block|}
block|,
block|{
name|DEVICEID_6300ESB
block|,
literal|"Intel 6300ESB watchdog timer"
block|,
literal|5
block|}
block|,
block|{
name|DEVICEID_82801FBR
block|,
literal|"Intel 82801FB/FR watchdog timer"
block|,
literal|6
block|}
block|,
block|{
name|DEVICEID_ICH6M
block|,
literal|"Intel ICH6M watchdog timer"
block|,
literal|6
block|}
block|,
block|{
name|DEVICEID_ICH6W
block|,
literal|"Intel ICH6W watchdog timer"
block|,
literal|6
block|}
block|,
block|{
name|DEVICEID_ICH7
block|,
literal|"Intel ICH7 watchdog timer"
block|,
literal|7
block|}
block|,
block|{
name|DEVICEID_ICH7DH
block|,
literal|"Intel ICH7DH watchdog timer"
block|,
literal|7
block|}
block|,
block|{
name|DEVICEID_ICH7M
block|,
literal|"Intel ICH7M watchdog timer"
block|,
literal|7
block|}
block|,
block|{
name|DEVICEID_ICH7MDH
block|,
literal|"Intel ICH7MDH watchdog timer"
block|,
literal|7
block|}
block|,
block|{
name|DEVICEID_ICH8
block|,
literal|"Intel ICH8 watchdog timer"
block|,
literal|8
block|}
block|,
block|{
name|DEVICEID_ICH8DH
block|,
literal|"Intel ICH8DH watchdog timer"
block|,
literal|8
block|}
block|,
block|{
name|DEVICEID_ICH8DO
block|,
literal|"Intel ICH8DO watchdog timer"
block|,
literal|8
block|}
block|,
block|{
name|DEVICEID_ICH8M
block|,
literal|"Intel ICH8M watchdog timer"
block|,
literal|8
block|}
block|,
block|{
name|DEVICEID_ICH8ME
block|,
literal|"Intel ICH8M-E watchdog timer"
block|,
literal|8
block|}
block|,
block|{
name|DEVICEID_63XXESB
block|,
literal|"Intel 63XXESB watchdog timer"
block|,
literal|8
block|}
block|,
block|{
name|DEVICEID_ICH9
block|,
literal|"Intel ICH9 watchdog timer"
block|,
literal|9
block|}
block|,
block|{
name|DEVICEID_ICH9DH
block|,
literal|"Intel ICH9DH watchdog timer"
block|,
literal|9
block|}
block|,
block|{
name|DEVICEID_ICH9DO
block|,
literal|"Intel ICH9DO watchdog timer"
block|,
literal|9
block|}
block|,
block|{
name|DEVICEID_ICH9M
block|,
literal|"Intel ICH9M watchdog timer"
block|,
literal|9
block|}
block|,
block|{
name|DEVICEID_ICH9ME
block|,
literal|"Intel ICH9M-E watchdog timer"
block|,
literal|9
block|}
block|,
block|{
name|DEVICEID_ICH9R
block|,
literal|"Intel ICH9R watchdog timer"
block|,
literal|9
block|}
block|,
block|{
name|DEVICEID_ICH10
block|,
literal|"Intel ICH10 watchdog timer"
block|,
literal|10
block|}
block|,
block|{
name|DEVICEID_ICH10D
block|,
literal|"Intel ICH10D watchdog timer"
block|,
literal|10
block|}
block|,
block|{
name|DEVICEID_ICH10DO
block|,
literal|"Intel ICH10DO watchdog timer"
block|,
literal|10
block|}
block|,
block|{
name|DEVICEID_ICH10R
block|,
literal|"Intel ICH10R watchdog timer"
block|,
literal|10
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ichwd_devclass
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ichwd_read_tco_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
define|\
value|bus_space_read_1((sc)->tco_bst, (sc)->tco_bsh, (off))
end_define

begin_define
define|#
directive|define
name|ichwd_read_tco_2
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
define|\
value|bus_space_read_2((sc)->tco_bst, (sc)->tco_bsh, (off))
end_define

begin_define
define|#
directive|define
name|ichwd_read_tco_4
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
define|\
value|bus_space_read_4((sc)->tco_bst, (sc)->tco_bsh, (off))
end_define

begin_define
define|#
directive|define
name|ichwd_read_smi_4
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
define|\
value|bus_space_read_4((sc)->smi_bst, (sc)->smi_bsh, (off))
end_define

begin_define
define|#
directive|define
name|ichwd_read_gcs_4
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
define|\
value|bus_space_read_4((sc)->gcs_bst, (sc)->gcs_bsh, (off))
end_define

begin_define
define|#
directive|define
name|ichwd_write_tco_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_1((sc)->tco_bst, (sc)->tco_bsh, (off), (val))
end_define

begin_define
define|#
directive|define
name|ichwd_write_tco_2
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_2((sc)->tco_bst, (sc)->tco_bsh, (off), (val))
end_define

begin_define
define|#
directive|define
name|ichwd_write_tco_4
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_4((sc)->tco_bst, (sc)->tco_bsh, (off), (val))
end_define

begin_define
define|#
directive|define
name|ichwd_write_smi_4
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_4((sc)->smi_bst, (sc)->smi_bsh, (off), (val))
end_define

begin_define
define|#
directive|define
name|ichwd_write_gcs_4
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_4((sc)->gcs_bst, (sc)->gcs_bsh, (off), (val))
end_define

begin_define
define|#
directive|define
name|ichwd_verbose_printf
parameter_list|(
name|dev
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {						\ 		if (bootverbose)			\ 			device_printf(dev, __VA_ARGS__);\ 	} while (0)
end_define

begin_comment
comment|/*  * Disable the watchdog timeout SMI handler.  *  * Apparently, some BIOSes install handlers that reset or disable the  * watchdog timer instead of resetting the system, so we disable the SMI  * (by clearing the SMI_TCO_EN bit of the SMI_EN register) to prevent this  * from happening.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ichwd_smi_disable
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ichwd_write_smi_4
argument_list|(
name|sc
argument_list|,
name|SMI_EN
argument_list|,
name|ichwd_read_smi_4
argument_list|(
name|sc
argument_list|,
name|SMI_EN
argument_list|)
operator|&
operator|~
name|SMI_TCO_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable the watchdog timeout SMI handler.  See above for details.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ichwd_smi_enable
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ichwd_write_smi_4
argument_list|(
name|sc
argument_list|,
name|SMI_EN
argument_list|,
name|ichwd_read_smi_4
argument_list|(
name|sc
argument_list|,
name|SMI_EN
argument_list|)
operator||
name|SMI_TCO_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the watchdog status bits.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ichwd_sts_reset
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * The watchdog status bits are set to 1 by the hardware to 	 * indicate various conditions.  They can be cleared by software 	 * by writing a 1, not a 0. 	 */
name|ichwd_write_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO1_STS
argument_list|,
name|TCO_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* 	 * XXX The datasheet says that TCO_SECOND_TO_STS must be cleared 	 * before TCO_BOOT_STS, not the other way around. 	 */
name|ichwd_write_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO2_STS
argument_list|,
name|TCO_BOOT_STS
argument_list|)
expr_stmt|;
name|ichwd_write_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO2_STS
argument_list|,
name|TCO_SECOND_TO_STS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable the watchdog timer by clearing the TCO_TMR_HALT bit in the  * TCO1_CNT register.  This is complicated by the need to preserve bit 9  * of that same register, and the requirement that all other bits must be  * written back as zero.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ichwd_tmr_enable
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|cnt
decl_stmt|;
name|cnt
operator|=
name|ichwd_read_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO1_CNT
argument_list|)
operator|&
name|TCO_CNT_PRESERVE
expr_stmt|;
name|ichwd_write_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO1_CNT
argument_list|,
name|cnt
operator|&
operator|~
name|TCO_TMR_HALT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|ichwd_verbose_printf
argument_list|(
name|sc
operator|->
name|device
argument_list|,
literal|"timer enabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disable the watchdog timer.  See above for details.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ichwd_tmr_disable
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|cnt
decl_stmt|;
name|cnt
operator|=
name|ichwd_read_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO1_CNT
argument_list|)
operator|&
name|TCO_CNT_PRESERVE
expr_stmt|;
name|ichwd_write_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO1_CNT
argument_list|,
name|cnt
operator||
name|TCO_TMR_HALT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|ichwd_verbose_printf
argument_list|(
name|sc
operator|->
name|device
argument_list|,
literal|"timer disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reload the watchdog timer: writing anything to any of the lower five  * bits of the TCO_RLD register reloads the timer from the last value  * written to TCO_TMR.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ichwd_tmr_reload
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|ich_version
operator|<=
literal|5
condition|)
name|ichwd_write_tco_1
argument_list|(
name|sc
argument_list|,
name|TCO_RLD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|ichwd_write_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO_RLD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ichwd_verbose_printf
argument_list|(
name|sc
operator|->
name|device
argument_list|,
literal|"timer reloaded\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the initial timeout value.  Note that this must always be followed  * by a reload.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ichwd_tmr_set
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|timeout
parameter_list|)
block|{
comment|/* 	 * If the datasheets are to be believed, the minimum value 	 * actually varies from chipset to chipset - 4 for ICH5 and 2 for 	 * all other chipsets.  I suspect this is a bug in the ICH5 	 * datasheet and that the minimum is uniformly 2, but I'd rather 	 * err on the side of caution. 	 */
if|if
condition|(
name|timeout
operator|<
literal|4
condition|)
name|timeout
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ich_version
operator|<=
literal|5
condition|)
block|{
name|uint8_t
name|tmr_val8
init|=
name|ichwd_read_tco_1
argument_list|(
name|sc
argument_list|,
name|TCO_TMR1
argument_list|)
decl_stmt|;
name|tmr_val8
operator|&=
literal|0xc0
expr_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0xbf
condition|)
name|timeout
operator|=
literal|0xbf
expr_stmt|;
name|tmr_val8
operator||=
name|timeout
expr_stmt|;
name|ichwd_write_tco_1
argument_list|(
name|sc
argument_list|,
name|TCO_TMR1
argument_list|,
name|tmr_val8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint16_t
name|tmr_val16
init|=
name|ichwd_read_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO_TMR2
argument_list|)
decl_stmt|;
name|tmr_val16
operator|&=
literal|0xfc00
expr_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0x03ff
condition|)
name|timeout
operator|=
literal|0x03ff
expr_stmt|;
name|tmr_val16
operator||=
name|timeout
expr_stmt|;
name|ichwd_write_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO_TMR2
argument_list|,
name|tmr_val16
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
name|ichwd_verbose_printf
argument_list|(
name|sc
operator|->
name|device
argument_list|,
literal|"timeout set to %u ticks\n"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|ichwd_clear_noreboot
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
comment|/* try to clear the NO_REBOOT bit */
if|if
condition|(
name|sc
operator|->
name|ich_version
operator|<=
literal|5
condition|)
block|{
name|status
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|ich
argument_list|,
name|ICH_GEN_STA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|status
operator|&=
operator|~
name|ICH_GEN_STA_NO_REBOOT
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|ich
argument_list|,
name|ICH_GEN_STA
argument_list|,
name|status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|ich
argument_list|,
name|ICH_GEN_STA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ICH_GEN_STA_NO_REBOOT
condition|)
name|rc
operator|=
name|EIO
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|ichwd_read_gcs_4
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|status
operator|&=
operator|~
name|ICH_GCS_NO_REBOOT
expr_stmt|;
name|ichwd_write_gcs_4
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|status
operator|=
name|ichwd_read_gcs_4
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ICH_GCS_NO_REBOOT
condition|)
name|rc
operator|=
name|EIO
expr_stmt|;
block|}
if|if
condition|(
name|rc
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|device
argument_list|,
literal|"ICH WDT present but disabled in BIOS or hardware\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Watchdog event handler - called by the framework to enable or disable  * the watchdog or change the initial timeout value.  */
end_comment

begin_function
specifier|static
name|void
name|ichwd_event
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|struct
name|ichwd_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|unsigned
name|int
name|timeout
decl_stmt|;
comment|/* convert from power-of-two-ns to WDT ticks */
name|cmd
operator|&=
name|WD_INTERVAL
expr_stmt|;
name|timeout
operator|=
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
name|cmd
operator|)
operator|/
name|ICHWD_TICK
expr_stmt|;
if|if
condition|(
name|cmd
condition|)
block|{
if|if
condition|(
name|timeout
operator|!=
name|sc
operator|->
name|timeout
condition|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|active
condition|)
name|ichwd_tmr_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ichwd_tmr_set
argument_list|(
name|sc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
name|ichwd_tmr_reload
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|active
condition|)
name|ichwd_tmr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|device_t
name|ichwd_find_ich_lpc_bridge
parameter_list|(
name|struct
name|ichwd_device
modifier|*
modifier|*
name|id_p
parameter_list|)
block|{
name|struct
name|ichwd_device
modifier|*
name|id
decl_stmt|;
name|device_t
name|ich
init|=
name|NULL
decl_stmt|;
comment|/* look for an ICH LPC interface bridge */
for|for
control|(
name|id
operator|=
name|ichwd_devices
init|;
name|id
operator|->
name|desc
operator|!=
name|NULL
condition|;
operator|++
name|id
control|)
if|if
condition|(
operator|(
name|ich
operator|=
name|pci_find_device
argument_list|(
name|VENDORID_INTEL
argument_list|,
name|id
operator|->
name|device
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|ich
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ichwd_verbose_printf
argument_list|(
name|ich
argument_list|,
literal|"found ICH%d or equivalent chipset: %s\n"
argument_list|,
name|id
operator|->
name|version
argument_list|,
name|id
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id_p
condition|)
operator|*
name|id_p
operator|=
name|id
expr_stmt|;
return|return
operator|(
name|ich
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look for an ICH LPC interface bridge.  If one is found, register an  * ichwd device.  There can be only one.  */
end_comment

begin_function
specifier|static
name|void
name|ichwd_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|struct
name|ichwd_device
modifier|*
name|id_p
decl_stmt|;
name|device_t
name|ich
init|=
name|NULL
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|rcba
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ich
operator|=
name|ichwd_find_ich_lpc_bridge
argument_list|(
operator|&
name|id_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ich
operator|==
name|NULL
condition|)
return|return;
comment|/* good, add child to bus */
if|if
condition|(
operator|(
name|dev
operator|=
name|device_find_child
argument_list|(
name|parent
argument_list|,
name|driver
operator|->
name|name
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dev
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
name|driver
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|id_p
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id_p
operator|->
name|version
operator|>=
literal|6
condition|)
block|{
comment|/* get RCBA (root complex base address) */
name|rcba
operator|=
name|pci_read_config
argument_list|(
name|ich
argument_list|,
name|ICH_RCBA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bus_set_resource
argument_list|(
name|ich
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
operator|(
name|rcba
operator|&
literal|0xffffc000
operator|)
operator|+
name|ICH_GCS_OFFSET
argument_list|,
name|ICH_GCS_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|ichwd_verbose_printf
argument_list|(
name|dev
argument_list|,
literal|"Can not set memory resource for RCBA\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ichwd_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* Do not claim some ISA PnP device by accident. */
if|if
condition|(
name|isa_get_logicalid
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichwd_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ichwd_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ichwd_device
modifier|*
name|id_p
decl_stmt|;
name|device_t
name|ich
decl_stmt|;
name|unsigned
name|int
name|pmbase
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|device
operator|=
name|dev
expr_stmt|;
name|ich
operator|=
name|ichwd_find_ich_lpc_bridge
argument_list|(
operator|&
name|id_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ich
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|device
argument_list|,
literal|"Can not find ICH device.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|ich
operator|=
name|ich
expr_stmt|;
name|sc
operator|->
name|ich_version
operator|=
name|id_p
operator|->
name|version
expr_stmt|;
comment|/* get ACPI base address */
name|pmbase
operator|=
name|pci_read_config
argument_list|(
name|ich
argument_list|,
name|ICH_PMBASE
argument_list|,
literal|2
argument_list|)
operator|&
name|ICH_PMBASE_MASK
expr_stmt|;
if|if
condition|(
name|pmbase
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ICH PMBASE register is empty\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* allocate I/O register space */
name|sc
operator|->
name|smi_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|smi_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|smi_rid
argument_list|,
name|pmbase
operator|+
name|SMI_BASE
argument_list|,
name|pmbase
operator|+
name|SMI_BASE
operator|+
name|SMI_LEN
operator|-
literal|1
argument_list|,
name|SMI_LEN
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smi_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reserve SMI registers\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|smi_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|smi_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|smi_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|smi_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tco_rid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|tco_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|tco_rid
argument_list|,
name|pmbase
operator|+
name|TCO_BASE
argument_list|,
name|pmbase
operator|+
name|TCO_BASE
operator|+
name|TCO_LEN
operator|-
literal|1
argument_list|,
name|TCO_LEN
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tco_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reserve TCO registers\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|tco_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|tco_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tco_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|tco_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gcs_rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ich_version
operator|>=
literal|6
condition|)
block|{
name|sc
operator|->
name|gcs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|ich
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|gcs_rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gcs_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reserve GCS registers\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|gcs_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|gcs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gcs_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|gcs_res
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|gcs_res
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|gcs_bst
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|gcs_bsh
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ichwd_clear_noreboot
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s (ICH%d or equivalent)\n"
argument_list|,
name|device_get_desc
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|ich_version
argument_list|)
expr_stmt|;
comment|/* 	 * XXX we should check the status registers (specifically, the 	 * TCO_SECOND_TO_STS bit in the TCO2_STS register) to see if we 	 * just came back from a watchdog-induced reset, and let the user 	 * know. 	 */
comment|/* reset the watchdog status registers */
name|ichwd_sts_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* make sure the WDT starts out inactive */
name|ichwd_tmr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* register the watchdog event handler */
name|sc
operator|->
name|ev_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|watchdog_list
argument_list|,
name|ichwd_event
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable the SMI handler */
name|ichwd_smi_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tco_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|tco_rid
argument_list|,
name|sc
operator|->
name|tco_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smi_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|smi_rid
argument_list|,
name|sc
operator|->
name|smi_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gcs_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ich
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|gcs_rid
argument_list|,
name|sc
operator|->
name|gcs_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichwd_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ichwd_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|ich
init|=
name|NULL
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* halt the watchdog timer */
if|if
condition|(
name|sc
operator|->
name|active
condition|)
name|ichwd_tmr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* enable the SMI handler */
name|ichwd_smi_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* deregister event handler */
if|if
condition|(
name|sc
operator|->
name|ev_tag
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|watchdog_list
argument_list|,
name|sc
operator|->
name|ev_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ev_tag
operator|=
name|NULL
expr_stmt|;
comment|/* reset the watchdog status registers */
name|ichwd_sts_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* deallocate I/O register space */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|tco_rid
argument_list|,
name|sc
operator|->
name|tco_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|smi_rid
argument_list|,
name|sc
operator|->
name|smi_res
argument_list|)
expr_stmt|;
comment|/* deallocate memory resource */
name|ich
operator|=
name|ichwd_find_ich_lpc_bridge
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gcs_res
operator|&&
name|ich
condition|)
name|bus_release_resource
argument_list|(
name|ich
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|gcs_rid
argument_list|,
name|sc
operator|->
name|gcs_res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ichwd_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|ichwd_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ichwd_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ichwd_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ichwd_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ichwd_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ichwd_driver
init|=
block|{
literal|"ichwd"
block|,
name|ichwd_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ichwd_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ichwd_modevent
parameter_list|(
name|module_t
name|mode
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|printf
argument_list|(
literal|"ichwd module loaded\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|printf
argument_list|(
literal|"ichwd module unloaded\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
name|printf
argument_list|(
literal|"ichwd module shutting down\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ichwd
argument_list|,
name|isa
argument_list|,
name|ichwd_driver
argument_list|,
name|ichwd_devclass
argument_list|,
name|ichwd_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

