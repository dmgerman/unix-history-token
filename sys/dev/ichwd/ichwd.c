begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Texas A&M University  * All rights reserved.  *  * Developer: Wm. Daryl Hawkins  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Intel ICH Watchdog Timer (WDT) driver  *  * Originally developed by Wm. Daryl Hawkins of Texas A&M  * Heavily modified by<des@FreeBSD.org>  *  * This is a tricky one.  The ICH WDT can't be treated as a regular PCI  * device as it's actually an integrated function of the ICH LPC interface  * bridge.  Detection is also awkward, because we can only infer the  * presence of the watchdog timer from the fact that the machine has an  * ICH chipset, or, on ACPI 2.x systems, by the presence of the 'WDDT'  * ACPI table (although this driver does not support the ACPI detection  * method).  *  * There is one slight problem on non-ACPI or ACPI 1.x systems: we have no  * way of knowing if the WDT is permanently disabled (either by the BIOS  * or in hardware).  *  * The WDT is programmed through I/O registers in the ACPI I/O space.  * Intel swears it's always at offset 0x60, so we use that.  *  * For details about the ICH WDT, see Intel Application Note AP-725  * (document no. 292273-001).  The WDT is also described in the individual  * chipset datasheets, e.g. Intel82801EB ICH5 / 82801ER ICH5R Datasheet  * (document no. 252516-001) sections 9.10 and 9.11.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/watchdog.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ichwd/ichwd.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|ichwd_device
name|ichwd_devices
index|[]
init|=
block|{
block|{
name|VENDORID_INTEL
block|,
name|DEVICEID_82801AA
block|,
literal|"Intel 82801AA watchdog timer"
block|}
block|,
block|{
name|VENDORID_INTEL
block|,
name|DEVICEID_82801AB
block|,
literal|"Intel 82801AB watchdog timer"
block|}
block|,
block|{
name|VENDORID_INTEL
block|,
name|DEVICEID_82801BA
block|,
literal|"Intel 82801BA watchdog timer"
block|}
block|,
block|{
name|VENDORID_INTEL
block|,
name|DEVICEID_82801BAM
block|,
literal|"Intel 82801BAM watchdog timer"
block|}
block|,
block|{
name|VENDORID_INTEL
block|,
name|DEVICEID_82801CA
block|,
literal|"Intel 82801CA watchdog timer"
block|}
block|,
block|{
name|VENDORID_INTEL
block|,
name|DEVICEID_82801CAM
block|,
literal|"Intel 82801CAM watchdog timer"
block|}
block|,
block|{
name|VENDORID_INTEL
block|,
name|DEVICEID_82801DB
block|,
literal|"Intel 82801DB watchdog timer"
block|}
block|,
block|{
name|VENDORID_INTEL
block|,
name|DEVICEID_82801DBM
block|,
literal|"Intel 82801DBM watchdog timer"
block|}
block|,
block|{
name|VENDORID_INTEL
block|,
name|DEVICEID_82801E
block|,
literal|"Intel 82801E watchdog timer"
block|}
block|,
block|{
name|VENDORID_INTEL
block|,
name|DEVICEID_82801EBR
block|,
literal|"Intel 82801EB/ER watchdog timer"
block|}
block|,
block|{
name|VENDORID_INTEL
block|,
name|DEVICEID_82801FBR
block|,
literal|"Intel 82801FB/FR watchdog timer"
block|}
block|,
block|{
name|VENDORID_INTEL
block|,
name|DEVICEID_ICH5
block|,
literal|"Intel ICH5 watchdog timer"
block|}
block|,
block|{
name|VENDORID_INTEL
block|,
name|DEVICEID_6300ESB
block|,
literal|"Intel 6300ESB watchdog timer"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ichwd_devclass
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ichwd_read_tco_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
define|\
value|bus_space_read_1((sc)->tco_bst, (sc)->tco_bsh, (off))
end_define

begin_define
define|#
directive|define
name|ichwd_read_tco_2
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
define|\
value|bus_space_read_2((sc)->tco_bst, (sc)->tco_bsh, (off))
end_define

begin_define
define|#
directive|define
name|ichwd_read_tco_4
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
define|\
value|bus_space_read_4((sc)->tco_bst, (sc)->tco_bsh, (off))
end_define

begin_define
define|#
directive|define
name|ichwd_write_tco_1
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_1((sc)->tco_bst, (sc)->tco_bsh, (off), (val))
end_define

begin_define
define|#
directive|define
name|ichwd_write_tco_2
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_2((sc)->tco_bst, (sc)->tco_bsh, (off), (val))
end_define

begin_define
define|#
directive|define
name|ichwd_write_tco_4
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_4((sc)->tco_bst, (sc)->tco_bsh, (off), (val))
end_define

begin_define
define|#
directive|define
name|ichwd_read_smi_4
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
define|\
value|bus_space_read_4((sc)->smi_bst, (sc)->smi_bsh, (off))
end_define

begin_define
define|#
directive|define
name|ichwd_write_smi_4
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_4((sc)->smi_bst, (sc)->smi_bsh, (off), (val))
end_define

begin_function
specifier|static
name|__inline
name|void
name|ichwd_intr_enable
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ichwd_write_smi_4
argument_list|(
name|sc
argument_list|,
name|SMI_EN
argument_list|,
name|ichwd_read_smi_4
argument_list|(
name|sc
argument_list|,
name|SMI_EN
argument_list|)
operator|&
operator|~
name|SMI_TCO_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ichwd_intr_disable
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ichwd_write_smi_4
argument_list|(
name|sc
argument_list|,
name|SMI_EN
argument_list|,
name|ichwd_read_smi_4
argument_list|(
name|sc
argument_list|,
name|SMI_EN
argument_list|)
operator||
name|SMI_TCO_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ichwd_sts_reset
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ichwd_write_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO1_STS
argument_list|,
name|TCO_TIMEOUT
argument_list|)
expr_stmt|;
name|ichwd_write_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO2_STS
argument_list|,
name|TCO_BOOT_STS
argument_list|)
expr_stmt|;
name|ichwd_write_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO2_STS
argument_list|,
name|TCO_SECOND_TO_STS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ichwd_tmr_enable
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|cnt
decl_stmt|;
name|cnt
operator|=
name|ichwd_read_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO1_CNT
argument_list|)
operator|&
name|TCO_CNT_PRESERVE
expr_stmt|;
name|ichwd_write_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO1_CNT
argument_list|,
name|cnt
operator|&
operator|~
name|TCO_TMR_HALT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|device
argument_list|,
literal|"timer enabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ichwd_tmr_disable
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|cnt
decl_stmt|;
name|cnt
operator|=
name|ichwd_read_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO1_CNT
argument_list|)
operator|&
name|TCO_CNT_PRESERVE
expr_stmt|;
name|ichwd_write_tco_2
argument_list|(
name|sc
argument_list|,
name|TCO1_CNT
argument_list|,
name|cnt
operator||
name|TCO_TMR_HALT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|device
argument_list|,
literal|"timer disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ichwd_tmr_reload
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ichwd_write_tco_1
argument_list|(
name|sc
argument_list|,
name|TCO_RLD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|device
argument_list|,
literal|"timer reloaded\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ichwd_tmr_set
parameter_list|(
name|struct
name|ichwd_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|timeout
parameter_list|)
block|{
name|ichwd_write_tco_1
argument_list|(
name|sc
argument_list|,
name|TCO_TMR
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|sc
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|device
argument_list|,
literal|"timeout set to %u ticks\n"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Watchdog event handler.  */
end_comment

begin_function
specifier|static
name|void
name|ichwd_event
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|struct
name|ichwd_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|unsigned
name|int
name|timeout
decl_stmt|;
comment|/* convert from power-of-two-ns to WDT ticks */
name|cmd
operator|&=
name|WD_INTERVAL
expr_stmt|;
name|timeout
operator|=
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
name|cmd
operator|)
operator|/
name|ICHWD_TICK
expr_stmt|;
if|if
condition|(
name|cmd
operator|>
literal|0
operator|&&
name|cmd
operator|<=
literal|63
operator|&&
name|timeout
operator|>=
name|ICHWD_MIN_TIMEOUT
operator|&&
name|timeout
operator|<=
name|ICHWD_MAX_TIMEOUT
condition|)
block|{
if|if
condition|(
name|timeout
operator|!=
name|sc
operator|->
name|timeout
condition|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|active
condition|)
name|ichwd_tmr_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ichwd_tmr_set
argument_list|(
name|sc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
name|ichwd_tmr_reload
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|active
condition|)
name|ichwd_tmr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|pmbase
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Look for an ICH LPC interface bridge.  If one is found, register an  * ichwd device.  There can be only one.  */
end_comment

begin_function
specifier|static
name|void
name|ichwd_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|struct
name|ichwd_device
modifier|*
name|id
decl_stmt|;
name|device_t
name|ich
init|=
name|NULL
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
comment|/* look for an ICH LPC interface bridge */
for|for
control|(
name|id
operator|=
name|ichwd_devices
init|;
name|id
operator|->
name|desc
operator|!=
name|NULL
condition|;
operator|++
name|id
control|)
if|if
condition|(
operator|(
name|ich
operator|=
name|pci_find_device
argument_list|(
name|id
operator|->
name|vendor
argument_list|,
name|id
operator|->
name|device
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|ich
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s(): found ICH chipset: %s\n"
argument_list|,
name|__func__
argument_list|,
name|id
operator|->
name|desc
argument_list|)
expr_stmt|;
comment|/* get for ACPI base address */
name|pmbase
operator|=
name|pci_read_config
argument_list|(
name|ich
argument_list|,
name|ICH_PMBASE
argument_list|,
literal|2
argument_list|)
operator|&
name|ICH_PMBASE_MASK
expr_stmt|;
if|if
condition|(
name|pmbase
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s(): ICH PMBASE register is empty\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* try to clear the NO_REBOOT bit */
name|pci_write_config
argument_list|(
name|ich
argument_list|,
name|ICH_GEN_STA
argument_list|,
literal|0x00
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|ich
argument_list|,
name|ICH_GEN_STA
argument_list|,
literal|1
argument_list|)
operator|&
name|ICH_GEN_STA_NO_REBOOT
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s(): ICH WDT present but disabled\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* good, add child to bus */
if|if
condition|(
operator|(
name|dev
operator|=
name|device_find_child
argument_list|(
name|parent
argument_list|,
name|driver
operator|->
name|name
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dev
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
name|driver
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|id
operator|->
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichwd_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
operator|(
name|void
operator|)
name|dev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichwd_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ichwd_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|device
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|pmbase
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Not found\n"
argument_list|)
expr_stmt|;
block|}
comment|/* allocate I/O register space */
name|sc
operator|->
name|smi_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|smi_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|smi_rid
argument_list|,
name|pmbase
operator|+
name|SMI_BASE
argument_list|,
operator|~
literal|0ul
argument_list|,
name|SMI_LEN
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smi_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reserve SMI registers\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|smi_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|smi_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|smi_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|smi_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tco_rid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|tco_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|tco_rid
argument_list|,
name|pmbase
operator|+
name|TCO_BASE
argument_list|,
operator|~
literal|0ul
argument_list|,
name|TCO_LEN
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tco_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reserve TCO registers\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|tco_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|tco_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tco_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|tco_res
argument_list|)
expr_stmt|;
comment|/* reset the watchdog status registers */
name|ichwd_sts_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* make sure the WDT starts out inactive */
name|ichwd_tmr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* register the watchdog event handler */
name|sc
operator|->
name|ev_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|watchdog_list
argument_list|,
name|ichwd_event
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* enable watchdog timeout interrupts */
name|ichwd_intr_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tco_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|tco_rid
argument_list|,
name|sc
operator|->
name|tco_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smi_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|smi_rid
argument_list|,
name|sc
operator|->
name|smi_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichwd_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ichwd_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* halt the watchdog timer */
if|if
condition|(
name|sc
operator|->
name|active
condition|)
name|ichwd_tmr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* disable watchdog timeout interrupts */
name|ichwd_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* deregister event handler */
if|if
condition|(
name|sc
operator|->
name|ev_tag
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|watchdog_list
argument_list|,
name|sc
operator|->
name|ev_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ev_tag
operator|=
name|NULL
expr_stmt|;
comment|/* reset the watchdog status registers */
name|ichwd_sts_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* deallocate I/O register space */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|tco_rid
argument_list|,
name|sc
operator|->
name|tco_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|smi_rid
argument_list|,
name|sc
operator|->
name|smi_res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ichwd_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|ichwd_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ichwd_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ichwd_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ichwd_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ichwd_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ichwd_driver
init|=
block|{
literal|"ichwd"
block|,
name|ichwd_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ichwd_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ichwd_modevent
parameter_list|(
name|module_t
name|mode
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|printf
argument_list|(
literal|"ichwd module loaded\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|printf
argument_list|(
literal|"ichwd module unloaded\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
name|printf
argument_list|(
literal|"ichwd module shutting down\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ichwd
argument_list|,
name|isa
argument_list|,
name|ichwd_driver
argument_list|,
name|ichwd_devclass
argument_list|,
name|ichwd_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

