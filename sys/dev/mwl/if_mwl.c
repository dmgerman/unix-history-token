begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2007-2008 Marvell Semiconductor, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Marvell 88W8363 Wireless LAN controller.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_mwl.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_include
include|#
directive|include
file|<dev/mwl/if_mwlvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mwl/mwldiag.h>
end_include

begin_comment
comment|/* idiomatic shorthands: MS = mask+shift, SM = shift+mask */
end_comment

begin_define
define|#
directive|define
name|MS
parameter_list|(
name|v
parameter_list|,
name|x
parameter_list|)
value|(((v)& x)>> x##_S)
end_define

begin_define
define|#
directive|define
name|SM
parameter_list|(
name|v
parameter_list|,
name|x
parameter_list|)
value|(((v)<< x##_S)& x)
end_define

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|mwl_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_setupdma
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_hal_reset
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_init_locked
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_stop_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_reset
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_radar_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_chanswitch_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_bawatchdog_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_key_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|ieee80211_keyix
modifier|*
parameter_list|,
name|ieee80211_keyix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_key_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_key_set
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_mode_init
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_update_promisc
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_updateslot
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_beacon_setup
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_beacon_update
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MWL_HOST_PS_SUPPORT
end_ifdef

begin_function_decl
specifier|static
name|void
name|mwl_update_ps
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_set_tim
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|mwl_dma_setup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_dma_cleanup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|mwl_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_node_drain
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_node_getsignal
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_node_getmimoinfo
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ieee80211_mimo_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_rxbuf_init
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|,
name|struct
name|mwl_rxbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_rx_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_txq_init
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mwl_txq
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_tx_setup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_tx_cleanupq
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|,
name|struct
name|mwl_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_tx_cleanup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|mwl_calcformat
parameter_list|(
name|uint8_t
name|rate
parameter_list|,
specifier|const
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_tx_start
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mwl_txbuf
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_tx_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_chan_set
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_draintxq
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_cleartxq
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_recv_action
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_addba_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
parameter_list|,
name|int
name|dialogtoken
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_addba_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_addba_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_startrecv
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MWL_HAL_APMODE
name|mwl_getapmode
parameter_list|(
specifier|const
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_setapmode
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_peerstadb
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
name|aid
parameter_list|,
name|int
name|staid
parameter_list|,
name|MWL_HAL_PEERINFO
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_localstadb
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|allocstaid
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|int
name|aid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delstaid
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|int
name|staid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_agestations
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_setregdomain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_regdomain
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_getradiocaps
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwl_getchannels
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_sysctlattach
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_announce
parameter_list|(
name|struct
name|mwl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|mwl
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Marvell driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mwl_rxdesc
init|=
name|MWL_RXDESC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # rx desc's to allocate */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mwl
argument_list|,
name|OID_AUTO
argument_list|,
name|rxdesc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mwl_rxdesc
argument_list|,
literal|0
argument_list|,
literal|"rx descriptors allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mwl_rxbuf
init|=
name|MWL_RXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # rx buffers to allocate */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mwl
argument_list|,
name|OID_AUTO
argument_list|,
name|rxbuf
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mwl_rxbuf
argument_list|,
literal|0
argument_list|,
literal|"rx buffers allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.mwl.rxbuf"
argument_list|,
operator|&
name|mwl_rxbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mwl_txbuf
init|=
name|MWL_TXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # tx buffers to allocate */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mwl
argument_list|,
name|OID_AUTO
argument_list|,
name|txbuf
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mwl_txbuf
argument_list|,
literal|0
argument_list|,
literal|"tx buffers allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.mwl.txbuf"
argument_list|,
operator|&
name|mwl_txbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mwl_txcoalesce
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # tx packets to q before poking f/w*/
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mwl
argument_list|,
name|OID_AUTO
argument_list|,
name|txcoalesce
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mwl_txcoalesce
argument_list|,
literal|0
argument_list|,
literal|"tx buffers to send at once"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.mwl.txcoalesce"
argument_list|,
operator|&
name|mwl_txcoalesce
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mwl_rxquota
init|=
name|MWL_RXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # max buffers to process */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mwl
argument_list|,
name|OID_AUTO
argument_list|,
name|rxquota
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mwl_rxquota
argument_list|,
literal|0
argument_list|,
literal|"max rx buffers to process per interrupt"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.mwl.rxquota"
argument_list|,
operator|&
name|mwl_rxquota
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mwl_rxdmalow
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # min buffers for wakeup */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mwl
argument_list|,
name|OID_AUTO
argument_list|,
name|rxdmalow
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mwl_rxdmalow
argument_list|,
literal|0
argument_list|,
literal|"min free rx buffers before restarting traffic"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.mwl.rxdmalow"
argument_list|,
operator|&
name|mwl_rxdmalow
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MWL_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|mwl_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_mwl
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mwl_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.mwl.debug"
argument_list|,
operator|&
name|mwl_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|MWL_DEBUG_XMIT
init|=
literal|0x00000001
block|,
comment|/* basic xmit operation */
name|MWL_DEBUG_XMIT_DESC
init|=
literal|0x00000002
block|,
comment|/* xmit descriptors */
name|MWL_DEBUG_RECV
init|=
literal|0x00000004
block|,
comment|/* basic recv operation */
name|MWL_DEBUG_RECV_DESC
init|=
literal|0x00000008
block|,
comment|/* recv descriptors */
name|MWL_DEBUG_RESET
init|=
literal|0x00000010
block|,
comment|/* reset processing */
name|MWL_DEBUG_BEACON
init|=
literal|0x00000020
block|,
comment|/* beacon handling */
name|MWL_DEBUG_INTR
init|=
literal|0x00000040
block|,
comment|/* ISR */
name|MWL_DEBUG_TX_PROC
init|=
literal|0x00000080
block|,
comment|/* tx ISR proc */
name|MWL_DEBUG_RX_PROC
init|=
literal|0x00000100
block|,
comment|/* rx ISR proc */
name|MWL_DEBUG_KEYCACHE
init|=
literal|0x00000200
block|,
comment|/* key cache management */
name|MWL_DEBUG_STATE
init|=
literal|0x00000400
block|,
comment|/* 802.11 state transitions */
name|MWL_DEBUG_NODE
init|=
literal|0x00000800
block|,
comment|/* node management */
name|MWL_DEBUG_RECV_ALL
init|=
literal|0x00001000
block|,
comment|/* trace all frames (beacons) */
name|MWL_DEBUG_TSO
init|=
literal|0x00002000
block|,
comment|/* TSO processing */
name|MWL_DEBUG_AMPDU
init|=
literal|0x00004000
block|,
comment|/* BA stream handling */
name|MWL_DEBUG_ANY
init|=
literal|0xffffffff
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|IS_BEACON
parameter_list|(
name|wh
parameter_list|)
define|\
value|((wh->i_fc[0]& (IEEE80211_FC0_TYPE_MASK|IEEE80211_FC0_SUBTYPE_MASK)) == \ 	 (IEEE80211_FC0_TYPE_MGT|IEEE80211_FC0_SUBTYPE_BEACON))
end_define

begin_define
define|#
directive|define
name|IFF_DUMPPKTS_RECV
parameter_list|(
name|sc
parameter_list|,
name|wh
parameter_list|)
define|\
value|(((sc->sc_debug& MWL_DEBUG_RECV)&& \       ((sc->sc_debug& MWL_DEBUG_RECV_ALL) || !IS_BEACON(wh))) || \      (sc->sc_ifp->if_flags& (IFF_DEBUG|IFF_LINK2)) == (IFF_DEBUG|IFF_LINK2))
end_define

begin_define
define|#
directive|define
name|IFF_DUMPPKTS_XMIT
parameter_list|(
name|sc
parameter_list|)
define|\
value|((sc->sc_debug& MWL_DEBUG_XMIT) || \ 	 (sc->sc_ifp->if_flags& (IFF_DEBUG|IFF_LINK2)) == (IFF_DEBUG|IFF_LINK2))
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	if (sc->sc_debug& (m))					\ 		printf(fmt, __VA_ARGS__);			\ } while (0)
end_define

begin_define
define|#
directive|define
name|KEYPRINTF
parameter_list|(
name|sc
parameter_list|,
name|hk
parameter_list|,
name|mac
parameter_list|)
value|do {				\ 	if (sc->sc_debug& MWL_DEBUG_KEYCACHE)			\ 		mwl_keyprint(sc, __func__, hk, mac);		\ } while (0)
end_define

begin_function_decl
specifier|static
name|void
name|mwl_printrxbuf
parameter_list|(
specifier|const
name|struct
name|mwl_rxbuf
modifier|*
name|bf
parameter_list|,
name|u_int
name|ix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mwl_printtxbuf
parameter_list|(
specifier|const
name|struct
name|mwl_txbuf
modifier|*
name|bf
parameter_list|,
name|u_int
name|qnum
parameter_list|,
name|u_int
name|ix
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IFF_DUMPPKTS_RECV
parameter_list|(
name|sc
parameter_list|,
name|wh
parameter_list|)
define|\
value|((sc->sc_ifp->if_flags& (IFF_DEBUG|IFF_LINK2)) == (IFF_DEBUG|IFF_LINK2))
end_define

begin_define
define|#
directive|define
name|IFF_DUMPPKTS_XMIT
parameter_list|(
name|sc
parameter_list|)
define|\
value|((sc->sc_ifp->if_flags& (IFF_DEBUG|IFF_LINK2)) == (IFF_DEBUG|IFF_LINK2))
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	(void) sc;						\ } while (0)
end_define

begin_define
define|#
directive|define
name|KEYPRINTF
parameter_list|(
name|sc
parameter_list|,
name|k
parameter_list|,
name|mac
parameter_list|)
value|do {				\ 	(void) sc;						\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MWLDEV
argument_list|,
literal|"mwldev"
argument_list|,
literal|"mwl driver dma buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Each packet has fixed front matter: a 2-byte length  * of the payload, followed by a 4-address 802.11 header  * (regardless of the actual header and always w/o any  * QoS header).  The payload then follows.  */
end_comment

begin_struct
struct|struct
name|mwltxrec
block|{
name|uint16_t
name|fwlen
decl_stmt|;
name|struct
name|ieee80211_frame_addr4
name|wh
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_comment
comment|/*  * Read/Write shorthands for accesses to BAR 0.  Note  * that all BAR 1 operations are done in the "hal" and  * there should be no reference to them here.  */
end_comment

begin_function
specifier|static
name|__inline
name|uint32_t
name|RD4
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
return|return
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_io0t
argument_list|,
name|sc
operator|->
name|sc_io0h
argument_list|,
name|off
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|WR4
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_io0t
argument_list|,
name|sc
operator|->
name|sc_io0h
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mwl_attach
parameter_list|(
name|uint16_t
name|devid
parameter_list|,
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|struct
name|mwl_hal
modifier|*
name|mh
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_ANY
argument_list|,
literal|"%s: devid 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|devid
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_IEEE80211
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot if_alloc()\n"
argument_list|)
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
comment|/* set these up early for if_printf use */
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|mh
operator|=
name|mwl_hal_attach
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|devid
argument_list|,
name|sc
operator|->
name|sc_io1h
argument_list|,
name|sc
operator|->
name|sc_io1t
argument_list|,
name|sc
operator|->
name|sc_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to attach HAL\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_mh
operator|=
name|mh
expr_stmt|;
comment|/* 	 * Load firmware so we can get setup.  We arbitrarily 	 * pick station firmware; we'll re-load firmware as 	 * needed so setting up the wrong mode isn't a big deal. 	 */
if|if
condition|(
name|mwl_hal_fwload
argument_list|(
name|mh
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to setup builtin firmware\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
if|if
condition|(
name|mwl_hal_gethwspecs
argument_list|(
name|mh
argument_list|,
operator|&
name|sc
operator|->
name|sc_hwspecs
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to fetch h/w specs\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
name|error
operator|=
name|mwl_getchannels
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad1
goto|;
name|sc
operator|->
name|sc_txantenna
operator|=
literal|0
expr_stmt|;
comment|/* h/w default */
name|sc
operator|->
name|sc_rxantenna
operator|=
literal|0
expr_stmt|;
comment|/* h/w default */
name|sc
operator|->
name|sc_invalid
operator|=
literal|0
expr_stmt|;
comment|/* ready to go, enable int handling */
name|sc
operator|->
name|sc_ageinterval
operator|=
name|MWL_AGEINTERVAL
expr_stmt|;
comment|/* 	 * Allocate tx+rx descriptors and populate the lists. 	 * We immediately push the information to the firmware 	 * as otherwise it gets upset. 	 */
name|error
operator|=
name|mwl_dma_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to setup descriptors: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
name|error
operator|=
name|mwl_setupdma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* push to firmware */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
comment|/* NB: mwl_setupdma prints msg */
goto|goto
name|bad1
goto|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"mwl_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|sc_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|,
literal|0
argument_list|,
name|mwl_rx_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_radartask
argument_list|,
literal|0
argument_list|,
name|mwl_radar_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_chanswitchtask
argument_list|,
literal|0
argument_list|,
name|mwl_chanswitch_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bawatchdogtask
argument_list|,
literal|0
argument_list|,
name|mwl_bawatchdog_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* NB: insure BK queue is the lowest priority h/w queue */
if|if
condition|(
operator|!
name|mwl_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_BK
argument_list|,
name|MWL_WME_AC_BK
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to setup xmit queue for %s traffic!\n"
argument_list|,
name|ieee80211_wme_acnames
index|[
name|WME_AC_BK
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
if|if
condition|(
operator|!
name|mwl_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_BE
argument_list|,
name|MWL_WME_AC_BE
argument_list|)
operator|||
operator|!
name|mwl_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_VI
argument_list|,
name|MWL_WME_AC_VI
argument_list|)
operator|||
operator|!
name|mwl_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_VO
argument_list|,
name|MWL_WME_AC_VO
argument_list|)
condition|)
block|{
comment|/* 		 * Not enough hardware tx queues to properly do WME; 		 * just punt and assign them all to the same h/w queue. 		 * We could do a better job of this if, for example, 		 * we allocate queues when we switch from station to 		 * AP mode. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
operator|!=
name|NULL
condition|)
name|mwl_tx_cleanupq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
operator|!=
name|NULL
condition|)
name|mwl_tx_cleanupq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VO
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
block|}
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|,
literal|0
argument_list|,
name|mwl_tx_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|mwl_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|mwl_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|mwl_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|mwl_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|IFQ_MAXLEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* XXX not right but it's not used anywhere important */
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
comment|/* station mode supported */
operator||
name|IEEE80211_C_HOSTAP
comment|/* hostap mode */
operator||
name|IEEE80211_C_MONITOR
comment|/* monitor mode */
if|#
directive|if
literal|0
expr|| IEEE80211_C_IBSS
comment|/* ibss, nee adhoc, mode */
expr|| IEEE80211_C_AHDEMO
comment|/* adhoc demo mode */
endif|#
directive|endif
operator||
name|IEEE80211_C_MBSS
comment|/* mesh point link mode */
operator||
name|IEEE80211_C_WDS
comment|/* WDS supported */
operator||
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
operator||
name|IEEE80211_C_SHSLOT
comment|/* short slot time supported */
operator||
name|IEEE80211_C_WME
comment|/* WME/WMM supported */
operator||
name|IEEE80211_C_BURST
comment|/* xmit bursting supported */
operator||
name|IEEE80211_C_WPA
comment|/* capable of WPA1+WPA2 */
operator||
name|IEEE80211_C_BGSCAN
comment|/* capable of bg scanning */
operator||
name|IEEE80211_C_TXFRAG
comment|/* handle tx frags */
operator||
name|IEEE80211_C_TXPMGT
comment|/* capable of txpow mgt */
operator||
name|IEEE80211_C_DFS
comment|/* DFS supported */
expr_stmt|;
name|ic
operator|->
name|ic_htcaps
operator|=
name|IEEE80211_HTCAP_SMPS_ENA
comment|/* SM PS mode enabled */
operator||
name|IEEE80211_HTCAP_CHWIDTH40
comment|/* 40MHz channel width */
operator||
name|IEEE80211_HTCAP_SHORTGI20
comment|/* short GI in 20MHz */
operator||
name|IEEE80211_HTCAP_SHORTGI40
comment|/* short GI in 40MHz */
operator||
name|IEEE80211_HTCAP_RXSTBC_2STREAM
comment|/* 1-2 spatial streams */
if|#
directive|if
name|MWL_AGGR_SIZE
operator|==
literal|7935
operator||
name|IEEE80211_HTCAP_MAXAMSDU_7935
comment|/* max A-MSDU length */
else|#
directive|else
operator||
name|IEEE80211_HTCAP_MAXAMSDU_3839
comment|/* max A-MSDU length */
endif|#
directive|endif
if|#
directive|if
literal|0
expr|| IEEE80211_HTCAP_PSMP
comment|/* PSMP supported */
expr|| IEEE80211_HTCAP_40INTOLERANT
comment|/* 40MHz intolerant */
endif|#
directive|endif
comment|/* s/w capabilities */
operator||
name|IEEE80211_HTC_HT
comment|/* HT operation */
operator||
name|IEEE80211_HTC_AMPDU
comment|/* tx A-MPDU */
operator||
name|IEEE80211_HTC_AMSDU
comment|/* tx A-MSDU */
operator||
name|IEEE80211_HTC_SMPS
comment|/* SMPS available */
expr_stmt|;
comment|/* 	 * Mark h/w crypto support. 	 * XXX no way to query h/w support. 	 */
name|ic
operator|->
name|ic_cryptocaps
operator||=
name|IEEE80211_CRYPTO_WEP
operator||
name|IEEE80211_CRYPTO_AES_CCM
operator||
name|IEEE80211_CRYPTO_TKIP
operator||
name|IEEE80211_CRYPTO_TKIPMIC
expr_stmt|;
comment|/* 	 * Transmit requires space in the packet for a special 	 * format transmit record and optional padding between 	 * this record and the payload.  Ask the net80211 layer 	 * to arrange this when encapsulating packets so we can 	 * add it efficiently.  	 */
name|ic
operator|->
name|ic_headroom
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mwltxrec
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
comment|/* call MI attach routine. */
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|,
name|sc
operator|->
name|sc_hwspecs
operator|.
name|macAddr
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_setregdomain
operator|=
name|mwl_setregdomain
expr_stmt|;
name|ic
operator|->
name|ic_getradiocaps
operator|=
name|mwl_getradiocaps
expr_stmt|;
comment|/* override default methods */
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|mwl_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_newassoc
operator|=
name|mwl_newassoc
expr_stmt|;
name|ic
operator|->
name|ic_updateslot
operator|=
name|mwl_updateslot
expr_stmt|;
name|ic
operator|->
name|ic_update_mcast
operator|=
name|mwl_update_mcast
expr_stmt|;
name|ic
operator|->
name|ic_update_promisc
operator|=
name|mwl_update_promisc
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
operator|=
name|mwl_wme_update
expr_stmt|;
name|ic
operator|->
name|ic_node_alloc
operator|=
name|mwl_node_alloc
expr_stmt|;
name|sc
operator|->
name|sc_node_cleanup
operator|=
name|ic
operator|->
name|ic_node_cleanup
expr_stmt|;
name|ic
operator|->
name|ic_node_cleanup
operator|=
name|mwl_node_cleanup
expr_stmt|;
name|sc
operator|->
name|sc_node_drain
operator|=
name|ic
operator|->
name|ic_node_drain
expr_stmt|;
name|ic
operator|->
name|ic_node_drain
operator|=
name|mwl_node_drain
expr_stmt|;
name|ic
operator|->
name|ic_node_getsignal
operator|=
name|mwl_node_getsignal
expr_stmt|;
name|ic
operator|->
name|ic_node_getmimoinfo
operator|=
name|mwl_node_getmimoinfo
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|mwl_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|mwl_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|mwl_set_channel
expr_stmt|;
name|sc
operator|->
name|sc_recv_action
operator|=
name|ic
operator|->
name|ic_recv_action
expr_stmt|;
name|ic
operator|->
name|ic_recv_action
operator|=
name|mwl_recv_action
expr_stmt|;
name|sc
operator|->
name|sc_addba_request
operator|=
name|ic
operator|->
name|ic_addba_request
expr_stmt|;
name|ic
operator|->
name|ic_addba_request
operator|=
name|mwl_addba_request
expr_stmt|;
name|sc
operator|->
name|sc_addba_response
operator|=
name|ic
operator|->
name|ic_addba_response
expr_stmt|;
name|ic
operator|->
name|ic_addba_response
operator|=
name|mwl_addba_response
expr_stmt|;
name|sc
operator|->
name|sc_addba_stop
operator|=
name|ic
operator|->
name|ic_addba_stop
expr_stmt|;
name|ic
operator|->
name|ic_addba_stop
operator|=
name|mwl_addba_stop
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|mwl_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|mwl_vap_delete
expr_stmt|;
name|ieee80211_radiotap_attach
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tx_th
argument_list|)
argument_list|,
name|MWL_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rx_th
argument_list|)
argument_list|,
name|MWL_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
comment|/* 	 * Setup dynamic sysctl's now that country code and 	 * regdomain are available from the hal. 	 */
name|mwl_sysctlattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|mwl_announce
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad2
label|:
name|mwl_dma_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bad1
label|:
name|mwl_hal_detach
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|bad
label|:
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_invalid
operator|=
literal|1
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|mwl_detach
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|mwl_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * NB: the order of these is important: 	 * o call the 802.11 layer before detaching the hal to 	 *   insure callbacks into the driver to delete global 	 *   key cache entries can be handled 	 * o reclaim the tx queue data structures after calling 	 *   the 802.11 layer as we'll get called back to reclaim 	 *   node state and potentially want to use them 	 * o to cleanup the tx queues the hal is called, so detach 	 *   it last 	 * Other than that, it's straightforward... 	 */
name|ieee80211_ifdetach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|mwl_dma_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mwl_tx_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mwl_hal_detach
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * MAC address handling for multiple BSS on the same radio.  * The first vap uses the MAC address from the EEPROM.  For  * subsequent vap's we set the U/L bit (bit 1) in the MAC  * address and use the next six bits as an index.  */
end_comment

begin_function
specifier|static
name|void
name|assign_address
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|int
name|clone
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|clone
operator|&&
name|mwl_hal_ismbsscapable
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|)
condition|)
block|{
comment|/* NB: we only do this if h/w supports multiple bssid */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_bssidmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|mac
index|[
literal|0
index|]
operator||=
operator|(
name|i
operator|<<
literal|2
operator|)
operator||
literal|0x2
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bssidmask
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_nbssid0
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reclaim_address
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|int
name|i
init|=
name|mac
index|[
literal|0
index|]
operator|>>
literal|2
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
operator|--
name|sc
operator|->
name|sc_nbssid0
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_bssidmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|mwl_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac0
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|,
modifier|*
name|apvap
decl_stmt|;
name|struct
name|mwl_hal_vap
modifier|*
name|hvap
decl_stmt|;
name|struct
name|mwl_vap
modifier|*
name|mvp
decl_stmt|;
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|mac
argument_list|,
name|mac0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_MBSS
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_CLONE_MACADDR
operator|)
operator|==
literal|0
condition|)
name|assign_address
argument_list|(
name|sc
argument_list|,
name|mac
argument_list|,
name|flags
operator|&
name|IEEE80211_CLONE_BSSID
argument_list|)
expr_stmt|;
name|hvap
operator|=
name|mwl_hal_newvap
argument_list|(
name|mh
argument_list|,
name|MWL_HAL_AP
argument_list|,
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|hvap
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_CLONE_MACADDR
operator|)
operator|==
literal|0
condition|)
name|reclaim_address
argument_list|(
name|sc
argument_list|,
name|mac
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
case|case
name|IEEE80211_M_STA
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_CLONE_MACADDR
operator|)
operator|==
literal|0
condition|)
name|assign_address
argument_list|(
name|sc
argument_list|,
name|mac
argument_list|,
name|flags
operator|&
name|IEEE80211_CLONE_BSSID
argument_list|)
expr_stmt|;
name|hvap
operator|=
name|mwl_hal_newvap
argument_list|(
name|mh
argument_list|,
name|MWL_HAL_STA
argument_list|,
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|hvap
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_CLONE_MACADDR
operator|)
operator|==
literal|0
condition|)
name|reclaim_address
argument_list|(
name|sc
argument_list|,
name|mac
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* no h/w beacon miss support; always use s/w */
name|flags
operator||=
name|IEEE80211_CLONE_NOBEACONS
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_WDS
case|:
name|hvap
operator|=
name|NULL
expr_stmt|;
comment|/* NB: we use associated AP vap */
if|if
condition|(
name|sc
operator|->
name|sc_napvaps
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* no existing AP vap */
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
name|hvap
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
case|case
name|IEEE80211_M_AHDEMO
case|:
default|default:
return|return
name|NULL
return|;
block|}
name|mvp
operator|=
operator|(
expr|struct
name|mwl_vap
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mwl_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|hvap
operator|!=
name|NULL
condition|)
block|{
name|mwl_hal_delvap
argument_list|(
name|hvap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_CLONE_MACADDR
operator|)
operator|==
literal|0
condition|)
name|reclaim_address
argument_list|(
name|sc
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
comment|/* XXX msg */
return|return
name|NULL
return|;
block|}
name|mvp
operator|->
name|mv_hvap
operator|=
name|hvap
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_WDS
condition|)
block|{
comment|/* 		 * WDS vaps must have an associated AP vap; find one. 		 * XXX not right. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|apvap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
if|if
condition|(
name|apvap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
name|mvp
operator|->
name|mv_ap_hvap
operator|=
name|MWL_VAP
argument_list|(
name|apvap
argument_list|)
operator|->
name|mv_hvap
expr_stmt|;
break|break;
block|}
name|KASSERT
argument_list|(
name|mvp
operator|->
name|mv_ap_hvap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no ap vap"
operator|)
argument_list|)
expr_stmt|;
block|}
name|vap
operator|=
operator|&
name|mvp
operator|->
name|mv_vap
expr_stmt|;
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
argument_list|,
name|bssid
argument_list|,
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|hvap
operator|!=
name|NULL
condition|)
name|IEEE80211_ADDR_COPY
argument_list|(
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|mac
argument_list|)
expr_stmt|;
comment|/* override with driver methods */
name|mvp
operator|->
name|mv_newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|mwl_newstate
expr_stmt|;
name|vap
operator|->
name|iv_max_keyix
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|vap
operator|->
name|iv_key_alloc
operator|=
name|mwl_key_alloc
expr_stmt|;
name|vap
operator|->
name|iv_key_delete
operator|=
name|mwl_key_delete
expr_stmt|;
name|vap
operator|->
name|iv_key_set
operator|=
name|mwl_key_set
expr_stmt|;
ifdef|#
directive|ifdef
name|MWL_HOST_PS_SUPPORT
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
name|vap
operator|->
name|iv_update_ps
operator|=
name|mwl_update_ps
expr_stmt|;
name|mvp
operator|->
name|mv_set_tim
operator|=
name|vap
operator|->
name|iv_set_tim
expr_stmt|;
name|vap
operator|->
name|iv_set_tim
operator|=
name|mwl_set_tim
expr_stmt|;
block|}
endif|#
directive|endif
name|vap
operator|->
name|iv_reset
operator|=
name|mwl_reset
expr_stmt|;
name|vap
operator|->
name|iv_update_beacon
operator|=
name|mwl_beacon_update
expr_stmt|;
comment|/* override max aid so sta's cannot assoc when we're out of sta id's */
name|vap
operator|->
name|iv_max_aid
operator|=
name|MWL_MAXSTAID
expr_stmt|;
comment|/* override default A-MPDU rx parameters */
name|vap
operator|->
name|iv_ampdu_rxmax
operator|=
name|IEEE80211_HTCAP_MAXRXAMPDU_64K
expr_stmt|;
name|vap
operator|->
name|iv_ampdu_density
operator|=
name|IEEE80211_HTCAP_MPDUDENSITY_4
expr_stmt|;
comment|/* complete setup */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|mwl_media_change
argument_list|,
name|ieee80211_media_status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vap
operator|->
name|iv_opmode
condition|)
block|{
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_MBSS
case|:
case|case
name|IEEE80211_M_STA
case|:
comment|/* 		 * Setup sta db entry for local address. 		 */
name|mwl_localstadb
argument_list|(
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|sc
operator|->
name|sc_napvaps
operator|++
expr_stmt|;
else|else
name|sc
operator|->
name|sc_nstavaps
operator|++
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_WDS
case|:
name|sc
operator|->
name|sc_nwdsvaps
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Setup overall operating mode. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_napvaps
condition|)
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_HOSTAP
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_nstavaps
condition|)
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
else|else
name|ic
operator|->
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
return|return
name|vap
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|mwl_vap
modifier|*
name|mvp
init|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|parent
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|parent
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
name|struct
name|mwl_hal_vap
modifier|*
name|hvap
init|=
name|mvp
operator|->
name|mv_hvap
decl_stmt|;
name|enum
name|ieee80211_opmode
name|opmode
init|=
name|vap
operator|->
name|iv_opmode
decl_stmt|;
comment|/* XXX disallow ap vap delete if WDS still present */
if|if
condition|(
name|parent
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* quiesce h/w while we remove the vap */
name|mwl_hal_intrset
argument_list|(
name|mh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
block|}
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_MBSS
case|:
case|case
name|IEEE80211_M_STA
case|:
name|KASSERT
argument_list|(
name|hvap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no hal vap handle"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mwl_hal_delstation
argument_list|(
name|hvap
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|mwl_hal_delvap
argument_list|(
name|hvap
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|sc
operator|->
name|sc_napvaps
operator|--
expr_stmt|;
else|else
name|sc
operator|->
name|sc_nstavaps
operator|--
expr_stmt|;
comment|/* XXX don't do it for IEEE80211_CLONE_MACADDR */
name|reclaim_address
argument_list|(
name|sc
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_WDS
case|:
name|sc
operator|->
name|sc_nwdsvaps
operator|--
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|mwl_cleartxq
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mvp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|mwl_hal_intrset
argument_list|(
name|mh
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mwl_suspend
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|mwl_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mwl_resume
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|mwl_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mwl_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|mwl_stop
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler.  Most of the actual processing is deferred.  */
end_comment

begin_function
name|void
name|mwl_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_invalid
condition|)
block|{
comment|/* 		 * The hardware is not ready/present, don't touch anything. 		 * Note this can happen early on if the IRQ is shared. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_ANY
argument_list|,
literal|"%s: invalid; ignored\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Figure out the reason(s) for the interrupt. 	 */
name|mwl_hal_getisr
argument_list|(
name|mh
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* NB: clears ISR too */
if|if
condition|(
name|status
operator|==
literal|0
condition|)
comment|/* must be a shared irq */
return|return;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_INTR
argument_list|,
literal|"%s: status 0x%x imask 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MACREG_A2HRIC_BIT_RX_RDY
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MACREG_A2HRIC_BIT_TX_DONE
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MACREG_A2HRIC_BIT_BA_WATCHDOG
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_bawatchdogtask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MACREG_A2HRIC_BIT_OPC_DONE
condition|)
name|mwl_hal_cmddone
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|MACREG_A2HRIC_BIT_MAC_EVENT
condition|)
block|{
empty_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|MACREG_A2HRIC_BIT_ICV_ERROR
condition|)
block|{
comment|/* TKIP ICV error */
name|sc
operator|->
name|sc_stats
operator|.
name|mst_rx_badtkipicv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|MACREG_A2HRIC_BIT_QUEUE_EMPTY
condition|)
block|{
comment|/* 11n aggregation queue is empty, re-fill */
empty_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|MACREG_A2HRIC_BIT_QUEUE_FULL
condition|)
block|{
empty_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|MACREG_A2HRIC_BIT_RADAR_DETECT
condition|)
block|{
comment|/* radar detected, process event */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_radartask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|MACREG_A2HRIC_BIT_CHAN_SWITCH
condition|)
block|{
comment|/* DFS channel switch */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_chanswitchtask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_radar_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_ANY
argument_list|,
literal|"%s: radar detected, pending %u\n"
argument_list|,
name|__func__
argument_list|,
name|pending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_radardetect
operator|++
expr_stmt|;
comment|/* XXX stop h/w BA streams? */
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_dfs_notify_radar
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_chanswitch_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_ANY
argument_list|,
literal|"%s: channel switch notice, pending %u\n"
argument_list|,
name|__func__
argument_list|,
name|pending
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_csapending
operator|=
literal|0
expr_stmt|;
name|ieee80211_csa_completeswitch
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_bawatchdog
parameter_list|(
specifier|const
name|MWL_HAL_BASTREAM
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|sp
operator|->
name|data
index|[
literal|0
index|]
decl_stmt|;
comment|/* send DELBA and drop the stream */
name|ieee80211_ampdu_stop
argument_list|(
name|ni
argument_list|,
name|sp
operator|->
name|data
index|[
literal|1
index|]
argument_list|,
name|IEEE80211_REASON_UNSPECIFIED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_bawatchdog_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
specifier|const
name|MWL_HAL_BASTREAM
modifier|*
name|sp
decl_stmt|;
name|uint8_t
name|bitmap
decl_stmt|,
name|n
decl_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_bawatchdog
operator|++
expr_stmt|;
if|if
condition|(
name|mwl_hal_getwatchdogbitmap
argument_list|(
name|mh
argument_list|,
operator|&
name|bitmap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_AMPDU
argument_list|,
literal|"%s: could not get bitmap\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_bawatchdog_failed
operator|++
expr_stmt|;
return|return;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_AMPDU
argument_list|,
literal|"%s: bitmap 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap
operator|==
literal|0xff
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
comment|/* disable all ba streams */
for|for
control|(
name|bitmap
operator|=
literal|0
init|;
name|bitmap
operator|<
literal|8
condition|;
name|bitmap
operator|++
control|)
block|{
name|sp
operator|=
name|mwl_hal_bastream_lookup
argument_list|(
name|mh
argument_list|,
name|bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|mwl_bawatchdog
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_AMPDU
argument_list|,
literal|"%s: no BA streams found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_bawatchdog_empty
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bitmap
operator|!=
literal|0xaa
condition|)
block|{
comment|/* disable a single ba stream */
name|sp
operator|=
name|mwl_hal_bastream_lookup
argument_list|(
name|mh
argument_list|,
name|bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|mwl_bawatchdog
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_AMPDU
argument_list|,
literal|"%s: no BA stream %d\n"
argument_list|,
name|__func__
argument_list|,
name|bitmap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_bawatchdog_notfound
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Convert net80211 channel to a HAL channel.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_mapchan
parameter_list|(
name|MWL_HAL_CHANNEL
modifier|*
name|hc
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|hc
operator|->
name|channel
operator|=
name|chan
operator|->
name|ic_ieee
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|hc
operator|->
name|channelFlags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|hc
operator|->
name|channelFlags
operator|.
name|FreqBand
operator|=
name|MWL_FREQ_BAND_2DOT4GHZ
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|hc
operator|->
name|channelFlags
operator|.
name|FreqBand
operator|=
name|MWL_FREQ_BAND_5GHZ
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|hc
operator|->
name|channelFlags
operator|.
name|ChnlWidth
operator|=
name|MWL_CH_40_MHz_WIDTH
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|chan
argument_list|)
condition|)
name|hc
operator|->
name|channelFlags
operator|.
name|ExtChnlOffset
operator|=
name|MWL_EXT_CH_ABOVE_CTRL_CH
expr_stmt|;
else|else
name|hc
operator|->
name|channelFlags
operator|.
name|ExtChnlOffset
operator|=
name|MWL_EXT_CH_BELOW_CTRL_CH
expr_stmt|;
block|}
else|else
name|hc
operator|->
name|channelFlags
operator|.
name|ChnlWidth
operator|=
name|MWL_CH_20_MHz_WIDTH
expr_stmt|;
comment|/* XXX 10MHz channels */
block|}
end_function

begin_comment
comment|/*  * Inform firmware of our tx/rx dma setup.  The BAR 0  * writes below are for compatibility with older firmware.  * For current firmware we send this information with a  * cmd block via mwl_hal_sethwdma.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_setupdma
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|sc
operator|->
name|sc_hwdma
operator|.
name|rxDescRead
operator|=
name|sc
operator|->
name|sc_rxdma
operator|.
name|dd_desc_paddr
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_hwspecs
operator|.
name|rxDescRead
argument_list|,
name|sc
operator|->
name|sc_hwdma
operator|.
name|rxDescRead
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_hwspecs
operator|.
name|rxDescWrite
argument_list|,
name|sc
operator|->
name|sc_hwdma
operator|.
name|rxDescRead
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MWL_NUM_TX_QUEUES
operator|-
name|MWL_NUM_ACK_QUEUES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mwl_txq
modifier|*
name|txq
init|=
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
decl_stmt|;
name|sc
operator|->
name|sc_hwdma
operator|.
name|wcbBase
index|[
name|i
index|]
operator|=
name|txq
operator|->
name|dma
operator|.
name|dd_desc_paddr
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_hwspecs
operator|.
name|wcbBase
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|sc_hwdma
operator|.
name|wcbBase
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_hwdma
operator|.
name|maxNumTxWcb
operator|=
name|mwl_txbuf
expr_stmt|;
name|sc
operator|->
name|sc_hwdma
operator|.
name|maxNumWCB
operator|=
name|MWL_NUM_TX_QUEUES
operator|-
name|MWL_NUM_ACK_QUEUES
expr_stmt|;
name|error
operator|=
name|mwl_hal_sethwdma
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
operator|&
name|sc
operator|->
name|sc_hwdma
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to setup tx/rx dma; hal status %u\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Inform firmware of tx rate parameters.  * Called after a channel change.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_setcurchanrates
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|MWL_HAL_TXRATE
name|rates
decl_stmt|;
name|memset
argument_list|(
operator|&
name|rates
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rates
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|=
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* rate used to send management frames */
name|rates
operator|.
name|MgtRate
operator|=
name|rs
operator|->
name|rs_rates
index|[
literal|0
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
comment|/* rate used to send multicast frames */
name|rates
operator|.
name|McastRate
operator|=
name|rates
operator|.
name|MgtRate
expr_stmt|;
return|return
name|mwl_hal_settxrate_auto
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
operator|&
name|rates
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Inform firmware of tx rate parameters.  Called whenever  * user-settable params change and after a channel change.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_setrates
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|mwl_vap
modifier|*
name|mvp
init|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
init|=
name|ni
operator|->
name|ni_txparms
decl_stmt|;
name|MWL_HAL_TXRATE
name|rates
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
argument_list|,
operator|(
literal|"state %d"
operator|,
name|vap
operator|->
name|iv_state
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update the h/w rate map. 	 * NB: 0x80 for MCS is passed through unchanged 	 */
name|memset
argument_list|(
operator|&
name|rates
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rates
argument_list|)
argument_list|)
expr_stmt|;
comment|/* rate used to send management frames */
name|rates
operator|.
name|MgtRate
operator|=
name|tp
operator|->
name|mgmtrate
expr_stmt|;
comment|/* rate used to send multicast frames */
name|rates
operator|.
name|McastRate
operator|=
name|tp
operator|->
name|mcastrate
expr_stmt|;
comment|/* while here calculate EAPOL fixed rate cookie */
name|mvp
operator|->
name|mv_eapolformat
operator|=
name|htole16
argument_list|(
name|mwl_calcformat
argument_list|(
name|rates
operator|.
name|MgtRate
argument_list|,
name|ni
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mwl_hal_settxrate
argument_list|(
name|mvp
operator|->
name|mv_hvap
argument_list|,
name|tp
operator|->
name|ucastrate
operator|!=
name|IEEE80211_FIXED_RATE_NONE
condition|?
name|RATE_FIXED
else|:
name|RATE_AUTO
argument_list|,
operator|&
name|rates
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup a fixed xmit rate cookie for EAPOL frames.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_seteapolformat
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|mwl_vap
modifier|*
name|mvp
init|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
argument_list|,
operator|(
literal|"state %d"
operator|,
name|vap
operator|->
name|iv_state
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
comment|/* 	 * Use legacy rates when operating a mixed HT+non-HT bss. 	 * NB: this may violate POLA for sta and wds vap's. 	 */
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11NA
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_PUREN
operator|)
operator|==
literal|0
condition|)
name|rate
operator|=
name|vap
operator|->
name|iv_txparms
index|[
name|IEEE80211_MODE_11A
index|]
operator|.
name|mgmtrate
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11NG
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_PUREN
operator|)
operator|==
literal|0
condition|)
name|rate
operator|=
name|vap
operator|->
name|iv_txparms
index|[
name|IEEE80211_MODE_11G
index|]
operator|.
name|mgmtrate
expr_stmt|;
else|else
name|rate
operator|=
name|vap
operator|->
name|iv_txparms
index|[
name|mode
index|]
operator|.
name|mgmtrate
expr_stmt|;
name|mvp
operator|->
name|mv_eapolformat
operator|=
name|htole16
argument_list|(
name|mwl_calcformat
argument_list|(
name|rate
argument_list|,
name|ni
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map SKU+country code to region code for radar bin'ing.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_map2regioncode
parameter_list|(
specifier|const
name|struct
name|ieee80211_regdomain
modifier|*
name|rd
parameter_list|)
block|{
switch|switch
condition|(
name|rd
operator|->
name|regdomain
condition|)
block|{
case|case
name|SKU_FCC
case|:
case|case
name|SKU_FCC3
case|:
return|return
name|DOMAIN_CODE_FCC
return|;
case|case
name|SKU_CA
case|:
return|return
name|DOMAIN_CODE_IC
return|;
case|case
name|SKU_ETSI
case|:
case|case
name|SKU_ETSI2
case|:
case|case
name|SKU_ETSI3
case|:
if|if
condition|(
name|rd
operator|->
name|country
operator|==
name|CTRY_SPAIN
condition|)
return|return
name|DOMAIN_CODE_SPAIN
return|;
if|if
condition|(
name|rd
operator|->
name|country
operator|==
name|CTRY_FRANCE
operator|||
name|rd
operator|->
name|country
operator|==
name|CTRY_FRANCE2
condition|)
return|return
name|DOMAIN_CODE_FRANCE
return|;
comment|/* XXX force 1.3.1 radar type */
return|return
name|DOMAIN_CODE_ETSI_131
return|;
case|case
name|SKU_JAPAN
case|:
return|return
name|DOMAIN_CODE_MKK
return|;
case|case
name|SKU_ROW
case|:
return|return
name|DOMAIN_CODE_DGT
return|;
comment|/* Taiwan */
case|case
name|SKU_APAC
case|:
case|case
name|SKU_APAC2
case|:
case|case
name|SKU_APAC3
case|:
return|return
name|DOMAIN_CODE_AUS
return|;
comment|/* Australia */
block|}
comment|/* XXX KOREA? */
return|return
name|DOMAIN_CODE_FCC
return|;
comment|/* XXX? */
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_hal_reset
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
name|mwl_hal_setantenna
argument_list|(
name|mh
argument_list|,
name|WL_ANTENNATYPE_RX
argument_list|,
name|sc
operator|->
name|sc_rxantenna
argument_list|)
expr_stmt|;
name|mwl_hal_setantenna
argument_list|(
name|mh
argument_list|,
name|WL_ANTENNATYPE_TX
argument_list|,
name|sc
operator|->
name|sc_txantenna
argument_list|)
expr_stmt|;
name|mwl_hal_setradio
argument_list|(
name|mh
argument_list|,
literal|1
argument_list|,
name|WL_AUTO_PREAMBLE
argument_list|)
expr_stmt|;
name|mwl_hal_setwmm
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|mwl_chan_set
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* NB: RF/RA performance tuned for indoor mode */
name|mwl_hal_setrateadaptmode
argument_list|(
name|mh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mwl_hal_setoptimizationlevel
argument_list|(
name|mh
argument_list|,
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_BURST
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|mwl_hal_setregioncode
argument_list|(
name|mh
argument_list|,
name|mwl_map2regioncode
argument_list|(
operator|&
name|ic
operator|->
name|ic_regdomain
argument_list|)
argument_list|)
expr_stmt|;
name|mwl_hal_setaggampduratemode
argument_list|(
name|mh
argument_list|,
literal|1
argument_list|,
literal|80
argument_list|)
expr_stmt|;
comment|/* XXX */
name|mwl_hal_setcfend
argument_list|(
name|mh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_init_locked
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_ANY
argument_list|,
literal|"%s: if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|MWL_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Stop anything previously setup.  This is safe 	 * whether this is the first time through or not. 	 */
name|mwl_stop_locked
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Push vap-independent state to the firmware. 	 */
if|if
condition|(
operator|!
name|mwl_hal_reset
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to reset hardware\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* 	 * Setup recv (once); transmit is already good to go. 	 */
name|error
operator|=
name|mwl_startrecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to start recv logic\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Enable interrupts. 	 */
name|sc
operator|->
name|sc_imask
operator|=
name|MACREG_A2HRIC_BIT_RX_RDY
operator||
name|MACREG_A2HRIC_BIT_TX_DONE
operator||
name|MACREG_A2HRIC_BIT_OPC_DONE
if|#
directive|if
literal|0
expr|| MACREG_A2HRIC_BIT_MAC_EVENT
endif|#
directive|endif
operator||
name|MACREG_A2HRIC_BIT_ICV_ERROR
operator||
name|MACREG_A2HRIC_BIT_RADAR_DETECT
operator||
name|MACREG_A2HRIC_BIT_CHAN_SWITCH
if|#
directive|if
literal|0
expr|| MACREG_A2HRIC_BIT_QUEUE_EMPTY
endif|#
directive|endif
operator||
name|MACREG_A2HRIC_BIT_BA_WATCHDOG
operator||
name|MACREQ_A2HRIC_BIT_TX_ACK
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|mwl_hal_intrset
argument_list|(
name|mh
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_ANY
argument_list|,
literal|"%s: if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|MWL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mwl_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|MWL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* start all vap's */
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_stop_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|disable
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_ANY
argument_list|,
literal|"%s: invalid %u if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_invalid
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|MWL_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* 		 * Shutdown the hardware and driver. 		 */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|mwl_draintxq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|disable
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|MWL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mwl_stop_locked
argument_list|(
name|ifp
argument_list|,
name|disable
argument_list|)
expr_stmt|;
name|MWL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_reset_vap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|mwl_hal_vap
modifier|*
name|hvap
init|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_hvap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|IEEE80211_S_RUN
condition|)
name|mwl_setrates
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* XXX off by 1? */
name|mwl_hal_setrtsthreshold
argument_list|(
name|hvap
argument_list|,
name|vap
operator|->
name|iv_rtsthreshold
argument_list|)
expr_stmt|;
comment|/* XXX auto? 20/40 split? */
name|mwl_hal_sethtgi
argument_list|(
name|hvap
argument_list|,
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
operator|(
name|IEEE80211_FHT_SHORTGI20
operator||
name|IEEE80211_FHT_SHORTGI40
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|mwl_hal_setnprot
argument_list|(
name|hvap
argument_list|,
name|ic
operator|->
name|ic_htprotmode
operator|==
name|IEEE80211_PROT_NONE
condition|?
name|HTPROTECT_NONE
else|:
name|HTPROTECT_AUTO
argument_list|)
expr_stmt|;
comment|/* XXX txpower cap */
comment|/* re-setup beacons */
if|if
condition|(
name|state
operator|==
name|IEEE80211_S_RUN
operator|&&
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|)
condition|)
block|{
name|mwl_setapmode
argument_list|(
name|vap
argument_list|,
name|vap
operator|->
name|iv_bss
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|mwl_hal_setnprotmode
argument_list|(
name|hvap
argument_list|,
name|MS
argument_list|(
name|ic
operator|->
name|ic_curhtprotmode
argument_list|,
name|IEEE80211_HTINFO_OPMODE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mwl_beacon_setup
argument_list|(
name|vap
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reset the hardware w/o losing operational state.  * Used to to reset or reload hardware state for a vap.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_reset
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|u_long
name|cmd
parameter_list|)
block|{
name|struct
name|mwl_hal_vap
modifier|*
name|hvap
init|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_hvap
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hvap
operator|!=
name|NULL
condition|)
block|{
comment|/* WDS, MONITOR, etc. */
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
comment|/* XXX handle DWDS sta vap change */
comment|/* XXX do we need to disable interrupts? */
name|mwl_hal_intrset
argument_list|(
name|mh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|error
operator|=
name|mwl_reset_vap
argument_list|(
name|vap
argument_list|,
name|vap
operator|->
name|iv_state
argument_list|)
expr_stmt|;
name|mwl_hal_intrset
argument_list|(
name|mh
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a tx buffer for sending a frame.  The  * packet is assumed to have the WME AC stored so  * we can use it to select the appropriate h/w queue.  */
end_comment

begin_function
specifier|static
name|struct
name|mwl_txbuf
modifier|*
name|mwl_gettxbuf
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mwl_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|mwl_txbuf
modifier|*
name|bf
decl_stmt|;
comment|/* 	 * Grab a TX buffer and associated resources. 	 */
name|MWL_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|txq
operator|->
name|nfree
operator|--
expr_stmt|;
block|}
name|MWL_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_XMIT
argument_list|,
literal|"%s: out of xmit buffers on q %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|qnum
argument_list|)
expr_stmt|;
return|return
name|bf
return|;
block|}
end_function

begin_comment
comment|/*  * Return a tx buffer to the queue it came from.  Note there  * are two cases because we must preserve the order of buffers  * as it reflects the fixed order of descriptors in memory  * (the firmware pre-fetches descriptors so we cannot reorder).  */
end_comment

begin_function
specifier|static
name|void
name|mwl_puttxbuf_head
parameter_list|(
name|struct
name|mwl_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mwl_txbuf
modifier|*
name|bf
parameter_list|)
block|{
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|MWL_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|txq
operator|->
name|nfree
operator|++
expr_stmt|;
name|MWL_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_puttxbuf_tail
parameter_list|(
name|struct
name|mwl_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mwl_txbuf
modifier|*
name|bf
parameter_list|)
block|{
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|MWL_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|txq
operator|->
name|nfree
operator|++
expr_stmt|;
name|MWL_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mwl_txbuf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mwl_txq
modifier|*
name|txq
init|=
name|NULL
decl_stmt|;
comment|/* XXX silence gcc */
name|int
name|nqueued
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_invalid
condition|)
return|return;
name|nqueued
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bf
operator|=
name|NULL
expr_stmt|;
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Grab the node for the destination. 		 */
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no node"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
comment|/* committed, clear ref */
comment|/* 		 * Grab a TX buffer and associated resources. 		 * We honor the classification by the 802.11 layer. 		 */
name|txq
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
index|]
expr_stmt|;
name|bf
operator|=
name|mwl_gettxbuf
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MWL_TX_NODROP
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_qstop
operator|++
expr_stmt|;
comment|/* XXX blocks other traffic */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
else|#
directive|else
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_XMIT
argument_list|,
literal|"%s: tail drop on q %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|qnum
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_qdrop
operator|++
expr_stmt|;
continue|continue;
endif|#
directive|endif
comment|/* MWL_TX_NODROP */
block|}
comment|/* 		 * Pass the frame to the h/w for transmission. 		 */
if|if
condition|(
name|mwl_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|mwl_puttxbuf_head
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nqueued
operator|++
expr_stmt|;
if|if
condition|(
name|nqueued
operator|>=
name|mwl_txcoalesce
condition|)
block|{
comment|/* 			 * Poke the firmware to process queued frames; 			 * see below about (lack of) locking. 			 */
name|nqueued
operator|=
literal|0
expr_stmt|;
name|mwl_hal_txstart
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
literal|0
comment|/*XXX*/
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nqueued
condition|)
block|{
comment|/* 		 * NB: We don't need to lock against tx done because 		 * this just prods the firmware to check the transmit 		 * descriptors.  The firmware will also start fetching 		 * descriptors by itself if it notices new ones are 		 * present when it goes to deliver a tx done interrupt 		 * to the host. So if we race with tx done processing 		 * it's ok.  Delivering the kick here rather than in 		 * mwl_tx_start is an optimization to avoid poking the 		 * firmware for each packet. 		 * 		 * NB: the queue id isn't used so 0 is ok. 		 */
name|mwl_hal_txstart
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
literal|0
comment|/*XXX*/
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mwl_txbuf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mwl_txq
modifier|*
name|txq
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_invalid
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
comment|/* 	 * Grab a TX buffer and associated resources. 	 * Note that we depend on the classification 	 * by the 802.11 layer to get to the right h/w 	 * queue.  Management frames must ALWAYS go on 	 * queue 1 but we cannot just force that here 	 * because we may receive non-mgt frames. 	 */
name|txq
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
index|]
expr_stmt|;
name|bf
operator|=
name|mwl_gettxbuf
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_qstop
operator|++
expr_stmt|;
comment|/* XXX blocks other traffic */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* 	 * Pass the frame to the h/w for transmission. 	 */
if|if
condition|(
name|mwl_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|mwl_puttxbuf_head
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
comment|/* XXX */
block|}
comment|/* 	 * NB: We don't need to lock against tx done because 	 * this just prods the firmware to check the transmit 	 * descriptors.  The firmware will also start fetching 	 * descriptors by itself if it notices new ones are 	 * present when it goes to deliver a tx done interrupt 	 * to the host. So if we race with tx done processing 	 * it's ok.  Delivering the kick here rather than in 	 * mwl_tx_start is an optimization to avoid poking the 	 * firmware for each packet. 	 * 	 * NB: the queue id isn't used so 0 is ok. 	 */
name|mwl_hal_txstart
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
literal|0
comment|/*XXX*/
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ieee80211_media_change
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* NB: only the fixed rate can change and that doesn't need a reset */
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
name|mwl_setrates
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MWL_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|mwl_keyprint
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
specifier|const
name|MWL_HAL_KEYVAL
modifier|*
name|hk
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|ciphers
index|[]
init|=
block|{
literal|"WEP"
block|,
literal|"TKIP"
block|,
literal|"AES-CCM"
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|printf
argument_list|(
literal|"%s: [%u] %-7s"
argument_list|,
name|tag
argument_list|,
name|hk
operator|->
name|keyIndex
argument_list|,
name|ciphers
index|[
name|hk
operator|->
name|keyTypeId
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
name|hk
operator|->
name|keyLen
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|hk
operator|->
name|key
operator|.
name|aes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" mac %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|mac
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hk
operator|->
name|keyTypeId
operator|==
name|KEY_TYPE_ID_TKIP
condition|)
block|{
name|printf
argument_list|(
literal|" %s"
argument_list|,
literal|"rxmic"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|key
operator|.
name|tkip
operator|.
name|rxMic
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|hk
operator|->
name|key
operator|.
name|tkip
operator|.
name|rxMic
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" txmic"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|key
operator|.
name|tkip
operator|.
name|txMic
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|hk
operator|->
name|key
operator|.
name|tkip
operator|.
name|txMic
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" flags 0x%x\n"
argument_list|,
name|hk
operator|->
name|keyFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allocate a key cache slot for a unicast key.  The  * firmware handles key allocation and every station is  * guaranteed key space so we are always successful.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_key_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|ieee80211_keyix
modifier|*
name|keyix
parameter_list|,
name|ieee80211_keyix
modifier|*
name|rxkeyix
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|k
operator|->
name|wk_keyix
operator|!=
name|IEEE80211_KEYIX_NONE
operator|||
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_GROUP
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
literal|0
index|]
operator|<=
name|k
operator|&&
name|k
operator|<
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
name|IEEE80211_WEP_NKID
index|]
operator|)
condition|)
block|{
comment|/* should not happen */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: bogus group key\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* give the caller what they requested */
operator|*
name|keyix
operator|=
operator|*
name|rxkeyix
operator|=
name|k
operator|-
name|vap
operator|->
name|iv_nw_keys
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Firmware handles key allocation. 		 */
operator|*
name|keyix
operator|=
operator|*
name|rxkeyix
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a key entry allocated by mwl_key_alloc.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_key_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mwl_hal_vap
modifier|*
name|hvap
init|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_hvap
decl_stmt|;
name|MWL_HAL_KEYVAL
name|hk
decl_stmt|;
specifier|const
name|uint8_t
name|bcastaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
if|if
condition|(
name|hvap
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_WDS
condition|)
block|{
comment|/* XXX monitor mode? */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: no hvap for opmode %d\n"
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_opmode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|hvap
operator|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_ap_hvap
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: delete key %u\n"
argument_list|,
name|__func__
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
argument_list|)
argument_list|)
expr_stmt|;
name|hk
operator|.
name|keyIndex
operator|=
name|k
operator|->
name|wk_keyix
expr_stmt|;
switch|switch
condition|(
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
condition|)
block|{
case|case
name|IEEE80211_CIPHER_WEP
case|:
name|hk
operator|.
name|keyTypeId
operator|=
name|KEY_TYPE_ID_WEP
expr_stmt|;
break|break;
case|case
name|IEEE80211_CIPHER_TKIP
case|:
name|hk
operator|.
name|keyTypeId
operator|=
name|KEY_TYPE_ID_TKIP
expr_stmt|;
break|break;
case|case
name|IEEE80211_CIPHER_AES_CCM
case|:
name|hk
operator|.
name|keyTypeId
operator|=
name|KEY_TYPE_ID_AES
expr_stmt|;
break|break;
default|default:
comment|/* XXX should not happen */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: unknown cipher %d\n"
argument_list|,
name|__func__
argument_list|,
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
name|mwl_hal_keyreset
argument_list|(
name|hvap
argument_list|,
operator|&
name|hk
argument_list|,
name|bcastaddr
argument_list|)
operator|==
literal|0
operator|)
return|;
comment|/*XXX*/
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|addgroupflags
parameter_list|(
name|MWL_HAL_KEYVAL
modifier|*
name|hk
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|)
block|{
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_GROUP
condition|)
block|{
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_XMIT
condition|)
name|hk
operator|->
name|keyFlags
operator||=
name|KEY_FLAG_TXGROUPKEY
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_RECV
condition|)
name|hk
operator|->
name|keyFlags
operator||=
name|KEY_FLAG_RXGROUPKEY
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Set the key cache contents for the specified key.  Key cache  * slot(s) must already have been allocated by mwl_key_alloc.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_key_set
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
define|#
directive|define
name|GRPXMIT
value|(IEEE80211_KEY_XMIT | IEEE80211_KEY_GROUP)
comment|/* NB: static wep keys are marked GROUP+tx/rx; GTK will be tx or rx */
define|#
directive|define
name|IEEE80211_IS_STATICKEY
parameter_list|(
name|k
parameter_list|)
define|\
value|(((k)->wk_flags& (GRPXMIT|IEEE80211_KEY_RECV)) == \ 	 (GRPXMIT|IEEE80211_KEY_RECV))
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mwl_hal_vap
modifier|*
name|hvap
init|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_hvap
decl_stmt|;
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
init|=
name|k
operator|->
name|wk_cipher
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|macaddr
decl_stmt|;
name|MWL_HAL_KEYVAL
name|hk
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWCRYPT
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"s/w crypto set?"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hvap
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_WDS
condition|)
block|{
comment|/* XXX monitor mode? */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: no hvap for opmode %d\n"
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_opmode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|hvap
operator|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_ap_hvap
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|hk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
argument_list|)
argument_list|)
expr_stmt|;
name|hk
operator|.
name|keyIndex
operator|=
name|k
operator|->
name|wk_keyix
expr_stmt|;
switch|switch
condition|(
name|cip
operator|->
name|ic_cipher
condition|)
block|{
case|case
name|IEEE80211_CIPHER_WEP
case|:
name|hk
operator|.
name|keyTypeId
operator|=
name|KEY_TYPE_ID_WEP
expr_stmt|;
name|hk
operator|.
name|keyLen
operator|=
name|k
operator|->
name|wk_keylen
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|wk_keyix
operator|==
name|vap
operator|->
name|iv_def_txkey
condition|)
name|hk
operator|.
name|keyFlags
operator|=
name|KEY_FLAG_WEP_TXKEY
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_STATICKEY
argument_list|(
name|k
argument_list|)
condition|)
block|{
comment|/* NB: WEP is never used for the PTK */
operator|(
name|void
operator|)
name|addgroupflags
argument_list|(
operator|&
name|hk
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_CIPHER_TKIP
case|:
name|hk
operator|.
name|keyTypeId
operator|=
name|KEY_TYPE_ID_TKIP
expr_stmt|;
name|hk
operator|.
name|key
operator|.
name|tkip
operator|.
name|tsc
operator|.
name|high
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|k
operator|->
name|wk_keytsc
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|hk
operator|.
name|key
operator|.
name|tkip
operator|.
name|tsc
operator|.
name|low
operator|=
operator|(
name|uint16_t
operator|)
name|k
operator|->
name|wk_keytsc
expr_stmt|;
name|hk
operator|.
name|keyFlags
operator|=
name|KEY_FLAG_TSC_VALID
operator||
name|KEY_FLAG_MICKEY_VALID
expr_stmt|;
name|hk
operator|.
name|keyLen
operator|=
name|k
operator|->
name|wk_keylen
operator|+
name|IEEE80211_MICBUF_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|addgroupflags
argument_list|(
operator|&
name|hk
argument_list|,
name|k
argument_list|)
condition|)
name|hk
operator|.
name|keyFlags
operator||=
name|KEY_FLAG_PAIRWISE
expr_stmt|;
break|break;
case|case
name|IEEE80211_CIPHER_AES_CCM
case|:
name|hk
operator|.
name|keyTypeId
operator|=
name|KEY_TYPE_ID_AES
expr_stmt|;
name|hk
operator|.
name|keyLen
operator|=
name|k
operator|->
name|wk_keylen
expr_stmt|;
if|if
condition|(
operator|!
name|addgroupflags
argument_list|(
operator|&
name|hk
argument_list|,
name|k
argument_list|)
condition|)
name|hk
operator|.
name|keyFlags
operator||=
name|KEY_FLAG_PAIRWISE
expr_stmt|;
break|break;
default|default:
comment|/* XXX should not happen */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: unknown cipher %d\n"
argument_list|,
name|__func__
argument_list|,
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * NB: tkip mic keys get copied here too; the layout 	 *     just happens to match that in ieee80211_key. 	 */
name|memcpy
argument_list|(
name|hk
operator|.
name|key
operator|.
name|aes
argument_list|,
name|k
operator|->
name|wk_key
argument_list|,
name|hk
operator|.
name|keyLen
argument_list|)
expr_stmt|;
comment|/* 	 * Locate address of sta db entry for writing key; 	 * the convention unfortunately is somewhat different 	 * than how net80211, hostapd, and wpa_supplicant think. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
comment|/* 		 * NB: keys plumbed before the sta reaches AUTH state 		 * will be discarded or written to the wrong sta db 		 * entry because iv_bss is meaningless.  This is ok 		 * (right now) because we handle deferred plumbing of 		 * WEP keys when the sta reaches AUTH state. 		 */
name|macaddr
operator|=
name|vap
operator|->
name|iv_bss
operator|->
name|ni_bssid
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_GROUP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX plumb to local sta db too for static key wep */
name|mwl_hal_keyset
argument_list|(
name|hvap
argument_list|,
operator|&
name|hk
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_WDS
operator|&&
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* 		 * Prior to RUN state a WDS vap will not it's BSS node 		 * setup so we will plumb the key to the wrong mac 		 * address (it'll be our local address).  Workaround 		 * this for the moment by grabbing the correct address. 		 */
name|macaddr
operator|=
name|vap
operator|->
name|iv_des_bssid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|GRPXMIT
operator|)
operator|==
name|GRPXMIT
condition|)
name|macaddr
operator|=
name|vap
operator|->
name|iv_myaddr
expr_stmt|;
else|else
name|macaddr
operator|=
name|mac
expr_stmt|;
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
operator|&
name|hk
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|mwl_hal_keyset
argument_list|(
name|hvap
argument_list|,
operator|&
name|hk
argument_list|,
name|macaddr
argument_list|)
operator|==
literal|0
operator|)
return|;
undef|#
directive|undef
name|IEEE80211_IS_STATICKEY
undef|#
directive|undef
name|GRPXMIT
block|}
end_function

begin_comment
comment|/* unaligned little endian access */
end_comment

begin_define
define|#
directive|define
name|LE_READ_2
parameter_list|(
name|p
parameter_list|)
define|\
value|((uint16_t)				\ 	 ((((const uint8_t *)(p))[0]      ) |	\ 	  (((const uint8_t *)(p))[1]<<  8)))
end_define

begin_define
define|#
directive|define
name|LE_READ_4
parameter_list|(
name|p
parameter_list|)
define|\
value|((uint32_t)				\ 	 ((((const uint8_t *)(p))[0]      ) |	\ 	  (((const uint8_t *)(p))[1]<<  8) |	\ 	  (((const uint8_t *)(p))[2]<< 16) |	\ 	  (((const uint8_t *)(p))[3]<< 24)))
end_define

begin_comment
comment|/*  * Set the multicast filter contents into the hardware.  * XXX f/w has no support; just defer to the os.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_setmcastfilter
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|#
directive|if
literal|0
block|struct ether_multi *enm; 	struct ether_multistep estep; 	uint8_t macs[IEEE80211_ADDR_LEN*MWL_HAL_MCAST_MAX];
comment|/* XXX stack use */
block|uint8_t *mp; 	int nmc;  	mp = macs; 	nmc = 0; 	ETHER_FIRST_MULTI(estep,&sc->sc_ec, enm); 	while (enm != NULL) {
comment|/* XXX Punt on ranges. */
block|if (nmc == MWL_HAL_MCAST_MAX || 		    !IEEE80211_ADDR_EQ(enm->enm_addrlo, enm->enm_addrhi)) { 			ifp->if_flags |= IFF_ALLMULTI; 			return; 		} 		IEEE80211_ADDR_COPY(mp, enm->enm_addrlo); 		mp += IEEE80211_ADDR_LEN, nmc++; 		ETHER_NEXT_MULTI(estep, enm); 	} 	ifp->if_flags&= ~IFF_ALLMULTI; 	mwl_hal_setmcast(sc->sc_mh, nmc, macs);
else|#
directive|else
comment|/* XXX no mcast filter support; we get everything */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_mode_init
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
comment|/* 	 * NB: Ignore promisc in hostap mode; it's set by the 	 * bridge.  This is wrong but we have no way to 	 * identify internal requests (from the bridge) 	 * versus external requests such as for tcpdump. 	 */
name|mwl_hal_setpromisc
argument_list|(
name|mh
argument_list|,
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_HOSTAP
argument_list|)
expr_stmt|;
name|mwl_setmcastfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Callback from the 802.11 layer after a multicast state change.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|mwl_setmcastfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from the 802.11 layer after a promiscuous mode change.  * Note this interface does not check the operating mode as this  * is an internal callback and we are expected to honor the current  * state (e.g. this is used for setting the interface in promiscuous  * mode when operating in hostap mode to do ACS).  */
end_comment

begin_function
specifier|static
name|void
name|mwl_update_promisc
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|mwl_hal_setpromisc
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from the 802.11 layer to update the slot time  * based on the current setting.  We use it to notify the  * firmware of ERP changes and the f/w takes care of things  * like slot time and preamble.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_updateslot
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
name|int
name|prot
decl_stmt|;
comment|/* NB: can be called early; suppress needless cmds */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Calculate the ERP flags.  The firwmare will use 	 * this to carry out the appropriate measures. 	 */
name|prot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
operator|)
operator|==
literal|0
condition|)
name|prot
operator||=
name|IEEE80211_ERP_NON_ERP_PRESENT
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
condition|)
name|prot
operator||=
name|IEEE80211_ERP_USE_PROTECTION
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEBARKER
condition|)
name|prot
operator||=
name|IEEE80211_ERP_LONG_PREAMBLE
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_RESET
argument_list|,
literal|"%s: chan %u MHz/flags 0x%x %s slot, (prot 0x%x ic_flags 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_freq
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_flags
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|prot
argument_list|,
name|ic
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|mwl_hal_setgprot
argument_list|(
name|mh
argument_list|,
name|prot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup the beacon frame.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_beacon_setup
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|mwl_hal_vap
modifier|*
name|hvap
init|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_hvap
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|ieee80211_beacon_offsets
name|bo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|ieee80211_beacon_alloc
argument_list|(
name|ni
argument_list|,
operator|&
name|bo
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
name|mwl_hal_setbeacon
argument_list|(
name|hvap
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Update the beacon frame in response to a change.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_beacon_update
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|item
parameter_list|)
block|{
name|struct
name|mwl_hal_vap
modifier|*
name|hvap
init|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_hvap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|KASSERT
argument_list|(
name|hvap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no beacon"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|item
condition|)
block|{
case|case
name|IEEE80211_BEACON_ERP
case|:
name|mwl_updateslot
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_BEACON_HTINFO
case|:
name|mwl_hal_setnprotmode
argument_list|(
name|hvap
argument_list|,
name|MS
argument_list|(
name|ic
operator|->
name|ic_curhtprotmode
argument_list|,
name|IEEE80211_HTINFO_OPMODE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_BEACON_CAPS
case|:
case|case
name|IEEE80211_BEACON_WME
case|:
case|case
name|IEEE80211_BEACON_APPIE
case|:
case|case
name|IEEE80211_BEACON_CSA
case|:
break|break;
case|case
name|IEEE80211_BEACON_TIM
case|:
comment|/* NB: firmware always forms TIM */
return|return;
block|}
comment|/* XXX retain beacon frame and update */
name|mwl_beacon_setup
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_load_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"error %u on bus_dma callback"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MWL_HOST_PS_SUPPORT
end_ifdef

begin_comment
comment|/*  * Handle power save station occupancy changes.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_update_ps
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|nsta
parameter_list|)
block|{
name|struct
name|mwl_vap
modifier|*
name|mvp
init|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
if|if
condition|(
name|nsta
operator|==
literal|0
operator|||
name|mvp
operator|->
name|mv_last_ps_sta
operator|==
literal|0
condition|)
name|mwl_hal_setpowersave_bss
argument_list|(
name|mvp
operator|->
name|mv_hvap
argument_list|,
name|nsta
argument_list|)
expr_stmt|;
name|mvp
operator|->
name|mv_last_ps_sta
operator|=
name|nsta
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle associated station power save state changes.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_set_tim
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|mwl_vap
modifier|*
name|mvp
init|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
if|if
condition|(
name|mvp
operator|->
name|mv_set_tim
argument_list|(
name|ni
argument_list|,
name|set
argument_list|)
condition|)
block|{
comment|/* NB: state change */
name|mwl_hal_setpowersave_sta
argument_list|(
name|mvp
operator|->
name|mv_hvap
argument_list|,
name|IEEE80211_AID
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|)
argument_list|,
name|set
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MWL_HOST_PS_SUPPORT */
end_comment

begin_function
specifier|static
name|int
name|mwl_desc_setup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|mwl_descdma
modifier|*
name|dd
parameter_list|,
name|int
name|nbuf
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|int
name|ndesc
parameter_list|,
name|size_t
name|descsize
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint8_t
modifier|*
name|ds
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_RESET
argument_list|,
literal|"%s: %s DMA: %u bufs (%ju) %u desc/buf (%ju)\n"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|,
name|nbuf
argument_list|,
operator|(
name|uintmax_t
operator|)
name|bufsize
argument_list|,
name|ndesc
argument_list|,
operator|(
name|uintmax_t
operator|)
name|descsize
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_name
operator|=
name|name
expr_stmt|;
name|dd
operator|->
name|dd_desc_len
operator|=
name|nbuf
operator|*
name|ndesc
operator|*
name|descsize
expr_stmt|;
comment|/* 	 * Setup DMA descriptor area. 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|dd
operator|->
name|dd_desc_len
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|dd
operator|->
name|dd_desc_len
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"cannot allocate %s DMA tag\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* allocate descriptors */
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to create dmamap for %s descriptors, "
literal|"error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail0
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dd
operator|->
name|dd_desc
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to alloc memory for %u %s descriptors, "
literal|"error %u\n"
argument_list|,
name|nbuf
operator|*
name|ndesc
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_desc_len
argument_list|,
name|mwl_load_cb
argument_list|,
operator|&
name|dd
operator|->
name|dd_desc_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to map %s descriptors, error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|ds
operator|=
name|dd
operator|->
name|dd_desc
expr_stmt|;
name|memset
argument_list|(
name|ds
argument_list|,
literal|0
argument_list|,
name|dd
operator|->
name|dd_desc_len
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_RESET
argument_list|,
literal|"%s: %s DMA map: %p (%lu) -> %p (%lu)\n"
argument_list|,
name|__func__
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|ds
argument_list|,
operator|(
name|u_long
operator|)
name|dd
operator|->
name|dd_desc_len
argument_list|,
operator|(
name|caddr_t
operator|)
name|dd
operator|->
name|dd_desc_paddr
argument_list|,
comment|/*XXX*/
operator|(
name|u_long
operator|)
name|dd
operator|->
name|dd_desc_len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail2
label|:
name|bus_dmamem_free
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|fail1
label|:
name|bus_dmamap_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|fail0
label|:
name|bus_dma_tag_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|DS2PHYS
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_desc_cleanup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mwl_descdma
modifier|*
name|dd
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Construct a tx q's free list.  The order of entries on  * the list must reflect the physical layout of tx descriptors  * because the firmware pre-fetches descriptors.  *  * XXX might be better to use indices into the buffer array.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_txq_reset
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mwl_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|mwl_txbuf
modifier|*
name|bf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bf
operator|=
name|txq
operator|->
name|dma
operator|.
name|dd_bufptr
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mwl_txbuf
condition|;
name|i
operator|++
operator|,
name|bf
operator|++
control|)
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|txq
operator|->
name|nfree
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DS2PHYS
parameter_list|(
name|_dd
parameter_list|,
name|_ds
parameter_list|)
define|\
value|((_dd)->dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)->dd_desc))
end_define

begin_function
specifier|static
name|int
name|mwl_txdma_setup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mwl_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|bsize
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|mwl_txbuf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mwl_txdesc
modifier|*
name|ds
decl_stmt|;
name|error
operator|=
name|mwl_desc_setup
argument_list|(
name|sc
argument_list|,
literal|"tx"
argument_list|,
operator|&
name|txq
operator|->
name|dma
argument_list|,
name|mwl_txbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mwl_txbuf
argument_list|)
argument_list|,
name|MWL_TXDESC
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mwl_txdesc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* allocate and setup tx buffers */
name|bsize
operator|=
name|mwl_txbuf
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mwl_txbuf
argument_list|)
expr_stmt|;
name|bf
operator|=
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_MWLDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"malloc of %u tx buffers failed\n"
argument_list|,
name|mwl_txbuf
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|txq
operator|->
name|dma
operator|.
name|dd_bufptr
operator|=
name|bf
expr_stmt|;
name|ds
operator|=
name|txq
operator|->
name|dma
operator|.
name|dd_desc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mwl_txbuf
condition|;
name|i
operator|++
operator|,
name|bf
operator|++
operator|,
name|ds
operator|+=
name|MWL_TXDESC
control|)
block|{
name|bf
operator|->
name|bf_desc
operator|=
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_daddr
operator|=
name|DS2PHYS
argument_list|(
operator|&
name|txq
operator|->
name|dma
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to create dmamap for tx "
literal|"buffer %u, error %u\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|mwl_txq_reset
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_txdma_cleanup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mwl_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|mwl_txbuf
modifier|*
name|bf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bf
operator|=
name|txq
operator|->
name|dma
operator|.
name|dd_bufptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mwl_txbuf
condition|;
name|i
operator|++
operator|,
name|bf
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_m
operator|==
name|NULL
argument_list|,
operator|(
literal|"mbuf on free list"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_node
operator|==
name|NULL
argument_list|,
operator|(
literal|"node on free list"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_dmamap
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|)
expr_stmt|;
name|txq
operator|->
name|nfree
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|dma
operator|.
name|dd_bufptr
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|txq
operator|->
name|dma
operator|.
name|dd_bufptr
argument_list|,
name|M_MWLDEV
argument_list|)
expr_stmt|;
name|txq
operator|->
name|dma
operator|.
name|dd_bufptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txq
operator|->
name|dma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|mwl_desc_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|txq
operator|->
name|dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_rxdma_setup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|jumbosize
decl_stmt|,
name|bsize
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|mwl_rxbuf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mwl_jumbo
modifier|*
name|rbuf
decl_stmt|;
name|struct
name|mwl_rxdesc
modifier|*
name|ds
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|error
operator|=
name|mwl_desc_setup
argument_list|(
name|sc
argument_list|,
literal|"rx"
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
name|mwl_rxdesc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mwl_rxbuf
argument_list|)
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mwl_rxdesc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* 	 * Receive is done to a private pool of jumbo buffers. 	 * This allows us to attach to mbuf's and avoid re-mapping 	 * memory on each rx we post.  We allocate a large chunk 	 * of memory and manage it in the driver.  The mbuf free 	 * callback method is used to reclaim frames after sending 	 * them up the stack.  By default we allocate 2x the number of 	 * rx descriptors configured so we have some slop to hold 	 * us while frames are processed. 	 */
if|if
condition|(
name|mwl_rxbuf
operator|<
literal|2
operator|*
name|mwl_rxdesc
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"too few rx dma buffers (%d); increasing to %d\n"
argument_list|,
name|mwl_rxbuf
argument_list|,
literal|2
operator|*
name|mwl_rxdesc
argument_list|)
expr_stmt|;
name|mwl_rxbuf
operator|=
literal|2
operator|*
name|mwl_rxdesc
expr_stmt|;
block|}
name|jumbosize
operator|=
name|roundup
argument_list|(
name|MWL_AGGR_SIZE
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxmemsize
operator|=
name|mwl_rxbuf
operator|*
name|jumbosize
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|sc
operator|->
name|sc_rxmemsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|sc
operator|->
name|sc_rxmemsize
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|sc
operator|->
name|sc_rxdmat
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_rxdmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"could not create rx DMA map\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sc_rxdmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_rxmem
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"could not alloc %ju bytes of rx DMA memory\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|sc_rxmemsize
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_rxdmat
argument_list|,
name|sc
operator|->
name|sc_rxmap
argument_list|,
name|sc
operator|->
name|sc_rxmem
argument_list|,
name|sc
operator|->
name|sc_rxmemsize
argument_list|,
name|mwl_load_cb
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxmem_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"could not load rx DMA map\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Allocate rx buffers and set them up. 	 */
name|bsize
operator|=
name|mwl_rxdesc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mwl_rxbuf
argument_list|)
expr_stmt|;
name|bf
operator|=
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_MWLDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"malloc of %u rx buffers failed\n"
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|sc
operator|->
name|sc_rxdma
operator|.
name|dd_bufptr
operator|=
name|bf
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
name|ds
operator|=
name|sc
operator|->
name|sc_rxdma
operator|.
name|dd_desc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mwl_rxdesc
condition|;
name|i
operator|++
operator|,
name|bf
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|bf
operator|->
name|bf_desc
operator|=
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_daddr
operator|=
name|DS2PHYS
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
name|ds
argument_list|)
expr_stmt|;
comment|/* pre-assign dma buffer */
name|bf
operator|->
name|bf_data
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|sc_rxmem
operator|)
operator|+
operator|(
name|i
operator|*
name|jumbosize
operator|)
expr_stmt|;
comment|/* NB: tail is intentional to preserve descriptor order */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Place remainder of dma memory buffers on the free list. 	 */
name|SLIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxfree
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|mwl_rxbuf
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|sc_rxmem
operator|)
operator|+
operator|(
name|i
operator|*
name|jumbosize
operator|)
expr_stmt|;
name|rbuf
operator|=
name|MWL_JUMBO_DATA2BUF
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxfree
argument_list|,
name|rbuf
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nrxfree
operator|++
expr_stmt|;
block|}
name|MWL_RXFREE_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|DS2PHYS
end_undef

begin_function
specifier|static
name|void
name|mwl_rxdma_cleanup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rxmap
operator|!=
name|NULL
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_rxdmat
argument_list|,
name|sc
operator|->
name|sc_rxmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxmem
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_rxdmat
argument_list|,
name|sc
operator|->
name|sc_rxmem
argument_list|,
name|sc
operator|->
name|sc_rxmap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxmem
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rxmap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_rxdmat
argument_list|,
name|sc
operator|->
name|sc_rxmap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxmap
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rxdma
operator|.
name|dd_bufptr
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|sc_rxdma
operator|.
name|dd_bufptr
argument_list|,
name|M_MWLDEV
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxdma
operator|.
name|dd_bufptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rxdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|mwl_desc_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|)
expr_stmt|;
name|MWL_RXFREE_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_dma_setup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|mwl_rxdma_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mwl_rxdma_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MWL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|mwl_txdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mwl_dma_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_dma_cleanup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MWL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
name|mwl_txdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mwl_rxdma_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|mwl_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
specifier|const
name|size_t
name|space
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|mwl_node
argument_list|)
decl_stmt|;
name|struct
name|mwl_node
modifier|*
name|mn
decl_stmt|;
name|mn
operator|=
name|malloc
argument_list|(
name|space
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mn
operator|==
name|NULL
condition|)
block|{
comment|/* XXX stat+msg */
return|return
name|NULL
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_NODE
argument_list|,
literal|"%s: mn %p\n"
argument_list|,
name|__func__
argument_list|,
name|mn
argument_list|)
expr_stmt|;
return|return
operator|&
name|mn
operator|->
name|mn_node
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mwl_node
modifier|*
name|mn
init|=
name|MWL_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_NODE
argument_list|,
literal|"%s: ni %p ic %p staid %d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ni
operator|->
name|ni_ic
argument_list|,
name|mn
operator|->
name|mn_staid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mn
operator|->
name|mn_staid
operator|!=
literal|0
condition|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
if|if
condition|(
name|mn
operator|->
name|mn_hvap
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|mwl_hal_delstation
argument_list|(
name|mn
operator|->
name|mn_hvap
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
else|else
name|mwl_hal_delstation
argument_list|(
name|mn
operator|->
name|mn_hvap
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * NB: legacy WDS peer sta db entry is installed using 		 * the associate ap's hvap; use it again to delete it. 		 * XXX can vap be NULL? 		 */
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_WDS
operator|&&
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_ap_hvap
operator|!=
name|NULL
condition|)
name|mwl_hal_delstation
argument_list|(
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_ap_hvap
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
name|delstaid
argument_list|(
name|sc
argument_list|,
name|mn
operator|->
name|mn_staid
argument_list|)
expr_stmt|;
name|mn
operator|->
name|mn_staid
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|sc_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim rx dma buffers from packets sitting on the ampdu  * reorder queue for a station.  We replace buffers with a  * system cluster (if available).  */
end_comment

begin_function
specifier|static
name|void
name|mwl_ampdu_rxdma_reclaim
parameter_list|(
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|)
block|{
if|#
directive|if
literal|0
block|int i, n, off; 	struct mbuf *m; 	void *cl;  	n = rap->rxa_qframes; 	for (i = 0; i< rap->rxa_wnd&& n> 0; i++) { 		m = rap->rxa_m[i]; 		if (m == NULL) 			continue; 		n--;
comment|/* our dma buffers have a well-known free routine */
block|if ((m->m_flags& M_EXT) == 0 || 		    m->m_ext.ext_free != mwl_ext_free) 			continue;
comment|/* 		 * Try to allocate a cluster and move the data. 		 */
block|off = m->m_data - m->m_ext.ext_buf; 		if (off + m->m_pkthdr.len> MCLBYTES) {
comment|/* XXX no AMSDU for now */
block|continue; 		} 		cl = pool_cache_get_paddr(&mclpool_cache, 0,&m->m_ext.ext_paddr); 		if (cl != NULL) {
comment|/* 			 * Copy the existing data to the cluster, remove 			 * the rx dma buffer, and attach the cluster in 			 * its place.  Note we preserve the offset to the 			 * data so frames being bridged can still prepend 			 * their headers without adding another mbuf. 			 */
block|memcpy((caddr_t) cl + off, m->m_data, m->m_pkthdr.len); 			MEXTREMOVE(m); 			MEXTADD(m, cl, MCLBYTES, 0, NULL,&mclpool_cache);
comment|/* setup mbuf like _MCLGET does */
block|m->m_flags |= M_CLUSTER | M_EXT_RW; 			_MOWNERREF(m, M_EXT | M_CLUSTER);
comment|/* NB: m_data is clobbered by MEXTADDR, adjust */
block|m->m_data += off; 		} 	}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Callback to reclaim resources.  We first let the  * net80211 layer do it's thing, then if we are still  * blocked by a lack of rx dma buffers we walk the ampdu  * reorder q's to reclaim buffers by copying to a system  * cluster.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_node_drain
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mwl_node
modifier|*
name|mn
init|=
name|MWL_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_NODE
argument_list|,
literal|"%s: ni %p vap %p staid %d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ni
operator|->
name|ni_vap
argument_list|,
name|mn
operator|->
name|mn_staid
argument_list|)
expr_stmt|;
comment|/* NB: call up first to age out ampdu q's */
name|sc
operator|->
name|sc_node_drain
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* XXX better to not check low water mark? */
if|if
condition|(
name|sc
operator|->
name|sc_rxblocked
operator|&&
name|mn
operator|->
name|mn_staid
operator|!=
literal|0
operator|&&
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
operator|)
condition|)
block|{
name|uint8_t
name|tid
decl_stmt|;
comment|/* 		 * Walk the reorder q and reclaim rx dma buffers by copying 		 * the packet contents into clusters. 		 */
for|for
control|(
name|tid
operator|=
literal|0
init|;
name|tid
operator|<
name|WME_NUM_TID
condition|;
name|tid
operator|++
control|)
block|{
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
decl_stmt|;
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rap
operator|->
name|rxa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
condition|)
name|mwl_ampdu_rxdma_reclaim
argument_list|(
name|rap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_node_getsignal
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int8_t
modifier|*
name|rssi
parameter_list|,
name|int8_t
modifier|*
name|noise
parameter_list|)
block|{
operator|*
name|rssi
operator|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MWL_ANT_INFO_SUPPORT
if|#
directive|if
literal|0
comment|/* XXX need to smooth data */
block|*noise = -MWL_NODE_CONST(ni)->mn_ai.nf;
else|#
directive|else
operator|*
name|noise
operator|=
operator|-
literal|95
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
else|#
directive|else
operator|*
name|noise
operator|=
operator|-
literal|95
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Convert Hardware per-antenna rssi info to common format:  * Let a1, a2, a3 represent the amplitudes per chain  * Let amax represent max[a1, a2, a3]  * Rssi1_dBm = RSSI_dBm + 20*log10(a1/amax)  * Rssi1_dBm = RSSI_dBm + 20*log10(a1) - 20*log10(amax)  * We store a table that is 4*20*log10(idx) - the extra 4 is to store or  * maintain some extra precision.  *  * Values are stored in .5 db format capped at 127.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_node_getmimoinfo
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_mimo_info
modifier|*
name|mi
parameter_list|)
block|{
define|#
directive|define
name|CVT
parameter_list|(
name|_dst
parameter_list|,
name|_src
parameter_list|)
value|do {						\ 	(_dst) = rssi + ((logdbtbl[_src] - logdbtbl[rssi_max])>> 2);	\ 	(_dst) = (_dst)> 64 ? 127 : ((_dst)<< 1);			\ } while (0)
specifier|static
specifier|const
name|int8_t
name|logdbtbl
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|24
block|,
literal|38
block|,
literal|48
block|,
literal|56
block|,
literal|62
block|,
literal|68
block|,
literal|72
block|,
literal|76
block|,
literal|80
block|,
literal|83
block|,
literal|86
block|,
literal|89
block|,
literal|92
block|,
literal|94
block|,
literal|96
block|,
literal|98
block|,
literal|100
block|,
literal|102
block|,
literal|104
block|,
literal|106
block|,
literal|107
block|,
literal|109
block|,
literal|110
block|,
literal|112
block|,
literal|113
block|,
literal|115
block|,
literal|116
block|,
literal|117
block|,
literal|118
block|,
literal|119
block|}
decl_stmt|;
specifier|const
name|struct
name|mwl_node
modifier|*
name|mn
init|=
name|MWL_NODE_CONST
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|uint8_t
name|rssi
init|=
name|mn
operator|->
name|mn_ai
operator|.
name|rsvd1
operator|/
literal|2
decl_stmt|;
comment|/* XXX */
name|uint32_t
name|rssi_max
decl_stmt|;
name|rssi_max
operator|=
name|mn
operator|->
name|mn_ai
operator|.
name|rssi_a
expr_stmt|;
if|if
condition|(
name|mn
operator|->
name|mn_ai
operator|.
name|rssi_b
operator|>
name|rssi_max
condition|)
name|rssi_max
operator|=
name|mn
operator|->
name|mn_ai
operator|.
name|rssi_b
expr_stmt|;
if|if
condition|(
name|mn
operator|->
name|mn_ai
operator|.
name|rssi_c
operator|>
name|rssi_max
condition|)
name|rssi_max
operator|=
name|mn
operator|->
name|mn_ai
operator|.
name|rssi_c
expr_stmt|;
name|CVT
argument_list|(
name|mi
operator|->
name|rssi
index|[
literal|0
index|]
argument_list|,
name|mn
operator|->
name|mn_ai
operator|.
name|rssi_a
argument_list|)
expr_stmt|;
name|CVT
argument_list|(
name|mi
operator|->
name|rssi
index|[
literal|1
index|]
argument_list|,
name|mn
operator|->
name|mn_ai
operator|.
name|rssi_b
argument_list|)
expr_stmt|;
name|CVT
argument_list|(
name|mi
operator|->
name|rssi
index|[
literal|2
index|]
argument_list|,
name|mn
operator|->
name|mn_ai
operator|.
name|rssi_c
argument_list|)
expr_stmt|;
name|mi
operator|->
name|noise
index|[
literal|0
index|]
operator|=
name|mn
operator|->
name|mn_ai
operator|.
name|nf_a
expr_stmt|;
name|mi
operator|->
name|noise
index|[
literal|1
index|]
operator|=
name|mn
operator|->
name|mn_ai
operator|.
name|nf_b
expr_stmt|;
name|mi
operator|->
name|noise
index|[
literal|2
index|]
operator|=
name|mn
operator|->
name|mn_ai
operator|.
name|nf_c
expr_stmt|;
undef|#
directive|undef
name|CVT
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
modifier|*
name|mwl_getrxdma
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mwl_jumbo
modifier|*
name|buf
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
comment|/* 	 * Allocate from jumbo pool. 	 */
name|MWL_RXFREE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|buf
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_ANY
argument_list|,
literal|"%s: out of rx dma buffers\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_rx_nodmabuf
operator|++
expr_stmt|;
name|data
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxfree
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nrxfree
operator|--
expr_stmt|;
name|data
operator|=
name|MWL_JUMBO_BUF2DATA
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|MWL_RXFREE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|mwl_putrxdma
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mwl_jumbo
modifier|*
name|buf
decl_stmt|;
comment|/* XXX bounds check data */
name|MWL_RXFREE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|buf
operator|=
name|MWL_JUMBO_DATA2BUF
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxfree
argument_list|,
name|buf
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nrxfree
operator|++
expr_stmt|;
name|MWL_RXFREE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_rxbuf_init
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mwl_rxbuf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|mwl_rxdesc
modifier|*
name|ds
decl_stmt|;
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_data
operator|==
name|NULL
condition|)
block|{
name|bf
operator|->
name|bf_data
operator|=
name|mwl_getrxdma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_data
operator|==
name|NULL
condition|)
block|{
comment|/* mark descriptor to be skipped */
name|ds
operator|->
name|RxControl
operator|=
name|EAGLE_RXD_CTRL_OS_OWN
expr_stmt|;
comment|/* NB: don't need PREREAD */
name|MWL_RXDESC_SYNC
argument_list|(
name|sc
argument_list|,
name|ds
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_rxbuf_failed
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
comment|/* 	 * NB: DMA buffer contents is known to be unmodified 	 *     so there's no need to flush the data cache. 	 */
comment|/* 	 * Setup descriptor. 	 */
name|ds
operator|->
name|QosCtrl
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|RSSI
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|Status
operator|=
name|EAGLE_RXD_STATUS_IDLE
expr_stmt|;
name|ds
operator|->
name|Channel
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|PktLen
operator|=
name|htole16
argument_list|(
name|MWL_AGGR_SIZE
argument_list|)
expr_stmt|;
name|ds
operator|->
name|SQ2
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|pPhysBuffData
operator|=
name|htole32
argument_list|(
name|MWL_JUMBO_DMA_ADDR
argument_list|(
name|sc
argument_list|,
name|bf
operator|->
name|bf_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NB: don't touch pPhysNext, set once */
name|ds
operator|->
name|RxControl
operator|=
name|EAGLE_RXD_CTRL_DRIVER_OWN
expr_stmt|;
name|MWL_RXDESC_SYNC
argument_list|(
name|sc
argument_list|,
name|ds
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_ext_free
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
comment|/* XXX bounds check data */
name|mwl_putrxdma
argument_list|(
name|sc
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* 	 * If we were previously blocked by a lack of rx dma buffers 	 * check if we now have enough to restart rx interrupt handling. 	 * NB: we know we are called at splvm which is above splnet. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_rxblocked
operator|&&
name|sc
operator|->
name|sc_nrxfree
operator|>
name|mwl_rxdmalow
condition|)
block|{
name|sc
operator|->
name|sc_rxblocked
operator|=
literal|0
expr_stmt|;
name|mwl_hal_intrset
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|mwl_frame_bar
block|{
name|u_int8_t
name|i_fc
index|[
literal|2
index|]
decl_stmt|;
name|u_int8_t
name|i_dur
index|[
literal|2
index|]
decl_stmt|;
name|u_int8_t
name|i_ra
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|u_int8_t
name|i_ta
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
comment|/* ctl, seq, FCS */
block|}
name|__packed
struct|;
end_struct

begin_comment
comment|/*  * Like ieee80211_anyhdrsize, but handles BAR frames  * specially so the logic below to piece the 802.11  * header together works.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|mwl_anyhdrsize
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
operator|)
operator|==
name|IEEE80211_FC0_TYPE_CTL
condition|)
block|{
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_CTS
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_ACK
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame_ack
argument_list|)
return|;
case|case
name|IEEE80211_FC0_SUBTYPE_BAR
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|mwl_frame_bar
argument_list|)
return|;
block|}
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame_min
argument_list|)
return|;
block|}
else|else
return|return
name|ieee80211_hdrsize
argument_list|(
name|data
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_handlemicerror
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|wh
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_frame
operator|*
operator|)
operator|(
name|data
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
operator|(
specifier|const
expr|struct
name|ieee80211_frame_min
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_notify_michael_failure
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|wh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convert hardware signal strength to rssi.  The value  * provided by the device has the noise floor added in;  * we need to compensate for this but we don't have that  * so we use a fixed value.  *  * The offset of 8 is good for both 2.4 and 5GHz.  The LNA  * offset is already set as part of the initial gain.  This  * will give at least +/- 3dB for 2.4GHz and +/- 5dB for 5GHz.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|cvtrssi
parameter_list|(
name|uint8_t
name|ssi
parameter_list|)
block|{
name|int
name|rssi
init|=
operator|(
name|int
operator|)
name|ssi
operator|+
literal|8
decl_stmt|;
comment|/* XXX hack guess until we have a real noise floor */
name|rssi
operator|=
literal|2
operator|*
operator|(
literal|87
operator|-
name|rssi
operator|)
expr_stmt|;
comment|/* NB: .5 dBm units */
return|return
operator|(
name|rssi
operator|<
literal|0
condition|?
literal|0
else|:
name|rssi
operator|>
literal|127
condition|?
literal|127
else|:
name|rssi
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_rx_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
define|#
directive|define
name|IEEE80211_DIR_DSTODS
parameter_list|(
name|wh
parameter_list|)
define|\
value|((((const struct ieee80211_frame *)wh)->i_fc[1]& IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|mwl_rxbuf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mwl_rxdesc
modifier|*
name|ds
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_qosframe
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_qosframe_addr4
modifier|*
name|wh4
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mwl_node
modifier|*
name|mn
decl_stmt|;
name|int
name|off
decl_stmt|,
name|len
decl_stmt|,
name|hdrlen
decl_stmt|,
name|pktlen
decl_stmt|,
name|rssi
decl_stmt|,
name|ntodo
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|,
name|status
decl_stmt|;
name|void
modifier|*
name|newdata
decl_stmt|;
name|int16_t
name|nf
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_RX_PROC
argument_list|,
literal|"%s: pending %u rdptr 0x%x wrptr 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|npending
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_hwspecs
operator|.
name|rxDescRead
argument_list|)
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_hwspecs
operator|.
name|rxDescWrite
argument_list|)
argument_list|)
expr_stmt|;
name|nf
operator|=
operator|-
literal|96
expr_stmt|;
comment|/* XXX */
name|bf
operator|=
name|sc
operator|->
name|sc_rxnext
expr_stmt|;
for|for
control|(
name|ntodo
operator|=
name|mwl_rxquota
init|;
name|ntodo
operator|>
literal|0
condition|;
name|ntodo
operator|--
control|)
block|{
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|data
operator|=
name|bf
operator|->
name|bf_data
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * If data allocation failed previously there 			 * will be no buffer; try again to re-populate it. 			 * Note the firmware will not advance to the next 			 * descriptor with a dma buffer so we must mimic 			 * this or we'll get out of sync. 			 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_ANY
argument_list|,
literal|"%s: rx buf w/o dma memory\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mwl_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_rx_dmabufmissing
operator|++
expr_stmt|;
break|break;
block|}
name|MWL_RXDESC_SYNC
argument_list|(
name|sc
argument_list|,
name|ds
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|RxControl
operator|!=
name|EAGLE_RXD_CTRL_DMA_OWN
condition|)
break|break;
ifdef|#
directive|ifdef
name|MWL_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|MWL_DEBUG_RECV_DESC
condition|)
name|mwl_printrxbuf
argument_list|(
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
name|ds
operator|->
name|Status
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|EAGLE_RXD_STATUS_DECRYPT_ERR_MASK
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_rx_crypto
operator|++
expr_stmt|;
comment|/* 			 * NB: Check EAGLE_RXD_STATUS_GENERAL_DECRYPT_ERR 			 *     for backwards compatibility. 			 */
if|if
condition|(
name|status
operator|!=
name|EAGLE_RXD_STATUS_GENERAL_DECRYPT_ERR
operator|&&
operator|(
name|status
operator|&
name|EAGLE_RXD_STATUS_TKIP_MIC_DECRYPT_ERR
operator|)
condition|)
block|{
comment|/* 				 * MIC error, notify upper layers. 				 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rxdmat
argument_list|,
name|sc
operator|->
name|sc_rxmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|mwl_handlemicerror
argument_list|(
name|ic
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_rx_tkipmic
operator|++
expr_stmt|;
block|}
comment|/* XXX too painful to tap packets */
goto|goto
name|rx_next
goto|;
block|}
comment|/* 		 * Sync the data buffer. 		 */
name|len
operator|=
name|le16toh
argument_list|(
name|ds
operator|->
name|PktLen
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rxdmat
argument_list|,
name|sc
operator|->
name|sc_rxmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* 		 * The 802.11 header is provided all or in part at the front; 		 * use it to calculate the true size of the header that we'll 		 * construct below.  We use this to figure out where to copy 		 * payload prior to constructing the header. 		 */
name|hdrlen
operator|=
name|mwl_anyhdrsize
argument_list|(
name|data
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame_addr4
argument_list|)
expr_stmt|;
comment|/* calculate rssi early so we can re-use for each aggregate */
name|rssi
operator|=
name|cvtrssi
argument_list|(
name|ds
operator|->
name|RSSI
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|hdrlen
operator|+
operator|(
name|len
operator|-
name|off
operator|)
expr_stmt|;
comment|/* 		 * NB: we know our frame is at least as large as 		 * IEEE80211_MIN_LEN because there is a 4-address 		 * frame at the front.  Hence there's no need to 		 * vet the packet length.  If the frame in fact 		 * is too small it should be discarded at the 		 * net80211 layer. 		 */
comment|/* 		 * Attach dma buffer to an mbuf.  We tried 		 * doing this based on the packet size (i.e. 		 * copying small packets) but it turns out to 		 * be a net loss.  The tradeoff might be system 		 * dependent (cache architecture is important). 		 */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_ANY
argument_list|,
literal|"%s: no rx mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_rx_nombuf
operator|++
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
comment|/* 		 * Acquire the replacement dma buffer before 		 * processing the frame.  If we're out of dma 		 * buffers we disable rx interrupts and wait 		 * for the free pool to reach mlw_rxdmalow buffers 		 * before starting to do work again.  If the firmware 		 * runs out of descriptors then it will toss frames 		 * which is better than our doing it as that can 		 * starve our processing.  It is also important that 		 * we always process rx'd frames in case they are 		 * A-MPDU as otherwise the host's view of the BA 		 * window may get out of sync with the firmware. 		 */
name|newdata
operator|=
name|mwl_getrxdma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdata
operator|==
name|NULL
condition|)
block|{
comment|/* NB: stat+msg in mwl_getrxdma */
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* disable RX interrupt and mark state */
name|mwl_hal_intrset
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
name|sc
operator|->
name|sc_imask
operator|&
operator|~
name|MACREG_A2HRIC_BIT_RX_RDY
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxblocked
operator|=
literal|1
expr_stmt|;
name|ieee80211_drain
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* XXX check rxblocked and immediately start again? */
goto|goto
name|rx_stop
goto|;
block|}
name|bf
operator|->
name|bf_data
operator|=
name|newdata
expr_stmt|;
comment|/* 		 * Attach the dma buffer to the mbuf; 		 * mwl_rxbuf_init will re-setup the rx 		 * descriptor using the replacement dma 		 * buffer we just installed above. 		 */
name|MEXTADD
argument_list|(
name|m
argument_list|,
name|data
argument_list|,
name|MWL_AGGR_SIZE
argument_list|,
name|mwl_ext_free
argument_list|,
name|data
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|EXT_NET_DRV
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|off
operator|-
name|hdrlen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|pktlen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
comment|/* NB: dma buffer assumed read-only */
comment|/* 		 * Piece 802.11 header together. 		 */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_qosframe
operator|*
argument_list|)
expr_stmt|;
comment|/* NB: don't need to do this sometimes but ... */
comment|/* XXX special case so we can memcpy after m_devget? */
name|ovbcopy
argument_list|(
name|data
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
name|wh
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
block|{
if|if
condition|(
name|IEEE80211_DIR_DSTODS
argument_list|(
name|wh
argument_list|)
condition|)
block|{
name|wh4
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_qosframe_addr4
operator|*
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh4
operator|->
name|i_qos
operator|=
name|ds
operator|->
name|QosCtrl
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_qos
operator|=
name|ds
operator|->
name|QosCtrl
expr_stmt|;
block|}
block|}
comment|/* 		 * The f/w strips WEP header but doesn't clear 		 * the WEP bit; mark the packet with M_WEP so 		 * net80211 will treat the data as decrypted. 		 * While here also clear the PWR_MGT bit since 		 * power save is handled by the firmware and 		 * passing this up will potentially cause the 		 * upper layer to put a station in power save 		 * (except when configured with MWL_HOST_PS_SUPPORT). 		 */
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_WEP
expr_stmt|;
ifdef|#
directive|ifdef
name|MWL_HOST_PS_SUPPORT
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&=
operator|~
name|IEEE80211_FC1_WEP
expr_stmt|;
else|#
directive|else
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&=
operator|~
operator|(
name|IEEE80211_FC1_WEP
operator||
name|IEEE80211_FC1_PWR_MGT
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|struct
name|mwl_rx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_rx_th
decl_stmt|;
name|tap
operator|->
name|wr_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wr_rate
operator|=
name|ds
operator|->
name|Rate
expr_stmt|;
name|tap
operator|->
name|wr_antsignal
operator|=
name|rssi
operator|+
name|nf
expr_stmt|;
name|tap
operator|->
name|wr_antnoise
operator|=
name|nf
expr_stmt|;
block|}
if|if
condition|(
name|IFF_DUMPPKTS_RECV
argument_list|(
name|sc
argument_list|,
name|wh
argument_list|)
condition|)
block|{
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|,
name|ds
operator|->
name|Rate
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* dispatch */
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
operator|(
specifier|const
expr|struct
name|ieee80211_frame_min
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|mn
operator|=
name|MWL_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MWL_ANT_INFO_SUPPORT
name|mn
operator|->
name|mn_ai
operator|.
name|rssi_a
operator|=
name|ds
operator|->
name|ai
operator|.
name|rssi_a
expr_stmt|;
name|mn
operator|->
name|mn_ai
operator|.
name|rssi_b
operator|=
name|ds
operator|->
name|ai
operator|.
name|rssi_b
expr_stmt|;
name|mn
operator|->
name|mn_ai
operator|.
name|rssi_c
operator|=
name|ds
operator|->
name|ai
operator|.
name|rssi_c
expr_stmt|;
name|mn
operator|->
name|mn_ai
operator|.
name|rsvd1
operator|=
name|rssi
expr_stmt|;
endif|#
directive|endif
comment|/* tag AMPDU aggregates for reorder processing */
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_AMPDU
expr_stmt|;
operator|(
name|void
operator|)
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ieee80211_input_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|rx_next
label|:
comment|/* NB: ignore ENOMEM so we process more descriptors */
operator|(
name|void
operator|)
name|mwl_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_NEXT
argument_list|(
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|rx_stop
label|:
name|sc
operator|->
name|sc_rxnext
operator|=
name|bf
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
operator|&&
operator|!
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
comment|/* NB: kick fw; the tx thread may have been preempted */
name|mwl_hal_txstart
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mwl_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|IEEE80211_DIR_DSTODS
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_txq_init
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mwl_txq
modifier|*
name|txq
parameter_list|,
name|int
name|qnum
parameter_list|)
block|{
name|struct
name|mwl_txbuf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|bn
decl_stmt|;
name|struct
name|mwl_txdesc
modifier|*
name|ds
decl_stmt|;
name|MWL_TXQ_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|qnum
operator|=
name|qnum
expr_stmt|;
name|txq
operator|->
name|txpri
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
if|#
directive|if
literal|0
comment|/* NB: q setup by mwl_txdma_setup XXX */
block|STAILQ_INIT(&txq->free);
endif|#
directive|endif
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&txq->free
argument_list|,
argument|bf_list
argument_list|)
block|{
name|bf
operator|->
name|bf_txq
operator|=
name|txq
expr_stmt|;
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|bn
operator|=
name|STAILQ_NEXT
argument_list|(
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|bn
operator|==
name|NULL
condition|)
name|bn
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|free
argument_list|)
expr_stmt|;
name|ds
operator|->
name|pPhysNext
operator|=
name|htole32
argument_list|(
name|bn
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|txq
operator|->
name|active
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup a hardware data transmit queue for the specified  * access control.  We record the mapping from ac's  * to h/w queues for use by mwl_tx_start.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_tx_setup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ac
parameter_list|,
name|int
name|mvtype
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|struct
name|mwl_txq
modifier|*
name|txq
decl_stmt|;
if|if
condition|(
name|ac
operator|>=
name|N
argument_list|(
name|sc
operator|->
name|sc_ac2q
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"AC %u out of range, max %zu!\n"
argument_list|,
name|ac
argument_list|,
name|N
argument_list|(
name|sc
operator|->
name|sc_ac2q
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mvtype
operator|>=
name|MWL_NUM_TX_QUEUES
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"mvtype %u out of range, max %u!\n"
argument_list|,
name|mvtype
argument_list|,
name|MWL_NUM_TX_QUEUES
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|txq
operator|=
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|mvtype
index|]
expr_stmt|;
name|mwl_txq_init
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|mvtype
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|ac
index|]
operator|=
name|txq
expr_stmt|;
return|return
literal|1
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Update WME parameters for a transmit queue.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_txq_update
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ac
parameter_list|)
block|{
define|#
directive|define
name|MWL_EXPONENT_TO_VALUE
parameter_list|(
name|v
parameter_list|)
value|((1<<v)-1)
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|mwl_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|ac
index|]
decl_stmt|;
name|struct
name|wmeParams
modifier|*
name|wmep
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|ac
index|]
decl_stmt|;
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
name|int
name|aifs
decl_stmt|,
name|cwmin
decl_stmt|,
name|cwmax
decl_stmt|,
name|txoplim
decl_stmt|;
name|aifs
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
comment|/* XXX in sta mode need to pass log values for cwmin/max */
name|cwmin
operator|=
name|MWL_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmin
argument_list|)
expr_stmt|;
name|cwmax
operator|=
name|MWL_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmax
argument_list|)
expr_stmt|;
name|txoplim
operator|=
name|wmep
operator|->
name|wmep_txopLimit
expr_stmt|;
comment|/* NB: units of 32us */
if|if
condition|(
name|mwl_hal_setedcaparams
argument_list|(
name|mh
argument_list|,
name|txq
operator|->
name|qnum
argument_list|,
name|cwmin
argument_list|,
name|cwmax
argument_list|,
name|aifs
argument_list|,
name|txoplim
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to update hardware queue "
literal|"parameters for %s traffic!\n"
argument_list|,
name|ieee80211_wme_acnames
index|[
name|ac
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
undef|#
directive|undef
name|MWL_EXPONENT_TO_VALUE
block|}
end_function

begin_comment
comment|/*  * Callback from the 802.11 layer to update WME parameters.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
return|return
operator|!
name|mwl_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_BE
argument_list|)
operator|||
operator|!
name|mwl_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_BK
argument_list|)
operator|||
operator|!
name|mwl_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_VI
argument_list|)
operator|||
operator|!
name|mwl_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_VO
argument_list|)
condition|?
name|EIO
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim resources for a setup queue.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_tx_cleanupq
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mwl_txq
modifier|*
name|txq
parameter_list|)
block|{
comment|/* XXX hal work? */
name|MWL_TXQ_LOCK_DESTROY
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim all tx queue resources.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_tx_cleanup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MWL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
name|mwl_tx_cleanupq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_tx_dmasetup
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mwl_txbuf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This 	 * also calculates the number of descriptors we need. 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* XXX packet requires too many descriptors */
name|bf
operator|->
name|bf_nseg
operator|=
name|MWL_TXDESC
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_busdma
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Discard null packets and check for packets that 	 * require too many TX descriptors.  We try to convert 	 * the latter to a cluster. 	 */
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* too many desc's, linearize */
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_linear
operator|++
expr_stmt|;
if|#
directive|if
name|MWL_TXDESC
operator|>
literal|1
name|m
operator|=
name|m_collapse
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MWL_TXDESC
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|=
name|m_defrag
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|m0
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_busdma
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|<=
name|MWL_TXDESC
argument_list|,
operator|(
literal|"too many segments after defrag; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|0
condition|)
block|{
comment|/* null packet, discard */
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_nodata
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_XMIT
argument_list|,
literal|"%s: m %p len %u\n"
argument_list|,
name|__func__
argument_list|,
name|m0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|m0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|mwl_cvtlegacyrate
parameter_list|(
name|int
name|rate
parameter_list|)
block|{
switch|switch
condition|(
name|rate
condition|)
block|{
case|case
literal|2
case|:
return|return
literal|0
return|;
case|case
literal|4
case|:
return|return
literal|1
return|;
case|case
literal|11
case|:
return|return
literal|2
return|;
case|case
literal|22
case|:
return|return
literal|3
return|;
case|case
literal|44
case|:
return|return
literal|4
return|;
case|case
literal|12
case|:
return|return
literal|5
return|;
case|case
literal|18
case|:
return|return
literal|6
return|;
case|case
literal|24
case|:
return|return
literal|7
return|;
case|case
literal|36
case|:
return|return
literal|8
return|;
case|case
literal|48
case|:
return|return
literal|9
return|;
case|case
literal|72
case|:
return|return
literal|10
return|;
case|case
literal|96
case|:
return|return
literal|11
return|;
case|case
literal|108
case|:
return|return
literal|12
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate fixed tx rate information per client state;  * this value is suitable for writing to the Format field  * of a tx descriptor.  */
end_comment

begin_function
specifier|static
name|uint16_t
name|mwl_calcformat
parameter_list|(
name|uint8_t
name|rate
parameter_list|,
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|uint16_t
name|fmt
decl_stmt|;
name|fmt
operator|=
name|SM
argument_list|(
literal|3
argument_list|,
name|EAGLE_TXD_ANTENNA
argument_list|)
operator||
operator|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|?
name|EAGLE_TXD_EXTCHAN_LO
else|:
name|EAGLE_TXD_EXTCHAN_HI
operator|)
expr_stmt|;
if|if
condition|(
name|rate
operator|&
name|IEEE80211_RATE_MCS
condition|)
block|{
comment|/* HT MCS */
name|fmt
operator||=
name|EAGLE_TXD_FORMAT_HT
comment|/* NB: 0x80 implicitly stripped from ucastrate */
operator||
name|SM
argument_list|(
name|rate
argument_list|,
name|EAGLE_TXD_RATE
argument_list|)
expr_stmt|;
comment|/* XXX short/long GI may be wrong; re-check */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|fmt
operator||=
name|EAGLE_TXD_CHW_40
operator||
operator|(
name|ni
operator|->
name|ni_htcap
operator|&
name|IEEE80211_HTCAP_SHORTGI40
condition|?
name|EAGLE_TXD_GI_SHORT
else|:
name|EAGLE_TXD_GI_LONG
operator|)
expr_stmt|;
block|}
else|else
block|{
name|fmt
operator||=
name|EAGLE_TXD_CHW_20
operator||
operator|(
name|ni
operator|->
name|ni_htcap
operator|&
name|IEEE80211_HTCAP_SHORTGI20
condition|?
name|EAGLE_TXD_GI_SHORT
else|:
name|EAGLE_TXD_GI_LONG
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* legacy rate */
name|fmt
operator||=
name|EAGLE_TXD_FORMAT_LEGACY
operator||
name|SM
argument_list|(
name|mwl_cvtlegacyrate
argument_list|(
name|rate
argument_list|)
argument_list|,
name|EAGLE_TXD_RATE
argument_list|)
operator||
name|EAGLE_TXD_CHW_20
comment|/* XXX iv_flags& IEEE80211_F_SHPREAMBLE? */
operator||
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
condition|?
name|EAGLE_TXD_PREAMBLE_SHORT
else|:
name|EAGLE_TXD_PREAMBLE_LONG
operator|)
expr_stmt|;
block|}
return|return
name|fmt
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_tx_start
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mwl_txbuf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
define|#
directive|define
name|IEEE80211_DIR_DSTODS
parameter_list|(
name|wh
parameter_list|)
define|\
value|((wh->i_fc[1]& IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int
name|error
decl_stmt|,
name|iswep
decl_stmt|,
name|ismcast
decl_stmt|;
name|int
name|hdrlen
decl_stmt|,
name|copyhdrlen
decl_stmt|,
name|pktlen
decl_stmt|;
name|struct
name|mwl_txdesc
modifier|*
name|ds
decl_stmt|;
name|struct
name|mwl_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|mwltxrec
modifier|*
name|tr
decl_stmt|;
name|struct
name|mwl_node
modifier|*
name|mn
decl_stmt|;
name|uint16_t
name|qos
decl_stmt|;
if|#
directive|if
name|MWL_TXDESC
operator|>
literal|1
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|iswep
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
name|copyhdrlen
operator|=
name|hdrlen
expr_stmt|;
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
block|{
if|if
condition|(
name|IEEE80211_DIR_DSTODS
argument_list|(
name|wh
argument_list|)
condition|)
block|{
name|qos
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|ieee80211_qosframe_addr4
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
operator|)
expr_stmt|;
name|copyhdrlen
operator|-=
sizeof|sizeof
argument_list|(
name|qos
argument_list|)
expr_stmt|;
block|}
else|else
name|qos
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
operator|)
expr_stmt|;
block|}
else|else
name|qos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iswep
condition|)
block|{
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
decl_stmt|;
comment|/* 		 * Construct the 802.11 header+trailer for an encrypted 		 * frame. The only reason this can fail is because of an 		 * unknown or unsupported cipher/key type. 		 * 		 * NB: we do this even though the firmware will ignore 		 *     what we've done for WEP and TKIP as we need the 		 *     ExtIV filled in for CCMP and this also adjusts 		 *     the headers which simplifies our work below. 		 */
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * This can happen when the key is yanked after the 			 * frame was queued.  Just discard the frame; the 			 * 802.11 layer counts failures and provides 			 * debugging/diagnostics. 			 */
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* 		 * Adjust the packet length for the crypto additions 		 * done during encap and any other bits that the f/w 		 * will add later on. 		 */
name|cip
operator|=
name|k
operator|->
name|wk_cipher
expr_stmt|;
name|pktlen
operator|+=
name|cip
operator|->
name|ic_header
operator|+
name|cip
operator|->
name|ic_miclen
operator|+
name|cip
operator|->
name|ic_trailer
expr_stmt|;
comment|/* packet header may have moved, reset our local pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|iswep
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
if|#
directive|if
literal|0
block|sc->sc_tx_th.wt_rate = ds->DataRate;
endif|#
directive|endif
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_txpower
operator|=
name|ni
operator|->
name|ni_txpower
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy up/down the 802.11 header; the firmware requires 	 * we present a 2-byte payload length followed by a 	 * 4-address header (w/o QoS), followed (optionally) by 	 * any WEP/ExtIV header (but only filled in for CCMP). 	 * We are assured the mbuf has sufficient headroom to 	 * prepend in-place by the setup of ic_headroom in 	 * mwl_attach. 	 */
if|if
condition|(
name|hdrlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|mwltxrec
argument_list|)
condition|)
block|{
specifier|const
name|int
name|space
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|mwltxrec
argument_list|)
operator|-
name|hdrlen
decl_stmt|;
if|if
condition|(
name|M_LEADINGSPACE
argument_list|(
name|m0
argument_list|)
operator|<
name|space
condition|)
block|{
comment|/* NB: should never happen */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"not enough headroom, need %d found %zd, "
literal|"m_flags 0x%x m_len %d\n"
argument_list|,
name|space
argument_list|,
name|M_LEADINGSPACE
argument_list|(
name|m0
argument_list|)
argument_list|,
name|m0
operator|->
name|m_flags
argument_list|,
name|m0
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_noheadroom
operator|++
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|M_PREPEND
argument_list|(
name|m0
argument_list|,
name|space
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
name|tr
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|mwltxrec
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|wh
operator|!=
operator|(
expr|struct
name|ieee80211_frame
operator|*
operator|)
operator|&
name|tr
operator|->
name|wh
condition|)
name|ovbcopy
argument_list|(
name|wh
argument_list|,
operator|&
name|tr
operator|->
name|wh
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
comment|/* 	 * Note: the "firmware length" is actually the length 	 * of the fully formed "802.11 payload".  That is, it's 	 * everything except for the 802.11 header.  In particular 	 * this includes all crypto material including the MIC! 	 */
name|tr
operator|->
name|fwlen
operator|=
name|htole16
argument_list|(
name|pktlen
operator|-
name|hdrlen
argument_list|)
expr_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This 	 * also calculates the number of descriptors we need. 	 */
name|error
operator|=
name|mwl_tx_dmasetup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* NB: stat collected in mwl_tx_dmasetup */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_XMIT
argument_list|,
literal|"%s: unable to setup dma\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|bf
operator|->
name|bf_node
operator|=
name|ni
expr_stmt|;
comment|/* NB: held reference */
name|m0
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
comment|/* NB: may have changed */
name|tr
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|mwltxrec
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|=
operator|(
expr|struct
name|ieee80211_frame
operator|*
operator|)
operator|&
name|tr
operator|->
name|wh
expr_stmt|;
comment|/* 	 * Formulate tx descriptor. 	 */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|txq
operator|=
name|bf
operator|->
name|bf_txq
expr_stmt|;
name|ds
operator|->
name|QosCtrl
operator|=
name|qos
expr_stmt|;
comment|/* NB: already little-endian */
if|#
directive|if
name|MWL_TXDESC
operator|==
literal|1
comment|/* 	 * NB: multiframes should be zero because the descriptors 	 *     are initialized to zero.  This should handle the case 	 *     where the driver is built with MWL_TXDESC=1 but we are 	 *     using firmware with multi-segment support. 	 */
name|ds
operator|->
name|PktPtr
operator|=
name|htole32
argument_list|(
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|ds
operator|->
name|PktLen
operator|=
name|htole16
argument_list|(
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
else|#
directive|else
name|ds
operator|->
name|multiframes
operator|=
name|htole32
argument_list|(
name|bf
operator|->
name|bf_nseg
argument_list|)
expr_stmt|;
name|ds
operator|->
name|PktLen
operator|=
name|htole16
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bf
operator|->
name|bf_nseg
condition|;
name|i
operator|++
control|)
block|{
name|ds
operator|->
name|PktPtrArray
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|ds
operator|->
name|PktLenArray
index|[
name|i
index|]
operator|=
name|htole16
argument_list|(
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NB: pPhysNext, DataRate, and SapPktInfo setup once, don't touch */
name|ds
operator|->
name|Format
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|pad
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|ack_wcb_addr
operator|=
literal|0
expr_stmt|;
name|mn
operator|=
name|MWL_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* 	 * Select transmit rate. 	 */
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_mgmt
operator|++
expr_stmt|;
comment|/* fall thru... */
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
comment|/* NB: assign to BE q to avoid bursting */
name|ds
operator|->
name|TxPriority
operator|=
name|MWL_WME_AC_BE
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
if|if
condition|(
operator|!
name|ismcast
condition|)
block|{
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
init|=
name|ni
operator|->
name|ni_txparms
decl_stmt|;
comment|/* 			 * EAPOL frames get forced to a fixed rate and w/o 			 * aggregation; otherwise check for any fixed rate 			 * for the client (may depend on association state). 			 */
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EAPOL
condition|)
block|{
specifier|const
name|struct
name|mwl_vap
modifier|*
name|mvp
init|=
name|MWL_VAP_CONST
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|ds
operator|->
name|Format
operator|=
name|mvp
operator|->
name|mv_eapolformat
expr_stmt|;
name|ds
operator|->
name|pad
operator|=
name|htole16
argument_list|(
name|EAGLE_TXD_FIXED_RATE
operator||
name|EAGLE_TXD_DONT_AGGR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|ucastrate
operator|!=
name|IEEE80211_FIXED_RATE_NONE
condition|)
block|{
comment|/* XXX pre-calculate per node */
name|ds
operator|->
name|Format
operator|=
name|htole16
argument_list|(
name|mwl_calcformat
argument_list|(
name|tp
operator|->
name|ucastrate
argument_list|,
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|pad
operator|=
name|htole16
argument_list|(
name|EAGLE_TXD_FIXED_RATE
argument_list|)
expr_stmt|;
block|}
comment|/* NB: EAPOL frames will never have qos set */
if|if
condition|(
name|qos
operator|==
literal|0
condition|)
name|ds
operator|->
name|TxPriority
operator|=
name|txq
operator|->
name|qnum
expr_stmt|;
if|#
directive|if
name|MWL_MAXBA
operator|>
literal|3
elseif|else
if|if
condition|(
name|mwl_bastream_match
argument_list|(
operator|&
name|mn
operator|->
name|mn_ba
index|[
literal|3
index|]
argument_list|,
name|qos
argument_list|)
condition|)
name|ds
operator|->
name|TxPriority
operator|=
name|mn
operator|->
name|mn_ba
index|[
literal|3
index|]
operator|.
name|txq
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MWL_MAXBA
operator|>
literal|2
elseif|else
if|if
condition|(
name|mwl_bastream_match
argument_list|(
operator|&
name|mn
operator|->
name|mn_ba
index|[
literal|2
index|]
argument_list|,
name|qos
argument_list|)
condition|)
name|ds
operator|->
name|TxPriority
operator|=
name|mn
operator|->
name|mn_ba
index|[
literal|2
index|]
operator|.
name|txq
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MWL_MAXBA
operator|>
literal|1
elseif|else
if|if
condition|(
name|mwl_bastream_match
argument_list|(
operator|&
name|mn
operator|->
name|mn_ba
index|[
literal|1
index|]
argument_list|,
name|qos
argument_list|)
condition|)
name|ds
operator|->
name|TxPriority
operator|=
name|mn
operator|->
name|mn_ba
index|[
literal|1
index|]
operator|.
name|txq
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MWL_MAXBA
operator|>
literal|0
elseif|else
if|if
condition|(
name|mwl_bastream_match
argument_list|(
operator|&
name|mn
operator|->
name|mn_ba
index|[
literal|0
index|]
argument_list|,
name|qos
argument_list|)
condition|)
name|ds
operator|->
name|TxPriority
operator|=
name|mn
operator|->
name|mn_ba
index|[
literal|0
index|]
operator|.
name|txq
expr_stmt|;
endif|#
directive|endif
else|else
name|ds
operator|->
name|TxPriority
operator|=
name|txq
operator|->
name|qnum
expr_stmt|;
block|}
else|else
name|ds
operator|->
name|TxPriority
operator|=
name|txq
operator|->
name|qnum
expr_stmt|;
break|break;
default|default:
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bogus frame type 0x%x (%s)\n"
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_badframetype
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|IFF_DUMPPKTS_XMIT
argument_list|(
name|sc
argument_list|)
condition|)
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
operator|-
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
name|ds
operator|->
name|DataRate
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|MWL_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|ds
operator|->
name|Status
operator|=
name|htole32
argument_list|(
name|EAGLE_TXD_STATUS_FW_OWNED
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|txq
operator|->
name|active
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|MWL_TXDESC_SYNC
argument_list|(
name|txq
argument_list|,
name|ds
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
name|MWL_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|IEEE80211_DIR_DSTODS
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|mwl_cvtlegacyrix
parameter_list|(
name|int
name|rix
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|x
parameter_list|)
value|(sizeof(x)/sizeof(x[0]))
specifier|static
specifier|const
name|int
name|ieeerates
index|[]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|,
literal|44
block|,
literal|12
block|,
literal|18
block|,
literal|24
block|,
literal|36
block|,
literal|48
block|,
literal|72
block|,
literal|96
block|,
literal|108
block|}
decl_stmt|;
return|return
operator|(
name|rix
operator|<
name|N
argument_list|(
name|ieeerates
argument_list|)
condition|?
name|ieeerates
index|[
name|rix
index|]
else|:
literal|0
operator|)
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Process completed xmit descriptors from the specified queue.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_tx_processq
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mwl_txq
modifier|*
name|txq
parameter_list|)
block|{
define|#
directive|define
name|EAGLE_TXD_STATUS_MCAST
define|\
value|(EAGLE_TXD_STATUS_MULTICAST_TX | EAGLE_TXD_STATUS_BROADCAST_TX)
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|mwl_txbuf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mwl_txdesc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mwl_node
modifier|*
name|an
decl_stmt|;
name|int
name|nreaped
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_TX_PROC
argument_list|,
literal|"%s: tx queue %u\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|qnum
argument_list|)
expr_stmt|;
for|for
control|(
name|nreaped
operator|=
literal|0
init|;
condition|;
name|nreaped
operator|++
control|)
block|{
name|MWL_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|MWL_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|MWL_TXDESC_SYNC
argument_list|(
name|txq
argument_list|,
name|ds
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|Status
operator|&
name|htole32
argument_list|(
name|EAGLE_TXD_STATUS_FW_OWNED
argument_list|)
condition|)
block|{
name|MWL_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|txq
operator|->
name|active
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|MWL_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MWL_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|MWL_DEBUG_XMIT_DESC
condition|)
name|mwl_printtxbuf
argument_list|(
name|bf
argument_list|,
name|txq
operator|->
name|qnum
argument_list|,
name|nreaped
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|an
operator|=
name|MWL_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|status
operator|=
name|le32toh
argument_list|(
name|ds
operator|->
name|Status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|EAGLE_TXD_STATUS_OK
condition|)
block|{
name|uint16_t
name|Format
init|=
name|le16toh
argument_list|(
name|ds
operator|->
name|Format
argument_list|)
decl_stmt|;
name|uint8_t
name|txant
init|=
name|MS
argument_list|(
name|Format
argument_list|,
name|EAGLE_TXD_ANTENNA
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_ant_tx
index|[
name|txant
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|EAGLE_TXD_STATUS_OK_RETRY
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_retries
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|EAGLE_TXD_STATUS_OK_MORE_RETRY
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_mretries
operator|++
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|qnum
operator|>=
name|MWL_WME_AC_VO
condition|)
name|ic
operator|->
name|ic_wme
operator|.
name|wme_hipri_traffic
operator|++
expr_stmt|;
name|ni
operator|->
name|ni_txrate
operator|=
name|MS
argument_list|(
name|Format
argument_list|,
name|EAGLE_TXD_RATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Format
operator|&
name|EAGLE_TXD_FORMAT_HT
operator|)
operator|==
literal|0
condition|)
block|{
name|ni
operator|->
name|ni_txrate
operator|=
name|mwl_cvtlegacyrix
argument_list|(
name|ni
operator|->
name|ni_txrate
argument_list|)
expr_stmt|;
block|}
else|else
name|ni
operator|->
name|ni_txrate
operator||=
name|IEEE80211_RATE_MCS
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_rate
operator|=
name|ni
operator|->
name|ni_txrate
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|status
operator|&
name|EAGLE_TXD_STATUS_FAILED_LINK_ERROR
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_linkerror
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|EAGLE_TXD_STATUS_FAILED_XRETRY
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_xretries
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|EAGLE_TXD_STATUS_FAILED_AGING
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_aging
operator|++
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|->
name|m_flags
operator|&
name|M_FF
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|mst_ff_txerr
operator|++
expr_stmt|;
block|}
comment|/* 			 * Do any tx complete callback.  Note this must 			 * be done before releasing the node reference. 			 * XXX no way to figure out if frame was ACK'd 			 */
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|->
name|m_flags
operator|&
name|M_TXCB
condition|)
block|{
comment|/* XXX strip fw len in case header inspected */
name|m_adj
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|ieee80211_process_callback
argument_list|(
name|ni
argument_list|,
name|bf
operator|->
name|bf_m
argument_list|,
operator|(
name|status
operator|&
name|EAGLE_TXD_STATUS_OK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Reclaim reference to node. 			 * 			 * NB: the node may be reclaimed here if, for example 			 *     this is a DEAUTH message that was sent and the 			 *     node was timed out due to inactivity. 			 */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|ds
operator|->
name|Status
operator|=
name|htole32
argument_list|(
name|EAGLE_TXD_STATUS_IDLE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|mwl_puttxbuf_tail
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
return|return
name|nreaped
return|;
undef|#
directive|undef
name|EAGLE_TXD_STATUS_MCAST
block|}
end_function

begin_comment
comment|/*  * Deferred processing of transmit interrupt; special-cased  * for four hardware queues, 0-3.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_tx_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|nreaped
decl_stmt|;
comment|/* 	 * Process each active queue. 	 */
name|nreaped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|0
index|]
operator|.
name|active
argument_list|)
condition|)
name|nreaped
operator|+=
name|mwl_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|1
index|]
operator|.
name|active
argument_list|)
condition|)
name|nreaped
operator|+=
name|mwl_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|2
index|]
operator|.
name|active
argument_list|)
condition|)
name|nreaped
operator|+=
name|mwl_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|3
index|]
operator|.
name|active
argument_list|)
condition|)
name|nreaped
operator|+=
name|mwl_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nreaped
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
comment|/* NB: kick fw; the tx thread may have been preempted */
name|mwl_hal_txstart
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mwl_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_tx_draintxq
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mwl_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mwl_txbuf
modifier|*
name|bf
decl_stmt|;
name|u_int
name|ix
decl_stmt|;
comment|/* 	 * NB: this assumes output has been stopped and 	 *     we do not need to block mwl_tx_tasklet 	 */
for|for
control|(
name|ix
operator|=
literal|0
init|;
condition|;
name|ix
operator|++
control|)
block|{
name|MWL_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|MWL_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|txq
operator|->
name|active
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|MWL_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MWL_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|MWL_DEBUG_RESET
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
specifier|const
name|struct
name|mwltxrec
modifier|*
name|tr
init|=
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
specifier|const
expr|struct
name|mwltxrec
operator|*
argument_list|)
decl_stmt|;
name|mwl_printtxbuf
argument_list|(
name|bf
argument_list|,
name|txq
operator|->
name|qnum
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|&
name|tr
operator|->
name|wh
argument_list|,
name|bf
operator|->
name|bf_m
operator|->
name|m_len
operator|-
sizeof|sizeof
argument_list|(
name|tr
operator|->
name|fwlen
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MWL_DEBUG */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Reclaim node reference. 			 */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|mwl_puttxbuf_tail
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Drain the transmit queues and reclaim resources.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_draintxq
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MWL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
name|mwl_tx_draintxq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MWL_DIAGAPI
end_ifdef

begin_comment
comment|/*  * Reset the transmit queues to a pristine state after a fw download.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_resettxq
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MWL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
name|mwl_txq_reset
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MWL_DIAGAPI */
end_comment

begin_comment
comment|/*  * Clear the transmit queues of any frames submitted for the  * specified vap.  This is done when the vap is deleted so we  * don't potentially reference the vap after it is gone.  * Note we cannot remove the frames; we only reclaim the node  * reference.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_cleartxq
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|mwl_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|mwl_txbuf
modifier|*
name|bf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MWL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
block|{
name|txq
operator|=
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
expr_stmt|;
name|MWL_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&txq->active
argument_list|,
argument|bf_list
argument_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
operator|&&
name|ni
operator|->
name|ni_vap
operator|==
name|vap
condition|)
block|{
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
name|MWL_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_recv_action
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
specifier|const
name|struct
name|ieee80211_action
modifier|*
name|ia
decl_stmt|;
name|ia
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_action
operator|*
operator|)
name|frm
expr_stmt|;
if|if
condition|(
name|ia
operator|->
name|ia_category
operator|==
name|IEEE80211_ACTION_CAT_HT
operator|&&
name|ia
operator|->
name|ia_action
operator|==
name|IEEE80211_ACTION_HT_MIMOPWRSAVE
condition|)
block|{
specifier|const
name|struct
name|ieee80211_action_ht_mimopowersave
modifier|*
name|mps
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_action_ht_mimopowersave
operator|*
operator|)
name|ia
decl_stmt|;
name|mwl_hal_setmimops
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|mps
operator|->
name|am_control
operator|&
name|IEEE80211_A_HT_MIMOPWRSAVE_ENA
argument_list|,
name|MS
argument_list|(
name|mps
operator|->
name|am_control
argument_list|,
name|IEEE80211_A_HT_MIMOPWRSAVE_MODE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|sc
operator|->
name|sc_recv_action
argument_list|(
name|ni
argument_list|,
name|wh
argument_list|,
name|frm
argument_list|,
name|efrm
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_addba_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|dialogtoken
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|mwl_node
modifier|*
name|mn
init|=
name|MWL_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|mwl_bastate
modifier|*
name|bas
decl_stmt|;
name|bas
operator|=
name|tap
operator|->
name|txa_private
expr_stmt|;
if|if
condition|(
name|bas
operator|==
name|NULL
condition|)
block|{
specifier|const
name|MWL_HAL_BASTREAM
modifier|*
name|sp
decl_stmt|;
comment|/* 		 * Check for a free BA stream slot. 		 */
if|#
directive|if
name|MWL_MAXBA
operator|>
literal|3
if|if
condition|(
name|mn
operator|->
name|mn_ba
index|[
literal|3
index|]
operator|.
name|bastream
operator|==
name|NULL
condition|)
name|bas
operator|=
operator|&
name|mn
operator|->
name|mn_ba
index|[
literal|3
index|]
expr_stmt|;
elseif|else
endif|#
directive|endif
if|#
directive|if
name|MWL_MAXBA
operator|>
literal|2
if|if
condition|(
name|mn
operator|->
name|mn_ba
index|[
literal|2
index|]
operator|.
name|bastream
operator|==
name|NULL
condition|)
name|bas
operator|=
operator|&
name|mn
operator|->
name|mn_ba
index|[
literal|2
index|]
expr_stmt|;
elseif|else
endif|#
directive|endif
if|#
directive|if
name|MWL_MAXBA
operator|>
literal|1
if|if
condition|(
name|mn
operator|->
name|mn_ba
index|[
literal|1
index|]
operator|.
name|bastream
operator|==
name|NULL
condition|)
name|bas
operator|=
operator|&
name|mn
operator|->
name|mn_ba
index|[
literal|1
index|]
expr_stmt|;
elseif|else
endif|#
directive|endif
if|#
directive|if
name|MWL_MAXBA
operator|>
literal|0
if|if
condition|(
name|mn
operator|->
name|mn_ba
index|[
literal|0
index|]
operator|.
name|bastream
operator|==
name|NULL
condition|)
name|bas
operator|=
operator|&
name|mn
operator|->
name|mn_ba
index|[
literal|0
index|]
expr_stmt|;
else|else
endif|#
directive|endif
block|{
comment|/* sta already has max BA streams */
comment|/* XXX assign BA stream to highest priority tid */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_AMPDU
argument_list|,
literal|"%s: already has max bastreams\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_ampdu_reject
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* NB: no held reference to ni */
name|sp
operator|=
name|mwl_hal_bastream_alloc
argument_list|(
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_hvap
argument_list|,
operator|(
name|baparamset
operator|&
name|IEEE80211_BAPS_POLICY_IMMEDIATE
operator|)
operator|!=
literal|0
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|WME_AC_TO_TID
argument_list|(
name|tap
operator|->
name|txa_ac
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_htparam
argument_list|,
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * No available stream, return 0 so no 			 * a-mpdu aggregation will be done. 			 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_AMPDU
argument_list|,
literal|"%s: no bastream available\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_ampdu_nostream
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_AMPDU
argument_list|,
literal|"%s: alloc bastream %p\n"
argument_list|,
name|__func__
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* NB: qos is left zero so we won't match in mwl_tx_start */
name|bas
operator|->
name|bastream
operator|=
name|sp
expr_stmt|;
name|tap
operator|->
name|txa_private
operator|=
name|bas
expr_stmt|;
block|}
comment|/* fetch current seq# from the firmware; if available */
if|if
condition|(
name|mwl_hal_bastream_get_seqno
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
name|bas
operator|->
name|bastream
argument_list|,
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|?
name|vap
operator|->
name|iv_myaddr
else|:
name|ni
operator|->
name|ni_macaddr
argument_list|,
operator|&
name|tap
operator|->
name|txa_start
argument_list|)
operator|!=
literal|0
condition|)
name|tap
operator|->
name|txa_start
operator|=
literal|0
expr_stmt|;
return|return
name|sc
operator|->
name|sc_addba_request
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|dialogtoken
argument_list|,
name|baparamset
argument_list|,
name|batimeout
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_addba_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mwl_bastate
modifier|*
name|bas
decl_stmt|;
name|bas
operator|=
name|tap
operator|->
name|txa_private
expr_stmt|;
if|if
condition|(
name|bas
operator|==
name|NULL
condition|)
block|{
comment|/* XXX should not happen */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_AMPDU
argument_list|,
literal|"%s: no BA stream allocated, AC %d\n"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_ac
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_addba_nostream
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|code
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int
name|bufsiz
decl_stmt|,
name|error
decl_stmt|;
comment|/* 		 * Tell the firmware to setup the BA stream; 		 * we know resources are available because we 		 * pre-allocated one before forming the request. 		 */
name|bufsiz
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufsiz
operator|==
literal|0
condition|)
name|bufsiz
operator|=
name|IEEE80211_AGGR_BAWMAX
expr_stmt|;
name|error
operator|=
name|mwl_hal_bastream_create
argument_list|(
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_hvap
argument_list|,
name|bas
operator|->
name|bastream
argument_list|,
name|bufsiz
argument_list|,
name|bufsiz
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Setup failed, return immediately so no a-mpdu 			 * aggregation will be done. 			 */
name|mwl_hal_bastream_destroy
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
name|bas
operator|->
name|bastream
argument_list|)
expr_stmt|;
name|mwl_bastream_free
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_private
operator|=
name|NULL
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_AMPDU
argument_list|,
literal|"%s: create failed, error %d, bufsiz %d AC %d "
literal|"htparam 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|bufsiz
argument_list|,
name|tap
operator|->
name|txa_ac
argument_list|,
name|ni
operator|->
name|ni_htparam
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_bacreate_failed
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* NB: cache txq to avoid ptr indirect */
name|mwl_bastream_setup
argument_list|(
name|bas
argument_list|,
name|tap
operator|->
name|txa_ac
argument_list|,
name|bas
operator|->
name|bastream
operator|->
name|txq
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_AMPDU
argument_list|,
literal|"%s: bastream %p assigned to txq %d AC %d bufsiz %d "
literal|"htparam 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|bas
operator|->
name|bastream
argument_list|,
name|bas
operator|->
name|txq
argument_list|,
name|tap
operator|->
name|txa_ac
argument_list|,
name|bufsiz
argument_list|,
name|ni
operator|->
name|ni_htparam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Other side NAK'd us; return the resources. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_AMPDU
argument_list|,
literal|"%s: request failed with code %d, destroy bastream %p\n"
argument_list|,
name|__func__
argument_list|,
name|code
argument_list|,
name|bas
operator|->
name|bastream
argument_list|)
expr_stmt|;
name|mwl_hal_bastream_destroy
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
name|bas
operator|->
name|bastream
argument_list|)
expr_stmt|;
name|mwl_bastream_free
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_private
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* NB: firmware sends BAR so we don't need to */
return|return
name|sc
operator|->
name|sc_addba_response
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|code
argument_list|,
name|baparamset
argument_list|,
name|batimeout
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_addba_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mwl_bastate
modifier|*
name|bas
decl_stmt|;
name|bas
operator|=
name|tap
operator|->
name|txa_private
expr_stmt|;
if|if
condition|(
name|bas
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_AMPDU
argument_list|,
literal|"%s: destroy bastream %p\n"
argument_list|,
name|__func__
argument_list|,
name|bas
operator|->
name|bastream
argument_list|)
expr_stmt|;
name|mwl_hal_bastream_destroy
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
name|bas
operator|->
name|bastream
argument_list|)
expr_stmt|;
name|mwl_bastream_free
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_private
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|sc_addba_stop
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup the rx data structures.  This should only be  * done once or we may get out of sync with the firmware.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_startrecv
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_recvsetup
condition|)
block|{
name|struct
name|mwl_rxbuf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|mwl_rxdesc
modifier|*
name|ds
decl_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_rxbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
name|int
name|error
init|=
name|mwl_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_RECV
argument_list|,
literal|"%s: mwl_rxbuf_init failed %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|ds
operator|=
name|prev
operator|->
name|bf_desc
expr_stmt|;
name|ds
operator|->
name|pPhysNext
operator|=
name|htole32
argument_list|(
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|bf
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|ds
operator|=
name|prev
operator|->
name|bf_desc
expr_stmt|;
name|ds
operator|->
name|pPhysNext
operator|=
name|htole32
argument_list|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_recvsetup
operator|=
literal|1
expr_stmt|;
block|}
name|mwl_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set filters, etc. */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|MWL_HAL_APMODE
name|mwl_getapmode
parameter_list|(
specifier|const
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|MWL_HAL_APMODE
name|mode
decl_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_PUREN
condition|)
name|mode
operator|=
name|AP_MODE_N_ONLY
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|mode
operator|=
name|AP_MODE_AandN
expr_stmt|;
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PUREG
condition|)
name|mode
operator|=
name|AP_MODE_GandN
expr_stmt|;
else|else
name|mode
operator|=
name|AP_MODE_BandGandN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PUREG
condition|)
name|mode
operator|=
name|AP_MODE_G_ONLY
expr_stmt|;
else|else
name|mode
operator|=
name|AP_MODE_MIXED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
name|mode
operator|=
name|AP_MODE_B_ONLY
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|chan
argument_list|)
condition|)
name|mode
operator|=
name|AP_MODE_A_ONLY
expr_stmt|;
else|else
name|mode
operator|=
name|AP_MODE_MIXED
expr_stmt|;
comment|/* XXX should not happen? */
return|return
name|mode
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_setapmode
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|mwl_hal_vap
modifier|*
name|hvap
init|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_hvap
decl_stmt|;
return|return
name|mwl_hal_setapmode
argument_list|(
name|hvap
argument_list|,
name|mwl_getapmode
argument_list|(
name|vap
argument_list|,
name|chan
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set/change channels.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_chan_set
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|MWL_HAL_CHANNEL
name|hchan
decl_stmt|;
name|int
name|maxtxpow
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_RESET
argument_list|,
literal|"%s: chan %u MHz/flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
comment|/* 	 * Convert to a HAL channel description with 	 * the flags constrained to reflect the current 	 * operating mode. 	 */
name|mwl_mapchan
argument_list|(
operator|&
name|hchan
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|mwl_hal_intrset
argument_list|(
name|mh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
if|#
directive|if
literal|0
block|mwl_draintxq(sc);
comment|/* clear pending tx frames */
endif|#
directive|endif
name|mwl_hal_setchannel
argument_list|(
name|mh
argument_list|,
operator|&
name|hchan
argument_list|)
expr_stmt|;
comment|/* 	 * Tx power is cap'd by the regulatory setting and 	 * possibly a user-set limit.  We pass the min of 	 * these to the hal to apply them to the cal data 	 * for this channel. 	 * XXX min bound? 	 */
name|maxtxpow
operator|=
literal|2
operator|*
name|chan
operator|->
name|ic_maxregpower
expr_stmt|;
if|if
condition|(
name|maxtxpow
operator|>
name|ic
operator|->
name|ic_txpowlimit
condition|)
name|maxtxpow
operator|=
name|ic
operator|->
name|ic_txpowlimit
expr_stmt|;
name|mwl_hal_settxpower
argument_list|(
name|mh
argument_list|,
operator|&
name|hchan
argument_list|,
name|maxtxpow
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* NB: potentially change mcast/mgt rates */
name|mwl_setcurchanrates
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Update internal state. 	 */
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_chan_freq
operator|=
name|htole16
argument_list|(
name|chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_freq
operator|=
name|htole16
argument_list|(
name|chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_chan_flags
operator|=
name|htole16
argument_list|(
name|IEEE80211_CHAN_A
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|IEEE80211_CHAN_A
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_chan_flags
operator|=
name|htole16
argument_list|(
name|IEEE80211_CHAN_G
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|IEEE80211_CHAN_G
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_chan_flags
operator|=
name|htole16
argument_list|(
name|IEEE80211_CHAN_B
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|IEEE80211_CHAN_B
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_curchan
operator|=
name|hchan
expr_stmt|;
name|mwl_hal_intrset
argument_list|(
name|mh
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_STATE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_STATE
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
operator|(
name|void
operator|)
name|mwl_chan_set
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Handle a channel switch request.  We inform the firmware  * and mark the global state to suppress various actions.  * NB: we issue only one request to the fw; we may be called  * multiple times if there are multiple vap's.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_startcsa
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|MWL_HAL_CHANNEL
name|hchan
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_csapending
condition|)
return|return;
name|mwl_mapchan
argument_list|(
operator|&
name|hchan
argument_list|,
name|ic
operator|->
name|ic_csa_newchan
argument_list|)
expr_stmt|;
comment|/* 1 =>'s quiet channel */
name|mwl_hal_setchannelswitchie
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
operator|&
name|hchan
argument_list|,
literal|1
argument_list|,
name|ic
operator|->
name|ic_csa_count
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_csapending
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Plumb any static WEP key for the station.  This is  * necessary as we must propagate the key from the  * global key table of the vap to each sta db entry.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_setanywepkey
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
operator|(
name|IEEE80211_F_PRIVACY
operator||
name|IEEE80211_F_WPA
operator|)
operator|)
operator|==
name|IEEE80211_F_PRIVACY
operator|&&
name|vap
operator|->
name|iv_def_txkey
operator|!=
name|IEEE80211_KEYIX_NONE
operator|&&
name|vap
operator|->
name|iv_nw_keys
index|[
name|vap
operator|->
name|iv_def_txkey
index|]
operator|.
name|wk_keyix
operator|!=
name|IEEE80211_KEYIX_NONE
condition|)
operator|(
name|void
operator|)
name|mwl_key_set
argument_list|(
name|vap
argument_list|,
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
name|vap
operator|->
name|iv_def_txkey
index|]
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_peerstadb
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|aid
parameter_list|,
name|int
name|staid
parameter_list|,
name|MWL_HAL_PEERINFO
modifier|*
name|pi
parameter_list|)
block|{
define|#
directive|define
name|WME
parameter_list|(
name|ie
parameter_list|)
value|((const struct ieee80211_wme_info *) ie)
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|mwl_hal_vap
modifier|*
name|hvap
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_WDS
condition|)
block|{
comment|/* 		 * WDS vap's do not have a f/w vap; instead they piggyback 		 * on an AP vap and we must install the sta db entry and 		 * crypto state using that AP's handle (the WDS vap has none). 		 */
name|hvap
operator|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_ap_hvap
expr_stmt|;
block|}
else|else
name|hvap
operator|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_hvap
expr_stmt|;
name|error
operator|=
name|mwl_hal_newstation
argument_list|(
name|hvap
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|aid
argument_list|,
name|staid
argument_list|,
name|pi
argument_list|,
name|ni
operator|->
name|ni_flags
operator|&
operator|(
name|IEEE80211_NODE_QOS
operator||
name|IEEE80211_NODE_HT
operator|)
argument_list|,
name|ni
operator|->
name|ni_ies
operator|.
name|wme_ie
operator|!=
name|NULL
condition|?
name|WME
argument_list|(
name|ni
operator|->
name|ni_ies
operator|.
name|wme_ie
argument_list|)
operator|->
name|wme_info
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Setup security for this station.  For sta mode this is 		 * needed even though do the same thing on transition to 		 * AUTH state because the call to mwl_hal_newstation 		 * clobbers the crypto state we setup. 		 */
name|mwl_setanywepkey
argument_list|(
name|vap
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
undef|#
directive|undef
name|WME
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_setglobalkeys
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211_key
modifier|*
name|wk
decl_stmt|;
name|wk
operator|=
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
init|;
name|wk
operator|<
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
name|IEEE80211_WEP_NKID
index|]
condition|;
name|wk
operator|++
control|)
if|if
condition|(
name|wk
operator|->
name|wk_keyix
operator|!=
name|IEEE80211_KEYIX_NONE
condition|)
operator|(
name|void
operator|)
name|mwl_key_set
argument_list|(
name|vap
argument_list|,
name|wk
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert a legacy rate set to a firmware bitmask.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|get_rate_bitmap
parameter_list|(
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
name|uint32_t
name|rates
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rates
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
condition|)
block|{
case|case
literal|2
case|:
name|rates
operator||=
literal|0x001
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|rates
operator||=
literal|0x002
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|rates
operator||=
literal|0x004
expr_stmt|;
break|break;
case|case
literal|22
case|:
name|rates
operator||=
literal|0x008
expr_stmt|;
break|break;
case|case
literal|44
case|:
name|rates
operator||=
literal|0x010
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|rates
operator||=
literal|0x020
expr_stmt|;
break|break;
case|case
literal|18
case|:
name|rates
operator||=
literal|0x040
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|rates
operator||=
literal|0x080
expr_stmt|;
break|break;
case|case
literal|36
case|:
name|rates
operator||=
literal|0x100
expr_stmt|;
break|break;
case|case
literal|48
case|:
name|rates
operator||=
literal|0x200
expr_stmt|;
break|break;
case|case
literal|72
case|:
name|rates
operator||=
literal|0x400
expr_stmt|;
break|break;
case|case
literal|96
case|:
name|rates
operator||=
literal|0x800
expr_stmt|;
break|break;
case|case
literal|108
case|:
name|rates
operator||=
literal|0x1000
expr_stmt|;
break|break;
block|}
return|return
name|rates
return|;
block|}
end_function

begin_comment
comment|/*  * Construct an HT firmware bitmask from an HT rate set.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|get_htrate_bitmap
parameter_list|(
specifier|const
name|struct
name|ieee80211_htrateset
modifier|*
name|rs
parameter_list|)
block|{
name|uint32_t
name|rates
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rates
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|<
literal|16
condition|)
name|rates
operator||=
literal|1
operator|<<
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|rates
return|;
block|}
end_function

begin_comment
comment|/*  * Craft station database entry for station.  * NB: use host byte order here, the hal handles byte swapping.  */
end_comment

begin_function
specifier|static
name|MWL_HAL_PEERINFO
modifier|*
name|mkpeerinfo
parameter_list|(
name|MWL_HAL_PEERINFO
modifier|*
name|pi
parameter_list|,
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|memset
argument_list|(
name|pi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pi
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|LegacyRateBitMap
operator|=
name|get_rate_bitmap
argument_list|(
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
name|pi
operator|->
name|CapInfo
operator|=
name|ni
operator|->
name|ni_capinfo
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|)
block|{
comment|/* HT capabilities, etc */
name|pi
operator|->
name|HTCapabilitiesInfo
operator|=
name|ni
operator|->
name|ni_htcap
expr_stmt|;
comment|/* XXX pi.HTCapabilitiesInfo */
name|pi
operator|->
name|MacHTParamInfo
operator|=
name|ni
operator|->
name|ni_htparam
expr_stmt|;
name|pi
operator|->
name|HTRateBitMap
operator|=
name|get_htrate_bitmap
argument_list|(
operator|&
name|ni
operator|->
name|ni_htrates
argument_list|)
expr_stmt|;
name|pi
operator|->
name|AddHtInfo
operator|.
name|ControlChan
operator|=
name|ni
operator|->
name|ni_htctlchan
expr_stmt|;
name|pi
operator|->
name|AddHtInfo
operator|.
name|AddChan
operator|=
name|ni
operator|->
name|ni_ht2ndchan
expr_stmt|;
name|pi
operator|->
name|AddHtInfo
operator|.
name|OpMode
operator|=
name|ni
operator|->
name|ni_htopmode
expr_stmt|;
name|pi
operator|->
name|AddHtInfo
operator|.
name|stbc
operator|=
name|ni
operator|->
name|ni_htstbc
expr_stmt|;
comment|/* constrain according to local configuration */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_SHORTGI40
operator|)
operator|==
literal|0
condition|)
name|pi
operator|->
name|HTCapabilitiesInfo
operator|&=
operator|~
name|IEEE80211_HTCAP_SHORTGI40
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_SHORTGI20
operator|)
operator|==
literal|0
condition|)
name|pi
operator|->
name|HTCapabilitiesInfo
operator|&=
operator|~
name|IEEE80211_HTCAP_SHORTGI20
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_chw
operator|!=
literal|40
condition|)
name|pi
operator|->
name|HTCapabilitiesInfo
operator|&=
operator|~
name|IEEE80211_HTCAP_CHWIDTH40
expr_stmt|;
block|}
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/*  * Re-create the local sta db entry for a vap to ensure  * up to date WME state is pushed to the firmware.  Because  * this resets crypto state this must be followed by a  * reload of any keys in the global key table.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_localstadb
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
define|#
directive|define
name|WME
parameter_list|(
name|ie
parameter_list|)
value|((const struct ieee80211_wme_info *) ie)
name|struct
name|mwl_hal_vap
modifier|*
name|hvap
init|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_hvap
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|bss
decl_stmt|;
name|MWL_HAL_PEERINFO
name|pi
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|vap
operator|->
name|iv_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|bss
operator|=
name|vap
operator|->
name|iv_bss
expr_stmt|;
name|error
operator|=
name|mwl_hal_newstation
argument_list|(
name|hvap
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|?
name|mkpeerinfo
argument_list|(
operator|&
name|pi
argument_list|,
name|bss
argument_list|)
else|:
name|NULL
argument_list|,
operator|(
name|bss
operator|->
name|ni_flags
operator|&
operator|(
name|IEEE80211_NODE_QOS
operator||
name|IEEE80211_NODE_HT
operator|)
operator|)
argument_list|,
name|bss
operator|->
name|ni_ies
operator|.
name|wme_ie
operator|!=
name|NULL
condition|?
name|WME
argument_list|(
name|bss
operator|->
name|ni_ies
operator|.
name|wme_ie
argument_list|)
operator|->
name|wme_info
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|mwl_setglobalkeys
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_MBSS
case|:
name|error
operator|=
name|mwl_hal_newstation
argument_list|(
name|hvap
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|mwl_setglobalkeys
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
undef|#
directive|undef
name|WME
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|mwl_vap
modifier|*
name|mvp
init|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|mwl_hal_vap
modifier|*
name|hvap
init|=
name|mvp
operator|->
name|mv_hvap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
name|enum
name|ieee80211_state
name|ostate
init|=
name|vap
operator|->
name|iv_state
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_STATE
argument_list|,
literal|"%s: %s: %s -> %s\n"
argument_list|,
name|vap
operator|->
name|iv_ifp
operator|->
name|if_xname
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer
argument_list|)
expr_stmt|;
comment|/* 	 * Clear current radar detection state. 	 */
if|if
condition|(
name|ostate
operator|==
name|IEEE80211_S_CAC
condition|)
block|{
comment|/* stop quiet mode radar detection */
name|mwl_hal_setradardetection
argument_list|(
name|mh
argument_list|,
name|DR_CHK_CHANNEL_AVAILABLE_STOP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_radarena
condition|)
block|{
comment|/* stop in-service radar detection */
name|mwl_hal_setradardetection
argument_list|(
name|mh
argument_list|,
name|DR_DFS_DISABLE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_radarena
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Carry out per-state actions before doing net80211 work. 	 */
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* NB: only ap+sta vap's have a fw entity */
if|if
condition|(
name|hvap
operator|!=
name|NULL
condition|)
name|mwl_hal_stop
argument_list|(
name|hvap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SCAN
condition|)
block|{
name|mwl_hal_start
argument_list|(
name|hvap
argument_list|)
expr_stmt|;
comment|/* NB: this disables beacon frames */
name|mwl_hal_setinframode
argument_list|(
name|hvap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_AUTH
condition|)
block|{
comment|/* 		 * Must create a sta db entry in case a WEP key needs to 		 * be plumbed.  This entry will be overwritten if we 		 * associate; otherwise it will be reclaimed on node free. 		 */
name|ni
operator|=
name|vap
operator|->
name|iv_bss
expr_stmt|;
name|MWL_NODE
argument_list|(
name|ni
argument_list|)
operator|->
name|mn_hvap
operator|=
name|hvap
expr_stmt|;
operator|(
name|void
operator|)
name|mwl_peerstadb
argument_list|(
name|ni
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_CSA
condition|)
block|{
comment|/* XXX move to below? */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|mwl_startcsa
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_CAC
condition|)
block|{
comment|/* XXX move to below? */
comment|/* stop ap xmit and enable quiet mode radar detection */
name|mwl_hal_setradardetection
argument_list|(
name|mh
argument_list|,
name|DR_CHK_CHANNEL_AVAILABLE_START
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Invoke the parent method to do net80211 work. 	 */
name|error
operator|=
name|mvp
operator|->
name|mv_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* 	 * Carry out work that must be done after net80211 runs; 	 * this work requires up to date state (e.g. iv_bss). 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* NB: collect bss node again, it may have changed */
name|ni
operator|=
name|vap
operator|->
name|iv_bss
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_STATE
argument_list|,
literal|"%s: %s(RUN): iv_flags 0x%08x bintvl %d bssid %s "
literal|"capinfo 0x%04x chan %d\n"
argument_list|,
name|vap
operator|->
name|iv_ifp
operator|->
name|if_xname
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_flags
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_capinfo
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Recreate local sta db entry to update WME/HT state. 		 */
name|mwl_localstadb
argument_list|(
name|vap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vap
operator|->
name|iv_opmode
condition|)
block|{
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_MBSS
case|:
if|if
condition|(
name|ostate
operator|==
name|IEEE80211_S_CAC
condition|)
block|{
comment|/* enable in-service radar detection */
name|mwl_hal_setradardetection
argument_list|(
name|mh
argument_list|,
name|DR_IN_SERVICE_MONITOR_START
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_radarena
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 			 * Allocate and setup the beacon frame 			 * (and related state). 			 */
name|error
operator|=
name|mwl_reset_vap
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_RUN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_STATE
argument_list|,
literal|"%s: beacon setup failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* NB: must be after setting up beacon */
name|mwl_hal_start
argument_list|(
name|hvap
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_STA
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_STATE
argument_list|,
literal|"%s: %s: aid 0x%x\n"
argument_list|,
name|vap
operator|->
name|iv_ifp
operator|->
name|if_xname
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
comment|/* 			 * Set state now that we're associated. 			 */
name|mwl_hal_setassocid
argument_list|(
name|hvap
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|,
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
name|mwl_setrates
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|mwl_hal_setrtsthreshold
argument_list|(
name|hvap
argument_list|,
name|vap
operator|->
name|iv_rtsthreshold
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DWDS
operator|)
operator|&&
name|sc
operator|->
name|sc_ndwdsvaps
operator|++
operator|==
literal|0
condition|)
name|mwl_hal_setdwds
argument_list|(
name|mh
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_WDS
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_STATE
argument_list|,
literal|"%s: %s: bssid %s\n"
argument_list|,
name|vap
operator|->
name|iv_ifp
operator|->
name|if_xname
argument_list|,
name|__func__
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|)
expr_stmt|;
name|mwl_seteapolformat
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 		 * Set CS mode according to operating channel; 		 * this mostly an optimization for 5GHz. 		 * 		 * NB: must follow mwl_hal_start which resets csmode 		 */
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|mwl_hal_setcsmode
argument_list|(
name|mh
argument_list|,
name|CSMODE_AGGRESSIVE
argument_list|)
expr_stmt|;
else|else
name|mwl_hal_setcsmode
argument_list|(
name|mh
argument_list|,
name|CSMODE_AUTO_ENA
argument_list|)
expr_stmt|;
comment|/* 		 * Start timer to prod firmware. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_ageinterval
operator|!=
literal|0
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer
argument_list|,
name|sc
operator|->
name|sc_ageinterval
operator|*
name|hz
argument_list|,
name|mwl_agestations
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SLEEP
condition|)
block|{
comment|/* XXX set chip in power save */
block|}
elseif|else
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DWDS
operator|)
operator|&&
operator|--
name|sc
operator|->
name|sc_ndwdsvaps
operator|==
literal|0
condition|)
name|mwl_hal_setdwds
argument_list|(
name|mh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bad
label|:
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Manage station id's; these are separate from AID's  * as AID's may have values out of the range of possible  * station id's acceptable to the firmware.  */
end_comment

begin_function
specifier|static
name|int
name|allocstaid
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|int
name|aid
parameter_list|)
block|{
name|int
name|staid
decl_stmt|;
if|if
condition|(
operator|!
operator|(
literal|0
operator|<
name|aid
operator|&&
name|aid
operator|<
name|MWL_MAXSTAID
operator|)
operator|||
name|isset
argument_list|(
name|sc
operator|->
name|sc_staid
argument_list|,
name|aid
argument_list|)
condition|)
block|{
comment|/* NB: don't use 0 */
for|for
control|(
name|staid
operator|=
literal|1
init|;
name|staid
operator|<
name|MWL_MAXSTAID
condition|;
name|staid
operator|++
control|)
if|if
condition|(
name|isclr
argument_list|(
name|sc
operator|->
name|sc_staid
argument_list|,
name|staid
argument_list|)
condition|)
break|break;
block|}
else|else
name|staid
operator|=
name|aid
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_staid
argument_list|,
name|staid
argument_list|)
expr_stmt|;
return|return
name|staid
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delstaid
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|int
name|staid
parameter_list|)
block|{
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_staid
argument_list|,
name|staid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup driver-specific state for a newly associated node.  * Note that we're called also on a re-associate, the isnew  * param tells us if this is the first time or not.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|isnew
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mwl_node
modifier|*
name|mn
init|=
name|MWL_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|MWL_HAL_PEERINFO
name|pi
decl_stmt|;
name|uint16_t
name|aid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|aid
operator|=
name|IEEE80211_AID
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnew
condition|)
block|{
name|mn
operator|->
name|mn_staid
operator|=
name|allocstaid
argument_list|(
name|sc
argument_list|,
name|aid
argument_list|)
expr_stmt|;
name|mn
operator|->
name|mn_hvap
operator|=
name|MWL_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|mv_hvap
expr_stmt|;
block|}
else|else
block|{
name|mn
operator|=
name|MWL_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* XXX reset BA stream? */
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_NODE
argument_list|,
literal|"%s: mac %s isnew %d aid %d staid %d\n"
argument_list|,
name|__func__
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|isnew
argument_list|,
name|aid
argument_list|,
name|mn
operator|->
name|mn_staid
argument_list|)
expr_stmt|;
name|error
operator|=
name|mwl_peerstadb
argument_list|(
name|ni
argument_list|,
name|aid
argument_list|,
name|mn
operator|->
name|mn_staid
argument_list|,
name|mkpeerinfo
argument_list|(
operator|&
name|pi
argument_list|,
name|ni
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|MWL_DEBUG_NODE
argument_list|,
literal|"%s: error %d creating sta db entry\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* XXX how to deal with error? */
block|}
block|}
end_function

begin_comment
comment|/*  * Periodically poke the firmware to age out station state  * (power save queues, pending tx aggregates).  */
end_comment

begin_function
specifier|static
name|void
name|mwl_agestations
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|mwl_hal_setkeepalive
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ageinterval
operator|!=
literal|0
condition|)
comment|/* NB: catch dynamic changes */
name|callout_schedule
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer
argument_list|,
name|sc
operator|->
name|sc_ageinterval
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|mwl_hal_channel
modifier|*
name|findhalchannel
parameter_list|(
specifier|const
name|MWL_HAL_CHANNELINFO
modifier|*
name|ci
parameter_list|,
name|int
name|ieee
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ci
operator|->
name|nchannels
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|mwl_hal_channel
modifier|*
name|hc
init|=
operator|&
name|ci
operator|->
name|channels
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|hc
operator|->
name|ieee
operator|==
name|ieee
condition|)
return|return
name|hc
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_setregdomain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_regdomain
modifier|*
name|rd
parameter_list|,
name|int
name|nchan
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
specifier|const
name|MWL_HAL_CHANNELINFO
modifier|*
name|ci
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchan
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
operator|&
name|chans
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|struct
name|mwl_hal_channel
modifier|*
name|hc
decl_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mwl_hal_getchannelinfo
argument_list|(
name|mh
argument_list|,
name|MWL_FREQ_BAND_2DOT4GHZ
argument_list|,
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|?
name|MWL_CH_40_MHz_WIDTH
else|:
name|MWL_CH_20_MHz_WIDTH
argument_list|,
operator|&
name|ci
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|mwl_hal_getchannelinfo
argument_list|(
name|mh
argument_list|,
name|MWL_FREQ_BAND_5GHZ
argument_list|,
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|?
name|MWL_CH_40_MHz_WIDTH
else|:
name|MWL_CH_20_MHz_WIDTH
argument_list|,
operator|&
name|ci
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"%s: channel %u freq %u/0x%x not 2.4/5GHz\n"
argument_list|,
name|__func__
argument_list|,
name|c
operator|->
name|ic_ieee
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/*  		 * Verify channel has cal data and cap tx power. 		 */
name|hc
operator|=
name|findhalchannel
argument_list|(
name|ci
argument_list|,
name|c
operator|->
name|ic_ieee
argument_list|)
expr_stmt|;
if|if
condition|(
name|hc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|ic_maxpower
operator|>
literal|2
operator|*
name|hc
operator|->
name|maxTxPow
condition|)
name|c
operator|->
name|ic_maxpower
operator|=
literal|2
operator|*
name|hc
operator|->
name|maxTxPow
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* 			 * Look for the extension channel since the 			 * hal table only has the primary channel. 			 */
name|hc
operator|=
name|findhalchannel
argument_list|(
name|ci
argument_list|,
name|c
operator|->
name|ic_extieee
argument_list|)
expr_stmt|;
if|if
condition|(
name|hc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|ic_maxpower
operator|>
literal|2
operator|*
name|hc
operator|->
name|maxTxPow
condition|)
name|c
operator|->
name|ic_maxpower
operator|=
literal|2
operator|*
name|hc
operator|->
name|maxTxPow
expr_stmt|;
goto|goto
name|next
goto|;
block|}
block|}
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"%s: no cal data for channel %u ext %u freq %u/0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|c
operator|->
name|ic_ieee
argument_list|,
name|c
operator|->
name|ic_extieee
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
name|next
label|:
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IEEE80211_CHAN_HTG
value|(IEEE80211_CHAN_HT|IEEE80211_CHAN_G)
end_define

begin_define
define|#
directive|define
name|IEEE80211_CHAN_HTA
value|(IEEE80211_CHAN_HT|IEEE80211_CHAN_A)
end_define

begin_function
specifier|static
name|void
name|addchan
parameter_list|(
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|int
name|freq
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|ieee
parameter_list|,
name|int
name|txpow
parameter_list|)
block|{
name|c
operator|->
name|ic_freq
operator|=
name|freq
expr_stmt|;
name|c
operator|->
name|ic_flags
operator|=
name|flags
expr_stmt|;
name|c
operator|->
name|ic_ieee
operator|=
name|ieee
expr_stmt|;
name|c
operator|->
name|ic_minpower
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|ic_maxpower
operator|=
literal|2
operator|*
name|txpow
expr_stmt|;
name|c
operator|->
name|ic_maxregpower
operator|=
name|txpow
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|findchannel
parameter_list|(
specifier|const
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|nchans
parameter_list|,
name|int
name|freq
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchans
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|chans
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ic_freq
operator|==
name|freq
operator|&&
name|c
operator|->
name|ic_flags
operator|==
name|flags
condition|)
return|return
name|c
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|addht40channels
parameter_list|(
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
specifier|const
name|MWL_HAL_CHANNELINFO
modifier|*
name|ci
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|extc
decl_stmt|;
specifier|const
name|struct
name|mwl_hal_channel
modifier|*
name|hc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|c
operator|=
operator|&
name|chans
index|[
operator|*
name|nchans
index|]
expr_stmt|;
name|flags
operator|&=
operator|~
name|IEEE80211_CHAN_HT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ci
operator|->
name|nchannels
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Each entry defines an HT40 channel pair; find the 		 * extension channel above and the insert the pair. 		 */
name|hc
operator|=
operator|&
name|ci
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
name|extc
operator|=
name|findchannel
argument_list|(
name|chans
argument_list|,
operator|*
name|nchans
argument_list|,
name|hc
operator|->
name|freq
operator|+
literal|20
argument_list|,
name|flags
operator||
name|IEEE80211_CHAN_HT20
argument_list|)
expr_stmt|;
if|if
condition|(
name|extc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|nchans
operator|>=
name|maxchans
condition|)
break|break;
name|addchan
argument_list|(
name|c
argument_list|,
name|hc
operator|->
name|freq
argument_list|,
name|flags
operator||
name|IEEE80211_CHAN_HT40U
argument_list|,
name|hc
operator|->
name|ieee
argument_list|,
name|hc
operator|->
name|maxTxPow
argument_list|)
expr_stmt|;
name|c
operator|->
name|ic_extieee
operator|=
name|extc
operator|->
name|ic_ieee
expr_stmt|;
name|c
operator|++
operator|,
operator|(
operator|*
name|nchans
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|nchans
operator|>=
name|maxchans
condition|)
break|break;
name|addchan
argument_list|(
name|c
argument_list|,
name|extc
operator|->
name|ic_freq
argument_list|,
name|flags
operator||
name|IEEE80211_CHAN_HT40D
argument_list|,
name|extc
operator|->
name|ic_ieee
argument_list|,
name|hc
operator|->
name|maxTxPow
argument_list|)
expr_stmt|;
name|c
operator|->
name|ic_extieee
operator|=
name|hc
operator|->
name|ieee
expr_stmt|;
name|c
operator|++
operator|,
operator|(
operator|*
name|nchans
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|addchannels
parameter_list|(
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
specifier|const
name|MWL_HAL_CHANNELINFO
modifier|*
name|ci
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|c
operator|=
operator|&
name|chans
index|[
operator|*
name|nchans
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ci
operator|->
name|nchannels
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|mwl_hal_channel
modifier|*
name|hc
decl_stmt|;
name|hc
operator|=
operator|&
name|ci
operator|->
name|channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|nchans
operator|>=
name|maxchans
condition|)
break|break;
name|addchan
argument_list|(
name|c
argument_list|,
name|hc
operator|->
name|freq
argument_list|,
name|flags
argument_list|,
name|hc
operator|->
name|ieee
argument_list|,
name|hc
operator|->
name|maxTxPow
argument_list|)
expr_stmt|;
name|c
operator|++
operator|,
operator|(
operator|*
name|nchans
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|IEEE80211_CHAN_G
operator|||
name|flags
operator|==
name|IEEE80211_CHAN_HTG
condition|)
block|{
comment|/* g channel have a separate b-only entry */
if|if
condition|(
operator|*
name|nchans
operator|>=
name|maxchans
condition|)
break|break;
name|c
index|[
literal|0
index|]
operator|=
name|c
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|c
index|[
operator|-
literal|1
index|]
operator|.
name|ic_flags
operator|=
name|IEEE80211_CHAN_B
expr_stmt|;
name|c
operator|++
operator|,
operator|(
operator|*
name|nchans
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|==
name|IEEE80211_CHAN_HTG
condition|)
block|{
comment|/* HT g channel have a separate g-only entry */
if|if
condition|(
operator|*
name|nchans
operator|>=
name|maxchans
condition|)
break|break;
name|c
index|[
operator|-
literal|1
index|]
operator|.
name|ic_flags
operator|=
name|IEEE80211_CHAN_G
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|c
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|.
name|ic_flags
operator|&=
operator|~
name|IEEE80211_CHAN_HT
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|.
name|ic_flags
operator||=
name|IEEE80211_CHAN_HT20
expr_stmt|;
comment|/* HT20 */
name|c
operator|++
operator|,
operator|(
operator|*
name|nchans
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|==
name|IEEE80211_CHAN_HTA
condition|)
block|{
comment|/* HT a channel have a separate a-only entry */
if|if
condition|(
operator|*
name|nchans
operator|>=
name|maxchans
condition|)
break|break;
name|c
index|[
operator|-
literal|1
index|]
operator|.
name|ic_flags
operator|=
name|IEEE80211_CHAN_A
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|c
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|.
name|ic_flags
operator|&=
operator|~
name|IEEE80211_CHAN_HT
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|.
name|ic_flags
operator||=
name|IEEE80211_CHAN_HT20
expr_stmt|;
comment|/* HT20 */
name|c
operator|++
operator|,
operator|(
operator|*
name|nchans
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getchannels
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
specifier|const
name|MWL_HAL_CHANNELINFO
modifier|*
name|ci
decl_stmt|;
comment|/* 	 * Use the channel info from the hal to craft the 	 * channel list.  Note that we pass back an unsorted 	 * list; the caller is required to sort it for us 	 * (if desired). 	 */
operator|*
name|nchans
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mwl_hal_getchannelinfo
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
name|MWL_FREQ_BAND_2DOT4GHZ
argument_list|,
name|MWL_CH_20_MHz_WIDTH
argument_list|,
operator|&
name|ci
argument_list|)
operator|==
literal|0
condition|)
name|addchannels
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|ci
argument_list|,
name|IEEE80211_CHAN_HTG
argument_list|)
expr_stmt|;
if|if
condition|(
name|mwl_hal_getchannelinfo
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
name|MWL_FREQ_BAND_5GHZ
argument_list|,
name|MWL_CH_20_MHz_WIDTH
argument_list|,
operator|&
name|ci
argument_list|)
operator|==
literal|0
condition|)
name|addchannels
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|ci
argument_list|,
name|IEEE80211_CHAN_HTA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mwl_hal_getchannelinfo
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
name|MWL_FREQ_BAND_2DOT4GHZ
argument_list|,
name|MWL_CH_40_MHz_WIDTH
argument_list|,
operator|&
name|ci
argument_list|)
operator|==
literal|0
condition|)
name|addht40channels
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|ci
argument_list|,
name|IEEE80211_CHAN_HTG
argument_list|)
expr_stmt|;
if|if
condition|(
name|mwl_hal_getchannelinfo
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
name|MWL_FREQ_BAND_5GHZ
argument_list|,
name|MWL_CH_40_MHz_WIDTH
argument_list|,
operator|&
name|ci
argument_list|)
operator|==
literal|0
condition|)
name|addht40channels
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|ci
argument_list|,
name|IEEE80211_CHAN_HTA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_getradiocaps
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|getchannels
argument_list|(
name|sc
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|chans
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_getchannels
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
comment|/* 	 * Use the channel info from the hal to craft the 	 * channel list for net80211.  Note that we pass up 	 * an unsorted list; net80211 will sort it for us. 	 */
name|memset
argument_list|(
name|ic
operator|->
name|ic_channels
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ic
operator|->
name|ic_channels
argument_list|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_nchans
operator|=
literal|0
expr_stmt|;
name|getchannels
argument_list|(
name|sc
argument_list|,
name|IEEE80211_CHAN_MAX
argument_list|,
operator|&
name|ic
operator|->
name|ic_nchans
argument_list|,
name|ic
operator|->
name|ic_channels
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|regdomain
operator|=
name|SKU_DEBUG
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|country
operator|=
name|CTRY_DEFAULT
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|location
operator|=
literal|'I'
expr_stmt|;
name|ic
operator|->
name|ic_regdomain
operator|.
name|isocc
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* XXX? */
name|ic
operator|->
name|ic_regdomain
operator|.
name|isocc
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
return|return
operator|(
name|ic
operator|->
name|ic_nchans
operator|==
literal|0
condition|?
name|EIO
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|IEEE80211_CHAN_HTA
end_undef

begin_undef
undef|#
directive|undef
name|IEEE80211_CHAN_HTG
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|MWL_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|mwl_printrxbuf
parameter_list|(
specifier|const
name|struct
name|mwl_rxbuf
modifier|*
name|bf
parameter_list|,
name|u_int
name|ix
parameter_list|)
block|{
specifier|const
name|struct
name|mwl_rxdesc
modifier|*
name|ds
init|=
name|bf
operator|->
name|bf_desc
decl_stmt|;
name|uint32_t
name|status
init|=
name|le32toh
argument_list|(
name|ds
operator|->
name|Status
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"R[%2u] (DS.V:%p DS.P:%p) NEXT:%08x DATA:%08x RC:%02x%s\n"
literal|"      STAT:%02x LEN:%04x RSSI:%02x CHAN:%02x RATE:%02x QOS:%04x HT:%04x\n"
argument_list|,
name|ix
argument_list|,
name|ds
argument_list|,
operator|(
specifier|const
expr|struct
name|mwl_desc
operator|*
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|pPhysNext
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|pPhysBuffData
argument_list|)
argument_list|,
name|ds
operator|->
name|RxControl
argument_list|,
name|ds
operator|->
name|RxControl
operator|!=
name|EAGLE_RXD_CTRL_DRIVER_OWN
condition|?
literal|""
else|:
operator|(
name|status
operator|&
name|EAGLE_RXD_STATUS_OK
operator|)
condition|?
literal|" *"
else|:
literal|" !"
argument_list|,
name|ds
operator|->
name|Status
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|PktLen
argument_list|)
argument_list|,
name|ds
operator|->
name|RSSI
argument_list|,
name|ds
operator|->
name|Channel
argument_list|,
name|ds
operator|->
name|Rate
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|QosCtrl
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|HtSig2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_printtxbuf
parameter_list|(
specifier|const
name|struct
name|mwl_txbuf
modifier|*
name|bf
parameter_list|,
name|u_int
name|qnum
parameter_list|,
name|u_int
name|ix
parameter_list|)
block|{
specifier|const
name|struct
name|mwl_txdesc
modifier|*
name|ds
init|=
name|bf
operator|->
name|bf_desc
decl_stmt|;
name|uint32_t
name|status
init|=
name|le32toh
argument_list|(
name|ds
operator|->
name|Status
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"Q%u[%3u]"
argument_list|,
name|qnum
argument_list|,
name|ix
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (DS.V:%p DS.P:%p)\n"
argument_list|,
name|ds
argument_list|,
operator|(
specifier|const
expr|struct
name|mwl_txdesc
operator|*
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    NEXT:%08x DATA:%08x LEN:%04x STAT:%08x%s\n"
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|pPhysNext
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|PktPtr
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|PktLen
argument_list|)
argument_list|,
name|status
argument_list|,
name|status
operator|&
name|EAGLE_TXD_STATUS_USED
condition|?
literal|""
else|:
operator|(
name|status
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|?
literal|" *"
else|:
literal|" !"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    RATE:%02x PRI:%x QOS:%04x SAP:%08x FORMAT:%04x\n"
argument_list|,
name|ds
operator|->
name|DataRate
argument_list|,
name|ds
operator|->
name|TxPriority
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|QosCtrl
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|SapPktInfo
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|Format
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|MWL_TXDESC
operator|>
literal|1
name|printf
argument_list|(
literal|"    MULTIFRAMES:%u LEN:%04x %04x %04x %04x %04x %04x\n"
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|multiframes
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|PktLenArray
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|PktLenArray
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|PktLenArray
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|PktLenArray
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|PktLenArray
index|[
literal|4
index|]
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|ds
operator|->
name|PktLenArray
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    DATA:%08x %08x %08x %08x %08x %08x\n"
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|PktPtrArray
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|PktPtrArray
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|PktPtrArray
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|PktPtrArray
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|PktPtrArray
index|[
literal|4
index|]
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|ds
operator|->
name|PktPtrArray
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|{ const uint8_t *cp = (const uint8_t *) ds;   int i;   for (i = 0; i< sizeof(struct mwl_txdesc); i++) { 	printf("%02x ", cp[i]); 	if (((i+1) % 16) == 0) 		printf("\n");   }   printf("\n"); }
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MWL_DEBUG */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifdef
unit|static void mwl_txq_dump(struct mwl_txq *txq) { 	struct mwl_txbuf *bf; 	int i = 0;  	MWL_TXQ_LOCK(txq); 	STAILQ_FOREACH(bf,&txq->active, bf_list) { 		struct mwl_txdesc *ds = bf->bf_desc; 		MWL_TXDESC_SYNC(txq, ds, 		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
ifdef|#
directive|ifdef
name|MWL_DEBUG
end_ifdef

begin_endif
unit|mwl_printtxbuf(bf, txq->qnum, i);
endif|#
directive|endif
end_endif

begin_endif
unit|i++; 	} 	MWL_TXQ_UNLOCK(txq); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|mwl_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
if|if
condition|(
name|mwl_hal_setkeepalive
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|)
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"transmit timeout (firmware hung?)\n"
argument_list|)
expr_stmt|;
else|else
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"transmit timeout\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|mwl_reset(ifp); mwl_txq_dump(&sc->sc_txq[0]);
comment|/*XXX*/
endif|#
directive|endif
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_watchdog
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MWL_DIAGAPI
end_ifdef

begin_comment
comment|/*  * Diagnostic interface to the HAL.  This is used by various  * tools to do things like retrieve register contents for  * debugging.  The mechanism is intentionally opaque so that  * it can change frequently w/o concern for compatiblity.  */
end_comment

begin_function
specifier|static
name|int
name|mwl_ioctl_diag
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mwl_diag
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
name|u_int
name|id
init|=
name|md
operator|->
name|md_id
operator|&
name|MWL_DIAG_ID
decl_stmt|;
name|void
modifier|*
name|indata
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|outdata
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|insize
init|=
name|md
operator|->
name|md_in_size
decl_stmt|;
name|u_int32_t
name|outsize
init|=
name|md
operator|->
name|md_out_size
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|md
operator|->
name|md_id
operator|&
name|MWL_DIAG_IN
condition|)
block|{
comment|/* 		 * Copy in data. 		 */
name|indata
operator|=
name|malloc
argument_list|(
name|insize
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|indata
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|copyin
argument_list|(
name|md
operator|->
name|md_in_data
argument_list|,
name|indata
argument_list|,
name|insize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|md
operator|->
name|md_id
operator|&
name|MWL_DIAG_DYN
condition|)
block|{
comment|/* 		 * Allocate a buffer for the results (otherwise the HAL 		 * returns a pointer to a buffer where we can read the 		 * results).  Note that we depend on the HAL leaving this 		 * pointer for us to use below in reclaiming the buffer; 		 * may want to be more defensive. 		 */
name|outdata
operator|=
name|malloc
argument_list|(
name|outsize
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|outdata
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|mwl_hal_getdiagstate
argument_list|(
name|mh
argument_list|,
name|id
argument_list|,
name|indata
argument_list|,
name|insize
argument_list|,
operator|&
name|outdata
argument_list|,
operator|&
name|outsize
argument_list|)
condition|)
block|{
if|if
condition|(
name|outsize
operator|<
name|md
operator|->
name|md_out_size
condition|)
name|md
operator|->
name|md_out_size
operator|=
name|outsize
expr_stmt|;
if|if
condition|(
name|outdata
operator|!=
name|NULL
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|outdata
argument_list|,
name|md
operator|->
name|md_out_data
argument_list|,
name|md
operator|->
name|md_out_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|bad
label|:
if|if
condition|(
operator|(
name|md
operator|->
name|md_id
operator|&
name|MWL_DIAG_IN
operator|)
operator|&&
name|indata
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|indata
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|->
name|md_id
operator|&
name|MWL_DIAG_DYN
operator|)
operator|&&
name|outdata
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|outdata
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_ioctl_reset
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mwl_diag
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|mwl_hal
modifier|*
name|mh
init|=
name|sc
operator|->
name|sc_mh
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MWL_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|md_id
operator|==
literal|0
operator|&&
name|mwl_hal_fwload
argument_list|(
name|mh
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to load firmware\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|mwl_hal_gethwspecs
argument_list|(
name|mh
argument_list|,
operator|&
name|sc
operator|->
name|sc_hwspecs
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to fetch h/w specs\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|error
operator|=
name|mwl_setupdma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* NB: mwl_setupdma prints a msg */
return|return
name|error
return|;
block|}
comment|/* 	 * Reset tx/rx data structures; after reload we must 	 * re-start the driver's notion of the next xmit/recv. 	 */
name|mwl_draintxq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* clear pending frames */
name|mwl_resettxq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* rebuild tx q lists */
name|sc
operator|->
name|sc_rxnext
operator|=
name|NULL
expr_stmt|;
comment|/* force rx to start at the list head */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MWL_DIAGAPI */
end_comment

begin_function
specifier|static
name|int
name|mwl_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
define|#
directive|define
name|IS_RUNNING
parameter_list|(
name|ifp
parameter_list|)
define|\
value|((ifp->if_flags& IFF_UP)&& (ifp->if_drv_flags& IFF_DRV_RUNNING))
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|startall
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|MWL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|startall
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_RUNNING
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
comment|/* 			 * To avoid rescanning another access point, 			 * do not call mwl_init() here.  Instead, 			 * only reflect promisc mode settings. 			 */
name|mwl_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 			 * Beware of being called during attach/detach 			 * to reset promiscuous mode.  In that case we 			 * will still be marked UP but not RUNNING. 			 * However trying to re-init the interface 			 * is the wrong thing to do as we've already 			 * torn down much of our state.  There's 			 * probably a better way to deal with this. 			 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
name|mwl_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX lose error */
name|startall
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|mwl_stop_locked
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MWL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|startall
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGMVSTATS
case|:
name|mwl_hal_gethwstats
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
operator|&
name|sc
operator|->
name|sc_stats
operator|.
name|hw_stats
argument_list|)
expr_stmt|;
comment|/* NB: embed these numbers to get a consistent view */
name|sc
operator|->
name|sc_stats
operator|.
name|mst_tx_packets
operator|=
name|ifp
operator|->
name|if_opackets
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|mst_rx_packets
operator|=
name|ifp
operator|->
name|if_ipackets
expr_stmt|;
comment|/* 		 * NB: Drop the softc lock in case of a page fault; 		 * we'll accept any potential inconsisentcy in the 		 * statistics.  The alternative is to copy the data 		 * to a local structure. 		 */
return|return
name|copyout
argument_list|(
operator|&
name|sc
operator|->
name|sc_stats
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_stats
argument_list|)
argument_list|)
return|;
ifdef|#
directive|ifdef
name|MWL_DIAGAPI
case|case
name|SIOCGMVDIAG
case|:
comment|/* XXX check privs */
return|return
name|mwl_ioctl_diag
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|mwl_diag
operator|*
operator|)
name|ifr
argument_list|)
return|;
case|case
name|SIOCGMVRESET
case|:
comment|/* XXX check privs */
name|MWL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mwl_ioctl_reset
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|mwl_diag
operator|*
operator|)
name|ifr
argument_list|)
expr_stmt|;
name|MWL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MWL_DIAGAPI */
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|ic
operator|->
name|ic_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFADDR
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
undef|#
directive|undef
name|IS_RUNNING
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MWL_DEBUG
end_ifdef

begin_function
specifier|static
name|int
name|mwl_sysctl_debug
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|mwl_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|debug
decl_stmt|,
name|error
decl_stmt|;
name|debug
operator|=
name|sc
operator|->
name|sc_debug
operator||
operator|(
name|mwl_hal_getdebug
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|)
operator|<<
literal|24
operator|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|debug
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
name|mwl_hal_setdebug
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|,
name|debug
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_debug
operator|=
name|debug
operator|&
literal|0x00ffffff
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MWL_DEBUG */
end_comment

begin_function
specifier|static
name|void
name|mwl_sysctlattach
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MWL_DEBUG
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_debug
operator|=
name|mwl_debug
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|mwl_sysctl_debug
argument_list|,
literal|"I"
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Announce various information on device/driver attach.  */
end_comment

begin_function
specifier|static
name|void
name|mwl_announce
parameter_list|(
name|struct
name|mwl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Rev A%d hardware, v%d.%d.%d.%d firmware (regioncode %d)\n"
argument_list|,
name|sc
operator|->
name|sc_hwspecs
operator|.
name|hwVersion
argument_list|,
operator|(
name|sc
operator|->
name|sc_hwspecs
operator|.
name|fwReleaseNumber
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|sc
operator|->
name|sc_hwspecs
operator|.
name|fwReleaseNumber
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|sc
operator|->
name|sc_hwspecs
operator|.
name|fwReleaseNumber
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|sc
operator|->
name|sc_hwspecs
operator|.
name|fwReleaseNumber
operator|>>
literal|0
operator|)
operator|&
literal|0xff
argument_list|,
name|sc
operator|->
name|sc_hwspecs
operator|.
name|regionCode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fwrelease
operator|=
name|sc
operator|->
name|sc_hwspecs
operator|.
name|fwReleaseNumber
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|WME_AC_VO
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mwl_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|i
index|]
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Use hw queue %u for %s traffic\n"
argument_list|,
name|txq
operator|->
name|qnum
argument_list|,
name|ieee80211_wme_acnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bootverbose
operator|||
name|mwl_rxdesc
operator|!=
name|MWL_RXDESC
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"using %u rx descriptors\n"
argument_list|,
name|mwl_rxdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|||
name|mwl_rxbuf
operator|!=
name|MWL_RXBUF
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"using %u rx buffers\n"
argument_list|,
name|mwl_rxbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|||
name|mwl_txbuf
operator|!=
name|MWL_TXBUF
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"using %u tx buffers\n"
argument_list|,
name|mwl_txbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|&&
name|mwl_hal_ismbsscapable
argument_list|(
name|sc
operator|->
name|sc_mh
argument_list|)
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"multi-bss support\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MWL_TX_NODROP
if|if
condition|(
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"no tx drop\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

