begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2007-2009 Marvell Semiconductor, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/mwl/mwlhal.h>
end_include

begin_include
include|#
directive|include
file|<dev/mwl/mwlreg.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<dev/mwl/mwldiag.h>
end_include

begin_define
define|#
directive|define
name|MWLHAL_DEBUG
end_define

begin_comment
comment|/* debug msgs */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|WL_ANTENNAMODE_RX
init|=
literal|0xffff
block|,
name|WL_ANTENNAMODE_TX
init|=
literal|2
block|, }
name|wlantennamode_e
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|WL_TX_POWERLEVEL_LOW
init|=
literal|5
block|,
name|WL_TX_POWERLEVEL_MEDIUM
init|=
literal|10
block|,
name|WL_TX_POWERLEVEL_HIGH
init|=
literal|15
block|, }
name|wltxpowerlevel_e
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MWL_CMDBUF_SIZE
value|0x4000
end_define

begin_comment
comment|/* size of f/w command buffer */
end_comment

begin_define
define|#
directive|define
name|MWL_BASTREAMS_MAX
value|7
end_define

begin_comment
comment|/* max BA streams (NB: fw>3.3.5.9) */
end_comment

begin_define
define|#
directive|define
name|MWL_BAQID_MAX
value|8
end_define

begin_comment
comment|/* max BA Q id's (NB: fw>3.3.5.9) */
end_comment

begin_define
define|#
directive|define
name|MWL_MBSS_AP_MAX
value|8
end_define

begin_comment
comment|/* max ap vap's */
end_comment

begin_define
define|#
directive|define
name|MWL_MBSS_STA_MAX
value|24
end_define

begin_comment
comment|/* max station/client vap's */
end_comment

begin_define
define|#
directive|define
name|MWL_MBSS_MAX
value|(MWL_MBSS_AP_MAX+MWL_MBSS_STA_MAX)
end_define

begin_comment
comment|/*  * BA stream -> queue ID mapping  *  * The first 2 streams map to h/w; the remaining streams are  * implemented in firmware.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|ba2qid
index|[
name|MWL_BASTREAMS_MAX
index|]
init|=
block|{
literal|5
block|,
literal|6
comment|/* h/w supported */
if|#
directive|if
name|MWL_BASTREAMS_MAX
operator|==
literal|7
block|,
literal|7
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
comment|/* f/w supported */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qid2ba
index|[
name|MWL_BAQID_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IEEE80211_ADDR_LEN
value|6
end_define

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|IEEE80211_ADDR_COPY
parameter_list|(
name|_dst
parameter_list|,
name|_src
parameter_list|)
define|\
value|memcpy(_dst, _src, IEEE80211_ADDR_LEN)
end_define

begin_define
define|#
directive|define
name|IEEE80211_ADDR_EQ
parameter_list|(
name|_dst
parameter_list|,
name|_src
parameter_list|)
define|\
value|(memcmp(_dst, _src, IEEE80211_ADDR_LEN) == 0)
end_define

begin_define
define|#
directive|define
name|_CMD_SETUP
parameter_list|(
name|pCmd
parameter_list|,
name|type
parameter_list|,
name|cmd
parameter_list|)
value|do {				\ 	pCmd = (type *)&mh->mh_cmdbuf[0];				\ 	memset(pCmd, 0, sizeof(type));					\ 	pCmd->CmdHdr.Cmd = htole16(cmd);				\ 	pCmd->CmdHdr.Length = htole16(sizeof(type));			\ } while (0)
end_define

begin_define
define|#
directive|define
name|_VCMD_SETUP
parameter_list|(
name|vap
parameter_list|,
name|pCmd
parameter_list|,
name|type
parameter_list|,
name|cmd
parameter_list|)
value|do {				\ 	_CMD_SETUP(pCmd, type, cmd);					\ 	pCmd->CmdHdr.MacId = vap->macid;				\ } while (0)
end_define

begin_define
define|#
directive|define
name|PWTAGETRATETABLE20M
value|14*4
end_define

begin_define
define|#
directive|define
name|PWTAGETRATETABLE40M
value|9*4
end_define

begin_define
define|#
directive|define
name|PWTAGETRATETABLE20M_5G
value|35*4
end_define

begin_define
define|#
directive|define
name|PWTAGETRATETABLE40M_5G
value|16*4
end_define

begin_struct
struct|struct
name|mwl_hal_bastream
block|{
name|MWL_HAL_BASTREAM
name|public
decl_stmt|;
comment|/* public state */
name|uint8_t
name|stream
decl_stmt|;
comment|/* stream # */
name|uint8_t
name|setup
decl_stmt|;
comment|/* f/w cmd sent */
name|uint8_t
name|ba_policy
decl_stmt|;
comment|/* direct/delayed BA policy */
name|uint8_t
name|tid
decl_stmt|;
name|uint8_t
name|paraminfo
decl_stmt|;
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|mwl_hal_priv
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|mwl_hal_vap
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
decl_stmt|;
comment|/* back pointer */
name|uint16_t
name|bss_type
decl_stmt|;
comment|/* f/w type */
name|uint8_t
name|vap_type
decl_stmt|;
comment|/* MWL_HAL_BSSTYPE */
name|uint8_t
name|macid
decl_stmt|;
comment|/* for passing to f/w */
name|uint8_t
name|flags
decl_stmt|;
define|#
directive|define
name|MVF_RUNNING
value|0x01
comment|/* BSS_START issued */
define|#
directive|define
name|MVF_STATION
value|0x02
comment|/* sta db entry created */
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
comment|/* mac address */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MWLVAP
parameter_list|(
name|_vap
parameter_list|)
value|((_vap)->mh)
end_define

begin_comment
comment|/*  * Per-device state.  We allocate a single cmd buffer for  * submitting operations to the firmware.  Access to this  * buffer (and the f/w) are single-threaded.  At present  * we spin waiting for cmds to complete which is bad.  Not  * sure if it's possible to submit multiple requests or  * control when we get cmd done interrupts.  There's no  * documentation and no example code to indicate what can  * or cannot be done so all we can do right now is follow the  * linux driver logic.  This falls apart when the f/w fails;  * the system comes to a crawl as we spin waiting for operations  * to finish.  */
end_comment

begin_struct
struct|struct
name|mwl_hal_priv
block|{
name|struct
name|mwl_hal
name|public
decl_stmt|;
comment|/* public area */
name|device_t
name|mh_dev
decl_stmt|;
name|char
name|mh_mtxname
index|[
literal|12
index|]
decl_stmt|;
name|struct
name|mtx
name|mh_mtx
decl_stmt|;
name|bus_dma_tag_t
name|mh_dmat
decl_stmt|;
comment|/* bus DMA tag for cmd buffer */
name|bus_dma_segment_t
name|mh_seg
decl_stmt|;
comment|/* segment for cmd buffer */
name|bus_dmamap_t
name|mh_dmamap
decl_stmt|;
comment|/* DMA map for cmd buffer */
name|uint16_t
modifier|*
name|mh_cmdbuf
decl_stmt|;
comment|/* f/w cmd buffer */
name|bus_addr_t
name|mh_cmdaddr
decl_stmt|;
comment|/* physaddr of cmd buffer */
name|int
name|mh_flags
decl_stmt|;
define|#
directive|define
name|MHF_CALDATA
value|0x0001
comment|/* cal data retrieved */
define|#
directive|define
name|MHF_FWHANG
value|0x0002
comment|/* fw appears hung */
define|#
directive|define
name|MHF_MBSS
value|0x0004
comment|/* mbss enabled */
name|struct
name|mwl_hal_vap
name|mh_vaps
index|[
name|MWL_MBSS_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|mh_bastreams
decl_stmt|;
comment|/* bit mask of available BA streams */
name|int
name|mh_regioncode
decl_stmt|;
comment|/* XXX last region code sent to fw */
name|struct
name|mwl_hal_bastream
name|mh_streams
index|[
name|MWL_BASTREAMS_MAX
index|]
decl_stmt|;
name|int
name|mh_debug
decl_stmt|;
name|MWL_HAL_CHANNELINFO
name|mh_20M
decl_stmt|;
name|MWL_HAL_CHANNELINFO
name|mh_40M
decl_stmt|;
name|MWL_HAL_CHANNELINFO
name|mh_20M_5G
decl_stmt|;
name|MWL_HAL_CHANNELINFO
name|mh_40M_5G
decl_stmt|;
name|int
name|mh_SDRAMSIZE_Addr
decl_stmt|;
name|uint32_t
name|mh_RTSSuccesses
decl_stmt|;
comment|/* cumulative stats for read-on-clear */
name|uint32_t
name|mh_RTSFailures
decl_stmt|;
name|uint32_t
name|mh_RxDuplicateFrames
decl_stmt|;
name|uint32_t
name|mh_FCSErrorCount
decl_stmt|;
name|MWL_DIAG_REVS
name|mh_revs
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MWLPRIV
parameter_list|(
name|_mh
parameter_list|)
value|((struct mwl_hal_priv *)(_mh))
end_define

begin_function_decl
specifier|static
name|int
name|mwl_hal_setmac_locked
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
name|addr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwlExecuteCmd
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
parameter_list|,
name|unsigned
name|short
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mwlGetPwrCalTable
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MWLHAL_DEBUG
end_ifdef

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|mwlcmdname
parameter_list|(
name|int
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dumpresult
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
parameter_list|,
name|int
name|showresult
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MWLHAL_DEBUG */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_mwl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw_mwl
argument_list|,
name|OID_AUTO
argument_list|,
name|hal
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Marvell HAL parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|__inline
name|void
name|MWL_HAL_LOCK
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|mh
operator|->
name|mh_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|MWL_HAL_LOCK_ASSERT
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|mh
operator|->
name|mh_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|MWL_HAL_UNLOCK
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|mh
operator|->
name|mh_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|RD4
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
return|return
name|bus_space_read_4
argument_list|(
name|mh
operator|->
name|public
operator|.
name|mh_iot
argument_list|,
name|mh
operator|->
name|public
operator|.
name|mh_ioh
argument_list|,
name|off
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|WR4
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_space_write_4
argument_list|(
name|mh
operator|->
name|public
operator|.
name|mh_iot
argument_list|,
name|mh
operator|->
name|public
operator|.
name|mh_ioh
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwl_hal_load_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"error %u on bus_dma callback"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup for communication with the device.  We allocate  * a command buffer and map it for bus dma use.  The pci  * device id is used to identify whether the device has  * SRAM on it (in which case f/w download must include a  * memory controller reset).  All bus i/o operations happen  * in BAR 1; the driver passes in the tag and handle we need.  */
end_comment

begin_function
name|struct
name|mwl_hal
modifier|*
name|mwl_hal_attach
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint16_t
name|devid
parameter_list|,
name|bus_space_handle_t
name|ioh
parameter_list|,
name|bus_space_tag_t
name|iot
parameter_list|,
name|bus_dma_tag_t
name|tag
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
decl_stmt|;
name|struct
name|mwl_hal_vap
modifier|*
name|hvap
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|mh
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mwl_hal_priv
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|mh
operator|->
name|mh_dev
operator|=
name|dev
expr_stmt|;
name|mh
operator|->
name|public
operator|.
name|mh_ioh
operator|=
name|ioh
expr_stmt|;
name|mh
operator|->
name|public
operator|.
name|mh_iot
operator|=
name|iot
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MWL_BASTREAMS_MAX
condition|;
name|i
operator|++
control|)
block|{
name|mh
operator|->
name|mh_streams
index|[
name|i
index|]
operator|.
name|public
operator|.
name|txq
operator|=
name|ba2qid
index|[
name|i
index|]
expr_stmt|;
name|mh
operator|->
name|mh_streams
index|[
name|i
index|]
operator|.
name|stream
operator|=
name|i
expr_stmt|;
comment|/* construct back-mapping while we're at it */
if|if
condition|(
name|mh
operator|->
name|mh_streams
index|[
name|i
index|]
operator|.
name|public
operator|.
name|txq
operator|<
name|MWL_BAQID_MAX
condition|)
name|qid2ba
index|[
name|mh
operator|->
name|mh_streams
index|[
name|i
index|]
operator|.
name|public
operator|.
name|txq
index|]
operator|=
name|i
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unexpected BA tx qid %d for "
literal|"stream %d\n"
argument_list|,
name|mh
operator|->
name|mh_streams
index|[
name|i
index|]
operator|.
name|public
operator|.
name|txq
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* setup constant portion of vap state */
comment|/* XXX should get max ap/client vap's from f/w */
name|i
operator|=
literal|0
expr_stmt|;
name|hvap
operator|=
operator|&
name|mh
operator|->
name|mh_vaps
index|[
name|i
index|]
expr_stmt|;
name|hvap
operator|->
name|vap_type
operator|=
name|MWL_HAL_AP
expr_stmt|;
name|hvap
operator|->
name|bss_type
operator|=
name|htole16
argument_list|(
name|WL_MAC_TYPE_PRIMARY_AP
argument_list|)
expr_stmt|;
name|hvap
operator|->
name|macid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|MWL_MBSS_AP_MAX
condition|;
name|i
operator|++
control|)
block|{
name|hvap
operator|=
operator|&
name|mh
operator|->
name|mh_vaps
index|[
name|i
index|]
expr_stmt|;
name|hvap
operator|->
name|vap_type
operator|=
name|MWL_HAL_AP
expr_stmt|;
name|hvap
operator|->
name|bss_type
operator|=
name|htole16
argument_list|(
name|WL_MAC_TYPE_SECONDARY_AP
argument_list|)
expr_stmt|;
name|hvap
operator|->
name|macid
operator|=
name|i
expr_stmt|;
block|}
name|hvap
operator|=
operator|&
name|mh
operator|->
name|mh_vaps
index|[
name|i
index|]
expr_stmt|;
name|hvap
operator|->
name|vap_type
operator|=
name|MWL_HAL_STA
expr_stmt|;
name|hvap
operator|->
name|bss_type
operator|=
name|htole16
argument_list|(
name|WL_MAC_TYPE_PRIMARY_CLIENT
argument_list|)
expr_stmt|;
name|hvap
operator|->
name|macid
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|MWL_MBSS_MAX
condition|;
name|i
operator|++
control|)
block|{
name|hvap
operator|=
operator|&
name|mh
operator|->
name|mh_vaps
index|[
name|i
index|]
expr_stmt|;
name|hvap
operator|->
name|vap_type
operator|=
name|MWL_HAL_STA
expr_stmt|;
name|hvap
operator|->
name|bss_type
operator|=
name|htole16
argument_list|(
name|WL_MAC_TYPE_SECONDARY_CLIENT
argument_list|)
expr_stmt|;
name|hvap
operator|->
name|macid
operator|=
name|i
expr_stmt|;
block|}
name|mh
operator|->
name|mh_revs
operator|.
name|mh_devid
operator|=
name|devid
expr_stmt|;
name|snprintf
argument_list|(
name|mh
operator|->
name|mh_mtxname
argument_list|,
sizeof|sizeof
argument_list|(
name|mh
operator|->
name|mh_mtxname
argument_list|)
argument_list|,
literal|"%s_hal"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|mh
operator|->
name|mh_mtx
argument_list|,
name|mh
operator|->
name|mh_mtxname
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate the command buffer and map into the address 	 * space of the h/w.  We request "coherent" memory which 	 * will be uncached on some architectures. 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|tag
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MWL_CMDBUF_SIZE
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MWL_CMDBUF_SIZE
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|mh
operator|->
name|mh_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate memory for cmd tag, "
literal|"error %u\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail0
goto|;
block|}
comment|/* allocate descriptors */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mh
operator|->
name|mh_cmdbuf
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|mh
operator|->
name|mh_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate memory for cmd buffer, "
literal|"error %u\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|,
name|mh
operator|->
name|mh_cmdbuf
argument_list|,
name|MWL_CMDBUF_SIZE
argument_list|,
name|mwl_hal_load_cb
argument_list|,
operator|&
name|mh
operator|->
name|mh_cmdaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to load cmd buffer, error %u\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
comment|/* 	 * Some cards have SDRAM.  When loading firmware we need 	 * to reset the SDRAM controller prior to doing this. 	 * When the SDRAMSIZE is non-zero we do that work in 	 * mwl_hal_fwload. 	 */
switch|switch
condition|(
name|devid
condition|)
block|{
case|case
literal|0x2a02
case|:
comment|/* CB82 */
case|case
literal|0x2a03
case|:
comment|/* CB85 */
case|case
literal|0x2a08
case|:
comment|/* MC85_B1 */
case|case
literal|0x2a0b
case|:
comment|/* CB85AP */
case|case
literal|0x2a24
case|:
name|mh
operator|->
name|mh_SDRAMSIZE_Addr
operator|=
literal|0x40fe70b7
expr_stmt|;
comment|/* 8M SDRAM */
break|break;
case|case
literal|0x2a04
case|:
comment|/* MC85 */
name|mh
operator|->
name|mh_SDRAMSIZE_Addr
operator|=
literal|0x40fc70b7
expr_stmt|;
comment|/* 16M SDRAM */
break|break;
default|default:
break|break;
block|}
return|return
operator|&
name|mh
operator|->
name|public
return|;
name|fail2
label|:
name|bus_dmamem_free
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_cmdbuf
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|)
expr_stmt|;
name|fail1
label|:
name|bus_dma_tag_destroy
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|)
expr_stmt|;
name|fail0
label|:
name|mtx_destroy
argument_list|(
operator|&
name|mh
operator|->
name|mh_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mh
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|mwl_hal_detach
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|bus_dmamem_free
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_cmdbuf
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|mh
operator|->
name|mh_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mh
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset internal state after a firmware download.  */
end_comment

begin_function
specifier|static
name|int
name|mwlResetHalState
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* XXX get from f/w */
name|mh
operator|->
name|mh_bastreams
operator|=
operator|(
literal|1
operator|<<
name|MWL_BASTREAMS_MAX
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MWL_MBSS_MAX
condition|;
name|i
operator|++
control|)
name|mh
operator|->
name|mh_vaps
index|[
name|i
index|]
operator|.
name|mh
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Clear cumulative stats. 	 */
name|mh
operator|->
name|mh_RTSSuccesses
operator|=
literal|0
expr_stmt|;
name|mh
operator|->
name|mh_RTSFailures
operator|=
literal|0
expr_stmt|;
name|mh
operator|->
name|mh_RxDuplicateFrames
operator|=
literal|0
expr_stmt|;
name|mh
operator|->
name|mh_FCSErrorCount
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Fetch cal data for later use. 	 * XXX may want to fetch other stuff too. 	 */
comment|/* XXX check return */
if|if
condition|(
operator|(
name|mh
operator|->
name|mh_flags
operator|&
name|MHF_CALDATA
operator|)
operator|==
literal|0
condition|)
name|mwlGetPwrCalTable
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|mwl_hal_vap
modifier|*
name|mwl_hal_newvap
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|MWL_HAL_BSSTYPE
name|type
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|struct
name|mwl_hal_vap
modifier|*
name|vap
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
comment|/* NB: could optimize but not worth it w/ max 32 bss */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MWL_MBSS_MAX
condition|;
name|i
operator|++
control|)
block|{
name|vap
operator|=
operator|&
name|mh
operator|->
name|mh_vaps
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|vap_type
operator|==
name|type
operator|&&
name|vap
operator|->
name|mh
operator|==
name|NULL
condition|)
block|{
name|vap
operator|->
name|mh
operator|=
name|mh
expr_stmt|;
name|mwl_hal_setmac_locked
argument_list|(
name|vap
argument_list|,
name|mac
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|<
name|MWL_MBSS_MAX
operator|)
condition|?
name|vap
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|mwl_hal_delvap
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|)
block|{
comment|/* NB: locking not needed for single write */
name|vap
operator|->
name|mh
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Manipulate the debug mask.  Note debug  * msgs are only provided when this code is  * compiled with MWLHAL_DEBUG defined.  */
end_comment

begin_function
name|void
name|mwl_hal_setdebug
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh
parameter_list|,
name|int
name|debug
parameter_list|)
block|{
name|MWLPRIV
argument_list|(
name|mh
argument_list|)
operator|->
name|mh_debug
operator|=
name|debug
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mwl_hal_getdebug
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh
parameter_list|)
block|{
return|return
name|MWLPRIV
argument_list|(
name|mh
argument_list|)
operator|->
name|mh_debug
return|;
block|}
end_function

begin_function
name|void
name|mwl_hal_setbastreams
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|MWLPRIV
argument_list|(
name|mh
argument_list|)
operator|->
name|mh_bastreams
operator|=
name|mask
operator|&
operator|(
operator|(
literal|1
operator|<<
name|MWL_BASTREAMS_MAX
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mwl_hal_getbastreams
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh
parameter_list|)
block|{
return|return
name|MWLPRIV
argument_list|(
name|mh
argument_list|)
operator|->
name|mh_bastreams
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_ismbsscapable
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh
parameter_list|)
block|{
return|return
operator|(
name|MWLPRIV
argument_list|(
name|mh
argument_list|)
operator|->
name|mh_flags
operator|&
name|MHF_MBSS
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX inlined */
end_comment

begin_comment
comment|/*  * Return the current ISR setting and clear the cause.  * XXX maybe make inline  */
end_comment

begin_comment
unit|void mwl_hal_getisr(struct mwl_hal *mh0, uint32_t *status) { 	struct mwl_hal_priv *mh = MWLPRIV(mh0); 	uint32_t cause;  	cause = RD4(mh, MACREG_REG_A2H_INTERRUPT_CAUSE); 	if (cause == 0xffffffff) {
comment|/* card removed */
end_comment

begin_comment
unit|device_printf(mh->mh_dev, "%s: cause 0x%x\n", __func__, cause); 		cause = 0; 	} else if (cause != 0) {
comment|/* clear cause bits */
end_comment

begin_comment
unit|WR4(mh, MACREG_REG_A2H_INTERRUPT_CAUSE, 		    cause&~ mh->public.mh_imask); 		RD4(mh, MACREG_REG_INT_CODE);
comment|/* XXX flush write? */
end_comment

begin_endif
unit|} 	*status = cause; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Set the interrupt mask.  */
end_comment

begin_function
name|void
name|mwl_hal_intrset
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_A2H_INTERRUPT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|)
expr_stmt|;
name|mh
operator|->
name|public
operator|.
name|mh_imask
operator|=
name|mask
expr_stmt|;
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_A2H_INTERRUPT_MASK
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX inlined */
end_comment

begin_comment
comment|/*  * Kick the firmware to tell it there are new tx descriptors  * for processing.  The driver says what h/w q has work in  * case the f/w ever gets smarter.  */
end_comment

begin_endif
unit|void mwl_hal_txstart(struct mwl_hal *mh0, int qnum) { 	struct mwl_hal_priv *mh = MWLPRIV(mh0); 	uint32_t dummy;  	WR4(mh, MACREG_REG_H2A_INTERRUPT_EVENTS, MACREG_H2ARIC_BIT_PPA_READY); 	dummy = RD4(mh, MACREG_REG_INT_CODE); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Callback from the driver on a cmd done interrupt.  * Nothing to do right now as we spin waiting for  * cmd completion.  */
end_comment

begin_function
name|void
name|mwl_hal_cmddone
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct mwl_hal_priv *mh = MWLPRIV(mh0);  	if (mh->mh_debug& MWL_HAL_DEBUG_CMDDONE) { 		device_printf(mh->mh_dev, "cmd done interrupt:\n"); 		dumpresult(mh, 1); 	}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Return "hw specs".  Note this must be the first  * cmd MUST be done after a firmware download or the  * f/w will lockup.  * XXX move into the hal so driver doesn't need to be responsible  */
end_comment

begin_function
name|int
name|mwl_hal_gethwspecs
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|struct
name|mwl_hal_hwspec
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_DS_GET_HW_SPEC
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|minrev
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_DS_GET_HW_SPEC
argument_list|,
name|HostCmd_CMD_GET_HW_SPEC
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pCmd
operator|->
name|PermanentAddr
index|[
literal|0
index|]
argument_list|,
literal|0xff
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|ulFwAwakeCookie
operator|=
name|htole32
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|mh
operator|->
name|mh_cmdaddr
operator|+
literal|2048
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_GET_HW_SPEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|IEEE80211_ADDR_COPY
argument_list|(
name|hw
operator|->
name|macAddr
argument_list|,
name|pCmd
operator|->
name|PermanentAddr
argument_list|)
expr_stmt|;
name|hw
operator|->
name|wcbBase
index|[
literal|0
index|]
operator|=
name|le32toh
argument_list|(
name|pCmd
operator|->
name|WcbBase0
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|hw
operator|->
name|wcbBase
index|[
literal|1
index|]
operator|=
name|le32toh
argument_list|(
name|pCmd
operator|->
name|WcbBase1
index|[
literal|0
index|]
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|hw
operator|->
name|wcbBase
index|[
literal|2
index|]
operator|=
name|le32toh
argument_list|(
name|pCmd
operator|->
name|WcbBase1
index|[
literal|1
index|]
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|hw
operator|->
name|wcbBase
index|[
literal|3
index|]
operator|=
name|le32toh
argument_list|(
name|pCmd
operator|->
name|WcbBase1
index|[
literal|2
index|]
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|hw
operator|->
name|rxDescRead
operator|=
name|le32toh
argument_list|(
name|pCmd
operator|->
name|RxPdRdPtr
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|hw
operator|->
name|rxDescWrite
operator|=
name|le32toh
argument_list|(
name|pCmd
operator|->
name|RxPdWrPtr
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|hw
operator|->
name|regionCode
operator|=
name|le16toh
argument_list|(
name|pCmd
operator|->
name|RegionCode
argument_list|)
operator|&
literal|0x00ff
expr_stmt|;
name|hw
operator|->
name|fwReleaseNumber
operator|=
name|le32toh
argument_list|(
name|pCmd
operator|->
name|FWReleaseNumber
argument_list|)
expr_stmt|;
name|hw
operator|->
name|maxNumWCB
operator|=
name|le16toh
argument_list|(
name|pCmd
operator|->
name|NumOfWCB
argument_list|)
expr_stmt|;
name|hw
operator|->
name|maxNumMCAddr
operator|=
name|le16toh
argument_list|(
name|pCmd
operator|->
name|NumOfMCastAddr
argument_list|)
expr_stmt|;
name|hw
operator|->
name|numAntennas
operator|=
name|le16toh
argument_list|(
name|pCmd
operator|->
name|NumberOfAntenna
argument_list|)
expr_stmt|;
name|hw
operator|->
name|hwVersion
operator|=
name|pCmd
operator|->
name|Version
expr_stmt|;
name|hw
operator|->
name|hostInterface
operator|=
name|pCmd
operator|->
name|HostIf
expr_stmt|;
name|mh
operator|->
name|mh_revs
operator|.
name|mh_macRev
operator|=
name|hw
operator|->
name|hwVersion
expr_stmt|;
comment|/* XXX */
name|mh
operator|->
name|mh_revs
operator|.
name|mh_phyRev
operator|=
name|hw
operator|->
name|hostInterface
expr_stmt|;
comment|/* XXX */
name|minrev
operator|=
operator|(
operator|(
name|hw
operator|->
name|fwReleaseNumber
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|minrev
operator|>=
literal|4
condition|)
block|{
comment|/* starting with 3.4.x.x s/w BA streams supported */
name|mh
operator|->
name|mh_bastreams
operator|&=
operator|(
literal|1
operator|<<
name|MWL_BASTREAMS_MAX
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|mh
operator|->
name|mh_bastreams
operator|&=
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Inform the f/w about location of the tx/rx dma data structures  * and related state.  This cmd must be done immediately after a  * mwl_hal_gethwspecs call or the f/w will lockup.  */
end_comment

begin_function
name|int
name|mwl_hal_sethwdma
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
specifier|const
name|struct
name|mwl_hal_txrxdma
modifier|*
name|dma
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_DS_SET_HW_SPEC
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_DS_SET_HW_SPEC
argument_list|,
name|HostCmd_CMD_SET_HW_SPEC
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|WcbBase
index|[
literal|0
index|]
operator|=
name|htole32
argument_list|(
name|dma
operator|->
name|wcbBase
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|WcbBase
index|[
literal|1
index|]
operator|=
name|htole32
argument_list|(
name|dma
operator|->
name|wcbBase
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|WcbBase
index|[
literal|2
index|]
operator|=
name|htole32
argument_list|(
name|dma
operator|->
name|wcbBase
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|WcbBase
index|[
literal|3
index|]
operator|=
name|htole32
argument_list|(
name|dma
operator|->
name|wcbBase
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|TxWcbNumPerQueue
operator|=
name|htole32
argument_list|(
name|dma
operator|->
name|maxNumTxWcb
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|NumTxQueues
operator|=
name|htole32
argument_list|(
name|dma
operator|->
name|maxNumWCB
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|TotalRxWcb
operator|=
name|htole32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX */
name|pCmd
operator|->
name|RxPdWrPtr
operator|=
name|htole32
argument_list|(
name|dma
operator|->
name|rxDescRead
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Flags
operator|=
name|htole32
argument_list|(
name|SET_HW_SPEC_HOSTFORM_BEACON
ifdef|#
directive|ifdef
name|MWL_HOST_PS_SUPPORT
operator||
name|SET_HW_SPEC_HOST_POWERSAVE
endif|#
directive|endif
operator||
name|SET_HW_SPEC_HOSTFORM_PROBERESP
argument_list|)
expr_stmt|;
comment|/* disable multi-bss operation for A1-A4 parts */
if|if
condition|(
name|mh
operator|->
name|mh_revs
operator|.
name|mh_macRev
operator|<
literal|5
condition|)
name|pCmd
operator|->
name|Flags
operator||=
name|htole32
argument_list|(
name|SET_HW_SPEC_DISABLEMBSS
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_HW_SPEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pCmd
operator|->
name|Flags
operator|&
name|htole32
argument_list|(
name|SET_HW_SPEC_DISABLEMBSS
argument_list|)
condition|)
name|mh
operator|->
name|mh_flags
operator|&=
operator|~
name|MHF_MBSS
expr_stmt|;
else|else
name|mh
operator|->
name|mh_flags
operator||=
name|MHF_MBSS
expr_stmt|;
block|}
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve statistics from the f/w.  * XXX should be in memory shared w/ driver  */
end_comment

begin_function
name|int
name|mwl_hal_gethwstats
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|struct
name|mwl_hal_hwstats
modifier|*
name|stats
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_DS_802_11_GET_STAT
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_DS_802_11_GET_STAT
argument_list|,
name|HostCmd_CMD_802_11_GET_STAT
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_802_11_GET_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
specifier|const
name|uint32_t
modifier|*
name|sp
init|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|&
name|pCmd
operator|->
name|TxRetrySuccesses
decl_stmt|;
name|uint32_t
modifier|*
name|dp
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|stats
operator|->
name|TxRetrySuccesses
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|;
name|i
operator|++
control|)
name|dp
index|[
name|i
index|]
operator|=
name|le32toh
argument_list|(
name|sp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * Update stats not returned by f/w but available 		 * through public registers.  Note these registers 		 * are "clear on read" so we maintain cumulative data. 		 * XXX register defines 		 */
name|mh
operator|->
name|mh_RTSSuccesses
operator|+=
name|RD4
argument_list|(
name|mh
argument_list|,
literal|0xa834
argument_list|)
expr_stmt|;
name|mh
operator|->
name|mh_RTSFailures
operator|+=
name|RD4
argument_list|(
name|mh
argument_list|,
literal|0xa830
argument_list|)
expr_stmt|;
name|mh
operator|->
name|mh_RxDuplicateFrames
operator|+=
name|RD4
argument_list|(
name|mh
argument_list|,
literal|0xa84c
argument_list|)
expr_stmt|;
name|mh
operator|->
name|mh_FCSErrorCount
operator|+=
name|RD4
argument_list|(
name|mh
argument_list|,
literal|0xa840
argument_list|)
expr_stmt|;
block|}
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|stats
operator|->
name|RTSSuccesses
operator|=
name|mh
operator|->
name|mh_RTSSuccesses
expr_stmt|;
name|stats
operator|->
name|RTSFailures
operator|=
name|mh
operator|->
name|mh_RTSFailures
expr_stmt|;
name|stats
operator|->
name|RxDuplicateFrames
operator|=
name|mh
operator|->
name|mh_RxDuplicateFrames
expr_stmt|;
name|stats
operator|->
name|FCSErrorCount
operator|=
name|mh
operator|->
name|mh_FCSErrorCount
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Set HT guard interval handling.  * Takes effect immediately.  */
end_comment

begin_function
name|int
name|mwl_hal_sethtgi
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
name|int
name|GIType
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_FW_HT_GUARD_INTERVAL
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_FW_HT_GUARD_INTERVAL
argument_list|,
name|HostCmd_CMD_HT_GUARD_INTERVAL
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole32
argument_list|(
name|HostCmd_ACT_GEN_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|GIType
operator|==
literal|0
condition|)
block|{
name|pCmd
operator|->
name|GIType
operator|=
name|htole32
argument_list|(
name|GI_TYPE_LONG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GIType
operator|==
literal|1
condition|)
block|{
name|pCmd
operator|->
name|GIType
operator|=
name|htole32
argument_list|(
name|GI_TYPE_LONG
operator||
name|GI_TYPE_SHORT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pCmd
operator|->
name|GIType
operator|=
name|htole32
argument_list|(
name|GI_TYPE_LONG
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_HT_GUARD_INTERVAL
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Configure radio.  * Takes effect immediately.  * XXX preamble installed after set fixed rate cmd  */
end_comment

begin_function
name|int
name|mwl_hal_setradio
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
name|onoff
parameter_list|,
name|MWL_HAL_PREAMBLE
name|preamble
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_DS_802_11_RADIO_CONTROL
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_DS_802_11_RADIO_CONTROL
argument_list|,
name|HostCmd_CMD_802_11_RADIO_CONTROL
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
name|HostCmd_ACT_GEN_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
operator|==
literal|0
condition|)
name|pCmd
operator|->
name|Control
operator|=
literal|0
expr_stmt|;
else|else
name|pCmd
operator|->
name|Control
operator|=
name|htole16
argument_list|(
name|preamble
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|RadioOn
operator|=
name|htole16
argument_list|(
name|onoff
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_802_11_RADIO_CONTROL
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Configure antenna use.  * Takes effect immediately.  * XXX tx antenna setting ignored  * XXX rx antenna setting should always be 3 (for now)  */
end_comment

begin_function
name|int
name|mwl_hal_setantenna
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|MWL_HAL_ANTENNA
name|dirSet
parameter_list|,
name|int
name|ant
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_DS_802_11_RF_ANTENNA
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dirSet
operator|==
name|WL_ANTENNATYPE_RX
operator|||
name|dirSet
operator|==
name|WL_ANTENNATYPE_TX
operator|)
condition|)
return|return
name|EINVAL
return|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_DS_802_11_RF_ANTENNA
argument_list|,
name|HostCmd_CMD_802_11_RF_ANTENNA
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
name|dirSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|ant
operator|==
literal|0
condition|)
comment|/* default to all/both antennae */
name|ant
operator|=
literal|3
expr_stmt|;
name|pCmd
operator|->
name|AntennaMode
operator|=
name|htole16
argument_list|(
name|ant
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_802_11_RF_ANTENNA
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Set packet size threshold for implicit use of RTS.  * Takes effect immediately.  * XXX packet length> threshold =>'s RTS  */
end_comment

begin_function
name|int
name|mwl_hal_setrtsthreshold
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
name|int
name|threshold
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_DS_802_11_RTS_THSD
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_DS_802_11_RTS_THSD
argument_list|,
name|HostCmd_CMD_802_11_RTS_THSD
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
name|HostCmd_ACT_GEN_SET
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Threshold
operator|=
name|htole16
argument_list|(
name|threshold
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_802_11_RTS_THSD
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Enable sta-mode operation (disables beacon frame xmit).  */
end_comment

begin_function
name|int
name|mwl_hal_setinframode
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_INFRA_MODE
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_FW_SET_INFRA_MODE
argument_list|,
name|HostCmd_CMD_SET_INFRA_MODE
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_INFRA_MODE
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Configure radar detection in support of 802.11h.  */
end_comment

begin_function
name|int
name|mwl_hal_setradardetection
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|MWL_HAL_RADAR
name|action
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_802_11h_Detect_Radar
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_802_11h_Detect_Radar
argument_list|,
name|HostCmd_CMD_802_11H_DETECT_RADAR
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|CmdHdr
operator|.
name|Length
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
name|HostCmd_802_11h_Detect_Radar
argument_list|)
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|->
name|mh_regioncode
operator|==
name|DOMAIN_CODE_ETSI_131
condition|)
name|pCmd
operator|->
name|RadarTypeCode
operator|=
name|htole16
argument_list|(
literal|131
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_802_11H_DETECT_RADAR
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Convert public channel flags definition to a  * value suitable for feeding to the firmware.  * Note this includes byte swapping.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|cvtChannelFlags
parameter_list|(
specifier|const
name|MWL_HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
name|uint32_t
name|w
decl_stmt|;
comment|/* 	 * NB: f/w only understands FREQ_BAND_5GHZ, supplying the more 	 *     precise band info causes it to lockup (sometimes). 	 */
name|w
operator|=
operator|(
name|chan
operator|->
name|channelFlags
operator|.
name|FreqBand
operator|==
name|MWL_FREQ_BAND_2DOT4GHZ
operator|)
condition|?
name|FREQ_BAND_2DOT4GHZ
else|:
name|FREQ_BAND_5GHZ
expr_stmt|;
switch|switch
condition|(
name|chan
operator|->
name|channelFlags
operator|.
name|ChnlWidth
condition|)
block|{
case|case
name|MWL_CH_10_MHz_WIDTH
case|:
name|w
operator||=
name|CH_10_MHz_WIDTH
expr_stmt|;
break|break;
case|case
name|MWL_CH_20_MHz_WIDTH
case|:
name|w
operator||=
name|CH_20_MHz_WIDTH
expr_stmt|;
break|break;
case|case
name|MWL_CH_40_MHz_WIDTH
case|:
default|default:
name|w
operator||=
name|CH_40_MHz_WIDTH
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|chan
operator|->
name|channelFlags
operator|.
name|ExtChnlOffset
condition|)
block|{
case|case
name|MWL_EXT_CH_NONE
case|:
name|w
operator||=
name|EXT_CH_NONE
expr_stmt|;
break|break;
case|case
name|MWL_EXT_CH_ABOVE_CTRL_CH
case|:
name|w
operator||=
name|EXT_CH_ABOVE_CTRL_CH
expr_stmt|;
break|break;
case|case
name|MWL_EXT_CH_BELOW_CTRL_CH
case|:
name|w
operator||=
name|EXT_CH_BELOW_CTRL_CH
expr_stmt|;
break|break;
block|}
return|return
name|htole32
argument_list|(
name|w
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start a channel switch announcement countdown.  The IE  * in the beacon frame is allowed to go out and the firmware  * counts down and notifies the host when it's time to switch  * channels.  */
end_comment

begin_function
name|int
name|mwl_hal_setchannelswitchie
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
specifier|const
name|MWL_HAL_CHANNEL
modifier|*
name|nextchan
parameter_list|,
name|uint32_t
name|mode
parameter_list|,
name|uint32_t
name|count
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_SET_SWITCH_CHANNEL
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_SET_SWITCH_CHANNEL
argument_list|,
name|HostCmd_CMD_SET_SWITCH_CHANNEL
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Next11hChannel
operator|=
name|htole32
argument_list|(
name|nextchan
operator|->
name|channel
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Mode
operator|=
name|htole32
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|InitialCount
operator|=
name|htole32
argument_list|(
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|ChannelFlags
operator|=
name|cvtChannelFlags
argument_list|(
name|nextchan
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_SWITCH_CHANNEL
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Set the region code that selects the radar bin'ing agorithm.  */
end_comment

begin_function
name|int
name|mwl_hal_setregioncode
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
name|regionCode
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_SET_REGIONCODE_INFO
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_SET_REGIONCODE_INFO
argument_list|,
name|HostCmd_CMD_SET_REGION_CODE
argument_list|)
expr_stmt|;
comment|/* XXX map pseudo-codes to fw codes */
switch|switch
condition|(
name|regionCode
condition|)
block|{
case|case
name|DOMAIN_CODE_ETSI_131
case|:
name|pCmd
operator|->
name|regionCode
operator|=
name|htole16
argument_list|(
name|DOMAIN_CODE_ETSI
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pCmd
operator|->
name|regionCode
operator|=
name|htole16
argument_list|(
name|regionCode
argument_list|)
expr_stmt|;
break|break;
block|}
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_REGION_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|mh
operator|->
name|mh_regioncode
operator|=
name|regionCode
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RATEVAL
parameter_list|(
name|r
parameter_list|)
value|((r)&~ RATE_MCS)
end_define

begin_define
define|#
directive|define
name|RATETYPE
parameter_list|(
name|r
parameter_list|)
value|(((r)& RATE_MCS) ? HT_RATE_TYPE : LEGACY_RATE_TYPE)
end_define

begin_function
name|int
name|mwl_hal_settxrate
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
name|MWL_HAL_TXRATE_HANDLING
name|handling
parameter_list|,
specifier|const
name|MWL_HAL_TXRATE
modifier|*
name|rate
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_FW_USE_FIXED_RATE
modifier|*
name|pCmd
decl_stmt|;
name|FIXED_RATE_ENTRY
modifier|*
name|fp
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_FW_USE_FIXED_RATE
argument_list|,
name|HostCmd_CMD_SET_FIXED_RATE
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|MulticastRate
operator|=
name|RATEVAL
argument_list|(
name|rate
operator|->
name|McastRate
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|MultiRateTxType
operator|=
name|RATETYPE
argument_list|(
name|rate
operator|->
name|McastRate
argument_list|)
expr_stmt|;
comment|/* NB: no rate type field */
name|pCmd
operator|->
name|ManagementRate
operator|=
name|RATEVAL
argument_list|(
name|rate
operator|->
name|MgtRate
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pCmd
operator|->
name|FixedRateTable
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pCmd
operator|->
name|FixedRateTable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handling
operator|==
name|RATE_FIXED
condition|)
block|{
name|pCmd
operator|->
name|Action
operator|=
name|htole32
argument_list|(
name|HostCmd_ACT_GEN_SET
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|AllowRateDrop
operator|=
name|htole32
argument_list|(
name|FIXED_RATE_WITHOUT_AUTORATE_DROP
argument_list|)
expr_stmt|;
name|fp
operator|=
name|pCmd
operator|->
name|FixedRateTable
expr_stmt|;
name|fp
operator|->
name|FixedRate
operator|=
name|htole32
argument_list|(
name|RATEVAL
argument_list|(
name|rate
operator|->
name|RateSeries
index|[
literal|0
index|]
operator|.
name|Rate
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|FixRateTypeFlags
operator|.
name|FixRateType
operator|=
name|htole32
argument_list|(
name|RATETYPE
argument_list|(
name|rate
operator|->
name|RateSeries
index|[
literal|0
index|]
operator|.
name|Rate
argument_list|)
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|EntryCount
operator|=
name|htole32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|handling
operator|==
name|RATE_FIXED_DROP
condition|)
block|{
name|pCmd
operator|->
name|Action
operator|=
name|htole32
argument_list|(
name|HostCmd_ACT_GEN_SET
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|AllowRateDrop
operator|=
name|htole32
argument_list|(
name|FIXED_RATE_WITH_AUTO_RATE_DROP
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|pCmd
operator|->
name|FixedRateTable
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rate
operator|->
name|RateSeries
index|[
literal|0
index|]
operator|.
name|TryCount
operator|==
literal|0
condition|)
break|break;
name|fp
operator|->
name|FixRateTypeFlags
operator|.
name|FixRateType
operator|=
name|htole32
argument_list|(
name|RATETYPE
argument_list|(
name|rate
operator|->
name|RateSeries
index|[
name|i
index|]
operator|.
name|Rate
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|FixedRate
operator|=
name|htole32
argument_list|(
name|RATEVAL
argument_list|(
name|rate
operator|->
name|RateSeries
index|[
name|i
index|]
operator|.
name|Rate
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|FixRateTypeFlags
operator|.
name|RetryCountValid
operator|=
name|htole32
argument_list|(
name|RETRY_COUNT_VALID
argument_list|)
expr_stmt|;
name|fp
operator|->
name|RetryCount
operator|=
name|htole32
argument_list|(
name|rate
operator|->
name|RateSeries
index|[
name|i
index|]
operator|.
name|TryCount
operator|-
literal|1
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|pCmd
operator|->
name|EntryCount
operator|=
name|htole32
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
name|pCmd
operator|->
name|Action
operator|=
name|htole32
argument_list|(
name|HostCmd_ACT_NOT_USE_FIXED_RATE
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_FIXED_RATE
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_settxrate_auto
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
specifier|const
name|MWL_HAL_TXRATE
modifier|*
name|rate
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_FW_USE_FIXED_RATE
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_USE_FIXED_RATE
argument_list|,
name|HostCmd_CMD_SET_FIXED_RATE
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|MulticastRate
operator|=
name|RATEVAL
argument_list|(
name|rate
operator|->
name|McastRate
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|MultiRateTxType
operator|=
name|RATETYPE
argument_list|(
name|rate
operator|->
name|McastRate
argument_list|)
expr_stmt|;
comment|/* NB: no rate type field */
name|pCmd
operator|->
name|ManagementRate
operator|=
name|RATEVAL
argument_list|(
name|rate
operator|->
name|MgtRate
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pCmd
operator|->
name|FixedRateTable
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pCmd
operator|->
name|FixedRateTable
argument_list|)
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole32
argument_list|(
name|HostCmd_ACT_NOT_USE_FIXED_RATE
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_FIXED_RATE
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|RATEVAL
end_undef

begin_undef
undef|#
directive|undef
name|RATETYPE
end_undef

begin_function
name|int
name|mwl_hal_setslottime
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
name|usecs
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_SLOT
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|usecs
operator|!=
literal|9
operator|&&
name|usecs
operator|!=
literal|20
condition|)
return|return
name|EINVAL
return|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_SET_SLOT
argument_list|,
name|HostCmd_CMD_802_11_SET_SLOT
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
name|HostCmd_ACT_GEN_SET
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Slot
operator|=
operator|(
name|usecs
operator|==
literal|9
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_802_11_SET_SLOT
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_adjusttxpower
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|uint32_t
name|level
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_DS_802_11_RF_TX_POWER
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_DS_802_11_RF_TX_POWER
argument_list|,
name|HostCmd_CMD_802_11_RF_TX_POWER
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
name|HostCmd_ACT_GEN_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|<
literal|30
condition|)
block|{
name|pCmd
operator|->
name|SupportTxPowerLevel
operator|=
name|htole16
argument_list|(
name|WL_TX_POWERLEVEL_LOW
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|level
operator|>=
literal|30
operator|&&
name|level
operator|<
literal|60
condition|)
block|{
name|pCmd
operator|->
name|SupportTxPowerLevel
operator|=
name|htole16
argument_list|(
name|WL_TX_POWERLEVEL_MEDIUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pCmd
operator|->
name|SupportTxPowerLevel
operator|=
name|htole16
argument_list|(
name|WL_TX_POWERLEVEL_HIGH
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_802_11_RF_TX_POWER
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|mwl_hal_channel
modifier|*
name|findchannel
parameter_list|(
specifier|const
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|,
specifier|const
name|MWL_HAL_CHANNEL
modifier|*
name|c
parameter_list|)
block|{
specifier|const
name|struct
name|mwl_hal_channel
modifier|*
name|hc
decl_stmt|;
specifier|const
name|MWL_HAL_CHANNELINFO
modifier|*
name|ci
decl_stmt|;
name|int
name|chan
init|=
name|c
operator|->
name|channel
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|channelFlags
operator|.
name|FreqBand
operator|==
name|MWL_FREQ_BAND_2DOT4GHZ
condition|)
block|{
name|i
operator|=
name|chan
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|channelFlags
operator|.
name|ChnlWidth
operator|==
name|MWL_CH_40_MHz_WIDTH
condition|)
block|{
name|ci
operator|=
operator|&
name|mh
operator|->
name|mh_40M
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|channelFlags
operator|.
name|ExtChnlOffset
operator|==
name|MWL_EXT_CH_BELOW_CTRL_CH
condition|)
name|i
operator|-=
literal|4
expr_stmt|;
block|}
else|else
name|ci
operator|=
operator|&
name|mh
operator|->
name|mh_20M
expr_stmt|;
comment|/* 2.4G channel table is directly indexed */
name|hc
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|i
operator|<
name|ci
operator|->
name|nchannels
operator|)
condition|?
operator|&
name|ci
operator|->
name|channels
index|[
name|i
index|]
else|:
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|channelFlags
operator|.
name|FreqBand
operator|==
name|MWL_FREQ_BAND_5GHZ
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|channelFlags
operator|.
name|ChnlWidth
operator|==
name|MWL_CH_40_MHz_WIDTH
condition|)
block|{
name|ci
operator|=
operator|&
name|mh
operator|->
name|mh_40M_5G
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|channelFlags
operator|.
name|ExtChnlOffset
operator|==
name|MWL_EXT_CH_BELOW_CTRL_CH
condition|)
name|chan
operator|-=
literal|4
expr_stmt|;
block|}
else|else
name|ci
operator|=
operator|&
name|mh
operator|->
name|mh_20M_5G
expr_stmt|;
comment|/* 5GHz channel table is sparse and must be searched */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ci
operator|->
name|nchannels
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ci
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|ieee
operator|==
name|chan
condition|)
break|break;
name|hc
operator|=
operator|(
name|i
operator|<
name|ci
operator|->
name|nchannels
operator|)
condition|?
operator|&
name|ci
operator|->
name|channels
index|[
name|i
index|]
else|:
name|NULL
expr_stmt|;
block|}
else|else
name|hc
operator|=
name|NULL
expr_stmt|;
return|return
name|hc
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_settxpower
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
specifier|const
name|MWL_HAL_CHANNEL
modifier|*
name|c
parameter_list|,
name|uint8_t
name|maxtxpow
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_DS_802_11_RF_TX_POWER
modifier|*
name|pCmd
decl_stmt|;
specifier|const
name|struct
name|mwl_hal_channel
modifier|*
name|hc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|retval
decl_stmt|;
name|hc
operator|=
name|findchannel
argument_list|(
name|mh
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|hc
operator|==
name|NULL
condition|)
block|{
comment|/* XXX temp while testing */
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"%s: no cal data for channel %u band %u width %u ext %u\n"
argument_list|,
name|__func__
argument_list|,
name|c
operator|->
name|channel
argument_list|,
name|c
operator|->
name|channelFlags
operator|.
name|FreqBand
argument_list|,
name|c
operator|->
name|channelFlags
operator|.
name|ChnlWidth
argument_list|,
name|c
operator|->
name|channelFlags
operator|.
name|ExtChnlOffset
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_DS_802_11_RF_TX_POWER
argument_list|,
name|HostCmd_CMD_802_11_RF_TX_POWER
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
name|HostCmd_ACT_GEN_SET_LIST
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* NB: 5Ghz cal data have the channel # in [0]; don't truncate */
if|if
condition|(
name|c
operator|->
name|channelFlags
operator|.
name|FreqBand
operator|==
name|MWL_FREQ_BAND_5GHZ
condition|)
name|pCmd
operator|->
name|PowerLevelList
index|[
name|i
operator|++
index|]
operator|=
name|htole16
argument_list|(
name|hc
operator|->
name|targetPowers
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|uint16_t
name|pow
init|=
name|hc
operator|->
name|targetPowers
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pow
operator|>
name|maxtxpow
condition|)
name|pow
operator|=
name|maxtxpow
expr_stmt|;
name|pCmd
operator|->
name|PowerLevelList
index|[
name|i
index|]
operator|=
name|htole16
argument_list|(
name|pow
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_802_11_RF_TX_POWER
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_getchannelinfo
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
name|band
parameter_list|,
name|int
name|chw
parameter_list|,
specifier|const
name|MWL_HAL_CHANNELINFO
modifier|*
modifier|*
name|ci
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|band
condition|)
block|{
case|case
name|MWL_FREQ_BAND_2DOT4GHZ
case|:
operator|*
name|ci
operator|=
operator|(
name|chw
operator|==
name|MWL_CH_20_MHz_WIDTH
operator|)
condition|?
operator|&
name|mh
operator|->
name|mh_20M
else|:
operator|&
name|mh
operator|->
name|mh_40M
expr_stmt|;
break|break;
case|case
name|MWL_FREQ_BAND_5GHZ
case|:
operator|*
name|ci
operator|=
operator|(
name|chw
operator|==
name|MWL_CH_20_MHz_WIDTH
operator|)
condition|?
operator|&
name|mh
operator|->
name|mh_20M_5G
else|:
operator|&
name|mh
operator|->
name|mh_40M_5G
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
operator|(
operator|(
operator|*
name|ci
operator|)
operator|->
name|freqLow
operator|==
operator|(
operator|*
name|ci
operator|)
operator|->
name|freqHigh
operator|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setmcast
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
name|nmc
parameter_list|,
specifier|const
name|uint8_t
name|macs
index|[]
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_DS_MAC_MULTICAST_ADR
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|nmc
operator|>
name|MWL_HAL_MCAST_MAX
condition|)
return|return
name|EINVAL
return|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_DS_MAC_MULTICAST_ADR
argument_list|,
name|HostCmd_CMD_MAC_MULTICAST_ADR
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pCmd
operator|->
name|MACList
argument_list|,
name|macs
argument_list|,
name|nmc
operator|*
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|NumOfAdrs
operator|=
name|htole16
argument_list|(
name|nmc
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_MAC_MULTICAST_ADR
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_keyset
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|MWL_HAL_KEYVAL
modifier|*
name|kv
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_FW_UPDATE_ENCRYPTION_SET_KEY
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_FW_UPDATE_ENCRYPTION_SET_KEY
argument_list|,
name|HostCmd_CMD_UPDATE_ENCRYPTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|kv
operator|->
name|keyFlags
operator|&
operator|(
name|KEY_FLAG_TXGROUPKEY
operator||
name|KEY_FLAG_RXGROUPKEY
operator|)
condition|)
name|pCmd
operator|->
name|ActionType
operator|=
name|htole32
argument_list|(
name|EncrActionTypeSetGroupKey
argument_list|)
expr_stmt|;
else|else
name|pCmd
operator|->
name|ActionType
operator|=
name|htole32
argument_list|(
name|EncrActionTypeSetKey
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|KeyParam
operator|.
name|Length
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
name|pCmd
operator|->
name|KeyParam
argument_list|)
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|KeyParam
operator|.
name|KeyTypeId
operator|=
name|htole16
argument_list|(
name|kv
operator|->
name|keyTypeId
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|KeyParam
operator|.
name|KeyInfo
operator|=
name|htole32
argument_list|(
name|kv
operator|->
name|keyFlags
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|KeyParam
operator|.
name|KeyIndex
operator|=
name|htole32
argument_list|(
name|kv
operator|->
name|keyIndex
argument_list|)
expr_stmt|;
comment|/* NB: includes TKIP MIC keys */
name|memcpy
argument_list|(
operator|&
name|pCmd
operator|->
name|KeyParam
operator|.
name|Key
argument_list|,
operator|&
name|kv
operator|->
name|key
argument_list|,
name|kv
operator|->
name|keyLen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kv
operator|->
name|keyTypeId
condition|)
block|{
case|case
name|KEY_TYPE_ID_WEP
case|:
name|pCmd
operator|->
name|KeyParam
operator|.
name|KeyLen
operator|=
name|htole16
argument_list|(
name|kv
operator|->
name|keyLen
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_TYPE_ID_TKIP
case|:
name|pCmd
operator|->
name|KeyParam
operator|.
name|KeyLen
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
name|TKIP_TYPE_KEY
argument_list|)
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|KeyParam
operator|.
name|Key
operator|.
name|TkipKey
operator|.
name|TkipRsc
operator|.
name|low
operator|=
name|htole16
argument_list|(
name|kv
operator|->
name|key
operator|.
name|tkip
operator|.
name|rsc
operator|.
name|low
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|KeyParam
operator|.
name|Key
operator|.
name|TkipKey
operator|.
name|TkipRsc
operator|.
name|high
operator|=
name|htole32
argument_list|(
name|kv
operator|->
name|key
operator|.
name|tkip
operator|.
name|rsc
operator|.
name|high
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|KeyParam
operator|.
name|Key
operator|.
name|TkipKey
operator|.
name|TkipTsc
operator|.
name|low
operator|=
name|htole16
argument_list|(
name|kv
operator|->
name|key
operator|.
name|tkip
operator|.
name|tsc
operator|.
name|low
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|KeyParam
operator|.
name|Key
operator|.
name|TkipKey
operator|.
name|TkipTsc
operator|.
name|high
operator|=
name|htole32
argument_list|(
name|kv
operator|->
name|key
operator|.
name|tkip
operator|.
name|tsc
operator|.
name|high
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_TYPE_ID_AES
case|:
name|pCmd
operator|->
name|KeyParam
operator|.
name|KeyLen
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
name|AES_TYPE_KEY
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|MWL_MBSS_SUPPORT
name|IEEE80211_ADDR_COPY
argument_list|(
name|pCmd
operator|->
name|KeyParam
operator|.
name|Macaddr
argument_list|,
name|mac
argument_list|)
expr_stmt|;
else|#
directive|else
name|IEEE80211_ADDR_COPY
argument_list|(
name|pCmd
operator|->
name|Macaddr
argument_list|,
name|mac
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_UPDATE_ENCRYPTION
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_keyreset
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|MWL_HAL_KEYVAL
modifier|*
name|kv
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_FW_UPDATE_ENCRYPTION_SET_KEY
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_FW_UPDATE_ENCRYPTION_SET_KEY
argument_list|,
name|HostCmd_CMD_UPDATE_ENCRYPTION
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|ActionType
operator|=
name|htole16
argument_list|(
name|EncrActionTypeRemoveKey
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|KeyParam
operator|.
name|Length
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
name|pCmd
operator|->
name|KeyParam
argument_list|)
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|KeyParam
operator|.
name|KeyTypeId
operator|=
name|htole16
argument_list|(
name|kv
operator|->
name|keyTypeId
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|KeyParam
operator|.
name|KeyInfo
operator|=
name|htole32
argument_list|(
name|kv
operator|->
name|keyFlags
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|KeyParam
operator|.
name|KeyIndex
operator|=
name|htole32
argument_list|(
name|kv
operator|->
name|keyIndex
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MWL_MBSS_SUPPORT
name|IEEE80211_ADDR_COPY
argument_list|(
name|pCmd
operator|->
name|KeyParam
operator|.
name|Macaddr
argument_list|,
name|mac
argument_list|)
expr_stmt|;
else|#
directive|else
name|IEEE80211_ADDR_COPY
argument_list|(
name|pCmd
operator|->
name|Macaddr
argument_list|,
name|mac
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_UPDATE_ENCRYPTION
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwl_hal_setmac_locked
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|addr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_DS_SET_MAC
modifier|*
name|pCmd
decl_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_DS_SET_MAC
argument_list|,
name|HostCmd_CMD_SET_MAC_ADDR
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
operator|&
name|pCmd
operator|->
name|MacAddr
index|[
literal|0
index|]
argument_list|,
name|addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MWL_MBSS_SUPPORT
name|pCmd
operator|->
name|MacType
operator|=
name|vap
operator|->
name|bss_type
expr_stmt|;
comment|/* NB: already byte swapped */
name|IEEE80211_ADDR_COPY
argument_list|(
name|vap
operator|->
name|mac
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* XXX do only if success */
endif|#
directive|endif
return|return
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_MAC_ADDR
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setmac
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|addr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwl_hal_setmac_locked
argument_list|(
name|vap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setbeacon
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|void
modifier|*
name|frame
parameter_list|,
name|size_t
name|frameLen
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_DS_SET_BEACON
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* XXX verify frameLen fits */
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_DS_SET_BEACON
argument_list|,
name|HostCmd_CMD_SET_BEACON
argument_list|)
expr_stmt|;
comment|/* XXX override _VCMD_SETUP */
name|pCmd
operator|->
name|CmdHdr
operator|.
name|Length
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
name|HostCmd_DS_SET_BEACON
argument_list|)
operator|-
literal|1
operator|+
name|frameLen
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|FrmBodyLen
operator|=
name|htole16
argument_list|(
name|frameLen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pCmd
operator|->
name|FrmBody
argument_list|,
name|frame
argument_list|,
name|frameLen
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_BEACON
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setpowersave_bss
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
name|uint8_t
name|nsta
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_SET_POWERSAVESTATION
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_SET_POWERSAVESTATION
argument_list|,
name|HostCmd_CMD_SET_POWERSAVESTATION
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|NumberOfPowersave
operator|=
name|nsta
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_POWERSAVESTATION
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setpowersave_sta
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
name|uint16_t
name|aid
parameter_list|,
name|int
name|ena
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_SET_TIM
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_SET_TIM
argument_list|,
name|HostCmd_CMD_SET_TIM
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Aid
operator|=
name|htole16
argument_list|(
name|aid
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Set
operator|=
name|htole32
argument_list|(
name|ena
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_TIM
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setassocid
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|bssId
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|uint16_t
name|assocId
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_AID
modifier|*
name|pCmd
init|=
operator|(
name|HostCmd_FW_SET_AID
operator|*
operator|)
operator|&
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|0
index|]
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_FW_SET_AID
argument_list|,
name|HostCmd_CMD_SET_AID
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|AssocID
operator|=
name|htole16
argument_list|(
name|assocId
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
operator|&
name|pCmd
operator|->
name|MacAddr
index|[
literal|0
index|]
argument_list|,
name|bssId
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_AID
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setchannel
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
specifier|const
name|MWL_HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_RF_CHANNEL
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_SET_RF_CHANNEL
argument_list|,
name|HostCmd_CMD_SET_RF_CHANNEL
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
name|HostCmd_ACT_GEN_SET
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|CurrentChannel
operator|=
name|chan
operator|->
name|channel
expr_stmt|;
name|pCmd
operator|->
name|ChannelFlags
operator|=
name|cvtChannelFlags
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/* NB: byte-swapped */
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_RF_CHANNEL
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bastream_check_available
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
name|int
name|qid
parameter_list|,
specifier|const
name|uint8_t
name|Macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|uint8_t
name|Tid
parameter_list|,
name|uint8_t
name|ParamInfo
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_FW_BASTREAM
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK_ASSERT
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_FW_BASTREAM
argument_list|,
name|HostCmd_CMD_BASTREAM
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|ActionType
operator|=
name|htole32
argument_list|(
name|BaCheckCreateStream
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|BarThrs
operator|=
name|htole32
argument_list|(
literal|63
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|WindowSize
operator|=
name|htole32
argument_list|(
literal|64
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|IdleThrs
operator|=
name|htole32
argument_list|(
literal|0x22000
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
operator|&
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|PeerMacAddr
index|[
literal|0
index|]
argument_list|,
name|Macaddr
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|DialogToken
operator|=
literal|10
expr_stmt|;
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|Tid
operator|=
name|Tid
expr_stmt|;
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|QueueId
operator|=
name|qid
expr_stmt|;
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|ParamInfo
operator|=
operator|(
name|uint8_t
operator|)
name|ParamInfo
expr_stmt|;
if|#
directive|if
literal|0
block|cvtBAFlags(&pCmd->BaInfo.CreateParams.Flags, sp->ba_policy, 0);
else|#
directive|else
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|Flags
operator|=
name|htole32
argument_list|(
name|BASTREAM_FLAG_IMMEDIATE_TYPE
argument_list|)
operator||
name|htole32
argument_list|(
name|BASTREAM_FLAG_DIRECTION_UPSTREAM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_BASTREAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
comment|/* 		 * NB: BA stream create may fail when the stream is 		 * h/w backed under some (as yet not understood) conditions. 		 * Check the result code to catch this. 		 */
if|if
condition|(
name|le16toh
argument_list|(
name|pCmd
operator|->
name|CmdHdr
operator|.
name|Result
argument_list|)
operator|!=
name|HostCmd_RESULT_OK
condition|)
name|retval
operator|=
name|EIO
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|const
name|MWL_HAL_BASTREAM
modifier|*
name|mwl_hal_bastream_alloc
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
name|int
name|ba_policy
parameter_list|,
specifier|const
name|uint8_t
name|Macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|uint8_t
name|Tid
parameter_list|,
name|uint8_t
name|ParamInfo
parameter_list|,
name|void
modifier|*
name|a1
parameter_list|,
name|void
modifier|*
name|a2
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|mwl_hal_bastream
modifier|*
name|sp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|->
name|mh_bastreams
operator|==
literal|0
condition|)
block|{
comment|/* no streams available */
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|s
operator|=
literal|0
init|;
operator|(
name|mh
operator|->
name|mh_bastreams
operator|&
operator|(
literal|1
operator|<<
name|s
operator|)
operator|)
operator|==
literal|0
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|bastream_check_available
argument_list|(
name|vap
argument_list|,
name|s
argument_list|,
name|Macaddr
argument_list|,
name|Tid
argument_list|,
name|ParamInfo
argument_list|)
condition|)
block|{
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sp
operator|=
operator|&
name|mh
operator|->
name|mh_streams
index|[
name|s
index|]
expr_stmt|;
name|mh
operator|->
name|mh_bastreams
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|s
operator|)
expr_stmt|;
name|sp
operator|->
name|public
operator|.
name|data
index|[
literal|0
index|]
operator|=
name|a1
expr_stmt|;
name|sp
operator|->
name|public
operator|.
name|data
index|[
literal|1
index|]
operator|=
name|a2
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sp
operator|->
name|macaddr
argument_list|,
name|Macaddr
argument_list|)
expr_stmt|;
name|sp
operator|->
name|tid
operator|=
name|Tid
expr_stmt|;
name|sp
operator|->
name|paraminfo
operator|=
name|ParamInfo
expr_stmt|;
name|sp
operator|->
name|setup
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|ba_policy
operator|=
name|ba_policy
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|sp
operator|!=
name|NULL
condition|?
operator|&
name|sp
operator|->
name|public
else|:
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|MWL_HAL_BASTREAM
modifier|*
name|mwl_hal_bastream_lookup
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
name|s
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
literal|0
operator|<=
name|s
operator|&&
name|s
operator|<
name|MWL_BASTREAMS_MAX
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|mh
operator|->
name|mh_bastreams
operator|&
operator|(
literal|1
operator|<<
name|s
operator|)
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|mh
operator|->
name|mh_streams
index|[
name|s
index|]
operator|.
name|public
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__DECONST
end_ifndef

begin_define
define|#
directive|define
name|__DECONST
parameter_list|(
name|type
parameter_list|,
name|var
parameter_list|)
value|((type)(uintptr_t)(const void *)(var))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|mwl_hal_bastream_create
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|MWL_HAL_BASTREAM
modifier|*
name|s
parameter_list|,
name|int
name|BarThrs
parameter_list|,
name|int
name|WindowSize
parameter_list|,
name|uint16_t
name|seqno
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|mwl_hal_bastream
modifier|*
name|sp
init|=
name|__DECONST
argument_list|(
expr|struct
name|mwl_hal_bastream
operator|*
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|HostCmd_FW_BASTREAM
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_FW_BASTREAM
argument_list|,
name|HostCmd_CMD_BASTREAM
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|ActionType
operator|=
name|htole32
argument_list|(
name|BaCreateStream
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|BarThrs
operator|=
name|htole32
argument_list|(
name|BarThrs
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|WindowSize
operator|=
name|htole32
argument_list|(
name|WindowSize
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|IdleThrs
operator|=
name|htole32
argument_list|(
literal|0x22000
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
operator|&
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|PeerMacAddr
index|[
literal|0
index|]
argument_list|,
name|sp
operator|->
name|macaddr
argument_list|)
expr_stmt|;
comment|/* XXX proxy STA */
name|memset
argument_list|(
operator|&
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|StaSrcMacAddr
argument_list|,
literal|0
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|pCmd->BaInfo.CreateParams.DialogToken = DialogToken;
else|#
directive|else
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|DialogToken
operator|=
literal|10
expr_stmt|;
endif|#
directive|endif
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|Tid
operator|=
name|sp
operator|->
name|tid
expr_stmt|;
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|QueueId
operator|=
name|sp
operator|->
name|stream
expr_stmt|;
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|ParamInfo
operator|=
name|sp
operator|->
name|paraminfo
expr_stmt|;
comment|/* NB: ResetSeqNo known to be zero */
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|StartSeqNo
operator|=
name|htole16
argument_list|(
name|seqno
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|cvtBAFlags(&pCmd->BaInfo.CreateParams.Flags, sp->ba_policy, 0);
else|#
directive|else
name|pCmd
operator|->
name|BaInfo
operator|.
name|CreateParams
operator|.
name|Flags
operator|=
name|htole32
argument_list|(
name|BASTREAM_FLAG_IMMEDIATE_TYPE
argument_list|)
operator||
name|htole32
argument_list|(
name|BASTREAM_FLAG_DIRECTION_UPSTREAM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_BASTREAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
comment|/* 		 * NB: BA stream create may fail when the stream is 		 * h/w backed under some (as yet not understood) conditions. 		 * Check the result code to catch this. 		 */
if|if
condition|(
name|le16toh
argument_list|(
name|pCmd
operator|->
name|CmdHdr
operator|.
name|Result
argument_list|)
operator|!=
name|HostCmd_RESULT_OK
condition|)
name|retval
operator|=
name|EIO
expr_stmt|;
else|else
name|sp
operator|->
name|setup
operator|=
literal|1
expr_stmt|;
block|}
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_bastream_destroy
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
specifier|const
name|MWL_HAL_BASTREAM
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|struct
name|mwl_hal_bastream
modifier|*
name|sp
init|=
name|__DECONST
argument_list|(
expr|struct
name|mwl_hal_bastream
operator|*
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|HostCmd_FW_BASTREAM
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|stream
operator|>=
name|MWL_BASTREAMS_MAX
condition|)
block|{
comment|/* XXX */
return|return
name|EINVAL
return|;
block|}
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|setup
condition|)
block|{
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_BASTREAM
argument_list|,
name|HostCmd_CMD_BASTREAM
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|ActionType
operator|=
name|htole32
argument_list|(
name|BaDestroyStream
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|BaInfo
operator|.
name|DestroyParams
operator|.
name|FwBaContext
operator|.
name|Context
operator|=
name|htole32
argument_list|(
name|sp
operator|->
name|stream
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_BASTREAM
argument_list|)
expr_stmt|;
block|}
else|else
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* NB: always reclaim stream */
name|mh
operator|->
name|mh_bastreams
operator||=
literal|1
operator|<<
name|sp
operator|->
name|stream
expr_stmt|;
name|sp
operator|->
name|public
operator|.
name|data
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|public
operator|.
name|data
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|setup
operator|=
literal|0
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_bastream_get_seqno
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
specifier|const
name|MWL_HAL_BASTREAM
modifier|*
name|s
parameter_list|,
specifier|const
name|uint8_t
name|Macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|uint16_t
modifier|*
name|pseqno
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|struct
name|mwl_hal_bastream
modifier|*
name|sp
init|=
name|__DECONST
argument_list|(
expr|struct
name|mwl_hal_bastream
operator|*
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|HostCmd_GET_SEQNO
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_GET_SEQNO
argument_list|,
name|HostCmd_CMD_GET_SEQNO
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|pCmd
operator|->
name|MacAddr
argument_list|,
name|Macaddr
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|TID
operator|=
name|sp
operator|->
name|tid
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_GET_SEQNO
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
operator|*
name|pseqno
operator|=
name|le16toh
argument_list|(
name|pCmd
operator|->
name|SeqNo
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_getwatchdogbitmap
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|uint8_t
name|bitmap
index|[
literal|1
index|]
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_FW_GET_WATCHDOG_BITMAP
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_GET_WATCHDOG_BITMAP
argument_list|,
name|HostCmd_CMD_GET_WATCHDOG_BITMAP
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_GET_WATCHDOG_BITMAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|bitmap
index|[
literal|0
index|]
operator|=
name|pCmd
operator|->
name|Watchdogbitmap
expr_stmt|;
comment|/* fw returns qid, map it to BA stream */
if|if
condition|(
name|bitmap
index|[
literal|0
index|]
operator|<
name|MWL_BAQID_MAX
condition|)
name|bitmap
index|[
literal|0
index|]
operator|=
name|qid2ba
index|[
name|bitmap
index|[
literal|0
index|]
index|]
expr_stmt|;
block|}
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Configure aggressive Ampdu rate mode.  */
end_comment

begin_function
name|int
name|mwl_hal_setaggampduratemode
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|threshold
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_FW_AMPDU_RETRY_RATEDROP_MODE
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_AMPDU_RETRY_RATEDROP_MODE
argument_list|,
name|HostCmd_CMD_AMPDU_RETRY_RATEDROP_MODE
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Option
operator|=
name|htole32
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Threshold
operator|=
name|htole32
argument_list|(
name|threshold
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_AMPDU_RETRY_RATEDROP_MODE
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_getaggampduratemode
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
modifier|*
name|mode
parameter_list|,
name|int
modifier|*
name|threshold
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_FW_AMPDU_RETRY_RATEDROP_MODE
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_AMPDU_RETRY_RATEDROP_MODE
argument_list|,
name|HostCmd_CMD_AMPDU_RETRY_RATEDROP_MODE
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_AMPDU_RETRY_RATEDROP_MODE
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
operator|*
name|mode
operator|=
name|le32toh
argument_list|(
name|pCmd
operator|->
name|Option
argument_list|)
expr_stmt|;
operator|*
name|threshold
operator|=
name|le32toh
argument_list|(
name|pCmd
operator|->
name|Threshold
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Set CFEND status Enable/Disable  */
end_comment

begin_function
name|int
name|mwl_hal_setcfend
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
name|ena
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_CFEND_ENABLE
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_CFEND_ENABLE
argument_list|,
name|HostCmd_CMD_CFEND_ENABLE
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Enable
operator|=
name|htole32
argument_list|(
name|ena
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_CFEND_ENABLE
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setdwds
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
name|ena
parameter_list|)
block|{
name|HostCmd_DWDS_ENABLE
modifier|*
name|pCmd
decl_stmt|;
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_DWDS_ENABLE
argument_list|,
name|HostCmd_CMD_DWDS_ENABLE
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Enable
operator|=
name|htole32
argument_list|(
name|ena
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_DWDS_ENABLE
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvtPeerInfo
parameter_list|(
name|PeerInfo_t
modifier|*
name|to
parameter_list|,
specifier|const
name|MWL_HAL_PEERINFO
modifier|*
name|from
parameter_list|)
block|{
name|to
operator|->
name|LegacyRateBitMap
operator|=
name|htole32
argument_list|(
name|from
operator|->
name|LegacyRateBitMap
argument_list|)
expr_stmt|;
name|to
operator|->
name|HTRateBitMap
operator|=
name|htole32
argument_list|(
name|from
operator|->
name|HTRateBitMap
argument_list|)
expr_stmt|;
name|to
operator|->
name|CapInfo
operator|=
name|htole16
argument_list|(
name|from
operator|->
name|CapInfo
argument_list|)
expr_stmt|;
name|to
operator|->
name|HTCapabilitiesInfo
operator|=
name|htole16
argument_list|(
name|from
operator|->
name|HTCapabilitiesInfo
argument_list|)
expr_stmt|;
name|to
operator|->
name|MacHTParamInfo
operator|=
name|from
operator|->
name|MacHTParamInfo
expr_stmt|;
name|to
operator|->
name|AddHtInfo
operator|.
name|ControlChan
operator|=
name|from
operator|->
name|AddHtInfo
operator|.
name|ControlChan
expr_stmt|;
name|to
operator|->
name|AddHtInfo
operator|.
name|AddChan
operator|=
name|from
operator|->
name|AddHtInfo
operator|.
name|AddChan
expr_stmt|;
name|to
operator|->
name|AddHtInfo
operator|.
name|OpMode
operator|=
name|htole16
argument_list|(
name|from
operator|->
name|AddHtInfo
operator|.
name|OpMode
argument_list|)
expr_stmt|;
name|to
operator|->
name|AddHtInfo
operator|.
name|stbc
operator|=
name|htole16
argument_list|(
name|from
operator|->
name|AddHtInfo
operator|.
name|stbc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX station id must be in [0..63] */
end_comment

begin_function
name|int
name|mwl_hal_newstation
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|addr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|uint16_t
name|aid
parameter_list|,
name|uint16_t
name|sid
parameter_list|,
specifier|const
name|MWL_HAL_PEERINFO
modifier|*
name|peer
parameter_list|,
name|int
name|isQosSta
parameter_list|,
name|int
name|wmeInfo
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_NEW_STN
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_FW_SET_NEW_STN
argument_list|,
name|HostCmd_CMD_SET_NEW_STN
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|AID
operator|=
name|htole16
argument_list|(
name|aid
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|StnId
operator|=
name|htole16
argument_list|(
name|sid
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* SET */
if|if
condition|(
name|peer
operator|!=
name|NULL
condition|)
block|{
comment|/* NB: must fix up byte order */
name|cvtPeerInfo
argument_list|(
operator|&
name|pCmd
operator|->
name|PeerInfo
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_ADDR_COPY
argument_list|(
operator|&
name|pCmd
operator|->
name|MacAddr
index|[
literal|0
index|]
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Qosinfo
operator|=
name|wmeInfo
expr_stmt|;
name|pCmd
operator|->
name|isQosSta
operator|=
operator|(
name|isQosSta
operator|!=
literal|0
operator|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_NEW_STN
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
operator|&&
name|IEEE80211_ADDR_EQ
argument_list|(
name|vap
operator|->
name|mac
argument_list|,
name|addr
argument_list|)
condition|)
name|vap
operator|->
name|flags
operator||=
name|MVF_STATION
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_delstation
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|addr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_NEW_STN
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|islocal
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|islocal
operator|=
name|IEEE80211_ADDR_EQ
argument_list|(
name|vap
operator|->
name|mac
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|islocal
operator|||
operator|(
name|vap
operator|->
name|flags
operator|&
name|MVF_STATION
operator|)
condition|)
block|{
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_FW_SET_NEW_STN
argument_list|,
name|HostCmd_CMD_SET_NEW_STN
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* REMOVE */
name|IEEE80211_ADDR_COPY
argument_list|(
operator|&
name|pCmd
operator|->
name|MacAddr
index|[
literal|0
index|]
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_NEW_STN
argument_list|)
expr_stmt|;
if|if
condition|(
name|islocal
condition|)
name|vap
operator|->
name|flags
operator|&=
operator|~
name|MVF_STATION
expr_stmt|;
block|}
else|else
name|retval
operator|=
literal|0
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Prod the firmware to age packets on station power  * save queues and reap frames on the tx aggregation q's.  */
end_comment

begin_function
name|int
name|mwl_hal_setkeepalive
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_KEEP_ALIVE_TICK
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_SET_KEEP_ALIVE_TICK
argument_list|,
name|HostCmd_CMD_SET_KEEP_ALIVE
argument_list|)
expr_stmt|;
comment|/* 	 * NB: tick must be 0 to prod the f/w; 	 *     a non-zero value is a noop. 	 */
name|pCmd
operator|->
name|tick
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_KEEP_ALIVE
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setapmode
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
name|MWL_HAL_APMODE
name|ApMode
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_APMODE
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* XXX validate ApMode? */
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_FW_SET_APMODE
argument_list|,
name|HostCmd_CMD_SET_APMODE
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|ApMode
operator|=
name|ApMode
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_APMODE
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_stop
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_DS_BSS_START
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|flags
operator|&
name|MVF_RUNNING
condition|)
block|{
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_DS_BSS_START
argument_list|,
name|HostCmd_CMD_BSS_START
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Enable
operator|=
name|htole32
argument_list|(
name|HostCmd_ACT_GEN_OFF
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_BSS_START
argument_list|)
expr_stmt|;
block|}
else|else
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* NB: mark !running regardless */
name|vap
operator|->
name|flags
operator|&=
operator|~
name|MVF_RUNNING
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_start
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_DS_BSS_START
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_DS_BSS_START
argument_list|,
name|HostCmd_CMD_BSS_START
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Enable
operator|=
name|htole32
argument_list|(
name|HostCmd_ACT_GEN_ON
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_BSS_START
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|vap
operator|->
name|flags
operator||=
name|MVF_RUNNING
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setgprot
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_G_PROTECT_FLAG
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_SET_G_PROTECT_FLAG
argument_list|,
name|HostCmd_CMD_SET_G_PROTECT_FLAG
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|GProtectFlag
operator|=
name|htole32
argument_list|(
name|prot
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_G_PROTECT_FLAG
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setwmm
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_FW_SetWMMMode
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_SetWMMMode
argument_list|,
name|HostCmd_CMD_SET_WMM_MODE
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
name|onoff
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_WMM_MODE
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setedcaparams
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|uint8_t
name|qnum
parameter_list|,
name|uint32_t
name|CWmin
parameter_list|,
name|uint32_t
name|CWmax
parameter_list|,
name|uint8_t
name|AIFSN
parameter_list|,
name|uint16_t
name|TXOPLimit
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_EDCA_PARAMS
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_SET_EDCA_PARAMS
argument_list|,
name|HostCmd_CMD_SET_EDCA_PARAMS
argument_list|)
expr_stmt|;
comment|/* 	 * NB: CWmin and CWmax are always set. 	 *     TxOpLimit is set if bit 0x2 is marked in Action 	 *     AIFSN is set if bit 0x4 is marked in Action 	 */
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* NB: set everything */
name|pCmd
operator|->
name|TxOP
operator|=
name|htole16
argument_list|(
name|TXOPLimit
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|CWMax
operator|=
name|htole32
argument_list|(
name|CWmax
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|CWMin
operator|=
name|htole32
argument_list|(
name|CWmin
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|AIFSN
operator|=
name|AIFSN
expr_stmt|;
name|pCmd
operator|->
name|TxQNum
operator|=
name|qnum
expr_stmt|;
comment|/* XXX check */
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_EDCA_PARAMS
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* XXX 0 = indoor, 1 = outdoor */
end_comment

begin_function
name|int
name|mwl_hal_setrateadaptmode
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|uint16_t
name|mode
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_DS_SET_RATE_ADAPT_MODE
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_DS_SET_RATE_ADAPT_MODE
argument_list|,
name|HostCmd_CMD_SET_RATE_ADAPT_MODE
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
name|HostCmd_ACT_GEN_SET
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|RateAdaptMode
operator|=
name|htole16
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_RATE_ADAPT_MODE
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setcsmode
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|MWL_HAL_CSMODE
name|csmode
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_DS_SET_LINKADAPT_CS_MODE
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_DS_SET_LINKADAPT_CS_MODE
argument_list|,
name|HostCmd_CMD_SET_LINKADAPT_CS_MODE
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
name|HostCmd_ACT_GEN_SET
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|CSMode
operator|=
name|htole16
argument_list|(
name|csmode
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_LINKADAPT_CS_MODE
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setnprot
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
name|MWL_HAL_HTPROTECT
name|mode
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_N_PROTECT_FLAG
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* XXX validate mode */
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_FW_SET_N_PROTECT_FLAG
argument_list|,
name|HostCmd_CMD_SET_N_PROTECT_FLAG
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|NProtectFlag
operator|=
name|htole32
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_N_PROTECT_FLAG
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setnprotmode
parameter_list|(
name|struct
name|mwl_hal_vap
modifier|*
name|vap
parameter_list|,
name|uint8_t
name|mode
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLVAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_N_PROTECT_OPMODE
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_VCMD_SETUP
argument_list|(
name|vap
argument_list|,
name|pCmd
argument_list|,
name|HostCmd_FW_SET_N_PROTECT_OPMODE
argument_list|,
name|HostCmd_CMD_SET_N_PROTECT_OPMODE
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|NProtectOpMode
operator|=
name|mode
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_N_PROTECT_OPMODE
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setoptimizationlevel
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_OPTIMIZATION_LEVEL
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_SET_OPTIMIZATION_LEVEL
argument_list|,
name|HostCmd_CMD_SET_OPTIMIZATION_LEVEL
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|OptLevel
operator|=
name|level
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_OPTIMIZATION_LEVEL
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setmimops
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
specifier|const
name|uint8_t
name|addr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|uint8_t
name|enable
parameter_list|,
name|uint8_t
name|mode
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_MIMOPSHT
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_SET_MIMOPSHT
argument_list|,
name|HostCmd_CMD_SET_MIMOPSHT
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|pCmd
operator|->
name|Addr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Enable
operator|=
name|enable
expr_stmt|;
name|pCmd
operator|->
name|Mode
operator|=
name|mode
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_MIMOPSHT
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwlGetCalTable
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|,
name|uint8_t
name|annex
parameter_list|,
name|uint8_t
name|index
parameter_list|)
block|{
name|HostCmd_FW_GET_CALTABLE
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK_ASSERT
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_GET_CALTABLE
argument_list|,
name|HostCmd_CMD_GET_CALTABLE
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|annex
operator|=
name|annex
expr_stmt|;
name|pCmd
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|memset
argument_list|(
name|pCmd
operator|->
name|calTbl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pCmd
operator|->
name|calTbl
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_GET_CALTABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
operator|&&
name|pCmd
operator|->
name|calTbl
index|[
literal|0
index|]
operator|!=
name|annex
operator|&&
name|annex
operator|!=
literal|0
operator|&&
name|annex
operator|!=
literal|255
condition|)
name|retval
operator|=
name|EIO
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the max tx power from the channel's cal data.  */
end_comment

begin_function
specifier|static
name|void
name|setmaxtxpow
parameter_list|(
name|struct
name|mwl_hal_channel
modifier|*
name|hc
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|maxix
parameter_list|)
block|{
name|hc
operator|->
name|maxTxPow
operator|=
name|hc
operator|->
name|targetPowers
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|maxix
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hc
operator|->
name|targetPowers
index|[
name|i
index|]
operator|>
name|hc
operator|->
name|maxTxPow
condition|)
name|hc
operator|->
name|maxTxPow
operator|=
name|hc
operator|->
name|targetPowers
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct channel info for 5GHz channels from cal data.  */
end_comment

begin_function
specifier|static
name|void
name|get5Ghz
parameter_list|(
name|MWL_HAL_CHANNELINFO
modifier|*
name|ci
parameter_list|,
specifier|const
name|uint8_t
name|table
index|[]
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|f
decl_stmt|,
name|l
decl_stmt|,
name|h
decl_stmt|;
name|l
operator|=
literal|32000
expr_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|struct
name|mwl_hal_channel
modifier|*
name|hc
decl_stmt|;
if|if
condition|(
name|table
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|f
operator|=
literal|5000
operator|+
literal|5
operator|*
name|table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|<
name|l
condition|)
name|l
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|f
operator|>
name|h
condition|)
name|h
operator|=
name|f
expr_stmt|;
name|hc
operator|=
operator|&
name|ci
operator|->
name|channels
index|[
name|j
index|]
expr_stmt|;
name|hc
operator|->
name|freq
operator|=
name|f
expr_stmt|;
name|hc
operator|->
name|ieee
operator|=
name|table
index|[
name|i
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|hc
operator|->
name|targetPowers
argument_list|,
operator|&
name|table
index|[
name|i
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|setmaxtxpow
argument_list|(
name|hc
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* NB: col 1 is the freq, skip*/
name|j
operator|++
expr_stmt|;
block|}
name|ci
operator|->
name|nchannels
operator|=
name|j
expr_stmt|;
name|ci
operator|->
name|freqLow
operator|=
operator|(
name|l
operator|==
literal|32000
operator|)
condition|?
literal|0
else|:
name|l
expr_stmt|;
name|ci
operator|->
name|freqHigh
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|ieee2mhz
parameter_list|(
name|int
name|chan
parameter_list|)
block|{
if|if
condition|(
name|chan
operator|==
literal|14
condition|)
return|return
literal|2484
return|;
if|if
condition|(
name|chan
operator|<
literal|14
condition|)
return|return
literal|2407
operator|+
name|chan
operator|*
literal|5
return|;
return|return
literal|2512
operator|+
operator|(
name|chan
operator|-
literal|15
operator|)
operator|*
literal|20
return|;
block|}
end_function

begin_comment
comment|/*  * Construct channel info for 2.4GHz channels from cal data.  */
end_comment

begin_function
specifier|static
name|void
name|get2Ghz
parameter_list|(
name|MWL_HAL_CHANNELINFO
modifier|*
name|ci
parameter_list|,
specifier|const
name|uint8_t
name|table
index|[]
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|struct
name|mwl_hal_channel
modifier|*
name|hc
init|=
operator|&
name|ci
operator|->
name|channels
index|[
name|j
index|]
decl_stmt|;
name|hc
operator|->
name|ieee
operator|=
literal|1
operator|+
name|j
expr_stmt|;
name|hc
operator|->
name|freq
operator|=
name|ieee2mhz
argument_list|(
literal|1
operator|+
name|j
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hc
operator|->
name|targetPowers
argument_list|,
operator|&
name|table
index|[
name|i
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|setmaxtxpow
argument_list|(
name|hc
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|ci
operator|->
name|nchannels
operator|=
name|j
expr_stmt|;
name|ci
operator|->
name|freqLow
operator|=
name|ieee2mhz
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ci
operator|->
name|freqHigh
operator|=
name|ieee2mhz
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|DUMPCALDATA
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|DUMPCALDATA
end_ifdef

begin_function
specifier|static
name|void
name|dumpcaldata
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|table
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
literal|4
control|)
name|printf
argument_list|(
literal|"[%2d] %3d %3d %3d %3d\n"
argument_list|,
name|i
operator|/
literal|4
argument_list|,
name|table
index|[
name|i
operator|+
literal|0
index|]
argument_list|,
name|table
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|table
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|table
index|[
name|i
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|mwlGetPwrCalTable
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|MWL_HAL_CHANNELINFO
modifier|*
name|ci
decl_stmt|;
name|int
name|len
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
comment|/* NB: we hold the lock so it's ok to use cmdbuf */
name|data
operator|=
operator|(
operator|(
specifier|const
name|HostCmd_FW_GET_CALTABLE
operator|*
operator|)
name|mh
operator|->
name|mh_cmdbuf
operator|)
operator|->
name|calTbl
expr_stmt|;
if|if
condition|(
name|mwlGetCalTable
argument_list|(
name|mh
argument_list|,
literal|33
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|len
operator|=
operator|(
name|data
index|[
literal|2
index|]
operator||
operator|(
name|data
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator|)
operator|-
literal|12
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|PWTAGETRATETABLE20M
condition|)
name|len
operator|=
name|PWTAGETRATETABLE20M
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPCALDATA
name|dumpcaldata
argument_list|(
literal|"2.4G 20M"
argument_list|,
operator|&
name|data
index|[
literal|12
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/*XXX*/
endif|#
directive|endif
name|get2Ghz
argument_list|(
operator|&
name|mh
operator|->
name|mh_20M
argument_list|,
operator|&
name|data
index|[
literal|12
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mwlGetCalTable
argument_list|(
name|mh
argument_list|,
literal|34
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|len
operator|=
operator|(
name|data
index|[
literal|2
index|]
operator||
operator|(
name|data
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator|)
operator|-
literal|12
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|PWTAGETRATETABLE40M
condition|)
name|len
operator|=
name|PWTAGETRATETABLE40M
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPCALDATA
name|dumpcaldata
argument_list|(
literal|"2.4G 40M"
argument_list|,
operator|&
name|data
index|[
literal|12
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/*XXX*/
endif|#
directive|endif
name|ci
operator|=
operator|&
name|mh
operator|->
name|mh_40M
expr_stmt|;
name|get2Ghz
argument_list|(
name|ci
argument_list|,
operator|&
name|data
index|[
literal|12
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mwlGetCalTable
argument_list|(
name|mh
argument_list|,
literal|35
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|len
operator|=
operator|(
name|data
index|[
literal|2
index|]
operator||
operator|(
name|data
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator|)
operator|-
literal|20
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|PWTAGETRATETABLE20M_5G
condition|)
name|len
operator|=
name|PWTAGETRATETABLE20M_5G
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPCALDATA
name|dumpcaldata
argument_list|(
literal|"5G 20M"
argument_list|,
operator|&
name|data
index|[
literal|20
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/*XXX*/
endif|#
directive|endif
name|get5Ghz
argument_list|(
operator|&
name|mh
operator|->
name|mh_20M_5G
argument_list|,
operator|&
name|data
index|[
literal|20
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mwlGetCalTable
argument_list|(
name|mh
argument_list|,
literal|36
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|len
operator|=
operator|(
name|data
index|[
literal|2
index|]
operator||
operator|(
name|data
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator|)
operator|-
literal|20
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|PWTAGETRATETABLE40M_5G
condition|)
name|len
operator|=
name|PWTAGETRATETABLE40M_5G
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPCALDATA
name|dumpcaldata
argument_list|(
literal|"5G 40M"
argument_list|,
operator|&
name|data
index|[
literal|20
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/*XXX*/
endif|#
directive|endif
name|ci
operator|=
operator|&
name|mh
operator|->
name|mh_40M_5G
expr_stmt|;
name|get5Ghz
argument_list|(
name|ci
argument_list|,
operator|&
name|data
index|[
literal|20
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|mh
operator|->
name|mh_flags
operator||=
name|MHF_CALDATA
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_getregioncode
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|uint8_t
modifier|*
name|countryCode
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlGetCalTable
argument_list|(
name|mh
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
specifier|const
name|HostCmd_FW_GET_CALTABLE
modifier|*
name|pCmd
init|=
operator|(
specifier|const
name|HostCmd_FW_GET_CALTABLE
operator|*
operator|)
name|mh
operator|->
name|mh_cmdbuf
decl_stmt|;
operator|*
name|countryCode
operator|=
name|pCmd
operator|->
name|calTbl
index|[
literal|16
index|]
expr_stmt|;
block|}
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_setpromisc
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
name|ena
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|v
operator|=
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_PROMISCUOUS
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_PROMISCUOUS
argument_list|,
name|ena
condition|?
name|v
operator||
literal|1
else|:
name|v
operator|&
operator|~
literal|1
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_getpromisc
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|v
operator|=
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_PROMISCUOUS
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|&
literal|1
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_GetBeacon
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|uint8_t
modifier|*
name|pBcn
parameter_list|,
name|uint16_t
modifier|*
name|pLen
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_FW_GET_BEACON
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_GET_BEACON
argument_list|,
name|HostCmd_CMD_GET_BEACON
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Bcnlen
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_GET_BEACON
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
comment|/* XXX bounds check */
name|memcpy
argument_list|(
name|pBcn
argument_list|,
operator|&
name|pCmd
operator|->
name|Bcn
argument_list|,
name|pCmd
operator|->
name|Bcnlen
argument_list|)
expr_stmt|;
operator|*
name|pLen
operator|=
name|pCmd
operator|->
name|Bcnlen
expr_stmt|;
block|}
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_SetRifs
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|uint8_t
name|QNum
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
name|HostCmd_FW_SET_RIFS
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_FW_SET_RIFS
argument_list|,
name|HostCmd_CMD_SET_RIFS
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|QNum
operator|=
name|QNum
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_SET_RIFS
argument_list|)
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Diagnostic api's for set/get registers.  */
end_comment

begin_function
specifier|static
name|int
name|getRFReg
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|,
name|int
name|flag
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
name|HostCmd_DS_RF_REG_ACCESS
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_DS_RF_REG_ACCESS
argument_list|,
name|HostCmd_CMD_RF_REG_ACCESS
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Offset
operator|=
name|htole16
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
name|flag
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Value
operator|=
name|htole32
argument_list|(
operator|*
name|val
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_RF_REG_ACCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
operator|*
name|val
operator|=
name|pCmd
operator|->
name|Value
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getBBReg
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|,
name|int
name|flag
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
name|HostCmd_DS_BBP_REG_ACCESS
modifier|*
name|pCmd
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|_CMD_SETUP
argument_list|(
name|pCmd
argument_list|,
name|HostCmd_DS_BBP_REG_ACCESS
argument_list|,
name|HostCmd_CMD_BBP_REG_ACCESS
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Offset
operator|=
name|htole16
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Action
operator|=
name|htole16
argument_list|(
name|flag
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|Value
operator|=
name|htole32
argument_list|(
operator|*
name|val
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|HostCmd_CMD_BBP_REG_ACCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
operator|*
name|val
operator|=
name|pCmd
operator|->
name|Value
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|mwl_hal_getregdump
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|,
specifier|const
name|MWL_DIAG_REGRANGE
modifier|*
name|regs
parameter_list|,
name|void
modifier|*
name|dstbuf
parameter_list|,
name|int
name|space
parameter_list|)
block|{
name|uint32_t
modifier|*
name|dp
init|=
name|dstbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|space
operator|>=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|r
init|=
name|regs
index|[
name|i
index|]
operator|.
name|start
decl_stmt|;
name|u_int
name|e
init|=
name|regs
index|[
name|i
index|]
operator|.
name|end
decl_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
name|r
operator|<<
literal|16
operator|)
operator||
name|e
expr_stmt|;
name|space
operator|-=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|MWL_DIAG_ISMAC
argument_list|(
name|r
argument_list|)
condition|)
operator|*
name|dp
operator|=
name|RD4
argument_list|(
name|mh
argument_list|,
name|r
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MWL_DIAG_ISBB
argument_list|(
name|r
argument_list|)
condition|)
name|getBBReg
argument_list|(
name|mh
argument_list|,
name|HostCmd_ACT_GEN_READ
argument_list|,
name|r
operator|-
name|MWL_DIAG_BASE_BB
argument_list|,
name|dp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MWL_DIAG_ISRF
argument_list|(
name|r
argument_list|)
condition|)
name|getRFReg
argument_list|(
name|mh
argument_list|,
name|HostCmd_ACT_GEN_READ
argument_list|,
name|r
operator|-
name|MWL_DIAG_BASE_RF
argument_list|,
name|dp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|<
literal|0x1000
operator|||
name|r
operator|==
name|MACREG_REG_FW_PRESENT
condition|)
operator|*
name|dp
operator|=
name|RD4
argument_list|(
name|mh
argument_list|,
name|r
argument_list|)
expr_stmt|;
else|else
operator|*
name|dp
operator|=
literal|0xffffffff
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|r
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|space
operator|-=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|r
operator|<=
name|e
operator|&&
name|space
operator|>=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
do|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|dp
operator|-
operator|(
name|char
operator|*
operator|)
name|dstbuf
return|;
block|}
end_function

begin_function
name|int
name|mwl_hal_getdiagstate
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|int
name|request
parameter_list|,
specifier|const
name|void
modifier|*
name|args
parameter_list|,
name|uint32_t
name|argsize
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|,
name|uint32_t
modifier|*
name|resultsize
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|request
condition|)
block|{
case|case
name|MWL_DIAG_CMD_REVS
case|:
operator|*
name|result
operator|=
operator|&
name|mh
operator|->
name|mh_revs
expr_stmt|;
operator|*
name|resultsize
operator|=
sizeof|sizeof
argument_list|(
name|mh
operator|->
name|mh_revs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|MWL_DIAG_CMD_REGS
case|:
operator|*
name|resultsize
operator|=
name|mwl_hal_getregdump
argument_list|(
name|mh
argument_list|,
name|args
argument_list|,
operator|*
name|result
argument_list|,
operator|*
name|resultsize
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|MWL_DIAG_CMD_HOSTCMD
case|:
block|{
name|FWCmdHdr
modifier|*
name|pCmd
init|=
operator|(
name|FWCmdHdr
operator|*
operator|)
operator|&
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|0
index|]
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MWL_HAL_LOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pCmd
argument_list|,
name|args
argument_list|,
name|argsize
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mwlExecuteCmd
argument_list|(
name|mh
argument_list|,
name|le16toh
argument_list|(
name|pCmd
operator|->
name|Cmd
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
operator|(
operator|*
name|resultsize
operator|!=
literal|0
operator|)
condition|?
name|pCmd
else|:
name|NULL
expr_stmt|;
name|MWL_HAL_UNLOCK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|==
literal|0
operator|)
return|;
block|}
case|case
name|MWL_DIAG_CMD_FWLOAD
case|:
if|if
condition|(
name|mwl_hal_fwload
argument_list|(
name|mh0
argument_list|,
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"problem loading fw image\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Low level firmware cmd block handshake support.  */
end_comment

begin_function
specifier|static
name|void
name|mwlSendCmd
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|)
block|{
name|uint32_t
name|dummy
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_GEN_PTR
argument_list|,
name|mh
operator|->
name|mh_cmdaddr
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_H2A_INTERRUPT_EVENTS
argument_list|,
name|MACREG_H2ARIC_BIT_DOOR_BELL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwlWaitForCmdComplete
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|,
name|uint16_t
name|cmdCode
parameter_list|)
block|{
define|#
directive|define
name|MAX_WAIT_FW_COMPLETE_ITERATIONS
value|10000
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_WAIT_FW_COMPLETE_ITERATIONS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|0
index|]
operator|==
name|le16toh
argument_list|(
name|cmdCode
argument_list|)
condition|)
return|return
literal|1
return|;
name|DELAY
argument_list|(
literal|1
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
undef|#
directive|undef
name|MAX_WAIT_FW_COMPLETE_ITERATIONS
block|}
end_function

begin_function
specifier|static
name|int
name|mwlExecuteCmd
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|,
name|unsigned
name|short
name|cmd
parameter_list|)
block|{
name|MWL_HAL_LOCK_ASSERT
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mh
operator|->
name|mh_flags
operator|&
name|MHF_FWHANG
operator|)
operator|&&
operator|(
name|mh
operator|->
name|mh_debug
operator|&
name|MWL_HAL_DEBUG_IGNHANG
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MWLHAL_DEBUG
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"firmware hung, skipping cmd %s\n"
argument_list|,
name|mwlcmdname
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"firmware hung, skipping cmd 0x%x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|)
operator|==
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"%s: device not present!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
ifdef|#
directive|ifdef
name|MWLHAL_DEBUG
if|if
condition|(
name|mh
operator|->
name|mh_debug
operator|&
name|MWL_HAL_DEBUG_SENDCMD
condition|)
name|dumpresult
argument_list|(
name|mh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mwlSendCmd
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mwlWaitForCmdComplete
argument_list|(
name|mh
argument_list|,
literal|0x8000
operator||
name|cmd
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MWLHAL_DEBUG
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"timeout waiting for f/w cmd %s\n"
argument_list|,
name|mwlcmdname
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"timeout waiting for f/w cmd 0x%x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mh
operator|->
name|mh_flags
operator||=
name|MHF_FWHANG
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
name|bus_dmamap_sync
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MWLHAL_DEBUG
if|if
condition|(
name|mh
operator|->
name|mh_debug
operator|&
name|MWL_HAL_DEBUG_CMDDONE
condition|)
name|dumpresult
argument_list|(
name|mh
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Firmware download support.  */
end_comment

begin_define
define|#
directive|define
name|FW_DOWNLOAD_BLOCK_SIZE
value|256
end_define

begin_define
define|#
directive|define
name|FW_CHECK_USECS
value|(5*1000)
end_define

begin_comment
comment|/* 5ms */
end_comment

begin_define
define|#
directive|define
name|FW_MAX_NUM_CHECKS
value|200
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX read f/w from file */
end_comment

begin_include
include|#
directive|include
file|<dev/mwl/mwlbootfw.h>
end_include

begin_include
include|#
directive|include
file|<dev/mwl/mwl88W8363fw.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|mwlFwReset
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|)
block|{
if|if
condition|(
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|)
operator|==
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"%s: device not present!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_H2A_INTERRUPT_EVENTS
argument_list|,
name|ISR_RESET
argument_list|)
expr_stmt|;
name|mh
operator|->
name|mh_flags
operator|&=
operator|~
name|MHF_FWHANG
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwlTriggerPciCmd
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|)
block|{
name|uint32_t
name|dummy
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|mh
operator|->
name|mh_dmat
argument_list|,
name|mh
operator|->
name|mh_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_GEN_PTR
argument_list|,
name|mh
operator|->
name|mh_cmdaddr
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_H2A_INTERRUPT_EVENTS
argument_list|,
name|MACREG_H2ARIC_BIT_DOOR_BELL
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mwlWaitFor
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FW_MAX_NUM_CHECKS
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
name|FW_CHECK_USECS
argument_list|)
expr_stmt|;
if|if
condition|(
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|)
operator|==
name|val
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Firmware block xmit when talking to the boot-rom.  */
end_comment

begin_function
specifier|static
name|int
name|mwlSendBlock
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|,
name|int
name|bsize
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|dsize
parameter_list|)
block|{
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|0
index|]
operator|=
name|htole16
argument_list|(
name|HostCmd_CMD_CODE_DNLD
argument_list|)
expr_stmt|;
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|1
index|]
operator|=
name|htole16
argument_list|(
name|bsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|4
index|]
argument_list|,
name|data
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|mwlTriggerPciCmd
argument_list|(
name|mh
argument_list|)
expr_stmt|;
comment|/* XXX 2000 vs 200 */
if|if
condition|(
name|mwlWaitFor
argument_list|(
name|mh
argument_list|,
name|MACREG_INT_CODE_CMD_FINISHED
argument_list|)
condition|)
block|{
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"%s: timeout waiting for CMD_FINISHED, INT_CODE 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Firmware block xmit when talking to the 1st-stage loader.  */
end_comment

begin_function
specifier|static
name|int
name|mwlSendBlock2
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|dsize
parameter_list|)
block|{
name|memcpy
argument_list|(
operator|&
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|0
index|]
argument_list|,
name|data
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|mwlTriggerPciCmd
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|mwlWaitFor
argument_list|(
name|mh
argument_list|,
name|MACREG_INT_CODE_CMD_FINISHED
argument_list|)
condition|)
block|{
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"%s: timeout waiting for CMD_FINISHED, INT_CODE 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwlPokeSdramController
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|,
name|int
name|SDRAMSIZE_Addr
parameter_list|)
block|{
comment|/** Set up sdram controller for superflyv2 **/
name|WR4
argument_list|(
name|mh
argument_list|,
literal|0x00006014
argument_list|,
literal|0x33
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|mh
argument_list|,
literal|0x00006018
argument_list|,
literal|0xa3a2632
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|mh
argument_list|,
literal|0x00006010
argument_list|,
name|SDRAMSIZE_Addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mwl_hal_fwload
parameter_list|(
name|struct
name|mwl_hal
modifier|*
name|mh0
parameter_list|,
name|void
modifier|*
name|fwargs
parameter_list|)
block|{
name|struct
name|mwl_hal_priv
modifier|*
name|mh
init|=
name|MWLPRIV
argument_list|(
name|mh0
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fwname
init|=
literal|"mw88W8363fw"
decl_stmt|;
specifier|const
name|char
modifier|*
name|fwbootname
init|=
literal|"mwlboot"
decl_stmt|;
specifier|const
name|struct
name|firmware
modifier|*
name|fwboot
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
comment|/* XXX get from firmware header */
name|uint32_t
name|FwReadySignature
init|=
name|HostCmd_SOFTAP_FWRDY_SIGNATURE
decl_stmt|;
name|uint32_t
name|OpMode
init|=
name|HostCmd_SOFTAP_MODE
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|fp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|fmdata
decl_stmt|;
name|uint32_t
name|blocksize
decl_stmt|,
name|nbytes
decl_stmt|,
name|fmsize
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|ntries
decl_stmt|;
name|fw
operator|=
name|firmware_get
argument_list|(
name|fwname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"could not load firmware image %s\n"
argument_list|,
name|fwname
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|fmdata
operator|=
name|fw
operator|->
name|data
expr_stmt|;
name|fmsize
operator|=
name|fw
operator|->
name|datasize
expr_stmt|;
if|if
condition|(
name|fmsize
operator|<
literal|4
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"firmware image %s too small\n"
argument_list|,
name|fwname
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
if|if
condition|(
name|fmdata
index|[
literal|0
index|]
operator|==
literal|0x01
operator|&&
name|fmdata
index|[
literal|1
index|]
operator|==
literal|0x00
operator|&&
name|fmdata
index|[
literal|2
index|]
operator|==
literal|0x00
operator|&&
name|fmdata
index|[
literal|3
index|]
operator|==
literal|0x00
condition|)
block|{
comment|/* 		 * 2-stage load, get the boot firmware. 		 */
name|fwboot
operator|=
name|firmware_get
argument_list|(
name|fwbootname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwboot
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"could not load firmware image %s\n"
argument_list|,
name|fwbootname
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
block|}
else|else
name|fwboot
operator|=
name|NULL
expr_stmt|;
name|mwlFwReset
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_A2H_INTERRUPT_CLEAR_SEL
argument_list|,
name|MACREG_A2HRIC_BIT_MASK
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_A2H_INTERRUPT_CAUSE
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_A2H_INTERRUPT_MASK
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_A2H_INTERRUPT_STATUS_MASK
argument_list|,
name|MACREG_A2HRIC_BIT_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|->
name|mh_SDRAMSIZE_Addr
operator|!=
literal|0
condition|)
block|{
comment|/** Set up sdram controller for superflyv2 **/
name|mwlPokeSdramController
argument_list|(
name|mh
argument_list|,
name|mh
operator|->
name|mh_SDRAMSIZE_Addr
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"load %s firmware image (%u bytes)\n"
argument_list|,
name|fwname
argument_list|,
name|fmsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwboot
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Do 2-stage load.  The 1st stage loader is setup 		 * with the bootrom loader then we load the real 		 * image using a different handshake. With this 		 * mechanism the firmware is segmented into chunks 		 * that have a CRC.  If a chunk is incorrect we'll 		 * be told to retransmit. 		 */
comment|/* XXX assumes hlpimage fits in a block */
comment|/* NB: zero size block indicates download is finished */
if|if
condition|(
operator|!
name|mwlSendBlock
argument_list|(
name|mh
argument_list|,
name|fwboot
operator|->
name|datasize
argument_list|,
name|fwboot
operator|->
name|data
argument_list|,
name|fwboot
operator|->
name|datasize
argument_list|)
operator|||
operator|!
name|mwlSendBlock
argument_list|(
name|mh
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|DELAY
argument_list|(
literal|200
operator|*
name|FW_CHECK_USECS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|->
name|mh_SDRAMSIZE_Addr
operator|!=
literal|0
condition|)
block|{
comment|/** Set up sdram controller for superflyv2 **/
name|mwlPokeSdramController
argument_list|(
name|mh
argument_list|,
name|mh
operator|->
name|mh_SDRAMSIZE_Addr
argument_list|)
expr_stmt|;
block|}
name|nbytes
operator|=
name|ntries
operator|=
literal|0
expr_stmt|;
comment|/* NB: silence compiler */
for|for
control|(
name|fp
operator|=
name|fmdata
operator|,
name|ep
operator|=
name|fp
operator|+
name|fmsize
init|;
name|fp
operator|<
name|ep
condition|;
control|)
block|{
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|blocksize
operator|=
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_SCRATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocksize
operator|==
literal|0
condition|)
comment|/* download complete */
break|break;
if|if
condition|(
name|blocksize
operator|>
literal|0x00000c00
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|blocksize
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* block successfully downloaded, advance */
name|fp
operator|+=
name|nbytes
expr_stmt|;
name|ntries
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|++
name|ntries
operator|>
literal|2
condition|)
block|{
comment|/* 					 * Guard against f/w telling us to 					 * retry infinitely. 					 */
name|error
operator|=
name|ELOOP
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* clear NAK bit/flag */
name|blocksize
operator|&=
operator|~
literal|0x1
expr_stmt|;
block|}
if|if
condition|(
name|blocksize
operator|>
name|ep
operator|-
name|fp
condition|)
block|{
comment|/* XXX this should not happen, what to do? */
name|blocksize
operator|=
name|ep
operator|-
name|fp
expr_stmt|;
block|}
name|nbytes
operator|=
name|blocksize
expr_stmt|;
if|if
condition|(
operator|!
name|mwlSendBlock2
argument_list|(
name|mh
argument_list|,
name|fp
argument_list|,
name|nbytes
argument_list|)
condition|)
block|{
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|fp
operator|=
name|fmdata
operator|,
name|ep
operator|=
name|fp
operator|+
name|fmsize
init|;
name|fp
operator|<
name|ep
condition|;
control|)
block|{
name|nbytes
operator|=
name|ep
operator|-
name|fp
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
name|FW_DOWNLOAD_BLOCK_SIZE
condition|)
name|nbytes
operator|=
name|FW_DOWNLOAD_BLOCK_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|mwlSendBlock
argument_list|(
name|mh
argument_list|,
name|FW_DOWNLOAD_BLOCK_SIZE
argument_list|,
name|fp
argument_list|,
name|nbytes
argument_list|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|fp
operator|+=
name|nbytes
expr_stmt|;
block|}
block|}
comment|/* done with firmware... */
if|if
condition|(
name|fwboot
operator|!=
name|NULL
condition|)
name|firmware_put
argument_list|(
name|fwboot
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for firmware to startup; we monitor the 	 * INT_CODE register waiting for a signature to 	 * written back indicating it's ready to go. 	 */
name|mh
operator|->
name|mh_cmdbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * XXX WAR for mfg fw download 	 */
if|if
condition|(
name|OpMode
operator|!=
name|HostCmd_STA_MODE
condition|)
name|mwlTriggerPciCmd
argument_list|(
name|mh
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FW_MAX_NUM_CHECKS
condition|;
name|i
operator|++
control|)
block|{
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_GEN_PTR
argument_list|,
name|OpMode
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|FW_CHECK_USECS
argument_list|)
expr_stmt|;
if|if
condition|(
name|RD4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|)
operator|==
name|FwReadySignature
condition|)
block|{
name|WR4
argument_list|(
name|mh
argument_list|,
name|MACREG_REG_INT_CODE
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
return|return
name|mwlResetHalState
argument_list|(
name|mh
argument_list|)
return|;
block|}
block|}
return|return
name|ETIMEDOUT
return|;
name|bad
label|:
name|mwlFwReset
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|bad2
label|:
comment|/* done with firmware... */
if|if
condition|(
name|fwboot
operator|!=
name|NULL
condition|)
name|firmware_put
argument_list|(
name|fwboot
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MWLHAL_DEBUG
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mwlcmdname
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|12
index|]
decl_stmt|;
define|#
directive|define
name|CMD
parameter_list|(
name|x
parameter_list|)
value|case HostCmd_CMD_##x: return #x
switch|switch
condition|(
name|cmd
condition|)
block|{
name|CMD
argument_list|(
name|CODE_DNLD
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|GET_HW_SPEC
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_HW_SPEC
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|MAC_MULTICAST_ADR
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
literal|802_11_GET_STAT
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|MAC_REG_ACCESS
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|BBP_REG_ACCESS
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|RF_REG_ACCESS
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
literal|802_11_RADIO_CONTROL
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
literal|802_11_RF_TX_POWER
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
literal|802_11_RF_ANTENNA
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_BEACON
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_RF_CHANNEL
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_AID
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_INFRA_MODE
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_G_PROTECT_FLAG
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
literal|802_11_RTS_THSD
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
literal|802_11_SET_SLOT
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_EDCA_PARAMS
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
literal|802_11H_DETECT_RADAR
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_WMM_MODE
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|HT_GUARD_INTERVAL
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_FIXED_RATE
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_LINKADAPT_CS_MODE
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_MAC_ADDR
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_RATE_ADAPT_MODE
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|BSS_START
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_NEW_STN
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_KEEP_ALIVE
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_APMODE
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_SWITCH_CHANNEL
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|UPDATE_ENCRYPTION
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|BASTREAM
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_RIFS
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_N_PROTECT_FLAG
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_N_PROTECT_OPMODE
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_OPTIMIZATION_LEVEL
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|GET_CALTABLE
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_MIMOPSHT
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|GET_BEACON
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_REGION_CODE
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_POWERSAVESTATION
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|SET_TIM
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|GET_TIM
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|GET_SEQNO
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|DWDS_ENABLE
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|AMPDU_RETRY_RATEDROP_MODE
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|CFEND_ENABLE
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"0x%x"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
undef|#
directive|undef
name|CMD
block|}
end_function

begin_function
specifier|static
name|void
name|dumpresult
parameter_list|(
name|struct
name|mwl_hal_priv
modifier|*
name|mh
parameter_list|,
name|int
name|showresult
parameter_list|)
block|{
specifier|const
name|FWCmdHdr
modifier|*
name|h
init|=
operator|(
specifier|const
name|FWCmdHdr
operator|*
operator|)
name|mh
operator|->
name|mh_cmdbuf
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|h
operator|->
name|Length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MWL_MBSS_SUPPORT
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"Cmd %s Length %d SeqNum %d MacId %d"
argument_list|,
name|mwlcmdname
argument_list|(
name|le16toh
argument_list|(
name|h
operator|->
name|Cmd
argument_list|)
operator|&
operator|~
literal|0x8000
argument_list|)
argument_list|,
name|len
argument_list|,
name|h
operator|->
name|SeqNum
argument_list|,
name|h
operator|->
name|MacId
argument_list|)
expr_stmt|;
else|#
directive|else
name|device_printf
argument_list|(
name|mh
operator|->
name|mh_dev
argument_list|,
literal|"Cmd %s Length %d SeqNum %d"
argument_list|,
name|mwlcmdname
argument_list|(
name|le16toh
argument_list|(
name|h
operator|->
name|Cmd
argument_list|)
operator|&
operator|~
literal|0x8000
argument_list|)
argument_list|,
name|len
argument_list|,
name|le16toh
argument_list|(
name|h
operator|->
name|SeqNum
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|showresult
condition|)
block|{
specifier|const
name|char
modifier|*
name|results
index|[]
init|=
block|{
literal|"OK"
block|,
literal|"ERROR"
block|,
literal|"NOT_SUPPORT"
block|,
literal|"PENDING"
block|,
literal|"BUSY"
block|,
literal|"PARTIAL_DATA"
block|}
decl_stmt|;
name|int
name|result
init|=
name|le16toh
argument_list|(
name|h
operator|->
name|Result
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|<=
name|HostCmd_RESULT_PARTIAL_DATA
condition|)
name|printf
argument_list|(
literal|" Result %s"
argument_list|,
name|results
index|[
name|result
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" Result %d"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n%02x"
argument_list|,
name|cp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|cp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MWLHAL_DEBUG */
end_comment

end_unit

