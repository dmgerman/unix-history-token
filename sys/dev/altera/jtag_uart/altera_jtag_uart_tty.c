begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011-2012 Robert N. M. Watson  * All rights reserved.  *  * This software was developed by SRI International and the University of  * Cambridge Computer Laboratory under DARPA/AFRL contract (FA8750-10-C-0237)  * ("CTSRD"), as part of the DARPA CRASH research programme.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/altera/jtag_uart/altera_jtag_uart.h>
end_include

begin_comment
comment|/*  * If one of the Altera JTAG UARTs is currently the system console, register  * it here.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|altera_jtag_uart_softc
modifier|*
name|aju_cons_sc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tsw_outwakeup_t
name|aju_outwakeup
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|aju_ac_callout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aju_io_callout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ttydevsw
name|aju_ttydevsw
init|=
block|{
operator|.
name|tsw_flags
operator|=
name|TF_NOPREFIX
block|,
operator|.
name|tsw_outwakeup
operator|=
name|aju_outwakeup
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * When polling for the AC bit, the number of times we have to not see it  * before assuming JTAG has disappeared on us.  By default, two seconds.  */
end_comment

begin_define
define|#
directive|define
name|AJU_JTAG_MAXMISS
value|10
end_define

begin_comment
comment|/*  * Polling intervals for input/output and JTAG connection events.  */
end_comment

begin_define
define|#
directive|define
name|AJU_IO_POLLINTERVAL
value|(hz/100)
end_define

begin_define
define|#
directive|define
name|AJU_AC_POLLINTERVAL
value|(hz/5)
end_define

begin_comment
comment|/*  * Low-level read and write register routines; the Altera UART is little  * endian, so we byte swap 32-bit reads and writes.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|aju_data_read
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|le32toh
argument_list|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|ajus_mem_res
argument_list|,
name|ALTERA_JTAG_UART_DATA_OFF
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|aju_data_write
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|v
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|ajus_mem_res
argument_list|,
name|ALTERA_JTAG_UART_DATA_OFF
argument_list|,
name|htole32
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|aju_control_read
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|le32toh
argument_list|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|ajus_mem_res
argument_list|,
name|ALTERA_JTAG_UART_CONTROL_OFF
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|aju_control_write
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|v
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|ajus_mem_res
argument_list|,
name|ALTERA_JTAG_UART_CONTROL_OFF
argument_list|,
name|htole32
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Slightly higher-level routines aware of buffering and flow control.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|aju_writable
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|aju_control_read
argument_list|(
name|sc
argument_list|)
operator|&
name|ALTERA_JTAG_UART_CONTROL_WSPACE
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|aju_readable
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|AJU_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sc
operator|->
name|ajus_buffer_validp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|v
operator|=
name|aju_data_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|ALTERA_JTAG_UART_DATA_RVALID
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|sc
operator|->
name|ajus_buffer_validp
operator|=
literal|1
expr_stmt|;
operator|*
name|sc
operator|->
name|ajus_buffer_datap
operator|=
operator|(
name|v
operator|&
name|ALTERA_JTAG_UART_DATA_DATA
operator|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|aju_read
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|AJU_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|aju_readable
argument_list|(
name|sc
argument_list|)
condition|)
empty_stmt|;
operator|*
name|sc
operator|->
name|ajus_buffer_validp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|*
name|sc
operator|->
name|ajus_buffer_datap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines for enabling and disabling interrupts for read and write.  */
end_comment

begin_function
specifier|static
name|void
name|aju_intr_readable_enable
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|AJU_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|aju_control_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator||=
name|ALTERA_JTAG_UART_CONTROL_RE
expr_stmt|;
name|aju_control_write
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aju_intr_writable_enable
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|AJU_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|aju_control_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator||=
name|ALTERA_JTAG_UART_CONTROL_WE
expr_stmt|;
name|aju_control_write
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aju_intr_writable_disable
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|AJU_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|aju_control_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|~
name|ALTERA_JTAG_UART_CONTROL_WE
expr_stmt|;
name|aju_control_write
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aju_intr_disable
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|AJU_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|aju_control_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|~
operator|(
name|ALTERA_JTAG_UART_CONTROL_RE
operator||
name|ALTERA_JTAG_UART_CONTROL_WE
operator|)
expr_stmt|;
name|aju_control_write
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The actual work of checking for, and handling, available reads.  This is  * used in both polled and interrupt-driven modes, as JTAG UARTs may be hooked  * up with, or without, IRQs allocated.  */
end_comment

begin_function
specifier|static
name|void
name|aju_handle_input
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|AJU_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|aju_readable
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|c
operator|=
name|aju_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AJU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|sc
operator|->
name|ajus_flags
operator|&
name|ALTERA_JTAG_UART_FLAG_CONSOLE
condition|)
name|kdb_alt_break
argument_list|(
name|c
argument_list|,
operator|&
name|sc
operator|->
name|ajus_alt_break_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ttydisc_rint
argument_list|(
name|tp
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AJU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|AJU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ttydisc_rint_done
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|AJU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send output to the UART until either there's none left to send, or we run  * out of room and need to await an interrupt so that we can start sending  * again.  *  * XXXRW: It would be nice to query WSPACE at the beginning and write to the  * FIFO in bugger chunks.  */
end_comment

begin_function
specifier|static
name|void
name|aju_handle_output
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|uint8_t
name|ch
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|AJU_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AJU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|ttydisc_getc_poll
argument_list|(
name|tp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|AJU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|aju_control_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|ALTERA_JTAG_UART_CONTROL_WSPACE
operator|)
operator|!=
literal|0
condition|)
block|{
name|AJU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttydisc_getc
argument_list|(
name|tp
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: ttydisc_getc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|AJU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 			 * XXXRW: There is a slight race here in which we test 			 * for writability, drop the lock, get the character 			 * from the tty layer, re-acquire the lock, and then 			 * write.  It's possible for other code -- 			 * specifically, the low-level console -- to have 			 * written in the mean time, which might mean that 			 * there is no longer space.  The BERI memory bus will 			 * cause this write to block, wedging the processor 			 * until space is available -- which could be a while 			 * if JTAG is not attached! 			 * 			 * The 'easy' fix is to drop the character if WSPACE 			 * has become unset.  Not sure what the 'hard' fix is. 			 */
name|aju_data_write
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If JTAG is not present, then we will drop this 			 * character instead of perhaps scheduling an 			 * interrupt to let us know when there is buffer 			 * space.  Otherwise we might get a write interrupt 			 * later even though we aren't interested in sending 			 * anymore.  Loop to drain TTY-layer buffer. 			 */
if|if
condition|(
operator|*
name|sc
operator|->
name|ajus_jtag_presentp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ttydisc_getc
argument_list|(
name|tp
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: ttydisc_getc 2"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|AJU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sc
operator|->
name|ajus_irq_res
operator|!=
name|NULL
condition|)
name|aju_intr_writable_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|AJU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|AJU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aju_intr_writable_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aju_outwakeup
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|AJU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aju_handle_output
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|AJU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aju_io_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|sc
operator|->
name|ajus_ttyp
decl_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|AJU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * It would be convenient if we could share code with aju_intr() here 	 * by testing the control register for ALTERA_JTAG_UART_CONTROL_RI and 	 * ALTERA_JTAG_UART_CONTROL_WI.  Unfortunately, it's not clear that 	 * this is supported, so do all the work to poll for both input and 	 * output. 	 */
name|aju_handle_input
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|aju_handle_output
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* 	 * Reschedule next poll attempt.  There's some argument that we should 	 * do adaptive polling based on the expectation of I/O: is something 	 * pending in the output buffer, or have we recently had input, but we 	 * don't. 	 */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|ajus_io_callout
argument_list|,
name|AJU_IO_POLLINTERVAL
argument_list|,
name|aju_io_callout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|AJU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aju_ac_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|sc
operator|->
name|ajus_ttyp
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|AJU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|aju_control_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|ALTERA_JTAG_UART_CONTROL_AC
condition|)
block|{
name|v
operator|&=
operator|~
name|ALTERA_JTAG_UART_CONTROL_AC
expr_stmt|;
name|aju_control_write
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sc
operator|->
name|ajus_jtag_presentp
operator|==
literal|0
condition|)
block|{
operator|*
name|sc
operator|->
name|ajus_jtag_missedp
operator|=
literal|0
expr_stmt|;
operator|*
name|sc
operator|->
name|ajus_jtag_presentp
operator|=
literal|1
expr_stmt|;
name|aju_handle_output
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|sc
operator|->
name|ajus_jtag_presentp
operator|!=
literal|0
condition|)
block|{
operator|(
operator|*
name|sc
operator|->
name|ajus_jtag_missedp
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|sc
operator|->
name|ajus_jtag_missedp
operator|>=
name|AJU_JTAG_MAXMISS
condition|)
block|{
operator|*
name|sc
operator|->
name|ajus_jtag_presentp
operator|=
literal|0
expr_stmt|;
name|aju_handle_output
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|ajus_ac_callout
argument_list|,
name|AJU_AC_POLLINTERVAL
argument_list|,
name|aju_ac_callout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|AJU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aju_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|sc
operator|->
name|ajus_ttyp
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|AJU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|aju_control_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|ALTERA_JTAG_UART_CONTROL_RI
condition|)
name|aju_handle_input
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|ALTERA_JTAG_UART_CONTROL_WI
condition|)
name|aju_handle_output
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|AJU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|altera_jtag_uart_attach
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|AJU_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRW: Currently, we detect the console solely based on it using a 	 * reserved address, and borrow console-level locks and buffer if so. 	 * Is there a better way? 	 */
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ajus_mem_res
argument_list|)
operator|==
name|BERI_UART_BASE
condition|)
block|{
name|sc
operator|->
name|ajus_lockp
operator|=
operator|&
name|aju_cons_lock
expr_stmt|;
name|sc
operator|->
name|ajus_buffer_validp
operator|=
operator|&
name|aju_cons_buffer_valid
expr_stmt|;
name|sc
operator|->
name|ajus_buffer_datap
operator|=
operator|&
name|aju_cons_buffer_data
expr_stmt|;
name|sc
operator|->
name|ajus_jtag_presentp
operator|=
operator|&
name|aju_cons_jtag_present
expr_stmt|;
name|sc
operator|->
name|ajus_jtag_missedp
operator|=
operator|&
name|aju_cons_jtag_missed
expr_stmt|;
name|sc
operator|->
name|ajus_flags
operator||=
name|ALTERA_JTAG_UART_FLAG_CONSOLE
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|ajus_lockp
operator|=
operator|&
name|sc
operator|->
name|ajus_lock
expr_stmt|;
name|sc
operator|->
name|ajus_buffer_validp
operator|=
operator|&
name|sc
operator|->
name|ajus_buffer_valid
expr_stmt|;
name|sc
operator|->
name|ajus_buffer_datap
operator|=
operator|&
name|sc
operator|->
name|ajus_buffer_data
expr_stmt|;
name|sc
operator|->
name|ajus_jtag_presentp
operator|=
operator|&
name|sc
operator|->
name|ajus_jtag_present
expr_stmt|;
name|sc
operator|->
name|ajus_jtag_missedp
operator|=
operator|&
name|sc
operator|->
name|ajus_jtag_missed
expr_stmt|;
block|}
comment|/* 	 * Disable interrupts regardless of whether or not we plan to use 	 * them.  We will register an interrupt handler now if they will be 	 * used, but not re-enable intil later once the remainder of the tty 	 * layer is properly initialised, as we're not ready for input yet. 	 */
name|AJU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aju_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AJU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ajus_irq_res
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|ajus_dev
argument_list|,
name|sc
operator|->
name|ajus_irq_res
argument_list|,
name|INTR_ENTROPY
operator||
name|INTR_TYPE_TTY
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|aju_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ajus_irq_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|ajus_dev
argument_list|,
literal|"could not activate interrupt\n"
argument_list|)
expr_stmt|;
name|AJU_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|tp
operator|=
name|sc
operator|->
name|ajus_ttyp
operator|=
name|tty_alloc
argument_list|(
operator|&
name|aju_ttydevsw
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ajus_flags
operator|&
name|ALTERA_JTAG_UART_FLAG_CONSOLE
condition|)
block|{
name|aju_cons_sc
operator|=
name|sc
expr_stmt|;
name|tty_init_console
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|tty_makedev
argument_list|(
name|tp
argument_list|,
name|NULL
argument_list|,
literal|"%s%d"
argument_list|,
name|AJU_TTYNAME
argument_list|,
name|sc
operator|->
name|ajus_unit
argument_list|)
expr_stmt|;
comment|/* 	 * If we will be using interrupts, enable them now; otherwise, start 	 * polling.  From this point onwards, input can arrive. 	 */
if|if
condition|(
name|sc
operator|->
name|ajus_irq_res
operator|!=
name|NULL
condition|)
block|{
name|AJU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aju_intr_readable_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AJU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|ajus_io_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|ajus_io_callout
argument_list|,
name|AJU_IO_POLLINTERVAL
argument_list|,
name|aju_io_callout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|ajus_ac_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|ajus_ac_callout
argument_list|,
name|AJU_AC_POLLINTERVAL
argument_list|,
name|aju_ac_callout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|altera_jtag_uart_detach
parameter_list|(
name|struct
name|altera_jtag_uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|sc
operator|->
name|ajus_ttyp
decl_stmt|;
comment|/* 	 * If we're using interrupts, disable and release the interrupt 	 * handler now.  Otherwise drain the polling timeout. 	 */
if|if
condition|(
name|sc
operator|->
name|ajus_irq_res
operator|!=
name|NULL
condition|)
block|{
name|AJU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|aju_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AJU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|ajus_dev
argument_list|,
name|sc
operator|->
name|ajus_irq_res
argument_list|,
name|sc
operator|->
name|ajus_irq_cookie
argument_list|)
expr_stmt|;
block|}
else|else
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|ajus_io_callout
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|ajus_ac_callout
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ajus_flags
operator|&
name|ALTERA_JTAG_UART_FLAG_CONSOLE
condition|)
name|aju_cons_sc
operator|=
name|NULL
expr_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tty_rel_gone
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|AJU_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

