begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Robert N. M. Watson  * All rights reserved.  *  * This software was developed by SRI International and the University of  * Cambridge Computer Laboratory under DARPA/AFRL contract (FA8750-10-C-0237)  * ("CTSRD"), as part of the DARPA CRASH research programme.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_altera_sdcard.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_disk.h>
end_include

begin_include
include|#
directive|include
file|<dev/altera/sdcard/altera_sdcard.h>
end_include

begin_comment
comment|/*  * Device driver for the Altera University Program Secure Data Card IP Core,  * as described in the similarly named SOPC Builder IP Core specification.  * This soft core is not a full SD host controller interface (SDHCI) but  * instead provides a set of memory mapped registers and memory buffer that  * mildly abstract the SD Card protocol, but without providing DMA or  * interrupts.  However, it does hide the details of voltage and  * communications negotiation.  This driver implements disk(9), but due to the  * lack of interrupt support, must rely on timer-driven polling to determine  * when I/Os have completed.  *  * TODO:  *  * 1. Implement DISKFLAG_CANDELETE / SD Card sector erase support.  * 2. Implement d_ident from SD Card CID serial number field.  * 3. Handle read-only SD Cards.  * 4. Tune timeouts based on real-world SD Card speeds.  */
end_comment

begin_decl_stmt
name|devclass_t
name|altera_sdcard_devclass
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|altera_sdcard_attach
parameter_list|(
name|struct
name|altera_sdcard_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ALTERA_SDCARD_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ALTERA_SDCARD_CONDVAR_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|as_disk
operator|=
name|NULL
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|as_bioq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|as_currentbio
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|as_state
operator|=
name|ALTERA_SDCARD_STATE_NOCARD
expr_stmt|;
name|sc
operator|->
name|as_taskqueue
operator|=
name|taskqueue_create
argument_list|(
literal|"altera_sdcardc taskq"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|as_taskqueue
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|as_taskqueue
argument_list|,
literal|1
argument_list|,
name|PI_DISK
argument_list|,
literal|"altera_sdcardc%d taskqueue"
argument_list|,
name|sc
operator|->
name|as_unit
argument_list|)
expr_stmt|;
name|TIMEOUT_TASK_INIT
argument_list|(
name|sc
operator|->
name|as_taskqueue
argument_list|,
operator|&
name|sc
operator|->
name|as_task
argument_list|,
literal|0
argument_list|,
name|altera_sdcard_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Kick off timer-driven processing with a manual poll so that we 	 * synchronously detect an already-inserted SD Card during the boot or 	 * other driver attach point. 	 */
name|altera_sdcard_task
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|altera_sdcard_detach
parameter_list|(
name|struct
name|altera_sdcard_softc
modifier|*
name|sc
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|as_taskqueue
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: taskqueue not present"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Winding down the driver on detach is a bit complex.  Update the 	 * flags to indicate that a detach has been requested, and then wait 	 * for in-progress I/O to wind down before continuing. 	 */
name|ALTERA_SDCARD_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|as_flags
operator||=
name|ALTERA_SDCARD_FLAG_DETACHREQ
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|as_state
operator|!=
name|ALTERA_SDCARD_STATE_DETACHED
condition|)
name|ALTERA_SDCARD_CONDVAR_WAIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ALTERA_SDCARD_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Now wait for the possibly still executing taskqueue to drain.  In 	 * principle no more events will be scheduled as we've transitioned to 	 * a detached state, but there might still be a request in execution. 	 */
while|while
condition|(
name|taskqueue_cancel_timeout
argument_list|(
name|sc
operator|->
name|as_taskqueue
argument_list|,
operator|&
name|sc
operator|->
name|as_task
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain_timeout
argument_list|(
name|sc
operator|->
name|as_taskqueue
argument_list|,
operator|&
name|sc
operator|->
name|as_task
argument_list|)
expr_stmt|;
comment|/* 	 * Simulate a disk removal if one is present to deal with any pending 	 * or queued I/O. 	 */
if|if
condition|(
name|sc
operator|->
name|as_disk
operator|!=
name|NULL
condition|)
name|altera_sdcard_disk_remove
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|as_bioq
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: non-empty bioq"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Free any remaining allocated resources. 	 */
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|as_taskqueue
argument_list|)
expr_stmt|;
name|sc
operator|->
name|as_taskqueue
operator|=
name|NULL
expr_stmt|;
name|ALTERA_SDCARD_CONDVAR_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ALTERA_SDCARD_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up and start the next I/O.  Transition to the I/O state, but allow the  * caller to schedule the next timeout, as this may be called either from an  * initial attach context, or from the task queue, which requires different  * behaviour.  */
end_comment

begin_function
specifier|static
name|void
name|altera_sdcard_nextio
parameter_list|(
name|struct
name|altera_sdcard_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|ALTERA_SDCARD_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|as_currentbio
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: bio already active"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|sc
operator|->
name|as_bioq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: bioq empty"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|altera_sdcard_io_start
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|as_state
operator|=
name|ALTERA_SDCARD_STATE_IO
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|altera_sdcard_task_nocard
parameter_list|(
name|struct
name|altera_sdcard_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ALTERA_SDCARD_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Handle device driver detach. 	 */
if|if
condition|(
name|sc
operator|->
name|as_flags
operator|&
name|ALTERA_SDCARD_FLAG_DETACHREQ
condition|)
block|{
name|sc
operator|->
name|as_state
operator|=
name|ALTERA_SDCARD_STATE_DETACHED
expr_stmt|;
return|return;
block|}
comment|/* 	 * If there is no card insertion, remain in NOCARD. 	 */
if|if
condition|(
operator|!
operator|(
name|altera_sdcard_read_asr
argument_list|(
name|sc
argument_list|)
operator|&
name|ALTERA_SDCARD_ASR_CARDPRESENT
operator|)
condition|)
return|return;
comment|/* 	 * Read the CSD -- it may contain values that the driver can't handle, 	 * either because of an unsupported version/feature, or because the 	 * card is misbehaving.  This triggers a transition to 	 * ALTERA_SDCARD_STATE_BADCARD.  We rely on the CSD read to print a 	 * banner about how the card is problematic, since it has more 	 * information.  The bad card state allows us to print that banner 	 * once rather than each time we notice the card is there, and still 	 * bad. 	 */
if|if
condition|(
name|altera_sdcard_read_csd
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|as_state
operator|=
name|ALTERA_SDCARD_STATE_BADCARD
expr_stmt|;
return|return;
block|}
comment|/* 	 * Process card insertion and upgrade to the IDLE state. 	 */
name|altera_sdcard_disk_insert
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|as_state
operator|=
name|ALTERA_SDCARD_STATE_IDLE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|altera_sdcard_task_badcard
parameter_list|(
name|struct
name|altera_sdcard_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ALTERA_SDCARD_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Handle device driver detach. 	 */
if|if
condition|(
name|sc
operator|->
name|as_flags
operator|&
name|ALTERA_SDCARD_FLAG_DETACHREQ
condition|)
block|{
name|sc
operator|->
name|as_state
operator|=
name|ALTERA_SDCARD_STATE_DETACHED
expr_stmt|;
return|return;
block|}
comment|/* 	 * Handle safe card removal -- no teardown is required, just a state 	 * transition. 	 */
if|if
condition|(
operator|!
operator|(
name|altera_sdcard_read_asr
argument_list|(
name|sc
argument_list|)
operator|&
name|ALTERA_SDCARD_ASR_CARDPRESENT
operator|)
condition|)
name|sc
operator|->
name|as_state
operator|=
name|ALTERA_SDCARD_STATE_NOCARD
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|altera_sdcard_task_idle
parameter_list|(
name|struct
name|altera_sdcard_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ALTERA_SDCARD_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Handle device driver detach. 	 */
if|if
condition|(
name|sc
operator|->
name|as_flags
operator|&
name|ALTERA_SDCARD_FLAG_DETACHREQ
condition|)
block|{
name|sc
operator|->
name|as_state
operator|=
name|ALTERA_SDCARD_STATE_DETACHED
expr_stmt|;
return|return;
block|}
comment|/* 	 * Handle safe card removal. 	 */
if|if
condition|(
operator|!
operator|(
name|altera_sdcard_read_asr
argument_list|(
name|sc
argument_list|)
operator|&
name|ALTERA_SDCARD_ASR_CARDPRESENT
operator|)
condition|)
block|{
name|altera_sdcard_disk_remove
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|as_state
operator|=
name|ALTERA_SDCARD_STATE_NOCARD
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|altera_sdcard_task_io
parameter_list|(
name|struct
name|altera_sdcard_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|asr
decl_stmt|;
name|ALTERA_SDCARD_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|as_currentbio
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no current I/O"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTERA_SDCARD_FAST_SIM
name|recheck
label|:
endif|#
directive|endif
name|asr
operator|=
name|altera_sdcard_read_asr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Check for unexpected card removal during an I/O. 	 */
if|if
condition|(
operator|!
operator|(
name|asr
operator|&
name|ALTERA_SDCARD_ASR_CARDPRESENT
operator|)
condition|)
block|{
name|altera_sdcard_disk_remove
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|as_flags
operator|&
name|ALTERA_SDCARD_FLAG_DETACHREQ
condition|)
name|sc
operator|->
name|as_state
operator|=
name|ALTERA_SDCARD_STATE_DETACHED
expr_stmt|;
else|else
name|sc
operator|->
name|as_state
operator|=
name|ALTERA_SDCARD_STATE_NOCARD
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the I/O isn't complete, remain in the IO state without further 	 * action, even if DETACHREQ is in flight. 	 */
if|if
condition|(
name|asr
operator|&
name|ALTERA_SDCARD_ASR_CMDINPROGRESS
condition|)
return|return;
comment|/* 	 * Handle various forms of I/O completion, successful and otherwise. 	 * The I/O layer may restart the transaction if an error occurred, in 	 * which case remain in the IO state and reschedule. 	 */
if|if
condition|(
operator|!
name|altera_sdcard_io_complete
argument_list|(
name|sc
argument_list|,
name|asr
argument_list|)
condition|)
return|return;
comment|/* 	 * Now that I/O is complete, process detach requests in preference to 	 * starting new I/O. 	 */
if|if
condition|(
name|sc
operator|->
name|as_flags
operator|&
name|ALTERA_SDCARD_FLAG_DETACHREQ
condition|)
block|{
name|sc
operator|->
name|as_state
operator|=
name|ALTERA_SDCARD_STATE_DETACHED
expr_stmt|;
return|return;
block|}
comment|/* 	 * Finally, either start the next I/O or transition to the IDLE state. 	 */
if|if
condition|(
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|as_bioq
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|altera_sdcard_nextio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTERA_SDCARD_FAST_SIM
goto|goto
name|recheck
goto|;
endif|#
directive|endif
block|}
else|else
name|sc
operator|->
name|as_state
operator|=
name|ALTERA_SDCARD_STATE_IDLE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|altera_sdcard_task_rechedule
parameter_list|(
name|struct
name|altera_sdcard_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|interval
decl_stmt|;
comment|/* 	 * Reschedule based on new state.  Or not, if detaching the device 	 * driver.  Treat a bad card as though it were no card at all. 	 */
switch|switch
condition|(
name|sc
operator|->
name|as_state
condition|)
block|{
case|case
name|ALTERA_SDCARD_STATE_NOCARD
case|:
case|case
name|ALTERA_SDCARD_STATE_BADCARD
case|:
name|interval
operator|=
name|ALTERA_SDCARD_TIMEOUT_NOCARD
expr_stmt|;
break|break;
case|case
name|ALTERA_SDCARD_STATE_IDLE
case|:
name|interval
operator|=
name|ALTERA_SDCARD_TIMEOUT_IDLE
expr_stmt|;
break|break;
case|case
name|ALTERA_SDCARD_STATE_IO
case|:
if|if
condition|(
name|sc
operator|->
name|as_flags
operator|&
name|ALTERA_SDCARD_FLAG_IOERROR
condition|)
name|interval
operator|=
name|ALTERA_SDCARD_TIMEOUT_IOERROR
expr_stmt|;
else|else
name|interval
operator|=
name|ALTERA_SDCARD_TIMEOUT_IO
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: invalid exit state %d"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|as_state
argument_list|)
expr_stmt|;
block|}
name|taskqueue_enqueue_timeout
argument_list|(
name|sc
operator|->
name|as_taskqueue
argument_list|,
operator|&
name|sc
operator|->
name|as_task
argument_list|,
name|interval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Because the Altera SD Card IP Core doesn't support interrupts, we do all  * asynchronous work from a timeout.  Poll at two different rates -- an  * infrequent check for card insertion status changes, and a frequent one for  * I/O completion.  The task should never start in DETACHED, as that would  * imply that a previous instance failed to cancel rather than reschedule.  */
end_comment

begin_function
name|void
name|altera_sdcard_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|altera_sdcard_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|as_state
operator|!=
name|ALTERA_SDCARD_STATE_DETACHED
argument_list|,
operator|(
literal|"%s: already in detached"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ALTERA_SDCARD_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|as_state
condition|)
block|{
case|case
name|ALTERA_SDCARD_STATE_NOCARD
case|:
name|altera_sdcard_task_nocard
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALTERA_SDCARD_STATE_BADCARD
case|:
name|altera_sdcard_task_badcard
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALTERA_SDCARD_STATE_IDLE
case|:
name|altera_sdcard_task_idle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALTERA_SDCARD_STATE_IO
case|:
name|altera_sdcard_task_io
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: invalid enter state %d"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|as_state
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we have transitioned to DETACHED, signal the detach thread and 	 * cancel the timeout-driven task.  Otherwise reschedule on an 	 * appropriate timeout. 	 */
if|if
condition|(
name|sc
operator|->
name|as_state
operator|==
name|ALTERA_SDCARD_STATE_DETACHED
condition|)
name|ALTERA_SDCARD_CONDVAR_SIGNAL
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|altera_sdcard_task_rechedule
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ALTERA_SDCARD_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|altera_sdcard_start
parameter_list|(
name|struct
name|altera_sdcard_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ALTERA_SDCARD_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|as_state
operator|==
name|ALTERA_SDCARD_STATE_IDLE
argument_list|,
operator|(
literal|"%s: starting when not IDLE"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|taskqueue_cancel_timeout
argument_list|(
name|sc
operator|->
name|as_taskqueue
argument_list|,
operator|&
name|sc
operator|->
name|as_task
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|altera_sdcard_nextio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTERA_SDCARD_FAST_SIM
name|altera_sdcard_task_io
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|altera_sdcard_task_rechedule
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

