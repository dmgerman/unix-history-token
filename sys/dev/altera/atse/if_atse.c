begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012,2013 Bjoern A. Zeeb  * All rights reserved.  *  * This software was developed by SRI International and the University of  * Cambridge Computer Laboratory under DARPA/AFRL contract (FA8750-11-C-0249)  * ("MRC2"), as part of the DARPA MRC research programme.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Altera Triple-Speed Ethernet MegaCore, Function User Guide  * UG-01008-3.0, Software Version: 12.0, June 2012.  * Available at the time of writing at:  * http://www.altera.com/literature/ug/ug_ethernet.pdf  *  * We are using an Marvell E1111 (Alaska) PHY on the DE4.  See mii/e1000phy.c.  */
end_comment

begin_comment
comment|/*  * XXX-BZ NOTES:  * - ifOutBroadcastPkts are only counted if both ether dst and src are all-1s;  *   seems an IP core bug, they count ether broadcasts as multicast.  Is this  *   still the case?  * - figure out why the TX FIFO fill status and intr did not work as expected.  * - test 100Mbit/s and 10Mbit/s  * - blacklist the one special factory programmed ethernet address (for now  *   hardcoded, later from loader?)  * - resolve all XXX, left as reminders to shake out details later  * - Jumbo frame support  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/altera/atse/if_atsereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/altera/atse/a_api.h>
end_include

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|atse
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|atse
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ATSE_WATCHDOG_TIME
value|5
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_decl_stmt
specifier|static
name|poll_handler_t
name|atse_poll
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX once we'd do parallel attach, we need a global lock for this. */
end_comment

begin_define
define|#
directive|define
name|ATSE_ETHERNET_OPTION_BITS_UNDEF
value|0
end_define

begin_define
define|#
directive|define
name|ATSE_ETHERNET_OPTION_BITS_READ
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|atse_ethernet_option_bits_flag
init|=
name|ATSE_ETHERNET_OPTION_BITS_UNDEF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|atse_ethernet_option_bits
index|[
name|ALTERA_ETHERNET_OPTION_BITS_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Softc and critical resource locking.  */
end_comment

begin_define
define|#
directive|define
name|ATSE_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->atse_mtx)
end_define

begin_define
define|#
directive|define
name|ATSE_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->atse_mtx)
end_define

begin_define
define|#
directive|define
name|ATSE_LOCK_ASSERT
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&(_sc)->atse_mtx, MA_OWNED)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|format
parameter_list|,
modifier|...
parameter_list|)
value|printf(format, __VA_ARGS__)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|format
parameter_list|,
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* a_api.c functions; factor out? */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|a_onchip_fifo_mem_core_write
parameter_list|(
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|uint32_t
name|off
parameter_list|,
name|uint32_t
name|val4
parameter_list|,
specifier|const
name|char
modifier|*
name|desc
parameter_list|,
specifier|const
name|char
modifier|*
name|f
parameter_list|,
specifier|const
name|int
name|l
parameter_list|)
block|{
name|val4
operator|=
name|htole32
argument_list|(
name|val4
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"[%s:%d] FIFOW %s 0x%08x = 0x%08x\n"
argument_list|,
name|f
argument_list|,
name|l
argument_list|,
name|desc
argument_list|,
name|off
argument_list|,
name|val4
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|res
argument_list|,
name|off
argument_list|,
name|val4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|a_onchip_fifo_mem_core_read
parameter_list|(
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|uint32_t
name|off
parameter_list|,
specifier|const
name|char
modifier|*
name|desc
parameter_list|,
specifier|const
name|char
modifier|*
name|f
parameter_list|,
specifier|const
name|int
name|l
parameter_list|)
block|{
name|uint32_t
name|val4
decl_stmt|;
name|val4
operator|=
name|le32toh
argument_list|(
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"[%s:%d] FIFOR %s 0x%08x = 0x%08x\n"
argument_list|,
name|f
argument_list|,
name|l
argument_list|,
name|desc
argument_list|,
name|off
argument_list|,
name|val4
argument_list|)
expr_stmt|;
return|return
operator|(
name|val4
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The FIFO does an endian convertion, so we must not do it as well. */
end_comment

begin_comment
comment|/* XXX-BZ in fact we should do a htobe32 so le would be fine as well? */
end_comment

begin_define
define|#
directive|define
name|ATSE_TX_DATA_WRITE
parameter_list|(
name|sc
parameter_list|,
name|val4
parameter_list|)
define|\
value|bus_write_4((sc)->atse_tx_mem_res, A_ONCHIP_FIFO_MEM_CORE_DATA, val4)
end_define

begin_define
define|#
directive|define
name|ATSE_TX_META_WRITE
parameter_list|(
name|sc
parameter_list|,
name|val4
parameter_list|)
define|\
value|a_onchip_fifo_mem_core_write((sc)->atse_tx_mem_res,		\ 	    A_ONCHIP_FIFO_MEM_CORE_METADATA,				\ 	    (val4), "TXM", __func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|ATSE_TX_META_READ
parameter_list|(
name|sc
parameter_list|)
define|\
value|a_onchip_fifo_mem_core_read((sc)->atse_tx_mem_res,		\ 	    A_ONCHIP_FIFO_MEM_CORE_METADATA,				\ 	    "TXM", __func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|ATSE_TX_READ_FILL_LEVEL
parameter_list|(
name|sc
parameter_list|)
define|\
value|a_onchip_fifo_mem_core_read((sc)->atse_txc_mem_res,		\ 	    A_ONCHIP_FIFO_MEM_CORE_STATUS_REG_FILL_LEVEL,		\ 	    "TX_FILL", __func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|ATSE_RX_READ_FILL_LEVEL
parameter_list|(
name|sc
parameter_list|)
define|\
value|a_onchip_fifo_mem_core_read((sc)->atse_rxc_mem_res,		\ 	    A_ONCHIP_FIFO_MEM_CORE_STATUS_REG_FILL_LEVEL,		\ 	    "RX_FILL", __func__, __LINE__)
end_define

begin_comment
comment|/* The FIFO does an endian convertion, so we must not do it as well. */
end_comment

begin_comment
comment|/* XXX-BZ in fact we shoudl do a htobe32 so le would be fine as well? */
end_comment

begin_define
define|#
directive|define
name|ATSE_RX_DATA_READ
parameter_list|(
name|sc
parameter_list|)
define|\
value|bus_read_4((sc)->atse_rx_mem_res, A_ONCHIP_FIFO_MEM_CORE_DATA)
end_define

begin_define
define|#
directive|define
name|ATSE_RX_META_READ
parameter_list|(
name|sc
parameter_list|)
define|\
value|a_onchip_fifo_mem_core_read((sc)->atse_rx_mem_res,		\ 	    A_ONCHIP_FIFO_MEM_CORE_METADATA,				\ 	    "RXM", __func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|ATSE_RX_EVENT_READ
parameter_list|(
name|sc
parameter_list|)
define|\
value|a_onchip_fifo_mem_core_read((sc)->atse_rxc_mem_res,		\ 	    A_ONCHIP_FIFO_MEM_CORE_STATUS_REG_EVENT,			\ 	    "RX_EVENT", __func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|ATSE_TX_EVENT_READ
parameter_list|(
name|sc
parameter_list|)
define|\
value|a_onchip_fifo_mem_core_read((sc)->atse_txc_mem_res,		\ 	    A_ONCHIP_FIFO_MEM_CORE_STATUS_REG_EVENT,			\ 	    "TX_EVENT", __func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|ATSE_RX_EVENT_CLEAR
parameter_list|(
name|sc
parameter_list|)
define|\
value|do {								\ 		uint32_t val4;						\ 									\ 		val4 = a_onchip_fifo_mem_core_read(			\ 		    (sc)->atse_rxc_mem_res,				\ 		    A_ONCHIP_FIFO_MEM_CORE_STATUS_REG_EVENT,		\ 		    "RX_EVENT", __func__, __LINE__);			\ 		if (val4 != 0x00)					\ 			a_onchip_fifo_mem_core_write(			\ 			    (sc)->atse_rxc_mem_res,			\ 			    A_ONCHIP_FIFO_MEM_CORE_STATUS_REG_EVENT,	\ 			    val4, "RX_EVENT", __func__, __LINE__);	\ 	} while(0)
end_define

begin_define
define|#
directive|define
name|ATSE_TX_EVENT_CLEAR
parameter_list|(
name|sc
parameter_list|)
define|\
value|do {								\ 		uint32_t val4;						\ 									\ 		val4 = a_onchip_fifo_mem_core_read(			\ 		    (sc)->atse_txc_mem_res,				\ 		    A_ONCHIP_FIFO_MEM_CORE_STATUS_REG_EVENT,		\ 		    "TX_EVENT", __func__, __LINE__);			\ 		if (val4 != 0x00)					\ 			a_onchip_fifo_mem_core_write(			\ 			    (sc)->atse_txc_mem_res,			\ 			    A_ONCHIP_FIFO_MEM_CORE_STATUS_REG_EVENT,	\ 			    val4, "TX_EVENT", __func__, __LINE__);	\ 	} while(0)
end_define

begin_define
define|#
directive|define
name|ATSE_RX_INTR_ENABLE
parameter_list|(
name|sc
parameter_list|)
define|\
value|a_onchip_fifo_mem_core_write((sc)->atse_rxc_mem_res,		\ 	    A_ONCHIP_FIFO_MEM_CORE_STATUS_REG_INT_ENABLE,		\ 	    A_ONCHIP_FIFO_MEM_CORE_INTR_ALL,				\ 	    "RX_INTR", __func__, __LINE__)
end_define

begin_comment
comment|/* XXX-BZ review later. */
end_comment

begin_define
define|#
directive|define
name|ATSE_RX_INTR_DISABLE
parameter_list|(
name|sc
parameter_list|)
define|\
value|a_onchip_fifo_mem_core_write((sc)->atse_rxc_mem_res,		\ 	    A_ONCHIP_FIFO_MEM_CORE_STATUS_REG_INT_ENABLE, 0,		\ 	    "RX_INTR", __func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|ATSE_TX_INTR_ENABLE
parameter_list|(
name|sc
parameter_list|)
define|\
value|a_onchip_fifo_mem_core_write((sc)->atse_txc_mem_res,		\ 	    A_ONCHIP_FIFO_MEM_CORE_STATUS_REG_INT_ENABLE,		\ 	    A_ONCHIP_FIFO_MEM_CORE_INTR_ALL,				\ 	    "TX_INTR", __func__, __LINE__)
end_define

begin_comment
comment|/* XXX-BZ review later. */
end_comment

begin_define
define|#
directive|define
name|ATSE_TX_INTR_DISABLE
parameter_list|(
name|sc
parameter_list|)
define|\
value|a_onchip_fifo_mem_core_write((sc)->atse_txc_mem_res,		\ 	    A_ONCHIP_FIFO_MEM_CORE_STATUS_REG_INT_ENABLE, 0,		\ 	    "TX_INTR", __func__, __LINE__)
end_define

begin_comment
comment|/*  * Register space access macros.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|csr_write_4
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|val4
parameter_list|,
specifier|const
name|char
modifier|*
name|f
parameter_list|,
specifier|const
name|int
name|l
parameter_list|)
block|{
name|val4
operator|=
name|htole32
argument_list|(
name|val4
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"[%s:%d] CSR W %s 0x%08x (0x%08x) = 0x%08x\n"
argument_list|,
name|f
argument_list|,
name|l
argument_list|,
literal|"atse_mem_res"
argument_list|,
name|reg
argument_list|,
name|reg
operator|*
literal|4
argument_list|,
name|val4
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|atse_mem_res
argument_list|,
name|reg
operator|*
literal|4
argument_list|,
name|val4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|csr_read_4
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
specifier|const
name|char
modifier|*
name|f
parameter_list|,
specifier|const
name|int
name|l
parameter_list|)
block|{
name|uint32_t
name|val4
decl_stmt|;
name|val4
operator|=
name|le32toh
argument_list|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|atse_mem_res
argument_list|,
name|reg
operator|*
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"[%s:%d] CSR R %s 0x%08x (0x%08x) = 0x%08x\n"
argument_list|,
name|f
argument_list|,
name|l
argument_list|,
literal|"atse_mem_res"
argument_list|,
name|reg
argument_list|,
name|reg
operator|*
literal|4
argument_list|,
name|val4
argument_list|)
expr_stmt|;
return|return
operator|(
name|val4
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * See page 5-2 that it's all dword offsets and the MS 16 bits need to be zero  * on write and ignored on read.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pxx_write_2
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|bmcr
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint16_t
name|val
parameter_list|,
specifier|const
name|char
modifier|*
name|f
parameter_list|,
specifier|const
name|int
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|uint32_t
name|val4
decl_stmt|;
name|val4
operator|=
name|htole32
argument_list|(
name|val
operator|&
literal|0x0000ffff
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"[%s:%d] %s W %s 0x%08x (0x%08jx) = 0x%08x\n"
argument_list|,
name|f
argument_list|,
name|l
argument_list|,
name|s
argument_list|,
literal|"atse_mem_res"
argument_list|,
name|reg
argument_list|,
operator|(
name|bmcr
operator|+
name|reg
operator|)
operator|*
literal|4
argument_list|,
name|val4
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|atse_mem_res
argument_list|,
operator|(
name|bmcr
operator|+
name|reg
operator|)
operator|*
literal|4
argument_list|,
name|val4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint16_t
name|pxx_read_2
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|bmcr
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
specifier|const
name|char
modifier|*
name|f
parameter_list|,
specifier|const
name|int
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|uint32_t
name|val4
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|val4
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|atse_mem_res
argument_list|,
operator|(
name|bmcr
operator|+
name|reg
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|val
operator|=
name|le32toh
argument_list|(
name|val4
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"[%s:%d] %s R %s 0x%08x (0x%08jx) = 0x%04x\n"
argument_list|,
name|f
argument_list|,
name|l
argument_list|,
name|s
argument_list|,
literal|"atse_mem_res"
argument_list|,
name|reg
argument_list|,
operator|(
name|bmcr
operator|+
name|reg
operator|)
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CSR_WRITE_4
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|csr_write_4((sc), (reg), (val), __func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|CSR_READ_4
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
define|\
value|csr_read_4((sc), (reg), __func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|PCS_WRITE_2
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|pxx_write_2((sc), sc->atse_bmcr0, (reg), (val), __func__, __LINE__, \ 	    "PCS")
end_define

begin_define
define|#
directive|define
name|PCS_READ_2
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
define|\
value|pxx_read_2((sc), sc->atse_bmcr0, (reg), __func__, __LINE__, "PCS")
end_define

begin_define
define|#
directive|define
name|PHY_WRITE_2
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|pxx_write_2((sc), sc->atse_bmcr1, (reg), (val), __func__, __LINE__, \ 	    "PHY")
end_define

begin_define
define|#
directive|define
name|PHY_READ_2
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
define|\
value|pxx_read_2((sc), sc->atse_bmcr1, (reg), __func__, __LINE__, "PHY")
end_define

begin_function_decl
specifier|static
name|void
name|atse_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atse_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|devclass_t
name|atse_devclass
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|atse_tx_locked
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
parameter_list|,
name|int
modifier|*
name|sent
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|val4
decl_stmt|,
name|fill_level
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ATSE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m
operator|=
name|sc
operator|->
name|atse_tx_m
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: m is null: sc=%p"
operator|,
name|__func__
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
argument_list|,
operator|(
literal|"%s: not a pkthdr: m=%p"
operator|,
name|__func__
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy to buffer to minimize our pain as we can only store 	 * double words which, after the first mbuf gets out of alignment 	 * quite quickly. 	 */
if|if
condition|(
name|sc
operator|->
name|atse_tx_m_offset
operator|==
literal|0
condition|)
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|sc
operator|->
name|atse_tx_buf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_tx_buf_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
name|fill_level
operator|=
name|ATSE_TX_READ_FILL_LEVEL
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Returns 0xdeadc0de. */
block|val4 = ATSE_TX_META_READ(sc);
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|atse_tx_m_offset
operator|==
literal|0
condition|)
block|{
comment|/* Write start of packet. */
name|val4
operator|=
name|A_ONCHIP_FIFO_MEM_CORE_SOP
expr_stmt|;
name|val4
operator|&=
operator|~
name|A_ONCHIP_FIFO_MEM_CORE_EOP
expr_stmt|;
name|ATSE_TX_META_WRITE
argument_list|(
name|sc
argument_list|,
name|val4
argument_list|)
expr_stmt|;
block|}
comment|/* TX FIFO is single clock mode, so we have the full FIFO. */
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|sc
operator|->
name|atse_tx_buf_len
operator|-
name|sc
operator|->
name|atse_tx_m_offset
operator|)
operator|>
literal|4
operator|&&
name|fill_level
operator|<
name|AVALON_FIFO_TX_BASIC_OPTS_DEPTH
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|atse_tx_buf
index|[
name|sc
operator|->
name|atse_tx_m_offset
index|]
argument_list|,
operator|&
name|val4
argument_list|,
sizeof|sizeof
argument_list|(
name|val4
argument_list|)
argument_list|)
expr_stmt|;
name|ATSE_TX_DATA_WRITE
argument_list|(
name|sc
argument_list|,
name|val4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_tx_m_offset
operator|+=
sizeof|sizeof
argument_list|(
name|val4
argument_list|)
expr_stmt|;
name|c
operator|+=
sizeof|sizeof
argument_list|(
name|val4
argument_list|)
expr_stmt|;
name|fill_level
operator|++
expr_stmt|;
if|if
condition|(
name|fill_level
operator|==
name|AVALON_FIFO_TX_BASIC_OPTS_DEPTH
condition|)
name|fill_level
operator|=
name|ATSE_TX_READ_FILL_LEVEL
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sent
operator|!=
name|NULL
condition|)
operator|*
name|sent
operator|+=
name|c
expr_stmt|;
comment|/* Set EOP *before* writing the last symbol. */
if|if
condition|(
name|sc
operator|->
name|atse_tx_m_offset
operator|>=
operator|(
name|sc
operator|->
name|atse_tx_buf_len
operator|-
literal|4
operator|)
operator|&&
name|fill_level
operator|<
name|AVALON_FIFO_TX_BASIC_OPTS_DEPTH
condition|)
block|{
name|int
name|leftm
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
comment|/* Set EndOfPacket. */
name|val4
operator|=
name|A_ONCHIP_FIFO_MEM_CORE_EOP
expr_stmt|;
comment|/* Set EMPTY. */
name|leftm
operator|=
name|sc
operator|->
name|atse_tx_buf_len
operator|-
name|sc
operator|->
name|atse_tx_m_offset
expr_stmt|;
name|val4
operator||=
operator|(
operator|(
literal|4
operator|-
name|leftm
operator|)
operator|<<
name|A_ONCHIP_FIFO_MEM_CORE_EMPTY_SHIFT
operator|)
expr_stmt|;
name|x
operator|=
name|val4
expr_stmt|;
name|ATSE_TX_META_WRITE
argument_list|(
name|sc
argument_list|,
name|val4
argument_list|)
expr_stmt|;
comment|/* Write last symbol. */
name|val4
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|atse_tx_buf
operator|+
name|sc
operator|->
name|atse_tx_m_offset
argument_list|,
operator|&
name|val4
argument_list|,
name|leftm
argument_list|)
expr_stmt|;
name|ATSE_TX_DATA_WRITE
argument_list|(
name|sc
argument_list|,
name|val4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
operator|!=
name|NULL
condition|)
operator|*
name|sent
operator|+=
name|leftm
expr_stmt|;
comment|/* OK, the packet is gone. */
name|sc
operator|->
name|atse_tx_m
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|atse_tx_m_offset
operator|=
literal|0
expr_stmt|;
comment|/* If anyone is interested give them a copy. */
name|BPF_MTAP
argument_list|(
name|sc
operator|->
name|atse_ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atse_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sent
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ATSE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|||
operator|(
name|sc
operator|->
name|atse_flags
operator|&
name|ATSE_FLAGS_LINK
operator|)
operator|==
literal|0
condition|)
return|return;
if|#
directive|if
literal|1
comment|/*  	 * Disable the watchdog while sending, we are batching packets. 	 * Though we should never reach 5 seconds, and are holding the lock, 	 * but who knows. 	 */
name|sc
operator|->
name|atse_watchdog_timer
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|atse_tx_m
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|atse_tx_locked
argument_list|(
name|sc
argument_list|,
operator|&
name|sent
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* We have more space to send so continue ... */
for|for
control|(
init|;
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|;
control|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|sc
operator|->
name|atse_tx_m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_tx_m_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|atse_tx_m
operator|==
name|NULL
condition|)
break|break;
name|error
operator|=
name|atse_tx_locked
argument_list|(
name|sc
argument_list|,
operator|&
name|sent
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
name|done
label|:
comment|/* If the IP core walks into Nekromanteion try to bail out. */
if|if
condition|(
name|sent
operator|>
literal|0
condition|)
name|sc
operator|->
name|atse_watchdog_timer
operator|=
name|ATSE_WATCHDOG_TIME
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atse_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ATSE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|atse_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ATSE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|atse_stop_locked
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|,
name|val4
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ATSE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_watchdog_timer
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|atse_tick
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|atse_ifp
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|ATSE_RX_INTR_DISABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_TX_INTR_DISABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_RX_EVENT_CLEAR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_TX_EVENT_CLEAR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable MAC transmit and receive datapath. */
name|mask
operator|=
name|BASE_CFG_COMMAND_CONFIG_TX_ENA
operator||
name|BASE_CFG_COMMAND_CONFIG_RX_ENA
expr_stmt|;
name|val4
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|)
expr_stmt|;
name|val4
operator|&=
operator|~
name|mask
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|,
name|val4
argument_list|)
expr_stmt|;
comment|/* Wait for bits to be cleared; i=100 is excessive. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|val4
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val4
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val4
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"Disabling MAC TX/RX timed out.\n"
argument_list|)
expr_stmt|;
comment|/* Punt. */
name|sc
operator|->
name|atse_flags
operator|&=
operator|~
name|ATSE_FLAGS_LINK
expr_stmt|;
comment|/* XXX-BZ free the RX/TX rings. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|atse_mchash
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
name|__unused
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint8_t
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|y
operator|=
name|addr
index|[
name|i
index|]
operator|&
literal|0x01
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|y
operator|^=
operator|(
name|addr
index|[
name|i
index|]
operator|>>
name|j
operator|)
operator|&
literal|0x01
expr_stmt|;
name|x
operator||=
operator|(
name|y
operator|<<
name|i
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atse_rxfilter_locked
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|uint32_t
name|val4
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* XXX-BZ can we find out if we have the MHASH synthesized? */
name|val4
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|)
expr_stmt|;
comment|/* For simplicity always hash full 48 bits of addresses. */
if|if
condition|(
operator|(
name|val4
operator|&
name|BASE_CFG_COMMAND_CONFIG_MHASH_SEL
operator|)
operator|!=
literal|0
condition|)
name|val4
operator|&=
operator|~
name|BASE_CFG_COMMAND_CONFIG_MHASH_SEL
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|atse_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|val4
operator||=
name|BASE_CFG_COMMAND_CONFIG_PROMIS_EN
expr_stmt|;
else|else
name|val4
operator|&=
operator|~
name|BASE_CFG_COMMAND_CONFIG_PROMIS_EN
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|,
name|val4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
comment|/* Accept all multicast addresses. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MHASH_LEN
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MHASH_START
operator|+
name|i
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  		 * Can hold MHASH_LEN entries. 		 * XXX-BZ bitstring.h would be more general. 		 */
name|uint64_t
name|h
decl_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Re-build and re-program hash table.  First build the 		 * bit-field "yes" or "no" for each slot per address, then 		 * do all the programming afterwards. 		 */
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|h
operator||=
operator|(
literal|1
operator|<<
name|atse_mchash
argument_list|(
name|sc
argument_list|,
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MHASH_LEN
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MHASH_START
operator|+
name|i
argument_list|,
operator|(
name|h
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
literal|0x01
else|:
literal|0x00
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atse_ethernet_option_bits_read_fdt
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|device_t
name|fdev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rid
decl_stmt|;
if|if
condition|(
name|atse_ethernet_option_bits_flag
operator|&
name|ATSE_ETHERNET_OPTION_BITS_READ
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fdev
operator|=
name|device_find_child
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"cfi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|rid
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|fdev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ALTERA_ETHERNET_OPTION_BITS_LEN
condition|;
name|i
operator|++
control|)
name|atse_ethernet_option_bits
index|[
name|i
index|]
operator|=
name|bus_read_1
argument_list|(
name|res
argument_list|,
name|ALTERA_ETHERNET_OPTION_BITS_OFF
operator|+
name|i
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|fdev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|atse_ethernet_option_bits_flag
operator||=
name|ATSE_ETHERNET_OPTION_BITS_READ
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atse_ethernet_option_bits_read
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|atse_ethernet_option_bits_read_fdt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot read Ethernet addresses from flash.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atse_get_eth_address
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|long
name|hostid
decl_stmt|;
name|uint32_t
name|val4
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Make sure to only ever do this once.  Otherwise a reset would 	 * possibly change our ethernet address, which is not good at all. 	 */
if|if
condition|(
name|sc
operator|->
name|atse_eth_addr
index|[
literal|0
index|]
operator|!=
literal|0x00
operator|||
name|sc
operator|->
name|atse_eth_addr
index|[
literal|1
index|]
operator|!=
literal|0x00
operator|||
name|sc
operator|->
name|atse_eth_addr
index|[
literal|2
index|]
operator|!=
literal|0x00
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|atse_ethernet_option_bits_flag
operator|&
name|ATSE_ETHERNET_OPTION_BITS_READ
operator|)
operator|==
literal|0
condition|)
goto|goto
name|get_random
goto|;
name|val4
operator|=
name|atse_ethernet_option_bits
index|[
literal|0
index|]
operator|<<
literal|24
expr_stmt|;
name|val4
operator||=
name|atse_ethernet_option_bits
index|[
literal|1
index|]
operator|<<
literal|16
expr_stmt|;
name|val4
operator||=
name|atse_ethernet_option_bits
index|[
literal|2
index|]
operator|<<
literal|8
expr_stmt|;
name|val4
operator||=
name|atse_ethernet_option_bits
index|[
literal|3
index|]
expr_stmt|;
comment|/* They chose "safe". */
if|if
condition|(
name|val4
operator|!=
name|le32toh
argument_list|(
literal|0x00005afe
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"Magic '5afe' is not safe: 0x%08x. "
literal|"Falling back to random numbers for hardware address.\n"
argument_list|,
name|val4
argument_list|)
expr_stmt|;
goto|goto
name|get_random
goto|;
block|}
name|sc
operator|->
name|atse_eth_addr
index|[
literal|0
index|]
operator|=
name|atse_ethernet_option_bits
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|atse_eth_addr
index|[
literal|1
index|]
operator|=
name|atse_ethernet_option_bits
index|[
literal|5
index|]
expr_stmt|;
name|sc
operator|->
name|atse_eth_addr
index|[
literal|2
index|]
operator|=
name|atse_ethernet_option_bits
index|[
literal|6
index|]
expr_stmt|;
name|sc
operator|->
name|atse_eth_addr
index|[
literal|3
index|]
operator|=
name|atse_ethernet_option_bits
index|[
literal|7
index|]
expr_stmt|;
name|sc
operator|->
name|atse_eth_addr
index|[
literal|4
index|]
operator|=
name|atse_ethernet_option_bits
index|[
literal|8
index|]
expr_stmt|;
name|sc
operator|->
name|atse_eth_addr
index|[
literal|5
index|]
operator|=
name|atse_ethernet_option_bits
index|[
literal|9
index|]
expr_stmt|;
comment|/* Handle factory default ethernet addresss: 00:07:ed:ff:ed:15 */
if|if
condition|(
name|sc
operator|->
name|atse_eth_addr
index|[
literal|0
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|atse_eth_addr
index|[
literal|1
index|]
operator|==
literal|0x07
operator|&&
name|sc
operator|->
name|atse_eth_addr
index|[
literal|2
index|]
operator|==
literal|0xed
operator|&&
name|sc
operator|->
name|atse_eth_addr
index|[
literal|3
index|]
operator|==
literal|0xff
operator|&&
name|sc
operator|->
name|atse_eth_addr
index|[
literal|4
index|]
operator|==
literal|0xed
operator|&&
name|sc
operator|->
name|atse_eth_addr
index|[
literal|5
index|]
operator|==
literal|0x15
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"Factory programmed Ethernet "
literal|"hardware address blacklisted.  Falling back to random "
literal|"address to avoid collisions.\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"Please re-program your flash.\n"
argument_list|)
expr_stmt|;
goto|goto
name|get_random
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|atse_eth_addr
index|[
literal|0
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|atse_eth_addr
index|[
literal|1
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|atse_eth_addr
index|[
literal|2
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|atse_eth_addr
index|[
literal|3
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|atse_eth_addr
index|[
literal|4
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|atse_eth_addr
index|[
literal|5
index|]
operator|==
literal|0x00
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"All zero's Ethernet hardware "
literal|"address blacklisted.  Falling back to random address.\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"Please re-program your flash.\n"
argument_list|)
expr_stmt|;
goto|goto
name|get_random
goto|;
block|}
if|if
condition|(
name|ETHER_IS_MULTICAST
argument_list|(
name|sc
operator|->
name|atse_eth_addr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"Multicast Ethernet hardware "
literal|"address blacklisted.  Falling back to random address.\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"Please re-program your flash.\n"
argument_list|)
expr_stmt|;
goto|goto
name|get_random
goto|;
block|}
comment|/* 	 * If we find an Altera prefixed address with a 0x0 ending 	 * adjust by device unit.  If not and this is not the first 	 * Ethernet, go to random. 	 */
name|unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0x00
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|unit
operator|>
literal|0x0f
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"We do not support Ethernet "
literal|"addresses for more than 16 MACs. Falling back to "
literal|"random hadware address.\n"
argument_list|)
expr_stmt|;
goto|goto
name|get_random
goto|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|atse_eth_addr
index|[
literal|0
index|]
operator|&
operator|~
literal|0x2
operator|)
operator|!=
literal|0
operator|||
name|sc
operator|->
name|atse_eth_addr
index|[
literal|1
index|]
operator|!=
literal|0x07
operator|||
name|sc
operator|->
name|atse_eth_addr
index|[
literal|2
index|]
operator|!=
literal|0xed
operator|||
operator|(
name|sc
operator|->
name|atse_eth_addr
index|[
literal|5
index|]
operator|&
literal|0x0f
operator|)
operator|!=
literal|0x0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"Ethernet address not meeting our "
literal|"multi-MAC standards. Falling back to random hadware "
literal|"address.\n"
argument_list|)
expr_stmt|;
goto|goto
name|get_random
goto|;
block|}
name|sc
operator|->
name|atse_eth_addr
index|[
literal|5
index|]
operator||=
operator|(
name|unit
operator|&
literal|0x0f
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|get_random
label|:
comment|/* 	 * Fall back to random code we also use on bridge(4). 	 */
name|getcredhostid
argument_list|(
name|curthread
operator|->
name|td_ucred
argument_list|,
operator|&
name|hostid
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostid
operator|==
literal|0
condition|)
block|{
name|arc4rand
argument_list|(
name|sc
operator|->
name|atse_eth_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_eth_addr
index|[
literal|0
index|]
operator|&=
operator|~
literal|1
expr_stmt|;
comment|/* clear multicast bit */
name|sc
operator|->
name|atse_eth_addr
index|[
literal|0
index|]
operator||=
literal|2
expr_stmt|;
comment|/* set the LAA bit */
block|}
else|else
block|{
name|sc
operator|->
name|atse_eth_addr
index|[
literal|0
index|]
operator|=
literal|0x2
expr_stmt|;
name|sc
operator|->
name|atse_eth_addr
index|[
literal|1
index|]
operator|=
operator|(
name|hostid
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|atse_eth_addr
index|[
literal|2
index|]
operator|=
operator|(
name|hostid
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|atse_eth_addr
index|[
literal|3
index|]
operator|=
operator|(
name|hostid
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|atse_eth_addr
index|[
literal|4
index|]
operator|=
name|hostid
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|atse_eth_addr
index|[
literal|5
index|]
operator|=
name|sc
operator|->
name|atse_unit
operator|&
literal|0xff
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atse_set_eth_address
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|uint32_t
name|v0
decl_stmt|,
name|v1
decl_stmt|;
name|v0
operator|=
operator|(
name|sc
operator|->
name|atse_eth_addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sc
operator|->
name|atse_eth_addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sc
operator|->
name|atse_eth_addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|sc
operator|->
name|atse_eth_addr
index|[
literal|0
index|]
expr_stmt|;
name|v1
operator|=
operator|(
name|sc
operator|->
name|atse_eth_addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|sc
operator|->
name|atse_eth_addr
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|&
name|ATSE_ETH_ADDR_DEF
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_MAC_0
argument_list|,
name|v0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_MAC_1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|&
name|ATSE_ETH_ADDR_SUPP1
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|SUPPL_ADDR_SMAC_0_0
argument_list|,
name|v0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|SUPPL_ADDR_SMAC_0_1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|&
name|ATSE_ETH_ADDR_SUPP2
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|SUPPL_ADDR_SMAC_1_0
argument_list|,
name|v0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|SUPPL_ADDR_SMAC_1_1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|&
name|ATSE_ETH_ADDR_SUPP3
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|SUPPL_ADDR_SMAC_2_0
argument_list|,
name|v0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|SUPPL_ADDR_SMAC_2_1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|&
name|ATSE_ETH_ADDR_SUPP4
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|SUPPL_ADDR_SMAC_3_0
argument_list|,
name|v0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|SUPPL_ADDR_SMAC_3_1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atse_reset
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|val4
decl_stmt|,
name|mask
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
comment|/* 1. External PHY Initialization using MDIO. */
comment|/* 	 * We select the right MDIO space in atse_attach() and let MII do 	 * anything else. 	 */
comment|/* 2. PCS Configuration Register Initialization. */
comment|/* a. Set auto negotiation link timer to 1.6ms for SGMII. */
name|PCS_WRITE_2
argument_list|(
name|sc
argument_list|,
name|PCS_EXT_LINK_TIMER_0
argument_list|,
literal|0x0D40
argument_list|)
expr_stmt|;
name|PCS_WRITE_2
argument_list|(
name|sc
argument_list|,
name|PCS_EXT_LINK_TIMER_1
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
comment|/* b. Configure SGMII. */
name|val
operator|=
name|PCS_EXT_IF_MODE_SGMII_ENA
operator||
name|PCS_EXT_IF_MODE_USE_SGMII_AN
expr_stmt|;
name|PCS_WRITE_2
argument_list|(
name|sc
argument_list|,
name|PCS_EXT_IF_MODE
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* c. Enable auto negotiation. */
comment|/* Ignore Bits 6,8,13; should be set,set,unset. */
name|val
operator|=
name|PCS_READ_2
argument_list|(
name|sc
argument_list|,
name|PCS_CONTROL
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|PCS_CONTROL_ISOLATE
operator||
name|PCS_CONTROL_POWERDOWN
operator|)
expr_stmt|;
name|val
operator|&=
operator|~
name|PCS_CONTROL_LOOPBACK
expr_stmt|;
comment|/* Make this a -link1 option? */
name|val
operator||=
name|PCS_CONTROL_AUTO_NEGOTIATION_ENABLE
expr_stmt|;
name|PCS_WRITE_2
argument_list|(
name|sc
argument_list|,
name|PCS_CONTROL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* d. PCS reset. */
name|val
operator|=
name|PCS_READ_2
argument_list|(
name|sc
argument_list|,
name|PCS_CONTROL
argument_list|)
expr_stmt|;
name|val
operator||=
name|PCS_CONTROL_RESET
expr_stmt|;
name|PCS_WRITE_2
argument_list|(
name|sc
argument_list|,
name|PCS_CONTROL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Wait for reset bit to clear; i=100 is excessive. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|PCS_READ_2
argument_list|(
name|sc
argument_list|,
name|PCS_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PCS_CONTROL_RESET
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|&
name|PCS_CONTROL_RESET
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"PCS reset timed out.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 3. MAC Configuration Register Initialization. */
comment|/* a. Disable MAC transmit and receive datapath. */
name|mask
operator|=
name|BASE_CFG_COMMAND_CONFIG_TX_ENA
operator||
name|BASE_CFG_COMMAND_CONFIG_RX_ENA
expr_stmt|;
name|val4
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|)
expr_stmt|;
name|val4
operator|&=
operator|~
name|mask
expr_stmt|;
comment|/* Samples in the manual do have the SW_RESET bit set here, why? */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|,
name|val4
argument_list|)
expr_stmt|;
comment|/* Wait for bits to be cleared; i=100 is excessive. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|val4
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val4
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val4
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"Disabling MAC TX/RX timed out.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* b. MAC FIFO configuration. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_TX_SECTION_EMPTY
argument_list|,
name|FIFO_DEPTH_TX
operator|-
literal|16
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_TX_ALMOST_FULL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_TX_ALMOST_EMPTY
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_RX_SECTION_EMPTY
argument_list|,
name|FIFO_DEPTH_RX
operator|-
literal|16
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_RX_ALMOST_FULL
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_RX_ALMOST_EMPTY
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|CSR_WRITE_4(sc, BASE_CFG_TX_SECTION_FULL, 16); 	CSR_WRITE_4(sc, BASE_CFG_RX_SECTION_FULL, 16);
else|#
directive|else
comment|/* For store-and-forward mode, set this threshold to 0. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_TX_SECTION_FULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_RX_SECTION_FULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* c. MAC address configuration. */
comment|/* Also intialize supplementary addresses to our primary one. */
comment|/* XXX-BZ FreeBSD really needs to grow and API for using these. */
name|atse_get_eth_address
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|atse_set_eth_address
argument_list|(
name|sc
argument_list|,
name|ATSE_ETH_ADDR_ALL
argument_list|)
expr_stmt|;
comment|/* d. MAC function configuration. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_FRM_LENGTH
argument_list|,
literal|1518
argument_list|)
expr_stmt|;
comment|/* Default. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_TX_IPG_LENGTH
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_PAUSE_QUANT
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|val4
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|)
expr_stmt|;
comment|/*	 	 * If 1000BASE-X/SGMII PCS is initialized, set the ETH_SPEED (bit 3) 	 * and ENA_10 (bit 25) in command_config register to 0.  If half duplex 	 * is reported in the PHY/PCS status register, set the HD_ENA (bit 10) 	 * to 1 in command_config register. 	 * BZ: We shoot for 1000 instead. 	 */
if|#
directive|if
literal|0
block|val4 |= BASE_CFG_COMMAND_CONFIG_ETH_SPEED;
else|#
directive|else
name|val4
operator|&=
operator|~
name|BASE_CFG_COMMAND_CONFIG_ETH_SPEED
expr_stmt|;
endif|#
directive|endif
name|val4
operator|&=
operator|~
name|BASE_CFG_COMMAND_CONFIG_ENA_10
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * We do not want to set this, otherwise, we could not even send 	 * random raw ethernet frames for various other research.  By default 	 * FreeBSD will use the right ether source address. 	 */
block|val4 |= BASE_CFG_COMMAND_CONFIG_TX_ADDR_INS;
endif|#
directive|endif
name|val4
operator||=
name|BASE_CFG_COMMAND_CONFIG_PAD_EN
expr_stmt|;
name|val4
operator|&=
operator|~
name|BASE_CFG_COMMAND_CONFIG_CRC_FWD
expr_stmt|;
if|#
directive|if
literal|0
block|val4 |= BASE_CFG_COMMAND_CONFIG_CNTL_FRM_ENA;
endif|#
directive|endif
if|#
directive|if
literal|1
name|val4
operator||=
name|BASE_CFG_COMMAND_CONFIG_RX_ERR_DISC
expr_stmt|;
endif|#
directive|endif
name|val
operator|&=
operator|~
name|BASE_CFG_COMMAND_CONFIG_LOOP_ENA
expr_stmt|;
comment|/* link0? */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|,
name|val4
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure we do not enable 32bit alignment;  FreeBSD cannot 	 * cope with the additional padding (though we should!?). 	 * Also make sure we get the CRC appended. 	 */
name|val4
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|TX_CMD_STAT
argument_list|)
expr_stmt|;
name|val4
operator|&=
operator|~
operator|(
name|TX_CMD_STAT_OMIT_CRC
operator||
name|TX_CMD_STAT_TX_SHIFT16
operator|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TX_CMD_STAT
argument_list|,
name|val4
argument_list|)
expr_stmt|;
name|val4
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|RX_CMD_STAT
argument_list|)
expr_stmt|;
name|val4
operator|&=
operator|~
name|RX_CMD_STAT_RX_SHIFT16
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RX_CMD_STAT
argument_list|,
name|val4
argument_list|)
expr_stmt|;
comment|/* e. Reset MAC. */
name|val4
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|)
expr_stmt|;
name|val4
operator||=
name|BASE_CFG_COMMAND_CONFIG_SW_RESET
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|,
name|val4
argument_list|)
expr_stmt|;
comment|/* Wait for bits to be cleared; i=100 is excessive. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|val4
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val4
operator|&
name|BASE_CFG_COMMAND_CONFIG_SW_RESET
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val4
operator|&
name|BASE_CFG_COMMAND_CONFIG_SW_RESET
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"MAC reset timed out.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* f. Enable MAC transmit and receive datapath. */
name|mask
operator|=
name|BASE_CFG_COMMAND_CONFIG_TX_ENA
operator||
name|BASE_CFG_COMMAND_CONFIG_RX_ENA
expr_stmt|;
name|val4
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|)
expr_stmt|;
name|val4
operator||=
name|mask
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|,
name|val4
argument_list|)
expr_stmt|;
comment|/* Wait for bits to be cleared; i=100 is excessive. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|val4
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val4
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val4
operator|&
name|mask
operator|)
operator|!=
name|mask
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"Enabling MAC TX/RX timed out.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atse_init_locked
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint8_t
modifier|*
name|eaddr
decl_stmt|;
name|ATSE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|atse_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * Must update the ether address if changed.  Given we do not handle 	 * in atse_ioctl() but it's in the general framework, just always 	 * do it here before atse_reset(). 	 */
name|eaddr
operator|=
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|atse_ifp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|eaddr
argument_list|,
operator|&
name|sc
operator|->
name|atse_eth_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Make things frind to halt, cleanup, ... */
name|atse_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* ... reset, ... */
name|atse_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* ... and fire up the engine again. */
name|atse_rxfilter_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Memory rings?  DMA engine? */
name|sc
operator|->
name|atse_rx_buf_len
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|atse_flags
operator|&=
name|ATSE_FLAGS_LINK
expr_stmt|;
comment|/* Preserve. */
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* Only enable interrupts if we are not polling. */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|ATSE_RX_INTR_DISABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_TX_INTR_DISABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_RX_EVENT_CLEAR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_TX_EVENT_CLEAR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|ATSE_RX_INTR_ENABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_TX_INTR_ENABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|atse_miibus
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_flags
operator|&=
operator|~
name|ATSE_FLAGS_LINK
expr_stmt|;
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|atse_tick
argument_list|,
name|hz
argument_list|,
name|atse_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atse_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|atse_softc
operator|*
operator|)
name|xsc
expr_stmt|;
name|ATSE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|atse_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|atse_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|mask
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|ATSE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|atse_if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
operator|!=
literal|0
condition|)
name|atse_rxfilter_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|atse_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|atse_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|ATSE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|ATSE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_POLLING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IFCAP_POLLING
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_POLLING
expr_stmt|;
if|if
condition|(
operator|(
name|IFCAP_POLLING
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ether_poll_register
argument_list|(
name|atse_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ATSE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Disable interrupts. */
name|ATSE_RX_INTR_DISABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_TX_INTR_DISABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_RX_EVENT_CLEAR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_TX_EVENT_CLEAR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 			 * Do not allow disabling of polling if we do 			 * not have interrupts. 			 */
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|atse_rx_irq_res
operator|!=
name|NULL
operator|||
name|sc
operator|->
name|atse_tx_irq_res
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Enable interrupts. */
name|ATSE_RX_INTR_ENABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_TX_INTR_ENABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_POLLING
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* DEVICE_POLLING */
name|ATSE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|ATSE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|atse_rxfilter_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
block|{
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|atse_miibus
argument_list|)
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atse_watchdog
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ATSE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|atse_watchdog_timer
operator|==
literal|0
operator|||
operator|--
name|sc
operator|->
name|atse_watchdog_timer
operator|>
literal|0
condition|)
return|return;
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"watchdog timeout\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|atse_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|atse_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|atse_ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|atse_start_locked
argument_list|(
name|sc
operator|->
name|atse_ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atse_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|atse_softc
operator|*
operator|)
name|xsc
expr_stmt|;
name|ATSE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|atse_ifp
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|atse_miibus
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|atse_watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|atse_flags
operator|&
name|ATSE_FLAGS_LINK
operator|)
operator|==
literal|0
condition|)
name|atse_miibus_statchg
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|atse_tick
argument_list|,
name|hz
argument_list|,
name|atse_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set media options.  */
end_comment

begin_function
specifier|static
name|int
name|atse_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|mii_softc
modifier|*
name|miisc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ATSE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|atse_miibus
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|miisc
argument_list|,
argument|&mii->mii_phys
argument_list|,
argument|mii_list
argument_list|)
name|PHY_RESET
argument_list|(
name|miisc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ATSE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atse_update_rx_err
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* RX error are 6 bits, we only know 4 of them. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ATSE_RX_ERR_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|atse_rx_err
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|atse_rx_locked
parameter_list|(
name|struct
name|atse_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|fill
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint32_t
name|data
decl_stmt|,
name|meta
decl_stmt|;
name|int
name|rx_npkts
init|=
literal|0
decl_stmt|;
name|ATSE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|atse_ifp
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|meta
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|outer
label|:
if|if
condition|(
name|sc
operator|->
name|atse_rx_cycles
operator|<=
literal|0
condition|)
return|return
operator|(
name|rx_npkts
operator|)
return|;
name|sc
operator|->
name|atse_rx_cycles
operator|--
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|atse_rx_m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|rx_npkts
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
comment|/* Make sure upper layers will be aligned. */
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_rx_m
operator|=
name|m
expr_stmt|;
block|}
name|fill
operator|=
name|ATSE_RX_READ_FILL_LEVEL
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fill
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * XXX-BZ for whatever reason the FIFO requires the 			 * the data read before we can access the meta data. 			 */
name|data
operator|=
name|ATSE_RX_DATA_READ
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|meta
operator|=
name|ATSE_RX_META_READ
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|meta
operator|&
name|A_ONCHIP_FIFO_MEM_CORE_ERROR_MASK
condition|)
block|{
comment|/* XXX-BZ evaluate error. */
name|atse_update_rx_err
argument_list|(
name|sc
argument_list|,
operator|(
operator|(
name|meta
operator|&
name|A_ONCHIP_FIFO_MEM_CORE_ERROR_MASK
operator|)
operator|>>
name|A_ONCHIP_FIFO_MEM_CORE_ERROR_SHIFT
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|atse_rx_buf_len
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Should still read till EOP or next SOP. 				 * 				 * XXX-BZ might also depend on 				 * BASE_CFG_COMMAND_CONFIG_RX_ERR_DISC 				 */
name|sc
operator|->
name|atse_flags
operator||=
name|ATSE_FLAGS_ERROR
expr_stmt|;
return|return
operator|(
name|rx_npkts
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|meta
operator|&
name|A_ONCHIP_FIFO_MEM_CORE_CHANNEL_MASK
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"%s: unexpected "
literal|"channel %u\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|meta
operator|&
name|A_ONCHIP_FIFO_MEM_CORE_CHANNEL_MASK
operator|)
operator|>>
name|A_ONCHIP_FIFO_MEM_CORE_CHANNEL_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|meta
operator|&
name|A_ONCHIP_FIFO_MEM_CORE_SOP
condition|)
block|{
comment|/* 				 * There is no need to clear SOP between 1st 				 * and subsequent packet data junks. 				 */
if|if
condition|(
name|sc
operator|->
name|atse_rx_buf_len
operator|!=
literal|0
operator|&&
operator|(
name|sc
operator|->
name|atse_flags
operator|&
name|ATSE_FLAGS_SOP_SEEN
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|atse_dev
argument_list|,
literal|"%s: SOP "
literal|"without empty buffer: %u\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|atse_rx_buf_len
argument_list|)
expr_stmt|;
comment|/* XXX-BZ any better counter? */
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|atse_flags
operator|&
name|ATSE_FLAGS_SOP_SEEN
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|atse_flags
operator||=
name|ATSE_FLAGS_SOP_SEEN
expr_stmt|;
name|sc
operator|->
name|atse_rx_buf_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* We had to read the data before we could access meta data. See above. */
block|data = ATSE_RX_DATA_READ(sc);
endif|#
directive|endif
comment|/* Make sure to not overflow the mbuf data size. */
if|if
condition|(
name|sc
operator|->
name|atse_rx_buf_len
operator|>=
name|sc
operator|->
name|atse_rx_m
operator|->
name|m_len
operator|-
literal|4
condition|)
block|{
comment|/* 				 * XXX-BZ Error.  We need more mbufs and are 				 * not setup for this yet. 				 */
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|atse_flags
operator||=
name|ATSE_FLAGS_ERROR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|atse_flags
operator|&
name|ATSE_FLAGS_ERROR
operator|)
operator|==
literal|0
condition|)
comment|/* 				 * MUST keep this bcopy as m_data after m_adj 				 * for IP header aligment is on half-word 				 * and not word alignment. 				 */
name|bcopy
argument_list|(
operator|&
name|data
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|atse_rx_m
operator|->
name|m_data
operator|+
name|sc
operator|->
name|atse_rx_buf_len
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|meta
operator|&
name|A_ONCHIP_FIFO_MEM_CORE_EOP
condition|)
block|{
name|uint8_t
name|empty
decl_stmt|;
name|empty
operator|=
operator|(
name|meta
operator|&
name|A_ONCHIP_FIFO_MEM_CORE_EMPTY_MASK
operator|)
operator|>>
name|A_ONCHIP_FIFO_MEM_CORE_EMPTY_SHIFT
expr_stmt|;
name|sc
operator|->
name|atse_rx_buf_len
operator|+=
operator|(
literal|4
operator|-
name|empty
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|rx_npkts
operator|++
expr_stmt|;
name|m
operator|=
name|sc
operator|->
name|atse_rx_m
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|sc
operator|->
name|atse_rx_buf_len
expr_stmt|;
name|sc
operator|->
name|atse_rx_m
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|atse_rx_buf_len
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|atse_flags
operator|&=
operator|~
name|ATSE_FLAGS_SOP_SEEN
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|atse_flags
operator|&
name|ATSE_FLAGS_ERROR
condition|)
block|{
name|sc
operator|->
name|atse_flags
operator|&=
operator|~
name|ATSE_FLAGS_ERROR
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Need to start with a new packet. */
goto|goto
name|outer
goto|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|ATSE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ATSE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|outer
goto|;
comment|/* Need a new mbuf. */
block|}
else|else
block|{
name|sc
operator|->
name|atse_rx_buf_len
operator|+=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* for */
comment|/* XXX-BZ could optimize in case of another packet waiting. */
block|}
do|while
condition|(
operator|(
name|meta
operator|&
name|A_ONCHIP_FIFO_MEM_CORE_EOP
operator|)
operator|==
literal|0
operator|||
name|fill
operator|>
literal|0
condition|)
do|;
return|return
operator|(
name|rx_npkts
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Report current media status.  */
end_comment

begin_function
specifier|static
name|void
name|atse_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ATSE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|atse_miibus
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
name|ATSE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atse_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|rx
decl_stmt|,
name|tx
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|atse_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|atse_ifp
expr_stmt|;
name|ATSE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|ATSE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|ATSE_RX_INTR_DISABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_TX_INTR_DISABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rx
operator|=
name|ATSE_RX_EVENT_READ
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ATSE_TX_EVENT_READ
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rx
operator|&
operator|(
name|A_ONCHIP_FIFO_MEM_CORE_EVENT_OVERFLOW
operator||
name|A_ONCHIP_FIFO_MEM_CORE_EVENT_UNDERFLOW
operator|)
condition|)
block|{
comment|/* XXX-BZ ERROR HANDLING. */
name|atse_update_rx_err
argument_list|(
name|sc
argument_list|,
operator|(
operator|(
name|rx
operator|&
name|A_ONCHIP_FIFO_MEM_CORE_ERROR_MASK
operator|)
operator|>>
name|A_ONCHIP_FIFO_MEM_CORE_ERROR_SHIFT
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rx
operator|&
name|A_ONCHIP_FIFO_MEM_CORE_EVENT_EMPTY
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|atse_rx_cycles
operator|=
name|RX_CYCLES_IN_INTR
expr_stmt|;
name|atse_rx_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tx
operator|!=
literal|0
condition|)
block|{
comment|/* XXX-BZ build histogram. */
if|if
condition|(
name|tx
operator|&
operator|(
name|A_ONCHIP_FIFO_MEM_CORE_EVENT_OVERFLOW
operator||
name|A_ONCHIP_FIFO_MEM_CORE_EVENT_UNDERFLOW
operator|)
condition|)
block|{
comment|/* XXX-BZ ERROR HANDLING. */
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tx
operator|&
name|A_ONCHIP_FIFO_MEM_CORE_EVENT_EMPTY
condition|)
name|sc
operator|->
name|atse_watchdog_timer
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (tx& (A_ONCHIP_FIFO_MEM_CORE_EVENT_EMPTY| 		    A_ONCHIP_FIFO_MEM_CORE_EVENT_ALMOSTEMPTY)) 			atse_start_locked(ifp);
endif|#
directive|endif
block|}
comment|/* Clear events before re-enabling intrs. */
name|ATSE_TX_EVENT_CLEAR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_RX_EVENT_CLEAR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* Re-enable interrupts. */
name|ATSE_RX_INTR_ENABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_TX_INTR_ENABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|atse_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|ATSE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_function
specifier|static
name|int
name|atse_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|rx_npkts
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ATSE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|ATSE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rx_npkts
operator|)
return|;
block|}
name|sc
operator|->
name|atse_rx_cycles
operator|=
name|count
expr_stmt|;
name|rx_npkts
operator|=
name|atse_rx_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|atse_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|atse_rx_cycles
operator|>
literal|0
operator|||
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
condition|)
block|{
name|uint32_t
name|rx
decl_stmt|,
name|tx
decl_stmt|;
name|rx
operator|=
name|ATSE_RX_EVENT_READ
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ATSE_TX_EVENT_READ
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx
operator|&
operator|(
name|A_ONCHIP_FIFO_MEM_CORE_EVENT_OVERFLOW
operator||
name|A_ONCHIP_FIFO_MEM_CORE_EVENT_UNDERFLOW
operator|)
condition|)
block|{
comment|/* XXX-BZ ERROR HANDLING. */
name|atse_update_rx_err
argument_list|(
name|sc
argument_list|,
operator|(
operator|(
name|rx
operator|&
name|A_ONCHIP_FIFO_MEM_CORE_ERROR_MASK
operator|)
operator|>>
name|A_ONCHIP_FIFO_MEM_CORE_ERROR_SHIFT
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tx
operator|&
operator|(
name|A_ONCHIP_FIFO_MEM_CORE_EVENT_OVERFLOW
operator||
name|A_ONCHIP_FIFO_MEM_CORE_EVENT_UNDERFLOW
operator|)
condition|)
block|{
comment|/* XXX-BZ ERROR HANDLING. */
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tx
operator|&
name|A_ONCHIP_FIFO_MEM_CORE_EVENT_EMPTY
condition|)
name|sc
operator|->
name|atse_watchdog_timer
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (
comment|/* Severe error; if only we could find out. */
block|) { 			ifp->if_drv_flags&= ~IFF_DRV_RUNNING; 			atse_init_locked(sc); 		}
endif|#
directive|endif
block|}
name|ATSE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rx_npkts
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_struct
specifier|static
struct|struct
name|atse_mac_stats_regs
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|descr
decl_stmt|;
comment|/* Mostly copied from Altera datasheet. */
block|}
name|atse_mac_stats_regs
index|[]
init|=
block|{
index|[
literal|0x1a
index|]
operator|=
block|{
literal|"aFramesTransmittedOK"
block|,
literal|"The number of frames that are successfully transmitted including "
literal|"the pause frames."
block|}
block|,
block|{
literal|"aFramesReceivedOK"
block|,
literal|"The number of frames that are successfully received including the "
literal|"pause frames."
block|}
block|,
block|{
literal|"aFrameCheckSequenceErrors"
block|,
literal|"The number of receive frames with CRC error."
block|}
block|,
block|{
literal|"aAlignmentErrors"
block|,
literal|"The number of receive frames with alignment error."
block|}
block|,
block|{
literal|"aOctetsTransmittedOK"
block|,
literal|"The lower 32 bits of the number of data and padding octets that "
literal|"are successfully transmitted."
block|}
block|,
block|{
literal|"aOctetsReceivedOK"
block|,
literal|"The lower 32 bits of the number of data and padding octets that "
literal|" are successfully received."
block|}
block|,
block|{
literal|"aTxPAUSEMACCtrlFrames"
block|,
literal|"The number of pause frames transmitted."
block|}
block|,
block|{
literal|"aRxPAUSEMACCtrlFrames"
block|,
literal|"The number received pause frames received."
block|}
block|,
block|{
literal|"ifInErrors"
block|,
literal|"The number of errored frames received."
block|}
block|,
block|{
literal|"ifOutErrors"
block|,
literal|"The number of transmit frames with either a FIFO overflow error, "
literal|"a FIFO underflow error, or a error defined by the user "
literal|"application."
block|}
block|,
block|{
literal|"ifInUcastPkts"
block|,
literal|"The number of valid unicast frames received."
block|}
block|,
block|{
literal|"ifInMulticastPkts"
block|,
literal|"The number of valid multicast frames received. The count does "
literal|"not include pause frames."
block|}
block|,
block|{
literal|"ifInBroadcastPkts"
block|,
literal|"The number of valid broadcast frames received."
block|}
block|,
block|{
literal|"ifOutDiscards"
block|,
literal|"This statistics counter is not in use.  The MAC function does not "
literal|"discard frames that are written to the FIFO buffer by the user "
literal|"application."
block|}
block|,
block|{
literal|"ifOutUcastPkts"
block|,
literal|"The number of valid unicast frames transmitted."
block|}
block|,
block|{
literal|"ifOutMulticastPkts"
block|,
literal|"The number of valid multicast frames transmitted, excluding pause "
literal|"frames."
block|}
block|,
block|{
literal|"ifOutBroadcastPkts"
block|,
literal|"The number of valid broadcast frames transmitted."
block|}
block|,
block|{
literal|"etherStatsDropEvents"
block|,
literal|"The number of frames that are dropped due to MAC internal errors "
literal|"when FIFO buffer overflow persists."
block|}
block|,
block|{
literal|"etherStatsOctets"
block|,
literal|"The lower 32 bits of the total number of octets received. This "
literal|"count includes both good and errored frames."
block|}
block|,
block|{
literal|"etherStatsPkts"
block|,
literal|"The total number of good and errored frames received."
block|}
block|,
block|{
literal|"etherStatsUndersizePkts"
block|,
literal|"The number of frames received with length less than 64 bytes. "
literal|"This count does not include errored frames."
block|}
block|,
block|{
literal|"etherStatsOversizePkts"
block|,
literal|"The number of frames received that are longer than the value "
literal|"configured in the frm_length register. This count does not "
literal|"include errored frames."
block|}
block|,
block|{
literal|"etherStatsPkts64Octets"
block|,
literal|"The number of 64-byte frames received. This count includes good "
literal|"and errored frames."
block|}
block|,
block|{
literal|"etherStatsPkts65to127Octets"
block|,
literal|"The number of received good and errored frames between the length "
literal|"of 65 and 127 bytes."
block|}
block|,
block|{
literal|"etherStatsPkts128to255Octets"
block|,
literal|"The number of received good and errored frames between the length "
literal|"of 128 and 255 bytes."
block|}
block|,
block|{
literal|"etherStatsPkts256to511Octets"
block|,
literal|"The number of received good and errored frames between the length "
literal|"of 256 and 511 bytes."
block|}
block|,
block|{
literal|"etherStatsPkts512to1023Octets"
block|,
literal|"The number of received good and errored frames between the length "
literal|"of 512 and 1023 bytes."
block|}
block|,
block|{
literal|"etherStatsPkts1024to1518Octets"
block|,
literal|"The number of received good and errored frames between the length "
literal|"of 1024 and 1518 bytes."
block|}
block|,
block|{
literal|"etherStatsPkts1519toXOctets"
block|,
literal|"The number of received good and errored frames between the length "
literal|"of 1519 and the maximum frame length configured in the frm_length "
literal|"register."
block|}
block|,
block|{
literal|"etherStatsJabbers"
block|,
literal|"Too long frames with CRC error."
block|}
block|,
block|{
literal|"etherStatsFragments"
block|,
literal|"Too short frames with CRC error."
block|}
block|,
comment|/* 0x39 unused, 0x3a/b non-stats. */
index|[
literal|0x3c
index|]
operator|=
comment|/* Extended Statistics Counters */
block|{
literal|"msb_aOctetsTransmittedOK"
block|,
literal|"Upper 32 bits of the number of data and padding octets that are "
literal|"successfully transmitted."
block|}
block|,
block|{
literal|"msb_aOctetsReceivedOK"
block|,
literal|"Upper 32 bits of the number of data and padding octets that are "
literal|"successfully received."
block|}
block|,
block|{
literal|"msb_etherStatsOctets"
block|,
literal|"Upper 32 bits of the total number of octets received. This count "
literal|"includes both good and errored frames."
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|sysctl_atse_mac_stats_proc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|offset
decl_stmt|,
name|s
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|offset
operator|=
name|arg2
expr_stmt|;
name|s
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|s
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|atse_rx_err_stats_regs
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|descr
decl_stmt|;
block|}
name|atse_rx_err_stats_regs
index|[]
init|=
block|{
define|#
directive|define
name|ATSE_RX_ERR_FIFO_THRES_EOP
value|0
comment|/* FIFO threshold reached, on EOP. */
define|#
directive|define
name|ATSE_RX_ERR_ELEN
value|1
comment|/* Frame/payload length not valid. */
define|#
directive|define
name|ATSE_RX_ERR_CRC32
value|2
comment|/* CRC-32 error. */
define|#
directive|define
name|ATSE_RX_ERR_FIFO_THRES_TRUNC
value|3
comment|/* FIFO thresh., truncated frame. */
define|#
directive|define
name|ATSE_RX_ERR_4
value|4
comment|/* ? */
define|#
directive|define
name|ATSE_RX_ERR_5
value|5
comment|/* / */
block|{
literal|"rx_err_fifo_thres_eop"
block|,
literal|"FIFO threshold reached, reported on EOP."
block|}
block|,
block|{
literal|"rx_err_fifo_elen"
block|,
literal|"Frame or payload length not valid."
block|}
block|,
block|{
literal|"rx_err_fifo_crc32"
block|,
literal|"CRC-32 error."
block|}
block|,
block|{
literal|"rx_err_fifo_thres_trunc"
block|,
literal|"FIFO threshold reached, truncated frame"
block|}
block|,
block|{
literal|"rx_err_4"
block|,
literal|"?"
block|}
block|,
block|{
literal|"rx_err_5"
block|,
literal|"?"
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|int
name|sysctl_atse_rx_err_stats_proc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|offset
decl_stmt|,
name|s
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|offset
operator|=
name|arg2
expr_stmt|;
name|s
operator|=
name|sc
operator|->
name|atse_rx_err
index|[
name|offset
index|]
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|s
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atse_sysctl_stats_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|sctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|soid
decl_stmt|;
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|soid
operator|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* MAC statistics. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|atse_mac_stats_regs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|atse_mac_stats_regs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|atse_mac_stats_regs
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
operator|||
name|atse_mac_stats_regs
index|[
name|i
index|]
operator|.
name|descr
operator|==
name|NULL
condition|)
continue|continue;
name|SYSCTL_ADD_PROC
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|atse_mac_stats_regs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
name|i
argument_list|,
name|sysctl_atse_mac_stats_proc
argument_list|,
literal|"IU"
argument_list|,
name|atse_mac_stats_regs
index|[
name|i
index|]
operator|.
name|descr
argument_list|)
expr_stmt|;
block|}
comment|/* rx_err[]. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ATSE_RX_ERR_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|atse_rx_err_stats_regs
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
operator|||
name|atse_rx_err_stats_regs
index|[
name|i
index|]
operator|.
name|descr
operator|==
name|NULL
condition|)
continue|continue;
name|SYSCTL_ADD_PROC
argument_list|(
name|sctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|soid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|atse_rx_err_stats_regs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
name|i
argument_list|,
name|sysctl_atse_rx_err_stats_proc
argument_list|,
literal|"IU"
argument_list|,
name|atse_rx_err_stats_regs
index|[
name|i
index|]
operator|.
name|descr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Generic device handling routines.  */
end_comment

begin_function
name|int
name|atse_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|atse_ethernet_option_bits_read
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|atse_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|atse_tick
argument_list|,
operator|&
name|sc
operator|->
name|atse_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_tx_buf
operator|=
name|malloc
argument_list|(
name|ETHER_MAX_LEN_JUMBO
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * We are only doing single-PHY with this driver currently.  The 	 * defaults would be right so that BASE_CFG_MDIO_ADDR0 points to the 	 * 1st PHY address (0) apart from the fact that BMCR0 is always 	 * the PCS mapping, so we always use BMCR1. See Table 5-1 0xA0-0xBF. 	 */
if|#
directive|if
literal|0
comment|/* Always PCS. */
block|sc->atse_bmcr0 = MDIO_0_START; 	CSR_WRITE_4(sc, BASE_CFG_MDIO_ADDR0, 0x00);
endif|#
directive|endif
comment|/* Always use matching PHY for atse[0..]. */
name|sc
operator|->
name|atse_phy_addr
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_bmcr1
operator|=
name|MDIO_1_START
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_MDIO_ADDR1
argument_list|,
name|sc
operator|->
name|atse_phy_addr
argument_list|)
expr_stmt|;
comment|/* Reset the adapter. */
name|atse_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Setup interface. */
name|ifp
operator|=
name|sc
operator|->
name|atse_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"if_alloc() failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|atse_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|atse_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|atse_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ATSE_TX_LIST_CNT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|ATSE_TX_LIST_CNT
operator|-
literal|1
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* MII setup. */
name|error
operator|=
name|mii_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|atse_miibus
argument_list|,
name|ifp
argument_list|,
name|atse_ifmedia_upd
argument_list|,
name|atse_ifmedia_sts
argument_list|,
name|BMSR_DEFCAPMASK
argument_list|,
name|MII_PHY_ANY
argument_list|,
name|MII_OFFSET_ANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"attaching PHY failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Call media-indepedent attach routine. */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|atse_eth_addr
argument_list|)
expr_stmt|;
comment|/* Tell the upper layer(s) about vlan mtu support. */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* We will enable polling by default if no irqs available. See below. */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_POLLING
expr_stmt|;
endif|#
directive|endif
comment|/* Hook up interrupts. */
if|if
condition|(
name|sc
operator|->
name|atse_rx_irq_res
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|atse_rx_irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|atse_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|atse_rx_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"enabling RX IRQ failed\n"
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|atse_tx_irq_res
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|atse_tx_irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|atse_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|atse_tx_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|atse_rx_irq_res
argument_list|,
name|sc
operator|->
name|atse_rx_intrhand
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"enabling TX IRQ failed\n"
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
operator|!=
literal|0
operator|||
operator|(
name|sc
operator|->
name|atse_rx_irq_res
operator|==
name|NULL
operator|&&
name|sc
operator|->
name|atse_tx_irq_res
operator|==
name|NULL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* If not on and no IRQs force it on. */
if|if
condition|(
name|sc
operator|->
name|atse_rx_irq_res
operator|==
name|NULL
operator|&&
name|sc
operator|->
name|atse_tx_irq_res
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"forcing to polling due to no "
literal|"interrupts\n"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ether_poll_register
argument_list|(
name|atse_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
else|#
directive|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"no DEVICE_POLLING in kernel and no IRQs\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|ATSE_RX_INTR_ENABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_TX_INTR_ENABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|err
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|atse_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|atse_sysctl_stats_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atse_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|atse_mtx
argument_list|)
argument_list|,
operator|(
literal|"%s: mutex not initialized"
operator|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|atse_ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Only cleanup if attach succeeded. */
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ATSE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|atse_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATSE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|atse_tick
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|atse_miibus
operator|!=
name|NULL
condition|)
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|atse_miibus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|atse_tx_intrhand
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|atse_tx_irq_res
argument_list|,
name|sc
operator|->
name|atse_tx_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|atse_rx_intrhand
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|atse_rx_irq_res
argument_list|,
name|sc
operator|->
name|atse_rx_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|atse_tx_buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|atse_tx_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|atse_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Shared between nexus and fdt implementation. */
end_comment

begin_function
name|void
name|atse_detach_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|atse_txc_mem_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|atse_txc_mem_rid
argument_list|,
name|sc
operator|->
name|atse_txc_mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_txc_mem_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|atse_tx_mem_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|atse_tx_mem_rid
argument_list|,
name|sc
operator|->
name|atse_tx_mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_tx_mem_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|atse_tx_irq_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|atse_tx_irq_rid
argument_list|,
name|sc
operator|->
name|atse_tx_irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_tx_irq_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|atse_rxc_mem_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|atse_rxc_mem_rid
argument_list|,
name|sc
operator|->
name|atse_rxc_mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_rxc_mem_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|atse_rx_mem_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|atse_rx_mem_rid
argument_list|,
name|sc
operator|->
name|atse_rx_mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_rx_mem_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|atse_rx_irq_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|atse_rx_irq_rid
argument_list|,
name|sc
operator|->
name|atse_rx_irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_rx_irq_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|atse_mem_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|atse_mem_rid
argument_list|,
name|sc
operator|->
name|atse_mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|atse_mem_res
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|atse_detach_dev
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|atse_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* We are basically in undefined state now. */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"atse_detach() failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|atse_detach_resources
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|atse_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * We currently do not support re-mapping of MDIO space on-the-fly 	 * but de-facto hard-code the phy#. 	 */
if|if
condition|(
name|phy
operator|!=
name|sc
operator|->
name|atse_phy_addr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|atse_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * We currently do not support re-mapping of MDIO space on-the-fly 	 * but de-facto hard-code the phy#. 	 */
if|if
condition|(
name|phy
operator|!=
name|sc
operator|->
name|atse_phy_addr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|atse_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|atse_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|val4
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ATSE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|atse_miibus
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|atse_ifp
expr_stmt|;
if|if
condition|(
name|mii
operator|==
name|NULL
operator|||
name|ifp
operator|==
name|NULL
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|val4
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|)
expr_stmt|;
comment|/* Assume no link. */
name|sc
operator|->
name|atse_flags
operator|&=
operator|~
name|ATSE_FLAGS_LINK
expr_stmt|;
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_status
operator|&
operator|(
name|IFM_ACTIVE
operator||
name|IFM_AVALID
operator|)
operator|)
operator|==
operator|(
name|IFM_ACTIVE
operator||
name|IFM_AVALID
operator|)
condition|)
block|{
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_10_T
case|:
name|val4
operator||=
name|BASE_CFG_COMMAND_CONFIG_ENA_10
expr_stmt|;
name|val4
operator|&=
operator|~
name|BASE_CFG_COMMAND_CONFIG_ETH_SPEED
expr_stmt|;
name|sc
operator|->
name|atse_flags
operator||=
name|ATSE_FLAGS_LINK
expr_stmt|;
break|break;
case|case
name|IFM_100_TX
case|:
name|val4
operator|&=
operator|~
name|BASE_CFG_COMMAND_CONFIG_ENA_10
expr_stmt|;
name|val4
operator|&=
operator|~
name|BASE_CFG_COMMAND_CONFIG_ETH_SPEED
expr_stmt|;
name|sc
operator|->
name|atse_flags
operator||=
name|ATSE_FLAGS_LINK
expr_stmt|;
break|break;
case|case
name|IFM_1000_T
case|:
name|val4
operator|&=
operator|~
name|BASE_CFG_COMMAND_CONFIG_ENA_10
expr_stmt|;
name|val4
operator||=
name|BASE_CFG_COMMAND_CONFIG_ETH_SPEED
expr_stmt|;
name|sc
operator|->
name|atse_flags
operator||=
name|ATSE_FLAGS_LINK
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|atse_flags
operator|&
name|ATSE_FLAGS_LINK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX-BZ need to stop the MAC? */
return|return;
block|}
if|if
condition|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_FDX
argument_list|)
operator|!=
literal|0
condition|)
name|val4
operator|&=
operator|~
name|BASE_CFG_COMMAND_CONFIG_HD_ENA
expr_stmt|;
else|else
name|val4
operator||=
name|BASE_CFG_COMMAND_CONFIG_HD_ENA
expr_stmt|;
comment|/* XXX-BZ flow control? */
comment|/* Make sure the MAC is activated. */
name|val4
operator||=
name|BASE_CFG_COMMAND_CONFIG_TX_ENA
expr_stmt|;
name|val4
operator||=
name|BASE_CFG_COMMAND_CONFIG_RX_ENA
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|BASE_CFG_COMMAND_CONFIG
argument_list|,
name|val4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end */
end_comment

end_unit

