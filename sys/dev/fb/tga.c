begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000, 2001 Andrew Miklic, Andrew Gallatin, Peter Jeremy,  * and Thomas V. Crimi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995, 1996 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Chris G. Demetriou  *   * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND   * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fbio.h>
end_include

begin_include
include|#
directive|include
file|<sys/consio.h>
end_include

begin_include
include|#
directive|include
file|<isa/isareg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/vgareg.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/bios.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/vesa.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/rpb.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/fbreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/syscons/syscons.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/gfb.h>
end_include

begin_include
include|#
directive|include
file|<dev/gfb/gfb_pci.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/tga.h>
end_include

begin_include
include|#
directive|include
file|<dev/tga/tga_pci.h>
end_include

begin_include
include|#
directive|include
file|"opt_fb.h"
end_include

begin_comment
comment|/* TGA-specific FB video driver function declarations */
end_comment

begin_function_decl
specifier|static
name|int
name|tga_error
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|vi_init_t
name|tga_init
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|tga2_init
parameter_list|(
name|struct
name|gfb_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* TGA-specific functionality. */
end_comment

begin_decl_stmt
specifier|static
name|gfb_builtin_save_palette_t
name|tga_builtin_save_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_builtin_load_palette_t
name|tga_builtin_load_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_builtin_save_palette_t
name|tga2_builtin_save_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_builtin_load_palette_t
name|tga2_builtin_load_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_builtin_save_cursor_palette_t
name|tga2_builtin_save_cursor_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_builtin_load_cursor_palette_t
name|tga2_builtin_load_cursor_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_builtin_read_hw_cursor_t
name|tga_builtin_read_hw_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_builtin_set_hw_cursor_t
name|tga_builtin_set_hw_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_builtin_set_hw_cursor_shape_t
name|tga_builtin_set_hw_cursor_shape
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|bt463_load_palette_intr
parameter_list|(
name|struct
name|gfb_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bt463_load_cursor_palette_intr
parameter_list|(
name|struct
name|gfb_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tga_schedule_intr
parameter_list|(
name|struct
name|gfb_softc
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|gfb_softc
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* RAMDAC interface functions */
end_comment

begin_decl_stmt
specifier|static
name|gfb_ramdac_wr_t
name|tga_bt485_wr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_rd_t
name|tga_bt485_rd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_wr_t
name|tga_bt463_wr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_rd_t
name|tga_bt463_rd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_wr_t
name|tga2_ibm561_wr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_rd_t
name|tga2_ibm561_rd
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|tga2_ics9110_wr
parameter_list|(
name|struct
name|gfb_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* RAMDAC-specific functions */
end_comment

begin_decl_stmt
specifier|static
name|gfb_ramdac_init_t
name|bt463_init
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|bt463_update_window_type
parameter_list|(
name|struct
name|gfb_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|gfb_ramdac_save_palette_t
name|bt463_save_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_load_palette_t
name|bt463_load_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_save_cursor_palette_t
name|bt463_save_cursor_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_load_cursor_palette_t
name|bt463_load_cursor_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_init_t
name|bt485_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_save_palette_t
name|bt485_save_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_load_palette_t
name|bt485_load_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_save_cursor_palette_t
name|bt485_save_cursor_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_load_cursor_palette_t
name|bt485_load_cursor_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_read_hw_cursor_t
name|bt485_read_hw_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_set_hw_cursor_t
name|bt485_set_hw_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_set_hw_cursor_shape_t
name|bt485_set_hw_cursor_shape
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_init_t
name|ibm561_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_save_palette_t
name|ibm561_save_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_load_palette_t
name|ibm561_load_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_save_cursor_palette_t
name|ibm561_save_cursor_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gfb_ramdac_load_cursor_palette_t
name|ibm561_load_cursor_palette
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Video Driver-generic functions */
end_comment

begin_decl_stmt
specifier|static
name|vi_query_mode_t
name|tga_query_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_mode_t
name|tga_set_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_blank_display_t
name|tga_blank_display
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_ioctl_t
name|tga_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_border_t
name|tga_set_border
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_win_org_t
name|tga_set_win_org
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_fill_rect_t
name|tga_fill_rect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_bitblt_t
name|tga_bitblt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_clear_t
name|tga_clear
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_putc_t
name|tga_putc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_puts_t
name|tga_puts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_putm_t
name|tga_putm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|video_switch_t
name|tgavidsw
init|=
block|{
name|gfb_probe
block|,
name|tga_init
block|,
name|gfb_get_info
block|,
name|tga_query_mode
block|,
name|tga_set_mode
block|,
name|gfb_save_font
block|,
name|gfb_load_font
block|,
name|gfb_show_font
block|,
name|gfb_save_palette
block|,
name|gfb_load_palette
block|,
name|tga_set_border
block|,
name|gfb_save_state
block|,
name|gfb_load_state
block|,
name|tga_set_win_org
block|,
name|gfb_read_hw_cursor
block|,
name|gfb_set_hw_cursor
block|,
name|gfb_set_hw_cursor_shape
block|,
name|tga_blank_display
block|,
name|gfb_mmap
block|,
name|gfb_ioctl
block|,
name|tga_clear
block|,
name|tga_fill_rect
block|,
name|tga_bitblt
block|,
name|tga_error
block|,
name|tga_error
block|,
name|gfb_diag
block|,
name|gfb_save_cursor_palette
block|,
name|gfb_load_cursor_palette
block|,
name|gfb_copy
block|,
name|gfb_putp
block|,
name|tga_putc
block|,
name|tga_puts
block|,
name|tga_putm
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VIDEO_DRIVER
argument_list|(
name|tga
argument_list|,
name|tgavidsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|sc_rndr_sw_t
name|txtrndrsw
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|RENDERER
argument_list|(
name|tga
argument_list|,
literal|0
argument_list|,
name|txtrndrsw
argument_list|,
name|gfb_set
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SC_PIXEL_MODE
end_ifdef

begin_decl_stmt
specifier|extern
name|sc_rndr_sw_t
name|gfbrndrsw
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|RENDERER
argument_list|(
name|tga
argument_list|,
name|PIXEL_MODE
argument_list|,
name|gfbrndrsw
argument_list|,
name|gfb_set
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SC_PIXEL_MODE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SC_NO_MODE_CHANGE
end_ifndef

begin_decl_stmt
specifier|extern
name|sc_rndr_sw_t
name|grrndrsw
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|RENDERER
argument_list|(
name|tga
argument_list|,
name|GRAPHICS_MODE
argument_list|,
name|grrndrsw
argument_list|,
name|gfb_set
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SC_NO_MODE_CHANGE */
end_comment

begin_expr_stmt
name|RENDERER_MODULE
argument_list|(
name|tga
argument_list|,
name|gfb_set
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MHz
value|* 1000000
end_define

begin_define
define|#
directive|define
name|KHz
value|* 1000
end_define

begin_decl_stmt
specifier|extern
name|struct
name|gfb_softc
modifier|*
name|gfb_device_softcs
index|[
literal|2
index|]
index|[
name|MAX_NUM_GFB_CARDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    The following 3 variables exist only because we need statically    allocated structures very early in boot to support tga_configure()... */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|gfb_softc
name|console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|video_adapter_t
name|console_adp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|gfb_conf
name|console_gfbc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|console_palette_red
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|console_palette_green
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|console_palette_blue
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|console_cursor_palette_red
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|console_cursor_palette_green
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|console_cursor_palette_blue
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|monitor
name|decmonitors
index|[]
init|=
block|{
comment|/* 0x0: 1280 x 1024 @ 72Hz */
block|{
literal|1280
block|,
literal|32
block|,
literal|160
block|,
literal|232
block|,
literal|1024
block|,
literal|3
block|,
literal|3
block|,
literal|33
block|,
literal|130808
name|KHz
block|}
block|,
comment|/* 0x1: 1280 x 1024 @ 66Hz */
block|{
literal|1280
block|,
literal|32
block|,
literal|160
block|,
literal|232
block|,
literal|1024
block|,
literal|3
block|,
literal|3
block|,
literal|33
block|,
literal|119840
name|KHz
block|}
block|,
comment|/* 0x2: 1280 x 1024 @ 60Hz */
block|{
literal|1280
block|,
literal|44
block|,
literal|184
block|,
literal|200
block|,
literal|1024
block|,
literal|3
block|,
literal|3
block|,
literal|26
block|,
literal|108180
name|KHz
block|}
block|,
comment|/* 0x3: 1152 x  900 @ 72Hz */
block|{
literal|1152
block|,
literal|64
block|,
literal|112
block|,
literal|176
block|,
literal|900
block|,
literal|6
block|,
literal|10
block|,
literal|44
block|,
literal|103994
name|KHz
block|}
block|,
comment|/* 0x4: 1600 x 1200 @ 65Hz */
block|{
literal|1600
block|,
literal|32
block|,
literal|192
block|,
literal|336
block|,
literal|1200
block|,
literal|1
block|,
literal|3
block|,
literal|46
block|,
literal|175
name|MHz
block|}
block|,
comment|/* 0x5: 1024 x  768 @ 70Hz */
block|{
literal|1024
block|,
literal|24
block|,
literal|136
block|,
literal|144
block|,
literal|768
block|,
literal|3
block|,
literal|6
block|,
literal|29
block|,
literal|75
name|MHz
block|}
block|,
comment|/* 0x6: 1024 x  768 @ 72Hz */
block|{
literal|1024
block|,
literal|16
block|,
literal|128
block|,
literal|128
block|,
literal|768
block|,
literal|1
block|,
literal|6
block|,
literal|22
block|,
literal|74
name|MHz
block|}
block|,
comment|/* 0x7: 1024 x  864 @ 60Hz */
block|{
literal|1024
block|,
literal|12
block|,
literal|128
block|,
literal|116
block|,
literal|864
block|,
literal|0
block|,
literal|3
block|,
literal|34
block|,
literal|69
name|MHz
block|}
block|,
comment|/* 0x8: 1024 x  768 @ 60Hz */
block|{
literal|1024
block|,
literal|56
block|,
literal|64
block|,
literal|200
block|,
literal|768
block|,
literal|7
block|,
literal|9
block|,
literal|26
block|,
literal|65
name|MHz
block|}
block|,
comment|/* 0x9:  800 x  600 @ 72Hz */
block|{
literal|800
block|,
literal|56
block|,
literal|120
block|,
literal|64
block|,
literal|600
block|,
literal|37
block|,
literal|6
block|,
literal|23
block|,
literal|50
name|MHz
block|}
block|,
comment|/* 0xa:  800 x  600 @ 60Hz */
block|{
literal|800
block|,
literal|40
block|,
literal|128
block|,
literal|88
block|,
literal|600
block|,
literal|1
block|,
literal|4
block|,
literal|23
block|,
literal|40
name|MHz
block|}
block|,
comment|/* 0xb:  640 x  480 @ 72Hz */
block|{
literal|640
block|,
literal|24
block|,
literal|40
block|,
literal|128
block|,
literal|480
block|,
literal|9
block|,
literal|3
block|,
literal|28
block|,
literal|31500
name|KHz
block|}
block|,
comment|/* 0xc:  640 x  480 @ 60Hz */
block|{
literal|640
block|,
literal|16
block|,
literal|96
block|,
literal|48
block|,
literal|480
block|,
literal|10
block|,
literal|2
block|,
literal|33
block|,
literal|25175
name|KHz
block|}
block|,
comment|/* 0xd: 1280 x 1024 @ 75Hz */
block|{
literal|1280
block|,
literal|16
block|,
literal|144
block|,
literal|248
block|,
literal|1024
block|,
literal|1
block|,
literal|3
block|,
literal|38
block|,
literal|135
name|MHz
block|}
block|,
comment|/* 0xe: 1280 x 1024 @ 60Hz */
block|{
literal|1280
block|,
literal|19
block|,
literal|163
block|,
literal|234
block|,
literal|1024
block|,
literal|6
block|,
literal|7
block|,
literal|44
block|,
literal|110
name|MHz
block|}
block|,
comment|/* 0xf: 1600 x 1200 @ 75Hz */
comment|/* XXX -- this one's weird.  rcd */
block|{
literal|1600
block|,
literal|32
block|,
literal|192
block|,
literal|336
block|,
literal|1200
block|,
literal|1
block|,
literal|3
block|,
literal|46
block|,
literal|202500
name|KHz
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|MHz
end_undef

begin_undef
undef|#
directive|undef
name|KHz
end_undef

begin_undef
undef|#
directive|undef
name|KB
end_undef

begin_define
define|#
directive|define
name|KB
value|* 1024
end_define

begin_undef
undef|#
directive|undef
name|MB
end_undef

begin_define
define|#
directive|define
name|MB
value|* 1024 * 1024
end_define

begin_comment
comment|/*  * These are the 16 default VGA colors--these are replicated 16 times as the  * initial (default) color-map.  The text rendering functions use entries  * 0..15 for normal foreground/background colors.  The entries 128..255 are  * used for blinking entries--when "on," they contain the foreground color  * entries; when "off," they contain the background color entries...  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|cmap
block|{
name|u_char
name|red
decl_stmt|;
name|u_char
name|green
decl_stmt|;
name|u_char
name|blue
decl_stmt|;
block|}
name|default_cmap
index|[
literal|16
index|]
init|=
block|{
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* Black */
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
comment|/* Blue */
block|{
literal|0x00
block|,
literal|0xff
block|,
literal|0x00
block|}
block|,
comment|/* Green */
block|{
literal|0x00
block|,
literal|0xc0
block|,
literal|0xc0
block|}
block|,
comment|/* Cyan */
block|{
literal|0xff
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* Red */
block|{
literal|0xc0
block|,
literal|0x00
block|,
literal|0xc0
block|}
block|,
comment|/* Magenta */
block|{
literal|0xc0
block|,
literal|0xc0
block|,
literal|0x00
block|}
block|,
comment|/* Brown */
block|{
literal|0xc0
block|,
literal|0xc0
block|,
literal|0xc0
block|}
block|,
comment|/* Light Grey */
block|{
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|}
block|,
comment|/* Dark Grey */
block|{
literal|0x80
block|,
literal|0x80
block|,
literal|0xff
block|}
block|,
comment|/* Light Blue */
block|{
literal|0x80
block|,
literal|0xff
block|,
literal|0x80
block|}
block|,
comment|/* Light Green */
block|{
literal|0x80
block|,
literal|0xff
block|,
literal|0xff
block|}
block|,
comment|/* Light Cyan */
block|{
literal|0xff
block|,
literal|0x80
block|,
literal|0x80
block|}
block|,
comment|/* Light Red */
block|{
literal|0xff
block|,
literal|0x80
block|,
literal|0xff
block|}
block|,
comment|/* Light Magenta */
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0x80
block|}
block|,
comment|/* Yellow */
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
comment|/* White */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|gfb_font
name|bold8x16
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************************  *  * FB-generic functions  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|tga_init
parameter_list|(
name|int
name|unit
parameter_list|,
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|gfb_conf
modifier|*
name|gfbc
decl_stmt|;
name|unsigned
name|int
name|monitor
decl_stmt|;
name|int
name|card_type
decl_stmt|;
name|int
name|gder
decl_stmt|;
name|int
name|deep
decl_stmt|;
name|int
name|addrmask
decl_stmt|;
name|int
name|cs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|gfb_reg_t
name|ccbr
decl_stmt|;
comment|/* Assume the best... */
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|unit
index|]
expr_stmt|;
name|gfbc
operator|=
name|sc
operator|->
name|gfbc
expr_stmt|;
comment|/* Initialize palette counts... */
name|gfbc
operator|->
name|palette
operator|.
name|count
operator|=
literal|256
expr_stmt|;
name|gfbc
operator|->
name|cursor_palette
operator|.
name|count
operator|=
literal|3
expr_stmt|;
comment|/* Initialize the adapter... */
name|gder
operator|=
name|BASIC_READ_TGA_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GDER
argument_list|)
expr_stmt|;
name|addrmask
operator|=
operator|(
name|gder
operator|&
name|GDER_ADDR_MASK
operator|)
operator|>>
name|GDER_ADDR_SHIFT
expr_stmt|;
name|deep
operator|=
operator|(
name|gder
operator|&
name|GDER_DEEP
operator|)
operator|!=
literal|0
expr_stmt|;
name|cs
operator|=
operator|(
name|gder
operator|&
name|GDER_CS
operator|)
operator|==
literal|0
expr_stmt|;
name|card_type
operator|=
name|TGA_TYPE_UNKNOWN
expr_stmt|;
name|adp
operator|->
name|va_little_bitian
operator|=
literal|1
expr_stmt|;
name|adp
operator|->
name|va_little_endian
operator|=
literal|0
expr_stmt|;
name|adp
operator|->
name|va_initial_mode
operator|=
literal|0
expr_stmt|;
name|adp
operator|->
name|va_initial_bios_mode
operator|=
literal|0
expr_stmt|;
name|adp
operator|->
name|va_mode
operator|=
literal|0
expr_stmt|;
name|adp
operator|->
name|va_info
operator|.
name|vi_mem_model
operator|=
name|V_INFO_MM_TEXT
expr_stmt|;
name|adp
operator|->
name|va_info
operator|.
name|vi_mode
operator|=
name|M_VGA_M80x30
expr_stmt|;
name|adp
operator|->
name|va_info
operator|.
name|vi_flags
operator|=
name|V_INFO_COLOR
expr_stmt|;
name|adp
operator|->
name|va_buffer
operator|=
name|adp
operator|->
name|va_mem_base
expr_stmt|;
name|adp
operator|->
name|va_buffer_size
operator|=
literal|4
name|MB
operator|*
operator|(
literal|1
operator|+
name|addrmask
operator|)
expr_stmt|;
name|adp
operator|->
name|va_registers
operator|=
name|adp
operator|->
name|va_buffer
operator|+
name|TGA_REG_SPACE_OFFSET
expr_stmt|;
name|adp
operator|->
name|va_registers_size
operator|=
literal|2
name|KB
expr_stmt|;
name|adp
operator|->
name|va_window
operator|=
name|adp
operator|->
name|va_buffer
operator|+
operator|(
name|adp
operator|->
name|va_buffer_size
operator|/
literal|2
operator|)
expr_stmt|;
name|adp
operator|->
name|va_info
operator|.
name|vi_window
operator|=
name|vtophys
argument_list|(
name|adp
operator|->
name|va_window
argument_list|)
expr_stmt|;
name|adp
operator|->
name|va_window_size
operator|=
operator|(
name|deep
condition|?
literal|4
name|MB
else|:
literal|2
name|MB
operator|)
expr_stmt|;
name|adp
operator|->
name|va_info
operator|.
name|vi_window_size
operator|=
name|adp
operator|->
name|va_window_size
expr_stmt|;
name|adp
operator|->
name|va_window_gran
operator|=
name|adp
operator|->
name|va_window_size
expr_stmt|;
name|adp
operator|->
name|va_info
operator|.
name|vi_window_gran
operator|=
name|adp
operator|->
name|va_window_gran
expr_stmt|;
name|adp
operator|->
name|va_info
operator|.
name|vi_buffer
operator|=
name|vtophys
argument_list|(
name|adp
operator|->
name|va_buffer
argument_list|)
expr_stmt|;
name|adp
operator|->
name|va_info
operator|.
name|vi_buffer_size
operator|=
name|adp
operator|->
name|va_buffer_size
expr_stmt|;
name|adp
operator|->
name|va_disp_start
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|adp
operator|->
name|va_disp_start
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|adp
operator|->
name|va_info
operator|.
name|vi_depth
operator|=
operator|(
name|deep
condition|?
literal|32
else|:
literal|8
operator|)
expr_stmt|;
name|adp
operator|->
name|va_info
operator|.
name|vi_planes
operator|=
name|adp
operator|->
name|va_info
operator|.
name|vi_depth
operator|/
literal|8
expr_stmt|;
name|adp
operator|->
name|va_info
operator|.
name|vi_width
operator|=
operator|(
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VHCR
argument_list|)
operator|&
name|VHCR_ACTIVE_MASK
operator|)
expr_stmt|;
name|adp
operator|->
name|va_info
operator|.
name|vi_width
operator||=
operator|(
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VHCR
argument_list|)
operator|&
literal|0x30000000
operator|)
operator|>>
literal|19
expr_stmt|;
switch|switch
condition|(
name|adp
operator|->
name|va_info
operator|.
name|vi_width
condition|)
block|{
case|case
literal|0
case|:
name|adp
operator|->
name|va_info
operator|.
name|vi_width
operator|=
literal|8192
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|adp
operator|->
name|va_info
operator|.
name|vi_width
operator|=
literal|8196
expr_stmt|;
break|break;
default|default:
name|adp
operator|->
name|va_info
operator|.
name|vi_width
operator|*=
literal|4
expr_stmt|;
break|break;
block|}
name|adp
operator|->
name|va_info
operator|.
name|vi_height
operator|=
operator|(
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VVCR
argument_list|)
operator|&
name|VVCR_ACTIVE_MASK
operator|)
expr_stmt|;
name|adp
operator|->
name|va_line_width
operator|=
name|adp
operator|->
name|va_info
operator|.
name|vi_width
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_depth
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VHCR
argument_list|)
operator|&
name|VHCR_ODD
condition|)
name|adp
operator|->
name|va_info
operator|.
name|vi_width
operator|-=
literal|4
expr_stmt|;
comment|/* 	   Set the video base address and the cursor base address to 	   something known such that the video base address is at 	   least 1 KB past the cursor base address (the cursor is 1 KB 	   in size, so leave room for it)...we pick 4 KB  and 0 KB, 	   respectively, since they begin at the top of the framebuffer 	   for minimal fragmentation of the address space, and this will 	   always leave enough room for the cursor for all implementations... 	*/
comment|/* Set the video base address... */
name|tga_set_win_org
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
literal|4
name|KB
argument_list|)
expr_stmt|;
comment|/* Set the cursor base address... */
name|ccbr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_CCBR
argument_list|)
expr_stmt|;
name|ccbr
operator|=
operator|(
name|ccbr
operator|&
literal|0xfffffc0f
operator|)
operator||
operator|(
literal|0
operator|<<
literal|4
operator|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_CCBR
argument_list|,
name|ccbr
argument_list|)
expr_stmt|;
comment|/* Type the card... */
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_TGA
condition|)
block|{
if|if
condition|(
operator|!
name|deep
condition|)
block|{
comment|/* 8bpp frame buffer */
name|gfbc
operator|->
name|ramdac_name
operator|=
literal|"BT485"
expr_stmt|;
name|gfbc
operator|->
name|ramdac_init
operator|=
name|bt485_init
expr_stmt|;
name|gfbc
operator|->
name|ramdac_rd
operator|=
name|tga_bt485_rd
expr_stmt|;
name|gfbc
operator|->
name|ramdac_wr
operator|=
name|tga_bt485_wr
expr_stmt|;
name|gfbc
operator|->
name|ramdac_save_palette
operator|=
name|bt485_save_palette
expr_stmt|;
name|gfbc
operator|->
name|ramdac_load_palette
operator|=
name|bt485_load_palette
expr_stmt|;
name|gfbc
operator|->
name|ramdac_save_cursor_palette
operator|=
name|bt485_save_cursor_palette
expr_stmt|;
name|gfbc
operator|->
name|ramdac_load_cursor_palette
operator|=
name|bt485_load_cursor_palette
expr_stmt|;
name|gfbc
operator|->
name|ramdac_read_hw_cursor
operator|=
name|bt485_read_hw_cursor
expr_stmt|;
name|gfbc
operator|->
name|ramdac_set_hw_cursor
operator|=
name|bt485_set_hw_cursor
expr_stmt|;
name|gfbc
operator|->
name|ramdac_set_hw_cursor_shape
operator|=
name|bt485_set_hw_cursor_shape
expr_stmt|;
if|if
condition|(
name|addrmask
operator|==
name|GDER_ADDR_4MB
condition|)
block|{
comment|/* 4MB core map; T8-01 or T8-02 */
if|if
condition|(
operator|!
name|cs
condition|)
block|{
name|card_type
operator|=
name|TGA_TYPE_T8_01
expr_stmt|;
name|gfbc
operator|->
name|name
operator|=
literal|"T8-01"
expr_stmt|;
block|}
else|else
block|{
name|card_type
operator|=
name|TGA_TYPE_T8_02
expr_stmt|;
name|gfbc
operator|->
name|name
operator|=
literal|"T8-02"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|addrmask
operator|==
name|GDER_ADDR_8MB
condition|)
block|{
comment|/* 8MB core map; T8-22 */
if|if
condition|(
name|cs
condition|)
block|{
comment|/* sanity */
name|card_type
operator|=
name|TGA_TYPE_T8_22
expr_stmt|;
name|gfbc
operator|->
name|name
operator|=
literal|"T8-22"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|addrmask
operator|==
name|GDER_ADDR_16MB
condition|)
block|{
comment|/* 16MB core map; T8-44 */
if|if
condition|(
name|cs
condition|)
block|{
comment|/* sanity */
name|card_type
operator|=
name|TGA_TYPE_T8_44
expr_stmt|;
name|gfbc
operator|->
name|name
operator|=
literal|"T8-44"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|addrmask
operator|==
name|GDER_ADDR_32MB
condition|)
block|{
comment|/* 32MB core map; ??? */
name|card_type
operator|=
name|TGA_TYPE_UNKNOWN
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 32bpp frame buffer */
name|gfbc
operator|->
name|ramdac_name
operator|=
literal|"BT463"
expr_stmt|;
name|gfbc
operator|->
name|ramdac_init
operator|=
name|bt463_init
expr_stmt|;
name|gfbc
operator|->
name|ramdac_rd
operator|=
name|tga_bt463_rd
expr_stmt|;
name|gfbc
operator|->
name|ramdac_wr
operator|=
name|tga_bt463_wr
expr_stmt|;
name|gfbc
operator|->
name|builtin_save_palette
operator|=
name|tga_builtin_save_palette
expr_stmt|;
name|gfbc
operator|->
name|builtin_load_palette
operator|=
name|tga_builtin_load_palette
expr_stmt|;
name|gfbc
operator|->
name|ramdac_save_cursor_palette
operator|=
name|bt463_save_cursor_palette
expr_stmt|;
name|gfbc
operator|->
name|ramdac_load_cursor_palette
operator|=
name|bt463_load_cursor_palette
expr_stmt|;
name|gfbc
operator|->
name|builtin_read_hw_cursor
operator|=
name|tga_builtin_read_hw_cursor
expr_stmt|;
name|gfbc
operator|->
name|builtin_set_hw_cursor
operator|=
name|tga_builtin_set_hw_cursor
expr_stmt|;
name|gfbc
operator|->
name|builtin_set_hw_cursor_shape
operator|=
name|tga_builtin_set_hw_cursor_shape
expr_stmt|;
comment|/* 32bpp frame buffer */
if|if
condition|(
name|addrmask
operator|==
name|GDER_ADDR_4MB
condition|)
block|{
comment|/* 4MB core map; ??? */
name|card_type
operator|=
name|TGA_TYPE_UNKNOWN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addrmask
operator|==
name|GDER_ADDR_8MB
condition|)
block|{
comment|/* 8MB core map; ??? */
name|card_type
operator|=
name|TGA_TYPE_UNKNOWN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addrmask
operator|==
name|GDER_ADDR_16MB
condition|)
block|{
comment|/* 16MB core map; T32-04 or T32-08 */
if|if
condition|(
operator|!
name|cs
condition|)
block|{
name|card_type
operator|=
name|TGA_TYPE_T32_04
expr_stmt|;
name|gfbc
operator|->
name|name
operator|=
literal|"T32-04"
expr_stmt|;
block|}
else|else
block|{
name|card_type
operator|=
name|TGA_TYPE_T32_08
expr_stmt|;
name|gfbc
operator|->
name|name
operator|=
literal|"T32-08"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|addrmask
operator|==
name|GDER_ADDR_32MB
condition|)
block|{
comment|/* 32MB core map; T32-88 */
if|if
condition|(
name|cs
condition|)
block|{
comment|/* sanity */
name|card_type
operator|=
name|TGA_TYPE_T32_88
expr_stmt|;
name|gfbc
operator|->
name|name
operator|=
literal|"T32-88"
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_TGA2
condition|)
block|{
name|gfbc
operator|->
name|ramdac_name
operator|=
literal|"IBM561"
expr_stmt|;
name|gfbc
operator|->
name|ramdac_init
operator|=
name|ibm561_init
expr_stmt|;
name|gfbc
operator|->
name|ramdac_rd
operator|=
name|tga2_ibm561_rd
expr_stmt|;
name|gfbc
operator|->
name|ramdac_wr
operator|=
name|tga2_ibm561_wr
expr_stmt|;
name|gfbc
operator|->
name|ramdac_save_palette
operator|=
name|ibm561_save_palette
expr_stmt|;
name|gfbc
operator|->
name|ramdac_load_palette
operator|=
name|ibm561_load_palette
expr_stmt|;
name|gfbc
operator|->
name|ramdac_save_cursor_palette
operator|=
name|ibm561_save_cursor_palette
expr_stmt|;
name|gfbc
operator|->
name|ramdac_load_cursor_palette
operator|=
name|ibm561_load_cursor_palette
expr_stmt|;
name|gfbc
operator|->
name|builtin_read_hw_cursor
operator|=
name|tga_builtin_read_hw_cursor
expr_stmt|;
name|gfbc
operator|->
name|builtin_set_hw_cursor
operator|=
name|tga_builtin_set_hw_cursor
expr_stmt|;
name|gfbc
operator|->
name|builtin_set_hw_cursor_shape
operator|=
name|tga_builtin_set_hw_cursor_shape
expr_stmt|;
comment|/* 4MB core map */
if|if
condition|(
name|addrmask
operator|==
name|GDER_ADDR_4MB
condition|)
name|card_type
operator|=
name|TGA_TYPE_UNKNOWN
expr_stmt|;
comment|/* 8MB core map */
elseif|else
if|if
condition|(
name|addrmask
operator|==
name|GDER_ADDR_8MB
condition|)
block|{
name|card_type
operator|=
name|TGA2_TYPE_3D30
expr_stmt|;
name|gfbc
operator|->
name|name
operator|=
literal|"3D30"
expr_stmt|;
block|}
comment|/* 16MB core map */
elseif|else
if|if
condition|(
name|addrmask
operator|==
name|GDER_ADDR_16MB
condition|)
block|{
name|card_type
operator|=
name|TGA2_TYPE_4D20
expr_stmt|;
name|gfbc
operator|->
name|name
operator|=
literal|"4D20"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addrmask
operator|==
name|GDER_ADDR_32MB
condition|)
name|card_type
operator|=
name|TGA_TYPE_UNKNOWN
expr_stmt|;
block|}
comment|/* 	  For now, just return for TGA2 cards (i.e., 	  allow syscons to treat this device as a normal 	  VGA device, and don't do anything TGA2-specific, 	  e.g., only use the TGA2 card in VGA mode for now 	  as opposed to 2DA mode... 	*/
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_TGA2
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* If we couldn't identify the card, err-out... */
if|if
condition|(
name|card_type
operator|==
name|TGA_TYPE_UNKNOWN
condition|)
block|{
name|printf
argument_list|(
literal|"tga%d: Unknown TGA type\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Clear and disable interrupts... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_SISR
argument_list|,
literal|0x00000001
argument_list|)
expr_stmt|;
comment|/* Perform TGA2-specific initialization, if necessary... */
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_TGA2
condition|)
block|{
name|monitor
operator|=
operator|(
operator|~
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GREV
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0x0f
expr_stmt|;
name|tga2_init
argument_list|(
name|sc
argument_list|,
name|monitor
argument_list|)
expr_stmt|;
block|}
name|done
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tga2_init
parameter_list|(
name|sc
parameter_list|,
name|monitor
parameter_list|)
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|monitor
decl_stmt|;
block|{
return|return;
name|tga2_ics9110_wr
argument_list|(
name|sc
argument_list|,
name|decmonitors
index|[
name|monitor
index|]
operator|.
name|dotclock
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_VHCR
argument_list|,
operator|(
operator|(
name|decmonitors
index|[
name|monitor
index|]
operator|.
name|hbp
operator|/
literal|4
operator|)
operator|<<
name|VHCR_BPORCH_SHIFT
operator|)
operator||
operator|(
operator|(
name|decmonitors
index|[
name|monitor
index|]
operator|.
name|hsync
operator|/
literal|4
operator|)
operator|<<
name|VHCR_HSYNC_SHIFT
operator|)
operator||
operator|(
operator|(
operator|(
name|decmonitors
index|[
name|monitor
index|]
operator|.
name|hfp
operator|)
operator|/
literal|4
operator|)
operator|<<
name|VHCR_FPORCH_SHIFT
operator|)
operator||
operator|(
operator|(
name|decmonitors
index|[
name|monitor
index|]
operator|.
name|cols
operator|)
operator|/
literal|4
operator|)
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_VVCR
argument_list|,
operator|(
name|decmonitors
index|[
name|monitor
index|]
operator|.
name|vbp
operator|<<
name|VVCR_BPORCH_SHIFT
operator|)
operator||
operator|(
name|decmonitors
index|[
name|monitor
index|]
operator|.
name|vsync
operator|<<
name|VVCR_VSYNC_SHIFT
operator|)
operator||
operator|(
name|decmonitors
index|[
name|monitor
index|]
operator|.
name|vfp
operator|<<
name|VVCR_FPORCH_SHIFT
operator|)
operator||
operator|(
name|decmonitors
index|[
name|monitor
index|]
operator|.
name|rows
operator|)
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_VVBR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|GFB_REGISTER_READWRITE_BARRIER
argument_list|(
name|sc
argument_list|,
name|TGA_REG_VHCR
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_VVVR
argument_list|,
name|READ_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_VVVR
argument_list|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|GFB_REGISTER_READWRITE_BARRIER
argument_list|(
name|sc
argument_list|,
name|TGA_REG_VVVR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_GPMR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|GFB_REGISTER_READWRITE_BARRIER
argument_list|(
name|sc
argument_list|,
name|TGA_REG_GPMR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga_query_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_info_t
modifier|*
name|info
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Assume the best... */
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Verify that this mode is supported on this adapter... */
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_TGA2
condition|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|vi_mode
operator|!=
name|TGA2_2DA_MODE
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_mode
operator|!=
name|TGA2_VGA_MODE
operator|)
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|info
operator|->
name|vi_mode
operator|!=
literal|0
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga_set_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|gfb_reg_t
name|gder
decl_stmt|;
name|gfb_reg_t
name|vgae_mask
decl_stmt|;
comment|/* Assume the best... */
name|error
operator|=
literal|0
expr_stmt|;
name|gder
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|video_adapter_t
operator|*
name|adp
argument_list|,
name|TGA_REG_GDER
argument_list|)
expr_stmt|;
comment|/* 	   Determine the adapter type first 	   so we know which modes are valid for it... 	*/
switch|switch
condition|(
name|adp
operator|->
name|va_type
condition|)
block|{
case|case
name|KD_TGA2
case|:
comment|/* 		   Verify that this mode is supported 		   on this adapter... 		*/
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TGA2_2DA_MODE
case|:
name|vgae_mask
operator|=
operator|~
literal|0x00400000
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|video_adapter_t
operator|*
name|adp
argument_list|,
name|TGA_REG_GDER
argument_list|,
name|gder
operator|&
name|vgae_mask
argument_list|)
expr_stmt|;
name|adp
operator|->
name|va_mode
operator|=
name|mode
expr_stmt|;
break|break;
case|case
name|TGA2_VGA_MODE
case|:
name|vgae_mask
operator|=
literal|0x00400000
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|video_adapter_t
operator|*
name|adp
argument_list|,
name|TGA_REG_GDER
argument_list|,
name|gder
operator||
name|vgae_mask
argument_list|)
expr_stmt|;
name|adp
operator|->
name|va_mode
operator|=
name|mode
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
break|break;
case|case
name|KD_TGA
case|:
comment|/* 		   Verify that this mode is supported 		   on this adapter... 		*/
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
break|break;
default|default:
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga_blank_display
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|gfb_reg_t
name|blanked
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Assume the best... */
name|error
operator|=
literal|0
expr_stmt|;
name|blanked
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VVVR
argument_list|)
operator|&
operator|(
name|VVR_BLANK
operator||
name|VVR_VIDEOVALID
operator||
name|VVR_CURSOR
operator|)
expr_stmt|;
comment|/* If we're not already blanked, then blank...*/
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V_DISPLAY_BLANK
case|:
if|if
condition|(
name|blanked
operator|!=
operator|(
name|VVR_VIDEOVALID
operator||
name|VVR_BLANK
operator|)
condition|)
block|{
name|blanked
operator|=
name|VVR_VIDEOVALID
operator||
name|VVR_BLANK
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VVVR
argument_list|,
name|blanked
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|V_DISPLAY_STAND_BY
case|:
if|if
condition|(
name|blanked
operator|!=
name|VVR_BLANK
condition|)
block|{
name|blanked
operator|=
name|VVR_BLANK
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VVVR
argument_list|,
name|blanked
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|V_DISPLAY_ON
case|:
if|if
condition|(
name|blanked
operator|!=
operator|(
name|VVR_VIDEOVALID
operator||
name|VVR_CURSOR
operator|)
condition|)
block|{
name|blanked
operator|=
name|VVR_VIDEOVALID
operator||
name|VVR_CURSOR
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VVVR
argument_list|,
name|blanked
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga_ioctl
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FBIOPUTCMAP
case|:
if|#
directive|if
literal|0
block|tga_schedule_intr(sc, bt463_load_palette_intr); 		break;
endif|#
directive|endif
case|case
name|FBIO_GETWINORG
case|:
case|case
name|FBIO_SETWINORG
case|:
case|case
name|FBIO_SETDISPSTART
case|:
case|case
name|FBIO_SETLINEWIDTH
case|:
case|case
name|FBIO_GETPALETTE
case|:
case|case
name|FBIOGTYPE
case|:
case|case
name|FBIOGETCMAP
case|:
default|default:
name|error
operator|=
name|fb_commonioctl
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga_set_border
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|color
parameter_list|)
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga_set_win_org
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|gfb_reg_t
name|vvbr
decl_stmt|;
name|u_int16_t
name|window_orig
decl_stmt|;
name|int
name|gder
decl_stmt|;
name|int
name|deep
decl_stmt|;
name|int
name|cs
decl_stmt|;
comment|/* Get the adapter's parameters... */
name|gder
operator|=
name|BASIC_READ_TGA_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GDER
argument_list|)
expr_stmt|;
name|deep
operator|=
operator|(
name|gder
operator|&
literal|0x1
operator|)
operator|!=
literal|0
expr_stmt|;
name|cs
operator|=
operator|(
name|gder
operator|&
literal|0x200
operator|)
operator|==
literal|0
expr_stmt|;
comment|/* 	   Set the window (framebuffer) origin according to the video 	   base address... 	*/
name|window_orig
operator|=
name|offset
operator|/
operator|(
operator|(
literal|1
operator|+
name|cs
operator|)
operator|*
operator|(
literal|1
operator|+
name|deep
operator|)
operator|*
operator|(
literal|1
operator|+
name|deep
operator|)
operator|*
literal|2
name|KB
operator|)
expr_stmt|;
name|adp
operator|->
name|va_window_orig
operator|=
name|window_orig
operator|*
operator|(
operator|(
literal|1
operator|+
name|cs
operator|)
operator|*
operator|(
literal|1
operator|+
name|deep
operator|)
operator|*
operator|(
literal|1
operator|+
name|deep
operator|)
operator|*
literal|2
name|KB
operator|)
expr_stmt|;
comment|/* Set the video base address... */
name|vvbr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VVBR
argument_list|)
expr_stmt|;
name|vvbr
operator|=
operator|(
name|vvbr
operator|&
literal|0xfffffe00
operator|)
operator||
name|window_orig
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VVBR
argument_list|,
name|vvbr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga_fill_rect
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|val
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|cx
parameter_list|,
name|int
name|cy
parameter_list|)
block|{
name|int
name|off
decl_stmt|;
name|gfb_reg_t
name|gpxr
decl_stmt|;
name|gfb_reg_t
name|gmor
decl_stmt|;
name|gfb_reg_t
name|gbcr0
decl_stmt|;
name|gfb_reg_t
name|gbcr1
decl_stmt|;
name|gfb_reg_t
name|color
decl_stmt|;
comment|/* Save the pixel mode... */
name|gmor
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|)
expr_stmt|;
comment|/* Save the pixel mask... */
name|gpxr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|)
expr_stmt|;
comment|/* Save the block-color... */
name|gbcr0
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GBCR0
argument_list|)
expr_stmt|;
name|gbcr1
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GBCR1
argument_list|)
expr_stmt|;
comment|/* Set the pixel mode (block-fill)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|,
operator|(
name|gmor
operator|&
operator|~
name|GMOR_MODE_MASK
operator|)
operator||
name|GMOR_MODE_BLK_FILL
argument_list|)
expr_stmt|;
comment|/* Set the pixel mask (enable writes to all pixels)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|color
operator|=
operator|(
operator|(
name|val
operator|&
literal|0xff00
operator|)
operator|<<
literal|24
operator|)
operator|||
operator|(
operator|(
name|val
operator|&
literal|0xff00
operator|)
operator|<<
literal|16
operator|)
operator|||
operator|(
operator|(
name|val
operator|&
literal|0xff00
operator|)
operator|<<
literal|8
operator|)
operator|||
operator|(
operator|(
name|val
operator|&
literal|0xff00
operator|)
operator|<<
literal|0
operator|)
expr_stmt|;
comment|/* Set the color for the block-fill... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GBCR0
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GBCR1
argument_list|,
name|color
argument_list|)
expr_stmt|;
comment|/* 	   Just traverse the buffer, one 2K-pixel span at a time, setting 	   each pixel to the bolck-color... 	*/
for|for
control|(
name|off
operator|=
operator|(
name|x
operator|*
name|y
operator|)
init|;
name|off
operator|<
operator|(
operator|(
name|x
operator|+
name|cx
operator|)
operator|*
operator|(
name|y
operator|+
name|cy
operator|)
operator|)
condition|;
name|off
operator|+=
operator|(
literal|2
name|KB
operator|)
control|)
name|WRITE_GFB_BUFFER
argument_list|(
name|adp
argument_list|,
name|off
operator|>>
literal|2L
argument_list|,
literal|0x000007ff
argument_list|)
expr_stmt|;
comment|/* Restore the pixel mode... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|,
name|gpxr
argument_list|)
expr_stmt|;
comment|/* Restore the pixel mask... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|,
name|gmor
argument_list|)
expr_stmt|;
comment|/* Restore the block-color... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GBCR0
argument_list|,
name|gbcr0
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GBCR1
argument_list|,
name|gbcr1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga_bitblt
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|gfb_reg_t
name|gmor
decl_stmt|;
name|gfb_reg_t
name|gopr
decl_stmt|;
name|vm_offset_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|adp
argument_list|)
expr_stmt|;
comment|/* Save the pixel mode... */
name|gmor
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|)
expr_stmt|;
comment|/* Save the raster op... */
name|gopr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|)
expr_stmt|;
comment|/* Set the pixel mode (copy)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|,
operator|(
name|gmor
operator|&
operator|~
name|GMOR_MODE_MASK
operator|)
operator||
name|GMOR_MODE_COPY
argument_list|)
expr_stmt|;
comment|/* Set the raster op (src)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|,
operator|(
name|gopr
operator|&
literal|0xfffffff0
operator|)
operator||
literal|0x3
argument_list|)
expr_stmt|;
name|src
operator|=
operator|(
name|va_arg
argument_list|(
name|args
argument_list|,
name|vm_offset_t
argument_list|)
operator|+
name|adp
operator|->
name|va_window_orig
operator|)
operator|&
literal|0x0000000000fffff8
expr_stmt|;
name|dst
operator|=
operator|(
name|va_arg
argument_list|(
name|args
argument_list|,
name|vm_offset_t
argument_list|)
operator|+
name|adp
operator|->
name|va_window_orig
operator|)
operator|&
literal|0x0000000000fffff8
expr_stmt|;
name|count
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|+=
literal|64
operator|,
name|src
operator|+=
literal|64
operator|,
name|dst
operator|+=
literal|64
control|)
block|{
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GCSR
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GCDR
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the raster op... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|,
name|gopr
argument_list|)
expr_stmt|;
comment|/* Restore the pixel mode... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|,
name|gmor
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|int
if|#
directive|if
literal|0
expr|tga_clear(video_adapter_t *adp, int n) else tga_clear(video_adapter_t *adp)
endif|#
directive|endif
block|{
name|int
name|off
block|;
name|gfb_reg_t
name|gpxr
block|;
name|gfb_reg_t
name|gmor
block|;
name|gfb_reg_t
name|gopr
block|;
if|#
directive|if
literal|0
block|if(n == 0) return(0);
endif|#
directive|endif
comment|/* Save the pixel mode... */
name|gmor
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|)
block|;
comment|/* Save the pixel mask... */
name|gpxr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|)
block|;
comment|/* Save the raster op... */
name|gopr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|)
block|;
comment|/* Set the pixel mode (opaque-fill)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|,
operator|(
name|gmor
operator|&
operator|~
name|GMOR_MODE_MASK
operator|)
operator||
name|GMOR_MODE_OPQ_FILL
argument_list|)
block|;
comment|/* Set the pixel mask (enable writes to all pixels)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|,
literal|0xffffffff
argument_list|)
block|;
comment|/* Set the raster op (clear)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|,
operator|(
name|gopr
operator|&
literal|0xfffffff0
operator|)
operator||
literal|0x00
argument_list|)
block|;
comment|/* 	   Just traverse the buffer, one 2K-pixel span at a time, clearing 	   each pixel... 	*/
if|#
directive|if
literal|0
block|for(off = 0; off< (n * adp->va_line_width); off += (2 KB))
endif|#
directive|endif
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|adp
operator|->
name|va_window_size
condition|;
name|off
operator|+=
operator|(
literal|2
name|KB
operator|)
control|)
name|WRITE_GFB_BUFFER
argument_list|(
name|adp
argument_list|,
name|off
operator|>>
literal|2L
argument_list|,
literal|0x000007ff
argument_list|)
expr_stmt|;
comment|/* Restore the pixel mask... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|,
name|gpxr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Restore the raster op... */
end_comment

begin_expr_stmt
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|,
name|gopr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Restore the pixel mode... */
end_comment

begin_expr_stmt
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|,
name|gmor
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_macro
unit|}  int
name|tga_putc
argument_list|(
argument|video_adapter_t *adp
argument_list|,
argument|vm_offset_t off
argument_list|,
argument|u_int8_t c
argument_list|,
argument|u_int8_t a
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|gfb_reg_t
name|gpxr
decl_stmt|;
name|gfb_reg_t
name|gmor
decl_stmt|;
name|gfb_reg_t
name|gopr
decl_stmt|;
name|gfb_reg_t
name|gbgr
decl_stmt|;
name|gfb_reg_t
name|gfgr
decl_stmt|;
name|gfb_reg_t
name|mask
decl_stmt|;
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|u_int8_t
modifier|*
name|pixel
decl_stmt|;
name|vm_offset_t
name|poff
decl_stmt|;
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|pixel_size
decl_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
name|pixel_size
operator|=
name|adp
operator|->
name|va_info
operator|.
name|vi_depth
operator|/
literal|8
expr_stmt|;
comment|/* Save the pixel mode... */
name|gmor
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|)
expr_stmt|;
comment|/* Save the pixel mask... */
name|gpxr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|)
expr_stmt|;
comment|/* Save the raster op... */
name|gopr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|)
expr_stmt|;
comment|/* Save the background color... */
name|gbgr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GBGR
argument_list|)
expr_stmt|;
comment|/* Save the foreground color... */
name|gfgr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GFGR
argument_list|)
expr_stmt|;
comment|/* Set the pixel mode (opaque-stipple)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|,
operator|(
name|gmor
operator|&
operator|~
name|GMOR_MODE_MASK
operator|)
operator||
name|GMOR_MODE_OPQ_STPL
argument_list|)
expr_stmt|;
comment|/* Set the pixel mask (enable writes to the first cwidth pixels)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|,
operator|(
literal|1
operator|<<
name|adp
operator|->
name|va_info
operator|.
name|vi_cwidth
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Set the raster op (src)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|,
operator|(
name|gopr
operator|&
literal|0xfffffff0
operator|)
operator||
literal|0x3
argument_list|)
expr_stmt|;
comment|/* Set the foreground color mask from the attribute byte... */
name|mask
operator|=
operator|(
name|a
operator|&
literal|0x80
operator|)
condition|?
name|a
else|:
operator|(
name|a
operator|&
literal|0x0f
operator|)
expr_stmt|;
comment|/* Propagate the 8-bit mask across the full 32 bits... */
name|mask
operator||=
operator|(
name|mask
operator|<<
literal|24
operator|)
operator||
operator|(
name|mask
operator|<<
literal|16
operator|)
operator||
operator|(
name|mask
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Set the foreground color... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GFGR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* Set the background color mask from the attribute byte... */
name|mask
operator|=
operator|(
name|a
operator|>>
literal|4
operator|)
operator|&
literal|0x07
expr_stmt|;
comment|/* Propagate the 8-bit mask across the full 32 bits... */
name|mask
operator||=
operator|(
name|mask
operator|<<
literal|24
operator|)
operator||
operator|(
name|mask
operator|<<
literal|16
operator|)
operator||
operator|(
name|mask
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Set the background color... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GBGR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* Get the start of the array of pixels rows for this character... */
name|pixel
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|font
operator|+
operator|(
name|c
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
operator|)
expr_stmt|;
comment|/* Calculate the new cursor position... */
name|row
operator|=
name|off
operator|/
name|adp
operator|->
name|va_info
operator|.
name|vi_width
expr_stmt|;
name|col
operator|=
name|off
operator|%
name|adp
operator|->
name|va_info
operator|.
name|vi_width
expr_stmt|;
comment|/* Iterate over all the pixel rows for this character... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get the address of the character's pixel-row... */
name|poff
operator|=
operator|(
operator|(
name|col
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cwidth
operator|*
name|pixel_size
operator|)
operator|+
operator|(
operator|(
operator|(
name|row
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
operator|)
operator|+
name|i
operator|)
operator|*
name|adp
operator|->
name|va_line_width
operator|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
expr_stmt|;
comment|/* Now display the current pixel row... */
name|WRITE_GFB_BUFFER
argument_list|(
name|adp
argument_list|,
name|poff
argument_list|,
name|pixel
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the foreground color... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GFGR
argument_list|,
name|gfgr
argument_list|)
expr_stmt|;
comment|/* Restore the background color... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GBGR
argument_list|,
name|gbgr
argument_list|)
expr_stmt|;
comment|/* Restore the pixel mode... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|,
name|gpxr
argument_list|)
expr_stmt|;
comment|/* Restore the pixel mask... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|,
name|gmor
argument_list|)
expr_stmt|;
comment|/* Restore the raster op... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|,
name|gopr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|int
name|tga_puts
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|vm_offset_t
name|off
parameter_list|,
name|u_int16_t
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|gfb_reg_t
name|gpxr
decl_stmt|;
name|gfb_reg_t
name|gmor
decl_stmt|;
name|gfb_reg_t
name|gopr
decl_stmt|;
name|gfb_reg_t
name|row
decl_stmt|,
name|col
decl_stmt|;
name|u_int8_t
modifier|*
name|pixel
decl_stmt|;
name|u_int8_t
name|c
decl_stmt|;
name|u_int8_t
name|a
decl_stmt|;
name|gfb_reg_t
name|p
decl_stmt|;
name|vm_offset_t
name|poff
decl_stmt|;
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|pixel_size
decl_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
name|pixel_size
operator|=
name|adp
operator|->
name|va_info
operator|.
name|vi_depth
operator|/
literal|8
expr_stmt|;
comment|/* If the string in empty, just return now... */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|tga_putc
argument_list|(
name|adp
argument_list|,
name|off
operator|+
name|i
argument_list|,
name|s
index|[
name|i
index|]
operator|&
literal|0x00ff
argument_list|,
operator|(
name|s
index|[
name|i
index|]
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Save the pixel mode... */
name|gmor
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|)
expr_stmt|;
comment|/* Save the pixel mask... */
name|gpxr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|)
expr_stmt|;
comment|/* Save the raster op... */
name|gopr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|)
expr_stmt|;
comment|/* Set the pixel mode (simple)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|,
operator|(
name|gmor
operator|&
literal|0xffffffc0
operator|)
operator||
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Set the pixel mask (enable writes to all 32 pixels)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|,
operator|(
name|gpxr
operator|&
literal|0xfffffff0
operator|)
operator||
literal|0xf
argument_list|)
expr_stmt|;
comment|/* Set the raster op (src)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|,
operator|(
name|gopr
operator|&
literal|0xfffffff0
operator|)
operator||
literal|0x03
argument_list|)
expr_stmt|;
comment|/* 	   First, do as many characters-rows at a time as possible (as exist)... 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|len
operator|-
name|i
operator|)
operator|>
name|adp
operator|->
name|va_info
operator|.
name|vi_width
condition|;
name|i
operator|+=
name|adp
operator|->
name|va_info
operator|.
name|vi_width
control|)
block|{
comment|/* 		   Iterate over all the pixels for each character in the 		   character-row, doing a scan-line at-a-time, rather than 		   a character at-a-time (like tga_putc())... 		*/
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
condition|;
name|j
operator|++
control|)
block|{
name|p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|adp
operator|->
name|va_info
operator|.
name|vi_width
condition|;
name|k
operator|++
control|)
block|{
comment|/* 				   Get this character... 				*/
name|c
operator|=
name|s
index|[
name|i
operator|+
name|k
index|]
operator|&
literal|0x00ff
expr_stmt|;
comment|/* 				   Get the attribute for this character... 				*/
name|a
operator|=
operator|(
name|s
index|[
name|i
operator|+
name|k
index|]
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
comment|/* 				   Get the start of the array of pixels rows for 				   this character... 				*/
name|pixel
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|font
operator|+
operator|(
name|c
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
operator|)
expr_stmt|;
comment|/* Shift the other pre-existing pixel rows... */
name|p
operator|<<=
literal|8
expr_stmt|;
comment|/* 				   Get the first pixel row for 				   this character... 				*/
name|p
operator||=
name|pixel
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|k
operator|+
literal|1
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 					   Calculate the new cursor 					   position... 					*/
name|row
operator|=
operator|(
name|off
operator|+
name|i
operator|+
operator|(
name|k
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|/
name|adp
operator|->
name|va_info
operator|.
name|vi_width
expr_stmt|;
name|col
operator|=
operator|(
name|off
operator|+
name|i
operator|+
operator|(
name|k
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|%
name|adp
operator|->
name|va_info
operator|.
name|vi_width
expr_stmt|;
comment|/* 					   Get the address of the current 					   character's pixel-row... 					*/
name|poff
operator|=
operator|(
operator|(
name|col
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cwidth
operator|*
name|pixel_size
operator|)
operator|+
operator|(
operator|(
operator|(
name|row
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
operator|)
operator|+
name|j
operator|)
operator|*
name|adp
operator|->
name|va_line_width
operator|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
expr_stmt|;
comment|/* 					   Now display the current 					   pixel row... 					*/
operator|(
operator|*
name|vidsw
index|[
name|adp
operator|->
name|va_index
index|]
operator|->
name|putp
operator|)
operator|(
name|adp
operator|,
name|poff
operator|,
name|p
operator|,
name|a
operator|,
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
operator|,
name|adp
operator|->
name|va_info
operator|.
name|vi_depth
operator|,
literal|1
operator|,
literal|0
operator|)
expr_stmt|;
comment|/* Reset (clear) p... */
name|p
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	   Next, do as many character-sets at a time as possible (as exist)... 	*/
for|for
control|(
init|;
operator|(
name|len
operator|-
name|i
operator|)
operator|>
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
control|)
block|{
comment|/* 		   Iterate over all the pixels for each character in the 		   character-row, doing a scan-line at-a-time, rather than 		   a character at-a-time (like tga_putc())... 		*/
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
condition|;
name|j
operator|++
control|)
block|{
name|p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
comment|/* 				   Get this character... 				*/
name|c
operator|=
name|s
index|[
name|i
operator|+
name|k
index|]
operator|&
literal|0x00ff
expr_stmt|;
comment|/* 				   Get the attribute for this character... 				*/
name|a
operator|=
operator|(
name|s
index|[
name|i
operator|+
name|k
index|]
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
comment|/* 				   Get the start of the array of pixels rows for 				   this character... 				*/
name|pixel
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|font
operator|+
operator|(
name|c
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
operator|)
expr_stmt|;
comment|/* Shift the other pre-existing pixel rows... */
name|p
operator|<<=
literal|8
expr_stmt|;
comment|/* 				   Get the first pixel row for 				   this character... 				*/
name|p
operator||=
name|pixel
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|k
operator|+
literal|1
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 					   Calculate the new cursor 					   position... 					*/
name|row
operator|=
operator|(
name|off
operator|+
name|i
operator|)
operator|/
name|adp
operator|->
name|va_info
operator|.
name|vi_width
expr_stmt|;
name|col
operator|=
operator|(
name|off
operator|+
name|i
operator|)
operator|%
name|adp
operator|->
name|va_info
operator|.
name|vi_width
expr_stmt|;
comment|/* 					   Get the address of the current 					   character's pixel-row... 					*/
name|poff
operator|=
operator|(
operator|(
name|col
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cwidth
operator|*
name|pixel_size
operator|)
operator|+
operator|(
operator|(
operator|(
name|row
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
operator|)
operator|+
name|j
operator|)
operator|*
name|adp
operator|->
name|va_line_width
operator|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
expr_stmt|;
comment|/* 					   Now display the current 					   pixel row... 					*/
operator|(
operator|*
name|vidsw
index|[
name|adp
operator|->
name|va_index
index|]
operator|->
name|putp
operator|)
operator|(
name|adp
operator|,
name|poff
operator|,
name|p
operator|,
name|a
operator|,
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
operator|,
name|adp
operator|->
name|va_info
operator|.
name|vi_depth
operator|,
literal|1
operator|,
literal|0
operator|)
expr_stmt|;
comment|/* Reset (clear) p... */
name|p
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Restore the pixel mode... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|,
name|gpxr
argument_list|)
expr_stmt|;
comment|/* Restore the pixel mask... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|,
name|gmor
argument_list|)
expr_stmt|;
comment|/* Restore the raster op... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|,
name|gopr
argument_list|)
expr_stmt|;
comment|/* Finally, do the remaining characters a character at-a-time... */
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		   Get this character... 		*/
name|c
operator|=
name|s
index|[
name|i
index|]
operator|&
literal|0x00ff
expr_stmt|;
comment|/* 		   Get the attribute for this character... 		*/
name|a
operator|=
operator|(
name|s
index|[
name|i
index|]
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
comment|/* 		   Display this character... 		*/
name|tga_putc
argument_list|(
name|adp
argument_list|,
name|off
operator|+
name|i
argument_list|,
name|c
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tga_putm
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|u_int8_t
modifier|*
name|pixel_image
parameter_list|,
name|gfb_reg_t
name|pixel_mask
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|gfb_reg_t
name|gpxr
decl_stmt|;
name|gfb_reg_t
name|gmor
decl_stmt|;
name|gfb_reg_t
name|gopr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pixel_size
decl_stmt|;
name|vm_offset_t
name|poff
decl_stmt|;
name|pixel_size
operator|=
name|adp
operator|->
name|va_info
operator|.
name|vi_depth
operator|/
literal|8
expr_stmt|;
comment|/* Save the pixel mode... */
name|gmor
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|)
expr_stmt|;
comment|/* Save the pixel mask... */
name|gpxr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|)
expr_stmt|;
comment|/* Save the raster op... */
name|gopr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|)
expr_stmt|;
comment|/* Set the pixel mode (simple)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|,
operator|(
name|gmor
operator|&
operator|~
name|GMOR_MODE_MASK
operator|)
operator||
name|GMOR_MODE_SIMPLE
argument_list|)
expr_stmt|;
comment|/* Set the pixel mask (enable writes to the first 8 pixels)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|,
operator|(
name|gpxr
operator|&
literal|0xfffffff0
operator|)
operator||
literal|0xf
argument_list|)
expr_stmt|;
comment|/* Set the raster op (src)... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|,
operator|(
name|gopr
operator|&
literal|0xfffffff0
operator|)
operator||
literal|0x3
argument_list|)
expr_stmt|;
comment|/* Iterate over all the pixel rows for the mouse pointer... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get the address of the mouse pointer's pixel-row... */
name|poff
operator|=
operator|(
operator|(
name|x
operator|*
name|pixel_size
operator|)
operator|+
operator|(
operator|(
name|y
operator|+
name|i
operator|)
operator|*
name|adp
operator|->
name|va_line_width
operator|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
expr_stmt|;
comment|/* Now display the current pixel-row... */
operator|(
operator|*
name|vidsw
index|[
name|adp
operator|->
name|va_index
index|]
operator|->
name|putp
operator|)
operator|(
name|adp
operator|,
name|poff
operator|,
name|pixel_image
index|[
name|i
index|]
operator|,
name|pixel_mask
operator|,
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
operator|,
name|adp
operator|->
name|va_info
operator|.
name|vi_depth
operator|,
literal|1
operator|,
literal|0
operator|)
expr_stmt|;
block|}
comment|/* Restore the pixel mode... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GPXR_P
argument_list|,
name|gpxr
argument_list|)
expr_stmt|;
comment|/* Restore the pixel mask... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GMOR
argument_list|,
name|gmor
argument_list|)
expr_stmt|;
comment|/* Restore the raster op... */
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_GOPR
argument_list|,
name|gopr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga_error
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * TGA-specific functions  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|tga_builtin_save_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_color_palette_t
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
comment|/* 	 * We store 8 bit values in the palette buffer, while the standard 	 * VGA has 6 bit DAC . 	 */
name|outb
argument_list|(
name|PALRADR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|palette
operator|->
name|count
condition|;
operator|++
name|i
control|)
block|{
name|palette
operator|->
name|red
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|PALDATA
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|palette
operator|->
name|green
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|PALDATA
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|palette
operator|->
name|blue
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|PALDATA
argument_list|)
operator|<<
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga_builtin_load_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_color_palette_t
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
comment|/* 	 * We store 8 bit values in the palette buffer, while the standard 	 * VGA has 6 bit DAC . 	*/
name|outb
argument_list|(
name|PIXMASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PALWADR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|palette
operator|->
name|count
condition|;
operator|++
name|i
control|)
block|{
name|outb
argument_list|(
name|PALDATA
argument_list|,
name|palette
operator|->
name|red
index|[
name|i
index|]
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PALDATA
argument_list|,
name|palette
operator|->
name|green
index|[
name|i
index|]
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PALDATA
argument_list|,
name|palette
operator|->
name|blue
index|[
name|i
index|]
operator|>>
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga2_builtin_save_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_color_palette_t
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_LOW
argument_list|,
name|BT463_IREG_CPALETTE_RAM
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_HIGH
argument_list|,
operator|(
name|BT463_IREG_CPALETTE_RAM
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* spit out the colormap data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|palette
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_CMAP_DATA
argument_list|,
name|palette
operator|->
name|red
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_CMAP_DATA
argument_list|,
name|palette
operator|->
name|green
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_CMAP_DATA
argument_list|,
name|palette
operator|->
name|blue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga2_builtin_load_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_color_palette_t
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_LOW
argument_list|,
name|BT463_IREG_CPALETTE_RAM
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_HIGH
argument_list|,
operator|(
name|BT463_IREG_CPALETTE_RAM
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* spit out the colormap data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|palette
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_CMAP_DATA
argument_list|,
name|palette
operator|->
name|red
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_CMAP_DATA
argument_list|,
name|palette
operator|->
name|green
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_CMAP_DATA
argument_list|,
name|palette
operator|->
name|blue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga2_builtin_save_cursor_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|struct
name|fbcmap
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_LOW
argument_list|,
name|BT463_IREG_CURSOR_COLOR_0
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_HIGH
argument_list|,
operator|(
name|BT463_IREG_CURSOR_COLOR_0
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* spit out the cursor data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|palette
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|BTWNREG
argument_list|(
name|sc
argument_list|,
name|palette
operator|->
name|red
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|BTWNREG
argument_list|(
name|sc
argument_list|,
name|palette
operator|->
name|green
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|BTWNREG
argument_list|(
name|sc
argument_list|,
name|palette
operator|->
name|blue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga2_builtin_load_cursor_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|struct
name|fbcmap
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_LOW
argument_list|,
name|BT463_IREG_CURSOR_COLOR_0
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_HIGH
argument_list|,
operator|(
name|BT463_IREG_CURSOR_COLOR_0
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* spit out the cursor data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|palette
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|BTWNREG
argument_list|(
name|sc
argument_list|,
name|palette
operator|->
name|red
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|BTWNREG
argument_list|(
name|sc
argument_list|,
name|palette
operator|->
name|green
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|BTWNREG
argument_list|(
name|sc
argument_list|,
name|palette
operator|->
name|blue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga_builtin_read_hw_cursor
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|col
parameter_list|,
name|int
name|row
parameter_list|)
block|{
name|gfb_reg_t
name|cxyr
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Assume the best... */
name|error
operator|=
literal|0
expr_stmt|;
name|cxyr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_CXYR
argument_list|)
operator||
literal|0x00ffffff
expr_stmt|;
operator|*
name|col
operator|=
operator|(
name|cxyr
operator|&
literal|0x00000fff
operator|)
operator|/
name|adp
operator|->
name|va_info
operator|.
name|vi_cwidth
expr_stmt|;
operator|*
name|row
operator|=
operator|(
operator|(
name|cxyr
operator|&
literal|0x00fff000
operator|)
operator|>>
literal|12
operator|)
operator|/
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga_builtin_set_hw_cursor
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|col
parameter_list|,
name|int
name|row
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|gfb_reg_t
name|cxyr
decl_stmt|;
name|gfb_reg_t
name|vvvr
decl_stmt|;
comment|/* Assume the best... */
name|error
operator|=
literal|0
expr_stmt|;
name|vvvr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VVVR
argument_list|)
expr_stmt|;
comment|/* 	   Make sure the parameters are in range for the screen 	   size... 	*/
if|if
condition|(
operator|(
name|row
operator|>
name|adp
operator|->
name|va_info
operator|.
name|vi_height
operator|)
operator|||
operator|(
name|col
operator|>
name|adp
operator|->
name|va_info
operator|.
name|vi_width
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|row
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
operator|)
operator|>
literal|0x0fff
operator|)
operator|||
operator|(
operator|(
name|col
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cwidth
operator|)
operator|>
literal|0x0fff
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* 	   If either of the parameters is less than 0, 	   then hide the cursor... 	*/
elseif|else
if|if
condition|(
operator|(
name|row
operator|<
literal|0
operator|)
operator|||
operator|(
name|col
operator|<
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|vvvr
operator|&
literal|0x00000004
operator|)
operator|!=
literal|0
condition|)
block|{
name|vvvr
operator|&=
literal|0xfffffffb
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VVVR
argument_list|,
name|vvvr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Otherwise, just move the cursor as requested... */
else|else
block|{
name|cxyr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_CXYR
argument_list|)
operator|&
literal|0xff000000
expr_stmt|;
name|cxyr
operator||=
operator|(
operator|(
name|row
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|cxyr
operator||=
operator|(
name|col
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cwidth
operator|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_CXYR
argument_list|,
name|cxyr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vvvr
operator|&
literal|0x00000004
operator|)
operator|==
literal|0
condition|)
block|{
name|vvvr
operator||=
literal|0x00000004
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VVVR
argument_list|,
name|vvvr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga_builtin_set_hw_cursor_shape
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|cellsize
parameter_list|,
name|int
name|blink
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|vm_offset_t
name|cba
decl_stmt|;
name|gfb_reg_t
name|window_orig
decl_stmt|;
name|gfb_reg_t
name|ccbr
decl_stmt|;
name|gfb_reg_t
name|vvvr
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Assume the best... */
name|error
operator|=
literal|0
expr_stmt|;
name|vvvr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VVVR
argument_list|)
expr_stmt|;
comment|/* 	   Make sure the parameters are in range for the cursor 	   (it's a 64x64 cursor)... 	*/
if|if
condition|(
name|height
operator|>
literal|64
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* If height is less than or equal to 0, then hide the cursor... */
elseif|else
if|if
condition|(
name|height
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|vvvr
operator|&
literal|0x00000004
operator|)
operator|!=
literal|0
condition|)
block|{
name|vvvr
operator|&=
literal|0xfffffffb
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VVVR
argument_list|,
name|vvvr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Otherwise, just resize the cursor as requested... */
else|else
block|{
name|ccbr
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_CCBR
argument_list|)
expr_stmt|;
name|ccbr
operator|&=
literal|0xffff03ff
expr_stmt|;
name|ccbr
operator||=
operator|(
operator|(
name|height
operator|-
literal|1
operator|)
operator|<<
literal|10
operator|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_CCBR
argument_list|,
name|ccbr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vvvr
operator|&
literal|0x00000004
operator|)
operator|==
literal|0
condition|)
block|{
name|vvvr
operator||=
literal|0x00000004
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_VVVR
argument_list|,
name|vvvr
argument_list|)
expr_stmt|;
block|}
comment|/* Save the window origin... */
name|window_orig
operator|=
name|adp
operator|->
name|va_window_orig
expr_stmt|;
comment|/* 		   Fill in the cursor image (64 rows of 64 pixels per cursor 		   row at 2 bits-per-pixel, so 64 rows of 16 bytes each)--we 		   set va_window_orig to the cursor base address temporarily 		   so that we can write to the cursor image... 		*/
name|cba
operator|=
operator|(
name|READ_GFB_REGISTER
argument_list|(
name|adp
argument_list|,
name|TGA_REG_CCBR
argument_list|)
operator|&
literal|0xfffffc0f
operator|)
operator|>>
literal|4
expr_stmt|;
name|adp
operator|->
name|va_window_orig
operator|=
name|cba
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|64
operator|-
name|height
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|WRITE_GFB_BUFFER
argument_list|(
name|adp
argument_list|,
name|cba
operator|++
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|WRITE_GFB_BUFFER
argument_list|(
name|adp
argument_list|,
name|cba
operator|++
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
operator|(
operator|(
literal|64
operator|-
name|cellsize
operator|)
operator|/
literal|8
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
operator|)
condition|;
name|j
operator|++
control|)
name|WRITE_GFB_BUFFER
argument_list|(
name|adp
argument_list|,
name|cba
operator|++
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
operator|(
operator|(
literal|64
operator|/
literal|8
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|gfb_reg_t
argument_list|)
operator|)
condition|;
name|j
operator|++
control|)
name|WRITE_GFB_BUFFER
argument_list|(
name|adp
argument_list|,
name|cba
operator|++
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the window origin... */
name|adp
operator|->
name|va_window_orig
operator|=
name|window_orig
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt463_load_palette_intr
parameter_list|(
name|struct
name|gfb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_save_palette
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
operator|&
name|sc
operator|->
name|gfbc
operator|->
name|palette
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt463_load_cursor_palette_intr
parameter_list|(
name|struct
name|gfb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_load_cursor_palette
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
operator|&
name|sc
operator|->
name|gfbc
operator|->
name|cursor_palette
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tga_schedule_intr
parameter_list|(
name|struct
name|gfb_softc
modifier|*
name|sc
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|struct
name|gfb_softc
modifier|*
parameter_list|)
parameter_list|)
block|{
comment|/* Busy-wait for the previous interrupt to complete... */
while|while
condition|(
operator|(
name|READ_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_SISR
argument_list|)
operator|&
literal|0x00000001
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
comment|/* Arrange for f to be called at the next end-of-frame interrupt... */
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_intr
operator|=
name|f
expr_stmt|;
comment|/* Enable the interrupt... */
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_SISR
argument_list|,
literal|0x00010000
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|tga_bt485_rd
parameter_list|(
name|struct
name|gfb_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|btreg
parameter_list|)
block|{
name|gfb_reg_t
name|rdval
decl_stmt|;
if|if
condition|(
name|btreg
operator|>
name|BT485_REG_MAX
condition|)
name|panic
argument_list|(
literal|"tga_ramdac_rd: reg %d out of range\n"
argument_list|,
name|btreg
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_EPSR
argument_list|,
operator|(
name|btreg
operator|<<
literal|1
operator|)
operator||
literal|0x1
argument_list|)
expr_stmt|;
name|GFB_REGISTER_WRITE_BARRIER
argument_list|(
name|sc
argument_list|,
name|TGA_REG_EPSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rdval
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_EPDR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|rdval
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tga_bt485_wr
parameter_list|(
name|struct
name|gfb_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|btreg
parameter_list|,
name|u_int8_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|btreg
operator|>
name|BT485_REG_MAX
condition|)
name|panic
argument_list|(
literal|"tga_ramdac_wr: reg %d out of range\n"
argument_list|,
name|btreg
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_EPDR
argument_list|,
operator|(
name|btreg
operator|<<
literal|9
operator|)
operator||
operator|(
literal|0
operator|<<
literal|8
operator|)
operator||
name|val
argument_list|)
expr_stmt|;
name|GFB_REGISTER_WRITE_BARRIER
argument_list|(
name|sc
argument_list|,
name|TGA_REG_EPDR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|tga2_ibm561_rd
parameter_list|(
name|struct
name|gfb_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|btreg
parameter_list|)
block|{
name|bus_space_handle_t
name|ramdac
decl_stmt|;
name|u_int8_t
name|retval
decl_stmt|;
if|if
condition|(
name|btreg
operator|>
name|BT485_REG_MAX
condition|)
name|panic
argument_list|(
literal|"tga_ramdac_rd: reg %d out of range\n"
argument_list|,
name|btreg
argument_list|)
expr_stmt|;
name|ramdac
operator|=
name|sc
operator|->
name|bhandle
operator|+
name|TGA2_MEM_RAMDAC
operator|+
operator|(
literal|0xe
operator|<<
literal|12
operator|)
operator|+
operator|(
name|btreg
operator|<<
literal|8
operator|)
expr_stmt|;
name|retval
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|btag
argument_list|,
name|ramdac
argument_list|,
literal|0
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|btag
argument_list|,
name|ramdac
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tga2_ibm561_wr
parameter_list|(
name|struct
name|gfb_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|btreg
parameter_list|,
name|u_int8_t
name|val
parameter_list|)
block|{
name|bus_space_handle_t
name|ramdac
decl_stmt|;
if|if
condition|(
name|btreg
operator|>
name|BT485_REG_MAX
condition|)
name|panic
argument_list|(
literal|"tga_ramdac_wr: reg %d out of range\n"
argument_list|,
name|btreg
argument_list|)
expr_stmt|;
name|ramdac
operator|=
name|sc
operator|->
name|bhandle
operator|+
name|TGA2_MEM_RAMDAC
operator|+
operator|(
literal|0xe
operator|<<
literal|12
operator|)
operator|+
operator|(
name|btreg
operator|<<
literal|8
operator|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|btag
argument_list|,
name|ramdac
argument_list|,
literal|0
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|btag
argument_list|,
name|ramdac
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|tga_bt463_rd
parameter_list|(
name|struct
name|gfb_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|btreg
parameter_list|)
block|{
name|gfb_reg_t
name|rdval
decl_stmt|;
comment|/*  	 * Strobe CE# (high->low->high) since status and data are latched on  	 * the falling and rising edges (repsectively) of this active-low 	 * signal. 	 */
name|GFB_REGISTER_WRITE_BARRIER
argument_list|(
name|sc
argument_list|,
name|TGA_REG_EPSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_EPSR
argument_list|,
operator|(
name|btreg
operator|<<
literal|2
operator|)
operator||
literal|2
operator||
literal|1
argument_list|)
expr_stmt|;
name|GFB_REGISTER_WRITE_BARRIER
argument_list|(
name|sc
argument_list|,
name|TGA_REG_EPSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_EPSR
argument_list|,
operator|(
name|btreg
operator|<<
literal|2
operator|)
operator||
literal|2
operator||
literal|0
argument_list|)
expr_stmt|;
name|GFB_REGISTER_READ_BARRIER
argument_list|(
name|sc
argument_list|,
name|TGA_REG_EPSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rdval
operator|=
name|READ_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_EPDR
argument_list|)
expr_stmt|;
name|GFB_REGISTER_WRITE_BARRIER
argument_list|(
name|sc
argument_list|,
name|TGA_REG_EPSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_EPSR
argument_list|,
operator|(
name|btreg
operator|<<
literal|2
operator|)
operator||
literal|2
operator||
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|rdval
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tga_bt463_wr
parameter_list|(
name|struct
name|gfb_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|btreg
parameter_list|,
name|u_int8_t
name|val
parameter_list|)
block|{
comment|/*  	 * In spite of the 21030 documentation, to set the MPU bus bits for 	 * a write, you set them in the upper bits of EPDR, not EPSR. 	 */
comment|/*  	 * Strobe CE# (high->low->high) since status and data are latched on 	 * the falling and rising edges of this active-low signal. 	 */
name|GFB_REGISTER_WRITE_BARRIER
argument_list|(
name|sc
argument_list|,
name|TGA_REG_EPDR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_EPDR
argument_list|,
operator|(
name|btreg
operator|<<
literal|10
operator|)
operator||
literal|0x100
operator||
name|val
argument_list|)
expr_stmt|;
name|GFB_REGISTER_WRITE_BARRIER
argument_list|(
name|sc
argument_list|,
name|TGA_REG_EPDR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_EPDR
argument_list|,
operator|(
name|btreg
operator|<<
literal|10
operator|)
operator||
literal|0x000
operator||
name|val
argument_list|)
expr_stmt|;
name|GFB_REGISTER_WRITE_BARRIER
argument_list|(
name|sc
argument_list|,
name|TGA_REG_EPDR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|WRITE_GFB_REGISTER
argument_list|(
name|sc
operator|->
name|adp
argument_list|,
name|TGA_REG_EPDR
argument_list|,
operator|(
name|btreg
operator|<<
literal|10
operator|)
operator||
literal|0x100
operator||
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tga2_ics9110_wr
parameter_list|(
name|struct
name|gfb_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dotclock
parameter_list|)
block|{
name|bus_space_handle_t
name|clock
decl_stmt|;
name|gfb_reg_t
name|valU
decl_stmt|;
name|int
name|N
decl_stmt|,
name|M
decl_stmt|,
name|R
decl_stmt|,
name|V
decl_stmt|,
name|X
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|dotclock
condition|)
block|{
case|case
literal|130808000
case|:
name|N
operator|=
literal|0x40
expr_stmt|;
name|M
operator|=
literal|0x7
expr_stmt|;
name|V
operator|=
literal|0x0
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x1
expr_stmt|;
break|break;
case|case
literal|119840000
case|:
name|N
operator|=
literal|0x2d
expr_stmt|;
name|M
operator|=
literal|0x2b
expr_stmt|;
name|V
operator|=
literal|0x1
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x1
expr_stmt|;
break|break;
case|case
literal|108180000
case|:
name|N
operator|=
literal|0x11
expr_stmt|;
name|M
operator|=
literal|0x9
expr_stmt|;
name|V
operator|=
literal|0x1
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x2
expr_stmt|;
break|break;
case|case
literal|103994000
case|:
name|N
operator|=
literal|0x6d
expr_stmt|;
name|M
operator|=
literal|0xf
expr_stmt|;
name|V
operator|=
literal|0x0
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x1
expr_stmt|;
break|break;
case|case
literal|175000000
case|:
name|N
operator|=
literal|0x5F
expr_stmt|;
name|M
operator|=
literal|0x3E
expr_stmt|;
name|V
operator|=
literal|0x1
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x1
expr_stmt|;
break|break;
case|case
literal|75000000
case|:
name|N
operator|=
literal|0x6e
expr_stmt|;
name|M
operator|=
literal|0x15
expr_stmt|;
name|V
operator|=
literal|0x0
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x1
expr_stmt|;
break|break;
case|case
literal|74000000
case|:
name|N
operator|=
literal|0x2a
expr_stmt|;
name|M
operator|=
literal|0x41
expr_stmt|;
name|V
operator|=
literal|0x1
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x1
expr_stmt|;
break|break;
case|case
literal|69000000
case|:
name|N
operator|=
literal|0x35
expr_stmt|;
name|M
operator|=
literal|0xb
expr_stmt|;
name|V
operator|=
literal|0x0
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x1
expr_stmt|;
break|break;
case|case
literal|65000000
case|:
name|N
operator|=
literal|0x6d
expr_stmt|;
name|M
operator|=
literal|0x0c
expr_stmt|;
name|V
operator|=
literal|0x0
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x2
expr_stmt|;
break|break;
case|case
literal|50000000
case|:
name|N
operator|=
literal|0x37
expr_stmt|;
name|M
operator|=
literal|0x3f
expr_stmt|;
name|V
operator|=
literal|0x1
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x2
expr_stmt|;
break|break;
case|case
literal|40000000
case|:
name|N
operator|=
literal|0x5f
expr_stmt|;
name|M
operator|=
literal|0x11
expr_stmt|;
name|V
operator|=
literal|0x0
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x2
expr_stmt|;
break|break;
case|case
literal|31500000
case|:
name|N
operator|=
literal|0x16
expr_stmt|;
name|M
operator|=
literal|0x05
expr_stmt|;
name|V
operator|=
literal|0x0
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x2
expr_stmt|;
break|break;
case|case
literal|25175000
case|:
name|N
operator|=
literal|0x66
expr_stmt|;
name|M
operator|=
literal|0x1d
expr_stmt|;
name|V
operator|=
literal|0x0
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x2
expr_stmt|;
break|break;
case|case
literal|135000000
case|:
name|N
operator|=
literal|0x42
expr_stmt|;
name|M
operator|=
literal|0x07
expr_stmt|;
name|V
operator|=
literal|0x0
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x1
expr_stmt|;
break|break;
case|case
literal|110000000
case|:
name|N
operator|=
literal|0x60
expr_stmt|;
name|M
operator|=
literal|0x32
expr_stmt|;
name|V
operator|=
literal|0x1
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x2
expr_stmt|;
break|break;
case|case
literal|202500000
case|:
name|N
operator|=
literal|0x60
expr_stmt|;
name|M
operator|=
literal|0x32
expr_stmt|;
name|V
operator|=
literal|0x1
expr_stmt|;
name|X
operator|=
literal|0x1
expr_stmt|;
name|R
operator|=
literal|0x2
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unrecognized clock rate %d\n"
argument_list|,
name|dotclock
argument_list|)
expr_stmt|;
block|}
comment|/* XXX -- hard coded, bad */
name|valU
operator|=
name|N
operator||
operator|(
name|M
operator|<<
literal|7
operator|)
operator||
operator|(
name|V
operator|<<
literal|14
operator|)
expr_stmt|;
name|valU
operator||=
operator|(
name|X
operator|<<
literal|15
operator|)
operator||
operator|(
name|R
operator|<<
literal|17
operator|)
expr_stmt|;
name|valU
operator||=
literal|0x17
operator|<<
literal|19
expr_stmt|;
name|clock
operator|=
name|sc
operator|->
name|bhandle
operator|+
name|TGA2_MEM_EXTDEV
operator|+
name|TGA2_MEM_CLOCK
operator|+
operator|(
literal|0xe
operator|<<
literal|12
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|gfb_reg_t
name|writeval
decl_stmt|;
name|writeval
operator|=
name|valU
operator|&
literal|0x1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|writeval
operator||=
literal|0x2
expr_stmt|;
name|valU
operator|>>=
literal|1
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|btag
argument_list|,
name|clock
argument_list|,
literal|0
argument_list|,
name|writeval
argument_list|)
expr_stmt|;
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|btag
argument_list|,
name|clock
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
name|clock
operator|=
name|sc
operator|->
name|bhandle
operator|+
name|TGA2_MEM_EXTDEV
operator|+
name|TGA2_MEM_CLOCK
operator|+
operator|(
literal|0xe
operator|<<
literal|12
operator|)
operator|+
operator|(
literal|0x1
operator|<<
literal|11
operator|)
operator|+
operator|(
literal|0x1
operator|<<
literal|11
operator|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|btag
argument_list|,
name|clock
argument_list|,
literal|0
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|btag
argument_list|,
name|clock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * BrookTree RAMDAC-specific functions  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bt463_init
parameter_list|(
name|struct
name|gfb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
return|return;
comment|/* 	 * Init the BT463 for normal operation. 	 */
comment|/* 	 * Setup: 	 * reg 0: 4:1 multiplexing, 25/75 blink. 	 * reg 1: Overlay mapping: mapped to common palette,  	 *        14 window type entries, 24-plane configuration mode, 	 *        4 overlay planes, underlays disabled, no cursor.  	 * reg 2: sync-on-green enabled, pedestal enabled. 	 */
name|BTWREG
argument_list|(
name|sc
argument_list|,
name|BT463_IREG_COMMAND_0
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|BTWREG
argument_list|(
name|sc
argument_list|,
name|BT463_IREG_COMMAND_1
argument_list|,
literal|0x48
argument_list|)
expr_stmt|;
name|BTWREG
argument_list|(
name|sc
argument_list|,
name|BT463_IREG_COMMAND_2
argument_list|,
literal|0xC0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the read mask. 	 */
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_LOW
argument_list|,
name|BT463_IREG_READ_MASK_P0_P7
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_HIGH
argument_list|,
operator|(
name|BT463_IREG_READ_MASK_P0_P7
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|BTWNREG
argument_list|(
name|sc
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the blink mask. 	 */
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_LOW
argument_list|,
name|BT463_IREG_READ_MASK_P0_P7
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_HIGH
argument_list|,
operator|(
name|BT463_IREG_READ_MASK_P0_P7
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|BTWNREG
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Clear test register 	 */
name|BTWREG
argument_list|(
name|sc
argument_list|,
name|BT463_IREG_TEST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Initalize the RAMDAC info struct to hold all of our 	 * data, and fill it in. 	 */
comment|/* Initialize the window type table: 	 * 	 * Entry 0: 24-plane truecolor, overlays enabled, bypassed. 	 * 	 *  Lookup table bypass:      yes (    1<< 23& 0x800000)  800000 	 *  Colormap address:       0x000 (0x000<< 17& 0x7e0000)       0  	 *  Overlay mask:             0xf (  0xf<< 13& 0x01e000)   1e000 	 *  Overlay location:    P<27:24> (    0<< 12& 0x001000)       0 	 *  Display mode:       Truecolor (    0<<  9& 0x000e00)     000 	 *  Number of planes:           8 (    8<<  5& 0x0001e0)     100 	 *  Plane shift:                0 (    0<<  0& 0x00001f)       0 	 *                                                        -------- 	 *                                                        0x81e100 	 */
if|#
directive|if
literal|0
block|data->window_type[0] = 0x81e100;
endif|#
directive|endif
comment|/* Entry 1: 8-plane pseudocolor in the bottom 8 bits,  	 *          overlays enabled, colormap starting at 0.  	 * 	 *  Lookup table bypass:       no (    0<< 23& 0x800000)       0 	 *  Colormap address:       0x000 (0x000<< 17& 0x7e0000)       0  	 *  Overlay mask:             0xf (  0xf<< 13& 0x01e000) 0x1e000 	 *  Overlay location:    P<27:24> (    0<< 12& 0x001000)       0 	 *  Display mode:     Pseudocolor (    1<<  9& 0x000e00)   0x200 	 *  Number of planes:           8 (    8<<  5& 0x0001e0)   0x100 	 *  Plane shift:               16 ( 0x10<<  0& 0x00001f)      10 	 *                                                        -------- 	 *                                                        0x01e310 	 */
if|#
directive|if
literal|0
block|data->window_type[1] = 0x01e310;
endif|#
directive|endif
comment|/* The colormap interface to the world only supports one colormap,  	 * so having an entry for the 'alternate' colormap in the bt463  	 * probably isn't useful. 	 */
comment|/* Fill the remaining table entries with clones of entry 0 until we  	 * figure out a better use for them. 	 */
if|#
directive|if
literal|0
block|for(i = 2; i< BT463_NWTYPE_ENTRIES; i++) { 		data->window_type[i] = 0x81e100; 	}
endif|#
directive|endif
name|tga_schedule_intr
argument_list|(
name|sc
argument_list|,
name|bt463_update_window_type
argument_list|)
expr_stmt|;
name|tga_schedule_intr
argument_list|(
name|sc
argument_list|,
name|bt463_load_cursor_palette_intr
argument_list|)
expr_stmt|;
name|tga_schedule_intr
argument_list|(
name|sc
argument_list|,
name|bt463_load_palette_intr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt463_update_window_type
parameter_list|(
name|struct
name|gfb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* The Bt463 won't accept window type data except during a blanking 	 * interval, so we do this early in the interrupt. 	 * Blanking the screen might also be a good idea, but it can cause  	 * unpleasant flashing and is hard to do from this side of the 	 * ramdac interface. 	 */
comment|/* spit out the window type data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BT463_NWTYPE_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
literal|0
block|sc->gfbc->ramdac_wr(sc, BT463_REG_ADDR_LOW, 		    (BT463_IREG_WINDOW_TYPE_TABLE + i)& 0xff); 		sc->gfbc->ramdac_wr(sc, BT463_REG_ADDR_HIGH, 		    ((BT463_IREG_WINDOW_TYPE_TABLE + i)>> 8)& 0xff); 		BTWNREG(sc, (data->window_type[i])& 0xff); 		BTWNREG(sc, (data->window_type[i]>> 8)& 0xff); 		BTWNREG(sc, (data->window_type[i]>> 16)& 0xff);
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bt463_save_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_color_palette_t
modifier|*
name|palette
parameter_list|)
block|{
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_LOW
argument_list|,
name|BT463_IREG_CPALETTE_RAM
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_HIGH
argument_list|,
operator|(
name|BT463_IREG_CPALETTE_RAM
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* get the colormap data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|palette
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|palette
operator|->
name|red
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT463_REG_CMAP_DATA
argument_list|)
expr_stmt|;
name|palette
operator|->
name|green
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT463_REG_CMAP_DATA
argument_list|)
expr_stmt|;
name|palette
operator|->
name|blue
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT463_REG_CMAP_DATA
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bt463_load_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_color_palette_t
modifier|*
name|palette
parameter_list|)
block|{
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_LOW
argument_list|,
name|BT463_IREG_CPALETTE_RAM
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_HIGH
argument_list|,
operator|(
name|BT463_IREG_CPALETTE_RAM
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* spit out the colormap data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|palette
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_CMAP_DATA
argument_list|,
name|palette
operator|->
name|red
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_CMAP_DATA
argument_list|,
name|palette
operator|->
name|green
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_CMAP_DATA
argument_list|,
name|palette
operator|->
name|blue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bt463_save_cursor_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|struct
name|fbcmap
modifier|*
name|palette
parameter_list|)
block|{
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_LOW
argument_list|,
name|BT463_IREG_CURSOR_COLOR_0
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_HIGH
argument_list|,
operator|(
name|BT463_IREG_CURSOR_COLOR_0
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* spit out the cursor data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|palette
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|palette
operator|->
name|red
index|[
name|i
index|]
operator|=
name|BTRNREG
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|palette
operator|->
name|green
index|[
name|i
index|]
operator|=
name|BTRNREG
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|palette
operator|->
name|blue
index|[
name|i
index|]
operator|=
name|BTRNREG
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bt463_load_cursor_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|struct
name|bfcmap
modifier|*
name|palette
parameter_list|)
block|{
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_LOW
argument_list|,
name|BT463_IREG_CURSOR_COLOR_0
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT463_REG_ADDR_HIGH
argument_list|,
operator|(
name|BT463_IREG_CURSOR_COLOR_0
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* spit out the cursor data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|palette
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|BTWNREG
argument_list|(
name|sc
argument_list|,
name|palette
operator|->
name|red
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|BTWNREG
argument_list|(
name|sc
argument_list|,
name|palette
operator|->
name|green
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|BTWNREG
argument_list|(
name|sc
argument_list|,
name|palette
operator|->
name|blue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt485_init
parameter_list|(
name|struct
name|gfb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|num_cmap_entries
decl_stmt|;
name|u_int8_t
name|regval
decl_stmt|;
name|regval
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT485_REG_COMMAND_0
argument_list|)
expr_stmt|;
comment|/* 	 * Set the RAMDAC to 8 bit resolution, rather than 6 bit 	 * resolution. 	 */
name|regval
operator||=
literal|0x02
expr_stmt|;
comment|/* 	 * Set the RAMDAC to sync-on-green. 	 */
name|regval
operator||=
literal|0x08
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_COMMAND_0
argument_list|,
name|regval
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Set the RAMDAC to 8BPP (no interesting options). */
block|sc->gfbc->ramdac_wr(sc, BT485_REG_COMMAND_1, 0x40);
comment|/* Disable the cursor (for now) */
block|regval = sc->gfbc->ramdac_rd(sc, BT485_REG_COMMAND_2); 	regval&= ~0x03; 	regval |= 0x24; 	sc->gfbc->ramdac_wr(sc, BT485_REG_COMMAND_2, regval);
comment|/* Use a 64x64x2 cursor */
block|sc->gfbc->ramdac_wr(sc, BT485_REG_PCRAM_WRADDR, BT485_IREG_COMMAND_3); 	regval = sc->gfbc->ramdac_rd(sc, BT485_REG_EXTENDED); 	regval |= 0x04; 	regval |= 0x08; 	sc->gfbc->ramdac_wr(sc, BT485_REG_PCRAM_WRADDR, BT485_IREG_COMMAND_3); 	sc->gfbc->ramdac_wr(sc, BT485_REG_EXTENDED, regval);
comment|/* Set the Pixel Mask to something useful */
block|sc->gfbc->ramdac_wr(sc, BT485_REG_PIXMASK, 0xff);
endif|#
directive|endif
comment|/* Generate the cursor color map (Light-Grey)... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|gfbc
operator|->
name|cursor_palette
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|gfbc
operator|->
name|cursor_palette
operator|.
name|red
index|[
name|i
index|]
operator|=
name|default_cmap
index|[
literal|7
index|]
operator|.
name|red
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|cursor_palette
operator|.
name|green
index|[
name|i
index|]
operator|=
name|default_cmap
index|[
literal|7
index|]
operator|.
name|green
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|cursor_palette
operator|.
name|blue
index|[
name|i
index|]
operator|=
name|default_cmap
index|[
literal|7
index|]
operator|.
name|blue
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Enable cursor... */
block|regval = sc->gfbc->ramdac_rd(sc, BT485_REG_COMMAND_2); 	if(!(regval& 0x01)) { 		regval |= 0x01; 		sc->gfbc->ramdac_wr(sc, BT485_REG_COMMAND_2, regval); 	} 	else if(regval& 0x03) { 		regval&= ~0x03; 		sc->gfbc->ramdac_wr(sc, BT485_REG_COMMAND_2, regval); 	}
endif|#
directive|endif
comment|/* Generate the screen color map... */
name|num_cmap_entries
operator|=
sizeof|sizeof
argument_list|(
name|default_cmap
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|cmap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|gfbc
operator|->
name|palette
operator|.
name|count
operator|/
name|num_cmap_entries
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_cmap_entries
condition|;
name|j
operator|++
control|)
block|{
name|sc
operator|->
name|gfbc
operator|->
name|palette
operator|.
name|red
index|[
operator|(
name|num_cmap_entries
operator|*
name|i
operator|)
operator|+
name|j
index|]
operator|=
name|default_cmap
index|[
name|j
index|]
operator|.
name|red
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|palette
operator|.
name|green
index|[
operator|(
name|num_cmap_entries
operator|*
name|i
operator|)
operator|+
name|j
index|]
operator|=
name|default_cmap
index|[
name|j
index|]
operator|.
name|green
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|palette
operator|.
name|blue
index|[
operator|(
name|num_cmap_entries
operator|*
name|i
operator|)
operator|+
name|j
index|]
operator|=
name|default_cmap
index|[
name|j
index|]
operator|.
name|blue
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bt485_save_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_color_palette_t
modifier|*
name|palette
parameter_list|)
block|{
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
comment|/* addr[9:0] assumed to be 0 */
comment|/* set addr[7:0] to 0 */
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PCRAM_WRADDR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* spit out the color data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|palette
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|palette
operator|->
name|red
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PALETTE
argument_list|)
expr_stmt|;
name|palette
operator|->
name|green
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PALETTE
argument_list|)
expr_stmt|;
name|palette
operator|->
name|blue
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PALETTE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bt485_load_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_color_palette_t
modifier|*
name|palette
parameter_list|)
block|{
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
comment|/* addr[9:0] assumed to be 0 */
comment|/* set addr[7:0] to 0 */
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PCRAM_WRADDR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* spit out the color data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|palette
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PALETTE
argument_list|,
name|palette
operator|->
name|red
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PALETTE
argument_list|,
name|palette
operator|->
name|green
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PALETTE
argument_list|,
name|palette
operator|->
name|blue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bt485_save_cursor_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|struct
name|fbcmap
modifier|*
name|palette
parameter_list|)
block|{
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
comment|/* addr[9:0] assumed to be 0 */
comment|/* set addr[7:0] to 1 */
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_COC_WRADDR
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* spit out the cursor color data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|palette
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|palette
operator|->
name|red
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT485_REG_COCDATA
argument_list|)
expr_stmt|;
name|palette
operator|->
name|green
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT485_REG_COCDATA
argument_list|)
expr_stmt|;
name|palette
operator|->
name|blue
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT485_REG_COCDATA
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bt485_load_cursor_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|struct
name|fbcmap
modifier|*
name|palette
parameter_list|)
block|{
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
comment|/* addr[9:0] assumed to be 0 */
comment|/* set addr[7:0] to 1 */
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_COC_WRADDR
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* spit out the cursor color data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|palette
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_COCDATA
argument_list|,
name|palette
operator|->
name|red
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_COCDATA
argument_list|,
name|palette
operator|->
name|green
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_COCDATA
argument_list|,
name|palette
operator|->
name|blue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bt485_read_hw_cursor
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
modifier|*
name|col
parameter_list|,
name|int
modifier|*
name|row
parameter_list|)
block|{
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
name|col
operator|=
operator|(
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT485_REG_CURSOR_X_HIGH
argument_list|)
operator|&
literal|0x0f
operator|)
operator|<<
literal|8
expr_stmt|;
operator|*
name|col
operator||=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT485_REG_CURSOR_X_LOW
argument_list|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|col
operator|/=
name|adp
operator|->
name|va_info
operator|.
name|vi_cwidth
expr_stmt|;
operator|*
name|col
operator|-=
literal|8
expr_stmt|;
operator|*
name|row
operator|=
operator|(
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT485_REG_CURSOR_Y_HIGH
argument_list|)
operator|&
literal|0x0f
operator|)
operator|<<
literal|8
expr_stmt|;
operator|*
name|row
operator||=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT485_REG_CURSOR_Y_LOW
argument_list|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|row
operator|/=
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
expr_stmt|;
operator|*
name|row
operator|-=
literal|4
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bt485_set_hw_cursor
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|col
parameter_list|,
name|int
name|row
parameter_list|)
block|{
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Make sure the parameters are in range for the screen 	   size... */
if|if
condition|(
operator|(
name|row
operator|>
name|adp
operator|->
name|va_info
operator|.
name|vi_height
operator|)
operator|||
operator|(
name|col
operator|>
name|adp
operator|->
name|va_info
operator|.
name|vi_width
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|row
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
operator|)
operator|>
literal|0x0fff
operator|)
operator|||
operator|(
operator|(
name|col
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cwidth
operator|)
operator|>
literal|0x0fff
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|row
operator|<
literal|0
operator|)
operator|||
operator|(
name|col
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* If either of the parameters is less than 0, then hide the 		   cursor... */
name|col
operator|=
operator|-
literal|8
expr_stmt|;
name|row
operator|=
operator|-
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, just move the cursor as requested... */
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_CURSOR_X_LOW
argument_list|,
operator|(
operator|(
name|col
operator|+
literal|8
operator|)
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cwidth
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_CURSOR_X_HIGH
argument_list|,
operator|(
operator|(
operator|(
name|col
operator|+
literal|8
operator|)
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cwidth
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_CURSOR_Y_LOW
argument_list|,
operator|(
operator|(
name|row
operator|+
literal|4
operator|)
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_CURSOR_Y_HIGH
argument_list|,
operator|(
operator|(
operator|(
name|row
operator|+
literal|4
operator|)
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_cheight
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bt485_set_hw_cursor_shape
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|cellsize
parameter_list|,
name|int
name|blink
parameter_list|)
block|{
name|struct
name|gfb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cell_count
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int8_t
name|regval
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|cellsize
operator|/=
literal|2
expr_stmt|;
name|sc
operator|=
name|gfb_device_softcs
index|[
name|adp
operator|->
name|va_model
index|]
index|[
name|adp
operator|->
name|va_unit
index|]
expr_stmt|;
comment|/* 	   Make sure the parameters are in range for the cursor 	   (it's a 64x64 cursor)... 	*/
if|if
condition|(
name|height
operator|>
literal|64
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|height
operator|<=
literal|0
condition|)
block|{
comment|/* If height is less than or equal to 0, then hide the 		   cursor... */
block|}
else|else
block|{
comment|/* Otherwise, just resize the cursor as requested... */
comment|/* 64 pixels per cursor-row, 2 bits-per-pixel, so counts in 		   bytes... */
name|cell_count
operator|=
name|cellsize
operator|/
literal|8
expr_stmt|;
name|count
operator|=
literal|64
operator|/
literal|8
expr_stmt|;
comment|/*  		  * Write the cursor image data: 		  *	set addr[9:8] to 0, 		  *	set addr[7:0] to 0, 		  *	spit it all out. 		  */
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PCRAM_WRADDR
argument_list|,
name|BT485_IREG_COMMAND_3
argument_list|)
expr_stmt|;
name|regval
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT485_REG_EXTENDED
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
literal|0x03
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PCRAM_WRADDR
argument_list|,
name|BT485_IREG_COMMAND_3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_EXTENDED
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PCRAM_WRADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fill-in the desired pixels in the specified pixel-rows... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cell_count
condition|;
name|j
operator|++
control|)
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_CURSOR_RAM
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
operator|-
name|cell_count
condition|;
name|j
operator|++
control|)
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_CURSOR_RAM
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the remaining pixel rows... */
for|for
control|(
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_CURSOR_RAM
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 		 * Write the cursor mask data: 		 *	set addr[9:8] to 2, 		 *	set addr[7:0] to 0, 		 *	spit it all out. 		 */
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PCRAM_WRADDR
argument_list|,
name|BT485_IREG_COMMAND_3
argument_list|)
expr_stmt|;
name|regval
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT485_REG_EXTENDED
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
literal|0x03
expr_stmt|;
name|regval
operator||=
literal|0x02
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PCRAM_WRADDR
argument_list|,
name|BT485_IREG_COMMAND_3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_EXTENDED
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PCRAM_WRADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fill-in the desired pixels in the specified pixel-rows... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cell_count
condition|;
name|j
operator|++
control|)
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_CURSOR_RAM
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
operator|-
name|cell_count
condition|;
name|j
operator|++
control|)
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_CURSOR_RAM
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the remaining pixel rows... */
for|for
control|(
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_CURSOR_RAM
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* set addr[9:0] back to 0 */
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PCRAM_WRADDR
argument_list|,
name|BT485_IREG_COMMAND_3
argument_list|)
expr_stmt|;
name|regval
operator|=
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_rd
argument_list|(
name|sc
argument_list|,
name|BT485_REG_EXTENDED
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
literal|0x03
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_PCRAM_WRADDR
argument_list|,
name|BT485_IREG_COMMAND_3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gfbc
operator|->
name|ramdac_wr
argument_list|(
name|sc
argument_list|,
name|BT485_REG_EXTENDED
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ibm561_init
parameter_list|(
name|struct
name|gfb_softc
modifier|*
name|sc
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|ibm561_save_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_color_palette_t
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ibm561_load_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_color_palette_t
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ibm561_save_cursor_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|struct
name|fbcmap
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ibm561_load_cursor_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|struct
name|fbcmap
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MB
end_undef

begin_undef
undef|#
directive|undef
name|KB
end_undef

end_unit

