begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Kazutaka YOKOTA and Michael Smith  * Copyright (c) 2009-2013 Jung-uk Kim<jkim@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer as  *    the first lines of this file unmodified.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_vga.h"
end_include

begin_include
include|#
directive|include
file|"opt_vesa.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|VGA_NO_MODE_CHANGE
end_ifndef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/fbio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/bios.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/vesa.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/fbreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/vgareg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<isa/isareg.h>
end_include

begin_include
include|#
directive|include
file|<compat/x86bios/x86bios.h>
end_include

begin_define
define|#
directive|define
name|VESA_BIOS_OFFSET
value|0xc0000
end_define

begin_define
define|#
directive|define
name|VESA_PALETTE_SIZE
value|(256 * 4)
end_define

begin_define
define|#
directive|define
name|VESA_VIA_CLE266
value|"VIA CLE266\r\n"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|VESA_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|VESA_DEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VESA video adapter state buffer stub */
end_comment

begin_struct
struct|struct
name|adp_state
block|{
name|int
name|sig
decl_stmt|;
define|#
directive|define
name|V_STATE_SIG
value|0x61736576
name|u_char
name|regs
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|adp_state
name|adp_state_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|vesa_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vesa_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|vesa_state_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|vesa_state_buf_offs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|vesa_state_buf_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|vesa_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|vesa_palette_offs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|vesa_vmem_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|vesa_vmem_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|vesa_bios
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|vesa_bios_offs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|vesa_bios_int10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|vesa_bios_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VESA video adapter */
end_comment

begin_decl_stmt
specifier|static
name|video_adapter_t
modifier|*
name|vesa_adp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|vesa
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"VESA debugging"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|vesa_shadow_rom
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.vesa.shadow_rom"
argument_list|,
operator|&
name|vesa_shadow_rom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_vesa
argument_list|,
name|OID_AUTO
argument_list|,
name|shadow_rom
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|vesa_shadow_rom
argument_list|,
literal|0
argument_list|,
literal|"Enable video BIOS shadow"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* VESA functions */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int			vesa_nop(void);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|vesa_error
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|vi_probe_t
name|vesa_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_init_t
name|vesa_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_get_info_t
name|vesa_get_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_query_mode_t
name|vesa_query_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_mode_t
name|vesa_set_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_save_font_t
name|vesa_save_font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_load_font_t
name|vesa_load_font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_show_font_t
name|vesa_show_font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_save_palette_t
name|vesa_save_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_load_palette_t
name|vesa_load_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_border_t
name|vesa_set_border
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_save_state_t
name|vesa_save_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_load_state_t
name|vesa_load_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_win_org_t
name|vesa_set_origin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_read_hw_cursor_t
name|vesa_read_hw_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_hw_cursor_t
name|vesa_set_hw_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_hw_cursor_shape_t
name|vesa_set_hw_cursor_shape
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_blank_display_t
name|vesa_blank_display
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_mmap_t
name|vesa_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_ioctl_t
name|vesa_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_clear_t
name|vesa_clear
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_fill_rect_t
name|vesa_fill_rect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_bitblt_t
name|vesa_bitblt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_diag_t
name|vesa_diag
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|vesa_bios_info
parameter_list|(
name|int
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|video_switch_t
name|vesavidsw
init|=
block|{
name|vesa_probe
block|,
name|vesa_init
block|,
name|vesa_get_info
block|,
name|vesa_query_mode
block|,
name|vesa_set_mode
block|,
name|vesa_save_font
block|,
name|vesa_load_font
block|,
name|vesa_show_font
block|,
name|vesa_save_palette
block|,
name|vesa_load_palette
block|,
name|vesa_set_border
block|,
name|vesa_save_state
block|,
name|vesa_load_state
block|,
name|vesa_set_origin
block|,
name|vesa_read_hw_cursor
block|,
name|vesa_set_hw_cursor
block|,
name|vesa_set_hw_cursor_shape
block|,
name|vesa_blank_display
block|,
name|vesa_mmap
block|,
name|vesa_ioctl
block|,
name|vesa_clear
block|,
name|vesa_fill_rect
block|,
name|vesa_bitblt
block|,
name|vesa_error
block|,
name|vesa_error
block|,
name|vesa_diag
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|video_switch_t
modifier|*
name|prevvidsw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VESA BIOS video modes */
end_comment

begin_define
define|#
directive|define
name|VESA_MAXMODES
value|64
end_define

begin_define
define|#
directive|define
name|EOT
value|(-1)
end_define

begin_define
define|#
directive|define
name|NA
value|(-2)
end_define

begin_define
define|#
directive|define
name|MODE_TABLE_DELTA
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|vesa_vmode_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|video_info_t
modifier|*
name|vesa_vmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vesa_init_done
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vesa_info
modifier|*
name|vesa_adp_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
modifier|*
name|vesa_vmodetab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vesa_oemstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vesa_venderstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vesa_prodstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vesa_revstr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local macros and functions */
end_comment

begin_define
define|#
directive|define
name|BIOS_SADDRTOLADDR
parameter_list|(
name|p
parameter_list|)
value|((((p)& 0xffff0000)>> 12) + ((p)& 0x0000ffff))
end_define

begin_function_decl
specifier|static
name|int
name|int10_set_mode
parameter_list|(
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_post
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_get_mode
parameter_list|(
name|int
name|mode
parameter_list|,
name|struct
name|vesa_mode
modifier|*
name|vmode
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_set_mode
parameter_list|(
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int vesa_bios_get_dac(void);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|vesa_bios_set_dac
parameter_list|(
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_save_palette
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|,
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_save_palette2
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|r
parameter_list|,
name|u_char
modifier|*
name|g
parameter_list|,
name|u_char
modifier|*
name|b
parameter_list|,
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_load_palette
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|,
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_load_palette2
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|r
parameter_list|,
name|u_char
modifier|*
name|g
parameter_list|,
name|u_char
modifier|*
name|b
parameter_list|,
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|STATE_SIZE
value|0
end_define

begin_define
define|#
directive|define
name|STATE_SAVE
value|1
end_define

begin_define
define|#
directive|define
name|STATE_LOAD
value|2
end_define

begin_function_decl
specifier|static
name|size_t
name|vesa_bios_state_buf_size
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_save_restore
parameter_list|(
name|int
name|code
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MODE_TABLE_BROKEN
end_ifdef

begin_function_decl
specifier|static
name|int
name|vesa_bios_get_line_length
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|vesa_bios_set_line_length
parameter_list|(
name|int
name|pixel
parameter_list|,
name|int
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|lines
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int vesa_bios_get_start(int *x, int *y);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|vesa_bios_set_start
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_map_gen_mode_num
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|color
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_translate_flags
parameter_list|(
name|u_int16_t
name|vflags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_translate_mmodel
parameter_list|(
name|u_int8_t
name|vmodel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_get_bpscanline
parameter_list|(
name|struct
name|vesa_mode
modifier|*
name|vmode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vesa_bios_uninit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vesa_clear_modes
parameter_list|(
name|video_info_t
modifier|*
name|info
parameter_list|,
name|int
name|color
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int vesa_get_origin(video_adapter_t *adp, off_t *offset);
endif|#
directive|endif
end_endif

begin_comment
comment|/* INT 10 BIOS calls */
end_comment

begin_function
specifier|static
name|int
name|int10_set_mode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AL
operator|=
name|mode
expr_stmt|;
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_post
parameter_list|(
name|void
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
name|devclass_t
name|dc
decl_stmt|;
name|device_t
modifier|*
name|devs
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|is_pci
decl_stmt|;
if|if
condition|(
name|x86bios_get_orm
argument_list|(
name|vesa_bios_offs
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|dev
operator|=
name|NULL
expr_stmt|;
name|is_pci
operator|=
literal|0
expr_stmt|;
comment|/* Find the matching PCI video controller. */
name|dc
operator|=
name|devclass_find
argument_list|(
literal|"vgapci"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|!=
name|NULL
operator|&&
name|devclass_get_devices
argument_list|(
name|dc
argument_list|,
operator|&
name|devs
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|device_get_flags
argument_list|(
name|devs
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
operator|&&
name|x86bios_match_device
argument_list|(
name|vesa_bios_offs
argument_list|,
name|devs
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|dev
operator|=
name|devs
index|[
name|i
index|]
expr_stmt|;
name|is_pci
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|devs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
comment|/* Try VGA if a PCI device is not found. */
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|dc
operator|=
name|devclass_find
argument_list|(
name|VGA_DRIVER_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|!=
name|NULL
condition|)
name|dev
operator|=
name|devclass_get_device
argument_list|(
name|dc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: calling BIOS POST\n"
argument_list|,
name|dev
operator|==
name|NULL
condition|?
literal|"VESA"
else|:
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_pci
condition|)
block|{
name|regs
operator|.
name|R_AH
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AL
operator|=
operator|(
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
operator|<<
literal|3
operator|)
operator||
operator|(
name|pci_get_function
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x07
operator|)
expr_stmt|;
block|}
name|regs
operator|.
name|R_DL
operator|=
literal|0x80
expr_stmt|;
name|x86bios_call
argument_list|(
operator|&
name|regs
argument_list|,
name|X86BIOS_PHYSTOSEG
argument_list|(
name|vesa_bios_offs
operator|+
literal|3
argument_list|)
argument_list|,
name|X86BIOS_PHYSTOOFF
argument_list|(
name|vesa_bios_offs
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x86bios_get_intr
argument_list|(
literal|0x10
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* VESA BIOS calls */
end_comment

begin_function
specifier|static
name|int
name|vesa_bios_get_mode
parameter_list|(
name|int
name|mode
parameter_list|,
name|struct
name|vesa_mode
modifier|*
name|vmode
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
name|uint32_t
name|offs
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|x86bios_alloc
argument_list|(
operator|&
name|offs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vmode
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f01
expr_stmt|;
name|regs
operator|.
name|R_CX
operator|=
name|mode
expr_stmt|;
name|regs
operator|.
name|R_ES
operator|=
name|X86BIOS_PHYSTOSEG
argument_list|(
name|offs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_DI
operator|=
name|X86BIOS_PHYSTOOFF
argument_list|(
name|offs
argument_list|)
expr_stmt|;
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|R_AX
operator|!=
literal|0x004f
condition|)
block|{
name|x86bios_free
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vmode
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|buf
argument_list|,
name|vmode
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vmode
argument_list|)
argument_list|)
expr_stmt|;
name|x86bios_free
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vmode
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_set_mode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f02
expr_stmt|;
name|regs
operator|.
name|R_BX
operator|=
name|mode
expr_stmt|;
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
return|return
operator|(
name|regs
operator|.
name|R_AX
operator|!=
literal|0x004f
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int vesa_bios_get_dac(void) { 	x86regs_t regs;  	x86bios_init_regs(&regs); 	regs.R_AX = 0x4f08; 	regs.R_BL = 1;  	x86bios_intr(&regs, 0x10);  	if (regs.R_AX != 0x004f) 		return (6);  	return (regs.R_BH); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vesa_bios_set_dac
parameter_list|(
name|int
name|bits
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f08
expr_stmt|;
comment|/* regs.R_BL = 0; */
name|regs
operator|.
name|R_BH
operator|=
name|bits
expr_stmt|;
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|R_AX
operator|!=
literal|0x004f
condition|)
return|return
operator|(
literal|6
operator|)
return|;
return|return
operator|(
name|regs
operator|.
name|R_BH
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_save_palette
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f09
expr_stmt|;
name|regs
operator|.
name|R_BL
operator|=
literal|1
expr_stmt|;
name|regs
operator|.
name|R_CX
operator|=
name|colors
expr_stmt|;
name|regs
operator|.
name|R_DX
operator|=
name|start
expr_stmt|;
name|regs
operator|.
name|R_ES
operator|=
name|X86BIOS_PHYSTOSEG
argument_list|(
name|vesa_palette_offs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_DI
operator|=
name|X86BIOS_PHYSTOOFF
argument_list|(
name|vesa_palette_offs
argument_list|)
expr_stmt|;
name|bits
operator|=
literal|8
operator|-
name|bits
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vesa_lock
argument_list|)
expr_stmt|;
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|R_AX
operator|!=
literal|0x004f
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|vesa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colors
condition|;
operator|++
name|i
control|)
block|{
name|palette
index|[
name|i
operator|*
literal|3
index|]
operator|=
name|vesa_palette
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|<<
name|bits
expr_stmt|;
name|palette
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|vesa_palette
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|<<
name|bits
expr_stmt|;
name|palette
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|vesa_palette
index|[
name|i
operator|*
literal|4
index|]
operator|<<
name|bits
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|vesa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_save_palette2
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|r
parameter_list|,
name|u_char
modifier|*
name|g
parameter_list|,
name|u_char
modifier|*
name|b
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f09
expr_stmt|;
name|regs
operator|.
name|R_BL
operator|=
literal|1
expr_stmt|;
name|regs
operator|.
name|R_CX
operator|=
name|colors
expr_stmt|;
name|regs
operator|.
name|R_DX
operator|=
name|start
expr_stmt|;
name|regs
operator|.
name|R_ES
operator|=
name|X86BIOS_PHYSTOSEG
argument_list|(
name|vesa_palette_offs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_DI
operator|=
name|X86BIOS_PHYSTOOFF
argument_list|(
name|vesa_palette_offs
argument_list|)
expr_stmt|;
name|bits
operator|=
literal|8
operator|-
name|bits
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vesa_lock
argument_list|)
expr_stmt|;
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|R_AX
operator|!=
literal|0x004f
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|vesa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colors
condition|;
operator|++
name|i
control|)
block|{
name|r
index|[
name|i
index|]
operator|=
name|vesa_palette
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|<<
name|bits
expr_stmt|;
name|g
index|[
name|i
index|]
operator|=
name|vesa_palette
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|<<
name|bits
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|vesa_palette
index|[
name|i
operator|*
literal|4
index|]
operator|<<
name|bits
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|vesa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_load_palette
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f09
expr_stmt|;
comment|/* regs.R_BL = 0; */
name|regs
operator|.
name|R_CX
operator|=
name|colors
expr_stmt|;
name|regs
operator|.
name|R_DX
operator|=
name|start
expr_stmt|;
name|regs
operator|.
name|R_ES
operator|=
name|X86BIOS_PHYSTOSEG
argument_list|(
name|vesa_palette_offs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_DI
operator|=
name|X86BIOS_PHYSTOOFF
argument_list|(
name|vesa_palette_offs
argument_list|)
expr_stmt|;
name|bits
operator|=
literal|8
operator|-
name|bits
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vesa_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colors
condition|;
operator|++
name|i
control|)
block|{
name|vesa_palette
index|[
name|i
operator|*
literal|4
index|]
operator|=
name|palette
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|>>
name|bits
expr_stmt|;
name|vesa_palette
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|=
name|palette
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|>>
name|bits
expr_stmt|;
name|vesa_palette
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|=
name|palette
index|[
name|i
operator|*
literal|3
index|]
operator|>>
name|bits
expr_stmt|;
name|vesa_palette
index|[
name|i
operator|*
literal|4
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vesa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|regs
operator|.
name|R_AX
operator|!=
literal|0x004f
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_load_palette2
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|r
parameter_list|,
name|u_char
modifier|*
name|g
parameter_list|,
name|u_char
modifier|*
name|b
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f09
expr_stmt|;
comment|/* regs.R_BL = 0; */
name|regs
operator|.
name|R_CX
operator|=
name|colors
expr_stmt|;
name|regs
operator|.
name|R_DX
operator|=
name|start
expr_stmt|;
name|regs
operator|.
name|R_ES
operator|=
name|X86BIOS_PHYSTOSEG
argument_list|(
name|vesa_palette_offs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_DI
operator|=
name|X86BIOS_PHYSTOOFF
argument_list|(
name|vesa_palette_offs
argument_list|)
expr_stmt|;
name|bits
operator|=
literal|8
operator|-
name|bits
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vesa_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colors
condition|;
operator|++
name|i
control|)
block|{
name|vesa_palette
index|[
name|i
operator|*
literal|4
index|]
operator|=
name|b
index|[
name|i
index|]
operator|>>
name|bits
expr_stmt|;
name|vesa_palette
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|=
name|g
index|[
name|i
index|]
operator|>>
name|bits
expr_stmt|;
name|vesa_palette
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|=
name|r
index|[
name|i
index|]
operator|>>
name|bits
expr_stmt|;
name|vesa_palette
index|[
name|i
operator|*
literal|4
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vesa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|regs
operator|.
name|R_AX
operator|!=
literal|0x004f
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|vesa_bios_state_buf_size
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f04
expr_stmt|;
comment|/* regs.R_DL = STATE_SIZE; */
name|regs
operator|.
name|R_CX
operator|=
name|state
expr_stmt|;
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|R_AX
operator|!=
literal|0x004f
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|regs
operator|.
name|R_BX
operator|*
literal|64
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_save_restore
parameter_list|(
name|int
name|code
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|STATE_SAVE
operator|&&
name|code
operator|!=
name|STATE_LOAD
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f04
expr_stmt|;
name|regs
operator|.
name|R_DL
operator|=
name|code
expr_stmt|;
name|regs
operator|.
name|R_CX
operator|=
name|vesa_state
expr_stmt|;
name|regs
operator|.
name|R_ES
operator|=
name|X86BIOS_PHYSTOSEG
argument_list|(
name|vesa_state_buf_offs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_BX
operator|=
name|X86BIOS_PHYSTOOFF
argument_list|(
name|vesa_state_buf_offs
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vesa_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|STATE_SAVE
case|:
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|R_AX
operator|==
literal|0x004f
condition|)
name|bcopy
argument_list|(
name|vesa_state_buf
argument_list|,
name|p
argument_list|,
name|vesa_state_buf_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATE_LOAD
case|:
name|bcopy
argument_list|(
name|p
argument_list|,
name|vesa_state_buf
argument_list|,
name|vesa_state_buf_size
argument_list|)
expr_stmt|;
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|vesa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|regs
operator|.
name|R_AX
operator|!=
literal|0x004f
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MODE_TABLE_BROKEN
end_ifdef

begin_function
specifier|static
name|int
name|vesa_bios_get_line_length
parameter_list|(
name|void
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f06
expr_stmt|;
name|regs
operator|.
name|R_BL
operator|=
literal|1
expr_stmt|;
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|R_AX
operator|!=
literal|0x004f
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|regs
operator|.
name|R_BX
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vesa_bios_set_line_length
parameter_list|(
name|int
name|pixel
parameter_list|,
name|int
modifier|*
name|bytes
parameter_list|,
name|int
modifier|*
name|lines
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f06
expr_stmt|;
comment|/* regs.R_BL = 0; */
name|regs
operator|.
name|R_CX
operator|=
name|pixel
expr_stmt|;
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"bx:%d, cx:%d, dx:%d\n"
argument_list|,
name|regs
operator|.
name|R_BX
argument_list|,
name|regs
operator|.
name|R_CX
argument_list|,
name|regs
operator|.
name|R_DX
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|regs
operator|.
name|R_AX
operator|!=
literal|0x004f
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|bytes
operator|!=
name|NULL
condition|)
operator|*
name|bytes
operator|=
name|regs
operator|.
name|R_BX
expr_stmt|;
if|if
condition|(
name|lines
operator|!=
name|NULL
condition|)
operator|*
name|lines
operator|=
name|regs
operator|.
name|R_DX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int vesa_bios_get_start(int *x, int *y) { 	x86regs_t regs;  	x86bios_init_regs(&regs); 	regs.R_AX = 0x4f07; 	regs.R_BL = 1;  	x86bios_intr(&regs, 0x10);  	if (regs.R_AX != 0x004f) 		return (-1);  	*x = regs.R_CX; 	*y = regs.R_DX;  	return (0); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vesa_bios_set_start
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f07
expr_stmt|;
name|regs
operator|.
name|R_BL
operator|=
literal|0x80
expr_stmt|;
name|regs
operator|.
name|R_CX
operator|=
name|x
expr_stmt|;
name|regs
operator|.
name|R_DX
operator|=
name|y
expr_stmt|;
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
return|return
operator|(
name|regs
operator|.
name|R_AX
operator|!=
literal|0x004f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* map a generic video mode to a known mode */
end_comment

begin_function
specifier|static
name|int
name|vesa_map_gen_mode_num
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|color
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
block|}
name|mode_map
index|[]
init|=
block|{
block|{
name|M_TEXT_132x25
block|,
name|M_VESA_C132x25
block|}
block|,
block|{
name|M_TEXT_132x43
block|,
name|M_VESA_C132x43
block|}
block|,
block|{
name|M_TEXT_132x50
block|,
name|M_VESA_C132x50
block|}
block|,
block|{
name|M_TEXT_132x60
block|,
name|M_VESA_C132x60
block|}
block|,     }
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mode_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mode_map
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mode_map
index|[
name|i
index|]
operator|.
name|from
operator|==
name|mode
condition|)
return|return
operator|(
name|mode_map
index|[
name|i
index|]
operator|.
name|to
operator|)
return|;
block|}
return|return
operator|(
name|mode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_translate_flags
parameter_list|(
name|u_int16_t
name|vflags
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|u_int16_t
name|mask
decl_stmt|;
name|int
name|set
decl_stmt|;
name|int
name|reset
decl_stmt|;
block|}
name|ftable
index|[]
init|=
block|{
block|{
name|V_MODECOLOR
block|,
name|V_INFO_COLOR
block|,
literal|0
block|}
block|,
block|{
name|V_MODEGRAPHICS
block|,
name|V_INFO_GRAPHICS
block|,
literal|0
block|}
block|,
block|{
name|V_MODELFB
block|,
name|V_INFO_LINEAR
block|,
literal|0
block|}
block|,
block|{
name|V_MODENONVGA
block|,
name|V_INFO_NONVGA
block|,
literal|0
block|}
block|, 	}
struct|;
name|int
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|flags
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ftable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ftable
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|flags
operator||=
operator|(
name|vflags
operator|&
name|ftable
index|[
name|i
index|]
operator|.
name|mask
operator|)
condition|?
name|ftable
index|[
name|i
index|]
operator|.
name|set
else|:
name|ftable
index|[
name|i
index|]
operator|.
name|reset
expr_stmt|;
block|}
return|return
operator|(
name|flags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_translate_mmodel
parameter_list|(
name|u_int8_t
name|vmodel
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|u_int8_t
name|vmodel
decl_stmt|;
name|int
name|mmodel
decl_stmt|;
block|}
name|mtable
index|[]
init|=
block|{
block|{
name|V_MMTEXT
block|,
name|V_INFO_MM_TEXT
block|}
block|,
block|{
name|V_MMCGA
block|,
name|V_INFO_MM_CGA
block|}
block|,
block|{
name|V_MMHGC
block|,
name|V_INFO_MM_HGC
block|}
block|,
block|{
name|V_MMEGA
block|,
name|V_INFO_MM_PLANAR
block|}
block|,
block|{
name|V_MMPACKED
block|,
name|V_INFO_MM_PACKED
block|}
block|,
block|{
name|V_MMDIRCOLOR
block|,
name|V_INFO_MM_DIRECT
block|}
block|, 	}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mtable
index|[
name|i
index|]
operator|.
name|mmodel
operator|>=
literal|0
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mtable
index|[
name|i
index|]
operator|.
name|vmodel
operator|==
name|vmodel
condition|)
return|return
operator|(
name|mtable
index|[
name|i
index|]
operator|.
name|mmodel
operator|)
return|;
block|}
return|return
operator|(
name|V_INFO_MM_OTHER
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_get_bpscanline
parameter_list|(
name|struct
name|vesa_mode
modifier|*
name|vmode
parameter_list|)
block|{
name|int
name|bpsl
decl_stmt|;
if|if
condition|(
operator|(
name|vmode
operator|->
name|v_modeattr
operator|&
name|V_MODEGRAPHICS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Find the minimum length. */
switch|switch
condition|(
name|vmode
operator|->
name|v_bpp
operator|/
name|vmode
operator|->
name|v_planes
condition|)
block|{
case|case
literal|1
case|:
name|bpsl
operator|=
name|vmode
operator|->
name|v_width
operator|/
literal|8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bpsl
operator|=
name|vmode
operator|->
name|v_width
operator|/
literal|4
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bpsl
operator|=
name|vmode
operator|->
name|v_width
operator|/
literal|2
expr_stmt|;
break|break;
default|default:
name|bpsl
operator|=
name|vmode
operator|->
name|v_width
operator|*
operator|(
operator|(
name|vmode
operator|->
name|v_bpp
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
name|bpsl
operator|/=
name|vmode
operator|->
name|v_planes
expr_stmt|;
break|break;
block|}
comment|/* Use VBE 3.0 information if it looks sane. */
if|if
condition|(
operator|(
name|vmode
operator|->
name|v_modeattr
operator|&
name|V_MODELFB
operator|)
operator|!=
literal|0
operator|&&
name|vesa_adp_info
operator|->
name|v_version
operator|>=
literal|0x0300
operator|&&
name|vmode
operator|->
name|v_linbpscanline
operator|>
name|bpsl
condition|)
return|return
operator|(
name|vmode
operator|->
name|v_linbpscanline
operator|)
return|;
comment|/* Return the minimum if the mode table looks absurd. */
if|if
condition|(
name|vmode
operator|->
name|v_bpscanline
operator|<
name|bpsl
condition|)
return|return
operator|(
name|bpsl
operator|)
return|;
block|}
return|return
operator|(
name|vmode
operator|->
name|v_bpscanline
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|VESA_MAXSTR
value|256
end_define

begin_define
define|#
directive|define
name|VESA_STRCPY
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
value|do {				\ 	char *str;						\ 	int i;							\ 	dst = malloc(VESA_MAXSTR, M_DEVBUF, M_WAITOK);		\ 	str = x86bios_offset(BIOS_SADDRTOLADDR(src));		\ 	for (i = 0; i< VESA_MAXSTR - 1&& str[i] != '\0'; i++)	\ 		dst[i] = str[i];				\ 	dst[i] = '\0';						\ } while (0)
end_define

begin_function
specifier|static
name|int
name|vesa_bios_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|vesa_mode
name|vmode
decl_stmt|;
name|struct
name|vesa_info
modifier|*
name|buf
decl_stmt|;
name|video_info_t
modifier|*
name|p
decl_stmt|;
name|x86regs_t
name|regs
decl_stmt|;
name|size_t
name|bsize
decl_stmt|;
name|size_t
name|msize
decl_stmt|;
name|void
modifier|*
name|vmbuf
decl_stmt|;
name|uint8_t
modifier|*
name|vbios
decl_stmt|;
name|uint32_t
name|offs
decl_stmt|;
name|uint16_t
name|vers
decl_stmt|;
name|int
name|is_via_cle266
decl_stmt|;
name|int
name|modes
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|vesa_init_done
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vesa_bios_offs
operator|=
name|VESA_BIOS_OFFSET
expr_stmt|;
comment|/* 	 * If the VBE real mode interrupt vector is not found, try BIOS POST. 	 */
name|vesa_bios_int10
operator|=
name|x86bios_get_intr
argument_list|(
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|vesa_bios_int10
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vesa_bios_post
argument_list|()
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|vesa_bios_int10
operator|=
name|x86bios_get_intr
argument_list|(
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|vesa_bios_int10
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Shadow video ROM. 	 */
name|offs
operator|=
name|vesa_bios_int10
expr_stmt|;
if|if
condition|(
name|vesa_shadow_rom
condition|)
block|{
name|vbios
operator|=
name|x86bios_get_orm
argument_list|(
name|vesa_bios_offs
argument_list|)
expr_stmt|;
if|if
condition|(
name|vbios
operator|!=
name|NULL
condition|)
block|{
name|vesa_bios_size
operator|=
name|vbios
index|[
literal|2
index|]
operator|*
literal|512
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|VESA_BIOS_OFFSET
operator|<<
literal|12
operator|)
operator|&
literal|0xffff0000
operator|)
operator|==
operator|(
name|vesa_bios_int10
operator|&
literal|0xffff0000
operator|)
operator|&&
name|vesa_bios_size
operator|>
operator|(
name|vesa_bios_int10
operator|&
literal|0xffff
operator|)
condition|)
block|{
name|vesa_bios
operator|=
name|x86bios_alloc
argument_list|(
operator|&
name|vesa_bios_offs
argument_list|,
name|vesa_bios_size
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|vbios
argument_list|,
name|vesa_bios
argument_list|,
name|vesa_bios_size
argument_list|)
expr_stmt|;
name|offs
operator|=
operator|(
operator|(
name|vesa_bios_offs
operator|<<
literal|12
operator|)
operator|&
literal|0xffff0000
operator|)
operator|+
operator|(
name|vesa_bios_int10
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|x86bios_set_intr
argument_list|(
literal|0x10
argument_list|,
name|offs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vesa_bios
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"VESA: failed to shadow video ROM\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"VESA: INT 0x10 vector 0x%04x:0x%04x\n"
argument_list|,
operator|(
name|offs
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
name|offs
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f00
expr_stmt|;
name|vmbuf
operator|=
name|x86bios_alloc
argument_list|(
operator|&
name|offs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_ES
operator|=
name|X86BIOS_PHYSTOSEG
argument_list|(
name|offs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_DI
operator|=
name|X86BIOS_PHYSTOOFF
argument_list|(
name|offs
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"VBE2"
argument_list|,
name|vmbuf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* try for VBE2 data */
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|R_AX
operator|!=
literal|0x004f
operator|||
name|bcmp
argument_list|(
literal|"VESA"
argument_list|,
name|vmbuf
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|vesa_adp_info
operator|=
name|buf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|vmbuf
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"VESA: information block\n"
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|HD_OMIT_CHARS
argument_list|)
expr_stmt|;
block|}
name|vers
operator|=
name|buf
operator|->
name|v_version
operator|=
name|le16toh
argument_list|(
name|buf
operator|->
name|v_version
argument_list|)
expr_stmt|;
name|buf
operator|->
name|v_oemstr
operator|=
name|le32toh
argument_list|(
name|buf
operator|->
name|v_oemstr
argument_list|)
expr_stmt|;
name|buf
operator|->
name|v_flags
operator|=
name|le32toh
argument_list|(
name|buf
operator|->
name|v_flags
argument_list|)
expr_stmt|;
name|buf
operator|->
name|v_modetable
operator|=
name|le32toh
argument_list|(
name|buf
operator|->
name|v_modetable
argument_list|)
expr_stmt|;
name|buf
operator|->
name|v_memsize
operator|=
name|le16toh
argument_list|(
name|buf
operator|->
name|v_memsize
argument_list|)
expr_stmt|;
name|buf
operator|->
name|v_revision
operator|=
name|le16toh
argument_list|(
name|buf
operator|->
name|v_revision
argument_list|)
expr_stmt|;
name|buf
operator|->
name|v_venderstr
operator|=
name|le32toh
argument_list|(
name|buf
operator|->
name|v_venderstr
argument_list|)
expr_stmt|;
name|buf
operator|->
name|v_prodstr
operator|=
name|le32toh
argument_list|(
name|buf
operator|->
name|v_prodstr
argument_list|)
expr_stmt|;
name|buf
operator|->
name|v_revstr
operator|=
name|le32toh
argument_list|(
name|buf
operator|->
name|v_revstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|<
literal|0x0102
condition|)
block|{
name|printf
argument_list|(
literal|"VESA: VBE version %d.%d is not supported; "
literal|"version 1.2 or later is required.\n"
argument_list|,
operator|(
operator|(
name|vers
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|vers
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
operator|)
argument_list|,
operator|(
operator|(
name|vers
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
operator|)
operator|*
literal|10
operator|+
operator|(
name|vers
operator|&
literal|0x000f
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|VESA_STRCPY
argument_list|(
name|vesa_oemstr
argument_list|,
name|buf
operator|->
name|v_oemstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|>=
literal|0x0200
condition|)
block|{
name|VESA_STRCPY
argument_list|(
name|vesa_venderstr
argument_list|,
name|buf
operator|->
name|v_venderstr
argument_list|)
expr_stmt|;
name|VESA_STRCPY
argument_list|(
name|vesa_prodstr
argument_list|,
name|buf
operator|->
name|v_prodstr
argument_list|)
expr_stmt|;
name|VESA_STRCPY
argument_list|(
name|vesa_revstr
argument_list|,
name|buf
operator|->
name|v_revstr
argument_list|)
expr_stmt|;
block|}
name|is_via_cle266
operator|=
name|strncmp
argument_list|(
name|vesa_oemstr
argument_list|,
name|VESA_VIA_CLE266
argument_list|,
sizeof|sizeof
argument_list|(
name|VESA_VIA_CLE266
argument_list|)
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|v_modetable
operator|==
literal|0
condition|)
goto|goto
name|fail
goto|;
name|msize
operator|=
operator|(
name|size_t
operator|)
name|buf
operator|->
name|v_memsize
operator|*
literal|64
operator|*
literal|1024
expr_stmt|;
name|vesa_vmodetab
operator|=
name|x86bios_offset
argument_list|(
name|BIOS_SADDRTOLADDR
argument_list|(
name|buf
operator|->
name|v_modetable
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|modes
operator|=
literal|0
init|;
operator|(
name|i
operator|<
operator|(
name|M_VESA_MODE_MAX
operator|-
name|M_VESA_BASE
operator|+
literal|1
operator|)
operator|)
operator|&&
operator|(
name|vesa_vmodetab
index|[
name|i
index|]
operator|!=
literal|0xffff
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|vesa_vmodetab
index|[
name|i
index|]
operator|=
name|le16toh
argument_list|(
name|vesa_vmodetab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vesa_bios_get_mode
argument_list|(
name|vesa_vmodetab
index|[
name|i
index|]
argument_list|,
operator|&
name|vmode
argument_list|,
name|M_WAITOK
argument_list|)
condition|)
continue|continue;
name|vmode
operator|.
name|v_modeattr
operator|=
name|le16toh
argument_list|(
name|vmode
operator|.
name|v_modeattr
argument_list|)
expr_stmt|;
name|vmode
operator|.
name|v_wgran
operator|=
name|le16toh
argument_list|(
name|vmode
operator|.
name|v_wgran
argument_list|)
expr_stmt|;
name|vmode
operator|.
name|v_wsize
operator|=
name|le16toh
argument_list|(
name|vmode
operator|.
name|v_wsize
argument_list|)
expr_stmt|;
name|vmode
operator|.
name|v_waseg
operator|=
name|le16toh
argument_list|(
name|vmode
operator|.
name|v_waseg
argument_list|)
expr_stmt|;
name|vmode
operator|.
name|v_wbseg
operator|=
name|le16toh
argument_list|(
name|vmode
operator|.
name|v_wbseg
argument_list|)
expr_stmt|;
name|vmode
operator|.
name|v_posfunc
operator|=
name|le32toh
argument_list|(
name|vmode
operator|.
name|v_posfunc
argument_list|)
expr_stmt|;
name|vmode
operator|.
name|v_bpscanline
operator|=
name|le16toh
argument_list|(
name|vmode
operator|.
name|v_bpscanline
argument_list|)
expr_stmt|;
name|vmode
operator|.
name|v_width
operator|=
name|le16toh
argument_list|(
name|vmode
operator|.
name|v_width
argument_list|)
expr_stmt|;
name|vmode
operator|.
name|v_height
operator|=
name|le16toh
argument_list|(
name|vmode
operator|.
name|v_height
argument_list|)
expr_stmt|;
name|vmode
operator|.
name|v_lfb
operator|=
name|le32toh
argument_list|(
name|vmode
operator|.
name|v_lfb
argument_list|)
expr_stmt|;
name|vmode
operator|.
name|v_offscreen
operator|=
name|le32toh
argument_list|(
name|vmode
operator|.
name|v_offscreen
argument_list|)
expr_stmt|;
name|vmode
operator|.
name|v_offscreensize
operator|=
name|le16toh
argument_list|(
name|vmode
operator|.
name|v_offscreensize
argument_list|)
expr_stmt|;
name|vmode
operator|.
name|v_linbpscanline
operator|=
name|le16toh
argument_list|(
name|vmode
operator|.
name|v_linbpscanline
argument_list|)
expr_stmt|;
name|vmode
operator|.
name|v_maxpixelclock
operator|=
name|le32toh
argument_list|(
name|vmode
operator|.
name|v_maxpixelclock
argument_list|)
expr_stmt|;
comment|/* reject unsupported modes */
if|#
directive|if
literal|0
block|if ((vmode.v_modeattr& 		    (V_MODESUPP | V_MODEOPTINFO | V_MODENONVGA)) != 		    (V_MODESUPP | V_MODEOPTINFO)) 			continue;
else|#
directive|else
if|if
condition|(
operator|(
name|vmode
operator|.
name|v_modeattr
operator|&
name|V_MODEOPTINFO
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"Rejecting VESA %s mode: %d x %d x %d bpp "
literal|" attr = %x\n"
argument_list|,
name|vmode
operator|.
name|v_modeattr
operator|&
name|V_MODEGRAPHICS
condition|?
literal|"graphics"
else|:
literal|"text"
argument_list|,
name|vmode
operator|.
name|v_width
argument_list|,
name|vmode
operator|.
name|v_height
argument_list|,
name|vmode
operator|.
name|v_bpp
argument_list|,
name|vmode
operator|.
name|v_modeattr
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
endif|#
directive|endif
name|bsize
operator|=
name|vesa_get_bpscanline
argument_list|(
operator|&
name|vmode
argument_list|)
operator|*
name|vmode
operator|.
name|v_height
expr_stmt|;
if|if
condition|(
operator|(
name|vmode
operator|.
name|v_modeattr
operator|&
name|V_MODEGRAPHICS
operator|)
operator|!=
literal|0
condition|)
name|bsize
operator|*=
name|vmode
operator|.
name|v_planes
expr_stmt|;
comment|/* Does it have enough memory to support this mode? */
if|if
condition|(
name|msize
operator|<
name|bsize
condition|)
block|{
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"Rejecting VESA %s mode: %d x %d x %d bpp "
literal|" attr = %x, not enough memory\n"
argument_list|,
name|vmode
operator|.
name|v_modeattr
operator|&
name|V_MODEGRAPHICS
condition|?
literal|"graphics"
else|:
literal|"text"
argument_list|,
name|vmode
operator|.
name|v_width
argument_list|,
name|vmode
operator|.
name|v_height
argument_list|,
name|vmode
operator|.
name|v_bpp
argument_list|,
name|vmode
operator|.
name|v_modeattr
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|bsize
operator|>
name|vesa_vmem_max
condition|)
name|vesa_vmem_max
operator|=
name|bsize
expr_stmt|;
comment|/* expand the array if necessary */
if|if
condition|(
name|modes
operator|>=
name|vesa_vmode_max
condition|)
block|{
name|vesa_vmode_max
operator|+=
name|MODE_TABLE_DELTA
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vesa_vmode
argument_list|)
operator|*
operator|(
name|vesa_vmode_max
operator|+
literal|1
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"vesa_bios_init(): modes:%d, vesa_mode_max:%d\n"
argument_list|,
name|modes
argument_list|,
name|vesa_vmode_max
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|modes
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|vesa_vmode
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vesa_vmode
argument_list|)
operator|*
name|modes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vesa_vmode
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|vesa_vmode
operator|=
name|p
expr_stmt|;
block|}
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"Found VESA %s mode: %d x %d x %d bpp\n"
argument_list|,
name|vmode
operator|.
name|v_modeattr
operator|&
name|V_MODEGRAPHICS
condition|?
literal|"graphics"
else|:
literal|"text"
argument_list|,
name|vmode
operator|.
name|v_width
argument_list|,
name|vmode
operator|.
name|v_height
argument_list|,
name|vmode
operator|.
name|v_bpp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|is_via_cle266
condition|)
block|{
if|if
condition|(
operator|(
name|vmode
operator|.
name|v_width
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
operator|==
name|vmode
operator|.
name|v_height
operator|-
literal|1
condition|)
block|{
name|vmode
operator|.
name|v_width
operator|&=
literal|0xff
expr_stmt|;
name|vmode
operator|.
name|v_waseg
operator|=
literal|0xb8000
operator|>>
literal|4
expr_stmt|;
block|}
block|}
comment|/* copy some fields */
name|bzero
argument_list|(
operator|&
name|vesa_vmode
index|[
name|modes
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|vesa_vmode
index|[
name|modes
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_mode
operator|=
name|vesa_vmodetab
index|[
name|i
index|]
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_width
operator|=
name|vmode
operator|.
name|v_width
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_height
operator|=
name|vmode
operator|.
name|v_height
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_depth
operator|=
name|vmode
operator|.
name|v_bpp
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_planes
operator|=
name|vmode
operator|.
name|v_planes
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_cwidth
operator|=
name|vmode
operator|.
name|v_cwidth
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_cheight
operator|=
name|vmode
operator|.
name|v_cheight
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_window
operator|=
operator|(
name|vm_offset_t
operator|)
name|vmode
operator|.
name|v_waseg
operator|<<
literal|4
expr_stmt|;
comment|/* XXX window B */
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_window_size
operator|=
name|vmode
operator|.
name|v_wsize
operator|*
literal|1024
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_window_gran
operator|=
name|vmode
operator|.
name|v_wgran
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|vmode
operator|.
name|v_modeattr
operator|&
name|V_MODELFB
condition|)
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_buffer
operator|=
name|vmode
operator|.
name|v_lfb
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_buffer_size
operator|=
name|bsize
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_mem_model
operator|=
name|vesa_translate_mmodel
argument_list|(
name|vmode
operator|.
name|v_memmodel
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_mem_model
condition|)
block|{
case|case
name|V_INFO_MM_DIRECT
case|:
if|if
condition|(
operator|(
name|vmode
operator|.
name|v_modeattr
operator|&
name|V_MODELFB
operator|)
operator|!=
literal|0
operator|&&
name|vers
operator|>=
literal|0x0300
condition|)
block|{
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|0
index|]
operator|=
name|vmode
operator|.
name|v_linredfieldpos
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|1
index|]
operator|=
name|vmode
operator|.
name|v_lingreenfieldpos
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|2
index|]
operator|=
name|vmode
operator|.
name|v_linbluefieldpos
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|3
index|]
operator|=
name|vmode
operator|.
name|v_linresfieldpos
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|0
index|]
operator|=
name|vmode
operator|.
name|v_linredmasksize
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|1
index|]
operator|=
name|vmode
operator|.
name|v_lingreenmasksize
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|2
index|]
operator|=
name|vmode
operator|.
name|v_linbluemasksize
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|3
index|]
operator|=
name|vmode
operator|.
name|v_linresmasksize
expr_stmt|;
block|}
else|else
block|{
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|0
index|]
operator|=
name|vmode
operator|.
name|v_redfieldpos
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|1
index|]
operator|=
name|vmode
operator|.
name|v_greenfieldpos
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|2
index|]
operator|=
name|vmode
operator|.
name|v_bluefieldpos
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|3
index|]
operator|=
name|vmode
operator|.
name|v_resfieldpos
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|0
index|]
operator|=
name|vmode
operator|.
name|v_redmasksize
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|1
index|]
operator|=
name|vmode
operator|.
name|v_greenmasksize
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|2
index|]
operator|=
name|vmode
operator|.
name|v_bluemasksize
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|3
index|]
operator|=
name|vmode
operator|.
name|v_resmasksize
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|V_INFO_MM_PACKED
case|:
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_size
operator|=
operator|(
name|vmode
operator|.
name|v_bpp
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
break|break;
block|}
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_flags
operator|=
name|vesa_translate_flags
argument_list|(
name|vmode
operator|.
name|v_modeattr
argument_list|)
operator||
name|V_INFO_VESA
expr_stmt|;
operator|++
name|modes
expr_stmt|;
block|}
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_mode
operator|=
name|EOT
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"VESA: %d mode(s) found\n"
argument_list|,
name|modes
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
operator|==
literal|0
condition|)
goto|goto
name|fail
goto|;
name|x86bios_free
argument_list|(
name|vmbuf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Probe supported save/restore states. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vesa_bios_state_buf_size
argument_list|(
literal|1
operator|<<
name|i
argument_list|)
operator|>
literal|0
condition|)
name|vesa_state
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
if|if
condition|(
name|vesa_state
operator|!=
literal|0
condition|)
name|vesa_state_buf_size
operator|=
name|vesa_bios_state_buf_size
argument_list|(
name|vesa_state
argument_list|)
expr_stmt|;
name|vesa_palette
operator|=
name|x86bios_alloc
argument_list|(
operator|&
name|vesa_palette_offs
argument_list|,
name|VESA_PALETTE_SIZE
operator|+
name|vesa_state_buf_size
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|vesa_state_buf_size
operator|>
literal|0
condition|)
block|{
name|vesa_state_buf
operator|=
name|vesa_palette
operator|+
name|VESA_PALETTE_SIZE
expr_stmt|;
name|vesa_state_buf_offs
operator|=
name|vesa_palette_offs
operator|+
name|VESA_PALETTE_SIZE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|x86bios_free
argument_list|(
name|vmbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|vesa_bios_uninit
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vesa_bios_uninit
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|vesa_bios
operator|!=
name|NULL
condition|)
block|{
name|x86bios_set_intr
argument_list|(
literal|0x10
argument_list|,
name|vesa_bios_int10
argument_list|)
expr_stmt|;
name|vesa_bios_offs
operator|=
name|VESA_BIOS_OFFSET
expr_stmt|;
name|x86bios_free
argument_list|(
name|vesa_bios
argument_list|,
name|vesa_bios_size
argument_list|)
expr_stmt|;
name|vesa_bios
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vesa_adp_info
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|vesa_adp_info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|vesa_adp_info
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vesa_oemstr
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|vesa_oemstr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|vesa_oemstr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vesa_venderstr
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|vesa_venderstr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|vesa_venderstr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vesa_prodstr
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|vesa_prodstr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|vesa_prodstr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vesa_revstr
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|vesa_revstr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|vesa_revstr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vesa_vmode
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|vesa_vmode
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|vesa_vmode
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vesa_palette
operator|!=
name|NULL
condition|)
block|{
name|x86bios_free
argument_list|(
name|vesa_palette
argument_list|,
name|VESA_PALETTE_SIZE
operator|+
name|vesa_state_buf_size
argument_list|)
expr_stmt|;
name|vesa_palette
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vesa_clear_modes
parameter_list|(
name|video_info_t
modifier|*
name|info
parameter_list|,
name|int
name|color
parameter_list|)
block|{
while|while
condition|(
name|info
operator|->
name|vi_mode
operator|!=
name|EOT
condition|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|vi_flags
operator|&
name|V_INFO_COLOR
operator|)
operator|!=
name|color
condition|)
name|info
operator|->
name|vi_mode
operator|=
name|NA
expr_stmt|;
operator|++
name|info
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* entry points */
end_comment

begin_function
specifier|static
name|int
name|vesa_configure
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|video_adapter_t
modifier|*
name|adp
decl_stmt|;
name|int
name|adapters
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|vesa_init_done
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|VIO_PROBE_ONLY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the VESA module has already been loaded, abort loading  	 * the module this time. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|adp
operator|=
name|vid_get_adapter
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_VESA
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_VGA
condition|)
break|break;
block|}
comment|/* 	 * The VGA adapter is not found.  This is because either  	 * 1) the VGA driver has not been initialized, or 2) the VGA card 	 * is not present.  If 1) is the case, we shall defer 	 * initialization for now and try again later. 	 */
if|if
condition|(
name|adp
operator|==
name|NULL
condition|)
block|{
name|vga_sub_configure
operator|=
name|vesa_configure
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* count number of registered adapters */
for|for
control|(
operator|++
name|i
init|;
name|vid_get_adapter
argument_list|(
name|i
argument_list|)
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
empty_stmt|;
name|adapters
operator|=
name|i
expr_stmt|;
comment|/* call VESA BIOS */
name|vesa_adp
operator|=
name|adp
expr_stmt|;
if|if
condition|(
name|vesa_bios_init
argument_list|()
condition|)
block|{
name|vesa_adp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|vesa_adp
operator|->
name|va_flags
operator||=
name|V_ADP_VESA
expr_stmt|;
comment|/* remove conflicting modes if we have more than one adapter */
if|if
condition|(
name|adapters
operator|>
literal|1
condition|)
block|{
name|vesa_clear_modes
argument_list|(
name|vesa_vmode
argument_list|,
operator|(
name|vesa_adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
name|V_INFO_COLOR
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|vesa_load_ioctl
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|prevvidsw
operator|=
name|vidsw
index|[
name|vesa_adp
operator|->
name|va_index
index|]
expr_stmt|;
name|vidsw
index|[
name|vesa_adp
operator|->
name|va_index
index|]
operator|=
operator|&
name|vesavidsw
expr_stmt|;
name|vesa_init_done
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|vesa_adp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int vesa_nop(void) {  	return (0); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vesa_error
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_probe
parameter_list|(
name|int
name|unit
parameter_list|,
name|video_adapter_t
modifier|*
modifier|*
name|adpp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|probe
call|)
argument_list|(
name|unit
argument_list|,
name|adpp
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_init
parameter_list|(
name|int
name|unit
parameter_list|,
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|init
call|)
argument_list|(
name|unit
argument_list|,
name|adp
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_get_info
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|mode
parameter_list|,
name|video_info_t
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|prevvidsw
operator|->
name|get_info
call|)
argument_list|(
name|adp
argument_list|,
name|mode
argument_list|,
name|info
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|mode
operator|=
name|vesa_map_gen_mode_num
argument_list|(
name|vesa_adp
operator|->
name|va_type
argument_list|,
name|vesa_adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|!=
name|EOT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|==
name|NA
condition|)
continue|continue;
if|if
condition|(
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|==
name|mode
condition|)
block|{
operator|*
name|info
operator|=
name|vesa_vmode
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_query_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_info_t
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|prevvidsw
operator|->
name|query_mode
call|)
argument_list|(
name|adp
argument_list|,
name|info
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|!=
name|EOT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|vi_width
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_width
operator|!=
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_width
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_height
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_height
operator|!=
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_height
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_cwidth
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_cwidth
operator|!=
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_cwidth
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_cheight
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_cheight
operator|!=
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_cheight
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_depth
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_depth
operator|!=
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_depth
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_planes
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_planes
operator|!=
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_planes
operator|)
condition|)
continue|continue;
comment|/* pixel format, memory model */
if|if
condition|(
operator|(
name|info
operator|->
name|vi_flags
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_flags
operator|!=
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_flags
operator|)
condition|)
continue|continue;
operator|*
name|info
operator|=
name|vesa_vmode
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_set_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
condition|)
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|set_mode
call|)
argument_list|(
name|adp
argument_list|,
name|mode
argument_list|)
operator|)
return|;
name|mode
operator|=
name|vesa_map_gen_mode_num
argument_list|(
name|adp
operator|->
name|va_type
argument_list|,
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"VESA: set_mode(): %d(%x) -> %d(%x)\n"
argument_list|,
name|adp
operator|->
name|va_mode
argument_list|,
name|adp
operator|->
name|va_mode
argument_list|,
name|mode
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  	 * If the current mode is a VESA mode and the new mode is not, 	 * restore the state of the adapter first by setting one of the 	 * standard VGA mode, so that non-standard, extended SVGA registers  	 * are set to the state compatible with the standard VGA modes.  	 * Otherwise (*prevvidsw->set_mode)() may not be able to set up  	 * the new mode correctly. 	 */
if|if
condition|(
name|VESA_MODE
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|VESA_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
call|(
modifier|*
name|prevvidsw
operator|->
name|get_info
call|)
argument_list|(
name|adp
argument_list|,
name|mode
argument_list|,
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_DAC8
operator|)
operator|!=
literal|0
condition|)
block|{
name|vesa_bios_set_dac
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|adp
operator|->
name|va_flags
operator|&=
operator|~
name|V_ADP_DAC8
expr_stmt|;
block|}
name|int10_set_mode
argument_list|(
name|adp
operator|->
name|va_initial_bios_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|va_info
operator|.
name|vi_flags
operator|&
name|V_INFO_LINEAR
condition|)
name|pmap_unmapdev
argument_list|(
name|adp
operator|->
name|va_buffer
argument_list|,
name|vesa_vmem_max
argument_list|)
expr_stmt|;
comment|/*  			 * Once (*prevvidsw->get_info)() succeeded,  			 * (*prevvidsw->set_mode)() below won't fail... 			 */
block|}
block|}
comment|/* we may not need to handle this mode after all... */
if|if
condition|(
operator|!
name|VESA_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
call|(
modifier|*
name|prevvidsw
operator|->
name|set_mode
call|)
argument_list|(
name|adp
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* is the new mode supported? */
if|if
condition|(
name|vesa_get_info
argument_list|(
name|adp
argument_list|,
name|mode
argument_list|,
operator|&
name|info
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* assert(VESA_MODE(mode)); */
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"VESA: about to set a VESA mode...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* don't use the linear frame buffer for text modes. XXX */
if|if
condition|(
operator|!
operator|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
operator|)
condition|)
name|info
operator|.
name|vi_flags
operator|&=
operator|~
name|V_INFO_LINEAR
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_LINEAR
operator|)
operator|!=
literal|0
condition|)
name|mode
operator||=
literal|0x4000
expr_stmt|;
if|if
condition|(
name|vesa_bios_set_mode
argument_list|(
name|mode
operator||
literal|0x8000
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Palette format is reset by the above VBE function call. */
name|adp
operator|->
name|va_flags
operator|&=
operator|~
name|V_ADP_DAC8
expr_stmt|;
if|if
condition|(
operator|(
name|vesa_adp_info
operator|->
name|v_flags
operator|&
name|V_DAC8
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
operator|)
operator|!=
literal|0
operator|&&
name|vesa_bios_set_dac
argument_list|(
literal|8
argument_list|)
operator|>
literal|6
condition|)
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_DAC8
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|va_info
operator|.
name|vi_flags
operator|&
name|V_INFO_LINEAR
condition|)
name|pmap_unmapdev
argument_list|(
name|adp
operator|->
name|va_buffer
argument_list|,
name|vesa_vmem_max
argument_list|)
expr_stmt|;
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"VESA: mode set!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vesa_adp
operator|->
name|va_mode
operator|=
name|mode
operator|&
literal|0x1ff
expr_stmt|;
comment|/* Mode number is 9-bit. */
name|vesa_adp
operator|->
name|va_flags
operator|&=
operator|~
name|V_ADP_COLOR
expr_stmt|;
name|vesa_adp
operator|->
name|va_flags
operator||=
operator|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_COLOR
operator|)
condition|?
name|V_ADP_COLOR
else|:
literal|0
expr_stmt|;
name|vesa_adp
operator|->
name|va_crtc_addr
operator|=
operator|(
name|vesa_adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
name|COLOR_CRTC
else|:
name|MONO_CRTC
expr_stmt|;
name|vesa_adp
operator|->
name|va_line_width
operator|=
name|info
operator|.
name|vi_buffer_size
operator|/
name|info
operator|.
name|vi_height
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
operator|)
operator|!=
literal|0
condition|)
name|vesa_adp
operator|->
name|va_line_width
operator|/=
name|info
operator|.
name|vi_planes
expr_stmt|;
ifdef|#
directive|ifdef
name|MODE_TABLE_BROKEN
comment|/* If VBE function returns bigger bytes per scan line, use it. */
block|{
name|int
name|bpsl
init|=
name|vesa_bios_get_line_length
argument_list|()
decl_stmt|;
if|if
condition|(
name|bpsl
operator|>
name|vesa_adp
operator|->
name|va_line_width
condition|)
block|{
name|vesa_adp
operator|->
name|va_line_width
operator|=
name|bpsl
expr_stmt|;
name|info
operator|.
name|vi_buffer_size
operator|=
name|bpsl
operator|*
name|info
operator|.
name|vi_height
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
operator|)
operator|!=
literal|0
condition|)
name|info
operator|.
name|vi_buffer_size
operator|*=
name|info
operator|.
name|vi_planes
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_LINEAR
condition|)
block|{
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"VESA: setting up LFB\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vesa_adp
operator|->
name|va_buffer
operator|=
operator|(
name|vm_offset_t
operator|)
name|pmap_mapdev_attr
argument_list|(
name|info
operator|.
name|vi_buffer
argument_list|,
name|vesa_vmem_max
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
name|vesa_adp
operator|->
name|va_window
operator|=
name|vesa_adp
operator|->
name|va_buffer
expr_stmt|;
name|vesa_adp
operator|->
name|va_window_size
operator|=
name|info
operator|.
name|vi_buffer_size
operator|/
name|info
operator|.
name|vi_planes
expr_stmt|;
name|vesa_adp
operator|->
name|va_window_gran
operator|=
name|info
operator|.
name|vi_buffer_size
operator|/
name|info
operator|.
name|vi_planes
expr_stmt|;
block|}
else|else
block|{
name|vesa_adp
operator|->
name|va_buffer
operator|=
literal|0
expr_stmt|;
name|vesa_adp
operator|->
name|va_window
operator|=
operator|(
name|vm_offset_t
operator|)
name|x86bios_offset
argument_list|(
name|info
operator|.
name|vi_window
argument_list|)
expr_stmt|;
name|vesa_adp
operator|->
name|va_window_size
operator|=
name|info
operator|.
name|vi_window_size
expr_stmt|;
name|vesa_adp
operator|->
name|va_window_gran
operator|=
name|info
operator|.
name|vi_window_gran
expr_stmt|;
block|}
name|vesa_adp
operator|->
name|va_buffer_size
operator|=
name|info
operator|.
name|vi_buffer_size
expr_stmt|;
name|vesa_adp
operator|->
name|va_window_orig
operator|=
literal|0
expr_stmt|;
name|vesa_adp
operator|->
name|va_disp_start
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|vesa_adp
operator|->
name|va_disp_start
operator|.
name|y
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"vesa_set_mode(): vi_width:%d, line_width:%d\n"
argument_list|,
name|info
operator|.
name|vi_width
argument_list|,
name|vesa_adp
operator|->
name|va_line_width
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|vesa_adp
operator|->
name|va_info
argument_list|,
sizeof|sizeof
argument_list|(
name|vesa_adp
operator|->
name|va_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* move hardware cursor out of the way */
operator|(
operator|*
name|vidsw
index|[
name|vesa_adp
operator|->
name|va_index
index|]
operator|->
name|set_hw_cursor
operator|)
operator|(
name|vesa_adp
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_save_font
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|page
parameter_list|,
name|int
name|fontsize
parameter_list|,
name|int
name|fontwidth
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|ch
parameter_list|,
name|int
name|count
parameter_list|)
block|{
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|save_font
call|)
argument_list|(
name|adp
argument_list|,
name|page
argument_list|,
name|fontsize
argument_list|,
name|fontwidth
argument_list|,
name|data
argument_list|,
name|ch
argument_list|,
name|count
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_load_font
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|page
parameter_list|,
name|int
name|fontsize
parameter_list|,
name|int
name|fontwidth
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|ch
parameter_list|,
name|int
name|count
parameter_list|)
block|{
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|load_font
call|)
argument_list|(
name|adp
argument_list|,
name|page
argument_list|,
name|fontsize
argument_list|,
name|fontwidth
argument_list|,
name|data
argument_list|,
name|ch
argument_list|,
name|count
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_show_font
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|page
parameter_list|)
block|{
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|show_font
call|)
argument_list|(
name|adp
argument_list|,
name|page
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_save_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|bits
decl_stmt|;
if|if
condition|(
name|adp
operator|==
name|vesa_adp
operator|&&
name|VESA_MODE
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
condition|)
block|{
name|bits
operator|=
operator|(
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_DAC8
operator|)
operator|!=
literal|0
condition|?
literal|8
else|:
literal|6
expr_stmt|;
if|if
condition|(
name|vesa_bios_save_palette
argument_list|(
literal|0
argument_list|,
literal|256
argument_list|,
name|palette
argument_list|,
name|bits
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|save_palette
call|)
argument_list|(
name|adp
argument_list|,
name|palette
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_load_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|bits
decl_stmt|;
if|if
condition|(
name|adp
operator|==
name|vesa_adp
operator|&&
name|VESA_MODE
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
condition|)
block|{
name|bits
operator|=
operator|(
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_DAC8
operator|)
operator|!=
literal|0
condition|?
literal|8
else|:
literal|6
expr_stmt|;
if|if
condition|(
name|vesa_bios_load_palette
argument_list|(
literal|0
argument_list|,
literal|256
argument_list|,
name|palette
argument_list|,
name|bits
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|load_palette
call|)
argument_list|(
name|adp
argument_list|,
name|palette
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_set_border
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|color
parameter_list|)
block|{
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|set_border
call|)
argument_list|(
name|adp
argument_list|,
name|color
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_save_state
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|size_t
name|bsize
decl_stmt|;
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
operator|||
operator|(
name|size
operator|==
literal|0
operator|&&
name|vesa_state_buf_size
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|save_state
call|)
argument_list|(
name|adp
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
operator|)
return|;
name|bsize
operator|=
name|offsetof
argument_list|(
name|adp_state_t
argument_list|,
name|regs
argument_list|)
operator|+
name|vesa_state_buf_size
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
name|bsize
operator|)
return|;
if|if
condition|(
name|vesa_state_buf_size
operator|>
literal|0
operator|&&
name|size
operator|<
name|bsize
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|vesa_vmem_buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|vesa_vmem_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|vesa_vmem_buf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|VESA_MODE
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
condition|)
block|{
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
name|adp
operator|->
name|va_buffer
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|bsize
operator|=
name|adp
operator|->
name|va_buffer_size
expr_stmt|;
name|vesa_vmem_buf
operator|=
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|vesa_vmem_buf
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|buf
argument_list|,
name|vesa_vmem_buf
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vesa_state_buf_size
operator|==
literal|0
condition|)
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|save_state
call|)
argument_list|(
name|adp
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
operator|)
return|;
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|sig
operator|=
name|V_STATE_SIG
expr_stmt|;
return|return
operator|(
name|vesa_bios_save_restore
argument_list|(
name|STATE_SAVE
argument_list|,
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|regs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_load_state
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|size_t
name|bsize
decl_stmt|;
name|int
name|error
decl_stmt|,
name|mode
decl_stmt|;
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
condition|)
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|load_state
call|)
argument_list|(
name|adp
argument_list|,
name|p
argument_list|)
operator|)
return|;
comment|/* Try BIOS POST to restore a sane state. */
operator|(
name|void
operator|)
name|vesa_bios_post
argument_list|()
expr_stmt|;
name|bsize
operator|=
name|adp
operator|->
name|va_buffer_size
expr_stmt|;
name|mode
operator|=
name|adp
operator|->
name|va_mode
expr_stmt|;
name|error
operator|=
name|vesa_set_mode
argument_list|(
name|adp
argument_list|,
name|adp
operator|->
name|va_initial_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|adp
operator|->
name|va_initial_mode
condition|)
name|error
operator|=
name|vesa_set_mode
argument_list|(
name|adp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|vesa_vmem_buf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|VESA_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
name|adp
operator|->
name|va_buffer
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|vesa_vmem_buf
argument_list|,
name|buf
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|vesa_vmem_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|vesa_vmem_buf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|sig
operator|!=
name|V_STATE_SIG
condition|)
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|load_state
call|)
argument_list|(
name|adp
argument_list|,
name|p
argument_list|)
operator|)
return|;
return|return
operator|(
name|vesa_bios_save_restore
argument_list|(
name|STATE_LOAD
argument_list|,
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|regs
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int vesa_get_origin(video_adapter_t *adp, off_t *offset) { 	x86regs_t regs;  	x86bios_init_regs(&regs); 	regs.R_AX = 0x4f05; 	regs.R_BL = 0x10;  	x86bios_intr(&regs, 0x10);  	if (regs.R_AX != 0x004f) 		return (1); 	*offset = regs.DX * adp->va_window_gran;  	return (0); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vesa_set_origin
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|x86regs_t
name|regs
decl_stmt|;
comment|/* 	 * This function should return as quickly as possible to  	 * maintain good performance of the system. For this reason, 	 * error checking is kept minimal and let the VESA BIOS to  	 * detect error. 	 */
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
condition|)
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|set_win_org
call|)
argument_list|(
name|adp
argument_list|,
name|offset
argument_list|)
operator|)
return|;
comment|/* if this is a linear frame buffer, do nothing */
if|if
condition|(
name|adp
operator|->
name|va_info
operator|.
name|vi_flags
operator|&
name|V_INFO_LINEAR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX */
if|if
condition|(
name|adp
operator|->
name|va_window_gran
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f05
expr_stmt|;
name|regs
operator|.
name|R_DX
operator|=
name|offset
operator|/
name|adp
operator|->
name|va_window_gran
expr_stmt|;
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|R_AX
operator|!=
literal|0x004f
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|x86bios_init_regs
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|R_AX
operator|=
literal|0x4f05
expr_stmt|;
name|regs
operator|.
name|R_BL
operator|=
literal|1
expr_stmt|;
name|regs
operator|.
name|R_DX
operator|=
name|offset
operator|/
name|adp
operator|->
name|va_window_gran
expr_stmt|;
name|x86bios_intr
argument_list|(
operator|&
name|regs
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|adp
operator|->
name|va_window_orig
operator|=
operator|(
name|offset
operator|/
name|adp
operator|->
name|va_window_gran
operator|)
operator|*
name|adp
operator|->
name|va_window_gran
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX */
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_read_hw_cursor
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
modifier|*
name|col
parameter_list|,
name|int
modifier|*
name|row
parameter_list|)
block|{
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|read_hw_cursor
call|)
argument_list|(
name|adp
argument_list|,
name|col
argument_list|,
name|row
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_set_hw_cursor
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|col
parameter_list|,
name|int
name|row
parameter_list|)
block|{
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|set_hw_cursor
call|)
argument_list|(
name|adp
argument_list|,
name|col
argument_list|,
name|row
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_set_hw_cursor_shape
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|celsize
parameter_list|,
name|int
name|blink
parameter_list|)
block|{
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|set_hw_cursor_shape
call|)
argument_list|(
name|adp
argument_list|,
name|base
argument_list|,
name|height
argument_list|,
name|celsize
argument_list|,
name|blink
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_blank_display
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
comment|/* XXX: use VESA DPMS */
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|blank_display
call|)
argument_list|(
name|adp
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_mmap
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|prot
parameter_list|,
name|vm_memattr_t
modifier|*
name|memattr
parameter_list|)
block|{
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"vesa_mmap(): window:0x%tx, buffer:0x%tx, offset:0x%jx\n"
argument_list|,
name|adp
operator|->
name|va_info
operator|.
name|vi_window
argument_list|,
name|adp
operator|->
name|va_info
operator|.
name|vi_buffer
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|adp
operator|==
name|vesa_adp
operator|)
operator|&&
operator|(
name|adp
operator|->
name|va_info
operator|.
name|vi_flags
operator|&
name|V_INFO_LINEAR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* va_window_size == va_buffer_size/vi_planes */
comment|/* XXX: is this correct? */
if|if
condition|(
name|offset
operator|>
name|adp
operator|->
name|va_window_size
operator|-
name|PAGE_SIZE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|paddr
operator|=
name|adp
operator|->
name|va_info
operator|.
name|vi_buffer
operator|+
name|offset
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|mmap
call|)
argument_list|(
name|adp
argument_list|,
name|offset
argument_list|,
name|paddr
argument_list|,
name|prot
argument_list|,
name|memattr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_clear
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|)
block|{
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|clear
call|)
argument_list|(
name|adp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_fill_rect
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|val
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|cx
parameter_list|,
name|int
name|cy
parameter_list|)
block|{
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|fill_rect
call|)
argument_list|(
name|adp
argument_list|,
name|val
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bitblt
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
modifier|...
parameter_list|)
block|{
comment|/* FIXME */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|red
parameter_list|,
name|u_char
modifier|*
name|green
parameter_list|,
name|u_char
modifier|*
name|blue
parameter_list|,
name|u_char
modifier|*
name|trans
parameter_list|)
block|{
name|u_char
modifier|*
name|r
decl_stmt|;
name|u_char
modifier|*
name|g
decl_stmt|;
name|u_char
modifier|*
name|b
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|base
operator|<
literal|0
operator|||
name|base
operator|>=
literal|256
operator|||
name|count
operator|<
literal|0
operator|||
name|count
operator|>
literal|256
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|base
operator|+
name|count
operator|)
operator|>
literal|256
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|VESA_MODE
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|bits
operator|=
operator|(
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_DAC8
operator|)
operator|!=
literal|0
condition|?
literal|8
else|:
literal|6
expr_stmt|;
name|r
operator|=
name|malloc
argument_list|(
name|count
operator|*
literal|3
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|g
operator|=
name|r
operator|+
name|count
expr_stmt|;
name|b
operator|=
name|g
operator|+
name|count
expr_stmt|;
name|error
operator|=
name|vesa_bios_save_palette2
argument_list|(
name|base
argument_list|,
name|count
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|copyout
argument_list|(
name|r
argument_list|,
name|red
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|g
argument_list|,
name|green
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|b
argument_list|,
name|blue
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|trans
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|r
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|r
argument_list|,
name|trans
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|r
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|red
parameter_list|,
name|u_char
modifier|*
name|green
parameter_list|,
name|u_char
modifier|*
name|blue
parameter_list|,
name|u_char
modifier|*
name|trans
parameter_list|)
block|{
name|u_char
modifier|*
name|r
decl_stmt|;
name|u_char
modifier|*
name|g
decl_stmt|;
name|u_char
modifier|*
name|b
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|base
operator|<
literal|0
operator|||
name|base
operator|>=
literal|256
operator|||
name|count
operator|<
literal|0
operator|||
name|count
operator|>
literal|256
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|base
operator|+
name|count
operator|)
operator|>
literal|256
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|VESA_MODE
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|bits
operator|=
operator|(
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_DAC8
operator|)
operator|!=
literal|0
condition|?
literal|8
else|:
literal|6
expr_stmt|;
name|r
operator|=
name|malloc
argument_list|(
name|count
operator|*
literal|3
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|g
operator|=
name|r
operator|+
name|count
expr_stmt|;
name|b
operator|=
name|g
operator|+
name|count
expr_stmt|;
name|copyin
argument_list|(
name|red
argument_list|,
name|r
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|copyin
argument_list|(
name|green
argument_list|,
name|g
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|copyin
argument_list|(
name|blue
argument_list|,
name|b
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|error
operator|=
name|vesa_bios_load_palette2
argument_list|(
name|base
argument_list|,
name|count
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_ioctl
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|int
name|bytes
decl_stmt|;
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
condition|)
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FBIO_SETWINORG
case|:
comment|/* set frame buffer window origin */
if|if
condition|(
operator|!
name|VESA_MODE
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
condition|)
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
return|return
operator|(
name|vesa_set_origin
argument_list|(
name|adp
argument_list|,
operator|*
operator|(
name|off_t
operator|*
operator|)
name|arg
argument_list|)
condition|?
name|ENODEV
else|:
literal|0
operator|)
return|;
case|case
name|FBIO_SETDISPSTART
case|:
comment|/* set display start address */
if|if
condition|(
operator|!
name|VESA_MODE
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
condition|)
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
operator|)
return|;
if|if
condition|(
name|vesa_bios_set_start
argument_list|(
operator|(
operator|(
name|video_display_start_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|x
argument_list|,
operator|(
operator|(
name|video_display_start_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|y
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|adp
operator|->
name|va_disp_start
operator|.
name|x
operator|=
operator|(
operator|(
name|video_display_start_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|x
expr_stmt|;
name|adp
operator|->
name|va_disp_start
operator|.
name|y
operator|=
operator|(
operator|(
name|video_display_start_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|y
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FBIO_SETLINEWIDTH
case|:
comment|/* set line length in pixel */
if|if
condition|(
operator|!
name|VESA_MODE
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
condition|)
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
operator|)
return|;
if|if
condition|(
name|vesa_bios_set_line_length
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|bytes
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|adp
operator|->
name|va_line_width
operator|=
name|bytes
expr_stmt|;
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"new line width:%d\n"
argument_list|,
name|adp
operator|->
name|va_line_width
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FBIO_GETPALETTE
case|:
comment|/* get color palette */
if|if
condition|(
name|get_palette
argument_list|(
name|adp
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|index
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|red
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|green
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|blue
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|transparent
argument_list|)
condition|)
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FBIO_SETPALETTE
case|:
comment|/* set color palette */
if|if
condition|(
name|set_palette
argument_list|(
name|adp
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|index
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|red
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|green
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|blue
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|transparent
argument_list|)
condition|)
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FBIOGETCMAP
case|:
comment|/* get color palette */
if|if
condition|(
name|get_palette
argument_list|(
name|adp
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|index
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|red
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|green
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|blue
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FBIOPUTCMAP
case|:
comment|/* set color palette */
if|if
condition|(
name|set_palette
argument_list|(
name|adp
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|index
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|red
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|green
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|blue
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_diag
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* call the previous handler first */
name|error
operator|=
call|(
modifier|*
name|prevvidsw
operator|->
name|diag
call|)
argument_list|(
name|adp
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|level
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_info
parameter_list|(
name|int
name|level
parameter_list|)
block|{
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
name|struct
name|vesa_mode
name|vmode
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|uint16_t
name|vers
decl_stmt|;
name|vers
operator|=
name|vesa_adp_info
operator|->
name|v_version
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
comment|/* general adapter information */
name|printf
argument_list|(
literal|"VESA: v%d.%d, %dk memory, flags:0x%x, mode table:%p (%x)\n"
argument_list|,
operator|(
name|vers
operator|>>
literal|12
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|vers
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
operator|)
argument_list|,
operator|(
operator|(
name|vers
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
operator|)
operator|*
literal|10
operator|+
operator|(
name|vers
operator|&
literal|0x000f
operator|)
argument_list|,
name|vesa_adp_info
operator|->
name|v_memsize
operator|*
literal|64
argument_list|,
name|vesa_adp_info
operator|->
name|v_flags
argument_list|,
name|vesa_vmodetab
argument_list|,
name|vesa_adp_info
operator|->
name|v_modetable
argument_list|)
expr_stmt|;
comment|/* OEM string */
if|if
condition|(
name|vesa_oemstr
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"VESA: %s\n"
argument_list|,
name|vesa_oemstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|vers
operator|>=
literal|0x0200
operator|&&
name|bootverbose
condition|)
block|{
comment|/* vender name, product name, product revision */
name|printf
argument_list|(
literal|"VESA: %s %s %s\n"
argument_list|,
operator|(
name|vesa_venderstr
operator|!=
name|NULL
operator|)
condition|?
name|vesa_venderstr
else|:
literal|"unknown"
argument_list|,
operator|(
name|vesa_prodstr
operator|!=
name|NULL
operator|)
condition|?
name|vesa_prodstr
else|:
literal|"unknown"
argument_list|,
operator|(
name|vesa_revstr
operator|!=
name|NULL
operator|)
condition|?
name|vesa_revstr
else|:
literal|"?"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
comment|/* mode information */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
operator|(
name|M_VESA_MODE_MAX
operator|-
name|M_VESA_BASE
operator|+
literal|1
operator|)
operator|)
operator|&&
operator|(
name|vesa_vmodetab
index|[
name|i
index|]
operator|!=
literal|0xffff
operator|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|vesa_bios_get_mode
argument_list|(
name|vesa_vmodetab
index|[
name|i
index|]
argument_list|,
operator|&
name|vmode
argument_list|,
name|M_NOWAIT
argument_list|)
condition|)
continue|continue;
comment|/* print something for diagnostic purpose */
name|printf
argument_list|(
literal|"VESA: mode:0x%03x, flags:0x%04x"
argument_list|,
name|vesa_vmodetab
index|[
name|i
index|]
argument_list|,
name|vmode
operator|.
name|v_modeattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmode
operator|.
name|v_modeattr
operator|&
name|V_MODEOPTINFO
condition|)
block|{
if|if
condition|(
name|vmode
operator|.
name|v_modeattr
operator|&
name|V_MODEGRAPHICS
condition|)
block|{
name|printf
argument_list|(
literal|", G %dx%dx%d %d, "
argument_list|,
name|vmode
operator|.
name|v_width
argument_list|,
name|vmode
operator|.
name|v_height
argument_list|,
name|vmode
operator|.
name|v_bpp
argument_list|,
name|vmode
operator|.
name|v_planes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|", T %dx%d, "
argument_list|,
name|vmode
operator|.
name|v_width
argument_list|,
name|vmode
operator|.
name|v_height
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"font:%dx%d, "
argument_list|,
name|vmode
operator|.
name|v_cwidth
argument_list|,
name|vmode
operator|.
name|v_cheight
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pages:%d, mem:%d"
argument_list|,
name|vmode
operator|.
name|v_ipages
operator|+
literal|1
argument_list|,
name|vmode
operator|.
name|v_memmodel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vmode
operator|.
name|v_modeattr
operator|&
name|V_MODELFB
condition|)
block|{
name|printf
argument_list|(
literal|"\nVESA: LFB:0x%x, off:0x%x, off_size:0x%x"
argument_list|,
name|vmode
operator|.
name|v_lfb
argument_list|,
name|vmode
operator|.
name|v_offscreen
argument_list|,
name|vmode
operator|.
name|v_offscreensize
operator|*
literal|1024
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"VESA: window A:0x%x (%x), window B:0x%x (%x), "
argument_list|,
name|vmode
operator|.
name|v_waseg
argument_list|,
name|vmode
operator|.
name|v_waattr
argument_list|,
name|vmode
operator|.
name|v_wbseg
argument_list|,
name|vmode
operator|.
name|v_wbattr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"size:%dk, gran:%dk\n"
argument_list|,
name|vmode
operator|.
name|v_wsize
argument_list|,
name|vmode
operator|.
name|v_wgran
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VESA_DEBUG> 1 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* module loading */
end_comment

begin_function
specifier|static
name|int
name|vesa_load
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vesa_init_done
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_init
argument_list|(
operator|&
name|vesa_lock
argument_list|,
literal|"VESA lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* locate a VGA adapter */
name|vesa_adp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|vesa_configure
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|vesa_bios_info
argument_list|(
name|bootverbose
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_unload
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|palette
index|[
literal|256
operator|*
literal|3
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* if the adapter is currently in a VESA mode, don't unload */
if|if
condition|(
operator|(
name|vesa_adp
operator|!=
name|NULL
operator|)
operator|&&
name|VESA_MODE
argument_list|(
name|vesa_adp
operator|->
name|va_mode
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/*  	 * FIXME: if there is at least one vty which is in a VESA mode, 	 * we shouldn't be unloading! XXX 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|vesa_unload_ioctl
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vesa_adp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|vesa_adp
operator|->
name|va_flags
operator|&
name|V_ADP_DAC8
operator|)
operator|!=
literal|0
condition|)
block|{
name|vesa_bios_save_palette
argument_list|(
literal|0
argument_list|,
literal|256
argument_list|,
name|palette
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|vesa_bios_set_dac
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|vesa_adp
operator|->
name|va_flags
operator|&=
operator|~
name|V_ADP_DAC8
expr_stmt|;
name|vesa_bios_load_palette
argument_list|(
literal|0
argument_list|,
literal|256
argument_list|,
name|palette
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
name|vesa_adp
operator|->
name|va_flags
operator|&=
operator|~
name|V_ADP_VESA
expr_stmt|;
name|vidsw
index|[
name|vesa_adp
operator|->
name|va_index
index|]
operator|=
name|prevvidsw
expr_stmt|;
block|}
block|}
name|vesa_bios_uninit
argument_list|()
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|vesa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
return|return
operator|(
name|vesa_load
argument_list|()
operator|)
return|;
case|case
name|MOD_UNLOAD
case|:
return|return
operator|(
name|vesa_unload
argument_list|()
operator|)
return|;
block|}
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|vesa_mod
init|=
block|{
literal|"vesa"
block|,
name|vesa_mod_event
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|vesa
argument_list|,
name|vesa_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|vesa
argument_list|,
name|x86bios
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VGA_NO_MODE_CHANGE */
end_comment

end_unit

