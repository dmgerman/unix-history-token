begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************   SPDX-License-Identifier: BSD-3-Clause    Copyright (c) 2001-2004, Intel Corporation   All rights reserved.      Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_comment
comment|/* ixgb_hw.c  * Shared functions for accessing and configuring the adapter  */
end_comment

begin_include
include|#
directive|include
file|<dev/ixgb/ixgb_hw.h>
end_include

begin_include
include|#
directive|include
file|<dev/ixgb/ixgb_ids.h>
end_include

begin_comment
comment|/*  Local function prototypes */
end_comment

begin_function_decl
specifier|static
name|uint32_t
name|ixgb_hash_mc_addr
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|mc_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_mta_set
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|hash_value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_get_bus_info
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|ixgb_link_reset
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgb_optics_reset
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ixgb_phy_type
name|ixgb_identify_phy
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint32_t
name|ixgb_mac_reset
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|uint32_t
name|ixgb_mac_reset
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl_reg
decl_stmt|;
comment|/* Setup up hardware to known state with RESET.      * SWDPIN settings as per Kemano EPS.      */
name|ctrl_reg
operator|=
name|IXGB_CTRL0_RST
operator||
name|IXGB_CTRL0_SDP3_DIR
operator||
comment|/* All pins are Output=1 */
name|IXGB_CTRL0_SDP2_DIR
operator||
name|IXGB_CTRL0_SDP1_DIR
operator||
name|IXGB_CTRL0_SDP0_DIR
operator||
name|IXGB_CTRL0_SDP3
operator||
comment|/* Initial value 1101   */
name|IXGB_CTRL0_SDP2
operator||
name|IXGB_CTRL0_SDP0
expr_stmt|;
ifdef|#
directive|ifdef
name|HP_ZX1
comment|/* Workaround for 82597EX reset errata */
name|IXGB_WRITE_REG_IO
argument_list|(
name|hw
argument_list|,
name|CTRL0
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
else|#
directive|else
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL0
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Delay a few ms just to allow the reset to complete */
name|msec_delay
argument_list|(
name|IXGB_DELAY_AFTER_RESET
argument_list|)
expr_stmt|;
name|ctrl_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL0
argument_list|)
expr_stmt|;
if|#
directive|if
name|DBG
comment|/* Make sure the self-clearing global reset bit did self clear */
name|ASSERT
argument_list|(
operator|!
operator|(
name|ctrl_reg
operator|&
name|IXGB_CTRL0_RST
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|ixgb_phy_type_txn17401
condition|)
block|{
comment|/* Now reset the optics.  This reset is required to ensure link with          * the Kemano 003 optical module (TXN17401), as per instructions from          * the board designer.          */
name|ixgb_optics_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|ctrl_reg
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reset the transmit and receive units; mask and clear all interrupts.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|boolean_t
name|ixgb_adapter_stop
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl_reg
decl_stmt|;
name|uint32_t
name|icr_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgb_adapter_stop"
argument_list|)
expr_stmt|;
comment|/* If we are stopped or resetting exit gracefully and wait to be      * started again before accessing the hardware.      */
if|if
condition|(
name|hw
operator|->
name|adapter_stopped
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Exiting because the adapter is already stopped!!!\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Set the Adapter Stopped flag so other driver functions stop      * touching the Hardware.      */
name|hw
operator|->
name|adapter_stopped
operator|=
name|TRUE
expr_stmt|;
comment|/* Clear interrupt mask to stop board from generating interrupts */
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IMC
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* Disable the Transmit and Receive units.  Then delay to allow      * any pending transactions to complete before we hit the MAC with      * the global reset.      */
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|,
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|RCTL
argument_list|)
operator|&
operator|~
name|IXGB_RCTL_RXEN
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|,
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|TCTL
argument_list|)
operator|&
operator|~
name|IXGB_TCTL_TXEN
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
name|IXGB_DELAY_BEFORE_RESET
argument_list|)
expr_stmt|;
comment|/* Issue a global reset to the MAC.  This will reset the chip's      * transmit, receive, DMA, and link units.  It will not effect      * the current PCI configuration.  The global reset bit is self-      * clearing, and should clear within a microsecond.      */
name|DEBUGOUT
argument_list|(
literal|"Issuing a global reset to MAC\n"
argument_list|)
expr_stmt|;
name|ctrl_reg
operator|=
name|ixgb_mac_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Clear interrupt mask to stop board from generating interrupts */
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupt events. */
name|icr_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|ICR
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctrl_reg
operator|&
name|IXGB_CTRL0_RST
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Identifies the vendor of the optics module on the adapter.  The SR adapters  * support two different types of XPAK optics, so it is necessary to determine  * which optics are present before applying any optics-specific workarounds.  *  * hw - Struct containing variables accessed by shared code.  *  * Returns: the vendor of the XPAK optics module.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|ixgb_xpak_vendor
name|ixgb_identify_xpak_vendor
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint16_t
name|vendor_name
index|[
literal|5
index|]
decl_stmt|;
name|ixgb_xpak_vendor
name|xpak_vendor
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgb_identify_xpak_vendor"
argument_list|)
expr_stmt|;
comment|/* Read the first few bytes of the vendor string from the XPAK NVR      * registers.  These are standard XENPAK/XPAK registers, so all XPAK      * devices should implement them. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|vendor_name
index|[
name|i
index|]
operator|=
name|ixgb_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|MDIO_PMA_PMD_XPAK_VENDOR_NAME
operator|+
name|i
argument_list|,
name|IXGB_PHY_ADDRESS
argument_list|,
name|MDIO_PMA_PMD_DID
argument_list|)
expr_stmt|;
block|}
comment|/* Determine the actual vendor */
if|if
condition|(
name|vendor_name
index|[
literal|0
index|]
operator|==
literal|'I'
operator|&&
name|vendor_name
index|[
literal|1
index|]
operator|==
literal|'N'
operator|&&
name|vendor_name
index|[
literal|2
index|]
operator|==
literal|'T'
operator|&&
name|vendor_name
index|[
literal|3
index|]
operator|==
literal|'E'
operator|&&
name|vendor_name
index|[
literal|4
index|]
operator|==
literal|'L'
condition|)
block|{
name|xpak_vendor
operator|=
name|ixgb_xpak_vendor_intel
expr_stmt|;
block|}
else|else
block|{
name|xpak_vendor
operator|=
name|ixgb_xpak_vendor_infineon
expr_stmt|;
block|}
return|return
operator|(
name|xpak_vendor
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Determine the physical layer module on the adapter.  *  * hw - Struct containing variables accessed by shared code.  The device_id  *      field must be (correctly) populated before calling this routine.  *  * Returns: the phy type of the adapter.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|ixgb_phy_type
name|ixgb_identify_phy
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
name|ixgb_phy_type
name|phy_type
decl_stmt|;
name|ixgb_xpak_vendor
name|xpak_vendor
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgb_identify_phy"
argument_list|)
expr_stmt|;
comment|/* Infer the transceiver/phy type from the device id */
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGB_DEVICE_ID_82597EX
case|:
name|DEBUGOUT
argument_list|(
literal|"Identified TXN17401 optics\n"
argument_list|)
expr_stmt|;
name|phy_type
operator|=
name|ixgb_phy_type_txn17401
expr_stmt|;
break|break;
case|case
name|IXGB_DEVICE_ID_82597EX_SR
case|:
comment|/* The SR adapters carry two different types of XPAK optics              * modules; read the vendor identifier to determine the exact              * type of optics. */
name|xpak_vendor
operator|=
name|ixgb_identify_xpak_vendor
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpak_vendor
operator|==
name|ixgb_xpak_vendor_intel
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Identified TXN17201 optics\n"
argument_list|)
expr_stmt|;
name|phy_type
operator|=
name|ixgb_phy_type_txn17201
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Identified G6005 optics\n"
argument_list|)
expr_stmt|;
name|phy_type
operator|=
name|ixgb_phy_type_g6005
expr_stmt|;
block|}
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Unknown physical layer module\n"
argument_list|)
expr_stmt|;
name|phy_type
operator|=
name|ixgb_phy_type_unknown
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|phy_type
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Performs basic configuration of the adapter.  *  * hw - Struct containing variables accessed by shared code  *  * Resets the controller.  * Reads and validates the EEPROM.  * Initializes the receive address registers.  * Initializes the multicast table.  * Clears all on-chip counters.  * Calls routine to setup flow control settings.  * Leaves the transmit and receive units disabled and uninitialized.  *  * Returns:  *      TRUE if successful,  *      FALSE if unrecoverable problems were encountered.  *****************************************************************************/
end_comment

begin_function
name|boolean_t
name|ixgb_init_hw
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|ctrl_reg
decl_stmt|;
name|boolean_t
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgb_init_hw"
argument_list|)
expr_stmt|;
comment|/* Issue a global reset to the MAC.  This will reset the chip's      * transmit, receive, DMA, and link units.  It will not effect      * the current PCI configuration.  The global reset bit is self-      * clearing, and should clear within a microsecond.      */
name|DEBUGOUT
argument_list|(
literal|"Issuing a global reset to MAC\n"
argument_list|)
expr_stmt|;
name|ctrl_reg
operator|=
name|ixgb_mac_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Issuing an EE reset to MAC\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HP_ZX1
comment|/* Workaround for 82597EX reset errata */
name|IXGB_WRITE_REG_IO
argument_list|(
name|hw
argument_list|,
name|CTRL1
argument_list|,
name|IXGB_CTRL1_EE_RST
argument_list|)
expr_stmt|;
else|#
directive|else
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL1
argument_list|,
name|IXGB_CTRL1_EE_RST
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Delay a few ms just to allow the reset to complete */
name|msec_delay
argument_list|(
name|IXGB_DELAY_AFTER_EE_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixgb_get_eeprom_data
argument_list|(
name|hw
argument_list|)
operator|==
name|FALSE
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Use the device id to determine the type of phy/transceiver. */
name|hw
operator|->
name|device_id
operator|=
name|ixgb_get_ee_device_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy_type
operator|=
name|ixgb_identify_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Setup the receive addresses.      * Receive Address Registers (RARs 0 - 15).      */
name|ixgb_init_rx_addrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/*      * Check that a valid MAC address has been set.      * If it is not valid, we fail hardware init.      */
if|if
condition|(
operator|!
name|mac_addr_valid
argument_list|(
name|hw
operator|->
name|curr_mac_addr
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MAC address invalid after ixgb_init_rx_addrs\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* tell the routines in this file they can access hardware again */
name|hw
operator|->
name|adapter_stopped
operator|=
name|FALSE
expr_stmt|;
comment|/* Fill in the bus_info structure */
name|ixgb_get_bus_info
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Zero out the Multicast HASH table */
name|DEBUGOUT
argument_list|(
literal|"Zeroing the MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGB_MC_TBL_SIZE
condition|;
name|i
operator|++
control|)
name|IXGB_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Zero out the VLAN Filter Table Array */
name|ixgb_clear_vfta
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Zero all of the hardware counters */
name|ixgb_clear_hw_cntrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Call a subroutine to setup flow control. */
name|status
operator|=
name|ixgb_setup_fc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 82597EX errata: Call check-for-link in case lane deskew is locked */
name|ixgb_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Initializes receive address filters.  *  * hw - Struct containing variables accessed by shared code  *  * Places the MAC address in receive address register 0 and clears the rest  * of the receive addresss registers. Clears the multicast table. Assumes  * the receiver is in reset when the routine is called.  *****************************************************************************/
end_comment

begin_function
name|void
name|ixgb_init_rx_addrs
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgb_init_rx_addrs"
argument_list|)
expr_stmt|;
comment|/*      * If the current mac address is valid, assume it is a software override      * to the permanent address.      * Otherwise, use the permanent address from the eeprom.      */
if|if
condition|(
operator|!
name|mac_addr_valid
argument_list|(
name|hw
operator|->
name|curr_mac_addr
argument_list|)
condition|)
block|{
comment|/* Get the MAC address from the eeprom for later reference */
name|ixgb_get_ee_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|curr_mac_addr
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|" Keeping Permanent MAC Addr =%.2X %.2X %.2X "
argument_list|,
name|hw
operator|->
name|curr_mac_addr
index|[
literal|0
index|]
argument_list|,
name|hw
operator|->
name|curr_mac_addr
index|[
literal|1
index|]
argument_list|,
name|hw
operator|->
name|curr_mac_addr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"%.2X %.2X %.2X\n"
argument_list|,
name|hw
operator|->
name|curr_mac_addr
index|[
literal|3
index|]
argument_list|,
name|hw
operator|->
name|curr_mac_addr
index|[
literal|4
index|]
argument_list|,
name|hw
operator|->
name|curr_mac_addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Setup the receive address. */
name|DEBUGOUT
argument_list|(
literal|"Overriding MAC Address in RAR[0]\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|" New MAC Addr =%.2X %.2X %.2X "
argument_list|,
name|hw
operator|->
name|curr_mac_addr
index|[
literal|0
index|]
argument_list|,
name|hw
operator|->
name|curr_mac_addr
index|[
literal|1
index|]
argument_list|,
name|hw
operator|->
name|curr_mac_addr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"%.2X %.2X %.2X\n"
argument_list|,
name|hw
operator|->
name|curr_mac_addr
index|[
literal|3
index|]
argument_list|,
name|hw
operator|->
name|curr_mac_addr
index|[
literal|4
index|]
argument_list|,
name|hw
operator|->
name|curr_mac_addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|ixgb_rar_set
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|curr_mac_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Zero out the other 15 receive addresses. */
name|DEBUGOUT
argument_list|(
literal|"Clearing RAR[1-15]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|IXGB_RAR_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|IXGB_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Updates the MAC's list of multicast addresses.  *  * hw - Struct containing variables accessed by shared code  * mc_addr_list - the list of new multicast addresses  * mc_addr_count - number of addresses  * pad - number of bytes between addresses in the list  *  * The given list replaces any existing list. Clears the last 15 receive  * address registers and the multicast table. Uses receive address registers  * for the first 15 multicast addresses, and hashes the rest into the  * multicast table.  *****************************************************************************/
end_comment

begin_function
name|void
name|ixgb_mc_addr_list_update
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|mc_addr_list
parameter_list|,
name|uint32_t
name|mc_addr_count
parameter_list|,
name|uint32_t
name|pad
parameter_list|)
block|{
name|uint32_t
name|hash_value
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|rar_used_count
init|=
literal|1
decl_stmt|;
comment|/* RAR[0] is used for our MAC address */
name|DEBUGFUNC
argument_list|(
literal|"ixgb_mc_addr_list_update"
argument_list|)
expr_stmt|;
comment|/* Set the new number of MC addresses that we are being requested to use. */
name|hw
operator|->
name|num_mc_addrs
operator|=
name|mc_addr_count
expr_stmt|;
comment|/* Clear RAR[1-15] */
name|DEBUGOUT
argument_list|(
literal|" Clearing RAR[1-15]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rar_used_count
init|;
name|i
operator|<
name|IXGB_RAR_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|IXGB_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the MTA */
name|DEBUGOUT
argument_list|(
literal|" Clearing MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGB_MC_TBL_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|IXGB_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc_addr_count
condition|;
name|i
operator|++
control|)
block|{
name|DEBUGOUT
argument_list|(
literal|" Adding the multicast addresses:\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT7
argument_list|(
literal|" MC Addr #%d =%.2X %.2X %.2X %.2X %.2X %.2X\n"
argument_list|,
name|i
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|IXGB_ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|IXGB_ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|1
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|IXGB_ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|2
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|IXGB_ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|3
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|IXGB_ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|4
index|]
argument_list|,
name|mc_addr_list
index|[
name|i
operator|*
operator|(
name|IXGB_ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* Place this multicast address in the RAR if there is room, *          * else put it in the MTA          */
if|if
condition|(
name|rar_used_count
operator|<
name|IXGB_RAR_ENTRIES
condition|)
block|{
name|ixgb_rar_set
argument_list|(
name|hw
argument_list|,
name|mc_addr_list
operator|+
operator|(
name|i
operator|*
operator|(
name|IXGB_ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|)
argument_list|,
name|rar_used_count
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Added a multicast address to RAR[%d]\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rar_used_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|hash_value
operator|=
name|ixgb_hash_mc_addr
argument_list|(
name|hw
argument_list|,
name|mc_addr_list
operator|+
operator|(
name|i
operator|*
operator|(
name|IXGB_ETH_LENGTH_OF_ADDRESS
operator|+
name|pad
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|" Hash value = 0x%03X\n"
argument_list|,
name|hash_value
argument_list|)
expr_stmt|;
name|ixgb_mta_set
argument_list|(
name|hw
argument_list|,
name|hash_value
argument_list|)
expr_stmt|;
block|}
block|}
name|DEBUGOUT
argument_list|(
literal|"MC Update Complete\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Hashes an address to determine its location in the multicast table  *  * hw - Struct containing variables accessed by shared code  * mc_addr - the multicast address to hash  *  * Returns:  *      The hash value  *****************************************************************************/
end_comment

begin_function
specifier|static
name|uint32_t
name|ixgb_hash_mc_addr
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|mc_addr
parameter_list|)
block|{
name|uint32_t
name|hash_value
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgb_hash_mc_addr"
argument_list|)
expr_stmt|;
comment|/* The portion of the address that is used for the hash table is      * determined by the mc_filter_type setting.      */
switch|switch
condition|(
name|hw
operator|->
name|mc_filter_type
condition|)
block|{
comment|/* [0] [1] [2] [3] [4] [5]          * 01  AA  00  12  34  56          * LSB                 MSB - According to H/W docs */
case|case
literal|0
case|:
comment|/* [47:36] i.e. 0x563 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* [46:35] i.e. 0xAC6 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|3
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* [45:34] i.e. 0x5D8 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|6
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* [43:32] i.e. 0x634 for above example address */
name|hash_value
operator|=
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|)
operator||
operator|(
operator|(
operator|(
name|uint16_t
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Invalid mc_filter_type, what should we do? */
name|DEBUGOUT
argument_list|(
literal|"MC filter type param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|hash_value
operator|&=
literal|0xFFF
expr_stmt|;
return|return
operator|(
name|hash_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Sets the bit in the multicast table corresponding to the hash value.  *  * hw - Struct containing variables accessed by shared code  * hash_value - Multicast address hash value  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgb_mta_set
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|hash_value
parameter_list|)
block|{
name|uint32_t
name|hash_bit
decl_stmt|,
name|hash_reg
decl_stmt|;
name|uint32_t
name|mta_reg
decl_stmt|;
comment|/* The MTA is a register array of 128 32-bit registers.      * It is treated like an array of 4096 bits.  We want to set      * bit BitArray[hash_value]. So we figure out what register      * the bit is in, read it, OR in the new bit, then write      * back the new value.  The register is determined by the      * upper 7 bits of the hash value and the bit within that      * register are determined by the lower 5 bits of the value.      */
name|hash_reg
operator|=
operator|(
name|hash_value
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|hash_bit
operator|=
name|hash_value
operator|&
literal|0x1F
expr_stmt|;
name|mta_reg
operator|=
name|IXGB_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|hash_reg
argument_list|)
expr_stmt|;
name|mta_reg
operator||=
operator|(
literal|1
operator|<<
name|hash_bit
operator|)
expr_stmt|;
name|IXGB_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|MTA
argument_list|,
name|hash_reg
argument_list|,
name|mta_reg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Puts an ethernet address into a receive address register.  *  * hw - Struct containing variables accessed by shared code  * addr - Address to put into receive address register  * index - Receive address register to write  *****************************************************************************/
end_comment

begin_function
name|void
name|ixgb_rar_set
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|,
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|index
parameter_list|)
block|{
name|uint32_t
name|rar_low
decl_stmt|,
name|rar_high
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgb_rar_set"
argument_list|)
expr_stmt|;
comment|/* HW expects these in little endian so we reverse the byte order      * from network order (big endian) to little endian      */
name|rar_low
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|rar_high
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|IXGB_RAH_AV
operator|)
expr_stmt|;
name|IXGB_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
name|index
operator|<<
literal|1
operator|)
argument_list|,
name|rar_low
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|RA
argument_list|,
operator|(
operator|(
name|index
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a value to the specified offset in the VLAN filter table.  *  * hw - Struct containing variables accessed by shared code  * offset - Offset in VLAN filer table to write  * value - Value to write into VLAN filter table  *****************************************************************************/
end_comment

begin_function
name|void
name|ixgb_write_vfta
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|IXGB_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Clears the VLAN filer table  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|ixgb_clear_vfta
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|offset
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|IXGB_VLAN_FILTER_TBL_SIZE
condition|;
name|offset
operator|++
control|)
name|IXGB_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|VFTA
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Configures the flow control settings based on SW configuration.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|boolean_t
name|ixgb_setup_fc
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl_reg
decl_stmt|;
name|uint32_t
name|pap_reg
init|=
literal|0
decl_stmt|;
comment|/* by default, assume no pause time */
name|boolean_t
name|status
init|=
name|TRUE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgb_setup_fc"
argument_list|)
expr_stmt|;
comment|/* Get the current control reg 0 settings */
name|ctrl_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL0
argument_list|)
expr_stmt|;
comment|/* Clear the Receive Pause Enable and Transmit Pause Enable bits */
name|ctrl_reg
operator|&=
operator|~
operator|(
name|IXGB_CTRL0_RPE
operator||
name|IXGB_CTRL0_TPE
operator|)
expr_stmt|;
comment|/* The possible values of the "flow_control" parameter are:      *      0:  Flow control is completely disabled      *      1:  Rx flow control is enabled (we can receive pause frames      *          but not send pause frames).      *      2:  Tx flow control is enabled (we can send pause frames      *          but we do not support receiving pause frames).      *      3:  Both Rx and TX flow control (symmetric) are enabled.      *  other:  Invalid.      */
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|type
condition|)
block|{
case|case
name|ixgb_fc_none
case|:
comment|/* 0 */
comment|/* Set CMDC bit to disable Rx Flow control*/
name|ctrl_reg
operator||=
operator|(
name|IXGB_CTRL0_CMDC
operator|)
expr_stmt|;
break|break;
case|case
name|ixgb_fc_rx_pause
case|:
comment|/* 1 */
comment|/* RX Flow control is enabled, and TX Flow control is          * disabled.          */
name|ctrl_reg
operator||=
operator|(
name|IXGB_CTRL0_RPE
operator|)
expr_stmt|;
break|break;
case|case
name|ixgb_fc_tx_pause
case|:
comment|/* 2 */
comment|/* TX Flow control is enabled, and RX Flow control is          * disabled, by a software over-ride.          */
name|ctrl_reg
operator||=
operator|(
name|IXGB_CTRL0_TPE
operator|)
expr_stmt|;
name|pap_reg
operator|=
name|hw
operator|->
name|fc
operator|.
name|pause_time
expr_stmt|;
break|break;
case|case
name|ixgb_fc_full
case|:
comment|/* 3 */
comment|/* Flow control (both RX and TX) is enabled by a software          * over-ride.          */
name|ctrl_reg
operator||=
operator|(
name|IXGB_CTRL0_RPE
operator||
name|IXGB_CTRL0_TPE
operator|)
expr_stmt|;
name|pap_reg
operator|=
name|hw
operator|->
name|fc
operator|.
name|pause_time
expr_stmt|;
break|break;
default|default:
comment|/* We should never get here.  The value should be 0-3. */
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Write the new settings */
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL0
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pap_reg
operator|!=
literal|0
condition|)
block|{
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|PAP
argument_list|,
name|pap_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Set the flow control receive threshold registers.  Normally,      * these registers will be set to a default threshold that may be      * adjusted later by the driver's runtime code.  However, if the      * ability to transmit pause frames in not enabled, then these      * registers will be set to 0.      */
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|fc
operator|.
name|type
operator|&
name|ixgb_fc_tx_pause
operator|)
condition|)
block|{
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to set up the Receive Threshold high and low water         * marks as well as (optionally) enabling the transmission of XON frames.         */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|send_xon
condition|)
block|{
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTL
argument_list|,
operator|(
name|hw
operator|->
name|fc
operator|.
name|low_water
operator||
name|IXGB_FCRTL_XONE
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTL
argument_list|,
name|hw
operator|->
name|fc
operator|.
name|low_water
argument_list|)
expr_stmt|;
block|}
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|FCRTH
argument_list|,
name|hw
operator|->
name|fc
operator|.
name|high_water
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Reads a word from a device over the Management Data Interface (MDI) bus.  * This interface is used to manage Physical layer devices.  *  * hw          - Struct containing variables accessed by hw code  * reg_address - Offset of device register being read.  * phy_address - Address of device on MDI.  *  * Returns:  Data word (16 bits) from MDI device.  *  * The 82597EX has support for several MDI access methods.  This routine  * uses the new protocol MDI Single Command and Address Operation.  * This requires that first an address cycle command is sent, followed by a  * read command.  *****************************************************************************/
end_comment

begin_function
name|uint16_t
name|ixgb_read_phy_reg
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_address
parameter_list|,
name|uint32_t
name|phy_address
parameter_list|,
name|uint32_t
name|device_type
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|data
decl_stmt|;
name|uint32_t
name|command
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|reg_address
operator|<=
name|IXGB_MAX_PHY_REG_ADDRESS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|phy_address
operator|<=
name|IXGB_MAX_PHY_ADDRESS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|device_type
operator|<=
name|IXGB_MAX_PHY_DEV_TYPE
argument_list|)
expr_stmt|;
comment|/* Setup and write the address cycle command */
name|command
operator|=
operator|(
operator|(
name|reg_address
operator|<<
name|IXGB_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGB_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|phy_address
operator|<<
name|IXGB_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGB_MSCA_ADDR_CYCLE
operator||
name|IXGB_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/**************************************************************     ** Check every 10 usec to see if the address cycle completed     ** The COMMAND bit will clear when the operation is complete.     ** This may take as long as 64 usecs (we'll wait 100 usecs max)     ** from the CPU Write to the Ready bit assertion.     **************************************************************/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGB_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
name|ASSERT
argument_list|(
operator|(
name|command
operator|&
name|IXGB_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Address cycle complete, setup and write the read command */
name|command
operator|=
operator|(
operator|(
name|reg_address
operator|<<
name|IXGB_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGB_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|phy_address
operator|<<
name|IXGB_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGB_MSCA_READ
operator||
name|IXGB_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/**************************************************************     ** Check every 10 usec to see if the read command completed     ** The COMMAND bit will clear when the operation is complete.     ** The read may take as long as 64 usecs (we'll wait 100 usecs max)     ** from the CPU Write to the Ready bit assertion.     **************************************************************/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGB_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
name|ASSERT
argument_list|(
operator|(
name|command
operator|&
name|IXGB_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Operation is complete, get the data from the MDIO Read/Write Data      * register and return.      */
name|data
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|MSRWD
argument_list|)
expr_stmt|;
name|data
operator|>>=
name|IXGB_MSRWD_READ_DATA_SHIFT
expr_stmt|;
return|return
operator|(
operator|(
name|uint16_t
operator|)
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Writes a word to a device over the Management Data Interface (MDI) bus.  * This interface is used to manage Physical layer devices.  *  * hw          - Struct containing variables accessed by hw code  * reg_address - Offset of device register being read.  * phy_address - Address of device on MDI.  * device_type - Also known as the Device ID or DID.  * data        - 16-bit value to be written  *  * Returns:  void.  *  * The 82597EX has support for several MDI access methods.  This routine  * uses the new protocol MDI Single Command and Address Operation.  * This requires that first an address cycle command is sent, followed by a  * write command.  *****************************************************************************/
end_comment

begin_function
name|void
name|ixgb_write_phy_reg
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|reg_address
parameter_list|,
name|uint32_t
name|phy_address
parameter_list|,
name|uint32_t
name|device_type
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|command
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|reg_address
operator|<=
name|IXGB_MAX_PHY_REG_ADDRESS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|phy_address
operator|<=
name|IXGB_MAX_PHY_ADDRESS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|device_type
operator|<=
name|IXGB_MAX_PHY_DEV_TYPE
argument_list|)
expr_stmt|;
comment|/* Put the data in the MDIO Read/Write Data register */
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|MSRWD
argument_list|,
operator|(
name|uint32_t
operator|)
name|data
argument_list|)
expr_stmt|;
comment|/* Setup and write the address cycle command */
name|command
operator|=
operator|(
operator|(
name|reg_address
operator|<<
name|IXGB_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGB_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|phy_address
operator|<<
name|IXGB_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGB_MSCA_ADDR_CYCLE
operator||
name|IXGB_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/**************************************************************     ** Check every 10 usec to see if the address cycle completed     ** The COMMAND bit will clear when the operation is complete.     ** This may take as long as 64 usecs (we'll wait 100 usecs max)     ** from the CPU Write to the Ready bit assertion.     **************************************************************/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGB_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
name|ASSERT
argument_list|(
operator|(
name|command
operator|&
name|IXGB_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Address cycle complete, setup and write the write command */
name|command
operator|=
operator|(
operator|(
name|reg_address
operator|<<
name|IXGB_MSCA_NP_ADDR_SHIFT
operator|)
operator||
operator|(
name|device_type
operator|<<
name|IXGB_MSCA_DEV_TYPE_SHIFT
operator|)
operator||
operator|(
name|phy_address
operator|<<
name|IXGB_MSCA_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|IXGB_MSCA_WRITE
operator||
name|IXGB_MSCA_MDI_COMMAND
operator|)
operator|)
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|MSCA
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/**************************************************************     ** Check every 10 usec to see if the read command completed     ** The COMMAND bit will clear when the operation is complete.     ** The write may take as long as 64 usecs (we'll wait 100 usecs max)     ** from the CPU Write to the Ready bit assertion.     **************************************************************/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|command
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|MSCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|IXGB_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
name|ASSERT
argument_list|(
operator|(
name|command
operator|&
name|IXGB_MSCA_MDI_COMMAND
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Operation is complete, return. */
block|}
end_function

begin_comment
comment|/******************************************************************************  * Checks to see if the link status of the hardware has changed.  *  * hw - Struct containing variables accessed by hw code  *  * Called by any function that needs to check the link status of the adapter.  *****************************************************************************/
end_comment

begin_function
name|void
name|ixgb_check_for_link
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|status_reg
decl_stmt|;
name|uint32_t
name|xpcss_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgb_check_for_link"
argument_list|)
expr_stmt|;
name|xpcss_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|XPCSS
argument_list|)
expr_stmt|;
name|status_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xpcss_reg
operator|&
name|IXGB_XPCSS_ALIGN_STATUS
operator|)
operator|&&
operator|(
name|status_reg
operator|&
name|IXGB_STATUS_LU
operator|)
condition|)
block|{
name|hw
operator|->
name|link_up
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|xpcss_reg
operator|&
name|IXGB_XPCSS_ALIGN_STATUS
operator|)
operator|&&
operator|(
name|status_reg
operator|&
name|IXGB_STATUS_LU
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"XPCSS Not Aligned while Status:LU is set.\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|link_up
operator|=
name|ixgb_link_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*          * 82597EX errata.  Since the lane deskew problem may prevent          * link, reset the link before reporting link down.          */
name|hw
operator|->
name|link_up
operator|=
name|ixgb_link_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/*  Anything else for 10 Gig?? */
block|}
end_function

begin_comment
comment|/******************************************************************************  * Check for a bad link condition that may have occurred.  * The indication is that the RFC / LFC registers may be incrementing  * continually.  A full adapter reset is required to recover.  *  * hw - Struct containing variables accessed by hw code  *  * Called by any function that needs to check the link status of the adapter.  *****************************************************************************/
end_comment

begin_function
name|boolean_t
name|ixgb_check_for_bad_link
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|newLFC
decl_stmt|,
name|newRFC
decl_stmt|;
name|boolean_t
name|bad_link_returncode
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|ixgb_phy_type_txn17401
condition|)
block|{
name|newLFC
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|LFC
argument_list|)
expr_stmt|;
name|newRFC
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|RFC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|lastLFC
operator|+
literal|250
operator|<
name|newLFC
operator|)
operator|||
operator|(
name|hw
operator|->
name|lastRFC
operator|+
literal|250
operator|<
name|newRFC
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"BAD LINK! too many LFC/RFC since last check\n"
argument_list|)
expr_stmt|;
name|bad_link_returncode
operator|=
name|TRUE
expr_stmt|;
block|}
name|hw
operator|->
name|lastLFC
operator|=
name|newLFC
expr_stmt|;
name|hw
operator|->
name|lastRFC
operator|=
name|newRFC
expr_stmt|;
block|}
return|return
name|bad_link_returncode
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Clears all hardware statistics counters.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|ixgb_clear_hw_cntrs
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
specifier|volatile
name|uint32_t
name|temp_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgb_clear_hw_cntrs"
argument_list|)
expr_stmt|;
comment|/* if we are stopped or resetting exit gracefully */
if|if
condition|(
name|hw
operator|->
name|adapter_stopped
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Exiting because the adapter is stopped!!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|TPRL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|TPRH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|GPRCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|GPRCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|BPRCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|BPRCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|MPRCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|MPRCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|UPRCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|UPRCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|VPRCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|VPRCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|JPRCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|JPRCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|GORCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|GORCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|TORL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|TORH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|RNBC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|RUC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|ROC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|RLEC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|CRCERRS
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|ICBC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|ECBC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|MPC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|TPTL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|TPTH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|GPTCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|GPTCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|BPTCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|BPTCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|MPTCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|MPTCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|UPTCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|UPTCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|VPTCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|VPTCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|JPTCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|JPTCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|GOTCL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|GOTCH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|TOTL
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|TOTH
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|DC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|PLT64C
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|TSCTC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|TSCTFC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|IBIC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|RFC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|LFC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|PFRC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|PFTC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|MCFRC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|MCFTC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|XONRXC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|XONTXC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|XOFFRXC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|XOFFTXC
argument_list|)
expr_stmt|;
name|temp_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|RJC
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Turns on the software controllable LED  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|ixgb_led_on
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl0_reg
init|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL0
argument_list|)
decl_stmt|;
comment|/* To turn on the LED, clear software-definable pin 0 (SDP0). */
name|ctrl0_reg
operator|&=
operator|~
name|IXGB_CTRL0_SDP0
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL0
argument_list|,
name|ctrl0_reg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Turns off the software controllable LED  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|ixgb_led_off
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|ctrl0_reg
init|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL0
argument_list|)
decl_stmt|;
comment|/* To turn off the LED, set software-definable pin 0 (SDP0). */
name|ctrl0_reg
operator||=
name|IXGB_CTRL0_SDP0
expr_stmt|;
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL0
argument_list|,
name|ctrl0_reg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Gets the current PCI bus type, speed, and width of the hardware  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixgb_get_bus_info
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
name|uint32_t
name|status_reg
decl_stmt|;
name|status_reg
operator|=
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|type
operator|=
operator|(
name|status_reg
operator|&
name|IXGB_STATUS_PCIX_MODE
operator|)
condition|?
name|ixgb_bus_type_pcix
else|:
name|ixgb_bus_type_pci
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|type
operator|==
name|ixgb_bus_type_pci
condition|)
block|{
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
operator|(
name|status_reg
operator|&
name|IXGB_STATUS_PCI_SPD
operator|)
condition|?
name|ixgb_bus_speed_66
else|:
name|ixgb_bus_speed_33
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|status_reg
operator|&
name|IXGB_STATUS_PCIX_SPD_MASK
condition|)
block|{
case|case
name|IXGB_STATUS_PCIX_SPD_66
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgb_bus_speed_66
expr_stmt|;
break|break;
case|case
name|IXGB_STATUS_PCIX_SPD_100
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgb_bus_speed_100
expr_stmt|;
break|break;
case|case
name|IXGB_STATUS_PCIX_SPD_133
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgb_bus_speed_133
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|ixgb_bus_speed_reserved
expr_stmt|;
break|break;
block|}
block|}
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
operator|(
name|status_reg
operator|&
name|IXGB_STATUS_BUS64
operator|)
condition|?
name|ixgb_bus_width_64
else|:
name|ixgb_bus_width_32
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Tests a MAC address to ensure it is a valid Individual Address  *  * mac_addr - pointer to MAC address.  *  *****************************************************************************/
end_comment

begin_function
name|boolean_t
name|mac_addr_valid
parameter_list|(
name|uint8_t
modifier|*
name|mac_addr
parameter_list|)
block|{
name|boolean_t
name|is_valid
init|=
name|TRUE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"mac_addr_valid"
argument_list|)
expr_stmt|;
comment|/* Make sure it is not a multicast address */
if|if
condition|(
name|IS_MULTICAST
argument_list|(
name|mac_addr
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MAC address is multicast\n"
argument_list|)
expr_stmt|;
name|is_valid
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Not a broadcast address */
elseif|else
if|if
condition|(
name|IS_BROADCAST
argument_list|(
name|mac_addr
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MAC address is broadcast\n"
argument_list|)
expr_stmt|;
name|is_valid
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Reject the zero address */
elseif|else
if|if
condition|(
name|mac_addr
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|mac_addr
index|[
literal|5
index|]
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MAC address is all zeros\n"
argument_list|)
expr_stmt|;
name|is_valid
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
operator|(
name|is_valid
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Resets the 10GbE link.  Waits the settle time and returns the state of  * the link.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|boolean_t
name|ixgb_link_reset
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
name|boolean_t
name|link_status
init|=
name|FALSE
decl_stmt|;
name|uint8_t
name|wait_retries
init|=
name|MAX_RESET_ITERATIONS
decl_stmt|;
name|uint8_t
name|lrst_retries
init|=
name|MAX_RESET_ITERATIONS
decl_stmt|;
do|do
block|{
comment|/* Reset the link */
name|IXGB_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|CTRL0
argument_list|,
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|CTRL0
argument_list|)
operator||
name|IXGB_CTRL0_LRST
argument_list|)
expr_stmt|;
comment|/* Wait for link-up and lane re-alignment */
do|do
block|{
name|usec_delay
argument_list|(
name|IXGB_DELAY_USECS_AFTER_LINK_RESET
argument_list|)
expr_stmt|;
name|link_status
operator|=
operator|(
operator|(
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|STATUS
argument_list|)
operator|&
name|IXGB_STATUS_LU
operator|)
operator|&&
operator|(
name|IXGB_READ_REG
argument_list|(
name|hw
argument_list|,
name|XPCSS
argument_list|)
operator|&
name|IXGB_XPCSS_ALIGN_STATUS
operator|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|link_status
operator|&&
operator|--
name|wait_retries
condition|)
do|;
block|}
do|while
condition|(
operator|!
name|link_status
operator|&&
operator|--
name|lrst_retries
condition|)
do|;
return|return
name|link_status
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Resets the 10GbE optics module.  *  * hw - Struct containing variables accessed by shared code  *****************************************************************************/
end_comment

begin_function
name|void
name|ixgb_optics_reset
parameter_list|(
name|struct
name|ixgb_hw
modifier|*
name|hw
parameter_list|)
block|{
if|if
condition|(
name|hw
operator|->
name|phy_type
operator|==
name|ixgb_phy_type_txn17401
condition|)
block|{
name|uint16_t
name|mdio_reg
decl_stmt|;
name|ixgb_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|MDIO_PMA_PMD_CR1
argument_list|,
name|IXGB_PHY_ADDRESS
argument_list|,
name|MDIO_PMA_PMD_DID
argument_list|,
name|MDIO_PMA_PMD_CR1_RESET
argument_list|)
expr_stmt|;
name|mdio_reg
operator|=
name|ixgb_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|MDIO_PMA_PMD_CR1
argument_list|,
name|IXGB_PHY_ADDRESS
argument_list|,
name|MDIO_PMA_PMD_DID
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

