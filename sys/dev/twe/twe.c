begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Michael Smith  * Copyright (c) 2000 BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_comment
comment|/*  * Driver for the 3ware Escalade family of IDE RAID controllers.  */
end_comment

begin_include
include|#
directive|include
file|<dev/twe/twe_compat.h>
end_include

begin_include
include|#
directive|include
file|<dev/twe/twereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/twe/tweio.h>
end_include

begin_include
include|#
directive|include
file|<dev/twe/twevar.h>
end_include

begin_define
define|#
directive|define
name|TWE_DEFINE_TABLES
end_define

begin_include
include|#
directive|include
file|<dev/twe/twe_tables.h>
end_include

begin_comment
comment|/*  * Command submission.  */
end_comment

begin_function_decl
specifier|static
name|int
name|twe_get_param_1
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|u_int8_t
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_get_param_2
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|u_int16_t
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_get_param_4
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|u_int32_t
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|twe_get_param
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|parameter_id
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_set_param_1
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|u_int8_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_set_param_2
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|u_int16_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_set_param_4
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|u_int32_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_set_param
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|int
name|param_size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_init_connection
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_wait_request
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_immediate_request
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twe_startio
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twe_completeio
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twe_reset
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Command I/O to controller.  */
end_comment

begin_function_decl
specifier|static
name|int
name|twe_start
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twe_done
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twe_complete
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_wait_status
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|status
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_drain_response_queue
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_check_bits
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|status_reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_soft_reset
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Interrupt handling.  */
end_comment

begin_function_decl
specifier|static
name|void
name|twe_host_intr
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twe_attention_intr
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twe_command_intr
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Asynchronous event handling.  */
end_comment

begin_function_decl
specifier|static
name|int
name|twe_fetch_aen
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twe_handle_aen
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twe_enqueue_aen
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|aen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_dequeue_aen
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_drain_aen_queue
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_find_aen
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|aen
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Command buffer management.  */
end_comment

begin_function_decl
specifier|static
name|int
name|twe_get_request
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twe_request
modifier|*
modifier|*
name|tr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twe_release_request
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Debugging.  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|twe_format_aen
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|aen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twe_request_qlen
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twe_panic
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|reason
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/********************************************************************************  ********************************************************************************                                                                 Public Interfaces  ********************************************************************************  ********************************************************************************/
end_comment

begin_comment
comment|/********************************************************************************  * Initialise the controller, set up driver data structures.  */
end_comment

begin_function
name|int
name|twe_setup
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|twe_request
modifier|*
name|tr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/*      * Initialise request queues.      */
name|twe_initq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twe_initq_bio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twe_initq_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twe_initq_busy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twe_initq_complete
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|twe_wait_aen
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*      * Allocate request structures up front.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TWE_Q_LENGTH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|tr
operator|=
name|twe_allocate_request
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Set global defaults that won't change. 	 */
name|tr
operator|->
name|tr_command
operator|.
name|generic
operator|.
name|host_id
operator|=
name|sc
operator|->
name|twe_host_id
expr_stmt|;
comment|/* controller-assigned host ID */
name|tr
operator|->
name|tr_command
operator|.
name|generic
operator|.
name|request_id
operator|=
name|i
expr_stmt|;
comment|/* our index number */
name|sc
operator|->
name|twe_lookup
index|[
name|i
index|]
operator|=
name|tr
expr_stmt|;
comment|/* 	 * Put command onto the freelist. 	 */
name|twe_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
comment|/*      * Wait for the controller to come ready.      */
if|if
condition|(
name|twe_wait_status
argument_list|(
name|sc
argument_list|,
name|TWE_STATUS_MICROCONTROLLER_READY
argument_list|,
literal|60
argument_list|)
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"microcontroller not ready\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*      * Disable interrupts from the card.      */
name|twe_disable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Soft reset the controller, look for the AEN acknowledging the reset,      * check for errors, drain the response queue.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TWE_MAX_RESET_TRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"reset %d failed, trying again\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|twe_soft_reset
argument_list|(
name|sc
argument_list|)
condition|)
break|break;
comment|/* reset process complete */
block|}
comment|/* did we give up? */
if|if
condition|(
name|i
operator|>=
name|TWE_MAX_RESET_TRIES
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"can't initialise controller, giving up\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Locate disk devices and attach children to them.  */
end_comment

begin_function
name|void
name|twe_init
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|twe_drive
modifier|*
name|dr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|table
decl_stmt|;
name|u_int16_t
name|dsize
decl_stmt|;
name|TWE_Param
modifier|*
name|drives
decl_stmt|,
modifier|*
name|param
decl_stmt|;
name|TWE_Unit_Descriptor
modifier|*
name|ud
decl_stmt|;
comment|/*      * The controller is in a safe state, so try to find drives attached to it.      */
if|if
condition|(
operator|(
name|drives
operator|=
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|TWE_PARAM_UNITSUMMARY
argument_list|,
name|TWE_PARAM_UNITSUMMARY_Status
argument_list|,
name|TWE_MAX_UNITS
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"can't detect attached units\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * For each detected unit, create a child device.      */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dr
operator|=
operator|&
name|sc
operator|->
name|twe_drive
index|[
literal|0
index|]
init|;
name|i
operator|<
name|TWE_MAX_UNITS
condition|;
name|i
operator|++
operator|,
name|dr
operator|++
control|)
block|{
comment|/* check that the drive is online */
if|if
condition|(
operator|!
operator|(
name|drives
operator|->
name|data
index|[
name|i
index|]
operator|&
name|TWE_PARAM_UNITSTATUS_Online
operator|)
condition|)
continue|continue;
name|table
operator|=
name|TWE_PARAM_UNITINFO
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|twe_get_param_4
argument_list|(
name|sc
argument_list|,
name|table
argument_list|,
name|TWE_PARAM_UNITINFO_Capacity
argument_list|,
operator|&
name|dr
operator|->
name|td_size
argument_list|)
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"error fetching capacity for unit %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|twe_get_param_1
argument_list|(
name|sc
argument_list|,
name|table
argument_list|,
name|TWE_PARAM_UNITINFO_Status
argument_list|,
operator|&
name|dr
operator|->
name|td_state
argument_list|)
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"error fetching state for unit %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|twe_get_param_2
argument_list|(
name|sc
argument_list|,
name|table
argument_list|,
name|TWE_PARAM_UNITINFO_DescriptorSize
argument_list|,
operator|&
name|dsize
argument_list|)
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"error fetching descriptor size for unit %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|param
operator|=
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|table
argument_list|,
name|TWE_PARAM_UNITINFO_Descriptor
argument_list|,
name|dsize
operator|-
literal|3
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"error fetching descriptor for unit %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ud
operator|=
operator|(
name|TWE_Unit_Descriptor
operator|*
operator|)
name|param
operator|->
name|data
expr_stmt|;
name|dr
operator|->
name|td_type
operator|=
name|ud
operator|->
name|configuration
expr_stmt|;
name|free
argument_list|(
name|param
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* build synthetic geometry as per controller internal rules */
if|if
condition|(
name|dr
operator|->
name|td_size
operator|>
literal|0x200000
condition|)
block|{
name|dr
operator|->
name|td_heads
operator|=
literal|255
expr_stmt|;
name|dr
operator|->
name|td_sectors
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|dr
operator|->
name|td_heads
operator|=
literal|64
expr_stmt|;
name|dr
operator|->
name|td_sectors
operator|=
literal|32
expr_stmt|;
block|}
name|dr
operator|->
name|td_cylinders
operator|=
name|dr
operator|->
name|td_size
operator|/
operator|(
name|dr
operator|->
name|td_heads
operator|*
name|dr
operator|->
name|td_sectors
operator|)
expr_stmt|;
name|dr
operator|->
name|td_unit
operator|=
name|i
expr_stmt|;
name|twe_attach_drive
argument_list|(
name|sc
argument_list|,
name|dr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|drives
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/*      * Initialise connection with controller.      */
name|twe_init_connection
argument_list|(
name|sc
argument_list|,
name|TWE_INIT_MESSAGE_CREDITS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TWE_SHUTDOWN_NOTIFICATION
comment|/*      * Tell the controller we support shutdown notification.      */
name|twe_set_param_1
argument_list|(
name|sc
argument_list|,
name|TWE_PARAM_FEATURES
argument_list|,
name|TWE_PARAM_FEATURES_DriverShutdown
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*       * Mark controller up and ready to run.      */
name|sc
operator|->
name|twe_state
operator|&=
operator|~
name|TWE_STATE_SHUTDOWN
expr_stmt|;
comment|/*      * Finally enable interrupts.      */
name|twe_enable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Stop the controller  */
end_comment

begin_function
name|void
name|twe_deinit
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/*      * Mark the controller as shutting down, and disable any further interrupts.      */
name|sc
operator|->
name|twe_state
operator||=
name|TWE_STATE_SHUTDOWN
expr_stmt|;
name|twe_disable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TWE_SHUTDOWN_NOTIFICATION
comment|/*      * Disconnect from the controller      */
name|twe_init_connection
argument_list|(
name|sc
argument_list|,
name|TWE_SHUTDOWN_MESSAGE_CREDITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*******************************************************************************  * Take an interrupt, or be poked by other code to look for interrupt-worthy  * status.  */
end_comment

begin_function
name|void
name|twe_intr
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|status_reg
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/*      * Collect current interrupt status.      */
name|status_reg
operator|=
name|TWE_STATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twe_check_bits
argument_list|(
name|sc
argument_list|,
name|status_reg
argument_list|)
expr_stmt|;
comment|/*      * Dispatch based on interrupt status      */
if|if
condition|(
name|status_reg
operator|&
name|TWE_STATUS_HOST_INTERRUPT
condition|)
name|twe_host_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_reg
operator|&
name|TWE_STATUS_ATTENTION_INTERRUPT
condition|)
name|twe_attention_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_reg
operator|&
name|TWE_STATUS_COMMAND_INTERRUPT
condition|)
name|twe_command_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_reg
operator|*
name|TWE_STATUS_RESPONSE_INTERRUPT
condition|)
name|twe_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*******************************************************************************  * Receive a bio structure from a child device and queue it on a particular  * controller, then poke the controller to start as much work as it can.  */
end_comment

begin_function
name|int
name|twe_submit_bio
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|twe_bio
modifier|*
name|bp
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|twe_enqueue_bio
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|twe_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Handle controller-specific control operations.  */
end_comment

begin_function
name|int
name|twe_ioctl
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|twe_usercommand
modifier|*
name|tu
init|=
operator|(
expr|struct
name|twe_usercommand
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|twe_paramcommand
modifier|*
name|tp
init|=
operator|(
expr|struct
name|twe_paramcommand
operator|*
operator|)
name|addr
decl_stmt|;
name|union
name|twe_statrequest
modifier|*
name|ts
init|=
operator|(
expr|union
name|twe_statrequest
operator|*
operator|)
name|addr
decl_stmt|;
name|TWE_Param
modifier|*
name|param
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|int
modifier|*
name|arg
init|=
operator|(
name|int
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|twe_request
modifier|*
name|tr
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* handle a command from userspace */
case|case
name|TWEIO_COMMAND
case|:
comment|/* get a request */
if|if
condition|(
name|twe_get_request
argument_list|(
name|sc
argument_list|,
operator|&
name|tr
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|cmd_done
goto|;
block|}
comment|/* copy the user-supplied command */
name|bcopy
argument_list|(
operator|&
name|tu
operator|->
name|tu_command
argument_list|,
operator|&
name|tr
operator|->
name|tr_command
argument_list|,
sizeof|sizeof
argument_list|(
name|TWE_Command
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if there's a data buffer, allocate and copy it in */
name|tr
operator|->
name|tr_length
operator|=
name|tu
operator|->
name|tu_size
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|tr
operator|->
name|tr_data
operator|=
name|malloc
argument_list|(
name|tr
operator|->
name|tr_length
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cmd_done
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|tu
operator|->
name|tu_data
argument_list|,
name|tr
operator|->
name|tr_data
argument_list|,
name|tr
operator|->
name|tr_length
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|cmd_done
goto|;
name|tr
operator|->
name|tr_flags
operator||=
name|TWE_CMD_DATAIN
operator||
name|TWE_CMD_DATAOUT
expr_stmt|;
block|}
comment|/* run the command */
name|twe_wait_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* copy the command out again */
name|bcopy
argument_list|(
operator|&
name|tr
operator|->
name|tr_command
argument_list|,
operator|&
name|tu
operator|->
name|tu_command
argument_list|,
sizeof|sizeof
argument_list|(
name|TWE_Command
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if there was a data buffer, copy it out */
if|if
condition|(
name|tr
operator|->
name|tr_length
operator|>
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|tr
operator|->
name|tr_data
argument_list|,
name|tu
operator|->
name|tu_data
argument_list|,
name|tr
operator|->
name|tr_length
argument_list|)
expr_stmt|;
name|cmd_done
label|:
comment|/* free resources */
if|if
condition|(
name|tr
operator|->
name|tr_data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tr
operator|->
name|tr_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|!=
name|NULL
condition|)
name|twe_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
break|break;
comment|/* fetch statistics counter */
case|case
name|TWEIO_STATS
case|:
switch|switch
condition|(
name|ts
operator|->
name|ts_item
condition|)
block|{
ifdef|#
directive|ifdef
name|TWE_PERFORMANCE_MONITOR
case|case
name|TWEQ_FREE
case|:
case|case
name|TWEQ_BIO
case|:
case|case
name|TWEQ_READY
case|:
case|case
name|TWEQ_BUSY
case|:
case|case
name|TWEQ_COMPLETE
case|:
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|twe_qstat
index|[
name|ts
operator|->
name|ts_item
index|]
argument_list|,
operator|&
name|ts
operator|->
name|ts_qstat
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twe_qstat
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
break|break;
comment|/* poll for an AEN */
case|case
name|TWEIO_AEN_POLL
case|:
operator|*
name|arg
operator|=
name|twe_dequeue_aen
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
operator|-
literal|1
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
comment|/* wait for another AEN to show up */
case|case
name|TWEIO_AEN_WAIT
case|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|arg
operator|=
name|twe_dequeue_aen
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|twe_aen_queue
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"tweaen"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|TWEIO_GET_PARAM
case|:
if|if
condition|(
operator|(
name|param
operator|=
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|tp_table_id
argument_list|,
name|tp
operator|->
name|tp_param_id
argument_list|,
name|tp
operator|->
name|tp_size
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"TWEIO_GET_PARAM failed for 0x%x/0x%x/%d\n"
argument_list|,
name|tp
operator|->
name|tp_table_id
argument_list|,
name|tp
operator|->
name|tp_param_id
argument_list|,
name|tp
operator|->
name|tp_size
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|param
operator|->
name|parameter_size_bytes
operator|>
name|tp
operator|->
name|tp_size
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"TWEIO_GET_PARAM parameter too large (%d> %d)\n"
argument_list|,
name|param
operator|->
name|parameter_size_bytes
argument_list|,
name|tp
operator|->
name|tp_size
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|copyout
argument_list|(
name|param
operator|->
name|data
argument_list|,
name|tp
operator|->
name|tp_data
argument_list|,
name|param
operator|->
name|parameter_size_bytes
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|param
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TWEIO_SET_PARAM
case|:
if|if
condition|(
operator|(
name|data
operator|=
name|malloc
argument_list|(
name|tp
operator|->
name|tp_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|copyin
argument_list|(
name|tp
operator|->
name|tp_data
argument_list|,
name|data
argument_list|,
name|tp
operator|->
name|tp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|twe_set_param
argument_list|(
name|sc
argument_list|,
name|tp
operator|->
name|tp_table_id
argument_list|,
name|tp
operator|->
name|tp_param_id
argument_list|,
name|tp
operator|->
name|tp_size
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TWEIO_RESET
case|:
name|twe_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
comment|/* nothing we understand */
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Enable the useful interrupts from the controller.  */
end_comment

begin_function
name|void
name|twe_enable_interrupts
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|twe_state
operator||=
name|TWE_STATE_INTEN
expr_stmt|;
name|TWE_CONTROL
argument_list|(
name|sc
argument_list|,
name|TWE_CONTROL_CLEAR_ATTENTION_INTERRUPT
operator||
name|TWE_CONTROL_UNMASK_RESPONSE_INTERRUPT
operator||
name|TWE_CONTROL_ENABLE_INTERRUPTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Disable interrupts from the controller.  */
end_comment

begin_function
name|void
name|twe_disable_interrupts
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|TWE_CONTROL
argument_list|(
name|sc
argument_list|,
name|TWE_CONTROL_DISABLE_INTERRUPTS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|twe_state
operator|&=
operator|~
name|TWE_STATE_INTEN
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  ********************************************************************************                                                                Command Submission  ********************************************************************************  ********************************************************************************/
end_comment

begin_comment
comment|/********************************************************************************  * Read integer parameter table entries.  */
end_comment

begin_function
specifier|static
name|int
name|twe_get_param_1
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|u_int8_t
modifier|*
name|result
parameter_list|)
block|{
name|TWE_Param
modifier|*
name|param
decl_stmt|;
if|if
condition|(
operator|(
name|param
operator|=
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|table_id
argument_list|,
name|param_id
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
operator|*
name|result
operator|=
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|param
operator|->
name|data
expr_stmt|;
name|free
argument_list|(
name|param
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|twe_get_param_2
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|u_int16_t
modifier|*
name|result
parameter_list|)
block|{
name|TWE_Param
modifier|*
name|param
decl_stmt|;
if|if
condition|(
operator|(
name|param
operator|=
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|table_id
argument_list|,
name|param_id
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
operator|*
name|result
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|param
operator|->
name|data
expr_stmt|;
name|free
argument_list|(
name|param
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|twe_get_param_4
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|u_int32_t
modifier|*
name|result
parameter_list|)
block|{
name|TWE_Param
modifier|*
name|param
decl_stmt|;
if|if
condition|(
operator|(
name|param
operator|=
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|table_id
argument_list|,
name|param_id
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
operator|*
name|result
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|param
operator|->
name|data
expr_stmt|;
name|free
argument_list|(
name|param
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Perform a TWE_OP_GET_PARAM command.  If a callback function is provided, it  * will be called with the command when it's completed.  If no callback is   * provided, we will wait for the command to complete and then return just the data.  * The caller is responsible for freeing the data when done with it.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|twe_get_param
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|size_t
name|param_size
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
parameter_list|)
block|{
name|struct
name|twe_request
modifier|*
name|tr
decl_stmt|;
name|TWE_Command
modifier|*
name|cmd
decl_stmt|;
name|TWE_Param
modifier|*
name|param
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|tr
operator|=
name|NULL
expr_stmt|;
name|param
operator|=
name|NULL
expr_stmt|;
comment|/* get a command */
if|if
condition|(
name|twe_get_request
argument_list|(
name|sc
argument_list|,
operator|&
name|tr
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* get a buffer */
if|if
condition|(
operator|(
name|param
operator|=
operator|(
name|TWE_Param
operator|*
operator|)
name|malloc
argument_list|(
name|TWE_SECTOR_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|tr
operator|->
name|tr_data
operator|=
name|param
expr_stmt|;
name|tr
operator|->
name|tr_length
operator|=
name|TWE_SECTOR_SIZE
expr_stmt|;
name|tr
operator|->
name|tr_flags
operator|=
name|TWE_CMD_DATAIN
operator||
name|TWE_CMD_DATAOUT
expr_stmt|;
comment|/* build the command for the controller */
name|cmd
operator|=
operator|&
name|tr
operator|->
name|tr_command
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|opcode
operator|=
name|TWE_OP_GET_PARAM
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|size
operator|=
literal|2
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|unit
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|param_count
operator|=
literal|1
expr_stmt|;
comment|/* map the command/data into controller-visible space */
name|twe_map_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* fill in the outbound parameter data */
name|param
operator|->
name|table_id
operator|=
name|table_id
expr_stmt|;
name|param
operator|->
name|parameter_id
operator|=
name|param_id
expr_stmt|;
name|param
operator|->
name|parameter_size_bytes
operator|=
name|param_size
expr_stmt|;
comment|/* submit the command and either wait or let the callback handle it */
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
comment|/* XXX could use twe_wait_request here if interrupts were enabled? */
name|error
operator|=
name|twe_immediate_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|cmd
operator|->
name|generic
operator|.
name|flags
condition|)
block|{
case|case
name|TWE_FLAGS_SUCCESS
case|:
break|break;
case|case
name|TWE_FLAGS_INFORMATIONAL
case|:
case|case
name|TWE_FLAGS_WARNING
case|:
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"command completed - %s\n"
argument_list|,
name|twe_describe_code
argument_list|(
name|twe_table_status
argument_list|,
name|cmd
operator|->
name|generic
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TWE_FLAGS_FATAL
case|:
default|default:
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"command failed - %s\n"
argument_list|,
name|twe_describe_code
argument_list|(
name|twe_table_status
argument_list|,
name|cmd
operator|->
name|generic
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|twe_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|param
operator|)
return|;
block|}
else|else
block|{
name|tr
operator|->
name|tr_complete
operator|=
name|func
expr_stmt|;
name|error
operator|=
name|twe_start
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
name|func
operator|)
return|;
block|}
comment|/* something failed */
name|err
label|:
name|debug
argument_list|(
literal|1
argument_list|,
literal|"failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|!=
name|NULL
condition|)
name|twe_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|param
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Set integer parameter table entries.  */
end_comment

begin_function
specifier|static
name|int
name|twe_set_param_1
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|u_int8_t
name|value
parameter_list|)
block|{
return|return
operator|(
name|twe_set_param
argument_list|(
name|sc
argument_list|,
name|table_id
argument_list|,
name|param_id
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|,
operator|&
name|value
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|twe_set_param_2
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|u_int16_t
name|value
parameter_list|)
block|{
return|return
operator|(
name|twe_set_param
argument_list|(
name|sc
argument_list|,
name|table_id
argument_list|,
name|param_id
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|,
operator|&
name|value
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|twe_set_param_4
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|u_int32_t
name|value
parameter_list|)
block|{
return|return
operator|(
name|twe_set_param
argument_list|(
name|sc
argument_list|,
name|table_id
argument_list|,
name|param_id
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|,
operator|&
name|value
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Perform a TWE_OP_SET_PARAM command, returns nonzero on error.  */
end_comment

begin_function
specifier|static
name|int
name|twe_set_param
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|int
name|param_size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|twe_request
modifier|*
name|tr
decl_stmt|;
name|TWE_Command
modifier|*
name|cmd
decl_stmt|;
name|TWE_Param
modifier|*
name|param
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|tr
operator|=
name|NULL
expr_stmt|;
name|param
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
comment|/* get a command */
if|if
condition|(
name|twe_get_request
argument_list|(
name|sc
argument_list|,
operator|&
name|tr
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* get a buffer */
if|if
condition|(
operator|(
name|param
operator|=
operator|(
name|TWE_Param
operator|*
operator|)
name|malloc
argument_list|(
name|TWE_SECTOR_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|tr
operator|->
name|tr_data
operator|=
name|param
expr_stmt|;
name|tr
operator|->
name|tr_length
operator|=
name|TWE_SECTOR_SIZE
expr_stmt|;
name|tr
operator|->
name|tr_flags
operator|=
name|TWE_CMD_DATAIN
operator||
name|TWE_CMD_DATAOUT
expr_stmt|;
comment|/* build the command for the controller */
name|cmd
operator|=
operator|&
name|tr
operator|->
name|tr_command
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|opcode
operator|=
name|TWE_OP_SET_PARAM
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|size
operator|=
literal|2
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|unit
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|param_count
operator|=
literal|1
expr_stmt|;
comment|/* map the command/data into controller-visible space */
name|twe_map_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* fill in the outbound parameter data */
name|param
operator|->
name|table_id
operator|=
name|table_id
expr_stmt|;
name|param
operator|->
name|parameter_id
operator|=
name|param_id
expr_stmt|;
name|param
operator|->
name|parameter_size_bytes
operator|=
name|param_size
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|param
operator|->
name|data
argument_list|,
name|param_size
argument_list|)
expr_stmt|;
comment|/* XXX could use twe_wait_request here if interrupts were enabled? */
name|error
operator|=
name|twe_immediate_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|cmd
operator|->
name|generic
operator|.
name|flags
condition|)
block|{
case|case
name|TWE_FLAGS_SUCCESS
case|:
break|break;
case|case
name|TWE_FLAGS_INFORMATIONAL
case|:
case|case
name|TWE_FLAGS_WARNING
case|:
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"command completed - %s\n"
argument_list|,
name|twe_describe_code
argument_list|(
name|twe_table_status
argument_list|,
name|cmd
operator|->
name|generic
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TWE_FLAGS_FATAL
case|:
default|default:
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"command failed - %s\n"
argument_list|,
name|twe_describe_code
argument_list|(
name|twe_table_status
argument_list|,
name|cmd
operator|->
name|generic
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
if|if
condition|(
name|tr
operator|!=
name|NULL
condition|)
name|twe_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|param
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Perform a TWE_OP_INIT_CONNECTION command, returns nonzero on error.  *  * Typically called with interrupts disabled.  */
end_comment

begin_function
specifier|static
name|int
name|twe_init_connection
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|twe_request
modifier|*
name|tr
decl_stmt|;
name|TWE_Command
modifier|*
name|cmd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* get a command */
if|if
condition|(
name|twe_get_request
argument_list|(
name|sc
argument_list|,
operator|&
name|tr
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* build the command */
name|cmd
operator|=
operator|&
name|tr
operator|->
name|tr_command
expr_stmt|;
name|cmd
operator|->
name|initconnection
operator|.
name|opcode
operator|=
name|TWE_OP_INIT_CONNECTION
expr_stmt|;
name|cmd
operator|->
name|initconnection
operator|.
name|size
operator|=
literal|3
expr_stmt|;
name|cmd
operator|->
name|initconnection
operator|.
name|host_id
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|initconnection
operator|.
name|message_credits
operator|=
name|mode
expr_stmt|;
name|cmd
operator|->
name|initconnection
operator|.
name|response_queue_pointer
operator|=
literal|0
expr_stmt|;
comment|/* map the command into controller-visible space */
name|twe_map_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* submit the command */
name|error
operator|=
name|twe_immediate_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* XXX check command result? */
name|twe_unmap_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|twe_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TWE_INIT_MESSAGE_CREDITS
condition|)
name|sc
operator|->
name|twe_host_id
operator|=
name|cmd
operator|->
name|initconnection
operator|.
name|host_id
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Start the command (tr) and sleep waiting for it to complete.  *  * Successfully completed commands are dequeued.  */
end_comment

begin_function
specifier|static
name|int
name|twe_wait_request
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_flags
operator||=
name|TWE_CMD_SLEEPER
expr_stmt|;
name|tr
operator|->
name|tr_status
operator|=
name|TWE_CMD_BUSY
expr_stmt|;
name|twe_enqueue_ready
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|twe_startio
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
name|tr
operator|->
name|tr_status
operator|==
name|TWE_CMD_BUSY
condition|)
name|tsleep
argument_list|(
name|tr
argument_list|,
name|PRIBIO
argument_list|,
literal|"twewait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Start the command (tr) and busy-wait for it to complete.  * This should only be used when interrupts are actually disabled (although it  * will work if they are not).  */
end_comment

begin_function
specifier|static
name|int
name|twe_immediate_request
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twe_start
argument_list|(
name|tr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
while|while
condition|(
name|tr
operator|->
name|tr_status
operator|==
name|TWE_CMD_BUSY
condition|)
block|{
name|twe_done
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tr
operator|->
name|tr_status
operator|!=
name|TWE_CMD_COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Pull as much work off the softc's work queue as possible and give it to the  * controller.  */
end_comment

begin_function
specifier|static
name|void
name|twe_startio
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|twe_request
modifier|*
name|tr
decl_stmt|;
name|TWE_Command
modifier|*
name|cmd
decl_stmt|;
name|twe_bio
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* spin until something prevents us from doing any work */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* try to get a command that's already ready to go */
name|tr
operator|=
name|twe_dequeue_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* build a command from an outstanding bio */
if|if
condition|(
name|tr
operator|==
name|NULL
condition|)
block|{
comment|/* see if there's work to be done */
if|if
condition|(
operator|(
name|bp
operator|=
name|twe_dequeue_bio
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
comment|/* get a command */
if|if
condition|(
name|twe_get_request
argument_list|(
name|sc
argument_list|,
operator|&
name|tr
argument_list|)
condition|)
block|{
name|twe_enqueue_bio
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* connect the bio to the command */
name|tr
operator|->
name|tr_complete
operator|=
name|twe_completeio
expr_stmt|;
name|tr
operator|->
name|tr_private
operator|=
name|bp
expr_stmt|;
name|tr
operator|->
name|tr_data
operator|=
name|TWE_BIO_DATA
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_length
operator|=
name|TWE_BIO_LENGTH
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|cmd
operator|=
operator|&
name|tr
operator|->
name|tr_command
expr_stmt|;
if|if
condition|(
name|TWE_BIO_IS_READ
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|tr
operator|->
name|tr_flags
operator||=
name|TWE_CMD_DATAIN
expr_stmt|;
name|cmd
operator|->
name|io
operator|.
name|opcode
operator|=
name|TWE_OP_READ
expr_stmt|;
block|}
else|else
block|{
name|tr
operator|->
name|tr_flags
operator||=
name|TWE_CMD_DATAOUT
expr_stmt|;
name|cmd
operator|->
name|io
operator|.
name|opcode
operator|=
name|TWE_OP_WRITE
expr_stmt|;
block|}
comment|/* build a suitable I/O command (assumes 512-byte rounded transfers) */
name|cmd
operator|->
name|io
operator|.
name|size
operator|=
literal|3
expr_stmt|;
name|cmd
operator|->
name|io
operator|.
name|unit
operator|=
name|TWE_BIO_UNIT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|io
operator|.
name|block_count
operator|=
operator|(
name|tr
operator|->
name|tr_length
operator|+
name|TWE_BLOCK_SIZE
operator|-
literal|1
operator|)
operator|/
name|TWE_BLOCK_SIZE
expr_stmt|;
name|cmd
operator|->
name|io
operator|.
name|lba
operator|=
name|TWE_BIO_LBA
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* map the command so the controller can work with it */
name|twe_map_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
comment|/* did we find something to do? */
if|if
condition|(
name|tr
operator|==
name|NULL
condition|)
break|break;
comment|/* try to give command to controller */
name|error
operator|=
name|twe_start
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EBUSY
condition|)
block|{
name|twe_requeue_ready
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* try it again later */
break|break;
comment|/* don't try anything more for now */
block|}
comment|/* otherwise, fail the command */
name|tr
operator|->
name|tr_status
operator|=
name|TWE_CMD_FAILED
expr_stmt|;
name|twe_completeio
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/********************************************************************************  * Handle completion of an I/O command.  */
end_comment

begin_function
specifier|static
name|void
name|twe_completeio
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
block|{
name|TWE_Command
modifier|*
name|cmd
init|=
operator|&
name|tr
operator|->
name|tr_command
decl_stmt|;
name|struct
name|twe_softc
modifier|*
name|sc
init|=
name|tr
operator|->
name|tr_sc
decl_stmt|;
name|twe_bio
modifier|*
name|bp
init|=
operator|(
name|twe_bio
operator|*
operator|)
name|tr
operator|->
name|tr_private
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_status
operator|==
name|TWE_CMD_COMPLETE
condition|)
block|{
switch|switch
condition|(
name|cmd
operator|->
name|generic
operator|.
name|flags
condition|)
block|{
case|case
name|TWE_FLAGS_SUCCESS
case|:
break|break;
case|case
name|TWE_FLAGS_INFORMATIONAL
case|:
case|case
name|TWE_FLAGS_WARNING
case|:
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"command completed - %s\n"
argument_list|,
name|twe_describe_code
argument_list|(
name|twe_table_status
argument_list|,
name|cmd
operator|->
name|generic
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TWE_FLAGS_FATAL
case|:
default|default:
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"command failed - %s\n"
argument_list|,
name|twe_describe_code
argument_list|(
name|twe_table_status
argument_list|,
name|cmd
operator|->
name|generic
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|TWE_BIO_SET_ERROR
argument_list|(
name|bp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
comment|/*  	     * XXX some status values suggest that the controller should be reset and all outstanding 	     * commands retried.  This might be a good place for that. 	     */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|tr
operator|->
name|tr_status
operator|==
name|TWE_CMD_FAILED
condition|)
block|{
comment|/* could be more verbose here? */
name|TWE_BIO_SET_ERROR
argument_list|(
name|bp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"command failed submission - controller wedged\n"
argument_list|)
expr_stmt|;
comment|/* 	 * XXX reset controller and retry? 	 */
block|}
name|twe_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|twed_intr
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Reset the controller and pull all the active commands back onto the ready  * queue.  Used to restart a controller that's exhibiting bad behaviour.  */
end_comment

begin_function
specifier|static
name|void
name|twe_reset
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|twe_request
modifier|*
name|tr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"Controller reset in progress...\n"
argument_list|)
expr_stmt|;
comment|/*      * Disable interrupts from the controller, and mask any accidental entry      * into our interrupt handler.      */
name|twe_disable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/*      * Try to soft-reset the controller.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TWE_MAX_RESET_TRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"reset %d failed, trying again\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|twe_soft_reset
argument_list|(
name|sc
argument_list|)
condition|)
break|break;
comment|/* reset process complete */
block|}
comment|/* did we give up? */
if|if
condition|(
name|i
operator|>=
name|TWE_MAX_RESET_TRIES
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"can't reset controller, giving up\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * Move all of the commands that were busy back to the ready queue.      */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|tr
operator|=
name|twe_dequeue_busy
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|twe_enqueue_ready
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/*      * Kick the controller to start things going again, then re-enable interrupts.      */
name|twe_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twe_enable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"controller reset done, %d commands restarted\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|twe_enable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  ********************************************************************************                                                         Command I/O to Controller  ********************************************************************************  ********************************************************************************/
end_comment

begin_comment
comment|/********************************************************************************  * Try to deliver (tr) to the controller.  *  * Can be called at any interrupt level, with or without interrupts enabled.  */
end_comment

begin_function
specifier|static
name|int
name|twe_start
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|twe_softc
modifier|*
name|sc
init|=
name|tr
operator|->
name|tr_sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|done
decl_stmt|;
name|u_int32_t
name|status_reg
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* mark the command as currently being processed */
name|tr
operator|->
name|tr_status
operator|=
name|TWE_CMD_BUSY
expr_stmt|;
comment|/*       * Spin briefly waiting for the controller to come ready       *      * XXX it might be more efficient to return EBUSY immediately      *     and let the command be rescheduled.      */
for|for
control|(
name|i
operator|=
literal|100000
operator|,
name|done
operator|=
literal|0
init|;
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|!
name|done
condition|;
name|i
operator|--
control|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* check to see if we can post a command */
name|status_reg
operator|=
name|TWE_STATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twe_check_bits
argument_list|(
name|sc
argument_list|,
name|status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status_reg
operator|&
name|TWE_STATUS_COMMAND_QUEUE_FULL
operator|)
condition|)
block|{
name|TWE_COMMAND_QUEUE
argument_list|(
name|sc
argument_list|,
name|tr
operator|->
name|tr_cmdphys
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
comment|/* move command to work queue */
name|twe_enqueue_busy
argument_list|(
name|tr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TWE_DEBUG
if|if
condition|(
name|tr
operator|->
name|tr_complete
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"queued request %d with callback %p"
argument_list|,
name|tr
operator|->
name|tr_command
operator|.
name|generic
operator|.
name|request_id
argument_list|,
name|tr
operator|->
name|tr_complete
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tr
operator|->
name|tr_flags
operator|&
name|TWE_CMD_SLEEPER
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"queued request %d with wait channel %p"
argument_list|,
name|tr
operator|->
name|tr_command
operator|.
name|generic
operator|.
name|request_id
argument_list|,
name|tr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"queued request %d for polling caller"
argument_list|,
name|tr
operator|->
name|tr_command
operator|.
name|generic
operator|.
name|request_id
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* drop spl to allow completion interrupts */
block|}
comment|/* command is enqueued */
if|if
condition|(
name|done
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*       * We couldn't get the controller to take the command; try submitting it again later.      * This should only happen if something is wrong with the controller, or if we have      * overestimated the number of commands it can accept.  (Should we actually reject      * the command at this point?)      */
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Poll the controller (sc) for completed commands.  *  * Can be called at any interrupt level, with or without interrupts enabled.  */
end_comment

begin_function
specifier|static
name|void
name|twe_done
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|TWE_Response_Queue
name|rq
decl_stmt|;
name|struct
name|twe_request
modifier|*
name|tr
decl_stmt|;
name|int
name|s
decl_stmt|,
name|found
decl_stmt|;
name|u_int32_t
name|status_reg
decl_stmt|;
name|debug_called
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* loop collecting completed commands */
name|found
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|status_reg
operator|=
name|TWE_STATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twe_check_bits
argument_list|(
name|sc
argument_list|,
name|status_reg
argument_list|)
expr_stmt|;
comment|/* XXX should this fail? */
if|if
condition|(
operator|!
operator|(
name|status_reg
operator|&
name|TWE_STATUS_RESPONSE_QUEUE_EMPTY
operator|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|rq
operator|=
name|TWE_RESPONSE_QUEUE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tr
operator|=
name|sc
operator|->
name|twe_lookup
index|[
name|rq
operator|.
name|u
operator|.
name|response_id
index|]
expr_stmt|;
comment|/* find command */
if|if
condition|(
name|tr
operator|!=
name|NULL
condition|)
block|{
comment|/* paranoia */
name|debug
argument_list|(
literal|3
argument_list|,
literal|"completed request id %d with status %d"
argument_list|,
name|tr
operator|->
name|tr_command
operator|.
name|generic
operator|.
name|request_id
argument_list|,
name|tr
operator|->
name|tr_command
operator|.
name|generic
operator|.
name|status
argument_list|)
expr_stmt|;
comment|/* move to completed queue */
name|twe_remove_busy
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|twe_enqueue_complete
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"done event for nonbusy id %d\n"
argument_list|,
name|rq
operator|.
name|u
operator|.
name|response_id
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
comment|/* no response ready */
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* if we've completed any commands, try posting some more */
if|if
condition|(
name|found
condition|)
name|twe_startio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* handle completion and timeouts */
name|twe_complete
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX use deferred completion? */
block|}
end_function

begin_comment
comment|/********************************************************************************  * Perform post-completion processing for commands on (sc).  *  * This is split from twe_done as it can be safely deferred and run at a lower  * priority level should facilities for such a thing become available.  */
end_comment

begin_function
specifier|static
name|void
name|twe_complete
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|twe_request
modifier|*
name|tr
decl_stmt|;
name|debug_called
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/*      * Pull commands off the completed list, dispatch them appropriately      */
while|while
condition|(
operator|(
name|tr
operator|=
name|twe_dequeue_complete
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* unmap the command's data buffer */
name|twe_unmap_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* mark command as complete */
name|tr
operator|->
name|tr_status
operator|=
name|TWE_CMD_COMPLETE
expr_stmt|;
comment|/* dispatch to suit command originator */
if|if
condition|(
name|tr
operator|->
name|tr_complete
operator|!=
name|NULL
condition|)
block|{
comment|/* completion callback */
name|debug
argument_list|(
literal|2
argument_list|,
literal|"call completion handler %p"
argument_list|,
name|tr
operator|->
name|tr_complete
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_complete
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tr
operator|->
name|tr_flags
operator|&
name|TWE_CMD_SLEEPER
condition|)
block|{
comment|/* caller is asleep waiting */
name|debug
argument_list|(
literal|2
argument_list|,
literal|"wake up command owner on %p"
argument_list|,
name|tr
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* caller is polling command */
name|debug
argument_list|(
literal|2
argument_list|,
literal|"command left for owner"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/********************************************************************************  * Wait for (status) to be set in the controller status register for up to  * (timeout) seconds.  Returns 0 if found, nonzero if we time out.  *  * Note: this busy-waits, rather than sleeping, since we may be called with  * eg. clock interrupts masked.  */
end_comment

begin_function
specifier|static
name|int
name|twe_wait_status
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|status
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|time_t
name|expiry
decl_stmt|;
name|u_int32_t
name|status_reg
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|expiry
operator|=
name|time_second
operator|+
name|timeout
expr_stmt|;
do|do
block|{
name|status_reg
operator|=
name|TWE_STATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_reg
operator|&
name|status
condition|)
comment|/* got the required bit(s)? */
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|time_second
operator|<=
name|expiry
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Drain the response queue, which may contain responses to commands we know  * nothing about.  */
end_comment

begin_function
specifier|static
name|int
name|twe_drain_response_queue
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|TWE_Response_Queue
name|rq
decl_stmt|;
name|u_int32_t
name|status_reg
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* XXX give up eventually? */
name|status_reg
operator|=
name|TWE_STATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|twe_check_bits
argument_list|(
name|sc
argument_list|,
name|status_reg
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|status_reg
operator|&
name|TWE_STATUS_RESPONSE_QUEUE_EMPTY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rq
operator|=
name|TWE_RESPONSE_QUEUE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/********************************************************************************  * Soft-reset the controller  */
end_comment

begin_function
specifier|static
name|int
name|twe_soft_reset
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|status_reg
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|TWE_SOFT_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|twe_wait_status
argument_list|(
name|sc
argument_list|,
name|TWE_STATUS_ATTENTION_INTERRUPT
argument_list|,
literal|15
argument_list|)
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"no attention interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|twe_drain_aen_queue
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"can't drain AEN queue\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|twe_find_aen
argument_list|(
name|sc
argument_list|,
name|TWE_AEN_SOFT_RESET
argument_list|)
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"reset not reported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|status_reg
operator|=
name|TWE_STATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TWE_STATUS_ERRORS
argument_list|(
name|status_reg
argument_list|)
operator|||
name|twe_check_bits
argument_list|(
name|sc
argument_list|,
name|status_reg
argument_list|)
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"controller errors detected\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|twe_drain_response_queue
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"can't drain response queue\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  ********************************************************************************                                                                Interrupt Handling  ********************************************************************************  ********************************************************************************/
end_comment

begin_comment
comment|/********************************************************************************  * Host interrupt.  *  * XXX what does this mean?  */
end_comment

begin_function
specifier|static
name|void
name|twe_host_intr
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"host interrupt\n"
argument_list|)
expr_stmt|;
name|TWE_CONTROL
argument_list|(
name|sc
argument_list|,
name|TWE_CONTROL_CLEAR_HOST_INTERRUPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Attention interrupt.  *  * Signalled when the controller has one or more AENs for us.  */
end_comment

begin_function
specifier|static
name|void
name|twe_attention_intr
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* instigate a poll for AENs */
if|if
condition|(
name|twe_fetch_aen
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"error polling for signalled AEN\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TWE_CONTROL
argument_list|(
name|sc
argument_list|,
name|TWE_CONTROL_CLEAR_ATTENTION_INTERRUPT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/********************************************************************************  * Command interrupt.  *  * Signalled when the controller can handle more commands.  */
end_comment

begin_function
specifier|static
name|void
name|twe_command_intr
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/*      * We don't use this, rather we try to submit commands when we receive      * them, and when other commands have completed.  Mask it so we don't get      * another one.      */
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"command interrupt\n"
argument_list|)
expr_stmt|;
name|TWE_CONTROL
argument_list|(
name|sc
argument_list|,
name|TWE_CONTROL_MASK_COMMAND_INTERRUPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  ********************************************************************************                                                       Asynchronous Event Handling  ********************************************************************************  ********************************************************************************/
end_comment

begin_comment
comment|/********************************************************************************  * Request an AEN from the controller.  */
end_comment

begin_function
specifier|static
name|int
name|twe_fetch_aen
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|TWE_PARAM_AEN
argument_list|,
name|TWE_PARAM_AEN_UnitCode
argument_list|,
literal|2
argument_list|,
name|twe_handle_aen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Handle an AEN returned by the controller.  */
end_comment

begin_function
specifier|static
name|void
name|twe_handle_aen
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|twe_softc
modifier|*
name|sc
init|=
name|tr
operator|->
name|tr_sc
decl_stmt|;
name|TWE_Param
modifier|*
name|param
decl_stmt|;
name|u_int16_t
name|aen
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* XXX check for command success somehow? */
name|param
operator|=
operator|(
name|TWE_Param
operator|*
operator|)
name|tr
operator|->
name|tr_data
expr_stmt|;
name|aen
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|param
operator|->
name|data
operator|)
expr_stmt|;
name|free
argument_list|(
name|tr
operator|->
name|tr_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|twe_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|twe_enqueue_aen
argument_list|(
name|sc
argument_list|,
name|aen
argument_list|)
expr_stmt|;
comment|/* XXX poll for more AENs? */
block|}
end_function

begin_comment
comment|/********************************************************************************  * Pull AENs out of the controller and park them in the queue, in a context where  * interrupts aren't active.  Return nonzero if we encounter any errors in the  * process of obtaining all the available AENs.  */
end_comment

begin_function
specifier|static
name|int
name|twe_drain_aen_queue
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int16_t
name|aen
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|twe_get_param_2
argument_list|(
name|sc
argument_list|,
name|TWE_PARAM_AEN
argument_list|,
name|TWE_PARAM_AEN_UnitCode
argument_list|,
operator|&
name|aen
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|aen
operator|==
name|TWE_AEN_QUEUE_EMPTY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|twe_enqueue_aen
argument_list|(
name|sc
argument_list|,
name|aen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/********************************************************************************  * Push an AEN that we've received onto the queue.  *  * Note that we have to lock this against reentrance, since it may be called  * from both interrupt and non-interrupt context.  *  * If someone is waiting for the AEN we have, wake them up.  */
end_comment

begin_function
specifier|static
name|void
name|twe_enqueue_aen
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|aen
parameter_list|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|s
decl_stmt|,
name|next
decl_stmt|,
name|nextnext
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|=
name|twe_format_aen
argument_list|(
name|sc
argument_list|,
name|aen
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"AEN:<%s>\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* enqueue the AEN */
name|next
operator|=
operator|(
operator|(
name|sc
operator|->
name|twe_aen_head
operator|+
literal|1
operator|)
operator|%
name|TWE_Q_LENGTH
operator|)
expr_stmt|;
name|nextnext
operator|=
operator|(
operator|(
name|sc
operator|->
name|twe_aen_head
operator|+
literal|2
operator|)
operator|%
name|TWE_Q_LENGTH
operator|)
expr_stmt|;
comment|/* check to see if this is the last free slot, and subvert the AEN if it is */
if|if
condition|(
name|nextnext
operator|==
name|sc
operator|->
name|twe_aen_tail
condition|)
name|aen
operator|=
name|TWE_AEN_QUEUE_FULL
expr_stmt|;
comment|/* look to see if there's room for this AEN */
if|if
condition|(
name|next
operator|!=
name|sc
operator|->
name|twe_aen_tail
condition|)
block|{
name|sc
operator|->
name|twe_aen_queue
index|[
name|sc
operator|->
name|twe_aen_head
index|]
operator|=
name|aen
expr_stmt|;
name|sc
operator|->
name|twe_aen_head
operator|=
name|next
expr_stmt|;
block|}
comment|/* wake up anyone asleep on the queue */
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|twe_aen_queue
argument_list|)
expr_stmt|;
comment|/* anyone looking for this AEN? */
if|if
condition|(
name|sc
operator|->
name|twe_wait_aen
operator|==
name|aen
condition|)
block|{
name|sc
operator|->
name|twe_wait_aen
operator|=
operator|-
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|twe_wait_aen
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Pop an AEN off the queue, or return -1 if there are none left.  *  * We are more or less interrupt-safe, so don't block interrupts.  */
end_comment

begin_function
specifier|static
name|int
name|twe_dequeue_aen
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|twe_aen_tail
operator|==
name|sc
operator|->
name|twe_aen_head
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|sc
operator|->
name|twe_aen_queue
index|[
name|sc
operator|->
name|twe_aen_tail
index|]
expr_stmt|;
name|sc
operator|->
name|twe_aen_tail
operator|=
operator|(
operator|(
name|sc
operator|->
name|twe_aen_tail
operator|+
literal|1
operator|)
operator|%
name|TWE_Q_LENGTH
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Check to see if the requested AEN is in the queue.  *  * XXX we could probably avoid masking interrupts here  */
end_comment

begin_function
specifier|static
name|int
name|twe_find_aen
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|aen
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|missing
decl_stmt|;
name|missing
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|twe_aen_tail
init|;
operator|(
name|i
operator|!=
name|sc
operator|->
name|twe_aen_head
operator|)
operator|&&
name|missing
condition|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|TWE_Q_LENGTH
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|twe_aen_queue
index|[
name|i
index|]
operator|==
name|aen
condition|)
name|missing
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|missing
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* currently unused */
end_comment

begin_comment
comment|/********************************************************************************  * Sleep waiting for at least (timeout) seconds until we see (aen) as   * requested.  Returns nonzero on timeout or failure.  *  * XXX: this should not be used in cases where there may be more than one sleeper  *      without a mechanism for registering multiple sleepers.  */
end_comment

begin_endif
unit|static int twe_wait_aen(struct twe_softc *sc, int aen, int timeout) {     time_t	expiry;     int		found, s;      debug_called(4);      expiry = time_second + timeout;     found = 0;      s = splbio();     sc->twe_wait_aen = aen;     do { 	twe_fetch_aen(sc); 	tsleep(&sc->twe_wait_aen, PZERO, "twewaen", hz); 	if (sc->twe_wait_aen == -1) 	    found = 1;     } while ((time_second<= expiry)&& !found);     splx(s);     return(!found); }
endif|#
directive|endif
end_endif

begin_comment
comment|/********************************************************************************  ********************************************************************************                                                         Command Buffer Management  ********************************************************************************  ********************************************************************************/
end_comment

begin_comment
comment|/********************************************************************************  * Get a new command buffer.  *  * This will return NULL if all command buffers are in use.  */
end_comment

begin_function
specifier|static
name|int
name|twe_get_request
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twe_request
modifier|*
modifier|*
name|tr
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* try to reuse an old buffer */
operator|*
name|tr
operator|=
name|twe_dequeue_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* initialise some fields to their defaults */
if|if
condition|(
operator|*
name|tr
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|*
name|tr
operator|)
operator|->
name|tr_data
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|tr
operator|)
operator|->
name|tr_status
operator|=
name|TWE_CMD_SETUP
expr_stmt|;
comment|/* command is in setup phase */
operator|(
operator|*
name|tr
operator|)
operator|->
name|tr_flags
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|tr
operator|)
operator|->
name|tr_complete
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|tr
operator|)
operator|->
name|tr_command
operator|.
name|generic
operator|.
name|status
operator|=
literal|0
expr_stmt|;
comment|/* before submission to controller */
operator|(
operator|*
name|tr
operator|)
operator|->
name|tr_command
operator|.
name|generic
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* not used */
block|}
return|return
operator|(
operator|*
name|tr
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Release a command buffer for reuse.  *  */
end_comment

begin_function
specifier|static
name|void
name|twe_release_request
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|twe_enqueue_free
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************************  ********************************************************************************                                                                         Debugging  ********************************************************************************  ********************************************************************************/
end_comment

begin_comment
comment|/********************************************************************************  * Print some information about the controller  */
end_comment

begin_function
name|void
name|twe_describe_controller
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|TWE_Param
modifier|*
name|p
index|[
literal|6
index|]
decl_stmt|;
name|u_int8_t
name|ports
decl_stmt|;
name|u_int32_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug_called
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* get the port count */
name|twe_get_param_1
argument_list|(
name|sc
argument_list|,
name|TWE_PARAM_CONTROLLER
argument_list|,
name|TWE_PARAM_CONTROLLER_PortCount
argument_list|,
operator|&
name|ports
argument_list|)
expr_stmt|;
comment|/* get version strings */
name|p
index|[
literal|0
index|]
operator|=
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|TWE_PARAM_VERSION
argument_list|,
name|TWE_PARAM_VERSION_Mon
argument_list|,
literal|16
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|TWE_PARAM_VERSION
argument_list|,
name|TWE_PARAM_VERSION_FW
argument_list|,
literal|16
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|TWE_PARAM_VERSION
argument_list|,
name|TWE_PARAM_VERSION_BIOS
argument_list|,
literal|16
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|TWE_PARAM_VERSION
argument_list|,
name|TWE_PARAM_VERSION_PCB
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|TWE_PARAM_VERSION
argument_list|,
name|TWE_PARAM_VERSION_ATA
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|TWE_PARAM_VERSION
argument_list|,
name|TWE_PARAM_VERSION_PCI
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"%d ports, Firmware %.16s, BIOS %.16s\n"
argument_list|,
name|ports
argument_list|,
name|p
index|[
literal|1
index|]
operator|->
name|data
argument_list|,
name|p
index|[
literal|2
index|]
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"Monitor %.16s, PCB %.8s, Achip %.8s, Pchip %.8s\n"
argument_list|,
name|p
index|[
literal|0
index|]
operator|->
name|data
argument_list|,
name|p
index|[
literal|3
index|]
operator|->
name|data
argument_list|,
name|p
index|[
literal|4
index|]
operator|->
name|data
argument_list|,
name|p
index|[
literal|5
index|]
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
index|[
literal|4
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
index|[
literal|5
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* print attached drives */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|TWE_PARAM_DRIVESUMMARY
argument_list|,
name|TWE_PARAM_DRIVESUMMARY_Status
argument_list|,
literal|16
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|->
name|data
index|[
name|i
index|]
operator|!=
name|TWE_PARAM_DRIVESTATUS_Present
condition|)
continue|continue;
name|twe_get_param_4
argument_list|(
name|sc
argument_list|,
name|TWE_PARAM_DRIVEINFO
operator|+
name|i
argument_list|,
name|TWE_PARAM_DRIVEINFO_Size
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|twe_get_param
argument_list|(
name|sc
argument_list|,
name|TWE_PARAM_DRIVEINFO
operator|+
name|i
argument_list|,
name|TWE_PARAM_DRIVEINFO_Model
argument_list|,
literal|40
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"port %d: %.40s %dMB\n"
argument_list|,
name|i
argument_list|,
name|p
index|[
literal|1
index|]
operator|->
name|data
argument_list|,
name|size
operator|/
literal|2048
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"port %d, drive status unavailable\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/********************************************************************************  * Complain if the status bits aren't what we're expecting.  *  * Rate-limit the complaints to at most one of each every five seconds, but  * always return the correct status.  */
end_comment

begin_function
specifier|static
name|int
name|twe_check_bits
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|status_reg
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
specifier|static
name|time_t
name|lastwarn
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/*      * This can be a little problematic, as twe_panic may call twe_reset if       * TWE_DEBUG is not set, which will call us again as part of the soft reset.      */
if|if
condition|(
operator|(
name|status_reg
operator|&
name|TWE_STATUS_PANIC_BITS
operator|)
operator|!=
literal|0
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"FATAL STATUS BIT(S) %b\n"
argument_list|,
name|status_reg
operator|&
name|TWE_STATUS_PANIC_BITS
argument_list|,
name|TWE_STATUS_BITS_DESCRIPTION
argument_list|)
expr_stmt|;
name|twe_panic
argument_list|(
name|sc
argument_list|,
literal|"fatal status bits"
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|status_reg
operator|&
name|TWE_STATUS_EXPECTED_BITS
operator|)
operator|!=
name|TWE_STATUS_EXPECTED_BITS
condition|)
block|{
if|if
condition|(
name|time_second
operator|>
operator|(
name|lastwarn
index|[
literal|0
index|]
operator|+
literal|5
operator|)
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"missing expected status bit(s) %b\n"
argument_list|,
operator|~
name|status_reg
operator|&
name|TWE_STATUS_EXPECTED_BITS
argument_list|,
name|TWE_STATUS_BITS_DESCRIPTION
argument_list|)
expr_stmt|;
name|lastwarn
index|[
literal|0
index|]
operator|=
name|time_second
expr_stmt|;
block|}
name|result
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status_reg
operator|&
name|TWE_STATUS_UNEXPECTED_BITS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|time_second
operator|>
operator|(
name|lastwarn
index|[
literal|1
index|]
operator|+
literal|5
operator|)
condition|)
block|{
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"unexpected status bit(s) %b\n"
argument_list|,
name|status_reg
operator|&
name|TWE_STATUS_UNEXPECTED_BITS
argument_list|,
name|TWE_STATUS_BITS_DESCRIPTION
argument_list|)
expr_stmt|;
name|lastwarn
index|[
literal|1
index|]
operator|=
name|time_second
expr_stmt|;
block|}
name|result
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************************  * Return a string describing (aen).  *  * The low 8 bits of the aen are the code, the high 8 bits give the unit number  * where an AEN is specific to a unit.  *  * Note that we could expand this routine to handle eg. up/downgrading the status  * of a drive if we had some idea of what the drive's initial status was.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|twe_format_aen
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|aen
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|char
modifier|*
name|code
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
name|code
operator|=
name|twe_describe_code
argument_list|(
name|twe_table_aen
argument_list|,
name|TWE_AEN_CODE
argument_list|(
name|aen
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|code
operator|+
literal|2
expr_stmt|;
switch|switch
condition|(
operator|*
name|code
condition|)
block|{
case|case
literal|'q'
case|:
if|if
condition|(
operator|!
name|bootverbose
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* FALLTHROUGH */
case|case
literal|'p'
case|:
return|return
operator|(
name|msg
operator|)
return|;
case|case
literal|'c'
case|:
if|if
condition|(
operator|(
name|child
operator|=
name|sc
operator|->
name|twe_drive
index|[
name|TWE_AEN_UNIT
argument_list|(
name|aen
argument_list|)
index|]
operator|.
name|td_disk
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"twed%d: %s"
argument_list|,
name|device_get_unit
argument_list|(
name|child
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"twe%d: %s for unknown unit %d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|twe_dev
argument_list|)
argument_list|,
name|msg
argument_list|,
name|TWE_AEN_UNIT
argument_list|(
name|aen
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
case|case
literal|'x'
case|:
default|default:
break|break;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"unknown AEN 0x%x"
argument_list|,
name|aen
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|twe_request_qlen
parameter_list|(
name|struct
name|twe_request
modifier|*
name|tr
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|tr
operator|!=
name|NULL
condition|)
block|{
name|tr
operator|=
name|TAILQ_NEXT
argument_list|(
name|tr
argument_list|,
name|tr_link
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
name|void
name|twe_print_controller
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|status_reg
decl_stmt|;
name|status_reg
operator|=
name|TWE_STATUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"status   %b\n"
argument_list|,
name|status_reg
argument_list|,
name|TWE_STATUS_BITS_DESCRIPTION
argument_list|)
expr_stmt|;
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"free     %d\n"
argument_list|,
name|twe_request_qlen
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|twe_free
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"ready    %d\n"
argument_list|,
name|twe_request_qlen
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|twe_ready
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"busy     %d\n"
argument_list|,
name|twe_request_qlen
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|twe_busy
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"complete %d\n"
argument_list|,
name|twe_request_qlen
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|twe_complete
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|twe_printf
argument_list|(
name|sc
argument_list|,
literal|"AEN queue head %d  tail %d\n"
argument_list|,
name|sc
operator|->
name|twe_aen_head
argument_list|,
name|sc
operator|->
name|twe_aen_tail
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|twe_panic
parameter_list|(
name|struct
name|twe_softc
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|reason
parameter_list|)
block|{
name|twe_print_controller
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TWE_DEBUG
name|panic
argument_list|(
name|reason
argument_list|)
expr_stmt|;
else|#
directive|else
name|twe_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/********************************************************************************  * Print a request/command in human-readable format.  */
end_comment

begin_comment
unit|static void twe_print_request(struct twe_request *tr) {     struct twe_softc	*sc = tr->tr_sc;     TWE_Command	*cmd =&tr->tr_command;     int		i;      twe_printf(sc, "CMD: request_id %d  opcode<%s>  size %d  unit %d  host_id %d\n",  	       cmd->generic.request_id, twe_describe_code(twe_table_opcode, cmd->generic.opcode), cmd->generic.size,  	       cmd->generic.unit, cmd->generic.host_id);     twe_printf(sc, " status %d  flags 0x%x  count %d  sgl_offset %d\n",  	       cmd->generic.status, cmd->generic.flags, cmd->generic.count, cmd->generic.sgl_offset);      switch(cmd->generic.opcode) {
comment|/* XXX add more opcodes? */
end_comment

begin_endif
unit|case TWE_OP_READ:     case TWE_OP_WRITE: 	twe_printf(sc, " lba %d\n", cmd->io.lba); 	for (i = 0; (i< TWE_MAX_SGL_LENGTH)&& (cmd->io.sgl[i].length != 0); i++) 	    twe_printf(sc, "  %d: 0x%x/%d\n",  		       i, cmd->io.sgl[i].address, cmd->io.sgl[i].length); 	break;      case TWE_OP_GET_PARAM:     case TWE_OP_SET_PARAM: 	for (i = 0; (i< TWE_MAX_SGL_LENGTH)&& (cmd->param.sgl[i].length != 0); i++) 	    twe_printf(sc, "  %d: 0x%x/%d\n",  		       i, cmd->param.sgl[i].address, cmd->param.sgl[i].length); 	break;      case TWE_OP_INIT_CONNECTION: 	twe_printf(sc, " response queue pointer 0x%x\n",  		   cmd->initconnection.response_queue_pointer); 	break;      default: 	break;     }     twe_printf(sc, " tr_command %p/0x%x  tr_data %p/0x%x,%d\n",  	       tr, tr->tr_cmdphys, tr->tr_data, tr->tr_dataphys, tr->tr_length);     twe_printf(sc, " tr_status %d  tr_flags 0x%x  tr_complete %p  tr_private %p\n",  	       tr->tr_status, tr->tr_flags, tr->tr_complete, tr->tr_private); }
endif|#
directive|endif
end_endif

end_unit

