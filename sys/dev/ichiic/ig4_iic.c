begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2014 The DragonFly Project.  All rights reserved.  *  * This code is derived from software contributed to The DragonFly Project  * by Matthew Dillon<dillon@backplane.com> and was subsequently ported  * to FreeBSD by Michael Gmelin<freebsd@grem.de>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  * 3. Neither the name of The DragonFly Project nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific, prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE  * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Intel fourth generation mobile cpus integrated I2C deviceer.  *  * See ig4_reg.h for datasheet reference and notes.  * See ig4_var.h for locking semantics.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iicbus.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iiconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ichiic/ig4_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ichiic/ig4_var.h>
end_include

begin_define
define|#
directive|define
name|TRANS_NORMAL
value|1
end_define

begin_define
define|#
directive|define
name|TRANS_PCALL
value|2
end_define

begin_define
define|#
directive|define
name|TRANS_BLOCK
value|3
end_define

begin_function_decl
specifier|static
name|void
name|ig4iic_start
parameter_list|(
name|void
modifier|*
name|xdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ig4iic_intr
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ig4iic_dump
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|ig4_dump
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|ig4_dump
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ig4_dump
argument_list|,
literal|0
argument_list|,
literal|"Dump controller registers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Low-level inline support functions  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|reg_write
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|,
name|reg
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|bus_barrier
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|reg_read
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
block|{
name|uint32_t
name|value
decl_stmt|;
name|bus_barrier
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
name|value
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable or disable the controller and wait for the controller to acknowledge  * the state change.  */
end_comment

begin_function
specifier|static
name|int
name|set_controller
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|ctl
parameter_list|)
block|{
name|int
name|retry
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
comment|/* 	 * When the controller is enabled, interrupt on STOP detect 	 * or receive character ready and clear pending interrupts. 	 */
if|if
condition|(
name|ctl
operator|&
name|IG4_I2C_ENABLE
condition|)
block|{
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_INTR_MASK
argument_list|,
name|IG4_INTR_STOP_DET
operator||
name|IG4_INTR_RX_FULL
argument_list|)
expr_stmt|;
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CLR_INTR
argument_list|)
expr_stmt|;
block|}
else|else
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_INTR_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_I2C_EN
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|error
operator|=
name|IIC_ETIMEOUT
expr_stmt|;
for|for
control|(
name|retry
operator|=
literal|100
init|;
name|retry
operator|>
literal|0
condition|;
operator|--
name|retry
control|)
block|{
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_ENABLE_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|v
operator|^
name|ctl
operator|)
operator|&
name|IG4_I2C_ENABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cold
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
else|else
name|mtx_sleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|io_lock
argument_list|,
literal|0
argument_list|,
literal|"i2cslv"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait up to 25ms for the requested status using a 25uS polling loop.  */
end_comment

begin_function
specifier|static
name|int
name|wait_status
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|status
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|txlvl
init|=
operator|-
literal|1
decl_stmt|;
name|u_int
name|count_us
init|=
literal|0
decl_stmt|;
name|u_int
name|limit_us
init|=
literal|25000
decl_stmt|;
comment|/* 25ms */
name|error
operator|=
name|IIC_ETIMEOUT
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Check requested status 		 */
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_I2C_STA
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|status
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * When waiting for receive data break-out if the interrupt 		 * loaded data into the FIFO. 		 */
if|if
condition|(
name|status
operator|&
name|IG4_STATUS_RX_NOTEMPTY
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|rpos
operator|!=
name|sc
operator|->
name|rnext
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * When waiting for the transmit FIFO to become empty, 		 * reset the timeout if we see a change in the transmit 		 * FIFO level as progress is being made. 		 */
if|if
condition|(
name|status
operator|&
name|IG4_STATUS_TX_EMPTY
condition|)
block|{
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TXFLR
argument_list|)
operator|&
name|IG4_FIFOLVL_MASK
expr_stmt|;
if|if
condition|(
name|txlvl
operator|!=
name|v
condition|)
block|{
name|txlvl
operator|=
name|v
expr_stmt|;
name|count_us
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 * Stop if we've run out of time. 		 */
if|if
condition|(
name|count_us
operator|>=
name|limit_us
condition|)
break|break;
comment|/* 		 * When waiting for receive data let the interrupt do its 		 * work, otherwise poll with the lock held. 		 */
if|if
condition|(
name|status
operator|&
name|IG4_STATUS_RX_NOTEMPTY
condition|)
block|{
name|mtx_sleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|io_lock
argument_list|,
literal|0
argument_list|,
literal|"i2cwait"
argument_list|,
operator|(
name|hz
operator|+
literal|99
operator|)
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* sleep up to 10ms */
name|count_us
operator|+=
literal|10000
expr_stmt|;
block|}
else|else
block|{
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
name|count_us
operator|+=
literal|25
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read I2C data.  The data might have already been read by  * the interrupt code, otherwise it is sitting in the data  * register.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|data_read
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|c
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|rpos
operator|==
name|sc
operator|->
name|rnext
condition|)
block|{
name|c
operator|=
operator|(
name|uint8_t
operator|)
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|sc
operator|->
name|rbuf
index|[
name|sc
operator|->
name|rpos
operator|&
name|IG4_RBUFMASK
index|]
expr_stmt|;
operator|++
name|sc
operator|->
name|rpos
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the slave address.  The controller must be disabled when  * changing the address.  *  * This operation does not issue anything to the I2C bus but sets  * the target address for when the controller later issues a START.  */
end_comment

begin_function
specifier|static
name|void
name|set_slave_addr
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|slave
parameter_list|)
block|{
name|uint32_t
name|tar
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|int
name|use_10bit
decl_stmt|;
name|use_10bit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|slave_valid
operator|&&
name|sc
operator|->
name|last_slave
operator|==
name|slave
operator|&&
name|sc
operator|->
name|use_10bit
operator|==
name|use_10bit
condition|)
block|{
return|return;
block|}
name|sc
operator|->
name|use_10bit
operator|=
name|use_10bit
expr_stmt|;
comment|/* 	 * Wait for TXFIFO to drain before disabling the controller. 	 * 	 * If a write message has not been completed it's really a 	 * programming error, but for now in that case issue an extra 	 * byte + STOP. 	 * 	 * If a read message has not been completed it's also a programming 	 * error, for now just ignore it. 	 */
name|wait_status
argument_list|(
name|sc
argument_list|,
name|IG4_STATUS_TX_NOTFULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|write_started
condition|)
block|{
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|,
name|IG4_DATA_STOP
argument_list|)
expr_stmt|;
name|sc
operator|->
name|write_started
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|read_started
condition|)
name|sc
operator|->
name|read_started
operator|=
literal|0
expr_stmt|;
name|wait_status
argument_list|(
name|sc
argument_list|,
name|IG4_STATUS_TX_EMPTY
argument_list|)
expr_stmt|;
name|set_controller
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CTL
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
name|IG4_CTL_10BIT
expr_stmt|;
name|ctl
operator||=
name|IG4_CTL_RESTARTEN
expr_stmt|;
name|tar
operator|=
name|slave
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|use_10bit
condition|)
block|{
name|tar
operator||=
name|IG4_TAR_10BIT
expr_stmt|;
name|ctl
operator||=
name|IG4_CTL_10BIT
expr_stmt|;
block|}
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TAR_ADD
argument_list|,
name|tar
argument_list|)
expr_stmt|;
name|set_controller
argument_list|(
name|sc
argument_list|,
name|IG4_I2C_ENABLE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|slave_valid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|last_slave
operator|=
name|slave
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *				IICBUS API FUNCTIONS  */
end_comment

begin_function
specifier|static
name|int
name|ig4iic_xfer_start
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|slave
parameter_list|)
block|{
name|set_slave_addr
argument_list|(
name|sc
argument_list|,
name|slave
operator|>>
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ig4iic_read
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint16_t
name|len
parameter_list|,
name|bool
name|repeated_start
parameter_list|,
name|bool
name|stop
parameter_list|)
block|{
name|uint32_t
name|cmd
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cmd
operator|=
name|IG4_DATA_COMMAND_RD
expr_stmt|;
name|cmd
operator||=
name|repeated_start
condition|?
name|IG4_DATA_RESTART
else|:
literal|0
expr_stmt|;
name|cmd
operator||=
name|stop
operator|&&
name|len
operator|==
literal|1
condition|?
name|IG4_DATA_STOP
else|:
literal|0
expr_stmt|;
comment|/* Issue request for the first byte (could be last as well). */
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Maintain a pipeline by queueing the allowance for the next 		 * read before waiting for the current read. 		 */
name|cmd
operator|=
name|IG4_DATA_COMMAND_RD
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
operator|-
literal|1
condition|)
block|{
name|cmd
operator|=
name|IG4_DATA_COMMAND_RD
expr_stmt|;
name|cmd
operator||=
name|stop
operator|&&
name|i
operator|==
name|len
operator|-
literal|2
condition|?
name|IG4_DATA_STOP
else|:
literal|0
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|wait_status
argument_list|(
name|sc
argument_list|,
name|IG4_STATUS_RX_NOTEMPTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|buf
index|[
name|i
index|]
operator|=
name|data_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TX_ABRT_SOURCE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ig4iic_write
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint16_t
name|len
parameter_list|,
name|bool
name|repeated_start
parameter_list|,
name|bool
name|stop
parameter_list|)
block|{
name|uint32_t
name|cmd
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cmd
operator|=
name|repeated_start
condition|?
name|IG4_DATA_RESTART
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|wait_status
argument_list|(
name|sc
argument_list|,
name|IG4_STATUS_TX_NOTFULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|cmd
operator||=
name|buf
index|[
name|i
index|]
expr_stmt|;
name|cmd
operator||=
name|stop
operator|&&
name|i
operator|==
name|len
operator|-
literal|1
condition|?
name|IG4_DATA_STOP
else|:
literal|0
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TX_ABRT_SOURCE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ig4iic_transfer
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|iic_msg
modifier|*
name|msgs
parameter_list|,
name|uint32_t
name|nmsgs
parameter_list|)
block|{
name|ig4iic_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|reason
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|bool
name|rpstart
decl_stmt|;
name|bool
name|stop
decl_stmt|;
comment|/* 	 * The hardware interface imposes limits on allowed I2C messages. 	 * It is not possible to explicitly send a start or stop. 	 * They are automatically sent (or not sent, depending on the 	 * configuration) when a data byte is transferred. 	 * For this reason it's impossible to send a message with no data 	 * at all (like an SMBus quick message). 	 * The start condition is automatically generated after the stop 	 * condition, so it's impossible to not have a start after a stop. 	 * The repeated start condition is automatically sent if a change 	 * of the transfer direction happens, so it's impossible to have 	 * a change of direction without a (repeated) start. 	 * The repeated start can be forced even without the change of 	 * direction. 	 * Changing the target slave address requires resetting the hardware 	 * state, so it's impossible to do that without the stop followed 	 * by the start. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmsgs
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
literal|0
block|if (i == 0&& (msgs[i].flags& IIC_M_NOSTART) != 0) { 			reason = "first message without start"; 			break; 		} 		if (i == nmsgs - 1&& (msgs[i].flags& IIC_M_NOSTOP) != 0) { 			reason = "last message without stop"; 			break; 		}
endif|#
directive|endif
if|if
condition|(
name|msgs
index|[
name|i
index|]
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|reason
operator|=
literal|"message with no data"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|msgs
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IIC_M_NOSTART
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|msgs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|IIC_M_NOSTOP
operator|)
operator|==
literal|0
condition|)
block|{
name|reason
operator|=
literal|"stop not followed by start"
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|msgs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|IIC_M_NOSTOP
operator|)
operator|!=
literal|0
operator|&&
name|msgs
index|[
name|i
index|]
operator|.
name|slave
operator|!=
name|msgs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|slave
condition|)
block|{
name|reason
operator|=
literal|"change of slave without stop"
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|msgs
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IIC_M_NOSTART
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|msgs
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IIC_M_RD
operator|)
operator|!=
operator|(
name|msgs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|flags
operator|&
name|IIC_M_RD
operator|)
condition|)
block|{
name|reason
operator|=
literal|"change of direction without repeated"
literal|" start"
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|reason
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s\n"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
operator|(
name|IIC_ENOTSUPP
operator|)
return|;
block|}
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/* Debugging - dump registers. */
if|if
condition|(
name|ig4_dump
condition|)
block|{
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ig4_dump
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
condition|)
block|{
name|ig4_dump
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|unit
operator|)
expr_stmt|;
name|ig4iic_dump
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Clear any previous abort condition that may have been holding 	 * the txfifo in reset. 	 */
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CLR_TX_ABORT
argument_list|)
expr_stmt|;
comment|/* 	 * Clean out any previously received data. 	 */
if|if
condition|(
name|sc
operator|->
name|rpos
operator|!=
name|sc
operator|->
name|rnext
operator|&&
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"discarding %d bytes of spurious data\n"
argument_list|,
name|sc
operator|->
name|rnext
operator|-
name|sc
operator|->
name|rpos
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|rpos
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rnext
operator|=
literal|0
expr_stmt|;
name|rpstart
operator|=
name|false
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmsgs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|msgs
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IIC_M_NOSTART
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ig4iic_xfer_start
argument_list|(
name|sc
argument_list|,
name|msgs
index|[
name|i
index|]
operator|.
name|slave
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|slave_valid
operator|||
operator|(
name|msgs
index|[
name|i
index|]
operator|.
name|slave
operator|>>
literal|1
operator|)
operator|!=
name|sc
operator|->
name|last_slave
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"start condition suppressed"
literal|"but slave address is not set up"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rpstart
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|stop
operator|=
operator|(
name|msgs
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IIC_M_NOSTOP
operator|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|msgs
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IIC_M_RD
condition|)
name|error
operator|=
name|ig4iic_read
argument_list|(
name|sc
argument_list|,
name|msgs
index|[
name|i
index|]
operator|.
name|buf
argument_list|,
name|msgs
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|rpstart
argument_list|,
name|stop
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ig4iic_write
argument_list|(
name|sc
argument_list|,
name|msgs
index|[
name|i
index|]
operator|.
name|buf
argument_list|,
name|msgs
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|rpstart
argument_list|,
name|stop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|rpstart
operator|=
operator|!
name|stop
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ig4iic_reset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|speed
parameter_list|,
name|u_char
name|addr
parameter_list|,
name|u_char
modifier|*
name|oldaddr
parameter_list|)
block|{
name|ig4iic_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/* TODO handle speed configuration? */
if|if
condition|(
name|oldaddr
operator|!=
name|NULL
condition|)
operator|*
name|oldaddr
operator|=
name|sc
operator|->
name|last_slave
operator|<<
literal|1
expr_stmt|;
name|set_slave_addr
argument_list|(
name|sc
argument_list|,
name|addr
operator|>>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|IIC_UNKNOWN
condition|)
name|sc
operator|->
name|slave_valid
operator|=
name|false
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called from ig4iic_pci_attach/detach()  */
end_comment

begin_function
name|int
name|ig4iic_attach
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_COMP_TYPE
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_COMP_PARAM1
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_GENERAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|IG4_GENERAL_SWMODE
operator|)
operator|==
literal|0
condition|)
block|{
name|v
operator||=
name|IG4_GENERAL_SWMODE
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_GENERAL
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_GENERAL
argument_list|)
expr_stmt|;
block|}
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SW_LTR_VALUE
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_AUTO_LTR_VALUE
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_COMP_VER
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|IG4_COMP_VER
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_HCNT
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_LCNT
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_HCNT
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_LCNT
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SDA_HOLD
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_HCNT
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_HCNT
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_LCNT
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_LCNT
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* 	 * Program based on a 25000 Hz clock.  This is a bit of a 	 * hack (obviously).  The defaults are 400 and 470 for standard 	 * and 60 and 130 for fast.  The defaults for standard fail 	 * utterly (presumably cause an abort) because the clock time 	 * is ~18.8ms by default.  This brings it down to ~4ms (for now). 	 */
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_HCNT
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_LCNT
argument_list|,
literal|125
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_HCNT
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_LCNT
argument_list|,
literal|125
argument_list|)
expr_stmt|;
comment|/* 	 * Use a threshold of 1 so we get interrupted on each character, 	 * allowing us to use mtx_sleep() in our poll code.  Not perfect 	 * but this is better than using DELAY() for receiving data. 	 * 	 * See ig4_var.h for details on interrupt handler synchronization. 	 */
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_RX_TL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CTL
argument_list|,
name|IG4_CTL_MASTER
operator||
name|IG4_CTL_SLAVE_DISABLE
operator||
name|IG4_CTL_RESTARTEN
operator||
name|IG4_CTL_SPEED_STD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|iicbus
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"iicbus"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|iicbus
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"iicbus driver not found\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * Don't do this, it blows up the PCI config 	 */
block|reg_write(sc, IG4_REG_RESETS, IG4_RESETS_ASSERT); 	reg_write(sc, IG4_REG_RESETS, IG4_RESETS_DEASSERT);
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_controller
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"controller error during attach-1\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_controller
argument_list|(
name|sc
argument_list|,
name|IG4_I2C_ENABLE
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"controller error during attach-2\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|intr_res
argument_list|,
name|INTR_TYPE_MISC
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ig4iic_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unable to setup irq: error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|enum_hook
operator|.
name|ich_func
operator|=
name|ig4iic_start
expr_stmt|;
name|sc
operator|->
name|enum_hook
operator|.
name|ich_arg
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
comment|/* 	 * We have to wait until interrupts are enabled. I2C read and write 	 * only works if the interrupts are available. 	 */
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|enum_hook
argument_list|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
name|done
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ig4iic_start
parameter_list|(
name|void
modifier|*
name|xdev
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|ig4iic_softc_t
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|xdev
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|enum_hook
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to attach child: error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ig4iic_detach
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
condition|)
block|{
name|error
operator|=
name|bus_generic_detach
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|iicbus
condition|)
name|device_delete_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|iicbus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr_handle
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|intr_res
argument_list|,
name|sc
operator|->
name|intr_handle
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|iicbus
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|intr_handle
operator|=
name|NULL
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_INTR_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_controller
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt Operation, see ig4_var.h for locking semantics.  */
end_comment

begin_function
specifier|static
name|void
name|ig4iic_intr
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|ig4iic_softc_t
modifier|*
name|sc
init|=
name|cookie
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/*	reg_write(sc, IG4_REG_INTR_MASK, IG4_INTR_STOP_DET);*/
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CLR_INTR
argument_list|)
expr_stmt|;
name|status
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_I2C_STA
argument_list|)
expr_stmt|;
while|while
condition|(
name|status
operator|&
name|IG4_STATUS_RX_NOTEMPTY
condition|)
block|{
name|sc
operator|->
name|rbuf
index|[
name|sc
operator|->
name|rnext
operator|&
name|IG4_RBUFMASK
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|rnext
expr_stmt|;
name|status
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_I2C_STA
argument_list|)
expr_stmt|;
block|}
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|REGDUMP
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
define|\
value|device_printf(sc->dev, "  %-23s %08x\n", #reg, reg_read(sc, reg))
end_define

begin_function
specifier|static
name|void
name|ig4iic_dump
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"ig4iic register dump:\n"
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CTL
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TAR_ADD
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_HCNT
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_LCNT
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_HCNT
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_LCNT
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_INTR_STAT
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_INTR_MASK
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_RAW_INTR_STAT
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_RX_TL
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TX_TL
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_I2C_EN
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_I2C_STA
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TXFLR
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_RXFLR
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SDA_HOLD
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TX_ABRT_SOURCE
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SLV_DATA_NACK
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DMA_CTRL
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DMA_TDLR
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DMA_RDLR
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SDA_SETUP
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_ENABLE_STATUS
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_COMP_PARAM1
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_COMP_VER
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_COMP_TYPE
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CLK_PARMS
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_RESETS
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_GENERAL
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SW_LTR_VALUE
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_AUTO_LTR_VALUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|REGDUMP
end_undef

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|iicbus
argument_list|,
name|ig4iic
argument_list|,
name|iicbus_driver
argument_list|,
name|iicbus_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

