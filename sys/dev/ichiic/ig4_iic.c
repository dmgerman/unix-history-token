begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2014 The DragonFly Project.  All rights reserved.  *  * This code is derived from software contributed to The DragonFly Project  * by Matthew Dillon<dillon@backplane.com> and was subsequently ported  * to FreeBSD by Michael Gmelin<freebsd@grem.de>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  * 3. Neither the name of The DragonFly Project nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific, prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE  * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Intel fourth generation mobile cpus integrated I2C device, smbus driver.  *  * See ig4_reg.h for datasheet reference and notes.  * See ig4_var.h for locking semantics.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/smbus/smbconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ichiic/ig4_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ichiic/ig4_var.h>
end_include

begin_define
define|#
directive|define
name|TRANS_NORMAL
value|1
end_define

begin_define
define|#
directive|define
name|TRANS_PCALL
value|2
end_define

begin_define
define|#
directive|define
name|TRANS_BLOCK
value|3
end_define

begin_function_decl
specifier|static
name|void
name|ig4iic_start
parameter_list|(
name|void
modifier|*
name|xdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ig4iic_intr
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ig4iic_dump
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|ig4_dump
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|ig4_dump
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ig4_dump
argument_list|,
literal|0
argument_list|,
literal|"Dump controller registers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Low-level inline support functions  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|reg_write
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|,
name|reg
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|bus_barrier
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|reg_read
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
block|{
name|uint32_t
name|value
decl_stmt|;
name|bus_barrier
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
name|value
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable or disable the controller and wait for the controller to acknowledge  * the state change.  */
end_comment

begin_function
specifier|static
name|int
name|set_controller
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|ctl
parameter_list|)
block|{
name|int
name|retry
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_I2C_EN
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|error
operator|=
name|SMB_ETIMEOUT
expr_stmt|;
for|for
control|(
name|retry
operator|=
literal|100
init|;
name|retry
operator|>
literal|0
condition|;
operator|--
name|retry
control|)
block|{
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_ENABLE_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|v
operator|^
name|ctl
operator|)
operator|&
name|IG4_I2C_ENABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cold
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
else|else
name|mtx_sleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|io_lock
argument_list|,
literal|0
argument_list|,
literal|"i2cslv"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait up to 25ms for the requested status using a 25uS polling loop.  */
end_comment

begin_function
specifier|static
name|int
name|wait_status
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|status
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|txlvl
init|=
operator|-
literal|1
decl_stmt|;
name|u_int
name|count_us
init|=
literal|0
decl_stmt|;
name|u_int
name|limit_us
init|=
literal|25000
decl_stmt|;
comment|/* 25ms */
name|error
operator|=
name|SMB_ETIMEOUT
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Check requested status 		 */
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_I2C_STA
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|status
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * When waiting for receive data break-out if the interrupt 		 * loaded data into the FIFO. 		 */
if|if
condition|(
name|status
operator|&
name|IG4_STATUS_RX_NOTEMPTY
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|rpos
operator|!=
name|sc
operator|->
name|rnext
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * When waiting for the transmit FIFO to become empty, 		 * reset the timeout if we see a change in the transmit 		 * FIFO level as progress is being made. 		 */
if|if
condition|(
name|status
operator|&
name|IG4_STATUS_TX_EMPTY
condition|)
block|{
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TXFLR
argument_list|)
operator|&
name|IG4_FIFOLVL_MASK
expr_stmt|;
if|if
condition|(
name|txlvl
operator|!=
name|v
condition|)
block|{
name|txlvl
operator|=
name|v
expr_stmt|;
name|count_us
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 * Stop if we've run out of time. 		 */
if|if
condition|(
name|count_us
operator|>=
name|limit_us
condition|)
break|break;
comment|/* 		 * When waiting for receive data let the interrupt do its 		 * work, otherwise poll with the lock held. 		 */
if|if
condition|(
name|status
operator|&
name|IG4_STATUS_RX_NOTEMPTY
condition|)
block|{
name|mtx_sleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|io_lock
argument_list|,
literal|0
argument_list|,
literal|"i2cwait"
argument_list|,
operator|(
name|hz
operator|+
literal|99
operator|)
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* sleep up to 10ms */
name|count_us
operator|+=
literal|10000
expr_stmt|;
block|}
else|else
block|{
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
name|count_us
operator|+=
literal|25
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read I2C data.  The data might have already been read by  * the interrupt code, otherwise it is sitting in the data  * register.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|data_read
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|c
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|rpos
operator|==
name|sc
operator|->
name|rnext
condition|)
block|{
name|c
operator|=
operator|(
name|uint8_t
operator|)
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|sc
operator|->
name|rbuf
index|[
name|sc
operator|->
name|rpos
operator|&
name|IG4_RBUFMASK
index|]
expr_stmt|;
operator|++
name|sc
operator|->
name|rpos
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the slave address.  The controller must be disabled when  * changing the address.  *  * This operation does not issue anything to the I2C bus but sets  * the target address for when the controller later issues a START.  */
end_comment

begin_function
specifier|static
name|void
name|set_slave_addr
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|slave
parameter_list|,
name|int
name|trans_op
parameter_list|)
block|{
name|uint32_t
name|tar
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|int
name|use_10bit
decl_stmt|;
name|use_10bit
operator|=
name|sc
operator|->
name|use_10bit
expr_stmt|;
if|if
condition|(
name|trans_op
operator|&
name|SMB_TRANS_7BIT
condition|)
name|use_10bit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|trans_op
operator|&
name|SMB_TRANS_10BIT
condition|)
name|use_10bit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|slave_valid
operator|&&
name|sc
operator|->
name|last_slave
operator|==
name|slave
operator|&&
name|sc
operator|->
name|use_10bit
operator|==
name|use_10bit
condition|)
block|{
return|return;
block|}
name|sc
operator|->
name|use_10bit
operator|=
name|use_10bit
expr_stmt|;
comment|/* 	 * Wait for TXFIFO to drain before disabling the controller. 	 * 	 * If a write message has not been completed it's really a 	 * programming error, but for now in that case issue an extra 	 * byte + STOP. 	 * 	 * If a read message has not been completed it's also a programming 	 * error, for now just ignore it. 	 */
name|wait_status
argument_list|(
name|sc
argument_list|,
name|IG4_STATUS_TX_NOTFULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|write_started
condition|)
block|{
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|,
name|IG4_DATA_STOP
argument_list|)
expr_stmt|;
name|sc
operator|->
name|write_started
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|read_started
condition|)
name|sc
operator|->
name|read_started
operator|=
literal|0
expr_stmt|;
name|wait_status
argument_list|(
name|sc
argument_list|,
name|IG4_STATUS_TX_EMPTY
argument_list|)
expr_stmt|;
name|set_controller
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CTL
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
name|IG4_CTL_10BIT
expr_stmt|;
name|ctl
operator||=
name|IG4_CTL_RESTARTEN
expr_stmt|;
name|tar
operator|=
name|slave
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|use_10bit
condition|)
block|{
name|tar
operator||=
name|IG4_TAR_10BIT
expr_stmt|;
name|ctl
operator||=
name|IG4_CTL_10BIT
expr_stmt|;
block|}
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TAR_ADD
argument_list|,
name|tar
argument_list|)
expr_stmt|;
name|set_controller
argument_list|(
name|sc
argument_list|,
name|IG4_I2C_ENABLE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|slave_valid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|last_slave
operator|=
name|slave
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Issue START with byte command, possible count, and a variable length  * read or write buffer, then possible turn-around read.  The read also  * has a possible count received.  *  * For SMBUS -  *  * Quick:		START+ADDR+RD/WR STOP  *  * Normal:		START+ADDR+WR CMD DATA..DATA STOP  *  *			START+ADDR+RD CMD  *			RESTART+ADDR RDATA..RDATA STOP  *			(can also be used for I2C transactions)  *  * Process Call:	START+ADDR+WR CMD DATAL DATAH  *			RESTART+ADDR+RD RDATAL RDATAH STOP  *  * Block:		START+ADDR+RD CMD  *			RESTART+ADDR+RD RCOUNT DATA... STOP  *  * 			START+ADDR+WR CMD  *			RESTART+ADDR+WR WCOUNT DATA... STOP  *  * For I2C - basically, no *COUNT fields, possibly no *CMD field.  If the  *	     sender needs to issue a 2-byte command it will incorporate it  *	     into the write buffer and also set NOCMD.  *  * Generally speaking, the START+ADDR / RESTART+ADDR is handled automatically  * by the controller at the beginning of a command sequence or on a data  * direction turn-around, and we only need to tell it when to issue the STOP.  */
end_comment

begin_function
specifier|static
name|int
name|smb_transaction
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|,
name|char
name|cmd
parameter_list|,
name|int
name|op
parameter_list|,
name|char
modifier|*
name|wbuf
parameter_list|,
name|int
name|wcount
parameter_list|,
name|char
modifier|*
name|rbuf
parameter_list|,
name|int
name|rcount
parameter_list|,
name|int
modifier|*
name|actualp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|uint32_t
name|last
decl_stmt|;
comment|/* 	 * Debugging - dump registers 	 */
if|if
condition|(
name|ig4_dump
condition|)
block|{
name|unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ig4_dump
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
condition|)
block|{
name|ig4_dump
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|unit
operator|)
expr_stmt|;
name|ig4iic_dump
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Issue START or RESTART with next data byte, clear any previous 	 * abort condition that may have been holding the txfifo in reset. 	 */
name|last
operator|=
name|IG4_DATA_RESTART
expr_stmt|;
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CLR_TX_ABORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|actualp
condition|)
operator|*
name|actualp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Issue command if not told otherwise (smbus). 	 */
if|if
condition|(
operator|(
name|op
operator|&
name|SMB_TRANS_NOCMD
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|wait_status
argument_list|(
name|sc
argument_list|,
name|IG4_STATUS_TX_NOTFULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|last
operator||=
operator|(
name|u_char
operator|)
name|cmd
expr_stmt|;
if|if
condition|(
name|wcount
operator|==
literal|0
operator|&&
name|rcount
operator|==
literal|0
operator|&&
operator|(
name|op
operator|&
name|SMB_TRANS_NOSTOP
operator|)
operator|==
literal|0
condition|)
name|last
operator||=
name|IG4_DATA_STOP
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Clean out any previously received data. 	 */
if|if
condition|(
name|sc
operator|->
name|rpos
operator|!=
name|sc
operator|->
name|rnext
operator|&&
operator|(
name|op
operator|&
name|SMB_TRANS_NOREPORT
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"discarding %d bytes of spurious data\n"
argument_list|,
name|sc
operator|->
name|rnext
operator|-
name|sc
operator|->
name|rpos
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|rpos
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rnext
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If writing and not told otherwise, issue the write count (smbus). 	 */
if|if
condition|(
name|wcount
operator|&&
operator|(
name|op
operator|&
name|SMB_TRANS_NOCNT
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|wait_status
argument_list|(
name|sc
argument_list|,
name|IG4_STATUS_TX_NOTFULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|last
operator||=
operator|(
name|u_char
operator|)
name|cmd
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Bulk write (i2c) 	 */
while|while
condition|(
name|wcount
condition|)
block|{
name|error
operator|=
name|wait_status
argument_list|(
name|sc
argument_list|,
name|IG4_STATUS_TX_NOTFULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|last
operator||=
operator|(
name|u_char
operator|)
operator|*
name|wbuf
expr_stmt|;
if|if
condition|(
name|wcount
operator|==
literal|1
operator|&&
name|rcount
operator|==
literal|0
operator|&&
operator|(
name|op
operator|&
name|SMB_TRANS_NOSTOP
operator|)
operator|==
literal|0
condition|)
name|last
operator||=
name|IG4_DATA_STOP
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|,
name|last
argument_list|)
expr_stmt|;
operator|--
name|wcount
expr_stmt|;
operator|++
name|wbuf
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Issue reads to xmit FIFO (strange, I know) to tell the controller 	 * to clock in data.  At the moment just issue one read ahead to 	 * pipeline the incoming data. 	 * 	 * NOTE: In the case of NOCMD and wcount == 0 we still issue a 	 *	 RESTART here, even if the data direction has not changed 	 *	 from the previous CHAINing call.  This we force the RESTART. 	 *	 (A new START is issued automatically by the controller in 	 *	 the other nominal cases such as a data direction change or 	 *	 a previous STOP was issued). 	 * 	 * If this will be the last byte read we must also issue the STOP 	 * at the end of the read. 	 */
if|if
condition|(
name|rcount
condition|)
block|{
name|last
operator|=
name|IG4_DATA_RESTART
operator||
name|IG4_DATA_COMMAND_RD
expr_stmt|;
if|if
condition|(
name|rcount
operator|==
literal|1
operator|&&
operator|(
name|op
operator|&
operator|(
name|SMB_TRANS_NOSTOP
operator||
name|SMB_TRANS_NOCNT
operator|)
operator|)
operator|==
name|SMB_TRANS_NOCNT
condition|)
block|{
name|last
operator||=
name|IG4_DATA_STOP
expr_stmt|;
block|}
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|last
operator|=
name|IG4_DATA_COMMAND_RD
expr_stmt|;
block|}
comment|/* 	 * Bulk read (i2c) and count field handling (smbus) 	 */
while|while
condition|(
name|rcount
condition|)
block|{
comment|/* 		 * Maintain a pipeline by queueing the allowance for the next 		 * read before waiting for the current read. 		 */
if|if
condition|(
name|rcount
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|op
operator|&
name|SMB_TRANS_NOCNT
condition|)
name|last
operator|=
operator|(
name|rcount
operator|==
literal|2
operator|)
condition|?
name|IG4_DATA_STOP
else|:
literal|0
expr_stmt|;
else|else
name|last
operator|=
literal|0
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|,
name|IG4_DATA_COMMAND_RD
operator||
name|last
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|wait_status
argument_list|(
name|sc
argument_list|,
name|IG4_STATUS_RX_NOTEMPTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
operator|(
name|op
operator|&
name|SMB_TRANS_NOREPORT
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"rx timeout addr 0x%02x\n"
argument_list|,
name|sc
operator|->
name|last_slave
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|last
operator|=
name|data_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SMB_TRANS_NOCNT
condition|)
block|{
operator|*
name|rbuf
operator|=
operator|(
name|u_char
operator|)
name|last
expr_stmt|;
operator|++
name|rbuf
expr_stmt|;
operator|--
name|rcount
expr_stmt|;
if|if
condition|(
name|actualp
condition|)
operator|++
operator|*
name|actualp
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Handle count field (smbus), which is not part of 			 * the rcount'ed buffer.  The first read data in a 			 * bulk transfer is the count. 			 * 			 * XXX if rcount is loaded as 0 how do I generate a 			 *     STOP now without issuing another RD or WR? 			 */
if|if
condition|(
name|rcount
operator|>
operator|(
name|u_char
operator|)
name|last
condition|)
name|rcount
operator|=
operator|(
name|u_char
operator|)
name|last
expr_stmt|;
name|op
operator||=
name|SMB_TRANS_NOCNT
expr_stmt|;
block|}
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|done
label|:
comment|/* XXX wait for xmit buffer to become empty */
name|last
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TX_ABRT_SOURCE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *				SMBUS API FUNCTIONS  *  * Called from ig4iic_pci_attach/detach()  */
end_comment

begin_function
name|int
name|ig4iic_attach
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_COMP_TYPE
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_COMP_PARAM1
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_GENERAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|IG4_GENERAL_SWMODE
operator|)
operator|==
literal|0
condition|)
block|{
name|v
operator||=
name|IG4_GENERAL_SWMODE
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_GENERAL
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_GENERAL
argument_list|)
expr_stmt|;
block|}
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SW_LTR_VALUE
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_AUTO_LTR_VALUE
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_COMP_VER
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|IG4_COMP_VER
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_HCNT
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_LCNT
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_HCNT
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_LCNT
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SDA_HOLD
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_HCNT
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_HCNT
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_LCNT
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_LCNT
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* 	 * Program based on a 25000 Hz clock.  This is a bit of a 	 * hack (obviously).  The defaults are 400 and 470 for standard 	 * and 60 and 130 for fast.  The defaults for standard fail 	 * utterly (presumably cause an abort) because the clock time 	 * is ~18.8ms by default.  This brings it down to ~4ms (for now). 	 */
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_HCNT
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_LCNT
argument_list|,
literal|125
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_HCNT
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_LCNT
argument_list|,
literal|125
argument_list|)
expr_stmt|;
comment|/* 	 * Use a threshold of 1 so we get interrupted on each character, 	 * allowing us to use mtx_sleep() in our poll code.  Not perfect 	 * but this is better than using DELAY() for receiving data. 	 * 	 * See ig4_var.h for details on interrupt handler synchronization. 	 */
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_RX_TL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CTL
argument_list|,
name|IG4_CTL_MASTER
operator||
name|IG4_CTL_SLAVE_DISABLE
operator||
name|IG4_CTL_RESTARTEN
operator||
name|IG4_CTL_SPEED_STD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|smb
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"smbus"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|smb
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"smbus driver not found\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * Don't do this, it blows up the PCI config 	 */
block|reg_write(sc, IG4_REG_RESETS, IG4_RESETS_ASSERT); 	reg_write(sc, IG4_REG_RESETS, IG4_RESETS_DEASSERT);
endif|#
directive|endif
comment|/* 	 * Interrupt on STOP detect or receive character ready 	 */
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_INTR_MASK
argument_list|,
name|IG4_INTR_STOP_DET
operator||
name|IG4_INTR_RX_FULL
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_controller
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"controller error during attach-1\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_controller
argument_list|(
name|sc
argument_list|,
name|IG4_I2C_ENABLE
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"controller error during attach-2\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|intr_res
argument_list|,
name|INTR_TYPE_MISC
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ig4iic_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unable to setup irq: error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|enum_hook
operator|.
name|ich_func
operator|=
name|ig4iic_start
expr_stmt|;
name|sc
operator|->
name|enum_hook
operator|.
name|ich_arg
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
comment|/* We have to wait until interrupts are enabled. I2C read and write 	 * only works if the interrupts are available. 	 */
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|enum_hook
argument_list|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
name|done
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ig4iic_start
parameter_list|(
name|void
modifier|*
name|xdev
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|ig4iic_softc_t
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|xdev
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|enum_hook
argument_list|)
expr_stmt|;
comment|/* Attach us to the smbus */
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to attach child: error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ig4iic_detach
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
condition|)
block|{
name|error
operator|=
name|bus_generic_detach
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|smb
condition|)
name|device_delete_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|smb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr_handle
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|intr_res
argument_list|,
name|sc
operator|->
name|intr_handle
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|smb
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|intr_handle
operator|=
name|NULL
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_INTR_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CLR_INTR
argument_list|)
expr_stmt|;
name|set_controller
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ig4iic_smb_callback
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|index
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|SMB_REQUEST_BUS
case|:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SMB_RELEASE_BUS
case|:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|SMB_EABORT
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Quick command.  i.e. START + cmd + R/W + STOP and no data.  It is  * unclear to me how I could implement this with the intel i2c controller  * because the controller sends STARTs and STOPs automatically with data.  */
end_comment

begin_function
name|int
name|ig4iic_smb_quick
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|int
name|how
parameter_list|)
block|{
return|return
operator|(
name|SMB_ENOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Incremental send byte without stop (?).  It is unclear why the slave  * address is specified if this presumably is used in combination with  * ig4iic_smb_quick().  *  * (Also, how would this work anyway?  Issue the last byte with writeb()?)  */
end_comment

begin_function
name|int
name|ig4iic_smb_sendb
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|ig4iic_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|cmd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|set_slave_addr
argument_list|(
name|sc
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|byte
expr_stmt|;
if|if
condition|(
name|wait_status
argument_list|(
name|sc
argument_list|,
name|IG4_STATUS_TX_NOTFULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|SMB_ETIMEOUT
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Incremental receive byte without stop (?).  It is unclear why the slave  * address is specified if this presumably is used in combination with  * ig4iic_smb_quick().  */
end_comment

begin_function
name|int
name|ig4iic_smb_recvb
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|char
modifier|*
name|byte
parameter_list|)
block|{
name|ig4iic_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|set_slave_addr
argument_list|(
name|sc
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_write
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|,
name|IG4_DATA_COMMAND_RD
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_status
argument_list|(
name|sc
argument_list|,
name|IG4_STATUS_RX_NOTEMPTY
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|byte
operator|=
name|data_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|byte
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|SMB_ETIMEOUT
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write command and single byte in transaction.  */
end_comment

begin_function
name|int
name|ig4iic_smb_writeb
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|char
name|cmd
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|ig4iic_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|set_slave_addr
argument_list|(
name|sc
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|smb_transaction
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|SMB_TRANS_NOCNT
argument_list|,
operator|&
name|byte
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write command and single word in transaction.  */
end_comment

begin_function
name|int
name|ig4iic_smb_writew
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|char
name|cmd
parameter_list|,
name|short
name|word
parameter_list|)
block|{
name|ig4iic_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|set_slave_addr
argument_list|(
name|sc
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|word
operator|&
literal|0xFF
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|word
operator|>>
literal|8
expr_stmt|;
name|error
operator|=
name|smb_transaction
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|SMB_TRANS_NOCNT
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * write command and read single byte in transaction.  */
end_comment

begin_function
name|int
name|ig4iic_smb_readb
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|char
name|cmd
parameter_list|,
name|char
modifier|*
name|byte
parameter_list|)
block|{
name|ig4iic_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|set_slave_addr
argument_list|(
name|sc
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|smb_transaction
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|SMB_TRANS_NOCNT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|byte
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * write command and read word in transaction.  */
end_comment

begin_function
name|int
name|ig4iic_smb_readw
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|char
name|cmd
parameter_list|,
name|short
modifier|*
name|word
parameter_list|)
block|{
name|ig4iic_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|set_slave_addr
argument_list|(
name|sc
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|smb_transaction
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|SMB_TRANS_NOCNT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|word
operator|=
operator|(
name|u_char
operator|)
name|buf
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|u_char
operator|)
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * write command and word and read word in transaction  */
end_comment

begin_function
name|int
name|ig4iic_smb_pcall
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|char
name|cmd
parameter_list|,
name|short
name|sdata
parameter_list|,
name|short
modifier|*
name|rdata
parameter_list|)
block|{
name|ig4iic_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|char
name|rbuf
index|[
literal|2
index|]
decl_stmt|;
name|char
name|wbuf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|set_slave_addr
argument_list|(
name|sc
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wbuf
index|[
literal|0
index|]
operator|=
name|sdata
operator|&
literal|0xFF
expr_stmt|;
name|wbuf
index|[
literal|1
index|]
operator|=
name|sdata
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|smb_transaction
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|SMB_TRANS_NOCNT
argument_list|,
name|wbuf
argument_list|,
literal|2
argument_list|,
name|rbuf
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|rdata
operator|=
operator|(
name|u_char
operator|)
name|rbuf
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|u_char
operator|)
name|rbuf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ig4iic_smb_bwrite
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|char
name|cmd
parameter_list|,
name|u_char
name|wcount
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|ig4iic_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|set_slave_addr
argument_list|(
name|sc
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|smb_transaction
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|wcount
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ig4iic_smb_bread
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|char
name|cmd
parameter_list|,
name|u_char
modifier|*
name|countp_char
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|ig4iic_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|rcount
init|=
operator|*
name|countp_char
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|set_slave_addr
argument_list|(
name|sc
argument_list|,
name|slave
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|smb_transaction
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|rcount
argument_list|,
operator|&
name|rcount
argument_list|)
expr_stmt|;
operator|*
name|countp_char
operator|=
name|rcount
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ig4iic_smb_trans
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|char
name|cmd
parameter_list|,
name|int
name|op
parameter_list|,
name|char
modifier|*
name|wbuf
parameter_list|,
name|int
name|wcount
parameter_list|,
name|char
modifier|*
name|rbuf
parameter_list|,
name|int
name|rcount
parameter_list|,
name|int
modifier|*
name|actualp
parameter_list|)
block|{
name|ig4iic_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|set_slave_addr
argument_list|(
name|sc
argument_list|,
name|slave
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|error
operator|=
name|smb_transaction
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|op
argument_list|,
name|wbuf
argument_list|,
name|wcount
argument_list|,
name|rbuf
argument_list|,
name|rcount
argument_list|,
name|actualp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|call_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt Operation, see ig4_var.h for locking semantics.  */
end_comment

begin_function
specifier|static
name|void
name|ig4iic_intr
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|ig4iic_softc_t
modifier|*
name|sc
init|=
name|cookie
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/*	reg_write(sc, IG4_REG_INTR_MASK, IG4_INTR_STOP_DET);*/
name|status
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_I2C_STA
argument_list|)
expr_stmt|;
while|while
condition|(
name|status
operator|&
name|IG4_STATUS_RX_NOTEMPTY
condition|)
block|{
name|sc
operator|->
name|rbuf
index|[
name|sc
operator|->
name|rnext
operator|&
name|IG4_RBUFMASK
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DATA_CMD
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|rnext
expr_stmt|;
name|status
operator|=
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_I2C_STA
argument_list|)
expr_stmt|;
block|}
name|reg_read
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CLR_INTR
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|REGDUMP
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
define|\
value|device_printf(sc->dev, "  %-23s %08x\n", #reg, reg_read(sc, reg))
end_define

begin_function
specifier|static
name|void
name|ig4iic_dump
parameter_list|(
name|ig4iic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"ig4iic register dump:\n"
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CTL
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TAR_ADD
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_HCNT
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SS_SCL_LCNT
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_HCNT
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_FS_SCL_LCNT
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_INTR_STAT
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_INTR_MASK
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_RAW_INTR_STAT
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_RX_TL
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TX_TL
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_I2C_EN
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_I2C_STA
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TXFLR
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_RXFLR
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SDA_HOLD
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_TX_ABRT_SOURCE
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SLV_DATA_NACK
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DMA_CTRL
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DMA_TDLR
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_DMA_RDLR
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SDA_SETUP
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_ENABLE_STATUS
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_COMP_PARAM1
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_COMP_VER
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_COMP_TYPE
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_CLK_PARMS
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_RESETS
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_GENERAL
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_SW_LTR_VALUE
argument_list|)
expr_stmt|;
name|REGDUMP
argument_list|(
name|sc
argument_list|,
name|IG4_REG_AUTO_LTR_VALUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|REGDUMP
end_undef

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|smbus
argument_list|,
name|ig4iic
argument_list|,
name|smbus_driver
argument_list|,
name|smbus_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

