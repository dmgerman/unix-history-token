begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"opt_em.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
end_if

begin_include
include|#
directive|include
file|<sys/buf_ring.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<dev/led/led.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|"e1000_api.h"
end_include

begin_include
include|#
directive|include
file|"e1000_82571.h"
end_include

begin_include
include|#
directive|include
file|"if_em.h"
end_include

begin_comment
comment|/*********************************************************************  *  Driver version:  *********************************************************************/
end_comment

begin_decl_stmt
name|char
name|em_driver_version
index|[]
init|=
literal|"7.6.1-k"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  PCI Device ID Table  *  *  Used by probe to select devices to load on  *  Last field stores an index into e1000_strings  *  Last entry must be all 0s  *  *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|em_vendor_info_t
name|em_vendor_info_array
index|[]
init|=
block|{
comment|/* Intel(R) PRO/1000 Network Connection */
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_FIBER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_SERDES
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_SERDES_DUAL
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_SERDES_QUAD
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_QUAD_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_QUAD_COPPER_LP
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_QUAD_FIBER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571PT_QUAD_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82572EI_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82572EI_FIBER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82572EI_SERDES
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82572EI
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82573E
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82573E_IAMT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82573L
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82583V
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_80003ES2LAN_COPPER_SPT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_80003ES2LAN_SERDES_SPT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_80003ES2LAN_COPPER_DPT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_80003ES2LAN_SERDES_DPT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_IGP_M_AMT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_IGP_AMT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_IGP_C
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_IFE
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_IFE_GT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_IFE_G
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_IGP_M
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_82567V_3
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IGP_M_AMT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IGP_AMT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IGP_C
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IGP_M
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IGP_M_V
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IFE
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IFE_GT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IFE_G
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_BM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82574L
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82574LA
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH10_R_BM_LM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH10_R_BM_LF
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH10_R_BM_V
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH10_D_BM_LM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH10_D_BM_LF
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH10_D_BM_V
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_M_HV_LM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_M_HV_LC
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_D_HV_DM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_D_HV_DC
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH2_LV_LM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH2_LV_V
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_LPT_I217_LM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_LPT_I217_V
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_LPTLP_I218_LM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_LPTLP_I218_V
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_I218_LM2
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_I218_V2
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_I218_LM3
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_I218_V3
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_SPT_I219_LM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_SPT_I219_V
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_SPT_I219_LM2
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_SPT_I219_V2
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_LBG_I219_LM3
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_SPT_I219_LM4
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_SPT_I219_V4
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_SPT_I219_LM5
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_SPT_I219_V5
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
comment|/* required last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Table of branding strings for all supported NICs.  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|em_strings
index|[]
init|=
block|{
literal|"Intel(R) PRO/1000 Network Connection"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|em_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
end_ifdef

begin_function_decl
specifier|static
name|int
name|em_mq_start
parameter_list|(
name|if_t
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_mq_start_locked
parameter_list|(
name|if_t
parameter_list|,
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_qflush
parameter_list|(
name|if_t
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|em_start
parameter_list|(
name|if_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_start_locked
parameter_list|(
name|if_t
parameter_list|,
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|em_ioctl
parameter_list|(
name|if_t
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|em_get_counter
parameter_list|(
name|if_t
parameter_list|,
name|ift_counter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_stop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_media_status
parameter_list|(
name|if_t
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_media_change
parameter_list|(
name|if_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_allocate_legacy
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_allocate_msix
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_allocate_queues
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_setup_msix
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_local_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_reset
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_setup_interface
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_flush_desc_rings
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_setup_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_initialize_transmit_unit
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_allocate_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_free_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_free_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_setup_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_allocate_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_initialize_receive_unit
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_free_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_free_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_add_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_txeof
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|em_rxeof
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
end_ifndef

begin_function_decl
specifier|static
name|int
name|em_fixup_rx
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|em_setup_rxdesc
parameter_list|(
name|union
name|e1000_rx_desc_extended
modifier|*
parameter_list|,
specifier|const
name|struct
name|em_rxbuffer
modifier|*
name|rxbuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_receive_checksum
parameter_list|(
name|uint32_t
name|status
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_transmit_checksum_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_tso_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|tcphdr
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_disable_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_update_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_refresh_mbufs
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_register_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|if_t
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_unregister_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|if_t
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_setup_vlan_hw_support
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_xmit
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_dma_malloc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|struct
name|em_dma_alloc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_dma_free
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|em_dma_alloc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_sysctl_nvm_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_print_nvm_info
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_sysctl_debug_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_print_debug_info
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_is_valid_ether_addr
parameter_list|(
name|u8
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_sysctl_int_delay
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_add_int_delay_sysctl
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|em_int_delay_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Management and WOL Support */
end_comment

begin_function_decl
specifier|static
name|void
name|em_init_manageability
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_release_manageability
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_get_hw_control
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_release_hw_control
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_get_wakeup
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_enable_wakeup
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_enable_phy_wakeup
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_led_func
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_disable_aspm
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_irq_fast
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* MSIX handlers */
end_comment

begin_function_decl
specifier|static
name|void
name|em_msix_tx
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_msix_rx
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_msix_link
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_handle_tx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_handle_rx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_handle_link
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
end_ifdef

begin_function_decl
specifier|static
name|void
name|em_enable_vectors_82574
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|em_set_sysctl_value
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_set_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_sysctl_eee
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|em_rx_discard
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_decl_stmt
specifier|static
name|poll_handler_t
name|em_poll
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* POLLING */
end_comment

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|em_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|em_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|em_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|em_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|em_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|em_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|em_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|em_driver
init|=
block|{
literal|"em"
block|,
name|em_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|adapter
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|em_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|em
argument_list|,
name|pci
argument_list|,
name|em_driver
argument_list|,
name|em_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|em
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|em
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|em
argument_list|,
name|netmap
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_comment
comment|/*********************************************************************  *  Tunable default values.  *********************************************************************/
end_comment

begin_define
define|#
directive|define
name|EM_TICKS_TO_USECS
parameter_list|(
name|ticks
parameter_list|)
value|((1024 * (ticks) + 500) / 1000)
end_define

begin_define
define|#
directive|define
name|EM_USECS_TO_TICKS
parameter_list|(
name|usecs
parameter_list|)
value|((1000 * (usecs) + 512) / 1024)
end_define

begin_define
define|#
directive|define
name|M_TSO_LEN
value|66
end_define

begin_define
define|#
directive|define
name|MAX_INTS_PER_SEC
value|8000
end_define

begin_define
define|#
directive|define
name|DEFAULT_ITR
value|(1000000000/(MAX_INTS_PER_SEC * 256))
end_define

begin_comment
comment|/* Allow common code without TSO */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CSUM_TSO
end_ifndef

begin_define
define|#
directive|define
name|CSUM_TSO
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TSO_WORKAROUND
value|4
end_define

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|em
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"EM driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|em_disable_crc_stripping
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|disable_crc_stripping
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_disable_crc_stripping
argument_list|,
literal|0
argument_list|,
literal|"Disable CRC Stripping"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|em_tx_int_delay_dflt
init|=
name|EM_TICKS_TO_USECS
argument_list|(
name|EM_TIDV
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_rx_int_delay_dflt
init|=
name|EM_TICKS_TO_USECS
argument_list|(
name|EM_RDTR
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_int_delay
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_tx_int_delay_dflt
argument_list|,
literal|0
argument_list|,
literal|"Default transmit interrupt delay in usecs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_int_delay
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_rx_int_delay_dflt
argument_list|,
literal|0
argument_list|,
literal|"Default receive interrupt delay in usecs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|em_tx_abs_int_delay_dflt
init|=
name|EM_TICKS_TO_USECS
argument_list|(
name|EM_TADV
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_rx_abs_int_delay_dflt
init|=
name|EM_TICKS_TO_USECS
argument_list|(
name|EM_RADV
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_abs_int_delay
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_tx_abs_int_delay_dflt
argument_list|,
literal|0
argument_list|,
literal|"Default transmit interrupt delay limit in usecs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_abs_int_delay
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_rx_abs_int_delay_dflt
argument_list|,
literal|0
argument_list|,
literal|"Default receive interrupt delay limit in usecs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|em_rxd
init|=
name|EM_DEFAULT_RXD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_txd
init|=
name|EM_DEFAULT_TXD
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|rxd
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_rxd
argument_list|,
literal|0
argument_list|,
literal|"Number of receive descriptors per queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|txd
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_txd
argument_list|,
literal|0
argument_list|,
literal|"Number of transmit descriptors per queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|em_smart_pwr_down
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|smart_pwr_down
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_smart_pwr_down
argument_list|,
literal|0
argument_list|,
literal|"Set to true to leave smart power down enabled on newer adapters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Controls whether promiscuous also shows bad packets */
end_comment

begin_decl_stmt
specifier|static
name|int
name|em_debug_sbp
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|sbp
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_debug_sbp
argument_list|,
literal|0
argument_list|,
literal|"Show bad packets in promiscuous mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|em_enable_msix
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_msix
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_enable_msix
argument_list|,
literal|0
argument_list|,
literal|"Enable MSI-X interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|em_num_queues
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|num_queues
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_num_queues
argument_list|,
literal|0
argument_list|,
literal|"82574 only: Number of queues to configure, 0 indicates autoconfigure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Global variable to store last used CPU when binding queues ** to CPUs in igb_allocate_msix.  Starts at CPU_FIRST and increments when a ** queue is bound to a cpu. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|em_last_bind_cpu
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many packets rxeof tries to clean at a time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|em_rx_process_limit
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_process_limit
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_rx_process_limit
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of received packets to process "
literal|"at a time, -1 means unlimited"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Energy efficient ethernet - default to OFF */
end_comment

begin_decl_stmt
specifier|static
name|int
name|eee_setting
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|eee_setting
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|eee_setting
argument_list|,
literal|0
argument_list|,
literal|"Enable Energy Efficient Ethernet"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Global used in WOL setup with multiport cards */
end_comment

begin_decl_stmt
specifier|static
name|int
name|global_quad_port_a
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_comment
comment|/* see ixgbe.c for details */
end_comment

begin_include
include|#
directive|include
file|<dev/netmap/if_em_netmap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_comment
comment|/*********************************************************************  *  Device identification routine  *  *  em_probe determines if the driver should be loaded on  *  adapter based on PCI vendor/device id of the adapter.  *  *  return BUS_PROBE_DEFAULT on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
name|adapter_name
index|[
literal|60
index|]
decl_stmt|;
name|uint16_t
name|pci_vendor_id
init|=
literal|0
decl_stmt|;
name|uint16_t
name|pci_device_id
init|=
literal|0
decl_stmt|;
name|uint16_t
name|pci_subvendor_id
init|=
literal|0
decl_stmt|;
name|uint16_t
name|pci_subdevice_id
init|=
literal|0
decl_stmt|;
name|em_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_probe: begin"
argument_list|)
expr_stmt|;
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_vendor_id
operator|!=
name|EM_VENDOR_ID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|em_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subvendor_id
operator|==
name|PCI_ANY_ID
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subdevice_id
operator|==
name|PCI_ANY_ID
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|adapter_name
argument_list|,
literal|"%s %s"
argument_list|,
name|em_strings
index|[
name|ent
operator|->
name|index
index|]
argument_list|,
name|em_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|adapter_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device initialization routine  *  *  The attach entry point is called when the driver is being loaded.  *  This routine identifies the type of hardware, allocates all resources  *  and initializes the hardware.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_attach: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"em"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Disabled by device hint\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|dev
operator|=
name|adapter
operator|->
name|osdep
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|hw
operator|=
operator|&
name|adapter
operator|->
name|hw
expr_stmt|;
name|EM_CORE_LOCK_INIT
argument_list|(
name|adapter
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SYSCTL stuff */
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nvm"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|em_sysctl_nvm_info
argument_list|,
literal|"I"
argument_list|,
literal|"NVM Information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|em_sysctl_debug_info
argument_list|,
literal|"I"
argument_list|,
literal|"Debug Information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|em_set_flowcntl
argument_list|,
literal|"I"
argument_list|,
literal|"Flow Control"
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Determine hardware and mac info */
name|em_identify_hardware
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Setup PCI resources */
if|if
condition|(
name|em_allocate_pci_resources
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Allocation of PCI resources failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_pci
goto|;
block|}
comment|/* 	** For ICH8 and family we need to 	** map the flash memory, and this 	** must happen after the MAC is  	** identified 	*/
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich9lan
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich10lan
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pchlan
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch_lpt
operator|)
condition|)
block|{
name|int
name|rid
init|=
name|EM_BAR_TYPE_FLASH
decl_stmt|;
name|adapter
operator|->
name|flash
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|flash
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Mapping of Flash failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_pci
goto|;
block|}
comment|/* This is used in the shared code */
name|hw
operator|->
name|flash_address
operator|=
operator|(
name|u8
operator|*
operator|)
name|adapter
operator|->
name|flash
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|flash_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|flash
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|flash_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|flash
argument_list|)
expr_stmt|;
block|}
comment|/* 	** In the new SPT device flash is not  a 	** separate BAR, rather it is also in BAR0, 	** so use the same tag and an offset handle for the 	** FLASH read/write macros in the shared code. 	*/
elseif|else
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch_spt
condition|)
block|{
name|adapter
operator|->
name|osdep
operator|.
name|flash_bus_space_tag
operator|=
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|flash_bus_space_handle
operator|=
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|+
name|E1000_FLASH_BASE_ADDR
expr_stmt|;
block|}
comment|/* Do Shared Code initialization */
name|error
operator|=
name|e1000_setup_init_funcs
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Setup of Shared code failed, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_pci
goto|;
block|}
comment|/* 	 * Setup MSI/X or MSI if PCI Express 	 */
name|adapter
operator|->
name|msix
operator|=
name|em_setup_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|e1000_get_bus_info
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set up some sysctls for the tunable interrupt delays */
name|em_add_int_delay_sysctl
argument_list|(
name|adapter
argument_list|,
literal|"rx_int_delay"
argument_list|,
literal|"receive interrupt delay in usecs"
argument_list|,
operator|&
name|adapter
operator|->
name|rx_int_delay
argument_list|,
name|E1000_REGISTER
argument_list|(
name|hw
argument_list|,
name|E1000_RDTR
argument_list|)
argument_list|,
name|em_rx_int_delay_dflt
argument_list|)
expr_stmt|;
name|em_add_int_delay_sysctl
argument_list|(
name|adapter
argument_list|,
literal|"tx_int_delay"
argument_list|,
literal|"transmit interrupt delay in usecs"
argument_list|,
operator|&
name|adapter
operator|->
name|tx_int_delay
argument_list|,
name|E1000_REGISTER
argument_list|(
name|hw
argument_list|,
name|E1000_TIDV
argument_list|)
argument_list|,
name|em_tx_int_delay_dflt
argument_list|)
expr_stmt|;
name|em_add_int_delay_sysctl
argument_list|(
name|adapter
argument_list|,
literal|"rx_abs_int_delay"
argument_list|,
literal|"receive interrupt delay limit in usecs"
argument_list|,
operator|&
name|adapter
operator|->
name|rx_abs_int_delay
argument_list|,
name|E1000_REGISTER
argument_list|(
name|hw
argument_list|,
name|E1000_RADV
argument_list|)
argument_list|,
name|em_rx_abs_int_delay_dflt
argument_list|)
expr_stmt|;
name|em_add_int_delay_sysctl
argument_list|(
name|adapter
argument_list|,
literal|"tx_abs_int_delay"
argument_list|,
literal|"transmit interrupt delay limit in usecs"
argument_list|,
operator|&
name|adapter
operator|->
name|tx_abs_int_delay
argument_list|,
name|E1000_REGISTER
argument_list|(
name|hw
argument_list|,
name|E1000_TADV
argument_list|)
argument_list|,
name|em_tx_abs_int_delay_dflt
argument_list|)
expr_stmt|;
name|em_add_int_delay_sysctl
argument_list|(
name|adapter
argument_list|,
literal|"itr"
argument_list|,
literal|"interrupt delay limit in usecs/4"
argument_list|,
operator|&
name|adapter
operator|->
name|tx_itr
argument_list|,
name|E1000_REGISTER
argument_list|(
name|hw
argument_list|,
name|E1000_ITR
argument_list|)
argument_list|,
name|DEFAULT_ITR
argument_list|)
expr_stmt|;
comment|/* Sysctl for limiting the amount of work done in the taskqueue */
name|em_set_sysctl_value
argument_list|(
name|adapter
argument_list|,
literal|"rx_processing_limit"
argument_list|,
literal|"max number of rx packets to process"
argument_list|,
operator|&
name|adapter
operator|->
name|rx_process_limit
argument_list|,
name|em_rx_process_limit
argument_list|)
expr_stmt|;
comment|/* 	 * Validate number of transmit and receive descriptors. It 	 * must not exceed hardware maximum, and must be multiple 	 * of E1000_DBA_ALIGN. 	 */
if|if
condition|(
operator|(
operator|(
name|em_txd
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
operator|)
operator|%
name|EM_DBA_ALIGN
operator|)
operator|!=
literal|0
operator|||
operator|(
name|em_txd
operator|>
name|EM_MAX_TXD
operator|)
operator|||
operator|(
name|em_txd
operator|<
name|EM_MIN_TXD
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using %d TX descriptors instead of %d!\n"
argument_list|,
name|EM_DEFAULT_TXD
argument_list|,
name|em_txd
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_tx_desc
operator|=
name|EM_DEFAULT_TXD
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|num_tx_desc
operator|=
name|em_txd
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|em_rxd
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|e1000_rx_desc_extended
argument_list|)
operator|)
operator|%
name|EM_DBA_ALIGN
operator|)
operator|!=
literal|0
operator|||
operator|(
name|em_rxd
operator|>
name|EM_MAX_RXD
operator|)
operator|||
operator|(
name|em_rxd
operator|<
name|EM_MIN_RXD
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using %d RX descriptors instead of %d!\n"
argument_list|,
name|EM_DEFAULT_RXD
argument_list|,
name|em_rxd
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_rx_desc
operator|=
name|EM_DEFAULT_RXD
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|num_rx_desc
operator|=
name|em_rxd
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|autoneg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|autoneg_wait_to_complete
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|=
name|AUTONEG_ADV_DEFAULT
expr_stmt|;
comment|/* Copper options */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|mdix
operator|=
name|AUTO_ALL_MODES
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|disable_polarity_correction
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ms_type
operator|=
name|EM_MASTER_SLAVE
expr_stmt|;
block|}
comment|/* 	 * Set the frame limits assuming 	 * standard ethernet sized frames. 	 */
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
operator|=
name|ETHERMTU
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHERNET_FCS_SIZE
expr_stmt|;
comment|/* 	 * This controls when hardware reports transmit completion 	 * status. 	 */
name|hw
operator|->
name|mac
operator|.
name|report_tx_early
operator|=
literal|1
expr_stmt|;
comment|/*  	** Get queue/ring memory 	*/
if|if
condition|(
name|em_allocate_queues
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_pci
goto|;
block|}
comment|/* Allocate multicast array memory. */
name|adapter
operator|->
name|mta
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
operator|*
name|ETH_ADDR_LEN
operator|*
name|MAX_NUM_MULTICAST_ADDRESSES
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|mta
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can not allocate multicast setup array\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Check SOL/IDER usage */
if|if
condition|(
name|e1000_check_reset_block
argument_list|(
name|hw
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PHY reset is blocked"
literal|" due to SOL/IDER session.\n"
argument_list|)
expr_stmt|;
comment|/* Sysctl for setting Energy Efficient Ethernet */
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|eee_disable
operator|=
name|eee_setting
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"eee_control"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|em_sysctl_eee
argument_list|,
literal|"I"
argument_list|,
literal|"Disable Energy Efficient Ethernet"
argument_list|)
expr_stmt|;
comment|/* 	** Start from a known state, this is 	** important in reading the nvm and 	** mac from that. 	*/
name|e1000_reset_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Make sure we have a good EEPROM before we read from it */
if|if
condition|(
name|e1000_validate_nvm_checksum
argument_list|(
name|hw
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 		** Some PCI-E parts fail the first check due to 		** the link being in sleep state, call it again, 		** if it fails a second time its a real issue. 		*/
if|if
condition|(
name|e1000_validate_nvm_checksum
argument_list|(
name|hw
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The EEPROM Checksum Is Not Valid\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
block|}
comment|/* Copy the permanent MAC address out of the EEPROM */
if|if
condition|(
name|e1000_read_mac_addr
argument_list|(
name|hw
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"EEPROM read error while reading MAC"
literal|" address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
if|if
condition|(
operator|!
name|em_is_valid_ether_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid MAC address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Disable ULP support */
name|e1000_disable_ulp_lpt_lp
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	**  Do interrupt configuration 	*/
if|if
condition|(
name|adapter
operator|->
name|msix
operator|>
literal|1
condition|)
comment|/* Do MSIX */
name|error
operator|=
name|em_allocate_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
comment|/* MSI or Legacy */
name|error
operator|=
name|em_allocate_legacy
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_late
goto|;
comment|/* 	 * Get Wake-on-Lan and Management info for later use 	 */
name|em_get_wakeup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Setup OS specific network interface */
if|if
condition|(
name|em_setup_interface
argument_list|(
name|dev
argument_list|,
name|adapter
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err_late
goto|;
name|em_reset
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Initialize statistics */
name|em_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|get_link_status
operator|=
literal|1
expr_stmt|;
name|em_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Register for VLAN events */
name|adapter
operator|->
name|vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|em_register_vlan
argument_list|,
name|adapter
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|em_unregister_vlan
argument_list|,
name|adapter
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|em_add_hw_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Non-AMT based hardware can now take control from firmware */
if|if
condition|(
name|adapter
operator|->
name|has_manage
operator|&&
operator|!
name|adapter
operator|->
name|has_amt
condition|)
name|em_get_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is not active */
name|if_setdrvflagbits
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|led_dev
operator|=
name|led_create
argument_list|(
name|em_led_func
argument_list|,
name|adapter
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|em_netmap_attach
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|INIT_DEBUGOUT
argument_list|(
literal|"em_attach: end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_late
label|:
name|em_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|!=
operator|(
name|void
operator|*
operator|)
name|NULL
condition|)
name|if_free
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|err_pci
label|:
name|em_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|mta
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|EM_CORE_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device removal routine  *  *  The detach entry point is called when the driver is being removed.  *  This routine stops the adapter and deallocates all the resources  *  that were allocated for driver operation.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_detach: begin"
argument_list|)
expr_stmt|;
comment|/* Make sure VLANS are not using driver */
if|if
condition|(
name|if_vlantrunkinuse
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Vlan in use, detach first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_POLLING
condition|)
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|adapter
operator|->
name|led_dev
operator|!=
name|NULL
condition|)
name|led_destroy
argument_list|(
name|adapter
operator|->
name|led_dev
argument_list|)
expr_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|in_detach
operator|=
literal|1
expr_stmt|;
name|em_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|e1000_phy_hw_reset
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|em_release_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Unregister VLAN events */
if|if
condition|(
name|adapter
operator|->
name|vlan_attach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|adapter
operator|->
name|vlan_attach
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|vlan_detach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|adapter
operator|->
name|vlan_detach
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|netmap_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|em_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|em_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|mta
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Shutdown entry point  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
name|em_suspend
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Suspend/resume device methods.  */
end_comment

begin_function
specifier|static
name|int
name|em_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_release_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_enable_wakeup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
condition|)
name|e1000_resume_workarounds_pchlan
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_init_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
name|adapter
operator|->
name|link_active
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|EM_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|em_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|if_sendq_empty
argument_list|(
name|ifp
argument_list|)
condition|)
name|em_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EM_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
block|}
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|EM_MULTIQUEUE
end_ifndef

begin_function
specifier|static
name|void
name|em_start_locked
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|EM_TX_LOCK_ASSERT
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
condition|)
return|return;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
return|return;
while|while
condition|(
operator|!
name|if_sendq_empty
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
comment|/* Call cleanup if number of TX descriptors low */
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<=
name|EM_TX_CLEANUP_THRESHOLD
condition|)
name|em_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<
name|EM_MAX_SCATTER
condition|)
block|{
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|m_head
operator|=
name|if_dequeue
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 *  Encapsulation can modify our pointer, and or make it 		 *  NULL on failure.  In that event, we can't requeue. 		 */
if|if
condition|(
name|em_xmit
argument_list|(
name|txr
argument_list|,
operator|&
name|m_head
argument_list|)
condition|)
block|{
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
name|if_sendq_prepend
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Mark the queue as having work */
if|if
condition|(
name|txr
operator|->
name|busy
operator|==
name|EM_TX_IDLE
condition|)
name|txr
operator|->
name|busy
operator|=
name|EM_TX_BUSY
expr_stmt|;
comment|/* Send a copy of the frame to the BPF listener */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|em_start
parameter_list|(
name|if_t
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|EM_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|em_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* EM_MULTIQUEUE */
end_comment

begin_comment
comment|/*********************************************************************  *  Multiqueue Transmit routines   *  *  em_mq_start is called by the stack to initiate a transmit.  *  however, if busy the driver can queue the request rather  *  than do an immediate send. It is this that is an advantage  *  in this driver, rather than also having multiple tx queues.  **********************************************************************/
end_comment

begin_comment
comment|/* ** Multiqueue capable stack interface */
end_comment

begin_function
specifier|static
name|int
name|em_mq_start
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
name|i
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
else|else
name|i
operator|=
name|curcpu
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|EM_TX_TRYLOCK
argument_list|(
name|txr
argument_list|)
condition|)
block|{
name|em_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
else|else
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|tq
argument_list|,
operator|&
name|txr
operator|->
name|tx_task
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_mq_start_locked
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|enq
init|=
literal|0
decl_stmt|;
name|EM_TX_LOCK_ASSERT
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|)
operator|||
name|adapter
operator|->
name|link_active
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Process the queue */
while|while
condition|(
operator|(
name|next
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|em_xmit
argument_list|(
name|txr
argument_list|,
operator|&
name|next
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
comment|/* It was freed, move forward */
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  				 * Still have one left, it may not be 				 * the same since the transmit function 				 * may have changed it. 				 */
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
expr_stmt|;
name|enq
operator|++
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OBYTES
argument_list|,
name|next
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OMCASTS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Mark the queue as having work */
if|if
condition|(
operator|(
name|enq
operator|>
literal|0
operator|)
operator|&&
operator|(
name|txr
operator|->
name|busy
operator|==
name|EM_TX_IDLE
operator|)
condition|)
name|txr
operator|->
name|busy
operator|=
name|EM_TX_BUSY
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<
name|EM_MAX_SCATTER
condition|)
name|em_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<
name|EM_MAX_SCATTER
condition|)
block|{
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Flush all ring buffers */
end_comment

begin_function
specifier|static
name|void
name|em_qflush
parameter_list|(
name|if_t
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|EM_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txr
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EM_MULTIQUEUE */
end_comment

begin_comment
comment|/*********************************************************************  *  Ioctl entry point  *  *  em_ioctl is called when the user wants to configure the  *  interface.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_ioctl
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
endif|#
directive|endif
name|bool
name|avoid_reset
init|=
name|FALSE
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|in_detach
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* 		** Calling init results in link renegotiation, 		** so we avoid doing it when possible. 		*/
if|if
condition|(
name|avoid_reset
condition|)
block|{
name|if_setflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_UP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|em_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|!
operator|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_NOARP
operator|)
condition|)
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
block|{
name|int
name|max_frame_size
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
case|case
name|e1000_ich9lan
case|:
case|case
name|e1000_ich10lan
case|:
case|case
name|e1000_pch2lan
case|:
case|case
name|e1000_pch_lpt
case|:
case|case
name|e1000_pch_spt
case|:
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
case|case
name|e1000_80003es2lan
case|:
comment|/* 9K Jumbo Frame size */
name|max_frame_size
operator|=
literal|9234
expr_stmt|;
break|break;
case|case
name|e1000_pchlan
case|:
name|max_frame_size
operator|=
literal|4096
expr_stmt|;
break|break;
comment|/* Adapters that do not support jumbo frames */
case|case
name|e1000_ich8lan
case|:
name|max_frame_size
operator|=
name|ETHER_MAX_LEN
expr_stmt|;
break|break;
default|default:
name|max_frame_size
operator|=
name|MAX_JUMBO_FRAME_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|max_frame_size
operator|-
name|ETHER_HDR_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|if_setmtu
argument_list|(
name|ifp
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
operator|=
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCSIFFLAGS
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd:\ 		    SIOCSIFFLAGS (Set Interface Flags)"
argument_list|)
expr_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
if|if
condition|(
operator|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|^
name|adapter
operator|->
name|if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
name|em_disable_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_set_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
name|em_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|if_flags
operator|=
name|if_getflags
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOC(ADD|DEL)MULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
operator|!
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_POLLING
operator|)
condition|)
endif|#
directive|endif
name|em_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
comment|/* Check SOL/IDER usage */
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1000_check_reset_block
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
condition|)
block|{
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Media change is"
literal|" blocked due to SOL/IDER session.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* falls thru */
case|case
name|SIOCGIFMEDIA
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: \ 		    SIOCxIFMEDIA (Get/Set Interface Media)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|mask
decl_stmt|,
name|reinit
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCSIFCAP (Set Capabilities)"
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|mask
operator|&
name|IFCAP_POLLING
condition|)
block|{
if|if
condition|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|error
operator|=
name|ether_poll_register
argument_list|(
name|em_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|if_setcapenablebit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_POLLING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Enable interrupt even in error case */
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|if_setcapenablebit
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
name|IFCAP_POLLING
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|mask
operator|&
name|IFCAP_HWCSUM
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_HWCSUM
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_TSO4
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_VLAN_HWTAGGING
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_VLAN_HWFILTER
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_VLAN_HWTSO
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_WOL
operator|)
operator|&&
operator|(
name|if_getcapabilities
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_WOL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_WOL_MCAST
condition|)
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_WOL_MCAST
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_WOL_MAGIC
condition|)
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_WOL_MAGIC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reinit
operator|&&
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|em_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|if_vlancap
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Init entry point  *  *  This routine is used in two ways. It is used by the stack as  *  init entry point in network interface structure. It is also used  *  by the driver as a hw/sw initialization routine to get to a  *  consistent state.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_init: begin"
argument_list|)
expr_stmt|;
name|EM_CORE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* Get the latest mac address, User can use a LAA */
name|bcopy
argument_list|(
name|if_getlladdr
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Put the address into the Receive Address Array */
name|e1000_rar_set
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * With the 82571 adapter, RAR[0] may be overwritten 	 * when the other port is reset, we make a duplicate 	 * in RAR[14] for that eventuality, this assures 	 * the interface continues to function. 	 */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82571
condition|)
block|{
name|e1000_set_laa_state_82571
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|e1000_rar_set
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
name|E1000_RAR_ENTRIES
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the hardware */
name|em_reset
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Setup VLAN support, basic and offload if available */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_VET
argument_list|,
name|ETHERTYPE_VLAN
argument_list|)
expr_stmt|;
comment|/* Set hardware offload abilities */
name|if_clearhwassist
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TXCSUM
condition|)
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
name|CSUM_TCP
operator||
name|CSUM_UDP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  	** There have proven to be problems with TSO when not 	** at full gigabit speed, so disable the assist automatically 	** when at lower speeds.  -jfv 	*/
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TSO4
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|link_speed
operator|==
name|SPEED_1000
condition|)
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
name|CSUM_TSO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Configure for OS presence */
name|em_init_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Prepare transmit descriptors and buffers */
name|em_setup_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_initialize_transmit_unit
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Setup Multicast table */
name|em_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	** Figure out the desired mbuf 	** pool for doing jumbos 	*/
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
operator|<=
literal|2048
condition|)
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MCLBYTES
expr_stmt|;
elseif|else
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
operator|<=
literal|4096
condition|)
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUMPAGESIZE
expr_stmt|;
else|else
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUM9BYTES
expr_stmt|;
comment|/* Prepare receive descriptors and buffers */
if|if
condition|(
name|em_setup_receive_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup receive structures\n"
argument_list|)
expr_stmt|;
name|em_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|em_initialize_receive_unit
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Use real VLAN Filter support? */
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
comment|/* Use real VLAN Filter support */
name|em_setup_vlan_hw_support
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
block|{
name|u32
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_VME
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't lose promiscuous settings */
name|em_set_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Set the interface as ACTIVE */
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_DRV_RUNNING
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|em_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|e1000_clear_hw_cntrs_base_generic
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* MSI/X configuration for 82574 */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
block|{
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|tmp
operator||=
name|E1000_CTRL_EXT_PBA_CLR
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Set the IVAR - interrupt vector routing. */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IVAR
argument_list|,
name|adapter
operator|->
name|ivars
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* 	 * Only enable interrupts if we are not polling, make sure 	 * they are off otherwise. 	 */
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_POLLING
condition|)
name|em_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* DEVICE_POLLING */
name|em_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* AMT based hardware can now take control from firmware */
if|if
condition|(
name|adapter
operator|->
name|has_manage
operator|&&
name|adapter
operator|->
name|has_amt
condition|)
name|em_get_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_comment
comment|/*********************************************************************  *  *  Legacy polling routine: note this only works with single queue  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_poll
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|u32
name|reg_icr
decl_stmt|;
name|int
name|rx_done
decl_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
condition|)
block|{
name|reg_icr
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_icr
operator|&
operator|(
name|E1000_ICR_RXSEQ
operator||
name|E1000_ICR_LSC
operator|)
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|get_link_status
operator|=
literal|1
expr_stmt|;
name|em_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|em_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_rxeof
argument_list|(
name|rxr
argument_list|,
name|count
argument_list|,
operator|&
name|rx_done
argument_list|)
expr_stmt|;
name|EM_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|em_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|em_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|if_sendq_empty
argument_list|(
name|ifp
argument_list|)
condition|)
name|em_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EM_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
return|return
operator|(
name|rx_done
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_comment
comment|/*********************************************************************  *  *  Fast Legacy/MSI Combined Interrupt Service routine    *  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_irq_fast
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|if_t
name|ifp
decl_stmt|;
name|u32
name|reg_icr
decl_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|reg_icr
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
comment|/* Hot eject?  */
if|if
condition|(
name|reg_icr
operator|==
literal|0xffffffff
condition|)
return|return
name|FILTER_STRAY
return|;
comment|/* Definitely not our interrupt.  */
if|if
condition|(
name|reg_icr
operator|==
literal|0x0
condition|)
return|return
name|FILTER_STRAY
return|;
comment|/* 	 * Starting with the 82571 chip, bit 31 should be used to 	 * determine whether the interrupt belongs to us. 	 */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82571
operator|&&
operator|(
name|reg_icr
operator|&
name|E1000_ICR_INT_ASSERTED
operator|)
operator|==
literal|0
condition|)
return|return
name|FILTER_STRAY
return|;
name|em_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|que_task
argument_list|)
expr_stmt|;
comment|/* Link status change */
if|if
condition|(
name|reg_icr
operator|&
operator|(
name|E1000_ICR_RXSEQ
operator||
name|E1000_ICR_LSC
operator|)
condition|)
block|{
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|get_link_status
operator|=
literal|1
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_fast
argument_list|,
operator|&
name|adapter
operator|->
name|link_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_icr
operator|&
name|E1000_ICR_RXO
condition|)
name|adapter
operator|->
name|rx_overruns
operator|++
expr_stmt|;
return|return
name|FILTER_HANDLED
return|;
block|}
end_function

begin_comment
comment|/* Combined RX/TX handler, used by Legacy and MSI */
end_comment

begin_function
specifier|static
name|void
name|em_handle_que
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|bool
name|more
init|=
name|em_rxeof
argument_list|(
name|rxr
argument_list|,
name|adapter
operator|->
name|rx_process_limit
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|EM_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|em_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|em_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|if_sendq_empty
argument_list|(
name|ifp
argument_list|)
condition|)
name|em_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EM_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|que_task
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|em_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX Interrupt Service Routines  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_msix_tx
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
operator|++
name|txr
operator|->
name|tx_irq
expr_stmt|;
name|EM_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|em_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|em_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|if_sendq_empty
argument_list|(
name|ifp
argument_list|)
condition|)
name|em_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Reenable this interrupt */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|txr
operator|->
name|ims
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX RX Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_msix_rx
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|bool
name|more
decl_stmt|;
operator|++
name|rxr
operator|->
name|rx_irq
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|if_getdrvflags
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
name|more
operator|=
name|em_rxeof
argument_list|(
name|rxr
argument_list|,
name|adapter
operator|->
name|rx_process_limit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
name|taskqueue_enqueue
argument_list|(
name|rxr
operator|->
name|tq
argument_list|,
operator|&
name|rxr
operator|->
name|rx_task
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Reenable this interrupt */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|rxr
operator|->
name|ims
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX Link Fast Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_msix_link
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|u32
name|reg_icr
decl_stmt|;
operator|++
name|adapter
operator|->
name|link_irq
expr_stmt|;
name|reg_icr
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_icr
operator|&
name|E1000_ICR_RXO
condition|)
name|adapter
operator|->
name|rx_overruns
operator|++
expr_stmt|;
if|if
condition|(
name|reg_icr
operator|&
operator|(
name|E1000_ICR_RXSEQ
operator||
name|E1000_ICR_LSC
operator|)
condition|)
block|{
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|get_link_status
operator|=
literal|1
expr_stmt|;
name|em_handle_link
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|EM_MSIX_LINK
operator||
name|E1000_IMS_LSC
argument_list|)
expr_stmt|;
comment|/*  	** Because we must read the ICR for this interrupt  	** it may clear other causes using autoclear, for  	** this reason we simply create a soft interrupt  	** for all these vectors.  	*/
if|if
condition|(
name|reg_icr
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICS
argument_list|,
name|adapter
operator|->
name|ims
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|em_handle_rx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|context
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|bool
name|more
decl_stmt|;
name|more
operator|=
name|em_rxeof
argument_list|(
name|rxr
argument_list|,
name|adapter
operator|->
name|rx_process_limit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
name|taskqueue_enqueue
argument_list|(
name|rxr
operator|->
name|tq
argument_list|,
operator|&
name|rxr
operator|->
name|rx_task
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Reenable this interrupt */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|rxr
operator|->
name|ims
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|em_handle_tx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|context
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|EM_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|em_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|em_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|if_sendq_empty
argument_list|(
name|ifp
argument_list|)
condition|)
name|em_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|txr
operator|->
name|ims
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_handle_link
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
name|em_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|em_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|EM_MSIX_LINK
operator||
name|E1000_IMS_LSC
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|link_active
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|EM_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|em_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|if_sendq_empty
argument_list|(
name|ifp
argument_list|)
condition|)
name|em_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EM_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
block|}
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called whenever the user queries the status of  *  the interface using ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_media_status
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|u_char
name|fiber_type
init|=
name|IFM_1000_SX
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_media_status: begin"
argument_list|)
expr_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
block|{
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_fiber
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
operator|)
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|fiber_type
operator||
name|IFM_FDX
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
literal|10
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
break|break;
case|case
literal|100
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
break|break;
case|case
literal|1000
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|adapter
operator|->
name|link_duplex
operator|==
name|FULL_DUPLEX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_HDX
expr_stmt|;
block|}
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called when the user changes speed/duplex using  *  media/mediopt option with ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_media_change
parameter_list|(
name|if_t
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|adapter
operator|->
name|media
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_media_change: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
name|AUTONEG_ADV_DEFAULT
expr_stmt|;
break|break;
case|case
name|IFM_1000_LX
case|:
case|case
name|IFM_1000_SX
case|:
case|case
name|IFM_1000_T
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
name|ADVERTISE_1000_FULL
expr_stmt|;
break|break;
case|case
name|IFM_100_TX
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|FALSE
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifm
operator|->
name|ifm_media
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
condition|)
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_100_FULL
expr_stmt|;
else|else
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_100_HALF
expr_stmt|;
break|break;
case|case
name|IFM_10_T
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|FALSE
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifm
operator|->
name|ifm_media
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
condition|)
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_10_FULL
expr_stmt|;
else|else
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_10_HALF
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Unsupported media type\n"
argument_list|)
expr_stmt|;
block|}
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine maps the mbufs to tx descriptors.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_xmit
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_headp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|EM_MAX_SCATTER
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|em_txbuffer
modifier|*
name|tx_buffer
decl_stmt|,
modifier|*
name|tx_buffer_mapped
decl_stmt|;
name|struct
name|e1000_tx_desc
modifier|*
name|ctxd
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tp
init|=
name|NULL
decl_stmt|;
name|u32
name|txd_upper
init|=
literal|0
decl_stmt|,
name|txd_lower
init|=
literal|0
decl_stmt|;
name|int
name|ip_off
decl_stmt|,
name|poff
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|first
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bool
name|do_tso
decl_stmt|,
name|tso_desc
decl_stmt|,
name|remap
init|=
name|TRUE
decl_stmt|;
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
name|do_tso
operator|=
operator|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
expr_stmt|;
name|tso_desc
operator|=
name|FALSE
expr_stmt|;
name|ip_off
operator|=
name|poff
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Intel recommends entire IP/TCP header length reside in a single 	 * buffer. If multiple descriptors are used to describe the IP and 	 * TCP header, each descriptor should describe one or more 	 * complete headers; descriptors referencing only parts of headers 	 * are not supported. If all layer headers are not coalesced into 	 * a single buffer, each buffer should not cross a 4KB boundary, 	 * or be larger than the maximum read request size. 	 * Controller also requires modifing IP/TCP header to make TSO work 	 * so we firstly get a writable mbuf chain then coalesce ethernet/ 	 * IP/TCP header into a single buffer to meet the requirement of 	 * controller. This also simplifies IP/TCP/UDP checksum offloading 	 * which also has similar restrictions. 	 */
if|if
condition|(
name|do_tso
operator|||
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_OFFLOAD
condition|)
block|{
if|if
condition|(
name|do_tso
operator|||
operator|(
name|m_head
operator|->
name|m_next
operator|!=
name|NULL
operator|&&
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_OFFLOAD
operator|)
condition|)
block|{
if|if
condition|(
name|M_WRITABLE
argument_list|(
operator|*
name|m_headp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_head
operator|=
name|m_dup
argument_list|(
operator|*
name|m_headp
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m_headp
operator|=
name|m_head
expr_stmt|;
block|}
block|}
comment|/* 		 * XXX 		 * Assume IPv4, we don't have TSO/checksum offload support 		 * for IPv6 yet. 		 */
name|ip_off
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_len
operator|<
name|ip_off
condition|)
block|{
name|m_head
operator|=
name|m_pullup
argument_list|(
name|m_head
argument_list|,
name|ip_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m_head
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|ip_off
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_len
operator|<
name|ip_off
condition|)
block|{
name|m_head
operator|=
name|m_pullup
argument_list|(
name|m_head
argument_list|,
name|ip_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|m_head
operator|->
name|m_len
operator|<
name|ip_off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|m_head
operator|=
name|m_pullup
argument_list|(
name|m_head
argument_list|,
name|ip_off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m_head
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|ip_off
operator|)
expr_stmt|;
name|poff
operator|=
name|ip_off
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|do_tso
operator|||
operator|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
operator|)
condition|)
block|{
if|if
condition|(
name|m_head
operator|->
name|m_len
operator|<
name|poff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
block|{
name|m_head
operator|=
name|m_pullup
argument_list|(
name|m_head
argument_list|,
name|poff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
name|tp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m_head
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|poff
operator|)
expr_stmt|;
comment|/* 			 * TSO workaround: 			 *   pull 4 more bytes of data into it. 			 */
if|if
condition|(
name|m_head
operator|->
name|m_len
operator|<
name|poff
operator|+
operator|(
name|tp
operator|->
name|th_off
operator|<<
literal|2
operator|)
condition|)
block|{
name|m_head
operator|=
name|m_pullup
argument_list|(
name|m_head
argument_list|,
name|poff
operator|+
operator|(
name|tp
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|+
name|TSO_WORKAROUND
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m_head
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|ip_off
operator|)
expr_stmt|;
name|tp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m_head
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|poff
operator|)
expr_stmt|;
if|if
condition|(
name|do_tso
condition|)
block|{
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
operator|(
name|tp
operator|->
name|th_off
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
comment|/* 				 * The pseudo TCP checksum does not include TCP 				 * payload length so driver should recompute 				 * the checksum here what hardware expect to 				 * see. This is adherence of Microsoft's Large 				 * Send specification. 			 	*/
name|tp
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
condition|)
block|{
if|if
condition|(
name|m_head
operator|->
name|m_len
operator|<
name|poff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
block|{
name|m_head
operator|=
name|m_pullup
argument_list|(
name|m_head
argument_list|,
name|poff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m_head
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|ip_off
operator|)
expr_stmt|;
block|}
operator|*
name|m_headp
operator|=
name|m_head
expr_stmt|;
block|}
comment|/* 	 * Map the packet for DMA 	 * 	 * Capture the first descriptor index, 	 * this descriptor will have the index 	 * of the EOP which is the only one that 	 * now gets a DONE bit writeback. 	 */
name|first
operator|=
name|txr
operator|->
name|next_avail_desc
expr_stmt|;
name|tx_buffer
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
name|tx_buffer_mapped
operator|=
name|tx_buffer
expr_stmt|;
name|map
operator|=
name|tx_buffer
operator|->
name|map
expr_stmt|;
name|retry
label|:
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
operator|*
name|m_headp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
comment|/* 	 * There are two types of errors we can (try) to handle: 	 * - EFBIG means the mbuf chain was too long and bus_dma ran 	 *   out of segments.  Defragment the mbuf chain and try again. 	 * - ENOMEM means bus_dma could not obtain enough bounce buffers 	 *   at this point in time.  Defer sending and try again later. 	 * All other errors, in particular EINVAL, are fatal and prevent the 	 * mbuf chain from ever going through.  Drop it and report error. 	 */
if|if
condition|(
name|error
operator|==
name|EFBIG
operator|&&
name|remap
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_collapse
argument_list|(
operator|*
name|m_headp
argument_list|,
name|M_NOWAIT
argument_list|,
name|EM_MAX_SCATTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|adapter
operator|->
name|mbuf_defrag_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m_headp
operator|=
name|m
expr_stmt|;
comment|/* Try it again, but only once */
name|remap
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|adapter
operator|->
name|no_tx_dma_setup
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * TSO Hardware workaround, if this packet is not 	 * TSO, and is only a single descriptor long, and 	 * it follows a TSO burst, then we need to add a 	 * sentinel descriptor to prevent premature writeback. 	 */
if|if
condition|(
operator|(
operator|!
name|do_tso
operator|)
operator|&&
operator|(
name|txr
operator|->
name|tx_tso
operator|==
name|TRUE
operator|)
condition|)
block|{
if|if
condition|(
name|nsegs
operator|==
literal|1
condition|)
name|tso_desc
operator|=
name|TRUE
expr_stmt|;
name|txr
operator|->
name|tx_tso
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<
operator|(
name|nsegs
operator|+
name|EM_MAX_SCATTER
operator|)
condition|)
block|{
name|txr
operator|->
name|no_desc_avail
operator|++
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
comment|/* Do hardware assists */
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|em_tso_setup
argument_list|(
name|txr
argument_list|,
name|m_head
argument_list|,
name|ip_off
argument_list|,
name|ip
argument_list|,
name|tp
argument_list|,
operator|&
name|txd_upper
argument_list|,
operator|&
name|txd_lower
argument_list|)
expr_stmt|;
comment|/* we need to make a final sentinel transmit desc */
name|tso_desc
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_OFFLOAD
condition|)
name|em_transmit_checksum_setup
argument_list|(
name|txr
argument_list|,
name|m_head
argument_list|,
name|ip_off
argument_list|,
name|ip
argument_list|,
operator|&
name|txd_upper
argument_list|,
operator|&
name|txd_lower
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
comment|/* Set the vlan id. */
name|txd_upper
operator||=
name|htole16
argument_list|(
name|if_getvtag
argument_list|(
name|m_head
argument_list|)
argument_list|)
operator|<<
literal|16
expr_stmt|;
comment|/* Tell hardware to add tag */
name|txd_lower
operator||=
name|htole32
argument_list|(
name|E1000_TXD_CMD_VLE
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|txr
operator|->
name|next_avail_desc
expr_stmt|;
comment|/* Set up our transmit descriptors */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsegs
condition|;
name|j
operator|++
control|)
block|{
name|bus_size_t
name|seg_len
decl_stmt|;
name|bus_addr_t
name|seg_addr
decl_stmt|;
name|tx_buffer
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|i
index|]
expr_stmt|;
name|ctxd
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|i
index|]
expr_stmt|;
name|seg_addr
operator|=
name|segs
index|[
name|j
index|]
operator|.
name|ds_addr
expr_stmt|;
name|seg_len
operator|=
name|segs
index|[
name|j
index|]
operator|.
name|ds_len
expr_stmt|;
comment|/* 		** TSO Workaround: 		** If this is the last descriptor, we want to 		** split it so we have a small final sentinel 		*/
if|if
condition|(
name|tso_desc
operator|&&
operator|(
name|j
operator|==
operator|(
name|nsegs
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|seg_len
operator|>
literal|8
operator|)
condition|)
block|{
name|seg_len
operator|-=
name|TSO_WORKAROUND
expr_stmt|;
name|ctxd
operator|->
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|seg_addr
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|lower
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|adapter
operator|->
name|txd_cmd
operator||
name|txd_lower
operator||
name|seg_len
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|upper
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|txd_upper
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Now make the sentinel */
name|txr
operator|->
name|tx_avail
operator|--
expr_stmt|;
name|ctxd
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|i
index|]
expr_stmt|;
name|tx_buffer
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|i
index|]
expr_stmt|;
name|ctxd
operator|->
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|seg_addr
operator|+
name|seg_len
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|lower
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|adapter
operator|->
name|txd_cmd
operator||
name|txd_lower
operator||
name|TSO_WORKAROUND
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|upper
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|txd_upper
argument_list|)
expr_stmt|;
name|last
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ctxd
operator|->
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|seg_addr
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|lower
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|adapter
operator|->
name|txd_cmd
operator||
name|txd_lower
operator||
name|seg_len
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|upper
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|txd_upper
argument_list|)
expr_stmt|;
name|last
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|tx_buffer
operator|->
name|next_eop
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|txr
operator|->
name|next_avail_desc
operator|=
name|i
expr_stmt|;
name|txr
operator|->
name|tx_avail
operator|-=
name|nsegs
expr_stmt|;
name|tx_buffer
operator|->
name|m_head
operator|=
name|m_head
expr_stmt|;
comment|/* 	** Here we swap the map so the last descriptor, 	** which gets the completion interrupt has the 	** real map, and the first descriptor gets the 	** unused map from this descriptor. 	*/
name|tx_buffer_mapped
operator|->
name|map
operator|=
name|tx_buffer
operator|->
name|map
expr_stmt|;
name|tx_buffer
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/*          * Last Descriptor of Packet 	 * needs End Of Packet (EOP) 	 * and Report Status (RS)          */
name|ctxd
operator|->
name|lower
operator|.
name|data
operator||=
name|htole32
argument_list|(
name|E1000_TXD_CMD_EOP
operator||
name|E1000_TXD_CMD_RS
argument_list|)
expr_stmt|;
comment|/* 	 * Keep track in the first buffer which 	 * descriptor will be written back 	 */
name|tx_buffer
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
name|tx_buffer
operator|->
name|next_eop
operator|=
name|last
expr_stmt|;
comment|/* 	 * Advance the Transmit Descriptor Tail (TDT), this tells the E1000 	 * that this frame is available to transmit. 	 */
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|u32
name|reg_rctl
decl_stmt|;
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_PROMISC
condition|)
block|{
name|reg_rctl
operator||=
operator|(
name|E1000_RCTL_UPE
operator||
name|E1000_RCTL_MPE
operator|)
expr_stmt|;
comment|/* Turn this on if you want to see bad packets */
if|if
condition|(
name|em_debug_sbp
condition|)
name|reg_rctl
operator||=
name|E1000_RCTL_SBP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|reg_rctl
operator||=
name|E1000_RCTL_MPE
expr_stmt|;
name|reg_rctl
operator|&=
operator|~
name|E1000_RCTL_UPE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|em_disable_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|u32
name|reg_rctl
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|(
operator|~
name|E1000_RCTL_UPE
operator|)
expr_stmt|;
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_ALLMULTI
condition|)
name|mcnt
operator|=
name|MAX_NUM_MULTICAST_ADDRESSES
expr_stmt|;
else|else
name|mcnt
operator|=
name|if_multiaddr_count
argument_list|(
name|ifp
argument_list|,
name|MAX_NUM_MULTICAST_ADDRESSES
argument_list|)
expr_stmt|;
comment|/* Don't disable if in MAX groups */
if|if
condition|(
name|mcnt
operator|<
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
name|reg_rctl
operator|&=
operator|(
operator|~
name|E1000_RCTL_MPE
operator|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|(
operator|~
name|E1000_RCTL_SBP
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Multicast Update  *  *  This routine is called whenever multicast address list is updated.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|u32
name|reg_rctl
init|=
literal|0
decl_stmt|;
name|u8
modifier|*
name|mta
decl_stmt|;
comment|/* Multicast array memory */
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"em_set_multi: begin"
argument_list|)
expr_stmt|;
name|mta
operator|=
name|adapter
operator|->
name|mta
expr_stmt|;
name|bzero
argument_list|(
name|mta
argument_list|,
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
operator|*
name|ETH_ADDR_LEN
operator|*
name|MAX_NUM_MULTICAST_ADDRESSES
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82542
operator|&&
name|adapter
operator|->
name|hw
operator|.
name|revision_id
operator|==
name|E1000_REVISION_2
condition|)
block|{
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
name|e1000_pci_clear_mwi
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|reg_rctl
operator||=
name|E1000_RCTL_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|if_multiaddr_array
argument_list|(
name|ifp
argument_list|,
name|mta
argument_list|,
operator|&
name|mcnt
argument_list|,
name|MAX_NUM_MULTICAST_ADDRESSES
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>=
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
block|{
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|reg_rctl
operator||=
name|E1000_RCTL_MPE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
else|else
name|e1000_update_mc_addr_list
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|mta
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82542
operator|&&
name|adapter
operator|->
name|hw
operator|.
name|revision_id
operator|==
name|E1000_REVISION_2
condition|)
block|{
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|~
name|E1000_RCTL_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
name|e1000_pci_set_mwi
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Timer routine  *  *  This routine checks for link status and updates statistics.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_local_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|u32
name|trigger
init|=
literal|0
decl_stmt|;
name|EM_CORE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Reset LAA into RAR[0] on 82571 */
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82571
operator|)
operator|&&
name|e1000_get_laa_state_82571
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
condition|)
name|e1000_rar_set
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mask to use in the irq trigger */
if|if
condition|(
name|adapter
operator|->
name|msix_mem
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
name|trigger
operator||=
name|rxr
operator|->
name|ims
expr_stmt|;
name|rxr
operator|=
name|adapter
operator|->
name|rx_rings
expr_stmt|;
block|}
else|else
name|trigger
operator|=
name|E1000_ICS_RXDMT0
expr_stmt|;
comment|/* 	** Check on the state of the TX queue(s), this  	** can be done without the lock because its RO 	** and the HUNG state will be static if set. 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
if|if
condition|(
name|txr
operator|->
name|busy
operator|==
name|EM_TX_HUNG
condition|)
goto|goto
name|hung
goto|;
if|if
condition|(
name|txr
operator|->
name|busy
operator|>=
name|EM_TX_MAXTRIES
condition|)
name|txr
operator|->
name|busy
operator|=
name|EM_TX_HUNG
expr_stmt|;
comment|/* Schedule a TX tasklet if needed */
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<=
name|EM_MAX_SCATTER
condition|)
name|taskqueue_enqueue
argument_list|(
name|txr
operator|->
name|tq
argument_list|,
operator|&
name|txr
operator|->
name|tx_task
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|em_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEVICE_POLLING
comment|/* Trigger an RX interrupt to guarantee mbuf refresh */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICS
argument_list|,
name|trigger
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
name|hung
label|:
comment|/* Looks like we're hung */
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Watchdog timeout Queue[%d]-- resetting\n"
argument_list|,
name|txr
operator|->
name|me
argument_list|)
expr_stmt|;
name|em_print_debug_info
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|watchdog_events
operator|++
expr_stmt|;
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_update_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|u32
name|link_check
init|=
literal|0
decl_stmt|;
comment|/* Get the cached link value or read phy for real */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
condition|)
block|{
case|case
name|e1000_media_type_copper
case|:
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|get_link_status
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch_spt
condition|)
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Do the work to read phy */
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|link_check
operator|=
operator|!
name|hw
operator|->
name|mac
operator|.
name|get_link_status
expr_stmt|;
if|if
condition|(
name|link_check
condition|)
comment|/* ESB2 fix */
name|e1000_cfg_on_link_up
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
name|link_check
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|e1000_media_type_fiber
case|:
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|link_check
operator|=
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_LU
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_media_type_internal_serdes
case|:
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|link_check
operator|=
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|serdes_has_link
expr_stmt|;
break|break;
default|default:
case|case
name|e1000_media_type_unknown
case|:
break|break;
block|}
comment|/* Now check for a transition */
if|if
condition|(
name|link_check
operator|&&
operator|(
name|adapter
operator|->
name|link_active
operator|==
literal|0
operator|)
condition|)
block|{
name|e1000_get_speed_and_duplex
argument_list|(
name|hw
argument_list|,
operator|&
name|adapter
operator|->
name|link_speed
argument_list|,
operator|&
name|adapter
operator|->
name|link_duplex
argument_list|)
expr_stmt|;
comment|/* Check if we must disable SPEED_MODE bit on PCI-E */
if|if
condition|(
operator|(
name|adapter
operator|->
name|link_speed
operator|!=
name|SPEED_1000
operator|)
operator|&&
operator|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82571
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82572
operator|)
operator|)
condition|)
block|{
name|int
name|tarc0
decl_stmt|;
name|tarc0
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tarc0
operator|&=
operator|~
name|TARC_SPEED_MODE_BIT
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|tarc0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is up %d Mbps %s\n"
argument_list|,
name|adapter
operator|->
name|link_speed
argument_list|,
operator|(
operator|(
name|adapter
operator|->
name|link_duplex
operator|==
name|FULL_DUPLEX
operator|)
condition|?
literal|"Full Duplex"
else|:
literal|"Half Duplex"
operator|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|smartspeed
operator|=
literal|0
expr_stmt|;
name|if_setbaudrate
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|link_speed
operator|*
literal|1000000
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|link_check
operator|&&
operator|(
name|adapter
operator|->
name|link_active
operator|==
literal|1
operator|)
condition|)
block|{
name|if_setbaudrate
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_speed
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|link_duplex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is Down\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
literal|0
expr_stmt|;
comment|/* Link down, disable hang detection */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
name|txr
operator|->
name|busy
operator|=
name|EM_TX_IDLE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine disables all traffic on the adapter by issuing a  *  global reset on the MAC and deallocates TX/RX buffers.  *  *  This routine should always be called with BOTH the CORE  *  and TX locks.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_stop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|EM_CORE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_stop: begin"
argument_list|)
expr_stmt|;
name|em_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is no longer active */
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
comment|/* Disarm Hang Detection. */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|EM_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|txr
operator|->
name|busy
operator|=
name|EM_TX_IDLE
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
comment|/* I219 needs some special flushing to avoid hangs */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_pch_spt
condition|)
name|em_flush_desc_rings
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|e1000_reset_hw
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e1000_led_off
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|e1000_cleanup_led
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Determine hardware revision.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
comment|/* Make sure our PCI config space has the necessary stuff set */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|pci_cmd_word
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Save off the information about this board */
name|adapter
operator|->
name|hw
operator|.
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|revision_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|subsystem_vendor_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|subsystem_device_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Do Shared Code Init and Setup */
if|if
condition|(
name|e1000_set_mac_type
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Setup init failure\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|em_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|memory
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|memory
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|memory
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|memory
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|hw_addr
operator|=
operator|(
name|u8
operator|*
operator|)
operator|&
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|back
operator|=
operator|&
name|adapter
operator|->
name|osdep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup the Legacy or MSI Interrupt handler  *  **********************************************************************/
end_comment

begin_function
name|int
name|em_allocate_legacy
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
init|=
literal|0
decl_stmt|;
comment|/* Manually turn off all interrupts */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix
operator|==
literal|1
condition|)
comment|/* using MSI */
name|rid
operator|=
literal|1
expr_stmt|;
comment|/* We allocate a single interrupt resource */
name|adapter
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: "
literal|"interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Allocate a fast interrupt and the associated 	 * deferred processing contexts. 	 */
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|que_task
argument_list|,
literal|0
argument_list|,
name|em_handle_que
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"em_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|adapter
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|adapter
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s que"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use a TX only tasklet for local timer */
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|tx_task
argument_list|,
literal|0
argument_list|,
name|em_handle_tx
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"em_txq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|txr
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|txr
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s txq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|link_task
argument_list|,
literal|0
argument_list|,
name|em_handle_link
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|em_irq_fast
argument_list|,
name|NULL
argument_list|,
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register fast interrupt "
literal|"handler: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|adapter
operator|->
name|tq
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup the MSIX Interrupt handlers  *   This is not really Multiqueue, rather  *   its just separate interrupt vectors  *   for TX, RX, and Link.  *  **********************************************************************/
end_comment

begin_function
name|int
name|em_allocate_msix
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|vector
init|=
literal|0
decl_stmt|;
name|int
name|cpu_id
init|=
literal|0
decl_stmt|;
comment|/* Make sure all interrupts are disabled */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* First set up ring resources */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
operator|,
name|vector
operator|++
control|)
block|{
comment|/* RX ring */
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|rxr
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: "
literal|"RX MSIX Interrupt %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|rxr
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|em_msix_rx
argument_list|,
name|rxr
argument_list|,
operator|&
name|rxr
operator|->
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register RX handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|rxr
operator|->
name|res
argument_list|,
name|rxr
operator|->
name|tag
argument_list|,
literal|"rx%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rxr
operator|->
name|msix
operator|=
name|vector
expr_stmt|;
if|if
condition|(
name|em_last_bind_cpu
operator|<
literal|0
condition|)
name|em_last_bind_cpu
operator|=
name|CPU_FIRST
argument_list|()
expr_stmt|;
name|cpu_id
operator|=
name|em_last_bind_cpu
expr_stmt|;
name|bus_bind_intr
argument_list|(
name|dev
argument_list|,
name|rxr
operator|->
name|res
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|rxr
operator|->
name|rx_task
argument_list|,
literal|0
argument_list|,
name|em_handle_rx
argument_list|,
name|rxr
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"em_rxq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|rxr
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|rxr
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s rxq (cpuid %d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
comment|/* 		** Set the bit to enable interrupt 		** in E1000_IMS -- bits 20 and 21 		** are for RX0 and RX1, note this has 		** NOTHING to do with the MSIX vector 		*/
name|rxr
operator|->
name|ims
operator|=
literal|1
operator|<<
operator|(
literal|20
operator|+
name|i
operator|)
expr_stmt|;
name|adapter
operator|->
name|ims
operator||=
name|rxr
operator|->
name|ims
expr_stmt|;
name|adapter
operator|->
name|ivars
operator||=
operator|(
literal|8
operator||
name|rxr
operator|->
name|msix
operator|)
operator|<<
operator|(
name|i
operator|*
literal|4
operator|)
expr_stmt|;
name|em_last_bind_cpu
operator|=
name|CPU_NEXT
argument_list|(
name|em_last_bind_cpu
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
operator|,
name|vector
operator|++
control|)
block|{
comment|/* TX ring */
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|txr
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: "
literal|"TX MSIX Interrupt %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|txr
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|em_msix_tx
argument_list|,
name|txr
argument_list|,
operator|&
name|txr
operator|->
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register TX handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|txr
operator|->
name|res
argument_list|,
name|txr
operator|->
name|tag
argument_list|,
literal|"tx%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|txr
operator|->
name|msix
operator|=
name|vector
expr_stmt|;
if|if
condition|(
name|em_last_bind_cpu
operator|<
literal|0
condition|)
name|em_last_bind_cpu
operator|=
name|CPU_FIRST
argument_list|()
expr_stmt|;
name|cpu_id
operator|=
name|em_last_bind_cpu
expr_stmt|;
name|bus_bind_intr
argument_list|(
name|dev
argument_list|,
name|txr
operator|->
name|res
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|tx_task
argument_list|,
literal|0
argument_list|,
name|em_handle_tx
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"em_txq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|txr
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|txr
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s txq (cpuid %d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
comment|/* 		** Set the bit to enable interrupt 		** in E1000_IMS -- bits 22 and 23 		** are for TX0 and TX1, note this has 		** NOTHING to do with the MSIX vector 		*/
name|txr
operator|->
name|ims
operator|=
literal|1
operator|<<
operator|(
literal|22
operator|+
name|i
operator|)
expr_stmt|;
name|adapter
operator|->
name|ims
operator||=
name|txr
operator|->
name|ims
expr_stmt|;
name|adapter
operator|->
name|ivars
operator||=
operator|(
literal|8
operator||
name|txr
operator|->
name|msix
operator|)
operator|<<
operator|(
literal|8
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|em_last_bind_cpu
operator|=
name|CPU_NEXT
argument_list|(
name|em_last_bind_cpu
argument_list|)
expr_stmt|;
block|}
comment|/* Link interrupt */
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|adapter
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate "
literal|"bus resource: Link interrupt [%d]\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the link handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|em_msix_link
argument_list|,
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|adapter
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register LINK handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|adapter
operator|->
name|tag
argument_list|,
literal|"link"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adapter
operator|->
name|linkvec
operator|=
name|vector
expr_stmt|;
name|adapter
operator|->
name|ivars
operator||=
operator|(
literal|8
operator||
name|vector
operator|)
operator|<<
literal|16
expr_stmt|;
name|adapter
operator|->
name|ivars
operator||=
literal|0x80000000
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|int
name|rid
decl_stmt|;
comment|/* 	** Release all the queue interrupt resources: 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
comment|/* an early abort? */
if|if
condition|(
name|txr
operator|==
name|NULL
condition|)
break|break;
name|rid
operator|=
name|txr
operator|->
name|msix
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|txr
operator|->
name|res
argument_list|,
name|txr
operator|->
name|tag
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txr
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|txr
operator|->
name|res
argument_list|)
expr_stmt|;
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
comment|/* an early abort? */
if|if
condition|(
name|rxr
operator|==
name|NULL
condition|)
break|break;
name|rid
operator|=
name|rxr
operator|->
name|msix
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|rxr
operator|->
name|res
argument_list|,
name|rxr
operator|->
name|tag
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rxr
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|rxr
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|linkvec
condition|)
comment|/* we are doing MSIX */
name|rid
operator|=
name|adapter
operator|->
name|linkvec
operator|+
literal|1
expr_stmt|;
else|else
operator|(
name|adapter
operator|->
name|msix
operator|!=
literal|0
operator|)
condition|?
operator|(
name|rid
operator|=
literal|1
operator|)
else|:
operator|(
name|rid
operator|=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|adapter
operator|->
name|tag
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|adapter
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
name|EM_MSIX_BAR
argument_list|)
argument_list|,
name|adapter
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|memory
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|adapter
operator|->
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|flash
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|EM_FLASH
argument_list|,
name|adapter
operator|->
name|flash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup MSI or MSI/X  */
end_comment

begin_function
specifier|static
name|int
name|em_setup_msix
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|val
decl_stmt|;
comment|/* Nearly always going to use one queue */
name|adapter
operator|->
name|num_queues
operator|=
literal|1
expr_stmt|;
comment|/* 	** Try using MSI-X for Hartwell adapters 	*/
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82574
operator|)
operator|&&
operator|(
name|em_enable_msix
operator|==
name|TRUE
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
name|adapter
operator|->
name|num_queues
operator|=
operator|(
name|em_num_queues
operator|==
literal|1
operator|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
name|em_enable_vectors_82574
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Map the MSIX BAR */
name|int
name|rid
init|=
name|PCIR_BAR
argument_list|(
name|EM_MSIX_BAR
argument_list|)
decl_stmt|;
name|adapter
operator|->
name|msix_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|==
name|NULL
condition|)
block|{
comment|/* May not be enabled */
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Unable to map MSIX table \n"
argument_list|)
expr_stmt|;
goto|goto
name|msi
goto|;
block|}
name|val
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
comment|/* We need 5 vectors in the multiqueue case */
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|val
operator|>=
literal|5
condition|)
name|val
operator|=
literal|5
expr_stmt|;
else|else
block|{
name|adapter
operator|->
name|num_queues
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Insufficient MSIX vectors for>1 queue, "
literal|"using single queue...\n"
argument_list|)
expr_stmt|;
goto|goto
name|msix_one
goto|;
block|}
block|}
else|else
block|{
name|msix_one
label|:
endif|#
directive|endif
if|if
condition|(
name|val
operator|>=
literal|3
condition|)
name|val
operator|=
literal|3
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Insufficient MSIX vectors, using MSI\n"
argument_list|)
expr_stmt|;
goto|goto
name|msi
goto|;
block|}
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Using MSIX interrupts "
literal|"with %d vectors\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
comment|/* 		** If MSIX alloc failed or provided us with 		** less than needed, free and fall through to MSI 		*/
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|msi
label|:
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
name|EM_MSIX_BAR
argument_list|)
argument_list|,
name|adapter
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_mem
operator|=
name|NULL
expr_stmt|;
block|}
name|val
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Using an MSI interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
comment|/* Should only happen due to manual configuration */
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"No MSI/MSIX using a Legacy IRQ\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** The 3 following flush routines are used as a workaround in the ** I219 client parts and only for them. ** ** em_flush_tx_ring - remove all descriptors from the tx_ring ** ** We want to clear all pending descriptors from the TX ring. ** zeroing happens when the HW reads the regs. We  assign the ring itself as ** the data of the next descriptor. We don't care about the data we are about ** to reset the HW. */
end_comment

begin_function
specifier|static
name|void
name|em_flush_tx_ring
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|e1000_tx_desc
modifier|*
name|txd
decl_stmt|;
name|u32
name|tctl
decl_stmt|,
name|txd_lower
init|=
name|E1000_TXD_CMD_IFCS
decl_stmt|;
name|u16
name|size
init|=
literal|512
decl_stmt|;
name|tctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|tctl
operator||
name|E1000_TCTL_EN
argument_list|)
expr_stmt|;
name|txd
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|txr
operator|->
name|next_avail_desc
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|next_avail_desc
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|txr
operator|->
name|next_avail_desc
operator|=
literal|0
expr_stmt|;
comment|/* Just use the ring as a dummy buffer addr */
name|txd
operator|->
name|buffer_addr
operator|=
name|txr
operator|->
name|txdma
operator|.
name|dma_paddr
expr_stmt|;
name|txd
operator|->
name|lower
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|txd_lower
operator||
name|size
argument_list|)
expr_stmt|;
name|txd
operator|->
name|upper
operator|.
name|data
operator|=
literal|0
expr_stmt|;
comment|/* flush descriptors to memory before notifying the HW */
name|wmb
argument_list|()
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|txr
operator|->
name|next_avail_desc
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|usec_delay
argument_list|(
literal|250
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** em_flush_rx_ring - remove all descriptors from the rx_ring ** ** Mark all descriptors in the RX ring as consumed and disable the rx ring */
end_comment

begin_function
specifier|static
name|void
name|em_flush_rx_ring
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|rctl
decl_stmt|,
name|rxdctl
decl_stmt|;
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|rctl
operator|&
operator|~
name|E1000_RCTL_EN
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|rxdctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero the lower 14 bits (prefetch and host thresholds) */
name|rxdctl
operator|&=
literal|0xffffc000
expr_stmt|;
comment|/* 	 * update thresholds: prefetch threshold to 31, host threshold to 1 	 * and make sure the granularity is "descriptors" and not "cache lines" 	 */
name|rxdctl
operator||=
operator|(
literal|0x1F
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
operator||
name|E1000_RXDCTL_THRESH_UNIT_DESC
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rxdctl
argument_list|)
expr_stmt|;
comment|/* momentarily enable the RX ring for the changes to take effect */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|rctl
operator||
name|E1000_RCTL_EN
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|rctl
operator|&
operator|~
name|E1000_RCTL_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** em_flush_desc_rings - remove all descriptors from the descriptor rings ** ** In i219, the descriptor rings must be emptied before resetting the HW ** or before changing the device state to D3 during runtime (runtime PM). ** ** Failure to do this will cause the HW to enter a unit hang state which can ** only be released by PCI reset on the device ** */
end_comment

begin_function
specifier|static
name|void
name|em_flush_desc_rings
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|u16
name|hang_state
decl_stmt|;
name|u32
name|fext_nvm11
decl_stmt|,
name|tdlen
decl_stmt|;
comment|/* First, disable MULR fix in FEXTNVM11 */
name|fext_nvm11
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM11
argument_list|)
expr_stmt|;
name|fext_nvm11
operator||=
name|E1000_FEXTNVM11_DISABLE_MULR_FIX
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM11
argument_list|,
name|fext_nvm11
argument_list|)
expr_stmt|;
comment|/* do nothing if we're not in faulty state, or if the queue is empty */
name|tdlen
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDLEN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|hang_state
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCICFG_DESC_RING_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hang_state
operator|&
name|FLUSH_DESC_REQUIRED
operator|)
operator|||
operator|!
name|tdlen
condition|)
return|return;
name|em_flush_tx_ring
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* recheck, maybe the fault is caused by the rx ring */
name|hang_state
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCICFG_DESC_RING_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|hang_state
operator|&
name|FLUSH_DESC_REQUIRED
condition|)
name|em_flush_rx_ring
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize the hardware to a configuration  *  as specified by the adapter structure.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_reset
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u16
name|rx_buffer_size
decl_stmt|;
name|u32
name|pba
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_reset: begin"
argument_list|)
expr_stmt|;
comment|/* Set up smart power down as default off on newer adapters. */
if|if
condition|(
operator|!
name|em_smart_pwr_down
operator|&&
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82571
operator|||
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82572
operator|)
condition|)
block|{
name|u16
name|phy_tmp
init|=
literal|0
decl_stmt|;
comment|/* Speed up time to link by disabling smart power down. */
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
operator|&
name|phy_tmp
argument_list|)
expr_stmt|;
name|phy_tmp
operator|&=
operator|~
name|IGP02E1000_PM_SPD
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|phy_tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Packet Buffer Allocation (PBA) 	 * Writing PBA sets the receive portion of the buffer 	 * the remainder is used for the transmit buffer. 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
comment|/* Total Packet Buffer on these is 48K */
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
case|case
name|e1000_80003es2lan
case|:
name|pba
operator|=
name|E1000_PBA_32K
expr_stmt|;
comment|/* 32K for Rx, 16K for Tx */
break|break;
case|case
name|e1000_82573
case|:
comment|/* 82573: Total Packet Buffer is 32K */
name|pba
operator|=
name|E1000_PBA_12K
expr_stmt|;
comment|/* 12K for Rx, 20K for Tx */
break|break;
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|pba
operator|=
name|E1000_PBA_20K
expr_stmt|;
comment|/* 20K for Rx, 20K for Tx */
break|break;
case|case
name|e1000_ich8lan
case|:
name|pba
operator|=
name|E1000_PBA_8K
expr_stmt|;
break|break;
case|case
name|e1000_ich9lan
case|:
case|case
name|e1000_ich10lan
case|:
comment|/* Boost Receive side for jumbo frames */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
operator|>
literal|4096
condition|)
name|pba
operator|=
name|E1000_PBA_14K
expr_stmt|;
else|else
name|pba
operator|=
name|E1000_PBA_10K
expr_stmt|;
break|break;
case|case
name|e1000_pchlan
case|:
case|case
name|e1000_pch2lan
case|:
case|case
name|e1000_pch_lpt
case|:
case|case
name|e1000_pch_spt
case|:
name|pba
operator|=
name|E1000_PBA_26K
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
operator|>
literal|8192
condition|)
name|pba
operator|=
name|E1000_PBA_40K
expr_stmt|;
comment|/* 40K for Rx, 24K for Tx */
else|else
name|pba
operator|=
name|E1000_PBA_48K
expr_stmt|;
comment|/* 48K for Rx, 16K for Tx */
block|}
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PBA
argument_list|,
name|pba
argument_list|)
expr_stmt|;
comment|/* 	 * These parameters control the automatic generation (Tx) and 	 * response (Rx) to Ethernet PAUSE frames. 	 * - High water mark should allow for at least two frames to be 	 *   received after sending an XOFF. 	 * - Low water mark works best when it is very near the high water mark. 	 *   This allows the receiver to restart by sending XON when it has 	 *   drained a bit. Here we use an arbitrary value of 1500 which will 	 *   restart after one full frame is pulled from the buffer. There 	 *   could be several smaller frames in the buffer and if so they will 	 *   not trigger the XON until their total number reduces the buffer 	 *   by 1500. 	 * - The pause time is fairly large at 1000 x 512ns = 512 usec. 	 */
name|rx_buffer_size
operator|=
operator|(
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA
argument_list|)
operator|&
literal|0xffff
operator|)
operator|<<
literal|10
operator|)
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|=
name|rx_buffer_size
operator|-
name|roundup2
argument_list|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|low_water
operator|=
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|-
literal|1500
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|fc
condition|)
comment|/* locally set flow control value? */
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|adapter
operator|->
name|fc
expr_stmt|;
else|else
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|e1000_fc_full
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_80003es2lan
condition|)
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|=
literal|0xFFFF
expr_stmt|;
else|else
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|=
name|EM_FC_PAUSE_TIME
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|send_xon
operator|=
name|TRUE
expr_stmt|;
comment|/* Device specific overrides/settings */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_pchlan
case|:
comment|/* Workaround: no TX flow ctrl for PCH */
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|e1000_fc_rx_pause
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|=
literal|0xFFFF
expr_stmt|;
comment|/* override */
if|if
condition|(
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
operator|>
name|ETHERMTU
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|=
literal|0x3500
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|low_water
operator|=
literal|0x1500
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|=
literal|0x5000
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|low_water
operator|=
literal|0x3000
expr_stmt|;
block|}
name|hw
operator|->
name|fc
operator|.
name|refresh_time
operator|=
literal|0x1000
expr_stmt|;
break|break;
case|case
name|e1000_pch2lan
case|:
case|case
name|e1000_pch_lpt
case|:
case|case
name|e1000_pch_spt
case|:
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|=
literal|0x5C20
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|low_water
operator|=
literal|0x5048
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|=
literal|0x0650
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|refresh_time
operator|=
literal|0x0400
expr_stmt|;
comment|/* Jumbos need adjusted PBA */
if|if
condition|(
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
operator|>
name|ETHERMTU
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA
argument_list|,
literal|12
argument_list|)
expr_stmt|;
else|else
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA
argument_list|,
literal|26
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_ich9lan
case|:
case|case
name|e1000_ich10lan
case|:
if|if
condition|(
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
operator|>
name|ETHERMTU
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|=
literal|0x2800
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|low_water
operator|=
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|-
literal|8
expr_stmt|;
break|break;
block|}
comment|/* else fall thru */
default|default:
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_80003es2lan
condition|)
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|=
literal|0xFFFF
expr_stmt|;
break|break;
block|}
comment|/* I219 needs some special flushing to avoid hangs */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch_spt
condition|)
name|em_flush_desc_rings
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Issue a global reset */
name|e1000_reset_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|em_disable_aspm
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* and a re-init */
if|if
condition|(
name|e1000_init_hw
argument_list|(
name|hw
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hardware Initialization Failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_VET
argument_list|,
name|ETHERTYPE_VLAN
argument_list|)
expr_stmt|;
name|e1000_get_phy_info
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup networking device structure and register an interface.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_setup_interface
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|if_t
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_setup_interface: begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
operator|=
name|if_gethandle
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|if_setdev
argument_list|(
name|ifp
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|if_setinitfn
argument_list|(
name|ifp
argument_list|,
name|em_init
argument_list|)
expr_stmt|;
name|if_setsoftc
argument_list|(
name|ifp
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|if_setflags
argument_list|(
name|ifp
argument_list|,
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
argument_list|)
expr_stmt|;
name|if_setioctlfn
argument_list|(
name|ifp
argument_list|,
name|em_ioctl
argument_list|)
expr_stmt|;
name|if_setgetcounterfn
argument_list|(
name|ifp
argument_list|,
name|em_get_counter
argument_list|)
expr_stmt|;
comment|/* TSO parameters */
name|ifp
operator|->
name|if_hw_tsomax
operator|=
name|IP_MAXPACKET
expr_stmt|;
comment|/* Take m_pullup(9)'s in em_xmit() w/ TSO into acount. */
name|ifp
operator|->
name|if_hw_tsomaxsegcount
operator|=
name|EM_MAX_SCATTER
operator|-
literal|5
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegsize
operator|=
name|EM_TSO_SEG_SIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
comment|/* Multiqueue stack interface */
name|if_settransmitfn
argument_list|(
name|ifp
argument_list|,
name|em_mq_start
argument_list|)
expr_stmt|;
name|if_setqflushfn
argument_list|(
name|ifp
argument_list|,
name|em_qflush
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_setstartfn
argument_list|(
name|ifp
argument_list|,
name|em_start
argument_list|)
expr_stmt|;
name|if_setsendqlen
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|num_tx_desc
operator|-
literal|1
argument_list|)
expr_stmt|;
name|if_setsendqready
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
name|if_setcapabilities
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_setcapenable
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_HWCSUM
operator||
name|IFCAP_VLAN_HWCSUM
operator||
name|IFCAP_TSO4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we 	 * support full VLAN capability 	 */
name|if_setifheaderlen
argument_list|(
name|ifp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
argument_list|)
expr_stmt|;
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_MTU
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_setcapenable
argument_list|(
name|ifp
argument_list|,
name|if_getcapabilities
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	** Don't turn this on by default, if vlans are 	** created on another pseudo device (eg. lagg) 	** then vlan events are not passed thru, breaking 	** operation, but with HW FILTER off it works. If 	** using vlans directly on the em driver you can 	** enable this and get full hardware tag filtering. 	*/
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_VLAN_HWFILTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_POLLING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Enable only WOL MAGIC by default */
if|if
condition|(
name|adapter
operator|->
name|wol
condition|)
block|{
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_WOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_setcapenablebit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_WOL_MAGIC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
name|ifmedia_init
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|em_media_change
argument_list|,
name|em_media_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_fiber
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
operator|)
condition|)
block|{
name|u_char
name|fiber_type
init|=
name|IFM_1000_SX
decl_stmt|;
comment|/* default type */
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|fiber_type
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|fiber_type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|type
operator|!=
name|e1000_phy_ife
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Manage DMA'able memory.  */
end_comment

begin_function
specifier|static
name|void
name|em_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
condition|)
return|return;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_dma_malloc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|struct
name|em_dma_alloc
modifier|*
name|dma
parameter_list|,
name|int
name|mapflags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent */
name|EM_DBA_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|size
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: bus_dma_tag_create failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_0
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: bus_dmamem_alloc(%ju) failed: %d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|size
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_2
goto|;
block|}
name|dma
operator|->
name|dma_paddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|size
argument_list|,
name|em_dmamap_cb
argument_list|,
operator|&
name|dma
operator|->
name|dma_paddr
argument_list|,
name|mapflags
operator||
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|dma
operator|->
name|dma_paddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: bus_dmamap_load failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_3
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail_3
label|:
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|fail_2
label|:
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|fail_0
label|:
name|dma
operator|->
name|dma_tag
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_dma_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|em_dma_alloc
modifier|*
name|dma
parameter_list|)
block|{
if|if
condition|(
name|dma
operator|->
name|dma_tag
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dma
operator|->
name|dma_paddr
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_paddr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dma
operator|->
name|dma_vaddr
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_vaddr
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_tag
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for the transmit and receive rings, and then  *  the descriptors associated with each, called only once at attach.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_allocate_queues
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|NULL
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|NULL
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|tsize
decl_stmt|,
name|error
init|=
name|E1000_SUCCESS
decl_stmt|;
name|int
name|txconf
init|=
literal|0
decl_stmt|,
name|rxconf
init|=
literal|0
decl_stmt|;
comment|/* Allocate the TX ring struct memory */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|tx_rings
operator|=
operator|(
expr|struct
name|tx_ring
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tx_ring
argument_list|)
operator|*
name|adapter
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX ring memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Now allocate the RX */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|rx_rings
operator|=
operator|(
expr|struct
name|rx_ring
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rx_ring
argument_list|)
operator|*
name|adapter
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RX ring memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|rx_fail
goto|;
block|}
name|tsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
argument_list|,
name|EM_DBA_ALIGN
argument_list|)
expr_stmt|;
comment|/* 	 * Now set up the TX queues, txconf is needed to handle the 	 * possibility that things fail midcourse and we need to 	 * undo memory gracefully 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txconf
operator|++
control|)
block|{
comment|/* Set up some basics */
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|txr
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|txr
operator|->
name|me
operator|=
name|i
expr_stmt|;
comment|/* Initialize the TX lock */
name|snprintf
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:tx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|txr
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|txr
operator|->
name|tx_mtx
argument_list|,
name|txr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|em_dma_malloc
argument_list|(
name|adapter
argument_list|,
name|tsize
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
name|txr
operator|->
name|tx_base
operator|=
operator|(
expr|struct
name|e1000_tx_desc
operator|*
operator|)
name|txr
operator|->
name|txdma
operator|.
name|dma_vaddr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|tx_base
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|em_allocate_transmit_buffers
argument_list|(
name|txr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up transmit buffers\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
comment|/* Allocate a buf ring */
name|txr
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
literal|4096
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|txr
operator|->
name|tx_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Next the RX queues... 	 */
name|rsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|e1000_rx_desc_extended
argument_list|)
argument_list|,
name|EM_DBA_ALIGN
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxconf
operator|++
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|rxr
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|rxr
operator|->
name|me
operator|=
name|i
expr_stmt|;
comment|/* Initialize the RX lock */
name|snprintf
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:rx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|txr
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rxr
operator|->
name|rx_mtx
argument_list|,
name|rxr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|em_dma_malloc
argument_list|(
name|adapter
argument_list|,
name|rsize
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RxDescriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
name|rxr
operator|->
name|rx_base
operator|=
operator|(
expr|union
name|e1000_rx_desc_extended
operator|*
operator|)
name|rxr
operator|->
name|rxdma
operator|.
name|dma_vaddr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|rx_base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* Allocate receive buffers for the ring*/
if|if
condition|(
name|em_allocate_receive_buffers
argument_list|(
name|rxr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up receive buffers\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err_rx_desc
label|:
for|for
control|(
name|rxr
operator|=
name|adapter
operator|->
name|rx_rings
init|;
name|rxconf
operator|>
literal|0
condition|;
name|rxr
operator|++
operator|,
name|rxconf
operator|--
control|)
name|em_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|)
expr_stmt|;
name|err_tx_desc
label|:
for|for
control|(
name|txr
operator|=
name|adapter
operator|->
name|tx_rings
init|;
name|txconf
operator|>
literal|0
condition|;
name|txr
operator|++
operator|,
name|txconf
operator|--
control|)
name|em_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|rx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rx_fail
label|:
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|buf_ring_free
argument_list|(
name|txr
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|adapter
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for tx_buffer structures. The tx_buffer stores all  *  the information needed to transmit a packet on the wire. This is  *  called only once at attach, setup is done every reset.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_allocate_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|em_txbuffer
modifier|*
name|txbuf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Setup DMA descriptor areas. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|EM_TSO_SIZE
argument_list|,
comment|/* maxsize */
name|EM_MAX_SCATTER
argument_list|,
comment|/* nsegments */
name|PAGE_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|txr
operator|->
name|txtag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|txr
operator|->
name|tx_buffers
operator|=
operator|(
expr|struct
name|em_txbuffer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|em_txbuffer
argument_list|)
operator|*
name|adapter
operator|->
name|num_tx_desc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate tx_buffer memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create the descriptor buffer dma maps */
name|txbuf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
operator|,
name|txbuf
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
literal|0
argument_list|,
operator|&
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create TX DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
literal|0
return|;
name|fail
label|:
comment|/* We free all, it handles case where we are in the middle */
name|em_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize a transmit ring.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_setup_transmit_ring
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|em_txbuffer
modifier|*
name|txbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|netmap_getna
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
comment|/* Clear the old descriptor contents */
name|EM_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|slot
operator|=
name|netmap_reset
argument_list|(
name|na
argument_list|,
name|NR_TX
argument_list|,
name|txr
operator|->
name|me
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|tx_base
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
operator|)
operator|*
name|adapter
operator|->
name|num_tx_desc
argument_list|)
expr_stmt|;
comment|/* Reset indices */
name|txr
operator|->
name|next_avail_desc
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|next_to_clean
operator|=
literal|0
expr_stmt|;
comment|/* Free any existing tx buffers. */
name|txbuf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
operator|,
name|txbuf
operator|++
control|)
block|{
if|if
condition|(
name|txbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|txbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|slot
condition|)
block|{
name|int
name|si
init|=
name|netmap_idx_n2k
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|txr
operator|->
name|me
index|]
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|uint64_t
name|paddr
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|PNMB
argument_list|(
name|na
argument_list|,
name|slot
operator|+
name|si
argument_list|,
operator|&
name|paddr
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tx_base
index|[
name|i
index|]
operator|.
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
comment|/* reload the map for netmap mode */
name|netmap_load_map
argument_list|(
name|na
argument_list|,
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
comment|/* clear the watch index */
name|txbuf
operator|->
name|next_eop
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Set number of descriptors available */
name|txr
operator|->
name|tx_avail
operator|=
name|adapter
operator|->
name|num_tx_desc
expr_stmt|;
name|txr
operator|->
name|busy
operator|=
name|EM_TX_IDLE
expr_stmt|;
comment|/* Clear checksum offload context. */
name|txr
operator|->
name|last_hw_offload
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|last_hw_ipcss
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|last_hw_ipcso
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|last_hw_tucss
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|last_hw_tucso
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize all transmit rings.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_setup_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
name|em_setup_transmit_ring
argument_list|(
name|txr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Enable transmit unit.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_initialize_transmit_unit
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|tctl
decl_stmt|,
name|txdctl
init|=
literal|0
decl_stmt|,
name|tarc
decl_stmt|,
name|tipg
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_initialize_transmit_unit: begin"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|u64
name|bus_addr
init|=
name|txr
operator|->
name|txdma
operator|.
name|dma_paddr
decl_stmt|;
comment|/* Base and Len of TX Ring */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDLEN
argument_list|(
name|i
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDBAH
argument_list|(
name|i
argument_list|)
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|bus_addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDBAL
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|u32
operator|)
name|bus_addr
argument_list|)
expr_stmt|;
comment|/* Init the HEAD/TAIL indices */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HW_DEBUGOUT2
argument_list|(
literal|"Base = %x, Length = %x\n"
argument_list|,
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDBAL
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDLEN
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|busy
operator|=
name|EM_TX_IDLE
expr_stmt|;
name|txdctl
operator|=
literal|0
expr_stmt|;
comment|/* clear txdctl */
name|txdctl
operator||=
literal|0x1f
expr_stmt|;
comment|/* PTHRESH */
name|txdctl
operator||=
literal|1
operator|<<
literal|8
expr_stmt|;
comment|/* HTHRESH */
name|txdctl
operator||=
literal|1
operator|<<
literal|16
expr_stmt|;
comment|/* WTHRESH */
name|txdctl
operator||=
literal|1
operator|<<
literal|22
expr_stmt|;
comment|/* Reserved bit 22 must always be 1 */
name|txdctl
operator||=
name|E1000_TXDCTL_GRAN
expr_stmt|;
name|txdctl
operator||=
literal|1
operator|<<
literal|25
expr_stmt|;
comment|/* LWTHRESH */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|txdctl
argument_list|)
expr_stmt|;
block|}
comment|/* Set the default values for the Tx Inter Packet Gap timer */
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_80003es2lan
case|:
name|tipg
operator|=
name|DEFAULT_82543_TIPG_IPGR1
expr_stmt|;
name|tipg
operator||=
name|DEFAULT_80003ES2LAN_TIPG_IPGR2
operator|<<
name|E1000_TIPG_IPGR2_SHIFT
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_fiber
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
operator|)
condition|)
name|tipg
operator|=
name|DEFAULT_82543_TIPG_IPGT_FIBER
expr_stmt|;
else|else
name|tipg
operator|=
name|DEFAULT_82543_TIPG_IPGT_COPPER
expr_stmt|;
name|tipg
operator||=
name|DEFAULT_82543_TIPG_IPGR1
operator|<<
name|E1000_TIPG_IPGR1_SHIFT
expr_stmt|;
name|tipg
operator||=
name|DEFAULT_82543_TIPG_IPGR2
operator|<<
name|E1000_TIPG_IPGR2_SHIFT
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TIPG
argument_list|,
name|tipg
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TIDV
argument_list|,
name|adapter
operator|->
name|tx_int_delay
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82540
condition|)
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TADV
argument_list|,
name|adapter
operator|->
name|tx_abs_int_delay
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82571
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82572
operator|)
condition|)
block|{
name|tarc
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tarc
operator||=
name|TARC_SPEED_MODE_BIT
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|tarc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_80003es2lan
condition|)
block|{
comment|/* errata: program both queues to unweighted RR */
name|tarc
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tarc
operator||=
literal|1
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|tarc
argument_list|)
expr_stmt|;
name|tarc
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tarc
operator||=
literal|1
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|1
argument_list|)
argument_list|,
name|tarc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
block|{
name|tarc
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tarc
operator||=
name|TARC_ERRATA_BIT
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
block|{
name|tarc
operator||=
operator|(
name|TARC_COMPENSATION_MODE
operator||
name|TARC_MQ_FIX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|tarc
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|1
argument_list|)
argument_list|,
name|tarc
argument_list|)
expr_stmt|;
block|}
else|else
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|tarc
argument_list|)
expr_stmt|;
block|}
name|adapter
operator|->
name|txd_cmd
operator|=
name|E1000_TXD_CMD_IFCS
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|tx_int_delay
operator|.
name|value
operator|>
literal|0
condition|)
name|adapter
operator|->
name|txd_cmd
operator||=
name|E1000_TXD_CMD_IDE
expr_stmt|;
comment|/* Program the Transmit Control Register */
name|tctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TCTL
argument_list|)
expr_stmt|;
name|tctl
operator|&=
operator|~
name|E1000_TCTL_CT
expr_stmt|;
name|tctl
operator||=
operator|(
name|E1000_TCTL_PSP
operator||
name|E1000_TCTL_RTLC
operator||
name|E1000_TCTL_EN
operator||
operator|(
name|E1000_COLLISION_THRESHOLD
operator|<<
name|E1000_CT_SHIFT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82571
condition|)
name|tctl
operator||=
name|E1000_TCTL_MULR
expr_stmt|;
comment|/* This write will effectively turn on the transmit unit. */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|tctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch_spt
condition|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IOSFPC
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_RCTL_RDMTS_HEX
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IOSFPC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_TARC0_CB_MULTIQ_3_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free all transmit rings.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_free_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|EM_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|em_free_transmit_buffers
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|em_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|EM_TX_LOCK_DESTROY
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|adapter
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free transmit ring related data structures.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_free_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|em_txbuffer
modifier|*
name|txbuf
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"free_transmit_ring: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_buffers
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
control|)
block|{
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|txbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|txbuf
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
name|txbuf
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|txbuf
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
name|txbuf
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
if|if
condition|(
name|txr
operator|->
name|br
operator|!=
name|NULL
condition|)
name|buf_ring_free
argument_list|(
name|txr
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|txr
operator|->
name|tx_buffers
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|txr
operator|->
name|tx_buffers
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tx_buffers
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txr
operator|->
name|txtag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|)
expr_stmt|;
name|txr
operator|->
name|txtag
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  The offload context is protocol specific (TCP/UDP) and thus  *  only needs to be set when the protocol changes. The occasion  *  of a context change can be a performance detriment, and  *  might be better just disabled. The reason arises in the way  *  in which the controller supports pipelined requests from the  *  Tx data DMA. Up to four requests can be pipelined, and they may  *  belong to the same packet or to multiple packets. However all  *  requests for one packet are issued before a request is issued  *  for a subsequent packet and if a request for the next packet  *  requires a context change, that request will be stalled  *  until the previous request completes. This means setting up  *  a new context effectively disables pipelined Tx data DMA which  *  in turn greatly slow down performance to send small sized  *  frames.   **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_transmit_checksum_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|int
name|ip_off
parameter_list|,
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|u32
modifier|*
name|txd_upper
parameter_list|,
name|u32
modifier|*
name|txd_lower
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|e1000_context_desc
modifier|*
name|TXD
init|=
name|NULL
decl_stmt|;
name|struct
name|em_txbuffer
modifier|*
name|tx_buffer
decl_stmt|;
name|int
name|cur
decl_stmt|,
name|hdr_len
decl_stmt|;
name|u32
name|cmd
init|=
literal|0
decl_stmt|;
name|u16
name|offload
init|=
literal|0
decl_stmt|;
name|u8
name|ipcso
decl_stmt|,
name|ipcss
decl_stmt|,
name|tucso
decl_stmt|,
name|tucss
decl_stmt|;
name|ipcss
operator|=
name|ipcso
operator|=
name|tucss
operator|=
name|tucso
operator|=
literal|0
expr_stmt|;
name|hdr_len
operator|=
name|ip_off
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|cur
operator|=
name|txr
operator|->
name|next_avail_desc
expr_stmt|;
comment|/* Setup of IP header checksum. */
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
condition|)
block|{
operator|*
name|txd_upper
operator||=
name|E1000_TXD_POPTS_IXSM
operator|<<
literal|8
expr_stmt|;
name|offload
operator||=
name|CSUM_IP
expr_stmt|;
name|ipcss
operator|=
name|ip_off
expr_stmt|;
name|ipcso
operator|=
name|ip_off
operator|+
name|offsetof
argument_list|(
expr|struct
name|ip
argument_list|,
name|ip_sum
argument_list|)
expr_stmt|;
comment|/* 		 * Start offset for header checksum calculation. 		 * End offset for header checksum calculation. 		 * Offset of place to put the checksum. 		 */
name|TXD
operator|=
operator|(
expr|struct
name|e1000_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|cur
index|]
expr_stmt|;
name|TXD
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcss
operator|=
name|ipcss
expr_stmt|;
name|TXD
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcse
operator|=
name|htole16
argument_list|(
name|hdr_len
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcso
operator|=
name|ipcso
expr_stmt|;
name|cmd
operator||=
name|E1000_TXD_CMD_IP
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
condition|)
block|{
operator|*
name|txd_lower
operator|=
name|E1000_TXD_CMD_DEXT
operator||
name|E1000_TXD_DTYP_D
expr_stmt|;
operator|*
name|txd_upper
operator||=
name|E1000_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
name|offload
operator||=
name|CSUM_TCP
expr_stmt|;
name|tucss
operator|=
name|hdr_len
expr_stmt|;
name|tucso
operator|=
name|hdr_len
operator|+
name|offsetof
argument_list|(
expr|struct
name|tcphdr
argument_list|,
name|th_sum
argument_list|)
expr_stmt|;
comment|/* 		 * The 82574L can only remember the *last* context used 		 * regardless of queue that it was use for.  We cannot reuse 		 * contexts on this hardware platform and must generate a new 		 * context every time.  82574L hardware spec, section 7.2.6, 		 * second note. 		 */
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|<
literal|2
condition|)
block|{
comment|/*  		 	* Setting up new checksum offload context for every 			* frames takes a lot of processing time for hardware. 			* This also reduces performance a lot for small sized 			* frames so avoid it if driver can use previously 			* configured checksum offload context.  		 	*/
if|if
condition|(
name|txr
operator|->
name|last_hw_offload
operator|==
name|offload
condition|)
block|{
if|if
condition|(
name|offload
operator|&
name|CSUM_IP
condition|)
block|{
if|if
condition|(
name|txr
operator|->
name|last_hw_ipcss
operator|==
name|ipcss
operator|&&
name|txr
operator|->
name|last_hw_ipcso
operator|==
name|ipcso
operator|&&
name|txr
operator|->
name|last_hw_tucss
operator|==
name|tucss
operator|&&
name|txr
operator|->
name|last_hw_tucso
operator|==
name|tucso
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
name|txr
operator|->
name|last_hw_tucss
operator|==
name|tucss
operator|&&
name|txr
operator|->
name|last_hw_tucso
operator|==
name|tucso
condition|)
return|return;
block|}
block|}
name|txr
operator|->
name|last_hw_offload
operator|=
name|offload
expr_stmt|;
name|txr
operator|->
name|last_hw_tucss
operator|=
name|tucss
expr_stmt|;
name|txr
operator|->
name|last_hw_tucso
operator|=
name|tucso
expr_stmt|;
block|}
comment|/*  		 * Start offset for payload checksum calculation.  		 * End offset for payload checksum calculation.  		 * Offset of place to put the checksum.  		 */
name|TXD
operator|=
operator|(
expr|struct
name|e1000_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|cur
index|]
expr_stmt|;
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucss
operator|=
name|hdr_len
expr_stmt|;
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucse
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucso
operator|=
name|tucso
expr_stmt|;
name|cmd
operator||=
name|E1000_TXD_CMD_TCP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
condition|)
block|{
operator|*
name|txd_lower
operator|=
name|E1000_TXD_CMD_DEXT
operator||
name|E1000_TXD_DTYP_D
expr_stmt|;
operator|*
name|txd_upper
operator||=
name|E1000_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
name|tucss
operator|=
name|hdr_len
expr_stmt|;
name|tucso
operator|=
name|hdr_len
operator|+
name|offsetof
argument_list|(
expr|struct
name|udphdr
argument_list|,
name|uh_sum
argument_list|)
expr_stmt|;
comment|/* 		 * The 82574L can only remember the *last* context used 		 * regardless of queue that it was use for.  We cannot reuse 		 * contexts on this hardware platform and must generate a new 		 * context every time.  82574L hardware spec, section 7.2.6, 		 * second note. 		 */
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|<
literal|2
condition|)
block|{
comment|/*  		 	* Setting up new checksum offload context for every 			* frames takes a lot of processing time for hardware. 			* This also reduces performance a lot for small sized 			* frames so avoid it if driver can use previously 			* configured checksum offload context.  		 	*/
if|if
condition|(
name|txr
operator|->
name|last_hw_offload
operator|==
name|offload
condition|)
block|{
if|if
condition|(
name|offload
operator|&
name|CSUM_IP
condition|)
block|{
if|if
condition|(
name|txr
operator|->
name|last_hw_ipcss
operator|==
name|ipcss
operator|&&
name|txr
operator|->
name|last_hw_ipcso
operator|==
name|ipcso
operator|&&
name|txr
operator|->
name|last_hw_tucss
operator|==
name|tucss
operator|&&
name|txr
operator|->
name|last_hw_tucso
operator|==
name|tucso
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
name|txr
operator|->
name|last_hw_tucss
operator|==
name|tucss
operator|&&
name|txr
operator|->
name|last_hw_tucso
operator|==
name|tucso
condition|)
return|return;
block|}
block|}
name|txr
operator|->
name|last_hw_offload
operator|=
name|offload
expr_stmt|;
name|txr
operator|->
name|last_hw_tucss
operator|=
name|tucss
expr_stmt|;
name|txr
operator|->
name|last_hw_tucso
operator|=
name|tucso
expr_stmt|;
block|}
comment|/*  		 * Start offset for header checksum calculation.  		 * End offset for header checksum calculation.  		 * Offset of place to put the checksum.  		 */
name|TXD
operator|=
operator|(
expr|struct
name|e1000_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|cur
index|]
expr_stmt|;
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucss
operator|=
name|tucss
expr_stmt|;
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucse
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucso
operator|=
name|tucso
expr_stmt|;
block|}
if|if
condition|(
name|offload
operator|&
name|CSUM_IP
condition|)
block|{
name|txr
operator|->
name|last_hw_ipcss
operator|=
name|ipcss
expr_stmt|;
name|txr
operator|->
name|last_hw_ipcso
operator|=
name|ipcso
expr_stmt|;
block|}
name|TXD
operator|->
name|tcp_seg_setup
operator|.
name|data
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|cmd_and_length
operator|=
name|htole32
argument_list|(
name|adapter
operator|->
name|txd_cmd
operator||
name|E1000_TXD_CMD_DEXT
operator||
name|cmd
argument_list|)
expr_stmt|;
name|tx_buffer
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|cur
index|]
expr_stmt|;
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|tx_buffer
operator|->
name|next_eop
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|cur
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|cur
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|tx_avail
operator|--
expr_stmt|;
name|txr
operator|->
name|next_avail_desc
operator|=
name|cur
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Setup work for hardware segmentation offload (TSO)  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_tso_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|int
name|ip_off
parameter_list|,
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|tp
parameter_list|,
name|u32
modifier|*
name|txd_upper
parameter_list|,
name|u32
modifier|*
name|txd_lower
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|e1000_context_desc
modifier|*
name|TXD
decl_stmt|;
name|struct
name|em_txbuffer
modifier|*
name|tx_buffer
decl_stmt|;
name|int
name|cur
decl_stmt|,
name|hdr_len
decl_stmt|;
comment|/* 	 * In theory we can use the same TSO context if and only if 	 * frame is the same type(IP/TCP) and the same MSS. However 	 * checking whether a frame has the same IP/TCP structure is 	 * hard thing so just ignore that and always restablish a 	 * new TSO context. 	 */
name|hdr_len
operator|=
name|ip_off
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
operator|(
name|tp
operator|->
name|th_off
operator|<<
literal|2
operator|)
expr_stmt|;
operator|*
name|txd_lower
operator|=
operator|(
name|E1000_TXD_CMD_DEXT
operator||
comment|/* Extended descr type */
name|E1000_TXD_DTYP_D
operator||
comment|/* Data descr type */
name|E1000_TXD_CMD_TSE
operator|)
expr_stmt|;
comment|/* Do TSE on this packet */
comment|/* IP and/or TCP header checksum calculation and insertion. */
operator|*
name|txd_upper
operator|=
operator|(
name|E1000_TXD_POPTS_IXSM
operator||
name|E1000_TXD_POPTS_TXSM
operator|)
operator|<<
literal|8
expr_stmt|;
name|cur
operator|=
name|txr
operator|->
name|next_avail_desc
expr_stmt|;
name|tx_buffer
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|cur
index|]
expr_stmt|;
name|TXD
operator|=
operator|(
expr|struct
name|e1000_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|cur
index|]
expr_stmt|;
comment|/* 	 * Start offset for header checksum calculation. 	 * End offset for header checksum calculation. 	 * Offset of place put the checksum. 	 */
name|TXD
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcss
operator|=
name|ip_off
expr_stmt|;
name|TXD
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcse
operator|=
name|htole16
argument_list|(
name|ip_off
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcso
operator|=
name|ip_off
operator|+
name|offsetof
argument_list|(
expr|struct
name|ip
argument_list|,
name|ip_sum
argument_list|)
expr_stmt|;
comment|/* 	 * Start offset for payload checksum calculation. 	 * End offset for payload checksum calculation. 	 * Offset of place to put the checksum. 	 */
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucss
operator|=
name|ip_off
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucse
operator|=
literal|0
expr_stmt|;
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucso
operator|=
name|ip_off
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|tcphdr
argument_list|,
name|th_sum
argument_list|)
expr_stmt|;
comment|/* 	 * Payload size per packet w/o any headers. 	 * Length of all headers up to payload. 	 */
name|TXD
operator|->
name|tcp_seg_setup
operator|.
name|fields
operator|.
name|mss
operator|=
name|htole16
argument_list|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|tcp_seg_setup
operator|.
name|fields
operator|.
name|hdr_len
operator|=
name|hdr_len
expr_stmt|;
name|TXD
operator|->
name|cmd_and_length
operator|=
name|htole32
argument_list|(
name|adapter
operator|->
name|txd_cmd
operator||
name|E1000_TXD_CMD_DEXT
operator||
comment|/* Extended descr */
name|E1000_TXD_CMD_TSE
operator||
comment|/* TSE context */
name|E1000_TXD_CMD_IP
operator||
comment|/* Do IP csum */
name|E1000_TXD_CMD_TCP
operator||
comment|/* Do TCP checksum */
operator|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hdr_len
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Total len */
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|tx_buffer
operator|->
name|next_eop
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|cur
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|cur
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|tx_avail
operator|--
expr_stmt|;
name|txr
operator|->
name|next_avail_desc
operator|=
name|cur
expr_stmt|;
name|txr
operator|->
name|tx_tso
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Examine each tx_buffer in the used queue. If the hardware is done  *  processing the packet then free associated resources. The  *  tx_buffer is put back on the free queue.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_txeof
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|int
name|first
decl_stmt|,
name|last
decl_stmt|,
name|done
decl_stmt|,
name|processed
decl_stmt|;
name|struct
name|em_txbuffer
modifier|*
name|tx_buffer
decl_stmt|;
name|struct
name|e1000_tx_desc
modifier|*
name|tx_desc
decl_stmt|,
modifier|*
name|eop_desc
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|EM_TX_LOCK_ASSERT
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|netmap_tx_irq
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|me
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DEV_NETMAP */
comment|/* No work, make sure hang detection is disabled */
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
block|{
name|txr
operator|->
name|busy
operator|=
name|EM_TX_IDLE
expr_stmt|;
return|return;
block|}
name|processed
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|txr
operator|->
name|next_to_clean
expr_stmt|;
name|tx_desc
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|first
index|]
expr_stmt|;
name|tx_buffer
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
name|last
operator|=
name|tx_buffer
operator|->
name|next_eop
expr_stmt|;
name|eop_desc
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|last
index|]
expr_stmt|;
comment|/* 	 * What this does is get the index of the 	 * first descriptor AFTER the EOP of the  	 * first packet, that way we can do the 	 * simple comparison on the inner while loop. 	 */
if|if
condition|(
operator|++
name|last
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|last
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|last
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
while|while
condition|(
name|eop_desc
operator|->
name|upper
operator|.
name|fields
operator|.
name|status
operator|&
name|E1000_TXD_STAT_DD
condition|)
block|{
comment|/* We clean the range of the packet */
while|while
condition|(
name|first
operator|!=
name|done
condition|)
block|{
name|tx_desc
operator|->
name|upper
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|tx_desc
operator|->
name|lower
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|tx_desc
operator|->
name|buffer_addr
operator|=
literal|0
expr_stmt|;
operator|++
name|txr
operator|->
name|tx_avail
expr_stmt|;
operator|++
name|processed
expr_stmt|;
if|if
condition|(
name|tx_buffer
operator|->
name|m_head
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tx_buffer
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
name|tx_buffer
operator|->
name|next_eop
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|first
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|first
operator|=
literal|0
expr_stmt|;
name|tx_buffer
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
name|tx_desc
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|first
index|]
expr_stmt|;
block|}
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* See if we can continue to the next packet */
name|last
operator|=
name|tx_buffer
operator|->
name|next_eop
expr_stmt|;
if|if
condition|(
name|last
operator|!=
operator|-
literal|1
condition|)
block|{
name|eop_desc
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|last
index|]
expr_stmt|;
comment|/* Get new done point */
if|if
condition|(
operator|++
name|last
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|last
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|last
expr_stmt|;
block|}
else|else
break|break;
block|}
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|txr
operator|->
name|next_to_clean
operator|=
name|first
expr_stmt|;
comment|/* 	** Hang detection: we know there's work outstanding 	** or the entry return would have been taken, so no 	** descriptor processed here indicates a potential hang. 	** The local timer will examine this and do a reset if needed. 	*/
if|if
condition|(
name|processed
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|txr
operator|->
name|busy
operator|!=
name|EM_TX_HUNG
condition|)
operator|++
name|txr
operator|->
name|busy
expr_stmt|;
block|}
else|else
comment|/* At least one descriptor was cleaned */
name|txr
operator|->
name|busy
operator|=
name|EM_TX_BUSY
expr_stmt|;
comment|/* note this clears HUNG */
comment|/*          * If we have a minimum free, clear IFF_DRV_OACTIVE          * to tell the stack that it is OK to send packets. 	 * Notice that all writes of OACTIVE happen under the 	 * TX lock which, with a single queue, guarantees  	 * sanity.          */
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|>=
name|EM_MAX_SCATTER
condition|)
block|{
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
block|}
comment|/* Disable hang detection if all clean */
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|txr
operator|->
name|busy
operator|=
name|EM_TX_IDLE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Refresh RX descriptor mbufs from system mbuf buffer pool.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_refresh_mbufs
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dma_segment_t
name|segs
decl_stmt|;
name|struct
name|em_rxbuffer
modifier|*
name|rxbuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|,
name|nsegs
decl_stmt|;
name|bool
name|cleaned
init|=
name|FALSE
decl_stmt|;
name|i
operator|=
name|j
operator|=
name|rxr
operator|->
name|next_to_refresh
expr_stmt|;
comment|/* 	** Get one descriptor beyond 	** our work mark to control 	** the loop. 	*/
if|if
condition|(
operator|++
name|j
operator|==
name|adapter
operator|->
name|num_rx_desc
condition|)
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|!=
name|limit
condition|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|m_head
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|adapter
operator|->
name|rx_mbuf_sz
argument_list|)
expr_stmt|;
comment|/* 			** If we have a temporary resource shortage 			** that causes a failure, just abort refresh 			** for now, we will return to this point when 			** reinvoked from em_rxeof. 			*/
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|update
goto|;
block|}
else|else
name|m
operator|=
name|rxbuf
operator|->
name|m_head
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|adapter
operator|->
name|rx_mbuf_sz
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
comment|/* Use bus_dma machinery to setup the memory mapping  */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|,
name|rxbuf
operator|->
name|map
argument_list|,
name|m
argument_list|,
operator|&
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Refresh mbufs: hdr dmamap load"
literal|" failure - %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
goto|goto
name|update
goto|;
block|}
name|rxbuf
operator|->
name|m_head
operator|=
name|m
expr_stmt|;
name|rxbuf
operator|->
name|paddr
operator|=
name|segs
operator|.
name|ds_addr
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|,
name|rxbuf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|em_setup_rxdesc
argument_list|(
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
argument_list|,
name|rxbuf
argument_list|)
expr_stmt|;
name|cleaned
operator|=
name|TRUE
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
comment|/* Next is precalulated for us */
name|rxr
operator|->
name|next_to_refresh
operator|=
name|i
expr_stmt|;
comment|/* Calculate next controlling index */
if|if
condition|(
operator|++
name|j
operator|==
name|adapter
operator|->
name|num_rx_desc
condition|)
name|j
operator|=
literal|0
expr_stmt|;
block|}
name|update
label|:
comment|/* 	** Update the tail pointer only if, 	** and as far as we have refreshed. 	*/
if|if
condition|(
name|cleaned
condition|)
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|rxr
operator|->
name|next_to_refresh
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for rx_buffer structures. Since we use one  *  rx_buffer per received packet, the maximum number of rx_buffer's  *  that we'll need is equal to the number of receive descriptors  *  that we've allocated.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_allocate_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|em_rxbuffer
modifier|*
name|rxbuf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rxr
operator|->
name|rx_buffers
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|em_rxbuffer
argument_list|)
operator|*
name|adapter
operator|->
name|num_rx_desc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|rx_buffers
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate rx_buffer memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MJUM9BYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MJUM9BYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|rxr
operator|->
name|rxtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: bus_dma_tag_create failed %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rxbuf
operator|=
name|rxr
operator|->
name|rx_buffers
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|i
operator|++
operator|,
name|rxbuf
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|,
literal|0
argument_list|,
operator|&
name|rxbuf
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: bus_dmamap_create failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|em_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize a receive ring and its buffers.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_setup_receive_ring
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|struct
name|em_rxbuffer
modifier|*
name|rxbuf
decl_stmt|;
name|bus_dma_segment_t
name|seg
index|[
literal|1
index|]
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|nsegs
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|netmap_getna
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* Clear the ring contents */
name|EM_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|e1000_rx_desc_extended
argument_list|)
argument_list|,
name|EM_DBA_ALIGN
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|rx_base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|slot
operator|=
name|netmap_reset
argument_list|(
name|na
argument_list|,
name|NR_RX
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Free current RX buffer structs and their mbufs 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|i
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|,
name|rxbuf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|,
name|rxbuf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
comment|/* mark as freed */
block|}
block|}
comment|/* Now replenish the mbufs */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|!=
name|adapter
operator|->
name|num_rx_desc
condition|;
operator|++
name|j
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|j
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|slot
condition|)
block|{
name|int
name|si
init|=
name|netmap_idx_n2k
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|rxr
operator|->
name|me
index|]
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|uint64_t
name|paddr
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|PNMB
argument_list|(
name|na
argument_list|,
name|slot
operator|+
name|si
argument_list|,
operator|&
name|paddr
argument_list|)
expr_stmt|;
name|netmap_load_map
argument_list|(
name|na
argument_list|,
name|rxr
operator|->
name|rxtag
argument_list|,
name|rxbuf
operator|->
name|map
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|paddr
operator|=
name|paddr
expr_stmt|;
name|em_setup_rxdesc
argument_list|(
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|j
index|]
argument_list|,
name|rxbuf
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|rxbuf
operator|->
name|m_head
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|adapter
operator|->
name|rx_mbuf_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|m_head
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rxbuf
operator|->
name|m_head
operator|->
name|m_len
operator|=
name|adapter
operator|->
name|rx_mbuf_sz
expr_stmt|;
name|rxbuf
operator|->
name|m_head
operator|->
name|m_flags
operator|&=
operator|~
name|M_HASFCS
expr_stmt|;
comment|/* we strip it */
name|rxbuf
operator|->
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|adapter
operator|->
name|rx_mbuf_sz
expr_stmt|;
comment|/* Get the memory mapping */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|,
name|rxbuf
operator|->
name|map
argument_list|,
name|rxbuf
operator|->
name|m_head
argument_list|,
name|seg
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|,
name|rxbuf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|paddr
operator|=
name|seg
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|em_setup_rxdesc
argument_list|(
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|j
index|]
argument_list|,
name|rxbuf
argument_list|)
expr_stmt|;
block|}
name|rxr
operator|->
name|next_to_check
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|next_to_refresh
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|fail
label|:
name|EM_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize all receive rings.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_setup_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|int
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|q
operator|++
operator|,
name|rxr
operator|++
control|)
if|if
condition|(
name|em_setup_receive_ring
argument_list|(
name|rxr
argument_list|)
condition|)
goto|goto
name|fail
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
comment|/* 	 * Free RX buffers allocated so far, we will only handle 	 * the rings that completed, the failing case will have 	 * cleaned up for itself. 'q' failed, so its the terminus. 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|q
condition|;
operator|++
name|i
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|em_rxbuffer
modifier|*
name|rxbuf
decl_stmt|;
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|,
name|rxbuf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|,
name|rxbuf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|rxr
operator|->
name|next_to_check
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|next_to_refresh
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free all receive rings.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_free_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|em_free_receive_buffers
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
comment|/* Free the ring memory as well */
name|em_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|)
expr_stmt|;
name|EM_RX_LOCK_DESTROY
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|adapter
operator|->
name|rx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free receive ring data structures  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_free_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|struct
name|em_rxbuffer
modifier|*
name|rxbuf
init|=
name|NULL
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"free_receive_buffers: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|rx_buffers
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|i
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|,
name|rxbuf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|,
name|rxbuf
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|,
name|rxbuf
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rxbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|rxr
operator|->
name|rx_buffers
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|rx_buffers
operator|=
name|NULL
expr_stmt|;
name|rxr
operator|->
name|next_to_check
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|next_to_refresh
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rxr
operator|->
name|rxtag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|rxtag
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Enable receive unit.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_initialize_receive_unit
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|rctl
decl_stmt|,
name|rxcsum
decl_stmt|,
name|rfctl
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_initialize_receive_units: begin"
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure receives are disabled while setting 	 * up the descriptor ring 	 */
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
comment|/* Do not disable if ever enabled on this hardware */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82574
operator|)
operator|&&
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82583
operator|)
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|rctl
operator|&
operator|~
name|E1000_RCTL_EN
argument_list|)
expr_stmt|;
comment|/* Setup the Receive Control Register */
name|rctl
operator|&=
operator|~
operator|(
literal|3
operator|<<
name|E1000_RCTL_MO_SHIFT
operator|)
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_EN
operator||
name|E1000_RCTL_BAM
operator||
name|E1000_RCTL_LBM_NO
operator||
name|E1000_RCTL_RDMTS_HALF
operator||
operator|(
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
operator|<<
name|E1000_RCTL_MO_SHIFT
operator|)
expr_stmt|;
comment|/* Do not store bad packets */
name|rctl
operator|&=
operator|~
name|E1000_RCTL_SBP
expr_stmt|;
comment|/* Enable Long Packet receive */
if|if
condition|(
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
operator|>
name|ETHERMTU
condition|)
name|rctl
operator||=
name|E1000_RCTL_LPE
expr_stmt|;
else|else
name|rctl
operator|&=
operator|~
name|E1000_RCTL_LPE
expr_stmt|;
comment|/* Strip the CRC */
if|if
condition|(
operator|!
name|em_disable_crc_stripping
condition|)
name|rctl
operator||=
name|E1000_RCTL_SECRC
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RADV
argument_list|,
name|adapter
operator|->
name|rx_abs_int_delay
operator|.
name|value
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RDTR
argument_list|,
name|adapter
operator|->
name|rx_int_delay
operator|.
name|value
argument_list|)
expr_stmt|;
comment|/* 	 * Set the interrupt throttling rate. Value is calculated 	 * as DEFAULT_ITR = 1/(MAX_INTS_PER_SEC * 256ns) 	 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ITR
argument_list|,
name|DEFAULT_ITR
argument_list|)
expr_stmt|;
comment|/* Use extended rx descriptor formats */
name|rfctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RFCTL
argument_list|)
expr_stmt|;
name|rfctl
operator||=
name|E1000_RFCTL_EXTEN
expr_stmt|;
comment|/* 	** When using MSIX interrupts we need to throttle 	** using the EITR register (82574 only) 	*/
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EITR_82574
argument_list|(
name|i
argument_list|)
argument_list|,
name|DEFAULT_ITR
argument_list|)
expr_stmt|;
comment|/* Disable accelerated acknowledge */
name|rfctl
operator||=
name|E1000_RFCTL_ACK_DIS
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RFCTL
argument_list|,
name|rfctl
argument_list|)
expr_stmt|;
name|rxcsum
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCSUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
name|rxcsum
operator||=
name|E1000_RXCSUM_TUOFL
operator||
name|E1000_RXCSUM_IPOFL
operator||
name|E1000_RXCSUM_PCSD
expr_stmt|;
else|#
directive|else
name|rxcsum
operator||=
name|E1000_RXCSUM_TUOFL
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|rxcsum
operator|&=
operator|~
name|E1000_RXCSUM_TUOFL
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCSUM
argument_list|,
name|rxcsum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
define|#
directive|define
name|RSSKEYLEN
value|10
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
block|{
name|uint8_t
name|rss_key
index|[
literal|4
operator|*
name|RSSKEYLEN
index|]
decl_stmt|;
name|uint32_t
name|reta
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 		* Configure RSS key 		*/
name|arc4rand
argument_list|(
name|rss_key
argument_list|,
sizeof|sizeof
argument_list|(
name|rss_key
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSSKEYLEN
condition|;
operator|++
name|i
control|)
block|{
name|uint32_t
name|rssrk
init|=
literal|0
decl_stmt|;
name|rssrk
operator|=
name|EM_RSSRK_VAL
argument_list|(
name|rss_key
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RSSRK
argument_list|(
name|i
argument_list|)
argument_list|,
name|rssrk
argument_list|)
expr_stmt|;
block|}
comment|/* 		* Configure RSS redirect table in following fashion: 		* (hash& ring_cnt_mask) == rdr_table[(hash& rdr_table_mask)] 		*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|reta
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|uint32_t
name|q
decl_stmt|;
name|q
operator|=
operator|(
name|i
operator|%
name|adapter
operator|->
name|num_queues
operator|)
operator|<<
literal|7
expr_stmt|;
name|reta
operator||=
name|q
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RETA
argument_list|(
name|i
argument_list|)
argument_list|,
name|reta
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MRQC
argument_list|,
name|E1000_MRQC_RSS_ENABLE_2Q
operator||
name|E1000_MRQC_RSS_FIELD_IPV4_TCP
operator||
name|E1000_MRQC_RSS_FIELD_IPV4
operator||
name|E1000_MRQC_RSS_FIELD_IPV6_TCP_EX
operator||
name|E1000_MRQC_RSS_FIELD_IPV6_EX
operator||
name|E1000_MRQC_RSS_FIELD_IPV6
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	** XXX TEMPORARY WORKAROUND: on some systems with 82573 	** long latencies are observed, like Lenovo X60. This 	** change eliminates the problem, but since having positive 	** values in RDTR is a known source of problems on other 	** platforms another solution is being sought. 	*/
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82573
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDTR
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
comment|/* Setup the Base and Length of the Rx Descriptor Ring */
name|u64
name|bus_addr
init|=
name|rxr
operator|->
name|rxdma
operator|.
name|dma_paddr
decl_stmt|;
name|u32
name|rdt
init|=
name|adapter
operator|->
name|num_rx_desc
operator|-
literal|1
decl_stmt|;
comment|/* default */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDLEN
argument_list|(
name|i
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|e1000_rx_desc_extended
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDBAH
argument_list|(
name|i
argument_list|)
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|bus_addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDBAL
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|u32
operator|)
name|bus_addr
argument_list|)
expr_stmt|;
comment|/* Setup the Head and Tail Descriptor Pointers */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* 		 * an init() while a netmap client is active must 		 * preserve the rx buffers passed to userspace. 		 */
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_NETMAP
condition|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|netmap_getna
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|rdt
operator|-=
name|nm_kr_rxspace
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDT
argument_list|(
name|i
argument_list|)
argument_list|,
name|rdt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set PTHRESH for improved jumbo performance 	 * According to 10.2.5.11 of Intel 82574 Datasheet, 	 * RXDCTL(1) is written whenever RXDCTL(0) is written. 	 * Only write to RXDCTL(1) if there is a need for different 	 * settings. 	 */
if|if
condition|(
operator|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_ich9lan
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_ich10lan
operator|)
operator|)
operator|&&
operator|(
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
operator|>
name|ETHERMTU
operator|)
condition|)
block|{
name|u32
name|rxdctl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rxdctl
operator||
literal|3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|rxdctl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|rxdctl
operator||=
literal|0x20
expr_stmt|;
comment|/* PTHRESH */
name|rxdctl
operator||=
literal|4
operator|<<
literal|8
expr_stmt|;
comment|/* HTHRESH */
name|rxdctl
operator||=
literal|4
operator|<<
literal|16
expr_stmt|;
comment|/* WTHRESH */
name|rxdctl
operator||=
literal|1
operator|<<
literal|24
expr_stmt|;
comment|/* Switch to granularity */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxdctl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_pch2lan
condition|)
block|{
if|if
condition|(
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
operator|>
name|ETHERMTU
condition|)
name|e1000_lv_jumbo_workaround_ich8lan
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|e1000_lv_jumbo_workaround_ich8lan
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure VLAN Filters are off */
name|rctl
operator|&=
operator|~
name|E1000_RCTL_VFE
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|rx_mbuf_sz
operator|==
name|MCLBYTES
condition|)
name|rctl
operator||=
name|E1000_RCTL_SZ_2048
expr_stmt|;
elseif|else
if|if
condition|(
name|adapter
operator|->
name|rx_mbuf_sz
operator|==
name|MJUMPAGESIZE
condition|)
name|rctl
operator||=
name|E1000_RCTL_SZ_4096
operator||
name|E1000_RCTL_BSEX
expr_stmt|;
elseif|else
if|if
condition|(
name|adapter
operator|->
name|rx_mbuf_sz
operator|>
name|MJUMPAGESIZE
condition|)
name|rctl
operator||=
name|E1000_RCTL_SZ_8192
operator||
name|E1000_RCTL_BSEX
expr_stmt|;
comment|/* ensure we clear use DTYPE of 00 here */
name|rctl
operator|&=
operator|~
literal|0x00000C00
expr_stmt|;
comment|/* Write out the settings */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine executes in interrupt context. It replenishes  *  the mbufs in the descriptor and sends data which has been  *  dma'ed into host memory to upper layer.  *  *  We loop at most count times if count is> 0, or until done if  *  count< 0.  *    *  For polling we also now return the number of cleaned packets  *********************************************************************/
end_comment

begin_function
specifier|static
name|bool
name|em_rxeof
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|done
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|,
modifier|*
name|sendmp
decl_stmt|;
name|u32
name|status
init|=
literal|0
decl_stmt|;
name|u16
name|len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|processed
decl_stmt|,
name|rxdone
init|=
literal|0
decl_stmt|;
name|bool
name|eop
decl_stmt|;
name|union
name|e1000_rx_desc_extended
modifier|*
name|cur
decl_stmt|;
name|EM_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
comment|/* Sync the ring */
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|netmap_rx_irq
argument_list|(
name|ifp
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
operator|&
name|processed
argument_list|)
condition|)
block|{
name|EM_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
for|for
control|(
name|i
operator|=
name|rxr
operator|->
name|next_to_check
operator|,
name|processed
operator|=
literal|0
init|;
name|count
operator|!=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
name|cur
operator|=
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
expr_stmt|;
name|status
operator|=
name|le32toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
argument_list|)
expr_stmt|;
name|mp
operator|=
name|sendmp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|E1000_RXD_STAT_DD
operator|)
operator|==
literal|0
condition|)
break|break;
name|len
operator|=
name|le16toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|length
argument_list|)
expr_stmt|;
name|eop
operator|=
operator|(
name|status
operator|&
name|E1000_RXD_STAT_EOP
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|E1000_RXDEXT_ERR_FRAME_ERR_MASK
operator|)
operator|||
operator|(
name|rxr
operator|->
name|discard
operator|==
name|TRUE
operator|)
condition|)
block|{
name|adapter
operator|->
name|dropped_pkts
operator|++
expr_stmt|;
operator|++
name|rxr
operator|->
name|rx_discarded
expr_stmt|;
if|if
condition|(
operator|!
name|eop
condition|)
comment|/* Catch subsequent segs */
name|rxr
operator|->
name|discard
operator|=
name|TRUE
expr_stmt|;
else|else
name|rxr
operator|->
name|discard
operator|=
name|FALSE
expr_stmt|;
name|em_rx_discard
argument_list|(
name|rxr
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|next_desc
goto|;
block|}
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|,
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
comment|/* Assign correct length to the current fragment */
name|mp
operator|=
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
operator|.
name|m_head
expr_stmt|;
name|mp
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* Trigger for refresh */
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
operator|.
name|m_head
operator|=
name|NULL
expr_stmt|;
comment|/* First segment? */
if|if
condition|(
name|rxr
operator|->
name|fmp
operator|==
name|NULL
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|=
name|rxr
operator|->
name|lmp
operator|=
name|mp
expr_stmt|;
block|}
else|else
block|{
comment|/* Chain mbuf's together */
name|mp
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|rxr
operator|->
name|lmp
operator|->
name|m_next
operator|=
name|mp
expr_stmt|;
name|rxr
operator|->
name|lmp
operator|=
name|mp
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|eop
condition|)
block|{
operator|--
name|count
expr_stmt|;
name|sendmp
operator|=
name|rxr
operator|->
name|fmp
expr_stmt|;
name|if_setrcvif
argument_list|(
name|sendmp
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|em_receive_checksum
argument_list|(
name|status
argument_list|,
name|sendmp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
operator|>
operator|(
name|MCLBYTES
operator|-
name|ETHER_ALIGN
operator|)
operator|&&
name|em_fixup_rx
argument_list|(
name|rxr
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|skip
goto|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|&
name|E1000_RXD_STAT_VP
condition|)
block|{
name|if_setvtag
argument_list|(
name|sendmp
argument_list|,
name|le16toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|vlan
argument_list|)
argument_list|)
expr_stmt|;
name|sendmp
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
name|skip
label|:
endif|#
directive|endif
name|rxr
operator|->
name|fmp
operator|=
name|rxr
operator|->
name|lmp
operator|=
name|NULL
expr_stmt|;
block|}
name|next_desc
label|:
comment|/* Sync the ring */
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* Zero out the receive descriptors status. */
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
operator|&=
name|htole32
argument_list|(
operator|~
literal|0xFF
argument_list|)
expr_stmt|;
operator|++
name|rxdone
expr_stmt|;
comment|/* cumulative for POLL */
operator|++
name|processed
expr_stmt|;
comment|/* Advance our pointers to the next descriptor. */
if|if
condition|(
operator|++
name|i
operator|==
name|adapter
operator|->
name|num_rx_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Send to the stack */
if|if
condition|(
name|sendmp
operator|!=
name|NULL
condition|)
block|{
name|rxr
operator|->
name|next_to_check
operator|=
name|i
expr_stmt|;
name|EM_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|if_input
argument_list|(
name|ifp
argument_list|,
name|sendmp
argument_list|)
expr_stmt|;
name|EM_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|i
operator|=
name|rxr
operator|->
name|next_to_check
expr_stmt|;
block|}
comment|/* Only refresh mbufs every 8 descriptors */
if|if
condition|(
name|processed
operator|==
literal|8
condition|)
block|{
name|em_refresh_mbufs
argument_list|(
name|rxr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|processed
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Catch any remaining refresh work */
if|if
condition|(
name|e1000_rx_unrefreshed
argument_list|(
name|rxr
argument_list|)
condition|)
name|em_refresh_mbufs
argument_list|(
name|rxr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|next_to_check
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|done
operator|!=
name|NULL
condition|)
operator|*
name|done
operator|=
name|rxdone
expr_stmt|;
name|EM_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|status
operator|&
name|E1000_RXD_STAT_DD
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|em_rx_discard
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|em_rxbuffer
modifier|*
name|rbuf
decl_stmt|;
name|rbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|rxtag
argument_list|,
name|rbuf
operator|->
name|map
argument_list|)
expr_stmt|;
comment|/* Free any previous pieces */
if|if
condition|(
name|rxr
operator|->
name|fmp
operator|!=
name|NULL
condition|)
block|{
name|rxr
operator|->
name|fmp
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|rxr
operator|->
name|fmp
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|rxr
operator|->
name|lmp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	** Free buffer and allow em_refresh_mbufs() 	** to clean up and recharge buffer. 	*/
if|if
condition|(
name|rbuf
operator|->
name|m_head
condition|)
block|{
name|m_free
argument_list|(
name|rbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|rbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
end_ifndef

begin_comment
comment|/*  * When jumbo frames are enabled we should realign entire payload on  * architecures with strict alignment. This is serious design mistake of 8254x  * as it nullifies DMA operations. 8254x just allows RX buffer size to be  * 2048/4096/8192/16384. What we really want is 2048 - ETHER_ALIGN to align its  * payload. On architecures without strict alignment restrictions 8254x still  * performs unaligned memory access which would reduce the performance too.  * To avoid copying over an entire frame to align, we allocate a new mbuf and  * copy ethernet header to the new mbuf. The new mbuf is prepended into the  * existing mbuf chain.  *  * Be aware, best performance of the 8254x is achived only when jumbo frame is  * not used at all on architectures with strict alignment.  */
end_comment

begin_function
specifier|static
name|int
name|em_fixup_rx
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|rxr
operator|->
name|fmp
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
operator|(
name|MCLBYTES
operator|-
name|ETHER_HDR_LEN
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_data
operator|+
name|ETHER_HDR_LEN
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|ETHER_HDR_LEN
expr_stmt|;
block|}
else|else
block|{
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|n
operator|->
name|m_data
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|ETHER_HDR_LEN
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|ETHER_HDR_LEN
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|M_MOVE_PKTHDR
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|adapter
operator|->
name|dropped_pkts
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|rxr
operator|->
name|fmp
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|em_setup_rxdesc
parameter_list|(
name|union
name|e1000_rx_desc_extended
modifier|*
name|rxd
parameter_list|,
specifier|const
name|struct
name|em_rxbuffer
modifier|*
name|rxbuf
parameter_list|)
block|{
name|rxd
operator|->
name|read
operator|.
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|rxbuf
operator|->
name|paddr
argument_list|)
expr_stmt|;
comment|/* DD bits must be cleared */
name|rxd
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Verify that the hardware indicated that the checksum is valid.  *  Inform the stack about the status of checksum so that stack  *  doesn't spend time verifying the checksum.  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_receive_checksum
parameter_list|(
name|uint32_t
name|status
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
comment|/* Ignore Checksum bit is set */
if|if
condition|(
name|status
operator|&
name|E1000_RXD_STAT_IXSM
condition|)
return|return;
comment|/* If the IP checksum exists and there is no IP Checksum error */
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|E1000_RXD_STAT_IPCS
operator||
name|E1000_RXDEXT_STATERR_IPE
operator|)
operator|)
operator|==
name|E1000_RXD_STAT_IPCS
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator|)
expr_stmt|;
block|}
comment|/* TCP or UDP checksum */
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|E1000_RXD_STAT_TCPCS
operator||
name|E1000_RXDEXT_STATERR_TCPE
operator|)
operator|)
operator|==
name|E1000_RXD_STAT_TCPCS
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|E1000_RXD_STAT_UDPCS
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This routine is run via an vlan  * config EVENT  */
end_comment

begin_function
specifier|static
name|void
name|em_register_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_t
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|u32
name|index
decl_stmt|,
name|bit
decl_stmt|;
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|adapter
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid ID */
return|return;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|vtag
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bit
operator|=
name|vtag
operator|&
literal|0x1F
expr_stmt|;
name|adapter
operator|->
name|shadow_vfta
index|[
name|index
index|]
operator||=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
operator|++
name|adapter
operator|->
name|num_vlans
expr_stmt|;
comment|/* Re-init to load the changes */
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is run via an vlan  * unconfig EVENT  */
end_comment

begin_function
specifier|static
name|void
name|em_unregister_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_t
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|u32
name|index
decl_stmt|,
name|bit
decl_stmt|;
if|if
condition|(
name|adapter
operator|!=
name|arg
condition|)
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|vtag
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bit
operator|=
name|vtag
operator|&
literal|0x1F
expr_stmt|;
name|adapter
operator|->
name|shadow_vfta
index|[
name|index
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
operator|--
name|adapter
operator|->
name|num_vlans
expr_stmt|;
comment|/* Re-init to load the changes */
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_setup_vlan_hw_support
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|;
comment|/* 	** We get here thru init_locked, meaning 	** a soft reset, this has already cleared 	** the VFTA and other state, so if there 	** have been no vlan's registered do nothing. 	*/
if|if
condition|(
name|adapter
operator|->
name|num_vlans
operator|==
literal|0
condition|)
return|return;
comment|/* 	** A soft reset zero's out the VFTA, so 	** we need to repopulate it now. 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|EM_VFTA_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|adapter
operator|->
name|shadow_vfta
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VFTA
argument_list|,
name|i
argument_list|,
name|adapter
operator|->
name|shadow_vfta
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_CTRL_VME
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Enable the Filter Table */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|E1000_RCTL_CFIEN
expr_stmt|;
name|reg
operator||=
name|E1000_RCTL_VFE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|ims_mask
init|=
name|IMS_ENABLE_MASK
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EM_EIAC
argument_list|,
name|adapter
operator|->
name|ims
argument_list|)
expr_stmt|;
name|ims_mask
operator||=
name|adapter
operator|->
name|ims
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|ims_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EM_EIAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Bit of a misnomer, what this really means is  * to enable OS management of the system... aka  * to disable special hardware management features   */
end_comment

begin_function
specifier|static
name|void
name|em_init_manageability
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
comment|/* A shared code workaround */
define|#
directive|define
name|E1000_82542_MANC2H
value|E1000_MANC2H
if|if
condition|(
name|adapter
operator|->
name|has_manage
condition|)
block|{
name|int
name|manc2h
init|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC2H
argument_list|)
decl_stmt|;
name|int
name|manc
init|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC
argument_list|)
decl_stmt|;
comment|/* disable hardware interception of ARP */
name|manc
operator|&=
operator|~
operator|(
name|E1000_MANC_ARP_EN
operator|)
expr_stmt|;
comment|/* enable receiving management packets to the host */
name|manc
operator||=
name|E1000_MANC_EN_MNG2HOST
expr_stmt|;
define|#
directive|define
name|E1000_MNG2HOST_PORT_623
value|(1<< 5)
define|#
directive|define
name|E1000_MNG2HOST_PORT_664
value|(1<< 6)
name|manc2h
operator||=
name|E1000_MNG2HOST_PORT_623
expr_stmt|;
name|manc2h
operator||=
name|E1000_MNG2HOST_PORT_664
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC2H
argument_list|,
name|manc2h
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC
argument_list|,
name|manc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Give control back to hardware management  * controller if there is one.  */
end_comment

begin_function
specifier|static
name|void
name|em_release_manageability
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|adapter
operator|->
name|has_manage
condition|)
block|{
name|int
name|manc
init|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC
argument_list|)
decl_stmt|;
comment|/* re-enable hardware interception of ARP */
name|manc
operator||=
name|E1000_MANC_ARP_EN
expr_stmt|;
name|manc
operator|&=
operator|~
name|E1000_MANC_EN_MNG2HOST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC
argument_list|,
name|manc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * em_get_hw_control sets the {CTRL_EXT|FWSM}:DRV_LOAD bit.  * For ASF and Pass Through versions of f/w this means  * that the driver is loaded. For AMT version type f/w  * this means that the network i/f is open.  */
end_comment

begin_function
specifier|static
name|void
name|em_get_hw_control
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|ctrl_ext
decl_stmt|,
name|swsm
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82573
condition|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_SWSM
argument_list|,
name|swsm
operator||
name|E1000_SWSM_DRV_LOAD
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* else */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
operator||
name|E1000_CTRL_EXT_DRV_LOAD
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * em_release_hw_control resets {CTRL_EXT|FWSM}:DRV_LOAD bit.  * For ASF and Pass Through versions of f/w this means that  * the driver is no longer loaded. For AMT versions of the  * f/w this means that the network i/f is closed.  */
end_comment

begin_function
specifier|static
name|void
name|em_release_hw_control
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|ctrl_ext
decl_stmt|,
name|swsm
decl_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|has_manage
condition|)
return|return;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82573
condition|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_SWSM
argument_list|,
name|swsm
operator|&
operator|~
name|E1000_SWSM_DRV_LOAD
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* else */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
operator|&
operator|~
name|E1000_CTRL_EXT_DRV_LOAD
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|em_is_valid_ether_addr
parameter_list|(
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|char
name|zero_addr
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|addr
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|||
operator|(
operator|!
name|bcmp
argument_list|(
name|addr
argument_list|,
name|zero_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Parse the interface capabilities with regard ** to both system management and wake-on-lan for ** later use. */
end_comment

begin_function
specifier|static
name|void
name|em_get_wakeup
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u16
name|eeprom_data
init|=
literal|0
decl_stmt|,
name|device_id
decl_stmt|,
name|apme_mask
decl_stmt|;
name|adapter
operator|->
name|has_manage
operator|=
name|e1000_enable_mng_pass_thru
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|apme_mask
operator|=
name|EM_EEPROM_APME
expr_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
case|case
name|e1000_82583
case|:
name|adapter
operator|->
name|has_amt
operator|=
name|TRUE
expr_stmt|;
comment|/* Falls thru */
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
case|case
name|e1000_80003es2lan
case|:
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|func
operator|==
literal|1
condition|)
block|{
name|e1000_read_nvm
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|NVM_INIT_CONTROL3_PORT_B
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|e1000_read_nvm
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|NVM_INIT_CONTROL3_PORT_A
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_ich8lan
case|:
case|case
name|e1000_ich9lan
case|:
case|case
name|e1000_ich10lan
case|:
case|case
name|e1000_pchlan
case|:
case|case
name|e1000_pch2lan
case|:
name|apme_mask
operator|=
name|E1000_WUC_APME
expr_stmt|;
name|adapter
operator|->
name|has_amt
operator|=
name|TRUE
expr_stmt|;
name|eeprom_data
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUC
argument_list|)
expr_stmt|;
break|break;
default|default:
name|e1000_read_nvm
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|NVM_INIT_CONTROL3_PORT_A
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|eeprom_data
operator|&
name|apme_mask
condition|)
name|adapter
operator|->
name|wol
operator|=
operator|(
name|E1000_WUFC_MAG
operator||
name|E1000_WUFC_MC
operator|)
expr_stmt|;
comment|/*          * We have the eeprom settings, now apply the special cases          * where the eeprom may be wrong or the board won't support          * wake on lan on a particular port 	 */
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_82571EB_FIBER
case|:
comment|/* Wake events only supported on port A for dual fiber 		 * regardless of eeprom setting */
if|if
condition|(
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_FUNC_1
condition|)
name|adapter
operator|->
name|wol
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82571EB_QUAD_COPPER
case|:
case|case
name|E1000_DEV_ID_82571EB_QUAD_FIBER
case|:
case|case
name|E1000_DEV_ID_82571EB_QUAD_COPPER_LP
case|:
comment|/* if quad port adapter, disable WoL on all but port A */
if|if
condition|(
name|global_quad_port_a
operator|!=
literal|0
condition|)
name|adapter
operator|->
name|wol
operator|=
literal|0
expr_stmt|;
comment|/* Reset for multiple quad port adapters */
if|if
condition|(
operator|++
name|global_quad_port_a
operator|==
literal|4
condition|)
name|global_quad_port_a
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Enable PCI Wake On Lan capability  */
end_comment

begin_function
specifier|static
name|void
name|em_enable_wakeup
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|if_t
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|u32
name|pmc
decl_stmt|,
name|ctrl
decl_stmt|,
name|ctrl_ext
decl_stmt|,
name|rctl
decl_stmt|;
name|u16
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_PMG
argument_list|,
operator|&
name|pmc
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return;
comment|/* Advertise the wakeup capability */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_SWDPIN2
operator||
name|E1000_CTRL_SWDPIN3
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
name|E1000_WUC_PME_EN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_pchlan
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_ich9lan
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_ich10lan
operator|)
condition|)
name|e1000_suspend_workarounds_ich8lan
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Keep the laser running on Fiber adapters */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_fiber
operator|||
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
condition|)
block|{
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_SDP3_DATA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
block|}
comment|/* 	** Determine type of Wakeup: note that wol 	** is set with all bits on by default. 	*/
if|if
condition|(
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_WOL_MAGIC
operator|)
operator|==
literal|0
condition|)
name|adapter
operator|->
name|wol
operator|&=
operator|~
name|E1000_WUFC_MAG
expr_stmt|;
if|if
condition|(
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_WOL_MCAST
operator|)
operator|==
literal|0
condition|)
name|adapter
operator|->
name|wol
operator|&=
operator|~
name|E1000_WUFC_MC
expr_stmt|;
else|else
block|{
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_MPE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_pchlan
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
operator|)
condition|)
block|{
if|if
condition|(
name|em_enable_phy_wakeup
argument_list|(
name|adapter
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
name|E1000_WUC_PME_EN
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUFC
argument_list|,
name|adapter
operator|->
name|wol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|type
operator|==
name|e1000_phy_igp_3
condition|)
name|e1000_igp3_phy_powerdown_workaround_ich8lan
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Request PME */
name|status
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|pmc
operator|+
name|PCIR_POWER_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|status
operator|&=
operator|~
operator|(
name|PCIM_PSTAT_PME
operator||
name|PCIM_PSTAT_PMEENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_WOL
condition|)
name|status
operator||=
name|PCIM_PSTAT_PME
operator||
name|PCIM_PSTAT_PMEENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|pmc
operator|+
name|PCIR_POWER_STATUS
argument_list|,
name|status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** WOL in the newer chipset interfaces (pchlan) ** require thing to be copied into the phy */
end_comment

begin_function
specifier|static
name|int
name|em_enable_phy_wakeup
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|mreg
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|u16
name|preg
decl_stmt|;
comment|/* copy MAC RARs to PHY RARs */
name|e1000_copy_rx_addrs_to_phy_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* copy MAC MTA to PHY MTA */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|mta_reg_count
condition|;
name|i
operator|++
control|)
block|{
name|mreg
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|BM_MTA
argument_list|(
name|i
argument_list|)
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|mreg
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|BM_MTA
argument_list|(
name|i
argument_list|)
operator|+
literal|1
argument_list|,
call|(
name|u16
call|)
argument_list|(
operator|(
name|mreg
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* configure PHY Rx Control register */
name|e1000_read_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|BM_RCTL
argument_list|,
operator|&
name|preg
argument_list|)
expr_stmt|;
name|mreg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mreg
operator|&
name|E1000_RCTL_UPE
condition|)
name|preg
operator||=
name|BM_RCTL_UPE
expr_stmt|;
if|if
condition|(
name|mreg
operator|&
name|E1000_RCTL_MPE
condition|)
name|preg
operator||=
name|BM_RCTL_MPE
expr_stmt|;
name|preg
operator|&=
operator|~
operator|(
name|BM_RCTL_MO_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|mreg
operator|&
name|E1000_RCTL_MO_3
condition|)
name|preg
operator||=
operator|(
operator|(
operator|(
name|mreg
operator|&
name|E1000_RCTL_MO_3
operator|)
operator|>>
name|E1000_RCTL_MO_SHIFT
operator|)
operator|<<
name|BM_RCTL_MO_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|mreg
operator|&
name|E1000_RCTL_BAM
condition|)
name|preg
operator||=
name|BM_RCTL_BAM
expr_stmt|;
if|if
condition|(
name|mreg
operator|&
name|E1000_RCTL_PMCF
condition|)
name|preg
operator||=
name|BM_RCTL_PMCF
expr_stmt|;
name|mreg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mreg
operator|&
name|E1000_CTRL_RFCE
condition|)
name|preg
operator||=
name|BM_RCTL_RFCE
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|BM_RCTL
argument_list|,
name|preg
argument_list|)
expr_stmt|;
comment|/* enable PHY wakeup in MAC register */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
name|E1000_WUC_PHY_WAKE
operator||
name|E1000_WUC_PME_EN
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_WUFC
argument_list|,
name|adapter
operator|->
name|wol
argument_list|)
expr_stmt|;
comment|/* configure and enable PHY wakeup in PHY registers */
name|e1000_write_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|BM_WUFC
argument_list|,
name|adapter
operator|->
name|wol
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|BM_WUC
argument_list|,
name|E1000_WUC_PME_EN
argument_list|)
expr_stmt|;
comment|/* activate PHY wakeup */
name|ret
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"Could not acquire PHY\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|BM_WUC_ENABLE_PAGE
operator|<<
name|IGP_PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_ENABLE_REG
argument_list|,
operator|&
name|preg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"Could not read PHY page 769\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|preg
operator||=
name|BM_WUC_ENABLE_BIT
operator||
name|BM_WUC_HOST_WU_BIT
expr_stmt|;
name|ret
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_ENABLE_REG
argument_list|,
name|preg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|printf
argument_list|(
literal|"Could not set PHY Host Wakeup bit\n"
argument_list|)
expr_stmt|;
name|out
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_led_func
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
name|e1000_setup_led
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|e1000_led_on
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e1000_led_off
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|e1000_cleanup_led
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
block|}
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Disable the L0S and L1 LINK states */
end_comment

begin_function
specifier|static
name|void
name|em_disable_aspm
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|base
decl_stmt|,
name|reg
decl_stmt|;
name|u16
name|link_cap
decl_stmt|,
name|link_ctrl
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
break|break;
default|default:
return|return;
block|}
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|base
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|reg
operator|=
name|base
operator|+
name|PCIER_LINK_CAP
expr_stmt|;
name|link_cap
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|link_cap
operator|&
name|PCIEM_LINK_CAP_ASPM
operator|)
operator|==
literal|0
condition|)
return|return;
name|reg
operator|=
name|base
operator|+
name|PCIER_LINK_CTL
expr_stmt|;
name|link_ctrl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|link_ctrl
operator|&=
operator|~
name|PCIEM_LINK_CTL_ASPMC
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|link_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Update the board statistics counters.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
operator|||
operator|(
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_LU
operator|)
condition|)
block|{
name|adapter
operator|->
name|stats
operator|.
name|symerrs
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_SYMERRS
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|sec
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_SEC
argument_list|)
expr_stmt|;
block|}
name|adapter
operator|->
name|stats
operator|.
name|crcerrs
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CRCERRS
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mpc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MPC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|scc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_SCC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ecol
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ECOL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mcc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MCC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|latecol
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_LATECOL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|colc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_COLC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|dc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_DC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rlec
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RLEC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|xonrxc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_XONRXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|xontxc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_XONTXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|xoffrxc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_XOFFRXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|xofftxc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_XOFFTXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|fcruc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_FCRUC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc64
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PRC64
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc127
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PRC127
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc255
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PRC255
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc511
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PRC511
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc1023
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PRC1023
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc1522
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PRC1522
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gprc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_GPRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|bprc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_BPRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mprc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MPRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gptc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_GPTC
argument_list|)
expr_stmt|;
comment|/* For the 64-bit byte counters the low dword must be read first. */
comment|/* Both registers clear on the read of the high dword */
name|adapter
operator|->
name|stats
operator|.
name|gorc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_GORCL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_GORCH
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gotc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_GOTCL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_GOTCH
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rnbc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RNBC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ruc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RUC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rfc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RFC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|roc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ROC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rjc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RJC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tor
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TORH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tot
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TOTH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tpr
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TPR
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tpt
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TPT
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc64
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PTC64
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc127
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PTC127
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc255
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PTC255
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc511
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PTC511
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc1023
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PTC1023
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc1522
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PTC1522
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mptc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MPTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|bptc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_BPTC
argument_list|)
expr_stmt|;
comment|/* Interrupt Counts */
name|adapter
operator|->
name|stats
operator|.
name|iac
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IAC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|icrxptc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICRXPTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|icrxatc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICRXATC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ictxptc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICTXPTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ictxatc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICTXATC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ictxqec
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICTXQEC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ictxqmtc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICTXQMTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|icrxdmtc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICRXDMTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|icrxoc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICRXOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82543
condition|)
block|{
name|adapter
operator|->
name|stats
operator|.
name|algnerrc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ALGNERRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rxerrc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RXERRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tncrs
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TNCRS
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|cexterr
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CEXTERR
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tsctc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TSCTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tsctfc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TSCTFC
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|em_get_counter
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|adapter
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
name|IFCOUNTER_COLLISIONS
case|:
return|return
operator|(
name|adapter
operator|->
name|stats
operator|.
name|colc
operator|)
return|;
case|case
name|IFCOUNTER_IERRORS
case|:
return|return
operator|(
name|adapter
operator|->
name|dropped_pkts
operator|+
name|adapter
operator|->
name|stats
operator|.
name|rxerrc
operator|+
name|adapter
operator|->
name|stats
operator|.
name|crcerrs
operator|+
name|adapter
operator|->
name|stats
operator|.
name|algnerrc
operator|+
name|adapter
operator|->
name|stats
operator|.
name|ruc
operator|+
name|adapter
operator|->
name|stats
operator|.
name|roc
operator|+
name|adapter
operator|->
name|stats
operator|.
name|mpc
operator|+
name|adapter
operator|->
name|stats
operator|.
name|cexterr
operator|)
return|;
case|case
name|IFCOUNTER_OERRORS
case|:
return|return
operator|(
name|adapter
operator|->
name|stats
operator|.
name|ecol
operator|+
name|adapter
operator|->
name|stats
operator|.
name|latecol
operator|+
name|adapter
operator|->
name|watchdog_events
operator|)
return|;
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Export a single 32-bit register via a read-only sysctl. */
end_comment

begin_function
specifier|static
name|int
name|em_sysctl_reg_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|u_int
name|val
decl_stmt|;
name|adapter
operator|=
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|val
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|oidp
operator|->
name|oid_arg2
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add sysctl variables, one per statistic, to the system.  */
end_comment

begin_function
specifier|static
name|void
name|em_add_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
decl_stmt|;
name|struct
name|e1000_hw_stats
modifier|*
name|stats
init|=
operator|&
name|adapter
operator|->
name|stats
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|stat_node
decl_stmt|,
modifier|*
name|queue_node
decl_stmt|,
modifier|*
name|int_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|stat_list
decl_stmt|,
modifier|*
name|queue_list
decl_stmt|,
modifier|*
name|int_list
decl_stmt|;
define|#
directive|define
name|QUEUE_NAME_LEN
value|32
name|char
name|namebuf
index|[
name|QUEUE_NAME_LEN
index|]
decl_stmt|;
comment|/* Driver Statistics */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|dropped_pkts
argument_list|,
literal|"Driver dropped packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"link_irq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|link_irq
argument_list|,
literal|"Link MSIX IRQ Handled"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_defrag_fail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|mbuf_defrag_failed
argument_list|,
literal|"Defragmenting mbuf chain failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_dma_fail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|no_tx_dma_setup
argument_list|,
literal|"Driver tx dma failure in xmit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_overruns"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|rx_overruns
argument_list|,
literal|"RX overruns"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"watchdog_timeouts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|watchdog_events
argument_list|,
literal|"Watchdog timeouts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"device_control"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_CTRL
argument_list|,
name|em_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Device Control Register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_control"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_RCTL
argument_list|,
name|em_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Receiver Control Register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc_high_water"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|high_water
argument_list|,
literal|0
argument_list|,
literal|"Flow Control High Watermark"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc_low_water"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|low_water
argument_list|,
literal|0
argument_list|,
literal|"Flow Control Low Watermark"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"queue_tx_%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"TX Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txd_head"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_TDH
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|,
name|em_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Transmit Descriptor Head"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txd_tail"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_TDT
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|,
name|em_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Transmit Descriptor Tail"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_irq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|tx_irq
argument_list|,
literal|"Queue MSI-X Transmit Interrupts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_desc_avail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|no_desc_avail
argument_list|,
literal|"Queue No Descriptor Available"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"queue_rx_%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"RX Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxd_head"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_RDH
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|em_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Receive Descriptor Head"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxd_tail"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|em_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Receive Descriptor Tail"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_irq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxr
operator|->
name|rx_irq
argument_list|,
literal|"Queue MSI-X Receive Interrupts"
argument_list|)
expr_stmt|;
block|}
comment|/* MAC stats get their own sub node */
name|stat_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mac_stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Statistics"
argument_list|)
expr_stmt|;
name|stat_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|stat_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"excess_coll"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ecol
argument_list|,
literal|"Excessive collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"single_coll"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|scc
argument_list|,
literal|"Single collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"multiple_coll"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mcc
argument_list|,
literal|"Multiple collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"late_coll"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|latecol
argument_list|,
literal|"Late collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"collision_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|colc
argument_list|,
literal|"Collision Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"symbol_errors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|symerrs
argument_list|,
literal|"Symbol Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sequence_errors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|sec
argument_list|,
literal|"Sequence Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"defer_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|dc
argument_list|,
literal|"Defer Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"missed_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|mpc
argument_list|,
literal|"Missed Packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_no_buff"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|rnbc
argument_list|,
literal|"Receive No Buffers"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_undersize"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ruc
argument_list|,
literal|"Receive Undersize"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_fragmented"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|rfc
argument_list|,
literal|"Fragmented Packets Received "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_oversize"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|roc
argument_list|,
literal|"Oversized Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_jabber"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|rjc
argument_list|,
literal|"Recevied Jabber"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|rxerrc
argument_list|,
literal|"Receive Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"crc_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|crcerrs
argument_list|,
literal|"CRC errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"alignment_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|algnerrc
argument_list|,
literal|"Alignment Errors"
argument_list|)
expr_stmt|;
comment|/* On 82575 these are collision counts */
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"coll_ext_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|cexterr
argument_list|,
literal|"Collision/Carrier extension errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xon_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|xonrxc
argument_list|,
literal|"XON Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xon_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|xontxc
argument_list|,
literal|"XON Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xoff_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|xoffrxc
argument_list|,
literal|"XOFF Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xoff_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|xofftxc
argument_list|,
literal|"XOFF Transmitted"
argument_list|)
expr_stmt|;
comment|/* Packet Reception Stats */
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|tpr
argument_list|,
literal|"Total Packets Received "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|gprc
argument_list|,
literal|"Good Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bcast_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|bprc
argument_list|,
literal|"Broadcast Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mcast_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|mprc
argument_list|,
literal|"Multicast Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_64"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|prc64
argument_list|,
literal|"64 byte frames received "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_65_127"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|prc127
argument_list|,
literal|"65-127 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_128_255"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|prc255
argument_list|,
literal|"128-255 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_256_511"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|prc511
argument_list|,
literal|"256-511 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_512_1023"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|prc1023
argument_list|,
literal|"512-1023 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_1024_1522"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|prc1522
argument_list|,
literal|"1023-1522 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_octets_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|gorc
argument_list|,
literal|"Good Octets Received"
argument_list|)
expr_stmt|;
comment|/* Packet Transmission Stats */
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_octets_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|gotc
argument_list|,
literal|"Good Octets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|tpt
argument_list|,
literal|"Total Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|gptc
argument_list|,
literal|"Good Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bcast_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|bptc
argument_list|,
literal|"Broadcast Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mcast_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|mptc
argument_list|,
literal|"Multicast Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_64"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ptc64
argument_list|,
literal|"64 byte frames transmitted "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_65_127"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ptc127
argument_list|,
literal|"65-127 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_128_255"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ptc255
argument_list|,
literal|"128-255 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_256_511"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ptc511
argument_list|,
literal|"256-511 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_512_1023"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ptc1023
argument_list|,
literal|"512-1023 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_1024_1522"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ptc1522
argument_list|,
literal|"1024-1522 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|tsctc
argument_list|,
literal|"TSO Contexts Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_ctx_fail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|tsctfc
argument_list|,
literal|"TSO Contexts Failed"
argument_list|)
expr_stmt|;
comment|/* Interrupt Stats */
name|int_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"interrupts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Interrupt Statistics"
argument_list|)
expr_stmt|;
name|int_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|int_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"asserts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|iac
argument_list|,
literal|"Interrupt Assertion Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_pkt_timer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|icrxptc
argument_list|,
literal|"Interrupt Cause Rx Pkt Timer Expire Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_abs_timer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|icrxatc
argument_list|,
literal|"Interrupt Cause Rx Abs Timer Expire Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_pkt_timer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ictxptc
argument_list|,
literal|"Interrupt Cause Tx Pkt Timer Expire Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_abs_timer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ictxatc
argument_list|,
literal|"Interrupt Cause Tx Abs Timer Expire Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_queue_empty"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ictxqec
argument_list|,
literal|"Interrupt Cause Tx Queue Empty Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_queue_min_thresh"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ictxqmtc
argument_list|,
literal|"Interrupt Cause Tx Queue Min Thresh Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_desc_min_thresh"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|icrxdmtc
argument_list|,
literal|"Interrupt Cause Rx Desc Min Thresh Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_overrun"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|icrxoc
argument_list|,
literal|"Interrupt Cause Receiver Overrun Count"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  This routine provides a way to dump out the adapter eeprom,  *  often a useful debug/service tool. This only dumps the first  *  32 words, stuff that matters is in that extent.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_sysctl_nvm_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * This value will cause a hex dump of the 	 * first 32 16-bit words of the EEPROM to 	 * the screen. 	 */
if|if
condition|(
name|result
operator|==
literal|1
condition|)
name|em_print_nvm_info
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_print_nvm_info
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u16
name|eeprom_data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|row
init|=
literal|0
decl_stmt|;
comment|/* Its a bit crude, but it gets the job done */
name|printf
argument_list|(
literal|"\nInterface EEPROM Dump:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Offset\n0x0000  "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
literal|8
condition|)
block|{
comment|/* Make the offset block */
name|j
operator|=
literal|0
expr_stmt|;
operator|++
name|row
expr_stmt|;
name|printf
argument_list|(
literal|"\n0x00%x0  "
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
name|e1000_read_nvm
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%04x "
argument_list|,
name|eeprom_data
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_sysctl_int_delay
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|em_int_delay_info
modifier|*
name|info
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|u32
name|regval
decl_stmt|;
name|int
name|error
decl_stmt|,
name|usecs
decl_stmt|,
name|ticks
decl_stmt|;
name|info
operator|=
operator|(
expr|struct
name|em_int_delay_info
operator|*
operator|)
name|arg1
expr_stmt|;
name|usecs
operator|=
name|info
operator|->
name|value
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|usecs
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|usecs
operator|<
literal|0
operator|||
name|usecs
operator|>
name|EM_TICKS_TO_USECS
argument_list|(
literal|65535
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|info
operator|->
name|value
operator|=
name|usecs
expr_stmt|;
name|ticks
operator|=
name|EM_USECS_TO_TICKS
argument_list|(
name|usecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|offset
operator|==
name|E1000_ITR
condition|)
comment|/* units are 256ns here */
name|ticks
operator|*=
literal|4
expr_stmt|;
name|adapter
operator|=
name|info
operator|->
name|adapter
expr_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|regval
operator|=
name|E1000_READ_OFFSET
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|info
operator|->
name|offset
argument_list|)
expr_stmt|;
name|regval
operator|=
operator|(
name|regval
operator|&
operator|~
literal|0xffff
operator|)
operator||
operator|(
name|ticks
operator|&
literal|0xffff
operator|)
expr_stmt|;
comment|/* Handle a few special cases. */
switch|switch
condition|(
name|info
operator|->
name|offset
condition|)
block|{
case|case
name|E1000_RDTR
case|:
break|break;
case|case
name|E1000_TIDV
case|:
if|if
condition|(
name|ticks
operator|==
literal|0
condition|)
block|{
name|adapter
operator|->
name|txd_cmd
operator|&=
operator|~
name|E1000_TXD_CMD_IDE
expr_stmt|;
comment|/* Don't write 0 into the TIDV register. */
name|regval
operator|++
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|txd_cmd
operator||=
name|E1000_TXD_CMD_IDE
expr_stmt|;
break|break;
block|}
name|E1000_WRITE_OFFSET
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|info
operator|->
name|offset
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_add_int_delay_sysctl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|description
parameter_list|,
name|struct
name|em_int_delay_info
modifier|*
name|info
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|info
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|info
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|info
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|info
argument_list|,
literal|0
argument_list|,
name|em_sysctl_int_delay
argument_list|,
literal|"I"
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_set_sysctl_value
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|description
parameter_list|,
name|int
modifier|*
name|limit
parameter_list|,
name|int
name|value
parameter_list|)
block|{
operator|*
name|limit
operator|=
name|value
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|limit
argument_list|,
name|value
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Set flow control using sysctl: ** Flow control values: **      0 - off **      1 - rx pause **      2 - tx pause **      3 - full */
end_comment

begin_function
specifier|static
name|int
name|em_set_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
specifier|static
name|int
name|input
init|=
literal|3
decl_stmt|;
comment|/* default is full */
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|input
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|input
operator|==
name|adapter
operator|->
name|fc
condition|)
comment|/* no change? */
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|input
condition|)
block|{
case|case
name|e1000_fc_rx_pause
case|:
case|case
name|e1000_fc_tx_pause
case|:
case|case
name|e1000_fc_full
case|:
case|case
name|e1000_fc_none
case|:
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|requested_mode
operator|=
name|input
expr_stmt|;
name|adapter
operator|->
name|fc
operator|=
name|input
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
return|return
operator|(
name|error
operator|)
return|;
block|}
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|current_mode
operator|=
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|requested_mode
expr_stmt|;
name|e1000_force_mac_fc
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Manage Energy Efficient Ethernet: ** Control values: **     0/1 - enabled/disabled */
end_comment

begin_function
specifier|static
name|int
name|em_sysctl_eee
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|value
decl_stmt|;
name|value
operator|=
name|adapter
operator|->
name|hw
operator|.
name|dev_spec
operator|.
name|ich8lan
operator|.
name|eee_disable
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|dev_spec
operator|.
name|ich8lan
operator|.
name|eee_disable
operator|=
operator|(
name|value
operator|!=
literal|0
operator|)
expr_stmt|;
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_sysctl_debug_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|adapter
operator|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
expr_stmt|;
name|em_print_debug_info
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** This routine is meant to be fluid, add whatever is ** needed for debugging a problem.  -jfv */
end_comment

begin_function
specifier|static
name|void
name|em_print_debug_info
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
name|printf
argument_list|(
literal|"Interface is RUNNING "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Interface is NOT RUNNING\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
operator|&
name|IFF_DRV_OACTIVE
condition|)
name|printf
argument_list|(
literal|"and INACTIVE\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"and ACTIVE\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TX Queue %d ------\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"hw tdh = %d, hw tdt = %d\n"
argument_list|,
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDH
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Tx Queue Status = %d\n"
argument_list|,
name|txr
operator|->
name|busy
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TX descriptors avail = %d\n"
argument_list|,
name|txr
operator|->
name|tx_avail
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Tx Descriptors avail failure = %ld\n"
argument_list|,
name|txr
operator|->
name|no_desc_avail
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RX Queue %d ------\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"hw rdh = %d, hw rdt = %d\n"
argument_list|,
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RDH
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RDT
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RX discarded packets = %ld\n"
argument_list|,
name|rxr
operator|->
name|rx_discarded
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RX Next to Check = %d\n"
argument_list|,
name|rxr
operator|->
name|next_to_check
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RX Next to Refresh = %d\n"
argument_list|,
name|rxr
operator|->
name|next_to_refresh
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EM_MULTIQUEUE
end_ifdef

begin_comment
comment|/*  * 82574 only:  * Write a new value to the EEPROM increasing the number of MSIX  * vectors from 3 to 5, for proper multiqueue support.  */
end_comment

begin_function
specifier|static
name|void
name|em_enable_vectors_82574
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|u16
name|edata
decl_stmt|;
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
name|EM_NVM_PCIE_CTRL
argument_list|,
literal|1
argument_list|,
operator|&
name|edata
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Current cap: %#06x\n"
argument_list|,
name|edata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|edata
operator|&
name|EM_NVM_MSIX_N_MASK
operator|)
operator|>>
name|EM_NVM_MSIX_N_SHIFT
operator|)
operator|!=
literal|4
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Writing to eeprom: increasing "
literal|"reported MSIX vectors from 3 to 5...\n"
argument_list|)
expr_stmt|;
name|edata
operator|&=
operator|~
operator|(
name|EM_NVM_MSIX_N_MASK
operator|)
expr_stmt|;
name|edata
operator||=
literal|4
operator|<<
name|EM_NVM_MSIX_N_SHIFT
expr_stmt|;
name|e1000_write_nvm
argument_list|(
name|hw
argument_list|,
name|EM_NVM_PCIE_CTRL
argument_list|,
literal|1
argument_list|,
operator|&
name|edata
argument_list|)
expr_stmt|;
name|e1000_update_nvm_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Writing to eeprom: done\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_macro
name|DB_COMMAND
argument_list|(
argument|em_reset_dev
argument_list|,
argument|em_ddb_reset_dev
argument_list|)
end_macro

begin_block
block|{
name|devclass_t
name|dc
decl_stmt|;
name|int
name|max_em
decl_stmt|;
name|dc
operator|=
name|devclass_find
argument_list|(
literal|"em"
argument_list|)
expr_stmt|;
name|max_em
operator|=
name|devclass_get_maxunit
argument_list|(
name|dc
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
operator|(
name|max_em
operator|-
literal|1
operator|)
condition|;
name|index
operator|++
control|)
block|{
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|devclass_get_device
argument_list|(
name|dc
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_driver
argument_list|(
name|dev
argument_list|)
operator|==
operator|&
name|em_driver
condition|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|DB_COMMAND
argument_list|(
argument|em_dump_queue
argument_list|,
argument|em_ddb_dump_queue
argument_list|)
end_macro

begin_block
block|{
name|devclass_t
name|dc
decl_stmt|;
name|int
name|max_em
decl_stmt|;
name|dc
operator|=
name|devclass_find
argument_list|(
literal|"em"
argument_list|)
expr_stmt|;
name|max_em
operator|=
name|devclass_get_maxunit
argument_list|(
name|dc
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
operator|(
name|max_em
operator|-
literal|1
operator|)
condition|;
name|index
operator|++
control|)
block|{
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|devclass_get_device
argument_list|(
name|dc
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_driver
argument_list|(
name|dev
argument_list|)
operator|==
operator|&
name|em_driver
condition|)
name|em_print_debug_info
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

