begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Matt Macy<mmacy@nextbsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"if_em.h"
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_define
define|#
directive|define
name|em_mac_min
value|e1000_82547
end_define

begin_define
define|#
directive|define
name|igb_mac_min
value|e1000_82575
end_define

begin_comment
comment|/*********************************************************************  *  Driver version:  *********************************************************************/
end_comment

begin_decl_stmt
name|char
name|em_driver_version
index|[]
init|=
literal|"7.6.1-k"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  PCI Device ID Table  *  *  Used by probe to select devices to load on  *  Last field stores an index into e1000_strings  *  Last entry must be all 0s  *  *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|pci_vendor_info_t
name|em_vendor_info_array
index|[]
init|=
block|{
comment|/* Intel(R) PRO/1000 Network Connection - Legacy em*/
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82540EM
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82540EM_LOM
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82540EP
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82540EP_LOM
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82540EP_LP
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82541EI
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82541ER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82541ER_LOM
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82541EI_MOBILE
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82541GI
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82541GI_LF
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82541GI_MOBILE
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82542
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82543GC_FIBER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82543GC_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82544EI_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82544EI_FIBER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82544GC_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82544GC_LOM
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82545EM_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82545EM_FIBER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82545GM_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82545GM_FIBER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82545GM_SERDES
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82546EB_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82546EB_FIBER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82546EB_QUAD_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82546GB_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82546GB_FIBER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82546GB_SERDES
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82546GB_PCIE
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82546GB_QUAD_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82547EI
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82547EI_MOBILE
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82547GI
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
comment|/* Intel(R) PRO/1000 Network Connection - em */
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82571EB_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82571EB_FIBER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82571EB_SERDES
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82571EB_SERDES_DUAL
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82571EB_SERDES_QUAD
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82571EB_QUAD_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82571EB_QUAD_COPPER_LP
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82571EB_QUAD_FIBER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82571PT_QUAD_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82572EI
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82572EI_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82572EI_FIBER
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82572EI_SERDES
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82573E
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82573E_IAMT
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82573L
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82583V
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_80003ES2LAN_COPPER_SPT
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_80003ES2LAN_SERDES_SPT
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_80003ES2LAN_COPPER_DPT
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_80003ES2LAN_SERDES_DPT
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH8_IGP_M_AMT
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH8_IGP_AMT
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH8_IGP_C
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH8_IFE
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH8_IFE_GT
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH8_IFE_G
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH8_IGP_M
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH8_82567V_3
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH9_IGP_M_AMT
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH9_IGP_AMT
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH9_IGP_C
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH9_IGP_M
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH9_IGP_M_V
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH9_IFE
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH9_IFE_GT
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH9_IFE_G
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH9_BM
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82574L
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82574LA
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH10_R_BM_LM
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH10_R_BM_LF
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH10_R_BM_V
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH10_D_BM_LM
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH10_D_BM_LF
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_ICH10_D_BM_V
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_M_HV_LM
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_M_HV_LC
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_D_HV_DM
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_D_HV_DC
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH2_LV_LM
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH2_LV_V
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_LPT_I217_LM
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_LPT_I217_V
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_LPTLP_I218_LM
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_LPTLP_I218_V
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_I218_LM2
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_I218_V2
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_I218_LM3
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_I218_V3
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_SPT_I219_LM
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_SPT_I219_V
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_SPT_I219_LM2
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_SPT_I219_V2
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_LBG_I219_LM3
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_SPT_I219_LM4
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_SPT_I219_V4
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_SPT_I219_LM5
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_PCH_SPT_I219_V5
argument_list|,
literal|"Intel(R) PRO/1000 Network Connection"
argument_list|)
block|,
comment|/* required last entry */
name|PVID_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pci_vendor_info_t
name|igb_vendor_info_array
index|[]
init|=
block|{
comment|/* Intel(R) PRO/1000 Network Connection - igb */
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82575EB_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82575EB_FIBER_SERDES
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82575GB_QUAD_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82576
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82576_NS
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82576_NS_SERDES
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82576_FIBER
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82576_SERDES
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82576_SERDES_QUAD
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82576_QUAD_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82576_QUAD_COPPER_ET2
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82576_VF
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82580_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82580_FIBER
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82580_SERDES
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82580_SGMII
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82580_COPPER_DUAL
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_82580_QUAD_FIBER
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_DH89XXCC_SERDES
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_DH89XXCC_SGMII
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_DH89XXCC_SFP
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_DH89XXCC_BACKPLANE
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I350_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I350_FIBER
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I350_SERDES
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I350_SGMII
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I350_VF
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I210_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I210_COPPER_IT
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I210_COPPER_OEM1
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I210_COPPER_FLASHLESS
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I210_SERDES_FLASHLESS
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I210_FIBER
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I210_SERDES
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I210_SGMII
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I211_COPPER
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I354_BACKPLANE_1GBPS
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I354_BACKPLANE_2_5GBPS
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
name|PVID
argument_list|(
literal|0x8086
argument_list|,
name|E1000_DEV_ID_I354_SGMII
argument_list|,
literal|"Intel(R) PRO/1000 PCI-Express Network Driver"
argument_list|)
block|,
comment|/* required last entry */
name|PVID_END
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|em_register
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|igb_register
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_if_attach_pre
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_if_attach_post
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_if_detach
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_if_shutdown
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_if_suspend
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_if_resume
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_if_tx_queues_alloc
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|caddr_t
modifier|*
name|vaddrs
parameter_list|,
name|uint64_t
modifier|*
name|paddrs
parameter_list|,
name|int
name|ntxqs
parameter_list|,
name|int
name|ntxqsets
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_if_rx_queues_alloc
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|caddr_t
modifier|*
name|vaddrs
parameter_list|,
name|uint64_t
modifier|*
name|paddrs
parameter_list|,
name|int
name|nrxqs
parameter_list|,
name|int
name|nrxqsets
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_if_queues_free
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|em_if_get_counter
parameter_list|(
name|if_ctx_t
parameter_list|,
name|ift_counter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_if_init
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_if_stop
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_if_media_status
parameter_list|(
name|if_ctx_t
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_if_media_change
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_if_mtu_set
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|uint32_t
name|mtu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_if_timer
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|uint16_t
name|qid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_if_vlan_register
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|u16
name|vtag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_if_vlan_unregister
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|u16
name|vtag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_identify_hardware
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_allocate_pci_resources
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_free_pci_resources
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_reset
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_setup_interface
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_setup_msix
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_initialize_transmit_unit
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_initialize_receive_unit
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_if_enable_intr
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_if_disable_intr
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_if_rx_queue_intr_enable
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_if_tx_queue_intr_enable
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|uint16_t
name|txqid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_if_multi_set
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_if_update_admin_status
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_if_debug
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_add_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_if_set_promisc
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_setup_vlan_hw_support
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_sysctl_nvm_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_print_nvm_info
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_sysctl_debug_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_get_rs
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_print_debug_info
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_is_valid_ether_addr
parameter_list|(
name|u8
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_sysctl_int_delay
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_add_int_delay_sysctl
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|em_int_delay_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Management and WOL Support */
end_comment

begin_function_decl
specifier|static
name|void
name|em_init_manageability
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_release_manageability
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_get_hw_control
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_release_hw_control
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_get_wakeup
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_enable_wakeup
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_enable_phy_wakeup
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_disable_aspm
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|em_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_disable_promisc
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* MSIX handlers */
end_comment

begin_function_decl
specifier|static
name|int
name|em_if_msix_intr_assign
parameter_list|(
name|if_ctx_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_msix_link
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_handle_link
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_enable_vectors_82574
parameter_list|(
name|if_ctx_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_set_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_sysctl_eee
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_if_led_func
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|int
name|onoff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_get_regs
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lem_smartspeed
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_configure_queues
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|em_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_register
argument_list|,
name|em_register
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|iflib_device_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|iflib_device_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|iflib_device_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|iflib_device_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|iflib_device_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|iflib_device_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|igb_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_register
argument_list|,
name|igb_register
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|iflib_device_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|iflib_device_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|iflib_device_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|iflib_device_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|iflib_device_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|iflib_device_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|em_driver
init|=
block|{
literal|"em"
block|,
name|em_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|adapter
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|em_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|em
argument_list|,
name|pci
argument_list|,
name|em_driver
argument_list|,
name|em_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|em
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|em
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|em
argument_list|,
name|iflib
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|igb_driver
init|=
block|{
literal|"igb"
block|,
name|igb_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|adapter
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|igb_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|igb
argument_list|,
name|pci
argument_list|,
name|igb_driver
argument_list|,
name|igb_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|igb
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|igb
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|igb
argument_list|,
name|iflib
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|em_if_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|ifdi_attach_pre
argument_list|,
name|em_if_attach_pre
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_attach_post
argument_list|,
name|em_if_attach_post
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_detach
argument_list|,
name|em_if_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_shutdown
argument_list|,
name|em_if_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_suspend
argument_list|,
name|em_if_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_resume
argument_list|,
name|em_if_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_init
argument_list|,
name|em_if_init
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_stop
argument_list|,
name|em_if_stop
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_msix_intr_assign
argument_list|,
name|em_if_msix_intr_assign
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_intr_enable
argument_list|,
name|em_if_enable_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_intr_disable
argument_list|,
name|em_if_disable_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_tx_queues_alloc
argument_list|,
name|em_if_tx_queues_alloc
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_rx_queues_alloc
argument_list|,
name|em_if_rx_queues_alloc
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_queues_free
argument_list|,
name|em_if_queues_free
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_update_admin_status
argument_list|,
name|em_if_update_admin_status
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_multi_set
argument_list|,
name|em_if_multi_set
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_media_status
argument_list|,
name|em_if_media_status
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_media_change
argument_list|,
name|em_if_media_change
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_mtu_set
argument_list|,
name|em_if_mtu_set
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_promisc_set
argument_list|,
name|em_if_set_promisc
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_timer
argument_list|,
name|em_if_timer
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_vlan_register
argument_list|,
name|em_if_vlan_register
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_vlan_unregister
argument_list|,
name|em_if_vlan_unregister
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_get_counter
argument_list|,
name|em_if_get_counter
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_led_func
argument_list|,
name|em_if_led_func
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_rx_queue_intr_enable
argument_list|,
name|em_if_rx_queue_intr_enable
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_tx_queue_intr_enable
argument_list|,
name|em_if_tx_queue_intr_enable
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ifdi_debug
argument_list|,
name|em_if_debug
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * note that if (adapter->msix_mem) is replaced by:  * if (adapter->intr_type == IFLIB_INTR_MSIX)  */
end_comment

begin_decl_stmt
specifier|static
name|driver_t
name|em_if_driver
init|=
block|{
literal|"em_if"
block|,
name|em_if_methods
block|,
expr|sizeof
operator|(
expr|struct
name|adapter
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Tunable default values.  *********************************************************************/
end_comment

begin_define
define|#
directive|define
name|EM_TICKS_TO_USECS
parameter_list|(
name|ticks
parameter_list|)
value|((1024 * (ticks) + 500) / 1000)
end_define

begin_define
define|#
directive|define
name|EM_USECS_TO_TICKS
parameter_list|(
name|usecs
parameter_list|)
value|((1000 * (usecs) + 512) / 1024)
end_define

begin_define
define|#
directive|define
name|M_TSO_LEN
value|66
end_define

begin_define
define|#
directive|define
name|MAX_INTS_PER_SEC
value|8000
end_define

begin_define
define|#
directive|define
name|DEFAULT_ITR
value|(1000000000/(MAX_INTS_PER_SEC * 256))
end_define

begin_comment
comment|/* Allow common code without TSO */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CSUM_TSO
end_ifndef

begin_define
define|#
directive|define
name|CSUM_TSO
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TSO_WORKAROUND
value|4
end_define

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|em
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"EM driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|em_disable_crc_stripping
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|disable_crc_stripping
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_disable_crc_stripping
argument_list|,
literal|0
argument_list|,
literal|"Disable CRC Stripping"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|em_tx_int_delay_dflt
init|=
name|EM_TICKS_TO_USECS
argument_list|(
name|EM_TIDV
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_rx_int_delay_dflt
init|=
name|EM_TICKS_TO_USECS
argument_list|(
name|EM_RDTR
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_int_delay
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_tx_int_delay_dflt
argument_list|,
literal|0
argument_list|,
literal|"Default transmit interrupt delay in usecs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_int_delay
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_rx_int_delay_dflt
argument_list|,
literal|0
argument_list|,
literal|"Default receive interrupt delay in usecs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|em_tx_abs_int_delay_dflt
init|=
name|EM_TICKS_TO_USECS
argument_list|(
name|EM_TADV
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_rx_abs_int_delay_dflt
init|=
name|EM_TICKS_TO_USECS
argument_list|(
name|EM_RADV
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_abs_int_delay
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_tx_abs_int_delay_dflt
argument_list|,
literal|0
argument_list|,
literal|"Default transmit interrupt delay limit in usecs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_abs_int_delay
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_rx_abs_int_delay_dflt
argument_list|,
literal|0
argument_list|,
literal|"Default receive interrupt delay limit in usecs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|em_smart_pwr_down
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|smart_pwr_down
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_smart_pwr_down
argument_list|,
literal|0
argument_list|,
literal|"Set to true to leave smart power down enabled on newer adapters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Controls whether promiscuous also shows bad packets */
end_comment

begin_decl_stmt
specifier|static
name|int
name|em_debug_sbp
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|sbp
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_debug_sbp
argument_list|,
literal|0
argument_list|,
literal|"Show bad packets in promiscuous mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* How many packets rxeof tries to clean at a time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|em_rx_process_limit
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_process_limit
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_rx_process_limit
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of received packets to process "
literal|"at a time, -1 means unlimited"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Energy efficient ethernet - default to OFF */
end_comment

begin_decl_stmt
specifier|static
name|int
name|eee_setting
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|eee_setting
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|eee_setting
argument_list|,
literal|0
argument_list|,
literal|"Enable Energy Efficient Ethernet"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Tuneable Interrupt rate */
end_comment

begin_decl_stmt
specifier|static
name|int
name|em_max_interrupt_rate
init|=
literal|8000
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_em
argument_list|,
name|OID_AUTO
argument_list|,
name|max_interrupt_rate
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|em_max_interrupt_rate
argument_list|,
literal|0
argument_list|,
literal|"Maximum interrupts per second"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Global used in WOL setup with multiport cards */
end_comment

begin_decl_stmt
specifier|static
name|int
name|global_quad_port_a
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|if_txrx
name|igb_txrx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|if_txrx
name|em_txrx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|if_txrx
name|lem_txrx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|if_shared_ctx
name|em_sctx_init
init|=
block|{
operator|.
name|isc_magic
operator|=
name|IFLIB_MAGIC
block|,
operator|.
name|isc_q_align
operator|=
name|PAGE_SIZE
block|,
operator|.
name|isc_tx_maxsize
operator|=
name|EM_TSO_SIZE
block|,
operator|.
name|isc_tx_maxsegsize
operator|=
name|PAGE_SIZE
block|,
operator|.
name|isc_rx_maxsize
operator|=
name|MJUM9BYTES
block|,
operator|.
name|isc_rx_nsegments
operator|=
literal|1
block|,
operator|.
name|isc_rx_maxsegsize
operator|=
name|MJUM9BYTES
block|,
operator|.
name|isc_nfl
operator|=
literal|1
block|,
operator|.
name|isc_nrxqs
operator|=
literal|1
block|,
operator|.
name|isc_ntxqs
operator|=
literal|1
block|,
operator|.
name|isc_admin_intrcnt
operator|=
literal|1
block|,
operator|.
name|isc_vendor_info
operator|=
name|em_vendor_info_array
block|,
operator|.
name|isc_driver_version
operator|=
name|em_driver_version
block|,
operator|.
name|isc_driver
operator|=
operator|&
name|em_if_driver
block|,
operator|.
name|isc_flags
operator|=
name|IFLIB_NEED_SCRATCH
operator||
name|IFLIB_TSO_INIT_IP
block|,
operator|.
name|isc_nrxd_min
operator|=
block|{
name|EM_MIN_RXD
block|}
block|,
operator|.
name|isc_ntxd_min
operator|=
block|{
name|EM_MIN_TXD
block|}
block|,
operator|.
name|isc_nrxd_max
operator|=
block|{
name|EM_MAX_RXD
block|}
block|,
operator|.
name|isc_ntxd_max
operator|=
block|{
name|EM_MAX_TXD
block|}
block|,
operator|.
name|isc_nrxd_default
operator|=
block|{
name|EM_DEFAULT_RXD
block|}
block|,
operator|.
name|isc_ntxd_default
operator|=
block|{
name|EM_DEFAULT_TXD
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|if_shared_ctx_t
name|em_sctx
init|=
operator|&
name|em_sctx_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|if_shared_ctx
name|igb_sctx_init
init|=
block|{
operator|.
name|isc_magic
operator|=
name|IFLIB_MAGIC
block|,
operator|.
name|isc_q_align
operator|=
name|PAGE_SIZE
block|,
operator|.
name|isc_tx_maxsize
operator|=
name|EM_TSO_SIZE
block|,
operator|.
name|isc_tx_maxsegsize
operator|=
name|PAGE_SIZE
block|,
operator|.
name|isc_rx_maxsize
operator|=
name|MJUM9BYTES
block|,
operator|.
name|isc_rx_nsegments
operator|=
literal|1
block|,
operator|.
name|isc_rx_maxsegsize
operator|=
name|MJUM9BYTES
block|,
operator|.
name|isc_nfl
operator|=
literal|1
block|,
operator|.
name|isc_nrxqs
operator|=
literal|1
block|,
operator|.
name|isc_ntxqs
operator|=
literal|1
block|,
operator|.
name|isc_admin_intrcnt
operator|=
literal|1
block|,
operator|.
name|isc_vendor_info
operator|=
name|igb_vendor_info_array
block|,
operator|.
name|isc_driver_version
operator|=
name|em_driver_version
block|,
operator|.
name|isc_driver
operator|=
operator|&
name|em_if_driver
block|,
operator|.
name|isc_flags
operator|=
name|IFLIB_NEED_SCRATCH
operator||
name|IFLIB_TSO_INIT_IP
block|,
operator|.
name|isc_nrxd_min
operator|=
block|{
name|EM_MIN_RXD
block|}
block|,
operator|.
name|isc_ntxd_min
operator|=
block|{
name|EM_MIN_TXD
block|}
block|,
operator|.
name|isc_nrxd_max
operator|=
block|{
name|EM_MAX_RXD
block|}
block|,
operator|.
name|isc_ntxd_max
operator|=
block|{
name|EM_MAX_TXD
block|}
block|,
operator|.
name|isc_nrxd_default
operator|=
block|{
name|EM_DEFAULT_RXD
block|}
block|,
operator|.
name|isc_ntxd_default
operator|=
block|{
name|EM_DEFAULT_TXD
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|if_shared_ctx_t
name|igb_sctx
init|=
operator|&
name|igb_sctx_init
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************  *  * Dump Registers  *  ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|IGB_REGS_LEN
value|739
end_define

begin_function
specifier|static
name|int
name|em_get_regs
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|u32
modifier|*
name|regs_buff
init|=
operator|(
name|u32
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
name|IGB_REGS_LEN
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|memset
argument_list|(
name|regs_buff
argument_list|,
literal|0
argument_list|,
name|IGB_REGS_LEN
operator|*
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|rc
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|32
operator|*
literal|400
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* General Registers */
name|regs_buff
index|[
literal|0
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|1
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|2
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|3
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|4
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|5
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDLEN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|6
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDH
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|7
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDT
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|8
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|9
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDBAL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|10
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDBAH
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|11
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|12
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDBAL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|13
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDBAH
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|14
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDLEN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|15
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDH
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|16
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|17
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|18
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDFH
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|19
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDFT
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|20
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDFHS
argument_list|)
expr_stmt|;
name|regs_buff
index|[
literal|21
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDFPC
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"General Registers\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tCTRL\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tSTATUS\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tCTRL_EXIT\t %08x\n\n"
argument_list|,
name|regs_buff
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Interrupt Registers\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tICR\t %08x\n\n"
argument_list|,
name|regs_buff
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"RX Registers\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tRCTL\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tRDLEN\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tRDH\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tRDT\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tRXDCTL\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tRDBAL\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tRDBAH\t %08x\n\n"
argument_list|,
name|regs_buff
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"TX Registers\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tTCTL\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tTDBAL\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tTDBAH\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|13
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tTDLEN\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|14
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tTDH\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tTDT\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|16
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tTXDCTL\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|17
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tTDFH\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|18
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tTDFT\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|19
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tTDFHS\t %08x\n"
argument_list|,
name|regs_buff
index|[
literal|20
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tTDFPC\t %08x\n\n"
argument_list|,
name|regs_buff
index|[
literal|21
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMP_DESCS
block|{
name|if_softc_ctx_t
name|scctx
init|=
name|adapter
operator|->
name|shared
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|rx_que
operator|->
name|rxr
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|tx_que
operator|->
name|txr
decl_stmt|;
name|int
name|ntxd
init|=
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
decl_stmt|;
name|int
name|nrxd
init|=
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nrxd
condition|;
name|j
operator|++
control|)
block|{
name|u32
name|staterr
init|=
name|le32toh
argument_list|(
name|rxr
operator|->
name|rx_base
index|[
name|j
index|]
operator|.
name|wb
operator|.
name|upper
operator|.
name|status_error
argument_list|)
decl_stmt|;
name|u32
name|length
init|=
name|le32toh
argument_list|(
name|rxr
operator|->
name|rx_base
index|[
name|j
index|]
operator|.
name|wb
operator|.
name|upper
operator|.
name|length
argument_list|)
decl_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tReceive Descriptor Address %d: %08"
name|PRIx64
literal|"  Error:%d  Length:%d\n"
argument_list|,
name|j
argument_list|,
name|rxr
operator|->
name|rx_base
index|[
name|j
index|]
operator|.
name|read
operator|.
name|buffer_addr
argument_list|,
name|staterr
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|min
argument_list|(
name|ntxd
argument_list|,
literal|256
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|int
modifier|*
name|ptr
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|j
index|]
decl_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tTXD[%03d] [0]: %08x [1]: %08x [2]: %08x [3]: %08x  eop: %d DD=%d\n"
argument_list|,
name|j
argument_list|,
name|ptr
index|[
literal|0
index|]
argument_list|,
name|ptr
index|[
literal|1
index|]
argument_list|,
name|ptr
index|[
literal|2
index|]
argument_list|,
name|ptr
index|[
literal|3
index|]
argument_list|,
name|buf
operator|->
name|eop
argument_list|,
name|buf
operator|->
name|eop
operator|!=
operator|-
literal|1
condition|?
name|txr
operator|->
name|tx_base
index|[
name|buf
operator|->
name|eop
index|]
operator|.
name|upper
operator|.
name|fields
operator|.
name|status
operator|&
name|E1000_TXD_STAT_DD
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|em_register
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|em_sctx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|igb_register
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|igb_sctx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_set_num_queues
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|int
name|maxqueues
decl_stmt|;
comment|/* Sanity check based on HW */
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82576
case|:
case|case
name|e1000_82580
case|:
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
name|maxqueues
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|e1000_i210
case|:
case|case
name|e1000_82575
case|:
name|maxqueues
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|e1000_i211
case|:
case|case
name|e1000_82574
case|:
name|maxqueues
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|maxqueues
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|maxqueues
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|EM_CAPS
define|\
value|IFCAP_TSO4 | IFCAP_TXCSUM | IFCAP_LRO | IFCAP_RXCSUM | IFCAP_VLAN_HWFILTER | IFCAP_WOL_MAGIC | \ 	IFCAP_WOL_MCAST | IFCAP_WOL | IFCAP_VLAN_HWTSO | IFCAP_HWCSUM | IFCAP_VLAN_HWTAGGING | \ 	IFCAP_VLAN_HWCSUM | IFCAP_VLAN_HWTSO | IFCAP_VLAN_MTU;
end_define

begin_define
define|#
directive|define
name|IGB_CAPS
define|\
value|IFCAP_TSO4 | IFCAP_TXCSUM | IFCAP_LRO | IFCAP_RXCSUM | IFCAP_VLAN_HWFILTER | IFCAP_WOL_MAGIC | \ 	IFCAP_WOL_MCAST | IFCAP_WOL | IFCAP_VLAN_HWTSO | IFCAP_HWCSUM | IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_HWCSUM | \ 	IFCAP_VLAN_HWTSO | IFCAP_VLAN_MTU | IFCAP_TXCSUM_IPV6 | IFCAP_HWCSUM_IPV6 | IFCAP_JUMBO_MTU;
end_define

begin_comment
comment|/*********************************************************************  *  Device initialization routine  *  *  The attach entry point is called when the driver is being loaded.  *  This routine identifies the type of hardware, allocates all resources  *  and initializes the hardware.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_if_attach_pre
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|if_softc_ctx_t
name|scctx
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_if_attach_pre begin"
argument_list|)
expr_stmt|;
name|dev
operator|=
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|adapter
operator|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"em"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Disabled by device hint\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|adapter
operator|->
name|dev
operator|=
name|adapter
operator|->
name|osdep
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|scctx
operator|=
name|adapter
operator|->
name|shared
operator|=
name|iflib_get_softc_ctx
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|media
operator|=
name|iflib_get_media
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|hw
operator|=
operator|&
name|adapter
operator|->
name|hw
expr_stmt|;
name|adapter
operator|->
name|tx_process_limit
operator|=
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
expr_stmt|;
comment|/* SYSCTL stuff */
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nvm"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|em_sysctl_nvm_info
argument_list|,
literal|"I"
argument_list|,
literal|"NVM Information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|em_sysctl_debug_info
argument_list|,
literal|"I"
argument_list|,
literal|"Debug Information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|em_set_flowcntl
argument_list|,
literal|"I"
argument_list|,
literal|"Flow Control"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"reg_dump"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|em_get_regs
argument_list|,
literal|"A"
argument_list|,
literal|"Dump Registers"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rs_dump"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|em_get_rs
argument_list|,
literal|"I"
argument_list|,
literal|"Dump RS indexes"
argument_list|)
expr_stmt|;
comment|/* Determine hardware and mac info */
name|em_identify_hardware
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* Set isc_msix_bar */
name|scctx
operator|->
name|isc_msix_bar
operator|=
name|PCIR_BAR
argument_list|(
name|EM_MSIX_BAR
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_tx_nsegments
operator|=
name|EM_MAX_SCATTER
expr_stmt|;
name|scctx
operator|->
name|isc_tx_tso_segments_max
operator|=
name|scctx
operator|->
name|isc_tx_nsegments
expr_stmt|;
name|scctx
operator|->
name|isc_tx_tso_size_max
operator|=
name|EM_TSO_SIZE
expr_stmt|;
name|scctx
operator|->
name|isc_tx_tso_segsize_max
operator|=
name|EM_TSO_SEG_SIZE
expr_stmt|;
name|scctx
operator|->
name|isc_nrxqsets_max
operator|=
name|scctx
operator|->
name|isc_ntxqsets_max
operator|=
name|em_set_num_queues
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"attach_pre capping queues at %d\n"
argument_list|,
name|scctx
operator|->
name|isc_ntxqsets_max
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_tx_csum_flags
operator|=
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP_TSO
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
condition|)
block|{
name|int
name|try_second_bar
decl_stmt|;
name|scctx
operator|->
name|isc_txqsizes
index|[
literal|0
index|]
operator|=
name|roundup2
argument_list|(
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|e1000_adv_tx_desc
argument_list|)
argument_list|,
name|EM_DBA_ALIGN
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_rxqsizes
index|[
literal|0
index|]
operator|=
name|roundup2
argument_list|(
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|e1000_adv_rx_desc
argument_list|)
argument_list|,
name|EM_DBA_ALIGN
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_txd_size
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|e1000_adv_tx_desc
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_rxd_size
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|e1000_adv_rx_desc
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_txrx
operator|=
operator|&
name|igb_txrx
expr_stmt|;
name|scctx
operator|->
name|isc_capenable
operator|=
name|IGB_CAPS
expr_stmt|;
name|scctx
operator|->
name|isc_tx_csum_flags
operator|=
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_TSO
operator||
name|CSUM_IP6_TCP
expr|\
operator||
name|CSUM_IP6_UDP
operator||
name|CSUM_IP6_TCP
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|!=
name|e1000_82575
condition|)
name|scctx
operator|->
name|isc_tx_csum_flags
operator||=
name|CSUM_SCTP
operator||
name|CSUM_IP6_SCTP
expr_stmt|;
comment|/* 		** Some new devices, as with ixgbe, now may 		** use a different BAR, so we need to keep 		** track of which is used. 		*/
name|try_second_bar
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|scctx
operator|->
name|isc_msix_bar
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|try_second_bar
operator|==
literal|0
condition|)
name|scctx
operator|->
name|isc_msix_bar
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|em_mac_min
condition|)
block|{
name|scctx
operator|->
name|isc_txqsizes
index|[
literal|0
index|]
operator|=
name|roundup2
argument_list|(
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
argument_list|,
name|EM_DBA_ALIGN
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_rxqsizes
index|[
literal|0
index|]
operator|=
name|roundup2
argument_list|(
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|e1000_rx_desc_extended
argument_list|)
argument_list|,
name|EM_DBA_ALIGN
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_txd_size
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_rxd_size
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|e1000_rx_desc_extended
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_txrx
operator|=
operator|&
name|em_txrx
expr_stmt|;
name|scctx
operator|->
name|isc_capenable
operator|=
name|EM_CAPS
expr_stmt|;
name|scctx
operator|->
name|isc_tx_csum_flags
operator|=
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP_TSO
expr_stmt|;
block|}
else|else
block|{
name|scctx
operator|->
name|isc_txqsizes
index|[
literal|0
index|]
operator|=
name|roundup2
argument_list|(
operator|(
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
argument_list|,
name|EM_DBA_ALIGN
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_rxqsizes
index|[
literal|0
index|]
operator|=
name|roundup2
argument_list|(
operator|(
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_rx_desc
argument_list|)
argument_list|,
name|EM_DBA_ALIGN
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_txd_size
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_rxd_size
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_rx_desc
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_tx_csum_flags
operator|=
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP_TSO
expr_stmt|;
name|scctx
operator|->
name|isc_txrx
operator|=
operator|&
name|lem_txrx
expr_stmt|;
name|scctx
operator|->
name|isc_capenable
operator|=
name|EM_CAPS
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|<
name|e1000_82543
condition|)
name|scctx
operator|->
name|isc_capenable
operator|&=
operator|~
operator|(
name|IFCAP_HWCSUM
operator||
name|IFCAP_VLAN_HWCSUM
operator|)
expr_stmt|;
name|scctx
operator|->
name|isc_tx_csum_flags
operator|=
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP_TSO
expr_stmt|;
name|scctx
operator|->
name|isc_msix_bar
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Setup PCI resources */
if|if
condition|(
name|em_allocate_pci_resources
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Allocation of PCI resources failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_pci
goto|;
block|}
comment|/* 	** For ICH8 and family we need to 	** map the flash memory, and this 	** must happen after the MAC is 	** identified 	*/
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich9lan
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich10lan
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pchlan
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch_lpt
operator|)
condition|)
block|{
name|int
name|rid
init|=
name|EM_BAR_TYPE_FLASH
decl_stmt|;
name|adapter
operator|->
name|flash
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|flash
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Mapping of Flash failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_pci
goto|;
block|}
comment|/* This is used in the shared code */
name|hw
operator|->
name|flash_address
operator|=
operator|(
name|u8
operator|*
operator|)
name|adapter
operator|->
name|flash
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|flash_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|flash
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|flash_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|flash
argument_list|)
expr_stmt|;
block|}
comment|/* 	** In the new SPT device flash is not  a 	** separate BAR, rather it is also in BAR0, 	** so use the same tag and an offset handle for the 	** FLASH read/write macros in the shared code. 	*/
elseif|else
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch_spt
condition|)
block|{
name|adapter
operator|->
name|osdep
operator|.
name|flash_bus_space_tag
operator|=
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|flash_bus_space_handle
operator|=
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|+
name|E1000_FLASH_BASE_ADDR
expr_stmt|;
block|}
comment|/* Do Shared Code initialization */
name|error
operator|=
name|e1000_setup_init_funcs
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Setup of Shared code failed, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_pci
goto|;
block|}
name|em_setup_msix
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|e1000_get_bus_info
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set up some sysctls for the tunable interrupt delays */
name|em_add_int_delay_sysctl
argument_list|(
name|adapter
argument_list|,
literal|"rx_int_delay"
argument_list|,
literal|"receive interrupt delay in usecs"
argument_list|,
operator|&
name|adapter
operator|->
name|rx_int_delay
argument_list|,
name|E1000_REGISTER
argument_list|(
name|hw
argument_list|,
name|E1000_RDTR
argument_list|)
argument_list|,
name|em_rx_int_delay_dflt
argument_list|)
expr_stmt|;
name|em_add_int_delay_sysctl
argument_list|(
name|adapter
argument_list|,
literal|"tx_int_delay"
argument_list|,
literal|"transmit interrupt delay in usecs"
argument_list|,
operator|&
name|adapter
operator|->
name|tx_int_delay
argument_list|,
name|E1000_REGISTER
argument_list|(
name|hw
argument_list|,
name|E1000_TIDV
argument_list|)
argument_list|,
name|em_tx_int_delay_dflt
argument_list|)
expr_stmt|;
name|em_add_int_delay_sysctl
argument_list|(
name|adapter
argument_list|,
literal|"rx_abs_int_delay"
argument_list|,
literal|"receive interrupt delay limit in usecs"
argument_list|,
operator|&
name|adapter
operator|->
name|rx_abs_int_delay
argument_list|,
name|E1000_REGISTER
argument_list|(
name|hw
argument_list|,
name|E1000_RADV
argument_list|)
argument_list|,
name|em_rx_abs_int_delay_dflt
argument_list|)
expr_stmt|;
name|em_add_int_delay_sysctl
argument_list|(
name|adapter
argument_list|,
literal|"tx_abs_int_delay"
argument_list|,
literal|"transmit interrupt delay limit in usecs"
argument_list|,
operator|&
name|adapter
operator|->
name|tx_abs_int_delay
argument_list|,
name|E1000_REGISTER
argument_list|(
name|hw
argument_list|,
name|E1000_TADV
argument_list|)
argument_list|,
name|em_tx_abs_int_delay_dflt
argument_list|)
expr_stmt|;
name|em_add_int_delay_sysctl
argument_list|(
name|adapter
argument_list|,
literal|"itr"
argument_list|,
literal|"interrupt delay limit in usecs/4"
argument_list|,
operator|&
name|adapter
operator|->
name|tx_itr
argument_list|,
name|E1000_REGISTER
argument_list|(
name|hw
argument_list|,
name|E1000_ITR
argument_list|)
argument_list|,
name|DEFAULT_ITR
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|autoneg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|autoneg_wait_to_complete
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|=
name|AUTONEG_ADV_DEFAULT
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|<
name|em_mac_min
condition|)
block|{
name|e1000_init_script_state_82541
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|e1000_set_tbi_compatibility_82543
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* Copper options */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|mdix
operator|=
name|AUTO_ALL_MODES
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|disable_polarity_correction
operator|=
name|FALSE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ms_type
operator|=
name|EM_MASTER_SLAVE
expr_stmt|;
block|}
comment|/* 	 * Set the frame limits assuming 	 * standard ethernet sized frames. 	 */
name|scctx
operator|->
name|isc_max_frame_size
operator|=
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
operator|=
name|ETHERMTU
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHERNET_FCS_SIZE
expr_stmt|;
comment|/* 	 * This controls when hardware reports transmit completion 	 * status. 	 */
name|hw
operator|->
name|mac
operator|.
name|report_tx_early
operator|=
literal|1
expr_stmt|;
comment|/* Allocate multicast array memory. */
name|adapter
operator|->
name|mta
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
operator|*
name|ETH_ADDR_LEN
operator|*
name|MAX_NUM_MULTICAST_ADDRESSES
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|mta
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can not allocate multicast setup array\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Check SOL/IDER usage */
if|if
condition|(
name|e1000_check_reset_block
argument_list|(
name|hw
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PHY reset is blocked"
literal|" due to SOL/IDER session.\n"
argument_list|)
expr_stmt|;
comment|/* Sysctl for setting Energy Efficient Ethernet */
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|eee_disable
operator|=
name|eee_setting
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"eee_control"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|em_sysctl_eee
argument_list|,
literal|"I"
argument_list|,
literal|"Disable Energy Efficient Ethernet"
argument_list|)
expr_stmt|;
comment|/* 	** Start from a known state, this is 	** important in reading the nvm and 	** mac from that. 	*/
name|e1000_reset_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Make sure we have a good EEPROM before we read from it */
if|if
condition|(
name|e1000_validate_nvm_checksum
argument_list|(
name|hw
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 		** Some PCI-E parts fail the first check due to 		** the link being in sleep state, call it again, 		** if it fails a second time its a real issue. 		*/
if|if
condition|(
name|e1000_validate_nvm_checksum
argument_list|(
name|hw
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The EEPROM Checksum Is Not Valid\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
block|}
comment|/* Copy the permanent MAC address out of the EEPROM */
if|if
condition|(
name|e1000_read_mac_addr
argument_list|(
name|hw
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"EEPROM read error while reading MAC"
literal|" address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
if|if
condition|(
operator|!
name|em_is_valid_ether_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid MAC address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Disable ULP support */
name|e1000_disable_ulp_lpt_lp
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Get Wake-on-Lan and Management info for later use 	 */
name|em_get_wakeup
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|iflib_set_mac
argument_list|(
name|ctx
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_late
label|:
name|em_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_pci
label|:
name|em_free_pci_resources
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|mta
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_if_attach_post
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Setup OS specific network interface */
name|error
operator|=
name|em_setup_interface
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
goto|goto
name|err_late
goto|;
block|}
name|em_reset
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* Initialize statistics */
name|em_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|get_link_status
operator|=
literal|1
expr_stmt|;
name|em_if_update_admin_status
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|em_add_hw_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Non-AMT based hardware can now take control from firmware */
if|if
condition|(
name|adapter
operator|->
name|has_manage
operator|&&
operator|!
name|adapter
operator|->
name|has_amt
condition|)
name|em_get_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_if_attach_post: end"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|err_late
label|:
name|em_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_free_pci_resources
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|em_if_queues_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|mta
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device removal routine  *  *  The detach entry point is called when the driver is being removed.  *  This routine stops the adapter and deallocates all the resources  *  that were allocated for driver operation.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_if_detach
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_detach: begin"
argument_list|)
expr_stmt|;
name|e1000_phy_hw_reset
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|em_release_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_free_pci_resources
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Shutdown entry point  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_if_shutdown
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
return|return
name|em_if_suspend
argument_list|(
name|ctx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Suspend/resume device methods.  */
end_comment

begin_function
specifier|static
name|int
name|em_if_suspend
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|em_release_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_enable_wakeup
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_if_resume
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
condition|)
name|e1000_resume_workarounds_pchlan
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|em_if_init
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|em_init_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_if_mtu_set
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|uint32_t
name|mtu
parameter_list|)
block|{
name|int
name|max_frame_size
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|iflib_get_softc_ctx
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
case|case
name|e1000_ich9lan
case|:
case|case
name|e1000_ich10lan
case|:
case|case
name|e1000_pch2lan
case|:
case|case
name|e1000_pch_lpt
case|:
case|case
name|e1000_pch_spt
case|:
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
case|case
name|e1000_80003es2lan
case|:
comment|/* 9K Jumbo Frame size */
name|max_frame_size
operator|=
literal|9234
expr_stmt|;
break|break;
case|case
name|e1000_pchlan
case|:
name|max_frame_size
operator|=
literal|4096
expr_stmt|;
break|break;
case|case
name|e1000_82542
case|:
case|case
name|e1000_ich8lan
case|:
comment|/* Adapters that do not support jumbo frames */
name|max_frame_size
operator|=
name|ETHER_MAX_LEN
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
condition|)
name|max_frame_size
operator|=
literal|9234
expr_stmt|;
else|else
comment|/* lem */
name|max_frame_size
operator|=
name|MAX_JUMBO_FRAME_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|mtu
operator|>
name|max_frame_size
operator|-
name|ETHER_HDR_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|scctx
operator|->
name|isc_max_frame_size
operator|=
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
operator|=
name|mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Init entry point  *  *  This routine is used in two ways. It is used by the stack as  *  init entry point in network interface structure. It is also used  *  by the driver as a hw/sw initialization routine to get to a  *  consistent state.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_if_init
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|iflib_get_ifp
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|tx_que
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_if_init: begin"
argument_list|)
expr_stmt|;
comment|/* Get the latest mac address, User can use a LAA */
name|bcopy
argument_list|(
name|if_getlladdr
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Put the address into the Receive Address Array */
name|e1000_rar_set
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * With the 82571 adapter, RAR[0] may be overwritten 	 * when the other port is reset, we make a duplicate 	 * in RAR[14] for that eventuality, this assures 	 * the interface continues to function. 	 */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82571
condition|)
block|{
name|e1000_set_laa_state_82571
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|e1000_rar_set
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
name|E1000_RAR_ENTRIES
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the hardware */
name|em_reset
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|em_if_update_admin_status
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tx_que
operator|=
name|adapter
operator|->
name|tx_queues
init|;
name|i
operator|<
name|adapter
operator|->
name|tx_num_queues
condition|;
name|i
operator|++
operator|,
name|tx_que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|tx_que
operator|->
name|txr
decl_stmt|;
name|txr
operator|->
name|tx_rs_cidx
operator|=
name|txr
operator|->
name|tx_rs_pidx
operator|=
name|txr
operator|->
name|tx_cidx_processed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Setup VLAN support, basic and offload if available */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_VET
argument_list|,
name|ETHERTYPE_VLAN
argument_list|)
expr_stmt|;
comment|/* Clear bad data from Rx FIFOs */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
condition|)
name|e1000_rx_fifo_flush_82575
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Configure for OS presence */
name|em_init_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Prepare transmit descriptors and buffers */
name|em_initialize_transmit_unit
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* Setup Multicast table */
name|em_if_multi_set
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out the desired mbuf 	 * pool for doing jumbos 	 */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
operator|<=
literal|2048
condition|)
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MCLBYTES
expr_stmt|;
ifndef|#
directive|ifndef
name|CONTIGMALLOC_WORKS
else|else
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUMPAGESIZE
expr_stmt|;
else|#
directive|else
elseif|else
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
operator|<=
literal|4096
condition|)
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUMPAGESIZE
expr_stmt|;
else|else
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUM9BYTES
expr_stmt|;
endif|#
directive|endif
name|em_initialize_receive_unit
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* Use real VLAN Filter support? */
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
comment|/* Use real VLAN Filter support */
name|em_setup_vlan_hw_support
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
block|{
name|u32
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_VME
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't lose promiscuous settings */
name|em_if_set_promisc
argument_list|(
name|ctx
argument_list|,
name|IFF_PROMISC
argument_list|)
expr_stmt|;
name|e1000_clear_hw_cntrs_base_generic
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* MSI/X configuration for 82574 */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
block|{
name|int
name|tmp
init|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
decl_stmt|;
name|tmp
operator||=
name|E1000_CTRL_EXT_PBA_CLR
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Set the IVAR - interrupt vector routing. */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IVAR
argument_list|,
name|adapter
operator|->
name|ivars
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|intr_type
operator|==
name|IFLIB_INTR_MSIX
condition|)
comment|/* Set up queue routing */
name|igb_configure_queues
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* this clears any pending interrupts */
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICS
argument_list|,
name|E1000_ICS_LSC
argument_list|)
expr_stmt|;
comment|/* AMT based hardware can now take control from firmware */
if|if
condition|(
name|adapter
operator|->
name|has_manage
operator|&&
name|adapter
operator|->
name|has_amt
condition|)
name|em_get_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Set Energy Efficient Ethernet */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
operator|&&
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_i354
condition|)
name|e1000_set_eee_i354
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|e1000_set_eee_i350
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Fast Legacy/MSI Combined Interrupt Service routine  *  *********************************************************************/
end_comment

begin_function
name|int
name|em_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|if_ctx_t
name|ctx
init|=
name|adapter
operator|->
name|ctx
decl_stmt|;
name|u32
name|reg_icr
decl_stmt|;
name|reg_icr
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|intr_type
operator|!=
name|IFLIB_INTR_LEGACY
condition|)
goto|goto
name|skip_stray
goto|;
comment|/* Hot eject? */
if|if
condition|(
name|reg_icr
operator|==
literal|0xffffffff
condition|)
return|return
name|FILTER_STRAY
return|;
comment|/* Definitely not our interrupt. */
if|if
condition|(
name|reg_icr
operator|==
literal|0x0
condition|)
return|return
name|FILTER_STRAY
return|;
comment|/* 	 * Starting with the 82571 chip, bit 31 should be used to 	 * determine whether the interrupt belongs to us. 	 */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82571
operator|&&
operator|(
name|reg_icr
operator|&
name|E1000_ICR_INT_ASSERTED
operator|)
operator|==
literal|0
condition|)
return|return
name|FILTER_STRAY
return|;
name|skip_stray
label|:
comment|/* Link status change */
if|if
condition|(
name|reg_icr
operator|&
operator|(
name|E1000_ICR_RXSEQ
operator||
name|E1000_ICR_LSC
operator|)
condition|)
block|{
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|get_link_status
operator|=
literal|1
expr_stmt|;
name|iflib_admin_intr_deferred
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_icr
operator|&
name|E1000_ICR_RXO
condition|)
name|adapter
operator|->
name|rx_overruns
operator|++
expr_stmt|;
return|return
operator|(
name|FILTER_SCHEDULE_THREAD
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_rx_enable_queue
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|em_rx_queue
modifier|*
name|rxq
parameter_list|)
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIMS
argument_list|,
name|rxq
operator|->
name|eims
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_rx_enable_queue
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|em_rx_queue
modifier|*
name|rxq
parameter_list|)
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|rxq
operator|->
name|eims
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_tx_enable_queue
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|em_tx_queue
modifier|*
name|txq
parameter_list|)
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIMS
argument_list|,
name|txq
operator|->
name|eims
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_tx_enable_queue
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|em_tx_queue
modifier|*
name|txq
parameter_list|)
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|txq
operator|->
name|eims
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_if_rx_queue_intr_enable
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|rxq
init|=
operator|&
name|adapter
operator|->
name|rx_queues
index|[
name|rxqid
index|]
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
condition|)
name|igb_rx_enable_queue
argument_list|(
name|adapter
argument_list|,
name|rxq
argument_list|)
expr_stmt|;
else|else
name|em_rx_enable_queue
argument_list|(
name|adapter
argument_list|,
name|rxq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_if_tx_queue_intr_enable
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|uint16_t
name|txqid
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|txq
init|=
operator|&
name|adapter
operator|->
name|tx_queues
index|[
name|txqid
index|]
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
condition|)
name|igb_tx_enable_queue
argument_list|(
name|adapter
argument_list|,
name|txq
argument_list|)
expr_stmt|;
else|else
name|em_tx_enable_queue
argument_list|(
name|adapter
argument_list|,
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX RX Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_msix_que
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|em_rx_queue
modifier|*
name|que
init|=
name|arg
decl_stmt|;
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
return|return
operator|(
name|FILTER_SCHEDULE_THREAD
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX Link Fast Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_msix_link
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|u32
name|reg_icr
decl_stmt|;
operator|++
name|adapter
operator|->
name|link_irq
expr_stmt|;
name|MPASS
argument_list|(
name|adapter
operator|->
name|hw
operator|.
name|back
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|reg_icr
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_icr
operator|&
name|E1000_ICR_RXO
condition|)
name|adapter
operator|->
name|rx_overruns
operator|++
expr_stmt|;
if|if
condition|(
name|reg_icr
operator|&
operator|(
name|E1000_ICR_RXSEQ
operator||
name|E1000_ICR_LSC
operator|)
condition|)
block|{
name|em_handle_link
argument_list|(
name|adapter
operator|->
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|EM_MSIX_LINK
operator||
name|E1000_IMS_LSC
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
condition|)
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIMS
argument_list|,
name|adapter
operator|->
name|link_mask
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Because we must read the ICR for this interrupt 	 * it may clear other causes using autoclear, for 	 * this reason we simply create a soft interrupt 	 * for all these vectors. 	 */
if|if
condition|(
name|reg_icr
operator|&&
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|<
name|igb_mac_min
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICS
argument_list|,
name|adapter
operator|->
name|ims
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_handle_link
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|context
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|get_link_status
operator|=
literal|1
expr_stmt|;
name|iflib_admin_intr_deferred
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called whenever the user queries the status of  *  the interface using ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_if_media_status
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|u_char
name|fiber_type
init|=
name|IFM_1000_SX
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_if_media_status: begin"
argument_list|)
expr_stmt|;
name|iflib_admin_intr_deferred
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
block|{
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_fiber
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
operator|)
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82545
condition|)
name|fiber_type
operator|=
name|IFM_1000_LX
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|fiber_type
operator||
name|IFM_FDX
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
literal|10
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
break|break;
case|case
literal|100
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
break|break;
case|case
literal|1000
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|adapter
operator|->
name|link_duplex
operator|==
name|FULL_DUPLEX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_HDX
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called when the user changes speed/duplex using  *  media/mediopt option with ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_if_media_change
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
name|iflib_get_media
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_if_media_change: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
name|AUTONEG_ADV_DEFAULT
expr_stmt|;
break|break;
case|case
name|IFM_1000_LX
case|:
case|case
name|IFM_1000_SX
case|:
case|case
name|IFM_1000_T
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
name|ADVERTISE_1000_FULL
expr_stmt|;
break|break;
case|case
name|IFM_100_TX
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|FALSE
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifm
operator|->
name|ifm_media
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
condition|)
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_100_FULL
expr_stmt|;
else|else
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_100_HALF
expr_stmt|;
break|break;
case|case
name|IFM_10_T
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|FALSE
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifm
operator|->
name|ifm_media
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
condition|)
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_10_FULL
expr_stmt|;
else|else
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_10_HALF
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Unsupported media type\n"
argument_list|)
expr_stmt|;
block|}
name|em_if_init
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_if_set_promisc
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|u32
name|reg_rctl
decl_stmt|;
name|em_disable_promisc
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|reg_rctl
operator||=
operator|(
name|E1000_RCTL_UPE
operator||
name|E1000_RCTL_MPE
operator|)
expr_stmt|;
comment|/* Turn this on if you want to see bad packets */
if|if
condition|(
name|em_debug_sbp
condition|)
name|reg_rctl
operator||=
name|E1000_RCTL_SBP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|reg_rctl
operator||=
name|E1000_RCTL_MPE
expr_stmt|;
name|reg_rctl
operator|&=
operator|~
name|E1000_RCTL_UPE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_disable_promisc
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|iflib_get_ifp
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|u32
name|reg_rctl
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|(
operator|~
name|E1000_RCTL_UPE
operator|)
expr_stmt|;
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_ALLMULTI
condition|)
name|mcnt
operator|=
name|MAX_NUM_MULTICAST_ADDRESSES
expr_stmt|;
else|else
name|mcnt
operator|=
name|if_multiaddr_count
argument_list|(
name|ifp
argument_list|,
name|MAX_NUM_MULTICAST_ADDRESSES
argument_list|)
expr_stmt|;
comment|/* Don't disable if in MAX groups */
if|if
condition|(
name|mcnt
operator|<
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
name|reg_rctl
operator|&=
operator|(
operator|~
name|E1000_RCTL_MPE
operator|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|(
operator|~
name|E1000_RCTL_SBP
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Multicast Update  *  *  This routine is called whenever multicast address list is updated.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_if_multi_set
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|iflib_get_ifp
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|u32
name|reg_rctl
init|=
literal|0
decl_stmt|;
name|u8
modifier|*
name|mta
decl_stmt|;
comment|/* Multicast array memory */
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"em_set_multi: begin"
argument_list|)
expr_stmt|;
name|mta
operator|=
name|adapter
operator|->
name|mta
expr_stmt|;
name|bzero
argument_list|(
name|mta
argument_list|,
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
operator|*
name|ETH_ADDR_LEN
operator|*
name|MAX_NUM_MULTICAST_ADDRESSES
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82542
operator|&&
name|adapter
operator|->
name|hw
operator|.
name|revision_id
operator|==
name|E1000_REVISION_2
condition|)
block|{
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
name|e1000_pci_clear_mwi
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|reg_rctl
operator||=
name|E1000_RCTL_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|if_multiaddr_array
argument_list|(
name|ifp
argument_list|,
name|mta
argument_list|,
operator|&
name|mcnt
argument_list|,
name|MAX_NUM_MULTICAST_ADDRESSES
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>=
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
block|{
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|reg_rctl
operator||=
name|E1000_RCTL_MPE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
else|else
name|e1000_update_mc_addr_list
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|mta
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82542
operator|&&
name|adapter
operator|->
name|hw
operator|.
name|revision_id
operator|==
name|E1000_REVISION_2
condition|)
block|{
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|~
name|E1000_RCTL_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
name|e1000_pci_set_mwi
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Timer routine  *  *  This routine checks for link status and updates statistics.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_if_timer
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|uint16_t
name|qid
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|trigger
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|qid
operator|!=
literal|0
condition|)
return|return;
name|em_if_update_admin_status
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|em_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Reset LAA into RAR[0] on 82571 */
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82571
operator|)
operator|&&
name|e1000_get_laa_state_82571
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
condition|)
name|e1000_rar_set
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|<
name|em_mac_min
condition|)
name|lem_smartspeed
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Mask to use in the irq trigger */
if|if
condition|(
name|adapter
operator|->
name|intr_type
operator|==
name|IFLIB_INTR_MSIX
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|que
operator|=
name|adapter
operator|->
name|rx_queues
init|;
name|i
operator|<
name|adapter
operator|->
name|rx_num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
name|trigger
operator||=
name|que
operator|->
name|eims
expr_stmt|;
block|}
else|else
block|{
name|trigger
operator|=
name|E1000_ICS_RXDMT0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|em_if_update_admin_status
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|iflib_get_ifp
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|device_t
name|dev
init|=
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|u32
name|link_check
decl_stmt|,
name|thstat
decl_stmt|,
name|ctrl
decl_stmt|;
name|link_check
operator|=
name|thstat
operator|=
name|ctrl
operator|=
literal|0
expr_stmt|;
comment|/* Get the cached link value or read phy for real */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
condition|)
block|{
case|case
name|e1000_media_type_copper
case|:
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|get_link_status
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch_spt
condition|)
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Do the work to read phy */
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|link_check
operator|=
operator|!
name|hw
operator|->
name|mac
operator|.
name|get_link_status
expr_stmt|;
if|if
condition|(
name|link_check
condition|)
comment|/* ESB2 fix */
name|e1000_cfg_on_link_up
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|link_check
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|e1000_media_type_fiber
case|:
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|link_check
operator|=
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_LU
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_media_type_internal_serdes
case|:
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|link_check
operator|=
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|serdes_has_link
expr_stmt|;
break|break;
comment|/* VF device is type_unknown */
case|case
name|e1000_media_type_unknown
case|:
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|link_check
operator|=
operator|!
name|hw
operator|->
name|mac
operator|.
name|get_link_status
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
break|break;
block|}
comment|/* Check for thermal downshift or shutdown */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i350
condition|)
block|{
name|thstat
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_THSTAT
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
block|}
comment|/* Now check for a transition */
if|if
condition|(
name|link_check
operator|&&
operator|(
name|adapter
operator|->
name|link_active
operator|==
literal|0
operator|)
condition|)
block|{
name|e1000_get_speed_and_duplex
argument_list|(
name|hw
argument_list|,
operator|&
name|adapter
operator|->
name|link_speed
argument_list|,
operator|&
name|adapter
operator|->
name|link_duplex
argument_list|)
expr_stmt|;
comment|/* Check if we must disable SPEED_MODE bit on PCI-E */
if|if
condition|(
operator|(
name|adapter
operator|->
name|link_speed
operator|!=
name|SPEED_1000
operator|)
operator|&&
operator|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82571
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82572
operator|)
operator|)
condition|)
block|{
name|int
name|tarc0
decl_stmt|;
name|tarc0
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tarc0
operator|&=
operator|~
name|TARC_SPEED_MODE_BIT
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|tarc0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is up %d Mbps %s\n"
argument_list|,
name|adapter
operator|->
name|link_speed
argument_list|,
operator|(
operator|(
name|adapter
operator|->
name|link_duplex
operator|==
name|FULL_DUPLEX
operator|)
condition|?
literal|"Full Duplex"
else|:
literal|"Half Duplex"
operator|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|smartspeed
operator|=
literal|0
expr_stmt|;
name|if_setbaudrate
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|link_speed
operator|*
literal|1000000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctrl
operator|&
name|E1000_CTRL_EXT_LINK_MODE_GMII
operator|)
operator|&&
operator|(
name|thstat
operator|&
name|E1000_THSTAT_LINK_THROTTLE
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link: thermal downshift\n"
argument_list|)
expr_stmt|;
comment|/* Delay Link Up for Phy update */
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i210
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i211
operator|)
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|id
operator|==
name|I210_I_PHY_ID
operator|)
condition|)
name|msec_delay
argument_list|(
name|I210_LINK_DELAY
argument_list|)
expr_stmt|;
comment|/* Reset if the media type changed. */
if|if
condition|(
operator|(
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
operator|.
name|media_changed
operator|)
operator|&&
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
operator|)
condition|)
block|{
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
operator|.
name|media_changed
operator|=
name|false
expr_stmt|;
name|adapter
operator|->
name|flags
operator||=
name|IGB_MEDIA_RESET
expr_stmt|;
name|em_reset
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
name|iflib_link_state_change
argument_list|(
name|ctx
argument_list|,
name|LINK_STATE_UP
argument_list|,
name|ifp
operator|->
name|if_baudrate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Link state changed to up\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|link_check
operator|&&
operator|(
name|adapter
operator|->
name|link_active
operator|==
literal|1
operator|)
condition|)
block|{
name|if_setbaudrate
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_speed
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|link_duplex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is Down\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
literal|0
expr_stmt|;
name|iflib_link_state_change
argument_list|(
name|ctx
argument_list|,
name|LINK_STATE_DOWN
argument_list|,
name|ifp
operator|->
name|if_baudrate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"link state changed to down\n"
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|EM_MSIX_LINK
operator||
name|E1000_IMS_LSC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine disables all traffic on the adapter by issuing a  *  global reset on the MAC and deallocates TX/RX buffers.  *  *  This routine should always be called with BOTH the CORE  *  and TX locks.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_if_stop
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_stop: begin"
argument_list|)
expr_stmt|;
name|e1000_reset_hw
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82544
condition|)
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUFC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e1000_led_off
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|e1000_cleanup_led
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Determine hardware revision.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_identify_hardware
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
comment|/* Make sure our PCI config space has the necessary stuff set */
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|pci_cmd_word
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Save off the information about this board */
name|adapter
operator|->
name|hw
operator|.
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|revision_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|subsystem_vendor_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|subsystem_device_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Do Shared Code Init and Setup */
if|if
condition|(
name|e1000_set_mac_type
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Setup init failure\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|em_allocate_pci_resources
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|device_t
name|dev
init|=
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|val
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|memory
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|memory
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|memory
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|memory
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|hw_addr
operator|=
operator|(
name|u8
operator|*
operator|)
operator|&
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
expr_stmt|;
comment|/* Only older adapters use IO mapping */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|<
name|em_mac_min
operator|&&
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>
name|e1000_82543
condition|)
block|{
comment|/* Figure our where our IO BAR is ? */
for|for
control|(
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
init|;
name|rid
operator|<
name|PCIR_CIS
condition|;
control|)
block|{
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|EM_BAR_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|EM_BAR_TYPE_IO
condition|)
block|{
name|adapter
operator|->
name|io_rid
operator|=
name|rid
expr_stmt|;
break|break;
block|}
name|rid
operator|+=
literal|4
expr_stmt|;
comment|/* check for 64bit BAR */
if|if
condition|(
name|EM_BAR_MEM_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|EM_BAR_MEM_TYPE_64BIT
condition|)
name|rid
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|rid
operator|>=
name|PCIR_CIS
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to locate IO BAR\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|->
name|ioport
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|adapter
operator|->
name|io_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|ioport
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: "
literal|"ioport\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|->
name|hw
operator|.
name|io_base
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|io_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|ioport
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|io_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|ioport
argument_list|)
expr_stmt|;
block|}
name|adapter
operator|->
name|hw
operator|.
name|back
operator|=
operator|&
name|adapter
operator|->
name|osdep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup the MSIX Interrupt handlers  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_if_msix_intr_assign
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|int
name|msix
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|rx_que
init|=
name|adapter
operator|->
name|rx_queues
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|tx_que
init|=
name|adapter
operator|->
name|tx_queues
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|i
decl_stmt|,
name|vector
init|=
literal|0
decl_stmt|,
name|rx_vectors
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* First set up ring resources */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|rx_num_queues
condition|;
name|i
operator|++
operator|,
name|rx_que
operator|++
operator|,
name|vector
operator|++
control|)
block|{
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"rxq%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|error
operator|=
name|iflib_irq_alloc_generic
argument_list|(
name|ctx
argument_list|,
operator|&
name|rx_que
operator|->
name|que_irq
argument_list|,
name|rid
argument_list|,
name|IFLIB_INTR_RXTX
argument_list|,
name|em_msix_que
argument_list|,
name|rx_que
argument_list|,
name|rx_que
operator|->
name|me
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
argument_list|,
literal|"Failed to allocate que int %d err: %d"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|rx_num_queues
operator|=
name|i
operator|+
literal|1
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rx_que
operator|->
name|msix
operator|=
name|vector
expr_stmt|;
comment|/* 		 * Set the bit to enable interrupt 		 * in E1000_IMS -- bits 20 and 21 		 * are for RX0 and RX1, note this has 		 * NOTHING to do with the MSIX vector 		 */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
block|{
name|rx_que
operator|->
name|eims
operator|=
literal|1
operator|<<
operator|(
literal|20
operator|+
name|i
operator|)
expr_stmt|;
name|adapter
operator|->
name|ims
operator||=
name|rx_que
operator|->
name|eims
expr_stmt|;
name|adapter
operator|->
name|ivars
operator||=
operator|(
literal|8
operator||
name|rx_que
operator|->
name|msix
operator|)
operator|<<
operator|(
name|i
operator|*
literal|4
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
name|rx_que
operator|->
name|eims
operator|=
name|E1000_EICR_TX_QUEUE0
operator|<<
name|vector
expr_stmt|;
else|else
name|rx_que
operator|->
name|eims
operator|=
literal|1
operator|<<
name|vector
expr_stmt|;
block|}
name|rx_vectors
operator|=
name|vector
expr_stmt|;
name|vector
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|tx_num_queues
condition|;
name|i
operator|++
operator|,
name|tx_que
operator|++
operator|,
name|vector
operator|++
control|)
block|{
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"txq%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tx_que
operator|=
operator|&
name|adapter
operator|->
name|tx_queues
index|[
name|i
index|]
expr_stmt|;
name|iflib_softirq_alloc_generic
argument_list|(
name|ctx
argument_list|,
name|rid
argument_list|,
name|IFLIB_INTR_TX
argument_list|,
name|tx_que
argument_list|,
name|tx_que
operator|->
name|me
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|tx_que
operator|->
name|msix
operator|=
operator|(
name|vector
operator|%
name|adapter
operator|->
name|tx_num_queues
operator|)
expr_stmt|;
comment|/* 		 * Set the bit to enable interrupt 		 * in E1000_IMS -- bits 22 and 23 		 * are for TX0 and TX1, note this has 		 * NOTHING to do with the MSIX vector 		 */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
block|{
name|tx_que
operator|->
name|eims
operator|=
literal|1
operator|<<
operator|(
literal|22
operator|+
name|i
operator|)
expr_stmt|;
name|adapter
operator|->
name|ims
operator||=
name|tx_que
operator|->
name|eims
expr_stmt|;
name|adapter
operator|->
name|ivars
operator||=
operator|(
literal|8
operator||
name|tx_que
operator|->
name|msix
operator|)
operator|<<
operator|(
literal|8
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
block|{
name|tx_que
operator|->
name|eims
operator|=
name|E1000_EICR_TX_QUEUE0
operator|<<
operator|(
name|i
operator|%
name|adapter
operator|->
name|tx_num_queues
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tx_que
operator|->
name|eims
operator|=
literal|1
operator|<<
operator|(
name|i
operator|%
name|adapter
operator|->
name|tx_num_queues
operator|)
expr_stmt|;
block|}
block|}
comment|/* Link interrupt */
name|rid
operator|=
name|rx_vectors
operator|+
literal|1
expr_stmt|;
name|error
operator|=
name|iflib_irq_alloc_generic
argument_list|(
name|ctx
argument_list|,
operator|&
name|adapter
operator|->
name|irq
argument_list|,
name|rid
argument_list|,
name|IFLIB_INTR_ADMIN
argument_list|,
name|em_msix_link
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
literal|"aq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
argument_list|,
literal|"Failed to register admin handler"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|adapter
operator|->
name|linkvec
operator|=
name|rx_vectors
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|<
name|igb_mac_min
condition|)
block|{
name|adapter
operator|->
name|ivars
operator||=
operator|(
literal|8
operator||
name|rx_vectors
operator|)
operator|<<
literal|16
expr_stmt|;
name|adapter
operator|->
name|ivars
operator||=
literal|0x80000000
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|iflib_irq_free
argument_list|(
name|ctx
argument_list|,
operator|&
name|adapter
operator|->
name|irq
argument_list|)
expr_stmt|;
name|rx_que
operator|=
name|adapter
operator|->
name|rx_queues
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|rx_num_queues
condition|;
name|i
operator|++
operator|,
name|rx_que
operator|++
control|)
name|iflib_irq_free
argument_list|(
name|ctx
argument_list|,
operator|&
name|rx_que
operator|->
name|que_irq
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_configure_queues
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|rx_que
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|tx_que
decl_stmt|;
name|u32
name|tmp
decl_stmt|,
name|ivar
init|=
literal|0
decl_stmt|,
name|newitr
init|=
literal|0
decl_stmt|;
comment|/* First turn on RSS capability */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|!=
name|e1000_82575
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GPIE
argument_list|,
name|E1000_GPIE_MSIX_MODE
operator||
name|E1000_GPIE_EIAME
operator||
name|E1000_GPIE_PBA
operator||
name|E1000_GPIE_NSICR
argument_list|)
expr_stmt|;
comment|/* Turn on MSIX */
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82580
case|:
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
case|case
name|e1000_i210
case|:
case|case
name|e1000_i211
case|:
case|case
name|e1000_vfadapt
case|:
case|case
name|e1000_vfadapt_i350
case|:
comment|/* RX entries */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|rx_num_queues
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|index
init|=
name|i
operator|>>
literal|1
decl_stmt|;
name|ivar
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|rx_que
operator|=
operator|&
name|adapter
operator|->
name|rx_queues
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
block|{
name|ivar
operator|&=
literal|0xFF00FFFF
expr_stmt|;
name|ivar
operator||=
operator|(
name|rx_que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|16
expr_stmt|;
block|}
else|else
block|{
name|ivar
operator|&=
literal|0xFFFFFF00
expr_stmt|;
name|ivar
operator||=
name|rx_que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
block|}
comment|/* TX entries */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|tx_num_queues
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|index
init|=
name|i
operator|>>
literal|1
decl_stmt|;
name|ivar
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|tx_que
operator|=
operator|&
name|adapter
operator|->
name|tx_queues
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
block|{
name|ivar
operator|&=
literal|0x00FFFFFF
expr_stmt|;
name|ivar
operator||=
operator|(
name|tx_que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|24
expr_stmt|;
block|}
else|else
block|{
name|ivar
operator|&=
literal|0xFFFF00FF
expr_stmt|;
name|ivar
operator||=
operator|(
name|tx_que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|8
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|que_mask
operator||=
name|tx_que
operator|->
name|eims
expr_stmt|;
block|}
comment|/* And for the link interrupt */
name|ivar
operator|=
operator|(
name|adapter
operator|->
name|linkvec
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|8
expr_stmt|;
name|adapter
operator|->
name|link_mask
operator|=
literal|1
operator|<<
name|adapter
operator|->
name|linkvec
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR_MISC
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_82576
case|:
comment|/* RX entries */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|rx_num_queues
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|index
init|=
name|i
operator|&
literal|0x7
decl_stmt|;
comment|/* Each IVAR has two entries */
name|ivar
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|rx_que
operator|=
operator|&
name|adapter
operator|->
name|rx_queues
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|8
condition|)
block|{
name|ivar
operator|&=
literal|0xFFFFFF00
expr_stmt|;
name|ivar
operator||=
name|rx_que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
expr_stmt|;
block|}
else|else
block|{
name|ivar
operator|&=
literal|0xFF00FFFF
expr_stmt|;
name|ivar
operator||=
operator|(
name|rx_que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|16
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|que_mask
operator||=
name|rx_que
operator|->
name|eims
expr_stmt|;
block|}
comment|/* TX entries */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|tx_num_queues
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|index
init|=
name|i
operator|&
literal|0x7
decl_stmt|;
comment|/* Each IVAR has two entries */
name|ivar
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|tx_que
operator|=
operator|&
name|adapter
operator|->
name|tx_queues
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|8
condition|)
block|{
name|ivar
operator|&=
literal|0xFFFF00FF
expr_stmt|;
name|ivar
operator||=
operator|(
name|tx_que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|8
expr_stmt|;
block|}
else|else
block|{
name|ivar
operator|&=
literal|0x00FFFFFF
expr_stmt|;
name|ivar
operator||=
operator|(
name|tx_que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|24
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|que_mask
operator||=
name|tx_que
operator|->
name|eims
expr_stmt|;
block|}
comment|/* And for the link interrupt */
name|ivar
operator|=
operator|(
name|adapter
operator|->
name|linkvec
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|8
expr_stmt|;
name|adapter
operator|->
name|link_mask
operator|=
literal|1
operator|<<
name|adapter
operator|->
name|linkvec
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR_MISC
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_82575
case|:
comment|/* enable MSI-X support*/
name|tmp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|tmp
operator||=
name|E1000_CTRL_EXT_PBA_CLR
expr_stmt|;
comment|/* Auto-Mask interrupts upon ICR read. */
name|tmp
operator||=
name|E1000_CTRL_EXT_EIAME
expr_stmt|;
name|tmp
operator||=
name|E1000_CTRL_EXT_IRCA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Queues */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|rx_num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rx_que
operator|=
operator|&
name|adapter
operator|->
name|rx_queues
index|[
name|i
index|]
expr_stmt|;
name|tmp
operator|=
name|E1000_EICR_RX_QUEUE0
operator|<<
name|i
expr_stmt|;
name|tmp
operator||=
name|E1000_EICR_TX_QUEUE0
operator|<<
name|i
expr_stmt|;
name|rx_que
operator|->
name|eims
operator|=
name|tmp
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MSIXBM
argument_list|(
literal|0
argument_list|)
argument_list|,
name|i
argument_list|,
name|rx_que
operator|->
name|eims
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|que_mask
operator||=
name|rx_que
operator|->
name|eims
expr_stmt|;
block|}
comment|/* Link */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MSIXBM
argument_list|(
name|adapter
operator|->
name|linkvec
argument_list|)
argument_list|,
name|E1000_EIMS_OTHER
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_mask
operator||=
name|E1000_EIMS_OTHER
expr_stmt|;
default|default:
break|break;
block|}
comment|/* Set the starting interrupt rate */
if|if
condition|(
name|em_max_interrupt_rate
operator|>
literal|0
condition|)
name|newitr
operator|=
operator|(
literal|4000000
operator|/
name|em_max_interrupt_rate
operator|)
operator|&
literal|0x7FFC
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
name|newitr
operator||=
name|newitr
operator|<<
literal|16
expr_stmt|;
else|else
name|newitr
operator||=
name|E1000_EITR_CNT_IGNR
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|rx_num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rx_que
operator|=
operator|&
name|adapter
operator|->
name|rx_queues
index|[
name|i
index|]
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EITR
argument_list|(
name|rx_que
operator|->
name|msix
argument_list|)
argument_list|,
name|newitr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|em_free_pci_resources
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|rx_queues
decl_stmt|;
name|device_t
name|dev
init|=
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
comment|/* Release all msix queue resources */
if|if
condition|(
name|adapter
operator|->
name|intr_type
operator|==
name|IFLIB_INTR_MSIX
condition|)
name|iflib_irq_free
argument_list|(
name|ctx
argument_list|,
operator|&
name|adapter
operator|->
name|irq
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|rx_num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|iflib_irq_free
argument_list|(
name|ctx
argument_list|,
operator|&
name|que
operator|->
name|que_irq
argument_list|)
expr_stmt|;
block|}
comment|/* First release all the interrupt resources */
if|if
condition|(
name|adapter
operator|->
name|memory
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|adapter
operator|->
name|memory
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|memory
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|flash
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|EM_FLASH
argument_list|,
name|adapter
operator|->
name|flash
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|flash
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|ioport
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|adapter
operator|->
name|io_rid
argument_list|,
name|adapter
operator|->
name|ioport
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Setup MSI or MSI/X */
end_comment

begin_function
specifier|static
name|int
name|em_setup_msix
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
block|{
name|em_enable_vectors_82574
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize the hardware to a configuration  *  as specified by the adapter structure.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|lem_smartspeed
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u16
name|phy_tmp
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|link_active
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|type
operator|!=
name|e1000_phy_igp
operator|)
operator|||
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|==
literal|0
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_FULL
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|adapter
operator|->
name|smartspeed
operator|==
literal|0
condition|)
block|{
comment|/* If Master/Slave config fault is asserted twice, 		 * we assume back-to-back */
name|e1000_read_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|phy_tmp
operator|&
name|SR_1000T_MS_CONFIG_FAULT
operator|)
condition|)
return|return;
name|e1000_read_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_tmp
operator|&
name|SR_1000T_MS_CONFIG_FAULT
condition|)
block|{
name|e1000_read_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|phy_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_tmp
operator|&
name|CR_1000T_MS_ENABLE
condition|)
block|{
name|phy_tmp
operator|&=
operator|~
name|CR_1000T_MS_ENABLE
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|phy_tmp
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|smartspeed
operator|++
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|&&
operator|!
name|e1000_copper_link_autoneg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
operator|&&
operator|!
name|e1000_read_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_tmp
argument_list|)
condition|)
block|{
name|phy_tmp
operator||=
operator|(
name|MII_CR_AUTO_NEG_EN
operator||
name|MII_CR_RESTART_AUTO_NEG
operator|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|smartspeed
operator|==
name|EM_SMARTSPEED_DOWNSHIFT
condition|)
block|{
comment|/* If still no link, perhaps using 2/3 pair cable */
name|e1000_read_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|phy_tmp
argument_list|)
expr_stmt|;
name|phy_tmp
operator||=
name|CR_1000T_MS_ENABLE
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|phy_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|&&
operator|!
name|e1000_copper_link_autoneg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
operator|&&
operator|!
name|e1000_read_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_tmp
argument_list|)
condition|)
block|{
name|phy_tmp
operator||=
operator|(
name|MII_CR_AUTO_NEG_EN
operator||
name|MII_CR_RESTART_AUTO_NEG
operator|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_tmp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restart process after EM_SMARTSPEED_MAX iterations */
if|if
condition|(
name|adapter
operator|->
name|smartspeed
operator|++
operator|==
name|EM_SMARTSPEED_MAX
condition|)
name|adapter
operator|->
name|smartspeed
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize the DMA Coalescing feature  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_init_dmac
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|pba
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|dmac
decl_stmt|,
name|reg
init|=
operator|~
name|E1000_DMACR_DMAC_EN
decl_stmt|;
name|u16
name|hwm
decl_stmt|;
name|u16
name|max_frame_size
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i211
condition|)
return|return;
name|max_frame_size
operator|=
name|adapter
operator|->
name|shared
operator|->
name|isc_max_frame_size
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>
name|e1000_82580
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|dmac
operator|==
literal|0
condition|)
block|{
comment|/* Disabling it */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMACR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DMA Coalescing enabled\n"
argument_list|)
expr_stmt|;
comment|/* Set starting threshold */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMCTXTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hwm
operator|=
literal|64
operator|*
name|pba
operator|-
name|max_frame_size
operator|/
literal|16
expr_stmt|;
if|if
condition|(
name|hwm
operator|<
literal|64
operator|*
operator|(
name|pba
operator|-
literal|6
operator|)
condition|)
name|hwm
operator|=
literal|64
operator|*
operator|(
name|pba
operator|-
literal|6
operator|)
expr_stmt|;
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCRTC
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|E1000_FCRTC_RTH_COAL_MASK
expr_stmt|;
name|reg
operator||=
operator|(
operator|(
name|hwm
operator|<<
name|E1000_FCRTC_RTH_COAL_SHIFT
operator|)
operator|&
name|E1000_FCRTC_RTH_COAL_MASK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCRTC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|dmac
operator|=
name|pba
operator|-
name|max_frame_size
operator|/
literal|512
expr_stmt|;
if|if
condition|(
name|dmac
operator|<
name|pba
operator|-
literal|10
condition|)
name|dmac
operator|=
name|pba
operator|-
literal|10
expr_stmt|;
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMACR
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|E1000_DMACR_DMACTHR_MASK
expr_stmt|;
name|reg
operator|=
operator|(
operator|(
name|dmac
operator|<<
name|E1000_DMACR_DMACTHR_SHIFT
operator|)
operator|&
name|E1000_DMACR_DMACTHR_MASK
operator|)
expr_stmt|;
comment|/* transition to L0x or L1 if available..*/
name|reg
operator||=
operator|(
name|E1000_DMACR_DMAC_EN
operator||
name|E1000_DMACR_DMAC_LX_MASK
operator|)
expr_stmt|;
comment|/* Check if status is 2.5Gb backplane connection 		* before configuration of watchdog timer, which is 		* in msec values in 12.8usec intervals 		* watchdog timer= msec values in 32usec intervals 		* for non 2.5Gb connection 		*/
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i354
condition|)
block|{
name|int
name|status
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|E1000_STATUS_2P5_SKU
operator|)
operator|&&
operator|(
operator|!
operator|(
name|status
operator|&
name|E1000_STATUS_2P5_SKU_OVER
operator|)
operator|)
condition|)
name|reg
operator||=
operator|(
operator|(
name|adapter
operator|->
name|dmac
operator|*
literal|5
operator|)
operator|>>
literal|6
operator|)
expr_stmt|;
else|else
name|reg
operator||=
operator|(
name|adapter
operator|->
name|dmac
operator|>>
literal|5
operator|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator||=
operator|(
name|adapter
operator|->
name|dmac
operator|>>
literal|5
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMACR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMCRTRH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the interval before transition */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMCTLX
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i350
condition|)
name|reg
operator||=
name|IGB_DMCTLX_DCFLUSH_DIS
expr_stmt|;
comment|/* 		** in 2.5Gb connection, TTLX unit is 0.4 usec 		** which is 0x4*2 = 0xA. But delay is still 4 usec 		*/
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i354
condition|)
block|{
name|int
name|status
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|E1000_STATUS_2P5_SKU
operator|)
operator|&&
operator|(
operator|!
operator|(
name|status
operator|&
name|E1000_STATUS_2P5_SKU_OVER
operator|)
operator|)
condition|)
name|reg
operator||=
literal|0xA
expr_stmt|;
else|else
name|reg
operator||=
literal|0x4
expr_stmt|;
block|}
else|else
block|{
name|reg
operator||=
literal|0x4
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMCTLX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* free space in tx packet buffer to wake from DMA coal */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMCTXTH
argument_list|,
operator|(
name|IGB_TXPBSIZE
operator|-
operator|(
literal|2
operator|*
name|max_frame_size
operator|)
operator|)
operator|>>
literal|6
argument_list|)
expr_stmt|;
comment|/* make low power state decision controlled by DMA coal */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCIEMISC
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|E1000_PCIEMISC_LX_DECISION
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCIEMISC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82580
condition|)
block|{
name|u32
name|reg
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCIEMISC
argument_list|)
decl_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCIEMISC
argument_list|,
name|reg
operator|&
operator|~
name|E1000_PCIEMISC_LX_DECISION
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMACR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|em_reset
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|iflib_get_ifp
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u16
name|rx_buffer_size
decl_stmt|;
name|u32
name|pba
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_reset: begin"
argument_list|)
expr_stmt|;
comment|/* Let the firmware know the OS is in control */
name|em_get_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Set up smart power down as default off on newer adapters. */
if|if
condition|(
operator|!
name|em_smart_pwr_down
operator|&&
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82571
operator|||
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82572
operator|)
condition|)
block|{
name|u16
name|phy_tmp
init|=
literal|0
decl_stmt|;
comment|/* Speed up time to link by disabling smart power down. */
name|e1000_read_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
operator|&
name|phy_tmp
argument_list|)
expr_stmt|;
name|phy_tmp
operator|&=
operator|~
name|IGP02E1000_PM_SPD
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|phy_tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Packet Buffer Allocation (PBA) 	 * Writing PBA sets the receive portion of the buffer 	 * the remainder is used for the transmit buffer. 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
comment|/* Total Packet Buffer on these is 48K */
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
case|case
name|e1000_80003es2lan
case|:
name|pba
operator|=
name|E1000_PBA_32K
expr_stmt|;
comment|/* 32K for Rx, 16K for Tx */
break|break;
case|case
name|e1000_82573
case|:
comment|/* 82573: Total Packet Buffer is 32K */
name|pba
operator|=
name|E1000_PBA_12K
expr_stmt|;
comment|/* 12K for Rx, 20K for Tx */
break|break;
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|pba
operator|=
name|E1000_PBA_20K
expr_stmt|;
comment|/* 20K for Rx, 20K for Tx */
break|break;
case|case
name|e1000_ich8lan
case|:
name|pba
operator|=
name|E1000_PBA_8K
expr_stmt|;
break|break;
case|case
name|e1000_ich9lan
case|:
case|case
name|e1000_ich10lan
case|:
comment|/* Boost Receive side for jumbo frames */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
operator|>
literal|4096
condition|)
name|pba
operator|=
name|E1000_PBA_14K
expr_stmt|;
else|else
name|pba
operator|=
name|E1000_PBA_10K
expr_stmt|;
break|break;
case|case
name|e1000_pchlan
case|:
case|case
name|e1000_pch2lan
case|:
case|case
name|e1000_pch_lpt
case|:
case|case
name|e1000_pch_spt
case|:
name|pba
operator|=
name|E1000_PBA_26K
expr_stmt|;
break|break;
case|case
name|e1000_82575
case|:
name|pba
operator|=
name|E1000_PBA_32K
expr_stmt|;
break|break;
case|case
name|e1000_82576
case|:
case|case
name|e1000_vfadapt
case|:
name|pba
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXPBS
argument_list|)
expr_stmt|;
name|pba
operator|&=
name|E1000_RXPBS_SIZE_MASK_82576
expr_stmt|;
break|break;
case|case
name|e1000_82580
case|:
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
case|case
name|e1000_vfadapt_i350
case|:
name|pba
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXPBS
argument_list|)
expr_stmt|;
name|pba
operator|=
name|e1000_rxpbs_adjust_82580
argument_list|(
name|pba
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_i210
case|:
case|case
name|e1000_i211
case|:
name|pba
operator|=
name|E1000_PBA_34K
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
operator|>
literal|8192
condition|)
name|pba
operator|=
name|E1000_PBA_40K
expr_stmt|;
comment|/* 40K for Rx, 24K for Tx */
else|else
name|pba
operator|=
name|E1000_PBA_48K
expr_stmt|;
comment|/* 48K for Rx, 16K for Tx */
block|}
comment|/* Special needs in case of Jumbo frames */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82575
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
operator|)
condition|)
block|{
name|u32
name|tx_space
decl_stmt|,
name|min_tx
decl_stmt|,
name|min_rx
decl_stmt|;
name|pba
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA
argument_list|)
expr_stmt|;
name|tx_space
operator|=
name|pba
operator|>>
literal|16
expr_stmt|;
name|pba
operator|&=
literal|0xffff
expr_stmt|;
name|min_tx
operator|=
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
operator|-
name|ETHERNET_FCS_SIZE
operator|)
operator|*
literal|2
expr_stmt|;
name|min_tx
operator|=
name|roundup2
argument_list|(
name|min_tx
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|min_tx
operator|>>=
literal|10
expr_stmt|;
name|min_rx
operator|=
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
expr_stmt|;
name|min_rx
operator|=
name|roundup2
argument_list|(
name|min_rx
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|min_rx
operator|>>=
literal|10
expr_stmt|;
if|if
condition|(
name|tx_space
operator|<
name|min_tx
operator|&&
operator|(
operator|(
name|min_tx
operator|-
name|tx_space
operator|)
operator|<
name|pba
operator|)
condition|)
block|{
name|pba
operator|=
name|pba
operator|-
operator|(
name|min_tx
operator|-
name|tx_space
operator|)
expr_stmt|;
comment|/* 			 * if short on rx space, rx wins 			 * and must trump tx adjustment 			 */
if|if
condition|(
name|pba
operator|<
name|min_rx
condition|)
name|pba
operator|=
name|min_rx
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA
argument_list|,
name|pba
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|igb_mac_min
condition|)
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PBA
argument_list|,
name|pba
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT1
argument_list|(
literal|"em_reset: pba=%dK"
argument_list|,
name|pba
argument_list|)
expr_stmt|;
comment|/* 	 * These parameters control the automatic generation (Tx) and 	 * response (Rx) to Ethernet PAUSE frames. 	 * - High water mark should allow for at least two frames to be 	 *   received after sending an XOFF. 	 * - Low water mark works best when it is very near the high water mark. 	 *   This allows the receiver to restart by sending XON when it has 	 *   drained a bit. Here we use an arbitrary value of 1500 which will 	 *   restart after one full frame is pulled from the buffer. There 	 *   could be several smaller frames in the buffer and if so they will 	 *   not trigger the XON until their total number reduces the buffer 	 *   by 1500. 	 * - The pause time is fairly large at 1000 x 512ns = 512 usec. 	 */
name|rx_buffer_size
operator|=
operator|(
name|pba
operator|&
literal|0xffff
operator|)
operator|<<
literal|10
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|=
name|rx_buffer_size
operator|-
name|roundup2
argument_list|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|max_frame_size
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|low_water
operator|=
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|-
literal|1500
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|fc
condition|)
comment|/* locally set flow control value? */
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|adapter
operator|->
name|fc
expr_stmt|;
else|else
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|e1000_fc_full
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_80003es2lan
condition|)
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|=
literal|0xFFFF
expr_stmt|;
else|else
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|=
name|EM_FC_PAUSE_TIME
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|send_xon
operator|=
name|TRUE
expr_stmt|;
comment|/* Device specific overrides/settings */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_pchlan
case|:
comment|/* Workaround: no TX flow ctrl for PCH */
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|e1000_fc_rx_pause
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|=
literal|0xFFFF
expr_stmt|;
comment|/* override */
if|if
condition|(
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
operator|>
name|ETHERMTU
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|=
literal|0x3500
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|low_water
operator|=
literal|0x1500
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|=
literal|0x5000
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|low_water
operator|=
literal|0x3000
expr_stmt|;
block|}
name|hw
operator|->
name|fc
operator|.
name|refresh_time
operator|=
literal|0x1000
expr_stmt|;
break|break;
case|case
name|e1000_pch2lan
case|:
case|case
name|e1000_pch_lpt
case|:
case|case
name|e1000_pch_spt
case|:
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|=
literal|0x5C20
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|low_water
operator|=
literal|0x5048
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|=
literal|0x0650
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|refresh_time
operator|=
literal|0x0400
expr_stmt|;
comment|/* Jumbos need adjusted PBA */
if|if
condition|(
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
operator|>
name|ETHERMTU
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA
argument_list|,
literal|12
argument_list|)
expr_stmt|;
else|else
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA
argument_list|,
literal|26
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_82575
case|:
case|case
name|e1000_82576
case|:
comment|/* 8-byte granularity */
name|hw
operator|->
name|fc
operator|.
name|low_water
operator|=
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|-
literal|8
expr_stmt|;
break|break;
case|case
name|e1000_82580
case|:
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
case|case
name|e1000_i210
case|:
case|case
name|e1000_i211
case|:
case|case
name|e1000_vfadapt
case|:
case|case
name|e1000_vfadapt_i350
case|:
comment|/* 16-byte granularity */
name|hw
operator|->
name|fc
operator|.
name|low_water
operator|=
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|-
literal|16
expr_stmt|;
break|break;
case|case
name|e1000_ich9lan
case|:
case|case
name|e1000_ich10lan
case|:
if|if
condition|(
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
operator|>
name|ETHERMTU
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|=
literal|0x2800
expr_stmt|;
name|hw
operator|->
name|fc
operator|.
name|low_water
operator|=
name|hw
operator|->
name|fc
operator|.
name|high_water
operator|-
literal|8
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_80003es2lan
condition|)
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|=
literal|0xFFFF
expr_stmt|;
break|break;
block|}
comment|/* Issue a global reset */
name|e1000_reset_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_WUFC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|em_disable_aspm
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|flags
operator|&
name|IGB_MEDIA_RESET
condition|)
block|{
name|e1000_setup_init_funcs
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|e1000_get_bus_info
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|flags
operator|&=
operator|~
name|IGB_MEDIA_RESET
expr_stmt|;
block|}
comment|/* and a re-init */
if|if
condition|(
name|e1000_init_hw
argument_list|(
name|hw
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hardware Initialization Failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
condition|)
name|igb_init_dmac
argument_list|(
name|adapter
argument_list|,
name|pba
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_VET
argument_list|,
name|ETHERTYPE_VLAN
argument_list|)
expr_stmt|;
name|e1000_get_phy_info
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|RSSKEYLEN
value|10
end_define

begin_function
specifier|static
name|void
name|em_initialize_rss_mapping
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|uint8_t
name|rss_key
index|[
literal|4
operator|*
name|RSSKEYLEN
index|]
decl_stmt|;
name|uint32_t
name|reta
init|=
literal|0
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Configure RSS key 	 */
name|arc4rand
argument_list|(
name|rss_key
argument_list|,
sizeof|sizeof
argument_list|(
name|rss_key
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSSKEYLEN
condition|;
operator|++
name|i
control|)
block|{
name|uint32_t
name|rssrk
init|=
literal|0
decl_stmt|;
name|rssrk
operator|=
name|EM_RSSRK_VAL
argument_list|(
name|rss_key
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RSSRK
argument_list|(
name|i
argument_list|)
argument_list|,
name|rssrk
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Configure RSS redirect table in following fashion: 	 * (hash& ring_cnt_mask) == rdr_table[(hash& rdr_table_mask)] 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|reta
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|uint32_t
name|q
decl_stmt|;
name|q
operator|=
operator|(
name|i
operator|%
name|adapter
operator|->
name|rx_num_queues
operator|)
operator|<<
literal|7
expr_stmt|;
name|reta
operator||=
name|q
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RETA
argument_list|(
name|i
argument_list|)
argument_list|,
name|reta
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MRQC
argument_list|,
name|E1000_MRQC_RSS_ENABLE_2Q
operator||
name|E1000_MRQC_RSS_FIELD_IPV4_TCP
operator||
name|E1000_MRQC_RSS_FIELD_IPV4
operator||
name|E1000_MRQC_RSS_FIELD_IPV6_TCP_EX
operator||
name|E1000_MRQC_RSS_FIELD_IPV6_EX
operator||
name|E1000_MRQC_RSS_FIELD_IPV6
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_initialize_rss_mapping
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|queue_id
decl_stmt|;
name|u32
name|reta
decl_stmt|;
name|u32
name|rss_key
index|[
literal|10
index|]
decl_stmt|,
name|mrqc
decl_stmt|,
name|shift
init|=
literal|0
decl_stmt|;
comment|/* XXX? */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
name|shift
operator|=
literal|6
expr_stmt|;
comment|/* 	 * The redirection table controls which destination 	 * queue each bucket redirects traffic to. 	 * Each DWORD represents four queues, with the LSB 	 * being the first queue in the DWORD. 	 * 	 * This just allocates buckets to queues using round-robin 	 * allocation. 	 * 	 * NOTE: It Just Happens to line up with the default 	 * RSS allocation method. 	 */
comment|/* Warning FM follows */
name|reta
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|RSS
name|queue_id
operator|=
name|rss_get_indirection_to_bucket
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * If we have more queues than buckets, we'll 		 * end up mapping buckets to a subset of the 		 * queues. 		 * 		 * If we have more buckets than queues, we'll 		 * end up instead assigning multiple buckets 		 * to queues. 		 * 		 * Both are suboptimal, but we need to handle 		 * the case so we don't go out of bounds 		 * indexing arrays and such. 		 */
name|queue_id
operator|=
name|queue_id
operator|%
name|adapter
operator|->
name|rx_num_queues
expr_stmt|;
else|#
directive|else
name|queue_id
operator|=
operator|(
name|i
operator|%
name|adapter
operator|->
name|rx_num_queues
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* Adjust if required */
name|queue_id
operator|=
name|queue_id
operator|<<
name|shift
expr_stmt|;
comment|/* 		 * The low 8 bits are for hash value (n+0); 		 * The next 8 bits are for hash value (n+1), etc. 		 */
name|reta
operator|=
name|reta
operator|>>
literal|8
expr_stmt|;
name|reta
operator|=
name|reta
operator||
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|queue_id
operator|)
operator|<<
literal|24
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RETA
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
argument_list|,
name|reta
argument_list|)
expr_stmt|;
name|reta
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Now fill in hash table */
comment|/* 	 * MRQC: Multiple Receive Queues Command 	 * Set queuing to RSS control, number depends on the device. 	 */
name|mrqc
operator|=
name|E1000_MRQC_ENABLE_RSS_8Q
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* XXX ew typecasting */
name|rss_getkey
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|rss_key
argument_list|)
expr_stmt|;
else|#
directive|else
name|arc4rand
argument_list|(
operator|&
name|rss_key
argument_list|,
sizeof|sizeof
argument_list|(
name|rss_key
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_RSSRK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|i
argument_list|,
name|rss_key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Configure the RSS fields to hash upon. 	 */
name|mrqc
operator||=
operator|(
name|E1000_MRQC_RSS_FIELD_IPV4
operator||
name|E1000_MRQC_RSS_FIELD_IPV4_TCP
operator|)
expr_stmt|;
name|mrqc
operator||=
operator|(
name|E1000_MRQC_RSS_FIELD_IPV6
operator||
name|E1000_MRQC_RSS_FIELD_IPV6_TCP
operator|)
expr_stmt|;
name|mrqc
operator||=
operator|(
name|E1000_MRQC_RSS_FIELD_IPV4_UDP
operator||
name|E1000_MRQC_RSS_FIELD_IPV6_UDP
operator|)
expr_stmt|;
name|mrqc
operator||=
operator|(
name|E1000_MRQC_RSS_FIELD_IPV6_UDP_EX
operator||
name|E1000_MRQC_RSS_FIELD_IPV6_TCP_EX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MRQC
argument_list|,
name|mrqc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup networking device structure and register an interface.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_setup_interface
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|iflib_get_ifp
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|adapter
operator|->
name|shared
decl_stmt|;
name|uint64_t
name|cap
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_setup_interface: begin"
argument_list|)
expr_stmt|;
comment|/* TSO parameters */
name|if_sethwtsomax
argument_list|(
name|ifp
argument_list|,
name|IP_MAXPACKET
argument_list|)
expr_stmt|;
comment|/* Take m_pullup(9)'s in em_xmit() w/ TSO into acount. */
name|if_sethwtsomaxsegcount
argument_list|(
name|ifp
argument_list|,
name|EM_MAX_SCATTER
operator|-
literal|5
argument_list|)
expr_stmt|;
name|if_sethwtsomaxsegsize
argument_list|(
name|ifp
argument_list|,
name|EM_TSO_SEG_SIZE
argument_list|)
expr_stmt|;
comment|/* Single Queue */
if|if
condition|(
name|adapter
operator|->
name|tx_num_queues
operator|==
literal|1
condition|)
block|{
name|if_setsendqlen
argument_list|(
name|ifp
argument_list|,
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
name|if_setsendqready
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|cap
operator|=
name|IFCAP_HWCSUM
operator||
name|IFCAP_VLAN_HWCSUM
operator||
name|IFCAP_TSO4
expr_stmt|;
name|cap
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_MTU
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we 	 * support full VLAN capability 	 */
name|if_setifheaderlen
argument_list|(
name|ifp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
argument_list|)
expr_stmt|;
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
name|cap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Don't turn this on by default, if vlans are 	 * created on another pseudo device (eg. lagg) 	 * then vlan events are not passed thru, breaking 	 * operation, but with HW FILTER off it works. If 	 * using vlans directly on the em driver you can 	 * enable this and get full hardware tag filtering. 	 */
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_VLAN_HWFILTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable only WOL MAGIC by default */
if|if
condition|(
name|adapter
operator|->
name|wol
condition|)
block|{
name|if_setcapenablebit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_WOL_MAGIC
argument_list|,
name|IFCAP_WOL_MCAST
operator||
name|IFCAP_WOL_UCAST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_setcapenablebit
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
name|IFCAP_WOL_MAGIC
operator||
name|IFCAP_WOL_MCAST
operator||
name|IFCAP_WOL_UCAST
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_fiber
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
operator|)
condition|)
block|{
name|u_char
name|fiber_type
init|=
name|IFM_1000_SX
decl_stmt|;
comment|/* default type */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82545
condition|)
name|fiber_type
operator|=
name|IFM_1000_LX
expr_stmt|;
name|ifmedia_add
argument_list|(
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|fiber_type
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|fiber_type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifmedia_add
argument_list|(
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|type
operator|!=
name|e1000_phy_ife
condition|)
block|{
name|ifmedia_add
argument_list|(
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|ifmedia_add
argument_list|(
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_if_tx_queues_alloc
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|caddr_t
modifier|*
name|vaddrs
parameter_list|,
name|uint64_t
modifier|*
name|paddrs
parameter_list|,
name|int
name|ntxqs
parameter_list|,
name|int
name|ntxqsets
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|adapter
operator|->
name|shared
decl_stmt|;
name|int
name|error
init|=
name|E1000_SUCCESS
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|que
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|MPASS
argument_list|(
name|adapter
operator|->
name|tx_num_queues
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|adapter
operator|->
name|tx_num_queues
operator|==
name|ntxqsets
argument_list|)
expr_stmt|;
comment|/* First allocate the top level queue structs */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|tx_queues
operator|=
operator|(
expr|struct
name|em_tx_queue
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|em_tx_queue
argument_list|)
operator|*
name|adapter
operator|->
name|tx_num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
argument_list|,
literal|"Unable to allocate queue memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|que
operator|=
name|adapter
operator|->
name|tx_queues
init|;
name|i
operator|<
name|adapter
operator|->
name|tx_num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
comment|/* Set up some basics */
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|txr
operator|->
name|adapter
operator|=
name|que
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|que
operator|->
name|me
operator|=
name|txr
operator|->
name|me
operator|=
name|i
expr_stmt|;
comment|/* Allocate report status array */
if|if
condition|(
operator|!
operator|(
name|txr
operator|->
name|tx_rsq
operator|=
operator|(
name|qidx_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|qidx_t
argument_list|)
operator|*
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
argument_list|,
literal|"failed to allocate rs_idxs memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
name|txr
operator|->
name|tx_rsq
index|[
name|j
index|]
operator|=
name|QIDX_INVALID
expr_stmt|;
comment|/* get the virtual and physical address of the hardware queues */
name|txr
operator|->
name|tx_base
operator|=
operator|(
expr|struct
name|e1000_tx_desc
operator|*
operator|)
name|vaddrs
index|[
name|i
operator|*
name|ntxqs
index|]
expr_stmt|;
name|txr
operator|->
name|tx_paddr
operator|=
name|paddrs
index|[
name|i
operator|*
name|ntxqs
index|]
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
argument_list|,
literal|"allocated for %d tx_queues\n"
argument_list|,
name|adapter
operator|->
name|tx_num_queues
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|em_if_queues_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_if_rx_queues_alloc
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|caddr_t
modifier|*
name|vaddrs
parameter_list|,
name|uint64_t
modifier|*
name|paddrs
parameter_list|,
name|int
name|nrxqs
parameter_list|,
name|int
name|nrxqsets
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|int
name|error
init|=
name|E1000_SUCCESS
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MPASS
argument_list|(
name|adapter
operator|->
name|rx_num_queues
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|adapter
operator|->
name|rx_num_queues
operator|==
name|nrxqsets
argument_list|)
expr_stmt|;
comment|/* First allocate the top level queue structs */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|rx_queues
operator|=
operator|(
expr|struct
name|em_rx_queue
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|em_rx_queue
argument_list|)
operator|*
name|adapter
operator|->
name|rx_num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
argument_list|,
literal|"Unable to allocate queue memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|que
operator|=
name|adapter
operator|->
name|rx_queues
init|;
name|i
operator|<
name|nrxqsets
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
comment|/* Set up some basics */
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|rxr
operator|->
name|adapter
operator|=
name|que
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|rxr
operator|->
name|que
operator|=
name|que
expr_stmt|;
name|que
operator|->
name|me
operator|=
name|rxr
operator|->
name|me
operator|=
name|i
expr_stmt|;
comment|/* get the virtual and physical address of the hardware queues */
name|rxr
operator|->
name|rx_base
operator|=
operator|(
expr|union
name|e1000_rx_desc_extended
operator|*
operator|)
name|vaddrs
index|[
name|i
operator|*
name|nrxqs
index|]
expr_stmt|;
name|rxr
operator|->
name|rx_paddr
operator|=
name|paddrs
index|[
name|i
operator|*
name|nrxqs
index|]
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
argument_list|,
literal|"allocated for %d rx_queues\n"
argument_list|,
name|adapter
operator|->
name|rx_num_queues
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|em_if_queues_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_if_queues_free
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|tx_que
init|=
name|adapter
operator|->
name|tx_queues
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|rx_que
init|=
name|adapter
operator|->
name|rx_queues
decl_stmt|;
if|if
condition|(
name|tx_que
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|tx_num_queues
condition|;
name|i
operator|++
operator|,
name|tx_que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|tx_que
operator|->
name|txr
decl_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_rsq
operator|==
name|NULL
condition|)
break|break;
name|free
argument_list|(
name|txr
operator|->
name|tx_rsq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tx_rsq
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|adapter
operator|->
name|tx_queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tx_queues
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rx_que
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|adapter
operator|->
name|rx_queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|rx_queues
operator|=
name|NULL
expr_stmt|;
block|}
name|em_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|mta
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|adapter
operator|->
name|mta
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Enable transmit unit.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_initialize_transmit_unit
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|adapter
operator|->
name|shared
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|tctl
decl_stmt|,
name|txdctl
init|=
literal|0
decl_stmt|,
name|tarc
decl_stmt|,
name|tipg
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_initialize_transmit_unit: begin"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|tx_num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|u64
name|bus_addr
decl_stmt|;
name|caddr_t
name|offp
decl_stmt|,
name|endp
decl_stmt|;
name|que
operator|=
operator|&
name|adapter
operator|->
name|tx_queues
index|[
name|i
index|]
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
name|bus_addr
operator|=
name|txr
operator|->
name|tx_paddr
expr_stmt|;
comment|/* Clear checksum offload context. */
name|offp
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|txr
operator|->
name|csum_flags
expr_stmt|;
name|endp
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|txr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|offp
argument_list|,
name|endp
operator|-
name|offp
argument_list|)
expr_stmt|;
comment|/* Base and Len of TX Ring */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDLEN
argument_list|(
name|i
argument_list|)
argument_list|,
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDBAH
argument_list|(
name|i
argument_list|)
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|bus_addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDBAL
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|u32
operator|)
name|bus_addr
argument_list|)
expr_stmt|;
comment|/* Init the HEAD/TAIL indices */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HW_DEBUGOUT2
argument_list|(
literal|"Base = %x, Length = %x\n"
argument_list|,
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDBAL
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDLEN
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|txdctl
operator|=
literal|0
expr_stmt|;
comment|/* clear txdctl */
name|txdctl
operator||=
literal|0x1f
expr_stmt|;
comment|/* PTHRESH */
name|txdctl
operator||=
literal|1
operator|<<
literal|8
expr_stmt|;
comment|/* HTHRESH */
name|txdctl
operator||=
literal|1
operator|<<
literal|16
expr_stmt|;
comment|/* WTHRESH */
name|txdctl
operator||=
literal|1
operator|<<
literal|22
expr_stmt|;
comment|/* Reserved bit 22 must always be 1 */
name|txdctl
operator||=
name|E1000_TXDCTL_GRAN
expr_stmt|;
name|txdctl
operator||=
literal|1
operator|<<
literal|25
expr_stmt|;
comment|/* LWTHRESH */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|txdctl
argument_list|)
expr_stmt|;
block|}
comment|/* Set the default values for the Tx Inter Packet Gap timer */
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_80003es2lan
case|:
name|tipg
operator|=
name|DEFAULT_82543_TIPG_IPGR1
expr_stmt|;
name|tipg
operator||=
name|DEFAULT_80003ES2LAN_TIPG_IPGR2
operator|<<
name|E1000_TIPG_IPGR2_SHIFT
expr_stmt|;
break|break;
case|case
name|e1000_82542
case|:
name|tipg
operator|=
name|DEFAULT_82542_TIPG_IPGT
expr_stmt|;
name|tipg
operator||=
name|DEFAULT_82542_TIPG_IPGR1
operator|<<
name|E1000_TIPG_IPGR1_SHIFT
expr_stmt|;
name|tipg
operator||=
name|DEFAULT_82542_TIPG_IPGR2
operator|<<
name|E1000_TIPG_IPGR2_SHIFT
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_fiber
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
operator|)
condition|)
name|tipg
operator|=
name|DEFAULT_82543_TIPG_IPGT_FIBER
expr_stmt|;
else|else
name|tipg
operator|=
name|DEFAULT_82543_TIPG_IPGT_COPPER
expr_stmt|;
name|tipg
operator||=
name|DEFAULT_82543_TIPG_IPGR1
operator|<<
name|E1000_TIPG_IPGR1_SHIFT
expr_stmt|;
name|tipg
operator||=
name|DEFAULT_82543_TIPG_IPGR2
operator|<<
name|E1000_TIPG_IPGR2_SHIFT
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TIPG
argument_list|,
name|tipg
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TIDV
argument_list|,
name|adapter
operator|->
name|tx_int_delay
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82540
condition|)
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TADV
argument_list|,
name|adapter
operator|->
name|tx_abs_int_delay
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82571
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82572
operator|)
condition|)
block|{
name|tarc
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tarc
operator||=
name|TARC_SPEED_MODE_BIT
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|tarc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_80003es2lan
condition|)
block|{
comment|/* errata: program both queues to unweighted RR */
name|tarc
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tarc
operator||=
literal|1
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|tarc
argument_list|)
expr_stmt|;
name|tarc
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tarc
operator||=
literal|1
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|1
argument_list|)
argument_list|,
name|tarc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
block|{
name|tarc
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tarc
operator||=
name|TARC_ERRATA_BIT
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|tx_num_queues
operator|>
literal|1
condition|)
block|{
name|tarc
operator||=
operator|(
name|TARC_COMPENSATION_MODE
operator||
name|TARC_MQ_FIX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|tarc
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|1
argument_list|)
argument_list|,
name|tarc
argument_list|)
expr_stmt|;
block|}
else|else
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|tarc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|tx_int_delay
operator|.
name|value
operator|>
literal|0
condition|)
name|adapter
operator|->
name|txd_cmd
operator||=
name|E1000_TXD_CMD_IDE
expr_stmt|;
comment|/* Program the Transmit Control Register */
name|tctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TCTL
argument_list|)
expr_stmt|;
name|tctl
operator|&=
operator|~
name|E1000_TCTL_CT
expr_stmt|;
name|tctl
operator||=
operator|(
name|E1000_TCTL_PSP
operator||
name|E1000_TCTL_RTLC
operator||
name|E1000_TCTL_EN
operator||
operator|(
name|E1000_COLLISION_THRESHOLD
operator|<<
name|E1000_CT_SHIFT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82571
condition|)
name|tctl
operator||=
name|E1000_TCTL_MULR
expr_stmt|;
comment|/* This write will effectively turn on the transmit unit. */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|tctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch_spt
condition|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IOSFPC
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_RCTL_RDMTS_HEX
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IOSFPC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_TARC0_CB_MULTIQ_3_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Enable receive unit.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_initialize_receive_unit
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|adapter
operator|->
name|shared
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|iflib_get_ifp
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u32
name|rctl
decl_stmt|,
name|rxcsum
decl_stmt|,
name|rfctl
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_initialize_receive_units: begin"
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure receives are disabled while setting 	 * up the descriptor ring 	 */
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
comment|/* Do not disable if ever enabled on this hardware */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82574
operator|)
operator|&&
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82583
operator|)
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|rctl
operator|&
operator|~
name|E1000_RCTL_EN
argument_list|)
expr_stmt|;
comment|/* Setup the Receive Control Register */
name|rctl
operator|&=
operator|~
operator|(
literal|3
operator|<<
name|E1000_RCTL_MO_SHIFT
operator|)
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_EN
operator||
name|E1000_RCTL_BAM
operator||
name|E1000_RCTL_LBM_NO
operator||
name|E1000_RCTL_RDMTS_HALF
operator||
operator|(
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
operator|<<
name|E1000_RCTL_MO_SHIFT
operator|)
expr_stmt|;
comment|/* Do not store bad packets */
name|rctl
operator|&=
operator|~
name|E1000_RCTL_SBP
expr_stmt|;
comment|/* Enable Long Packet receive */
if|if
condition|(
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
operator|>
name|ETHERMTU
condition|)
name|rctl
operator||=
name|E1000_RCTL_LPE
expr_stmt|;
else|else
name|rctl
operator|&=
operator|~
name|E1000_RCTL_LPE
expr_stmt|;
comment|/* Strip the CRC */
if|if
condition|(
operator|!
name|em_disable_crc_stripping
condition|)
name|rctl
operator||=
name|E1000_RCTL_SECRC
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82540
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RADV
argument_list|,
name|adapter
operator|->
name|rx_abs_int_delay
operator|.
name|value
argument_list|)
expr_stmt|;
comment|/* 		 * Set the interrupt throttling rate. Value is calculated 		 * as DEFAULT_ITR = 1/(MAX_INTS_PER_SEC * 256ns) 		 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ITR
argument_list|,
name|DEFAULT_ITR
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RDTR
argument_list|,
name|adapter
operator|->
name|rx_int_delay
operator|.
name|value
argument_list|)
expr_stmt|;
comment|/* Use extended rx descriptor formats */
name|rfctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RFCTL
argument_list|)
expr_stmt|;
name|rfctl
operator||=
name|E1000_RFCTL_EXTEN
expr_stmt|;
comment|/* 	 * When using MSIX interrupts we need to throttle 	 * using the EITR register (82574 only) 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EITR_82574
argument_list|(
name|i
argument_list|)
argument_list|,
name|DEFAULT_ITR
argument_list|)
expr_stmt|;
comment|/* Disable accelerated acknowledge */
name|rfctl
operator||=
name|E1000_RFCTL_ACK_DIS
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RFCTL
argument_list|,
name|rfctl
argument_list|)
expr_stmt|;
name|rxcsum
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCSUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_RXCSUM
operator|&&
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82543
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|tx_num_queues
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
condition|)
block|{
name|rxcsum
operator||=
name|E1000_RXCSUM_PCSD
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82575
condition|)
name|rxcsum
operator||=
name|E1000_RXCSUM_CRCOFL
expr_stmt|;
block|}
else|else
name|rxcsum
operator||=
name|E1000_RXCSUM_TUOFL
operator||
name|E1000_RXCSUM_IPOFL
operator||
name|E1000_RXCSUM_PCSD
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
condition|)
name|rxcsum
operator||=
name|E1000_RXCSUM_IPPCSE
expr_stmt|;
else|else
name|rxcsum
operator||=
name|E1000_RXCSUM_TUOFL
operator||
name|E1000_RXCSUM_IPOFL
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>
name|e1000_82575
condition|)
name|rxcsum
operator||=
name|E1000_RXCSUM_CRCOFL
expr_stmt|;
block|}
block|}
else|else
name|rxcsum
operator|&=
operator|~
name|E1000_RXCSUM_TUOFL
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCSUM
argument_list|,
name|rxcsum
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|rx_num_queues
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
condition|)
name|igb_initialize_rss_mapping
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
name|em_initialize_rss_mapping
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX TEMPORARY WORKAROUND: on some systems with 82573 	 * long latencies are observed, like Lenovo X60. This 	 * change eliminates the problem, but since having positive 	 * values in RDTR is a known source of problems on other 	 * platforms another solution is being sought. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82573
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDTR
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|que
operator|=
name|adapter
operator|->
name|rx_queues
init|;
name|i
operator|<
name|adapter
operator|->
name|rx_num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
comment|/* Setup the Base and Length of the Rx Descriptor Ring */
name|u64
name|bus_addr
init|=
name|rxr
operator|->
name|rx_paddr
decl_stmt|;
if|#
directive|if
literal|0
block|u32 rdt = adapter->rx_num_queues -1;
comment|/* default */
endif|#
directive|endif
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDLEN
argument_list|(
name|i
argument_list|)
argument_list|,
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|e1000_rx_desc_extended
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDBAH
argument_list|(
name|i
argument_list|)
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|bus_addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDBAL
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|u32
operator|)
name|bus_addr
argument_list|)
expr_stmt|;
comment|/* Setup the Head and Tail Descriptor Pointers */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDT
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set PTHRESH for improved jumbo performance 	 * According to 10.2.5.11 of Intel 82574 Datasheet, 	 * RXDCTL(1) is written whenever RXDCTL(0) is written. 	 * Only write to RXDCTL(1) if there is a need for different 	 * settings. 	 */
if|if
condition|(
operator|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_ich9lan
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_ich10lan
operator|)
operator|)
operator|&&
operator|(
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
operator|>
name|ETHERMTU
operator|)
condition|)
block|{
name|u32
name|rxdctl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rxdctl
operator||
literal|3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|rx_num_queues
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|rxdctl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|rxdctl
operator||=
literal|0x20
expr_stmt|;
comment|/* PTHRESH */
name|rxdctl
operator||=
literal|4
operator|<<
literal|8
expr_stmt|;
comment|/* HTHRESH */
name|rxdctl
operator||=
literal|4
operator|<<
literal|16
expr_stmt|;
comment|/* WTHRESH */
name|rxdctl
operator||=
literal|1
operator|<<
literal|24
expr_stmt|;
comment|/* Switch to granularity */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxdctl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
condition|)
block|{
name|u32
name|psize
decl_stmt|,
name|srrctl
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
operator|>
name|ETHERMTU
condition|)
block|{
comment|/* Set maximum packet len */
if|if
condition|(
name|adapter
operator|->
name|rx_mbuf_sz
operator|<=
literal|4096
condition|)
block|{
name|srrctl
operator||=
literal|4096
operator|>>
name|E1000_SRRCTL_BSIZEPKT_SHIFT
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_SZ_4096
operator||
name|E1000_RCTL_BSEX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|rx_mbuf_sz
operator|>
literal|4096
condition|)
block|{
name|srrctl
operator||=
literal|8192
operator|>>
name|E1000_SRRCTL_BSIZEPKT_SHIFT
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_SZ_8192
operator||
name|E1000_RCTL_BSEX
expr_stmt|;
block|}
name|psize
operator|=
name|scctx
operator|->
name|isc_max_frame_size
expr_stmt|;
comment|/* are we on a vlan? */
if|if
condition|(
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
name|psize
operator|+=
name|VLAN_TAG_SIZE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RLPML
argument_list|,
name|psize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|srrctl
operator||=
literal|2048
operator|>>
name|E1000_SRRCTL_BSIZEPKT_SHIFT
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_SZ_2048
expr_stmt|;
block|}
comment|/* 		 * If TX flow control is disabled and there's>1 queue defined, 		 * enable DROP. 		 * 		 * This drops frames rather than hanging the RX MAC for all queues. 		 */
if|if
condition|(
operator|(
name|adapter
operator|->
name|rx_num_queues
operator|>
literal|1
operator|)
operator|&&
operator|(
name|adapter
operator|->
name|fc
operator|==
name|e1000_fc_none
operator|||
name|adapter
operator|->
name|fc
operator|==
name|e1000_fc_rx_pause
operator|)
condition|)
block|{
name|srrctl
operator||=
name|E1000_SRRCTL_DROP_EN
expr_stmt|;
block|}
comment|/* Setup the Base and Length of the Rx Descriptor Rings */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|que
operator|=
name|adapter
operator|->
name|rx_queues
init|;
name|i
operator|<
name|adapter
operator|->
name|rx_num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|u64
name|bus_addr
init|=
name|rxr
operator|->
name|rx_paddr
decl_stmt|;
name|u32
name|rxdctl
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* Configure for header split? -- ignore for now */
name|rxr
operator|->
name|hdr_split
operator|=
name|igb_header_split
expr_stmt|;
else|#
directive|else
name|srrctl
operator||=
name|E1000_SRRCTL_DESCTYPE_ADV_ONEBUF
expr_stmt|;
endif|#
directive|endif
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDLEN
argument_list|(
name|i
argument_list|)
argument_list|,
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_rx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDBAH
argument_list|(
name|i
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|bus_addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDBAL
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|bus_addr
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SRRCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|srrctl
argument_list|)
expr_stmt|;
comment|/* Enable this Queue */
name|rxdctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|rxdctl
operator||=
name|E1000_RXDCTL_QUEUE_ENABLE
expr_stmt|;
name|rxdctl
operator|&=
literal|0xFFF00000
expr_stmt|;
name|rxdctl
operator||=
name|IGB_RX_PTHRESH
expr_stmt|;
name|rxdctl
operator||=
name|IGB_RX_HTHRESH
operator|<<
literal|8
expr_stmt|;
name|rxdctl
operator||=
name|IGB_RX_WTHRESH
operator|<<
literal|16
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxdctl
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_pch2lan
condition|)
block|{
if|if
condition|(
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
operator|>
name|ETHERMTU
condition|)
name|e1000_lv_jumbo_workaround_ich8lan
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|e1000_lv_jumbo_workaround_ich8lan
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure VLAN Filters are off */
name|rctl
operator|&=
operator|~
name|E1000_RCTL_VFE
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|<
name|igb_mac_min
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|rx_mbuf_sz
operator|==
name|MCLBYTES
condition|)
name|rctl
operator||=
name|E1000_RCTL_SZ_2048
expr_stmt|;
elseif|else
if|if
condition|(
name|adapter
operator|->
name|rx_mbuf_sz
operator|==
name|MJUMPAGESIZE
condition|)
name|rctl
operator||=
name|E1000_RCTL_SZ_4096
operator||
name|E1000_RCTL_BSEX
expr_stmt|;
elseif|else
if|if
condition|(
name|adapter
operator|->
name|rx_mbuf_sz
operator|>
name|MJUMPAGESIZE
condition|)
name|rctl
operator||=
name|E1000_RCTL_SZ_8192
operator||
name|E1000_RCTL_BSEX
expr_stmt|;
comment|/* ensure we clear use DTYPE of 00 here */
name|rctl
operator|&=
operator|~
literal|0x00000C00
expr_stmt|;
block|}
comment|/* Write out the settings */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|em_if_vlan_register
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|u32
name|index
decl_stmt|,
name|bit
decl_stmt|;
name|index
operator|=
operator|(
name|vtag
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bit
operator|=
name|vtag
operator|&
literal|0x1F
expr_stmt|;
name|adapter
operator|->
name|shadow_vfta
index|[
name|index
index|]
operator||=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
operator|++
name|adapter
operator|->
name|num_vlans
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_if_vlan_unregister
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|u32
name|index
decl_stmt|,
name|bit
decl_stmt|;
name|index
operator|=
operator|(
name|vtag
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bit
operator|=
name|vtag
operator|&
literal|0x1F
expr_stmt|;
name|adapter
operator|->
name|shadow_vfta
index|[
name|index
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
operator|--
name|adapter
operator|->
name|num_vlans
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_setup_vlan_hw_support
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|;
comment|/* 	 * We get here thru init_locked, meaning 	 * a soft reset, this has already cleared 	 * the VFTA and other state, so if there 	 * have been no vlan's registered do nothing. 	 */
if|if
condition|(
name|adapter
operator|->
name|num_vlans
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * A soft reset zero's out the VFTA, so 	 * we need to repopulate it now. 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|EM_VFTA_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|adapter
operator|->
name|shadow_vfta
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VFTA
argument_list|,
name|i
argument_list|,
name|adapter
operator|->
name|shadow_vfta
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_CTRL_VME
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Enable the Filter Table */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|E1000_RCTL_CFIEN
expr_stmt|;
name|reg
operator||=
name|E1000_RCTL_VFE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_if_enable_intr
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|ims_mask
init|=
name|IMS_ENABLE_MASK
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|EM_EIAC
argument_list|,
name|EM_MSIX_MASK
argument_list|)
expr_stmt|;
name|ims_mask
operator||=
name|adapter
operator|->
name|ims
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|intr_type
operator|==
name|IFLIB_INTR_MSIX
operator|&&
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
condition|)
block|{
name|u32
name|mask
init|=
operator|(
name|adapter
operator|->
name|que_mask
operator||
name|adapter
operator|->
name|link_mask
operator|)
decl_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIAC
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIAM
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIMS
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|ims_mask
operator|=
name|E1000_IMS_LSC
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|ims_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_if_disable_intr
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|intr_type
operator|==
name|IFLIB_INTR_MSIX
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|igb_mac_min
condition|)
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIMC
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Bit of a misnomer, what this really means is  * to enable OS management of the system... aka  * to disable special hardware management features  */
end_comment

begin_function
specifier|static
name|void
name|em_init_manageability
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
comment|/* A shared code workaround */
define|#
directive|define
name|E1000_82542_MANC2H
value|E1000_MANC2H
if|if
condition|(
name|adapter
operator|->
name|has_manage
condition|)
block|{
name|int
name|manc2h
init|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC2H
argument_list|)
decl_stmt|;
name|int
name|manc
init|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC
argument_list|)
decl_stmt|;
comment|/* disable hardware interception of ARP */
name|manc
operator|&=
operator|~
operator|(
name|E1000_MANC_ARP_EN
operator|)
expr_stmt|;
comment|/* enable receiving management packets to the host */
name|manc
operator||=
name|E1000_MANC_EN_MNG2HOST
expr_stmt|;
define|#
directive|define
name|E1000_MNG2HOST_PORT_623
value|(1<< 5)
define|#
directive|define
name|E1000_MNG2HOST_PORT_664
value|(1<< 6)
name|manc2h
operator||=
name|E1000_MNG2HOST_PORT_623
expr_stmt|;
name|manc2h
operator||=
name|E1000_MNG2HOST_PORT_664
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC2H
argument_list|,
name|manc2h
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC
argument_list|,
name|manc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Give control back to hardware management  * controller if there is one.  */
end_comment

begin_function
specifier|static
name|void
name|em_release_manageability
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|adapter
operator|->
name|has_manage
condition|)
block|{
name|int
name|manc
init|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC
argument_list|)
decl_stmt|;
comment|/* re-enable hardware interception of ARP */
name|manc
operator||=
name|E1000_MANC_ARP_EN
expr_stmt|;
name|manc
operator|&=
operator|~
name|E1000_MANC_EN_MNG2HOST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC
argument_list|,
name|manc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * em_get_hw_control sets the {CTRL_EXT|FWSM}:DRV_LOAD bit.  * For ASF and Pass Through versions of f/w this means  * that the driver is loaded. For AMT version type f/w  * this means that the network i/f is open.  */
end_comment

begin_function
specifier|static
name|void
name|em_get_hw_control
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|ctrl_ext
decl_stmt|,
name|swsm
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|vf_ifp
condition|)
return|return;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82573
condition|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_SWSM
argument_list|,
name|swsm
operator||
name|E1000_SWSM_DRV_LOAD
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* else */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
operator||
name|E1000_CTRL_EXT_DRV_LOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * em_release_hw_control resets {CTRL_EXT|FWSM}:DRV_LOAD bit.  * For ASF and Pass Through versions of f/w this means that  * the driver is no longer loaded. For AMT versions of the  * f/w this means that the network i/f is closed.  */
end_comment

begin_function
specifier|static
name|void
name|em_release_hw_control
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|ctrl_ext
decl_stmt|,
name|swsm
decl_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|has_manage
condition|)
return|return;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82573
condition|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_SWSM
argument_list|,
name|swsm
operator|&
operator|~
name|E1000_SWSM_DRV_LOAD
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* else */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
operator|&
operator|~
name|E1000_CTRL_EXT_DRV_LOAD
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|em_is_valid_ether_addr
parameter_list|(
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|char
name|zero_addr
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|addr
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|||
operator|(
operator|!
name|bcmp
argument_list|(
name|addr
argument_list|,
name|zero_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Parse the interface capabilities with regard ** to both system management and wake-on-lan for ** later use. */
end_comment

begin_function
specifier|static
name|void
name|em_get_wakeup
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|device_t
name|dev
init|=
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|u16
name|eeprom_data
init|=
literal|0
decl_stmt|,
name|device_id
decl_stmt|,
name|apme_mask
decl_stmt|;
name|adapter
operator|->
name|has_manage
operator|=
name|e1000_enable_mng_pass_thru
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|apme_mask
operator|=
name|EM_EEPROM_APME
expr_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82542
case|:
case|case
name|e1000_82543
case|:
break|break;
case|case
name|e1000_82544
case|:
name|e1000_read_nvm
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|NVM_INIT_CONTROL2_REG
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
name|apme_mask
operator|=
name|EM_82544_APME
expr_stmt|;
break|break;
case|case
name|e1000_82546
case|:
case|case
name|e1000_82546_rev_3
case|:
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|func
operator|==
literal|1
condition|)
block|{
name|e1000_read_nvm
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|NVM_INIT_CONTROL3_PORT_B
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|e1000_read_nvm
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|NVM_INIT_CONTROL3_PORT_A
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_82573
case|:
case|case
name|e1000_82583
case|:
name|adapter
operator|->
name|has_amt
operator|=
name|TRUE
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
case|case
name|e1000_80003es2lan
case|:
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|func
operator|==
literal|1
condition|)
block|{
name|e1000_read_nvm
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|NVM_INIT_CONTROL3_PORT_B
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|e1000_read_nvm
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|NVM_INIT_CONTROL3_PORT_A
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_ich8lan
case|:
case|case
name|e1000_ich9lan
case|:
case|case
name|e1000_ich10lan
case|:
case|case
name|e1000_pchlan
case|:
case|case
name|e1000_pch2lan
case|:
case|case
name|e1000_pch_lpt
case|:
case|case
name|e1000_pch_spt
case|:
case|case
name|e1000_82575
case|:
comment|/* listing all igb devices */
case|case
name|e1000_82576
case|:
case|case
name|e1000_82580
case|:
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
case|case
name|e1000_i210
case|:
case|case
name|e1000_i211
case|:
case|case
name|e1000_vfadapt
case|:
case|case
name|e1000_vfadapt_i350
case|:
name|apme_mask
operator|=
name|E1000_WUC_APME
expr_stmt|;
name|adapter
operator|->
name|has_amt
operator|=
name|TRUE
expr_stmt|;
name|eeprom_data
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUC
argument_list|)
expr_stmt|;
break|break;
default|default:
name|e1000_read_nvm
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|NVM_INIT_CONTROL3_PORT_A
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|eeprom_data
operator|&
name|apme_mask
condition|)
name|adapter
operator|->
name|wol
operator|=
operator|(
name|E1000_WUFC_MAG
operator||
name|E1000_WUFC_MC
operator|)
expr_stmt|;
comment|/* 	 * We have the eeprom settings, now apply the special cases 	 * where the eeprom may be wrong or the board won't support 	 * wake on lan on a particular port 	 */
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_82546GB_PCIE
case|:
name|adapter
operator|->
name|wol
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82546EB_FIBER
case|:
case|case
name|E1000_DEV_ID_82546GB_FIBER
case|:
comment|/* Wake events only supported on port A for dual fiber 		 * regardless of eeprom setting */
if|if
condition|(
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_FUNC_1
condition|)
name|adapter
operator|->
name|wol
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3
case|:
comment|/* if quad port adapter, disable WoL on all but port A */
if|if
condition|(
name|global_quad_port_a
operator|!=
literal|0
condition|)
name|adapter
operator|->
name|wol
operator|=
literal|0
expr_stmt|;
comment|/* Reset for multiple quad port adapters */
if|if
condition|(
operator|++
name|global_quad_port_a
operator|==
literal|4
condition|)
name|global_quad_port_a
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82571EB_FIBER
case|:
comment|/* Wake events only supported on port A for dual fiber 		 * regardless of eeprom setting */
if|if
condition|(
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_FUNC_1
condition|)
name|adapter
operator|->
name|wol
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82571EB_QUAD_COPPER
case|:
case|case
name|E1000_DEV_ID_82571EB_QUAD_FIBER
case|:
case|case
name|E1000_DEV_ID_82571EB_QUAD_COPPER_LP
case|:
comment|/* if quad port adapter, disable WoL on all but port A */
if|if
condition|(
name|global_quad_port_a
operator|!=
literal|0
condition|)
name|adapter
operator|->
name|wol
operator|=
literal|0
expr_stmt|;
comment|/* Reset for multiple quad port adapters */
if|if
condition|(
operator|++
name|global_quad_port_a
operator|==
literal|4
condition|)
name|global_quad_port_a
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Enable PCI Wake On Lan capability  */
end_comment

begin_function
specifier|static
name|void
name|em_enable_wakeup
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|device_t
name|dev
init|=
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|if_t
name|ifp
init|=
name|iflib_get_ifp
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|u32
name|pmc
decl_stmt|,
name|ctrl
decl_stmt|,
name|ctrl_ext
decl_stmt|,
name|rctl
decl_stmt|,
name|wuc
decl_stmt|;
name|u16
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_PMG
argument_list|,
operator|&
name|pmc
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return;
comment|/* Advertise the wakeup capability */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_SWDPIN2
operator||
name|E1000_CTRL_SWDPIN3
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|wuc
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUC
argument_list|)
expr_stmt|;
name|wuc
operator||=
operator|(
name|E1000_WUC_PME_EN
operator||
name|E1000_WUC_APME
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
name|wuc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_pchlan
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_ich9lan
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_ich10lan
operator|)
condition|)
name|e1000_suspend_workarounds_ich8lan
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Keep the laser running on Fiber adapters */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_fiber
operator|||
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
condition|)
block|{
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_SDP3_DATA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Determine type of Wakeup: note that wol 	 * is set with all bits on by default. 	 */
if|if
condition|(
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_WOL_MAGIC
operator|)
operator|==
literal|0
condition|)
name|adapter
operator|->
name|wol
operator|&=
operator|~
name|E1000_WUFC_MAG
expr_stmt|;
if|if
condition|(
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_WOL_UCAST
operator|)
operator|==
literal|0
condition|)
name|adapter
operator|->
name|wol
operator|&=
operator|~
name|E1000_WUFC_EX
expr_stmt|;
if|if
condition|(
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_WOL_MCAST
operator|)
operator|==
literal|0
condition|)
name|adapter
operator|->
name|wol
operator|&=
operator|~
name|E1000_WUFC_MC
expr_stmt|;
else|else
block|{
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_MPE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_pchlan
condition|)
block|{
if|if
condition|(
name|em_enable_phy_wakeup
argument_list|(
name|adapter
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
name|E1000_WUC_PME_EN
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUFC
argument_list|,
name|adapter
operator|->
name|wol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|type
operator|==
name|e1000_phy_igp_3
condition|)
name|e1000_igp3_phy_powerdown_workaround_ich8lan
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Request PME */
name|status
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|pmc
operator|+
name|PCIR_POWER_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|status
operator|&=
operator|~
operator|(
name|PCIM_PSTAT_PME
operator||
name|PCIM_PSTAT_PMEENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_WOL
condition|)
name|status
operator||=
name|PCIM_PSTAT_PME
operator||
name|PCIM_PSTAT_PMEENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|pmc
operator|+
name|PCIR_POWER_STATUS
argument_list|,
name|status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * WOL in the newer chipset interfaces (pchlan)  * require thing to be copied into the phy  */
end_comment

begin_function
specifier|static
name|int
name|em_enable_phy_wakeup
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|mreg
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|u16
name|preg
decl_stmt|;
comment|/* copy MAC RARs to PHY RARs */
name|e1000_copy_rx_addrs_to_phy_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* copy MAC MTA to PHY MTA */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|mta_reg_count
condition|;
name|i
operator|++
control|)
block|{
name|mreg
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|BM_MTA
argument_list|(
name|i
argument_list|)
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|mreg
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
name|hw
argument_list|,
name|BM_MTA
argument_list|(
name|i
argument_list|)
operator|+
literal|1
argument_list|,
call|(
name|u16
call|)
argument_list|(
operator|(
name|mreg
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* configure PHY Rx Control register */
name|e1000_read_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|BM_RCTL
argument_list|,
operator|&
name|preg
argument_list|)
expr_stmt|;
name|mreg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mreg
operator|&
name|E1000_RCTL_UPE
condition|)
name|preg
operator||=
name|BM_RCTL_UPE
expr_stmt|;
if|if
condition|(
name|mreg
operator|&
name|E1000_RCTL_MPE
condition|)
name|preg
operator||=
name|BM_RCTL_MPE
expr_stmt|;
name|preg
operator|&=
operator|~
operator|(
name|BM_RCTL_MO_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|mreg
operator|&
name|E1000_RCTL_MO_3
condition|)
name|preg
operator||=
operator|(
operator|(
operator|(
name|mreg
operator|&
name|E1000_RCTL_MO_3
operator|)
operator|>>
name|E1000_RCTL_MO_SHIFT
operator|)
operator|<<
name|BM_RCTL_MO_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|mreg
operator|&
name|E1000_RCTL_BAM
condition|)
name|preg
operator||=
name|BM_RCTL_BAM
expr_stmt|;
if|if
condition|(
name|mreg
operator|&
name|E1000_RCTL_PMCF
condition|)
name|preg
operator||=
name|BM_RCTL_PMCF
expr_stmt|;
name|mreg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mreg
operator|&
name|E1000_CTRL_RFCE
condition|)
name|preg
operator||=
name|BM_RCTL_RFCE
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|BM_RCTL
argument_list|,
name|preg
argument_list|)
expr_stmt|;
comment|/* enable PHY wakeup in MAC register */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
name|E1000_WUC_PHY_WAKE
operator||
name|E1000_WUC_PME_EN
operator||
name|E1000_WUC_APME
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_WUFC
argument_list|,
name|adapter
operator|->
name|wol
argument_list|)
expr_stmt|;
comment|/* configure and enable PHY wakeup in PHY registers */
name|e1000_write_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|BM_WUFC
argument_list|,
name|adapter
operator|->
name|wol
argument_list|)
expr_stmt|;
name|e1000_write_phy_reg
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|BM_WUC
argument_list|,
name|E1000_WUC_PME_EN
argument_list|)
expr_stmt|;
comment|/* activate PHY wakeup */
name|ret
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"Could not acquire PHY\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|BM_WUC_ENABLE_PAGE
operator|<<
name|IGP_PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_ENABLE_REG
argument_list|,
operator|&
name|preg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"Could not read PHY page 769\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|preg
operator||=
name|BM_WUC_ENABLE_BIT
operator||
name|BM_WUC_HOST_WU_BIT
expr_stmt|;
name|ret
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_ENABLE_REG
argument_list|,
name|preg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|printf
argument_list|(
literal|"Could not set PHY Host Wakeup bit\n"
argument_list|)
expr_stmt|;
name|out
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_if_led_func
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
name|e1000_setup_led
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|e1000_led_on
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e1000_led_off
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|e1000_cleanup_led
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Disable the L0S and L1 LINK states  */
end_comment

begin_function
specifier|static
name|void
name|em_disable_aspm
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|base
decl_stmt|,
name|reg
decl_stmt|;
name|u16
name|link_cap
decl_stmt|,
name|link_ctrl
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
break|break;
default|default:
return|return;
block|}
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|base
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|reg
operator|=
name|base
operator|+
name|PCIER_LINK_CAP
expr_stmt|;
name|link_cap
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|link_cap
operator|&
name|PCIEM_LINK_CAP_ASPM
operator|)
operator|==
literal|0
condition|)
return|return;
name|reg
operator|=
name|base
operator|+
name|PCIER_LINK_CTL
expr_stmt|;
name|link_ctrl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|link_ctrl
operator|&=
operator|~
name|PCIEM_LINK_CTL_ASPMC
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
argument_list|,
name|link_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Update the board statistics counters.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|em_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
operator|||
operator|(
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_LU
operator|)
condition|)
block|{
name|adapter
operator|->
name|stats
operator|.
name|symerrs
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_SYMERRS
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|sec
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_SEC
argument_list|)
expr_stmt|;
block|}
name|adapter
operator|->
name|stats
operator|.
name|crcerrs
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CRCERRS
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mpc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MPC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|scc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_SCC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ecol
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ECOL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mcc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MCC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|latecol
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_LATECOL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|colc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_COLC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|dc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_DC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rlec
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RLEC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|xonrxc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_XONRXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|xontxc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_XONTXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|xoffrxc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_XOFFRXC
argument_list|)
expr_stmt|;
comment|/* 	 ** For watchdog management we need to know if we have been 	 ** paused during the last interval, so capture that here. 	*/
name|adapter
operator|->
name|shared
operator|->
name|isc_pause_frames
operator|=
name|adapter
operator|->
name|stats
operator|.
name|xoffrxc
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|xofftxc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_XOFFTXC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|fcruc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_FCRUC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc64
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PRC64
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc127
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PRC127
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc255
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PRC255
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc511
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PRC511
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc1023
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PRC1023
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|prc1522
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PRC1522
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gprc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_GPRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|bprc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_BPRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mprc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MPRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gptc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_GPTC
argument_list|)
expr_stmt|;
comment|/* For the 64-bit byte counters the low dword must be read first. */
comment|/* Both registers clear on the read of the high dword */
name|adapter
operator|->
name|stats
operator|.
name|gorc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_GORCL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_GORCH
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|gotc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_GOTCL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_GOTCH
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rnbc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RNBC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ruc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RUC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rfc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RFC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|roc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ROC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rjc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RJC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tor
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TORH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tot
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TOTH
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tpr
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TPR
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tpt
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TPT
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc64
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PTC64
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc127
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PTC127
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc255
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PTC255
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc511
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PTC511
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc1023
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PTC1023
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ptc1522
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PTC1522
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|mptc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MPTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|bptc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_BPTC
argument_list|)
expr_stmt|;
comment|/* Interrupt Counts */
name|adapter
operator|->
name|stats
operator|.
name|iac
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IAC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|icrxptc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICRXPTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|icrxatc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICRXATC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ictxptc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICTXPTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ictxatc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICTXATC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ictxqec
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICTXQEC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|ictxqmtc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICTXQMTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|icrxdmtc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICRXDMTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|icrxoc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICRXOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82543
condition|)
block|{
name|adapter
operator|->
name|stats
operator|.
name|algnerrc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ALGNERRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|rxerrc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RXERRC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tncrs
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TNCRS
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|cexterr
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CEXTERR
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tsctc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TSCTC
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|stats
operator|.
name|tsctfc
operator|+=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TSCTFC
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|em_if_get_counter
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|iflib_get_ifp
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
name|IFCOUNTER_COLLISIONS
case|:
return|return
operator|(
name|adapter
operator|->
name|stats
operator|.
name|colc
operator|)
return|;
case|case
name|IFCOUNTER_IERRORS
case|:
return|return
operator|(
name|adapter
operator|->
name|dropped_pkts
operator|+
name|adapter
operator|->
name|stats
operator|.
name|rxerrc
operator|+
name|adapter
operator|->
name|stats
operator|.
name|crcerrs
operator|+
name|adapter
operator|->
name|stats
operator|.
name|algnerrc
operator|+
name|adapter
operator|->
name|stats
operator|.
name|ruc
operator|+
name|adapter
operator|->
name|stats
operator|.
name|roc
operator|+
name|adapter
operator|->
name|stats
operator|.
name|mpc
operator|+
name|adapter
operator|->
name|stats
operator|.
name|cexterr
operator|)
return|;
case|case
name|IFCOUNTER_OERRORS
case|:
return|return
operator|(
name|adapter
operator|->
name|stats
operator|.
name|ecol
operator|+
name|adapter
operator|->
name|stats
operator|.
name|latecol
operator|+
name|adapter
operator|->
name|watchdog_events
operator|)
return|;
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Export a single 32-bit register via a read-only sysctl. */
end_comment

begin_function
specifier|static
name|int
name|em_sysctl_reg_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|u_int
name|val
decl_stmt|;
name|adapter
operator|=
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|val
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|oidp
operator|->
name|oid_arg2
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add sysctl variables, one per statistic, to the system.  */
end_comment

begin_function
specifier|static
name|void
name|em_add_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|iflib_get_dev
argument_list|(
name|adapter
operator|->
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|tx_que
init|=
name|adapter
operator|->
name|tx_queues
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|rx_que
init|=
name|adapter
operator|->
name|rx_queues
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
decl_stmt|;
name|struct
name|e1000_hw_stats
modifier|*
name|stats
init|=
operator|&
name|adapter
operator|->
name|stats
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|stat_node
decl_stmt|,
modifier|*
name|queue_node
decl_stmt|,
modifier|*
name|int_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|stat_list
decl_stmt|,
modifier|*
name|queue_list
decl_stmt|,
modifier|*
name|int_list
decl_stmt|;
define|#
directive|define
name|QUEUE_NAME_LEN
value|32
name|char
name|namebuf
index|[
name|QUEUE_NAME_LEN
index|]
decl_stmt|;
comment|/* Driver Statistics */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|dropped_pkts
argument_list|,
literal|"Driver dropped packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"link_irq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|link_irq
argument_list|,
literal|"Link MSIX IRQ Handled"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_defrag_fail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|mbuf_defrag_failed
argument_list|,
literal|"Defragmenting mbuf chain failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_dma_fail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|no_tx_dma_setup
argument_list|,
literal|"Driver tx dma failure in xmit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_overruns"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|rx_overruns
argument_list|,
literal|"RX overruns"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"watchdog_timeouts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|watchdog_events
argument_list|,
literal|"Watchdog timeouts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"device_control"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_CTRL
argument_list|,
name|em_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Device Control Register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_control"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_RCTL
argument_list|,
name|em_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Receiver Control Register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc_high_water"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|high_water
argument_list|,
literal|0
argument_list|,
literal|"Flow Control High Watermark"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc_low_water"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|low_water
argument_list|,
literal|0
argument_list|,
literal|"Flow Control Low Watermark"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|tx_num_queues
condition|;
name|i
operator|++
operator|,
name|tx_que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|tx_que
operator|->
name|txr
decl_stmt|;
name|snprintf
argument_list|(
name|namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"queue_tx_%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"TX Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txd_head"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_TDH
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|,
name|em_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Transmit Descriptor Head"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txd_tail"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_TDT
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|,
name|em_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Transmit Descriptor Tail"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_irq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|tx_irq
argument_list|,
literal|"Queue MSI-X Transmit Interrupts"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|adapter
operator|->
name|rx_num_queues
condition|;
name|j
operator|++
operator|,
name|rx_que
operator|++
control|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|rx_que
operator|->
name|rxr
decl_stmt|;
name|snprintf
argument_list|(
name|namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"queue_rx_%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"RX Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxd_head"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_RDH
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|em_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Receive Descriptor Head"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxd_tail"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|em_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Receive Descriptor Tail"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_irq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxr
operator|->
name|rx_irq
argument_list|,
literal|"Queue MSI-X Receive Interrupts"
argument_list|)
expr_stmt|;
block|}
comment|/* MAC stats get their own sub node */
name|stat_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mac_stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Statistics"
argument_list|)
expr_stmt|;
name|stat_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|stat_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"excess_coll"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ecol
argument_list|,
literal|"Excessive collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"single_coll"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|scc
argument_list|,
literal|"Single collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"multiple_coll"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mcc
argument_list|,
literal|"Multiple collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"late_coll"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|latecol
argument_list|,
literal|"Late collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"collision_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|colc
argument_list|,
literal|"Collision Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"symbol_errors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|symerrs
argument_list|,
literal|"Symbol Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sequence_errors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|sec
argument_list|,
literal|"Sequence Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"defer_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|dc
argument_list|,
literal|"Defer Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"missed_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|mpc
argument_list|,
literal|"Missed Packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_no_buff"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|rnbc
argument_list|,
literal|"Receive No Buffers"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_undersize"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ruc
argument_list|,
literal|"Receive Undersize"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_fragmented"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|rfc
argument_list|,
literal|"Fragmented Packets Received "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_oversize"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|roc
argument_list|,
literal|"Oversized Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_jabber"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|rjc
argument_list|,
literal|"Recevied Jabber"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|rxerrc
argument_list|,
literal|"Receive Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"crc_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|crcerrs
argument_list|,
literal|"CRC errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"alignment_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|algnerrc
argument_list|,
literal|"Alignment Errors"
argument_list|)
expr_stmt|;
comment|/* On 82575 these are collision counts */
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"coll_ext_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|cexterr
argument_list|,
literal|"Collision/Carrier extension errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xon_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|xonrxc
argument_list|,
literal|"XON Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xon_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|xontxc
argument_list|,
literal|"XON Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xoff_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|xoffrxc
argument_list|,
literal|"XOFF Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xoff_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|xofftxc
argument_list|,
literal|"XOFF Transmitted"
argument_list|)
expr_stmt|;
comment|/* Packet Reception Stats */
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|tpr
argument_list|,
literal|"Total Packets Received "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|gprc
argument_list|,
literal|"Good Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bcast_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|bprc
argument_list|,
literal|"Broadcast Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mcast_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|mprc
argument_list|,
literal|"Multicast Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_64"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|prc64
argument_list|,
literal|"64 byte frames received "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_65_127"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|prc127
argument_list|,
literal|"65-127 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_128_255"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|prc255
argument_list|,
literal|"128-255 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_256_511"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|prc511
argument_list|,
literal|"256-511 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_512_1023"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|prc1023
argument_list|,
literal|"512-1023 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_1024_1522"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|prc1522
argument_list|,
literal|"1023-1522 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_octets_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|gorc
argument_list|,
literal|"Good Octets Received"
argument_list|)
expr_stmt|;
comment|/* Packet Transmission Stats */
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_octets_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|gotc
argument_list|,
literal|"Good Octets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|tpt
argument_list|,
literal|"Total Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|gptc
argument_list|,
literal|"Good Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bcast_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|bptc
argument_list|,
literal|"Broadcast Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mcast_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|mptc
argument_list|,
literal|"Multicast Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_64"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ptc64
argument_list|,
literal|"64 byte frames transmitted "
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_65_127"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ptc127
argument_list|,
literal|"65-127 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_128_255"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ptc255
argument_list|,
literal|"128-255 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_256_511"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ptc511
argument_list|,
literal|"256-511 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_512_1023"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ptc1023
argument_list|,
literal|"512-1023 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_1024_1522"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ptc1522
argument_list|,
literal|"1024-1522 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|tsctc
argument_list|,
literal|"TSO Contexts Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_ctx_fail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|tsctfc
argument_list|,
literal|"TSO Contexts Failed"
argument_list|)
expr_stmt|;
comment|/* Interrupt Stats */
name|int_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"interrupts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Interrupt Statistics"
argument_list|)
expr_stmt|;
name|int_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|int_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"asserts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|iac
argument_list|,
literal|"Interrupt Assertion Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_pkt_timer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|icrxptc
argument_list|,
literal|"Interrupt Cause Rx Pkt Timer Expire Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_abs_timer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|icrxatc
argument_list|,
literal|"Interrupt Cause Rx Abs Timer Expire Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_pkt_timer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ictxptc
argument_list|,
literal|"Interrupt Cause Tx Pkt Timer Expire Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_abs_timer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ictxatc
argument_list|,
literal|"Interrupt Cause Tx Abs Timer Expire Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_queue_empty"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ictxqec
argument_list|,
literal|"Interrupt Cause Tx Queue Empty Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_queue_min_thresh"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|ictxqmtc
argument_list|,
literal|"Interrupt Cause Tx Queue Min Thresh Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_desc_min_thresh"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|icrxdmtc
argument_list|,
literal|"Interrupt Cause Rx Desc Min Thresh Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_overrun"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|stats
operator|.
name|icrxoc
argument_list|,
literal|"Interrupt Cause Receiver Overrun Count"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  This routine provides a way to dump out the adapter eeprom,  *  often a useful debug/service tool. This only dumps the first  *  32 words, stuff that matters is in that extent.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_sysctl_nvm_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * This value will cause a hex dump of the 	 * first 32 16-bit words of the EEPROM to 	 * the screen. 	 */
if|if
condition|(
name|result
operator|==
literal|1
condition|)
name|em_print_nvm_info
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_print_nvm_info
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u16
name|eeprom_data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|row
init|=
literal|0
decl_stmt|;
comment|/* Its a bit crude, but it gets the job done */
name|printf
argument_list|(
literal|"\nInterface EEPROM Dump:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Offset\n0x0000  "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
literal|8
condition|)
block|{
comment|/* Make the offset block */
name|j
operator|=
literal|0
expr_stmt|;
operator|++
name|row
expr_stmt|;
name|printf
argument_list|(
literal|"\n0x00%x0  "
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
name|e1000_read_nvm
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%04x "
argument_list|,
name|eeprom_data
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_sysctl_int_delay
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|em_int_delay_info
modifier|*
name|info
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|u32
name|regval
decl_stmt|;
name|int
name|error
decl_stmt|,
name|usecs
decl_stmt|,
name|ticks
decl_stmt|;
name|info
operator|=
operator|(
expr|struct
name|em_int_delay_info
operator|*
operator|)
name|arg1
expr_stmt|;
name|usecs
operator|=
name|info
operator|->
name|value
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|usecs
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|usecs
operator|<
literal|0
operator|||
name|usecs
operator|>
name|EM_TICKS_TO_USECS
argument_list|(
literal|65535
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|info
operator|->
name|value
operator|=
name|usecs
expr_stmt|;
name|ticks
operator|=
name|EM_USECS_TO_TICKS
argument_list|(
name|usecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|offset
operator|==
name|E1000_ITR
condition|)
comment|/* units are 256ns here */
name|ticks
operator|*=
literal|4
expr_stmt|;
name|adapter
operator|=
name|info
operator|->
name|adapter
expr_stmt|;
name|regval
operator|=
name|E1000_READ_OFFSET
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|info
operator|->
name|offset
argument_list|)
expr_stmt|;
name|regval
operator|=
operator|(
name|regval
operator|&
operator|~
literal|0xffff
operator|)
operator||
operator|(
name|ticks
operator|&
literal|0xffff
operator|)
expr_stmt|;
comment|/* Handle a few special cases. */
switch|switch
condition|(
name|info
operator|->
name|offset
condition|)
block|{
case|case
name|E1000_RDTR
case|:
break|break;
case|case
name|E1000_TIDV
case|:
if|if
condition|(
name|ticks
operator|==
literal|0
condition|)
block|{
name|adapter
operator|->
name|txd_cmd
operator|&=
operator|~
name|E1000_TXD_CMD_IDE
expr_stmt|;
comment|/* Don't write 0 into the TIDV register. */
name|regval
operator|++
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|txd_cmd
operator||=
name|E1000_TXD_CMD_IDE
expr_stmt|;
break|break;
block|}
name|E1000_WRITE_OFFSET
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|info
operator|->
name|offset
argument_list|,
name|regval
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_add_int_delay_sysctl
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|description
parameter_list|,
name|struct
name|em_int_delay_info
modifier|*
name|info
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|info
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|info
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|info
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|info
argument_list|,
literal|0
argument_list|,
name|em_sysctl_int_delay
argument_list|,
literal|"I"
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set flow control using sysctl:  * Flow control values:  *      0 - off  *      1 - rx pause  *      2 - tx pause  *      3 - full  */
end_comment

begin_function
specifier|static
name|int
name|em_set_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
specifier|static
name|int
name|input
init|=
literal|3
decl_stmt|;
comment|/* default is full */
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|input
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|input
operator|==
name|adapter
operator|->
name|fc
condition|)
comment|/* no change? */
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|input
condition|)
block|{
case|case
name|e1000_fc_rx_pause
case|:
case|case
name|e1000_fc_tx_pause
case|:
case|case
name|e1000_fc_full
case|:
case|case
name|e1000_fc_none
case|:
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|requested_mode
operator|=
name|input
expr_stmt|;
name|adapter
operator|->
name|fc
operator|=
name|input
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
return|return
operator|(
name|error
operator|)
return|;
block|}
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|current_mode
operator|=
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|requested_mode
expr_stmt|;
name|e1000_force_mac_fc
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Manage Energy Efficient Ethernet:  * Control values:  *     0/1 - enabled/disabled  */
end_comment

begin_function
specifier|static
name|int
name|em_sysctl_eee
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|value
decl_stmt|;
name|value
operator|=
name|adapter
operator|->
name|hw
operator|.
name|dev_spec
operator|.
name|ich8lan
operator|.
name|eee_disable
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|adapter
operator|->
name|hw
operator|.
name|dev_spec
operator|.
name|ich8lan
operator|.
name|eee_disable
operator|=
operator|(
name|value
operator|!=
literal|0
operator|)
expr_stmt|;
name|em_if_init
argument_list|(
name|adapter
operator|->
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_sysctl_debug_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|adapter
operator|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
expr_stmt|;
name|em_print_debug_info
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_get_rs
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
operator|||
name|result
operator|!=
literal|1
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|em_dump_rs
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_if_debug
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|em_dump_rs
argument_list|(
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is meant to be fluid, add whatever is  * needed for debugging a problem.  -jfv  */
end_comment

begin_function
specifier|static
name|void
name|em_print_debug_info
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|iflib_get_dev
argument_list|(
name|adapter
operator|->
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|iflib_get_ifp
argument_list|(
name|adapter
operator|->
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|adapter
operator|->
name|tx_queues
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|adapter
operator|->
name|rx_queues
operator|->
name|rxr
decl_stmt|;
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
name|printf
argument_list|(
literal|"Interface is RUNNING "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Interface is NOT RUNNING\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_OACTIVE
condition|)
name|printf
argument_list|(
literal|"and INACTIVE\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"and ACTIVE\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|tx_num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TX Queue %d ------\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"hw tdh = %d, hw tdt = %d\n"
argument_list|,
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDH
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|adapter
operator|->
name|rx_num_queues
condition|;
name|j
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RX Queue %d ------\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"hw rdh = %d, hw rdt = %d\n"
argument_list|,
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RDH
argument_list|(
name|j
argument_list|)
argument_list|)
argument_list|,
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RDT
argument_list|(
name|j
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * 82574 only:  * Write a new value to the EEPROM increasing the number of MSIX  * vectors from 3 to 5, for proper multiqueue support.  */
end_comment

begin_function
specifier|static
name|void
name|em_enable_vectors_82574
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|iflib_get_softc
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|u16
name|edata
decl_stmt|;
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
name|EM_NVM_PCIE_CTRL
argument_list|,
literal|1
argument_list|,
operator|&
name|edata
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Current cap: %#06x\n"
argument_list|,
name|edata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|edata
operator|&
name|EM_NVM_MSIX_N_MASK
operator|)
operator|>>
name|EM_NVM_MSIX_N_SHIFT
operator|)
operator|!=
literal|4
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Writing to eeprom: increasing "
literal|"reported MSIX vectors from 3 to 5...\n"
argument_list|)
expr_stmt|;
name|edata
operator|&=
operator|~
operator|(
name|EM_NVM_MSIX_N_MASK
operator|)
expr_stmt|;
name|edata
operator||=
literal|4
operator|<<
name|EM_NVM_MSIX_N_SHIFT
expr_stmt|;
name|e1000_write_nvm
argument_list|(
name|hw
argument_list|,
name|EM_NVM_PCIE_CTRL
argument_list|,
literal|1
argument_list|,
operator|&
name|edata
argument_list|)
expr_stmt|;
name|e1000_update_nvm_checksum
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Writing to eeprom: done\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

