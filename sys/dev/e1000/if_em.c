begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2010, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_altq.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
end_if

begin_include
include|#
directive|include
file|<sys/buf_ring.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700029
end_if

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|"e1000_api.h"
end_include

begin_include
include|#
directive|include
file|"e1000_82571.h"
end_include

begin_include
include|#
directive|include
file|"if_em.h"
end_include

begin_comment
comment|/*********************************************************************  *  Set this to one to display debug statistics  *********************************************************************/
end_comment

begin_decl_stmt
name|int
name|em_display_debug_stats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Driver version:  *********************************************************************/
end_comment

begin_decl_stmt
name|char
name|em_driver_version
index|[]
init|=
literal|"6.9.25"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  PCI Device ID Table  *  *  Used by probe to select devices to load on  *  Last field stores an index into e1000_strings  *  Last entry must be all 0s  *  *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|em_vendor_info_t
name|em_vendor_info_array
index|[]
init|=
block|{
comment|/* Intel(R) PRO/1000 Network Connection */
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82540EM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82540EM_LOM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82540EP
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82540EP_LOM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82540EP_LP
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82541EI
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82541ER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82541ER_LOM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82541EI_MOBILE
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82541GI
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82541GI_LF
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82541GI_MOBILE
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82542
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82543GC_FIBER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82543GC_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82544EI_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82544EI_FIBER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82544GC_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82544GC_LOM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82545EM_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82545EM_FIBER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82545GM_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82545GM_FIBER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82545GM_SERDES
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82546EB_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82546EB_FIBER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82546EB_QUAD_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82546GB_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82546GB_FIBER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82546GB_SERDES
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82546GB_PCIE
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82546GB_QUAD_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82547EI
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82547EI_MOBILE
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82547GI
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_FIBER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_SERDES
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_SERDES_DUAL
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_SERDES_QUAD
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_QUAD_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_QUAD_COPPER_LP
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571EB_QUAD_FIBER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82571PT_QUAD_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82572EI_COPPER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82572EI_FIBER
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82572EI_SERDES
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82572EI
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82573E
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82573E_IAMT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82573L
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82583V
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_80003ES2LAN_COPPER_SPT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_80003ES2LAN_SERDES_SPT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_80003ES2LAN_COPPER_DPT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_80003ES2LAN_SERDES_DPT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_IGP_M_AMT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_IGP_AMT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_IGP_C
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_IFE
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_IFE_GT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_IFE_G
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_IGP_M
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH8_82567V_3
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IGP_M_AMT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IGP_AMT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IGP_C
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IGP_M
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IGP_M_V
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IFE
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IFE_GT
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_IFE_G
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH9_BM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82574L
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_82574LA
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH10_R_BM_LM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH10_R_BM_LF
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH10_R_BM_V
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH10_D_BM_LM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_ICH10_D_BM_LF
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_M_HV_LM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_M_HV_LC
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_D_HV_DM
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
block|{
literal|0x8086
block|,
name|E1000_DEV_ID_PCH_D_HV_DC
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|0
block|}
block|,
comment|/* required last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Table of branding strings for all supported NICs.  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|em_strings
index|[]
init|=
block|{
literal|"Intel(R) PRO/1000 Network Connection"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|em_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
end_if

begin_function_decl
specifier|static
name|int
name|em_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_mq_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|em_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_stop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_allocate_legacy
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_allocate_msix
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_setup_msix
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_local_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_hardware_init
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_setup_interface
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_setup_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_initialize_transmit_unit
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_setup_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_initialize_receive_unit
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_free_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_free_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_txeof
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_tx_purge
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_allocate_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_allocate_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_rxeof
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
end_ifndef

begin_function_decl
specifier|static
name|int
name|em_fixup_rx
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|em_receive_checksum
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|e1000_rx_desc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_transmit_checksum_setup
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
end_if

begin_function_decl
specifier|static
name|bool
name|em_tso_setup
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FreeBSD_version>= 700000 */
end_comment

begin_function_decl
specifier|static
name|void
name|em_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_disable_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_print_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_update_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_get_buf
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700029
end_if

begin_function_decl
specifier|static
name|void
name|em_register_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_unregister_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_setup_vlan_hw_support
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|em_xmit
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_smartspeed
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_82547_fifo_workaround
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_82547_update_fifo_head
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_82547_tx_fifo_reset
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_82547_move_tail
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_dma_malloc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|struct
name|em_dma_alloc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_dma_free
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|em_dma_alloc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_print_debug_info
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_print_nvm_info
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_is_valid_ether_addr
parameter_list|(
name|u8
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_sysctl_stats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_sysctl_debug_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u32
name|em_fill_descriptors
parameter_list|(
name|bus_addr_t
name|address
parameter_list|,
name|u32
name|length
parameter_list|,
name|PDESC_ARRAY
name|desc_array
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_sysctl_int_delay
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_add_int_delay_sysctl
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|em_int_delay_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Management and WOL Support */
end_comment

begin_function_decl
specifier|static
name|void
name|em_init_manageability
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_release_manageability
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_get_hw_control
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_release_hw_control
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_get_wakeup
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_enable_wakeup
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_enable_phy_wakeup
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|EM_LEGACY_IRQ
end_ifdef

begin_function_decl
specifier|static
name|void
name|em_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* FAST IRQ */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
end_if

begin_function_decl
specifier|static
name|void
name|em_irq_fast
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|em_irq_fast
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSIX handlers */
end_comment

begin_function_decl
specifier|static
name|void
name|em_msix_tx
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_msix_rx
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_msix_link
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_handle_rx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_handle_tx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_handle_rxtx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_handle_link
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_add_rx_process_limit
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ~EM_LEGACY_IRQ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_decl_stmt
specifier|static
name|poll_handler_t
name|em_poll
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* POLLING */
end_comment

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|em_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|em_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|em_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|em_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|em_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|em_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|em_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|em_driver
init|=
block|{
literal|"em"
block|,
name|em_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|adapter
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|em_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|em
argument_list|,
name|pci
argument_list|,
name|em_driver
argument_list|,
name|em_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|em
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|em
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*********************************************************************  *  Tunable default values.  *********************************************************************/
end_comment

begin_define
define|#
directive|define
name|EM_TICKS_TO_USECS
parameter_list|(
name|ticks
parameter_list|)
value|((1024 * (ticks) + 500) / 1000)
end_define

begin_define
define|#
directive|define
name|EM_USECS_TO_TICKS
parameter_list|(
name|usecs
parameter_list|)
value|((1000 * (usecs) + 512) / 1024)
end_define

begin_define
define|#
directive|define
name|M_TSO_LEN
value|66
end_define

begin_comment
comment|/* Allow common code without TSO */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CSUM_TSO
end_ifndef

begin_define
define|#
directive|define
name|CSUM_TSO
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|em_tx_int_delay_dflt
init|=
name|EM_TICKS_TO_USECS
argument_list|(
name|EM_TIDV
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_rx_int_delay_dflt
init|=
name|EM_TICKS_TO_USECS
argument_list|(
name|EM_RDTR
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_tx_abs_int_delay_dflt
init|=
name|EM_TICKS_TO_USECS
argument_list|(
name|EM_TADV
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_rx_abs_int_delay_dflt
init|=
name|EM_TICKS_TO_USECS
argument_list|(
name|EM_RADV
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_rxd
init|=
name|EM_DEFAULT_RXD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_txd
init|=
name|EM_DEFAULT_TXD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|em_smart_pwr_down
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls whether promiscuous also shows bad packets */
end_comment

begin_decl_stmt
specifier|static
name|int
name|em_debug_sbp
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local switch for MSI/MSIX */
end_comment

begin_decl_stmt
specifier|static
name|int
name|em_enable_msi
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.em.tx_int_delay"
argument_list|,
operator|&
name|em_tx_int_delay_dflt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.em.rx_int_delay"
argument_list|,
operator|&
name|em_rx_int_delay_dflt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.em.tx_abs_int_delay"
argument_list|,
operator|&
name|em_tx_abs_int_delay_dflt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.em.rx_abs_int_delay"
argument_list|,
operator|&
name|em_rx_abs_int_delay_dflt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.em.rxd"
argument_list|,
operator|&
name|em_rxd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.em.txd"
argument_list|,
operator|&
name|em_txd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.em.smart_pwr_down"
argument_list|,
operator|&
name|em_smart_pwr_down
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.em.sbp"
argument_list|,
operator|&
name|em_debug_sbp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.em.enable_msi"
argument_list|,
operator|&
name|em_enable_msi
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|EM_LEGACY_IRQ
end_ifndef

begin_comment
comment|/* How many packets rxeof tries to clean at a time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|em_rx_process_limit
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.em.rx_process_limit"
argument_list|,
operator|&
name|em_rx_process_limit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Flow control setting - default to FULL */
end_comment

begin_decl_stmt
specifier|static
name|int
name|em_fc_setting
init|=
name|e1000_fc_full
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.em.fc_setting"
argument_list|,
operator|&
name|em_fc_setting
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Shadow VFTA table, this is needed because ** the real vlan filter table gets cleared during ** a soft reset and the driver needs to be able ** to repopulate it. */
end_comment

begin_decl_stmt
specifier|static
name|u32
name|em_shadow_vfta
index|[
name|EM_VFTA_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global used in WOL setup with multiport cards */
end_comment

begin_decl_stmt
specifier|static
name|int
name|global_quad_port_a
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Device identification routine  *  *  em_probe determines if the driver should be loaded on  *  adapter based on PCI vendor/device id of the adapter.  *  *  return BUS_PROBE_DEFAULT on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
name|adapter_name
index|[
literal|60
index|]
decl_stmt|;
name|u16
name|pci_vendor_id
init|=
literal|0
decl_stmt|;
name|u16
name|pci_device_id
init|=
literal|0
decl_stmt|;
name|u16
name|pci_subvendor_id
init|=
literal|0
decl_stmt|;
name|u16
name|pci_subdevice_id
init|=
literal|0
decl_stmt|;
name|em_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_probe: begin"
argument_list|)
expr_stmt|;
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_vendor_id
operator|!=
name|EM_VENDOR_ID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|em_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subvendor_id
operator|==
name|PCI_ANY_ID
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subdevice_id
operator|==
name|PCI_ANY_ID
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|adapter_name
argument_list|,
literal|"%s %s"
argument_list|,
name|em_strings
index|[
name|ent
operator|->
name|index
index|]
argument_list|,
name|em_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|adapter_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device initialization routine  *  *  The attach entry point is called when the driver is being loaded.  *  This routine identifies the type of hardware, allocates all resources  *  and initializes the hardware.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|int
name|tsize
decl_stmt|,
name|rsize
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_attach: begin"
argument_list|)
expr_stmt|;
name|adapter
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|dev
operator|=
name|adapter
operator|->
name|osdep
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|EM_CORE_LOCK_INIT
argument_list|(
name|adapter
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|EM_TX_LOCK_INIT
argument_list|(
name|adapter
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|EM_RX_LOCK_INIT
argument_list|(
name|adapter
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SYSCTL stuff */
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|em_sysctl_debug_info
argument_list|,
literal|"I"
argument_list|,
literal|"Debug Information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|em_sysctl_stats
argument_list|,
literal|"I"
argument_list|,
literal|"Statistics"
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|adapter
operator|->
name|tx_fifo_timer
argument_list|,
operator|&
name|adapter
operator|->
name|tx_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Determine hardware and mac info */
name|em_identify_hardware
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Setup PCI resources */
if|if
condition|(
name|em_allocate_pci_resources
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Allocation of PCI resources failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_pci
goto|;
block|}
comment|/* 	** For ICH8 and family we need to 	** map the flash memory, and this 	** must happen after the MAC is  	** identified 	*/
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_pchlan
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_ich9lan
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_ich10lan
operator|)
condition|)
block|{
name|int
name|rid
init|=
name|EM_BAR_TYPE_FLASH
decl_stmt|;
name|adapter
operator|->
name|flash
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|flash
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Mapping of Flash failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_pci
goto|;
block|}
comment|/* This is used in the shared code */
name|adapter
operator|->
name|hw
operator|.
name|flash_address
operator|=
operator|(
name|u8
operator|*
operator|)
name|adapter
operator|->
name|flash
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|flash_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|flash
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|flash_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|flash
argument_list|)
expr_stmt|;
block|}
comment|/* Do Shared Code initialization */
if|if
condition|(
name|e1000_setup_init_funcs
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Setup of Shared code failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_pci
goto|;
block|}
name|e1000_get_bus_info
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Set up some sysctls for the tunable interrupt delays */
name|em_add_int_delay_sysctl
argument_list|(
name|adapter
argument_list|,
literal|"rx_int_delay"
argument_list|,
literal|"receive interrupt delay in usecs"
argument_list|,
operator|&
name|adapter
operator|->
name|rx_int_delay
argument_list|,
name|E1000_REGISTER
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RDTR
argument_list|)
argument_list|,
name|em_rx_int_delay_dflt
argument_list|)
expr_stmt|;
name|em_add_int_delay_sysctl
argument_list|(
name|adapter
argument_list|,
literal|"tx_int_delay"
argument_list|,
literal|"transmit interrupt delay in usecs"
argument_list|,
operator|&
name|adapter
operator|->
name|tx_int_delay
argument_list|,
name|E1000_REGISTER
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TIDV
argument_list|)
argument_list|,
name|em_tx_int_delay_dflt
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82540
condition|)
block|{
name|em_add_int_delay_sysctl
argument_list|(
name|adapter
argument_list|,
literal|"rx_abs_int_delay"
argument_list|,
literal|"receive interrupt delay limit in usecs"
argument_list|,
operator|&
name|adapter
operator|->
name|rx_abs_int_delay
argument_list|,
name|E1000_REGISTER
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RADV
argument_list|)
argument_list|,
name|em_rx_abs_int_delay_dflt
argument_list|)
expr_stmt|;
name|em_add_int_delay_sysctl
argument_list|(
name|adapter
argument_list|,
literal|"tx_abs_int_delay"
argument_list|,
literal|"transmit interrupt delay limit in usecs"
argument_list|,
operator|&
name|adapter
operator|->
name|tx_abs_int_delay
argument_list|,
name|E1000_REGISTER
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TADV
argument_list|)
argument_list|,
name|em_tx_abs_int_delay_dflt
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|EM_LEGACY_IRQ
comment|/* Sysctls for limiting the amount of work done in the taskqueue */
name|em_add_rx_process_limit
argument_list|(
name|adapter
argument_list|,
literal|"rx_processing_limit"
argument_list|,
literal|"max number of rx packets to process"
argument_list|,
operator|&
name|adapter
operator|->
name|rx_process_limit
argument_list|,
name|em_rx_process_limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Validate number of transmit and receive descriptors. It 	 * must not exceed hardware maximum, and must be multiple 	 * of E1000_DBA_ALIGN. 	 */
if|if
condition|(
operator|(
operator|(
name|em_txd
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
operator|)
operator|%
name|EM_DBA_ALIGN
operator|)
operator|!=
literal|0
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82544
operator|&&
name|em_txd
operator|>
name|EM_MAX_TXD
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|<
name|e1000_82544
operator|&&
name|em_txd
operator|>
name|EM_MAX_TXD_82543
operator|)
operator|||
operator|(
name|em_txd
operator|<
name|EM_MIN_TXD
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using %d TX descriptors instead of %d!\n"
argument_list|,
name|EM_DEFAULT_TXD
argument_list|,
name|em_txd
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_tx_desc
operator|=
name|EM_DEFAULT_TXD
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|num_tx_desc
operator|=
name|em_txd
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|em_rxd
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_rx_desc
argument_list|)
operator|)
operator|%
name|EM_DBA_ALIGN
operator|)
operator|!=
literal|0
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82544
operator|&&
name|em_rxd
operator|>
name|EM_MAX_RXD
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|<
name|e1000_82544
operator|&&
name|em_rxd
operator|>
name|EM_MAX_RXD_82543
operator|)
operator|||
operator|(
name|em_rxd
operator|<
name|EM_MIN_RXD
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using %d RX descriptors instead of %d!\n"
argument_list|,
name|EM_DEFAULT_RXD
argument_list|,
name|em_rxd
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_rx_desc
operator|=
name|EM_DEFAULT_RXD
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|num_rx_desc
operator|=
name|em_rxd
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_wait_to_complete
operator|=
name|FALSE
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
name|AUTONEG_ADV_DEFAULT
expr_stmt|;
name|adapter
operator|->
name|rx_buffer_len
operator|=
literal|2048
expr_stmt|;
name|e1000_init_script_state_82541
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|e1000_set_tbi_compatibility_82543
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Copper options */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
block|{
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|mdix
operator|=
name|AUTO_ALL_MODES
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|disable_polarity_correction
operator|=
name|FALSE
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|ms_type
operator|=
name|EM_MASTER_SLAVE
expr_stmt|;
block|}
comment|/* 	 * Set the frame limits assuming 	 * standard ethernet sized frames. 	 */
name|adapter
operator|->
name|max_frame_size
operator|=
name|ETHERMTU
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHERNET_FCS_SIZE
expr_stmt|;
name|adapter
operator|->
name|min_frame_size
operator|=
name|ETH_ZLEN
operator|+
name|ETHERNET_FCS_SIZE
expr_stmt|;
comment|/* 	 * This controls when hardware reports transmit completion 	 * status. 	 */
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|report_tx_early
operator|=
literal|1
expr_stmt|;
name|tsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
argument_list|,
name|EM_DBA_ALIGN
argument_list|)
expr_stmt|;
comment|/* Allocate Transmit Descriptor ring */
if|if
condition|(
name|em_dma_malloc
argument_list|(
name|adapter
argument_list|,
name|tsize
argument_list|,
operator|&
name|adapter
operator|->
name|txdma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate tx_desc memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
name|adapter
operator|->
name|tx_desc_base
operator|=
operator|(
expr|struct
name|e1000_tx_desc
operator|*
operator|)
name|adapter
operator|->
name|txdma
operator|.
name|dma_vaddr
expr_stmt|;
name|rsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_rx_desc
argument_list|)
argument_list|,
name|EM_DBA_ALIGN
argument_list|)
expr_stmt|;
comment|/* Allocate Receive Descriptor ring */
if|if
condition|(
name|em_dma_malloc
argument_list|(
name|adapter
argument_list|,
name|rsize
argument_list|,
operator|&
name|adapter
operator|->
name|rxdma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate rx_desc memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
name|adapter
operator|->
name|rx_desc_base
operator|=
operator|(
expr|struct
name|e1000_rx_desc
operator|*
operator|)
name|adapter
operator|->
name|rxdma
operator|.
name|dma_vaddr
expr_stmt|;
comment|/* 	** Start from a known state, this is 	** important in reading the nvm and 	** mac from that. 	*/
name|e1000_reset_hw
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Make sure we have a good EEPROM before we read from it */
if|if
condition|(
name|e1000_validate_nvm_checksum
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 		** Some PCI-E parts fail the first check due to 		** the link being in sleep state, call it again, 		** if it fails a second time its a real issue. 		*/
if|if
condition|(
name|e1000_validate_nvm_checksum
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The EEPROM Checksum Is Not Valid\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_hw_init
goto|;
block|}
block|}
comment|/* Copy the permanent MAC address out of the EEPROM */
if|if
condition|(
name|e1000_read_mac_addr
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"EEPROM read error while reading MAC"
literal|" address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_hw_init
goto|;
block|}
if|if
condition|(
operator|!
name|em_is_valid_ether_addr
argument_list|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid MAC address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_hw_init
goto|;
block|}
comment|/* Initialize the hardware */
if|if
condition|(
name|em_hardware_init
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize the hardware\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_hw_init
goto|;
block|}
comment|/* Allocate transmit descriptors and buffers */
if|if
condition|(
name|em_allocate_transmit_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup transmit structures\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_struct
goto|;
block|}
comment|/* Allocate receive descriptors and buffers */
if|if
condition|(
name|em_allocate_receive_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup receive structures\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_rx_struct
goto|;
block|}
comment|/* 	**  Do interrupt configuration 	*/
if|if
condition|(
name|adapter
operator|->
name|msi
operator|>
literal|1
condition|)
comment|/* Do MSI/X */
name|error
operator|=
name|em_allocate_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
comment|/* MSI or Legacy */
name|error
operator|=
name|em_allocate_legacy
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_rx_struct
goto|;
comment|/* 	 * Get Wake-on-Lan and Management info for later use 	 */
name|em_get_wakeup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Setup OS specific network interface */
name|em_setup_interface
argument_list|(
name|dev
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
comment|/* Initialize statistics */
name|em_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|get_link_status
operator|=
literal|1
expr_stmt|;
name|em_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Indicate SOL/IDER usage */
if|if
condition|(
name|e1000_check_reset_block
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PHY reset is blocked due to SOL/IDER session.\n"
argument_list|)
expr_stmt|;
comment|/* Do we need workaround for 82544 PCI-X adapter? */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|type
operator|==
name|e1000_bus_type_pcix
operator|&&
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82544
condition|)
name|adapter
operator|->
name|pcix_82544
operator|=
name|TRUE
expr_stmt|;
else|else
name|adapter
operator|->
name|pcix_82544
operator|=
name|FALSE
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700029
comment|/* Register for VLAN events */
name|adapter
operator|->
name|vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|em_register_vlan
argument_list|,
name|adapter
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|em_unregister_vlan
argument_list|,
name|adapter
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Non-AMT based hardware can now take control from firmware */
if|if
condition|(
name|adapter
operator|->
name|has_manage
operator|&&
operator|!
name|adapter
operator|->
name|has_amt
condition|)
name|em_get_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is not active */
name|adapter
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_attach: end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_rx_struct
label|:
name|em_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_tx_struct
label|:
name|err_hw_init
label|:
name|em_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|rxdma
argument_list|)
expr_stmt|;
name|err_rx_desc
label|:
name|em_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|txdma
argument_list|)
expr_stmt|;
name|err_tx_desc
label|:
name|err_pci
label|:
name|em_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_TX_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_RX_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device removal routine  *  *  The detach entry point is called when the driver is being removed.  *  This routine stops the adapter and deallocates all the resources  *  that were allocated for driver operation.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_detach: begin"
argument_list|)
expr_stmt|;
comment|/* Make sure VLANS are not using driver */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|->
name|if_nvlans
operator|!=
literal|0
condition|)
block|{
endif|#
directive|endif
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Vlan in use, detach first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_TX_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|in_detach
operator|=
literal|1
expr_stmt|;
name|em_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|e1000_phy_hw_reset
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|em_release_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700029
comment|/* Unregister VLAN events */
if|if
condition|(
name|adapter
operator|->
name|vlan_attach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|adapter
operator|->
name|vlan_attach
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|vlan_detach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|adapter
operator|->
name|vlan_detach
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ether_ifdetach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|adapter
operator|->
name|tx_fifo_timer
argument_list|)
expr_stmt|;
name|em_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|em_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Free Transmit Descriptor ring */
if|if
condition|(
name|adapter
operator|->
name|tx_desc_base
condition|)
block|{
name|em_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|txdma
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tx_desc_base
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free Receive Descriptor ring */
if|if
condition|(
name|adapter
operator|->
name|rx_desc_base
condition|)
block|{
name|em_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|rxdma
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|rx_desc_base
operator|=
name|NULL
expr_stmt|;
block|}
name|em_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_TX_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_RX_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Shutdown entry point  *  **********************************************************************/
specifier|static
name|int
name|em_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
name|em_suspend
argument_list|(
name|dev
argument_list|)
return|;
block|}
comment|/*  * Suspend/resume device methods.  */
specifier|static
name|int
name|em_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_release_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_enable_wakeup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
return|;
block|}
specifier|static
name|int
name|em_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_init_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
return|;
block|}
comment|/*********************************************************************  *  Transmit entry point  *  *  em_start is called by the stack to initiate a transmit.  *  The driver will remain in this routine as long as there are  *  packets to transmit and transmit resources are available.  *  In case resources are not available stack is notified and  *  the packet is requeued.  **********************************************************************/
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
specifier|static
name|int
name|em_mq_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
name|int
name|error
init|=
name|E1000_SUCCESS
decl_stmt|;
name|EM_TX_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* To allow being called from a tasklet */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|process
goto|;
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|)
operator|||
operator|(
operator|!
name|adapter
operator|->
name|link_active
operator|)
condition|)
block|{
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|drbr_needs_enqueue
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|br
argument_list|)
operator|&&
operator|(
name|adapter
operator|->
name|num_tx_desc_avail
operator|>
name|EM_TX_OP_THRESHOLD
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|em_xmit
argument_list|(
name|adapter
argument_list|,
operator|&
name|m
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
condition|)
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * We've bypassed the buf ring so we need to update 			 * ifp directly 			 */
name|drbr_stats_update
argument_list|(
name|ifp
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
expr_stmt|;
comment|/* 			** Send a copy of the frame to the BPF 			** listener and set the watchdog on. 			*/
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|watchdog_check
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|br
argument_list|,
name|m
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|process
label|:
if|if
condition|(
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|br
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Process the queue */
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
name|next
operator|=
name|drbr_dequeue
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|br
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|em_xmit
argument_list|(
name|adapter
argument_list|,
operator|&
name|next
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|br
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
name|drbr_stats_update
argument_list|(
name|ifp
argument_list|,
name|next
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|next
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* Set the watchdog */
name|adapter
operator|->
name|watchdog_check
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|num_tx_desc_avail
operator|<=
name|EM_TX_OP_THRESHOLD
condition|)
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* ** Multiqueue capable stack interface, this is not ** yet truely multiqueue, but that is coming... */
specifier|static
name|int
name|em_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|EM_TX_TRYLOCK
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|error
operator|=
name|em_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
specifier|static
name|void
name|em_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|EM_TX_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|adapter
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FreeBSD_version */
specifier|static
name|void
name|em_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|EM_TX_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
condition|)
return|return;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
return|return;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 *  Encapsulation can modify our pointer, and or make it 		 *  NULL on failure.  In that event, we can't requeue. 		 */
if|if
condition|(
name|em_xmit
argument_list|(
name|adapter
argument_list|,
operator|&
name|m_head
argument_list|)
condition|)
block|{
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Send a copy of the frame to the BPF listener */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
comment|/* Set timeout in case hardware has problems transmitting. */
name|adapter
operator|->
name|watchdog_check
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|num_tx_desc_avail
operator|<=
name|EM_TX_OP_THRESHOLD
condition|)
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|em_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|EM_TX_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|em_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  Ioctl entry point  *  *  em_ioctl is called when the user wants to configure the  *  interface.  *  *  return 0 on success, positive on failure  **********************************************************************/
specifier|static
name|int
name|em_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|in_detach
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* 			 * XXX 			 * Since resetting hardware takes a very long time 			 * and results in link renegotiation we only 			 * initialize the hardware only when it is absolutely 			 * required. 			 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
block|{
name|int
name|max_frame_size
decl_stmt|;
name|u16
name|eeprom_data
init|=
literal|0
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
comment|/* 			 * 82573 only supports jumbo frames 			 * if ASPM is disabled. 			 */
name|e1000_read_nvm
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|NVM_INIT_3GIO_3
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom_data
operator|&
name|NVM_WORD1A_ASPM_MASK
condition|)
block|{
name|max_frame_size
operator|=
name|ETHER_MAX_LEN
expr_stmt|;
break|break;
block|}
comment|/* Allow Jumbo frames - fall thru */
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
case|case
name|e1000_ich9lan
case|:
case|case
name|e1000_ich10lan
case|:
case|case
name|e1000_82574
case|:
case|case
name|e1000_80003es2lan
case|:
comment|/* Limit Jumbo Frame size */
name|max_frame_size
operator|=
literal|9234
expr_stmt|;
break|break;
case|case
name|e1000_pchlan
case|:
name|max_frame_size
operator|=
literal|4096
expr_stmt|;
break|break;
comment|/* Adapters that do not support jumbo frames */
case|case
name|e1000_82542
case|:
case|case
name|e1000_82583
case|:
case|case
name|e1000_ich8lan
case|:
name|max_frame_size
operator|=
name|ETHER_MAX_LEN
expr_stmt|;
break|break;
default|default:
name|max_frame_size
operator|=
name|MAX_JUMBO_FRAME_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|max_frame_size
operator|-
name|ETHER_HDR_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|adapter
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCSIFFLAGS
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd:\ 		    SIOCSIFFLAGS (Set Interface Flags)"
argument_list|)
expr_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|adapter
operator|->
name|if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
name|em_disable_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_set_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|EM_TX_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
name|adapter
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOC(ADD|DEL)MULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82542
operator|&&
name|adapter
operator|->
name|hw
operator|.
name|revision_id
operator|==
name|E1000_REVISION_2
condition|)
block|{
name|em_initialize_receive_unit
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
condition|)
endif|#
directive|endif
name|em_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
comment|/* Check SOL/IDER usage */
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1000_check_reset_block
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
condition|)
block|{
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Media change is"
literal|" blocked due to SOL/IDER session.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
case|case
name|SIOCGIFMEDIA
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: \ 		    SIOCxIFMEDIA (Get/Set Interface Media)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|mask
decl_stmt|,
name|reinit
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCSIFCAP (Set Capabilities)"
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|mask
operator|&
name|IFCAP_POLLING
condition|)
block|{
if|if
condition|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|error
operator|=
name|ether_poll_register
argument_list|(
name|em_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Enable interrupt even in error case */
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_POLLING
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|mask
operator|&
name|IFCAP_HWCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_HWCSUM
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_WOL
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_WOL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_WOL_MCAST
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_WOL_MCAST
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_WOL_MAGIC
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_WOL_MAGIC
expr_stmt|;
block|}
if|if
condition|(
name|reinit
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|em_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*********************************************************************  *  Init entry point  *  *  This routine is used in two ways. It is used by the stack as  *  init entry point in network interface structure. It is also used  *  by the driver as a hw/sw initialization routine to get to a  *  consistent state.  *  *  return 0 on success, positive on failure  **********************************************************************/
specifier|static
name|void
name|em_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|u32
name|pba
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_init: begin"
argument_list|)
expr_stmt|;
name|EM_CORE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_TX_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	 * Packet Buffer Allocation (PBA) 	 * Writing PBA sets the receive portion of the buffer 	 * the remainder is used for the transmit buffer. 	 * 	 * Devices before the 82547 had a Packet Buffer of 64K. 	 *   Default allocation: PBA=48K for Rx, leaving 16K for Tx. 	 * After the 82547 the buffer was reduced to 40K. 	 *   Default allocation: PBA=30K for Rx, leaving 10K for Tx. 	 *   Note: default does not leave enough room for Jumbo Frame>10k. 	 */
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82547
case|:
case|case
name|e1000_82547_rev_2
case|:
comment|/* 82547: Total Packet Buffer is 40K */
if|if
condition|(
name|adapter
operator|->
name|max_frame_size
operator|>
literal|8192
condition|)
name|pba
operator|=
name|E1000_PBA_22K
expr_stmt|;
comment|/* 22K for Rx, 18K for Tx */
else|else
name|pba
operator|=
name|E1000_PBA_30K
expr_stmt|;
comment|/* 30K for Rx, 10K for Tx */
name|adapter
operator|->
name|tx_fifo_head
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|tx_head_addr
operator|=
name|pba
operator|<<
name|EM_TX_HEAD_ADDR_SHIFT
expr_stmt|;
name|adapter
operator|->
name|tx_fifo_size
operator|=
operator|(
name|E1000_PBA_40K
operator|-
name|pba
operator|)
operator|<<
name|EM_PBA_BYTES_SHIFT
expr_stmt|;
break|break;
comment|/* Total Packet Buffer on these is 48K */
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
case|case
name|e1000_80003es2lan
case|:
name|pba
operator|=
name|E1000_PBA_32K
expr_stmt|;
comment|/* 32K for Rx, 16K for Tx */
break|break;
case|case
name|e1000_82573
case|:
comment|/* 82573: Total Packet Buffer is 32K */
name|pba
operator|=
name|E1000_PBA_12K
expr_stmt|;
comment|/* 12K for Rx, 20K for Tx */
break|break;
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|pba
operator|=
name|E1000_PBA_20K
expr_stmt|;
comment|/* 20K for Rx, 20K for Tx */
break|break;
case|case
name|e1000_ich9lan
case|:
case|case
name|e1000_ich10lan
case|:
case|case
name|e1000_pchlan
case|:
name|pba
operator|=
name|E1000_PBA_10K
expr_stmt|;
break|break;
case|case
name|e1000_ich8lan
case|:
name|pba
operator|=
name|E1000_PBA_8K
expr_stmt|;
break|break;
default|default:
comment|/* Devices before 82547 had a Packet Buffer of 64K.   */
if|if
condition|(
name|adapter
operator|->
name|max_frame_size
operator|>
literal|8192
condition|)
name|pba
operator|=
name|E1000_PBA_40K
expr_stmt|;
comment|/* 40K for Rx, 24K for Tx */
else|else
name|pba
operator|=
name|E1000_PBA_48K
expr_stmt|;
comment|/* 48K for Rx, 16K for Tx */
block|}
name|INIT_DEBUGOUT1
argument_list|(
literal|"em_init: pba=%dK"
argument_list|,
name|pba
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_PBA
argument_list|,
name|pba
argument_list|)
expr_stmt|;
comment|/* Get the latest mac address, User can use a LAA */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Put the address into the Receive Address Array */
name|e1000_rar_set
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * With the 82571 adapter, RAR[0] may be overwritten 	 * when the other port is reset, we make a duplicate 	 * in RAR[14] for that eventuality, this assures 	 * the interface continues to function. 	 */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82571
condition|)
block|{
name|e1000_set_laa_state_82571
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|e1000_rar_set
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
name|E1000_RAR_ENTRIES
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the hardware */
if|if
condition|(
name|em_hardware_init
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize the hardware\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|em_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Setup VLAN support, basic and offload if available */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_VET
argument_list|,
name|ETHERTYPE_VLAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
comment|/* Use real VLAN Filter support */
name|em_setup_vlan_hw_support
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
block|{
name|u32
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_VME
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set hardware offload abilities */
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82543
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Configure for OS presence */
name|em_init_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Prepare transmit descriptors and buffers */
name|em_setup_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_initialize_transmit_unit
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Setup Multicast table */
name|em_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Prepare receive descriptors and buffers */
if|if
condition|(
name|em_setup_receive_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup receive structures\n"
argument_list|)
expr_stmt|;
name|EM_TX_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|em_initialize_receive_unit
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Don't lose promiscuous settings */
name|em_set_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|em_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|e1000_clear_hw_cntrs_base_generic
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* MSI/X configuration for 82574 */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82574
condition|)
block|{
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|tmp
operator||=
name|E1000_CTRL_EXT_PBA_CLR
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* 		** Set the IVAR - interrupt vector routing. 		** Each nibble represents a vector, high bit 		** is enable, other 3 bits are the MSIX table 		** entry, we map RXQ0 to 0, TXQ0 to 1, and 		** Link (other) to 2, hence the magic number. 		*/
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IVAR
argument_list|,
literal|0x800A0908
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* 	 * Only enable interrupts if we are not polling, make sure 	 * they are off otherwise. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|em_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* DEVICE_POLLING */
name|em_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* AMT based hardware can now take control from firmware */
if|if
condition|(
name|adapter
operator|->
name|has_manage
operator|&&
name|adapter
operator|->
name|has_amt
condition|)
name|em_get_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Don't reset the phy next time init gets called */
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|reset_disable
operator|=
name|TRUE
expr_stmt|;
block|}
specifier|static
name|void
name|em_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/*********************************************************************  *  *  Legacy polling routine    *  *********************************************************************/
specifier|static
name|int
name|em_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u32
name|reg_icr
decl_stmt|,
name|rx_done
init|=
literal|0
decl_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|rx_done
operator|)
return|;
block|}
if|if
condition|(
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
condition|)
block|{
name|reg_icr
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
comment|/* Link status change */
if|if
condition|(
name|reg_icr
operator|&
operator|(
name|E1000_ICR_RXSEQ
operator||
name|E1000_ICR_LSC
operator|)
condition|)
block|{
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|get_link_status
operator|=
literal|1
expr_stmt|;
name|em_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_icr
operator|&
name|E1000_ICR_RXO
condition|)
name|adapter
operator|->
name|rx_overruns
operator|++
expr_stmt|;
block|}
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|rx_done
operator|=
name|em_rxeof
argument_list|(
name|adapter
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|EM_TX_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_txeof
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|br
argument_list|)
condition|)
name|em_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|em_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EM_TX_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|rx_done
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* DEVICE_POLLING */
ifdef|#
directive|ifdef
name|EM_LEGACY_IRQ
comment|/*********************************************************************  *  *  Legacy Interrupt Service routine    *  *********************************************************************/
specifier|static
name|void
name|em_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|u32
name|reg_icr
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
return|return;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|reg_icr
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_icr
operator|&
name|E1000_ICR_RXO
condition|)
name|adapter
operator|->
name|rx_overruns
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|reg_icr
operator|==
literal|0xffffffff
operator|)
operator|||
operator|(
name|reg_icr
operator|==
literal|0
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82571
operator|&&
operator|(
name|reg_icr
operator|&
name|E1000_ICR_INT_ASSERTED
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|reg_icr
operator|&
operator|(
name|E1000_ICR_RXSEQ
operator||
name|E1000_ICR_LSC
operator|)
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|get_link_status
operator|=
literal|1
expr_stmt|;
name|em_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Deal with TX cruft when link lost */
name|em_tx_purge
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|em_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|EM_TX_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_txeof
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_rxeof
argument_list|(
name|adapter
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|em_txeof
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|em_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|out
label|:
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
comment|/* EM_FAST_IRQ, then fast interrupt routines only */
specifier|static
name|void
name|em_handle_link
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
name|em_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Deal with TX cruft when link lost */
name|em_tx_purge
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|em_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
comment|/* Combined RX/TX handler, used by Legacy and MSI */
specifier|static
name|void
name|em_handle_rxtx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
if|if
condition|(
name|em_rxeof
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|rx_process_limit
argument_list|)
operator|!=
literal|0
condition|)
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|rxtx_task
argument_list|)
expr_stmt|;
name|EM_TX_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_txeof
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|br
argument_list|)
condition|)
name|em_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|em_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EM_TX_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
name|em_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  *  Fast Legacy/MSI Combined Interrupt Service routine    *  *********************************************************************/
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
define|#
directive|define
name|FILTER_STRAY
define|#
directive|define
name|FILTER_HANDLED
specifier|static
name|void
else|#
directive|else
specifier|static
name|int
endif|#
directive|endif
name|em_irq_fast
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u32
name|reg_icr
decl_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|reg_icr
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
comment|/* Hot eject?  */
if|if
condition|(
name|reg_icr
operator|==
literal|0xffffffff
condition|)
return|return
name|FILTER_STRAY
return|;
comment|/* Definitely not our interrupt.  */
if|if
condition|(
name|reg_icr
operator|==
literal|0x0
condition|)
return|return
name|FILTER_STRAY
return|;
comment|/* 	 * Starting with the 82571 chip, bit 31 should be used to 	 * determine whether the interrupt belongs to us. 	 */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82571
operator|&&
operator|(
name|reg_icr
operator|&
name|E1000_ICR_INT_ASSERTED
operator|)
operator|==
literal|0
condition|)
return|return
name|FILTER_STRAY
return|;
comment|/* 	 * Mask interrupts until the taskqueue is finished running.  This is 	 * cheap, just assume that it is needed.  This also works around the 	 * MSI message reordering errata on certain systems. 	 */
name|em_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|rxtx_task
argument_list|)
expr_stmt|;
comment|/* Link status change */
if|if
condition|(
name|reg_icr
operator|&
operator|(
name|E1000_ICR_RXSEQ
operator||
name|E1000_ICR_LSC
operator|)
condition|)
block|{
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|get_link_status
operator|=
literal|1
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_fast
argument_list|,
operator|&
name|adapter
operator|->
name|link_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_icr
operator|&
name|E1000_ICR_RXO
condition|)
name|adapter
operator|->
name|rx_overruns
operator|++
expr_stmt|;
return|return
name|FILTER_HANDLED
return|;
block|}
comment|/*********************************************************************  *  *  MSIX Interrupt Service Routines  *  **********************************************************************/
define|#
directive|define
name|EM_MSIX_TX
value|0x00040000
define|#
directive|define
name|EM_MSIX_RX
value|0x00010000
define|#
directive|define
name|EM_MSIX_LINK
value|0x00100000
specifier|static
name|void
name|em_msix_tx
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
operator|++
name|adapter
operator|->
name|tx_irq
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|EM_TX_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_txeof
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_TX_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|tx_task
argument_list|)
expr_stmt|;
block|}
comment|/* Reenable this interrupt */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|EM_MSIX_TX
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  MSIX RX Interrupt Service routine  *  **********************************************************************/
specifier|static
name|void
name|em_msix_rx
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
operator|++
name|adapter
operator|->
name|rx_irq
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
operator|(
name|em_rxeof
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|rx_process_limit
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|rx_task
argument_list|)
expr_stmt|;
comment|/* Reenable this interrupt */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|EM_MSIX_RX
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  MSIX Link Fast Interrupt Service routine  *  **********************************************************************/
specifier|static
name|void
name|em_msix_link
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|u32
name|reg_icr
decl_stmt|;
operator|++
name|adapter
operator|->
name|link_irq
expr_stmt|;
name|reg_icr
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_icr
operator|&
operator|(
name|E1000_ICR_RXSEQ
operator||
name|E1000_ICR_LSC
operator|)
condition|)
block|{
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|get_link_status
operator|=
literal|1
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_fast
argument_list|,
operator|&
name|adapter
operator|->
name|link_task
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|EM_MSIX_LINK
operator||
name|E1000_IMS_LSC
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|em_handle_rx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
operator|(
name|em_rxeof
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|rx_process_limit
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|rx_task
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|em_handle_tx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
if|if
condition|(
operator|!
name|EM_TX_TRYLOCK
argument_list|(
name|adapter
argument_list|)
condition|)
return|return;
name|em_txeof
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|br
argument_list|)
condition|)
name|em_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|em_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EM_TX_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* EM_FAST_IRQ */
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called whenever the user queries the status of  *  the interface using ifconfig.  *  **********************************************************************/
specifier|static
name|void
name|em_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_char
name|fiber_type
init|=
name|IFM_1000_SX
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_media_status: begin"
argument_list|)
expr_stmt|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
block|{
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_fiber
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
operator|)
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82545
condition|)
name|fiber_type
operator|=
name|IFM_1000_LX
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|fiber_type
operator||
name|IFM_FDX
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
literal|10
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
break|break;
case|case
literal|100
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
break|break;
case|case
literal|1000
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|adapter
operator|->
name|link_duplex
operator|==
name|FULL_DUPLEX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_HDX
expr_stmt|;
block|}
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called when the user changes speed/duplex using  *  media/mediopt option with ifconfig.  *  **********************************************************************/
specifier|static
name|int
name|em_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|adapter
operator|->
name|media
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_media_change: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|EM_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
name|AUTONEG_ADV_DEFAULT
expr_stmt|;
break|break;
case|case
name|IFM_1000_LX
case|:
case|case
name|IFM_1000_SX
case|:
case|case
name|IFM_1000_T
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
name|ADVERTISE_1000_FULL
expr_stmt|;
break|break;
case|case
name|IFM_100_TX
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|FALSE
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifm
operator|->
name|ifm_media
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
condition|)
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_100_FULL
expr_stmt|;
else|else
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_100_HALF
expr_stmt|;
break|break;
case|case
name|IFM_10_T
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|FALSE
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifm
operator|->
name|ifm_media
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
condition|)
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_10_FULL
expr_stmt|;
else|else
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_10_HALF
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Unsupported media type\n"
argument_list|)
expr_stmt|;
block|}
comment|/* As the speed/duplex settings my have changed we need to 	 * reset the PHY. 	 */
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|reset_disable
operator|=
name|FALSE
expr_stmt|;
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  This routine maps the mbufs to tx descriptors.  *  *  return 0 on success, positive on failure  **********************************************************************/
specifier|static
name|int
name|em_xmit
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_headp
parameter_list|)
block|{
name|bus_dma_segment_t
name|segs
index|[
name|EM_MAX_SCATTER
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|em_buffer
modifier|*
name|tx_buffer
decl_stmt|,
modifier|*
name|tx_buffer_mapped
decl_stmt|;
name|struct
name|e1000_tx_desc
modifier|*
name|ctxd
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|u32
name|txd_upper
decl_stmt|,
name|txd_lower
decl_stmt|,
name|txd_used
decl_stmt|,
name|txd_saved
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|first
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|,
name|do_tso
decl_stmt|,
name|tso_desc
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
endif|#
directive|endif
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
name|txd_upper
operator|=
name|txd_lower
operator|=
name|txd_used
operator|=
name|txd_saved
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
name|do_tso
operator|=
operator|(
operator|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|do_tso
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/*          * Force a cleanup if number of TX descriptors          * available hits the threshold          */
if|if
condition|(
name|adapter
operator|->
name|num_tx_desc_avail
operator|<=
name|EM_TX_CLEANUP_THRESHOLD
condition|)
block|{
name|em_txeof
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Now do we at least have a minimal? */
if|if
condition|(
name|adapter
operator|->
name|num_tx_desc_avail
operator|<=
name|EM_TX_OP_THRESHOLD
condition|)
block|{
name|adapter
operator|->
name|no_tx_desc_avail1
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
comment|/* 	 * TSO workaround:  	 *  If an mbuf is only header we need   	 *     to pull 4 bytes of data into it.  	 */
if|if
condition|(
name|do_tso
operator|&&
operator|(
name|m_head
operator|->
name|m_len
operator|<=
name|M_TSO_LEN
operator|)
condition|)
block|{
name|m_head
operator|=
name|m_pullup
argument_list|(
name|m_head
argument_list|,
name|M_TSO_LEN
operator|+
literal|4
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|m_head
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 	 * Map the packet for DMA 	 * 	 * Capture the first descriptor index, 	 * this descriptor will have the index 	 * of the EOP which is the only one that 	 * now gets a DONE bit writeback. 	 */
name|first
operator|=
name|adapter
operator|->
name|next_avail_tx_desc
expr_stmt|;
name|tx_buffer
operator|=
operator|&
name|adapter
operator|->
name|tx_buffer_area
index|[
name|first
index|]
expr_stmt|;
name|tx_buffer_mapped
operator|=
name|tx_buffer
expr_stmt|;
name|map
operator|=
name|tx_buffer
operator|->
name|map
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
operator|*
name|m_headp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
comment|/* 	 * There are two types of errors we can (try) to handle: 	 * - EFBIG means the mbuf chain was too long and bus_dma ran 	 *   out of segments.  Defragment the mbuf chain and try again. 	 * - ENOMEM means bus_dma could not obtain enough bounce buffers 	 *   at this point in time.  Defer sending and try again later. 	 * All other errors, in particular EINVAL, are fatal and prevent the 	 * mbuf chain from ever going through.  Drop it and report error. 	 */
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_defrag
argument_list|(
operator|*
name|m_headp
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|adapter
operator|->
name|mbuf_alloc_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m_headp
operator|=
name|m
expr_stmt|;
comment|/* Try it again */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
operator|*
name|m_headp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|adapter
operator|->
name|no_tx_dma_setup
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|adapter
operator|->
name|no_tx_dma_setup
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * TSO Hardware workaround, if this packet is not 	 * TSO, and is only a single descriptor long, and 	 * it follows a TSO burst, then we need to add a 	 * sentinel descriptor to prevent premature writeback. 	 */
if|if
condition|(
operator|(
name|do_tso
operator|==
literal|0
operator|)
operator|&&
operator|(
name|adapter
operator|->
name|tx_tso
operator|==
name|TRUE
operator|)
condition|)
block|{
if|if
condition|(
name|nsegs
operator|==
literal|1
condition|)
name|tso_desc
operator|=
name|TRUE
expr_stmt|;
name|adapter
operator|->
name|tx_tso
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|nsegs
operator|>
operator|(
name|adapter
operator|->
name|num_tx_desc_avail
operator|-
literal|2
operator|)
condition|)
block|{
name|adapter
operator|->
name|no_tx_desc_avail2
operator|++
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
comment|/* Do hardware assists */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|error
operator|=
name|em_tso_setup
argument_list|(
name|adapter
argument_list|,
name|m_head
argument_list|,
operator|&
name|txd_upper
argument_list|,
operator|&
name|txd_lower
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|TRUE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* something foobar */
comment|/* we need to make a final sentinel transmit desc */
name|tso_desc
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_OFFLOAD
condition|)
name|em_transmit_checksum_setup
argument_list|(
name|adapter
argument_list|,
name|m_head
argument_list|,
operator|&
name|txd_upper
argument_list|,
operator|&
name|txd_lower
argument_list|)
expr_stmt|;
name|i
operator|=
name|adapter
operator|->
name|next_avail_tx_desc
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|pcix_82544
condition|)
name|txd_saved
operator|=
name|i
expr_stmt|;
comment|/* Set up our transmit descriptors */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsegs
condition|;
name|j
operator|++
control|)
block|{
name|bus_size_t
name|seg_len
decl_stmt|;
name|bus_addr_t
name|seg_addr
decl_stmt|;
comment|/* If adapter is 82544 and on PCIX bus */
if|if
condition|(
name|adapter
operator|->
name|pcix_82544
condition|)
block|{
name|DESC_ARRAY
name|desc_array
decl_stmt|;
name|u32
name|array_elements
decl_stmt|,
name|counter
decl_stmt|;
comment|/* 			 * Check the Address and Length combination and 			 * split the data accordingly 			 */
name|array_elements
operator|=
name|em_fill_descriptors
argument_list|(
name|segs
index|[
name|j
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|j
index|]
operator|.
name|ds_len
argument_list|,
operator|&
name|desc_array
argument_list|)
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|array_elements
condition|;
name|counter
operator|++
control|)
block|{
if|if
condition|(
name|txd_used
operator|==
name|adapter
operator|->
name|num_tx_desc_avail
condition|)
block|{
name|adapter
operator|->
name|next_avail_tx_desc
operator|=
name|txd_saved
expr_stmt|;
name|adapter
operator|->
name|no_tx_desc_avail2
operator|++
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|tx_buffer
operator|=
operator|&
name|adapter
operator|->
name|tx_buffer_area
index|[
name|i
index|]
expr_stmt|;
name|ctxd
operator|=
operator|&
name|adapter
operator|->
name|tx_desc_base
index|[
name|i
index|]
expr_stmt|;
name|ctxd
operator|->
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|desc_array
operator|.
name|descriptor
index|[
name|counter
index|]
operator|.
name|address
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|lower
operator|.
name|data
operator|=
name|htole32
argument_list|(
operator|(
name|adapter
operator|->
name|txd_cmd
operator||
name|txd_lower
operator||
operator|(
name|u16
operator|)
name|desc_array
operator|.
name|descriptor
index|[
name|counter
index|]
operator|.
name|length
operator|)
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|upper
operator|.
name|data
operator|=
name|htole32
argument_list|(
operator|(
name|txd_upper
operator|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|tx_buffer
operator|->
name|next_eop
operator|=
operator|-
literal|1
expr_stmt|;
name|txd_used
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|tx_buffer
operator|=
operator|&
name|adapter
operator|->
name|tx_buffer_area
index|[
name|i
index|]
expr_stmt|;
name|ctxd
operator|=
operator|&
name|adapter
operator|->
name|tx_desc_base
index|[
name|i
index|]
expr_stmt|;
name|seg_addr
operator|=
name|segs
index|[
name|j
index|]
operator|.
name|ds_addr
expr_stmt|;
name|seg_len
operator|=
name|segs
index|[
name|j
index|]
operator|.
name|ds_len
expr_stmt|;
comment|/* 			** TSO Workaround: 			** If this is the last descriptor, we want to 			** split it so we have a small final sentinel 			*/
if|if
condition|(
name|tso_desc
operator|&&
operator|(
name|j
operator|==
operator|(
name|nsegs
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|seg_len
operator|>
literal|8
operator|)
condition|)
block|{
name|seg_len
operator|-=
literal|4
expr_stmt|;
name|ctxd
operator|->
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|seg_addr
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|lower
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|adapter
operator|->
name|txd_cmd
operator||
name|txd_lower
operator||
name|seg_len
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|upper
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|txd_upper
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Now make the sentinel */
operator|++
name|txd_used
expr_stmt|;
comment|/* using an extra txd */
name|ctxd
operator|=
operator|&
name|adapter
operator|->
name|tx_desc_base
index|[
name|i
index|]
expr_stmt|;
name|tx_buffer
operator|=
operator|&
name|adapter
operator|->
name|tx_buffer_area
index|[
name|i
index|]
expr_stmt|;
name|ctxd
operator|->
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|seg_addr
operator|+
name|seg_len
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|lower
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|adapter
operator|->
name|txd_cmd
operator||
name|txd_lower
operator||
literal|4
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|upper
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|txd_upper
argument_list|)
expr_stmt|;
name|last
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ctxd
operator|->
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|seg_addr
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|lower
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|adapter
operator|->
name|txd_cmd
operator||
name|txd_lower
operator||
name|seg_len
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|upper
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|txd_upper
argument_list|)
expr_stmt|;
name|last
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|tx_buffer
operator|->
name|next_eop
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|adapter
operator|->
name|next_avail_tx_desc
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|pcix_82544
condition|)
name|adapter
operator|->
name|num_tx_desc_avail
operator|-=
name|txd_used
expr_stmt|;
else|else
block|{
name|adapter
operator|->
name|num_tx_desc_avail
operator|-=
name|nsegs
expr_stmt|;
if|if
condition|(
name|tso_desc
condition|)
comment|/* TSO used an extra for sentinel */
name|adapter
operator|->
name|num_tx_desc_avail
operator|-=
name|txd_used
expr_stmt|;
block|}
comment|/* 	** Handle VLAN tag, this is the 	** biggest difference between  	** 6.x and 7 	*/
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
comment|/* Find out if we are in vlan mode. */
name|mtag
operator|=
name|VLAN_OUTPUT_TAG
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|!=
name|NULL
condition|)
block|{
name|ctxd
operator|->
name|upper
operator|.
name|fields
operator|.
name|special
operator|=
name|htole16
argument_list|(
name|VLAN_TAG_VALUE
argument_list|(
name|mtag
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* FreeBSD 7 */
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
comment|/* Set the vlan id. */
name|ctxd
operator|->
name|upper
operator|.
name|fields
operator|.
name|special
operator|=
name|htole16
argument_list|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Tell hardware to add tag */
name|ctxd
operator|->
name|lower
operator|.
name|data
operator||=
name|htole32
argument_list|(
name|E1000_TXD_CMD_VLE
argument_list|)
expr_stmt|;
block|}
name|tx_buffer
operator|->
name|m_head
operator|=
name|m_head
expr_stmt|;
name|tx_buffer_mapped
operator|->
name|map
operator|=
name|tx_buffer
operator|->
name|map
expr_stmt|;
name|tx_buffer
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|adapter
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/*          * Last Descriptor of Packet 	 * needs End Of Packet (EOP) 	 * and Report Status (RS)          */
name|ctxd
operator|->
name|lower
operator|.
name|data
operator||=
name|htole32
argument_list|(
name|E1000_TXD_CMD_EOP
operator||
name|E1000_TXD_CMD_RS
argument_list|)
expr_stmt|;
comment|/* 	 * Keep track in the first buffer which 	 * descriptor will be written back 	 */
name|tx_buffer
operator|=
operator|&
name|adapter
operator|->
name|tx_buffer_area
index|[
name|first
index|]
expr_stmt|;
name|tx_buffer
operator|->
name|next_eop
operator|=
name|last
expr_stmt|;
name|adapter
operator|->
name|watchdog_time
operator|=
name|ticks
expr_stmt|;
comment|/* 	 * Advance the Transmit Descriptor Tail (TDT), this tells the E1000 	 * that this frame is available to transmit. 	 */
name|bus_dmamap_sync
argument_list|(
name|adapter
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|adapter
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82547
operator|&&
name|adapter
operator|->
name|link_duplex
operator|==
name|HALF_DUPLEX
condition|)
name|em_82547_move_tail
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82547
condition|)
name|em_82547_update_fifo_head
argument_list|(
name|adapter
argument_list|,
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*********************************************************************  *  * 82547 workaround to avoid controller hang in half-duplex environment.  * The workaround is to avoid queuing a large packet that would span  * the internal Tx FIFO ring boundary. We need to reset the FIFO pointers  * in this case. We do that only when FIFO is quiescent.  *  **********************************************************************/
specifier|static
name|void
name|em_82547_move_tail
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|e1000_tx_desc
modifier|*
name|tx_desc
decl_stmt|;
name|u16
name|hw_tdt
decl_stmt|,
name|sw_tdt
decl_stmt|,
name|length
init|=
literal|0
decl_stmt|;
name|bool
name|eop
init|=
literal|0
decl_stmt|;
name|EM_TX_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|hw_tdt
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sw_tdt
operator|=
name|adapter
operator|->
name|next_avail_tx_desc
expr_stmt|;
while|while
condition|(
name|hw_tdt
operator|!=
name|sw_tdt
condition|)
block|{
name|tx_desc
operator|=
operator|&
name|adapter
operator|->
name|tx_desc_base
index|[
name|hw_tdt
index|]
expr_stmt|;
name|length
operator|+=
name|tx_desc
operator|->
name|lower
operator|.
name|flags
operator|.
name|length
expr_stmt|;
name|eop
operator|=
name|tx_desc
operator|->
name|lower
operator|.
name|data
operator|&
name|E1000_TXD_CMD_EOP
expr_stmt|;
if|if
condition|(
operator|++
name|hw_tdt
operator|==
name|adapter
operator|->
name|num_tx_desc
condition|)
name|hw_tdt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eop
condition|)
block|{
if|if
condition|(
name|em_82547_fifo_workaround
argument_list|(
name|adapter
argument_list|,
name|length
argument_list|)
condition|)
block|{
name|adapter
operator|->
name|tx_fifo_wrk_cnt
operator|++
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|tx_fifo_timer
argument_list|,
literal|1
argument_list|,
name|em_82547_move_tail
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
break|break;
block|}
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|hw_tdt
argument_list|)
expr_stmt|;
name|em_82547_update_fifo_head
argument_list|(
name|adapter
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
specifier|static
name|int
name|em_82547_fifo_workaround
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|fifo_space
decl_stmt|,
name|fifo_pkt_len
decl_stmt|;
name|fifo_pkt_len
operator|=
name|roundup2
argument_list|(
name|len
operator|+
name|EM_FIFO_HDR
argument_list|,
name|EM_FIFO_HDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|link_duplex
operator|==
name|HALF_DUPLEX
condition|)
block|{
name|fifo_space
operator|=
name|adapter
operator|->
name|tx_fifo_size
operator|-
name|adapter
operator|->
name|tx_fifo_head
expr_stmt|;
if|if
condition|(
name|fifo_pkt_len
operator|>=
operator|(
name|EM_82547_PKT_THRESH
operator|+
name|fifo_space
operator|)
condition|)
block|{
if|if
condition|(
name|em_82547_tx_fifo_reset
argument_list|(
name|adapter
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|em_82547_update_fifo_head
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|fifo_pkt_len
init|=
name|roundup2
argument_list|(
name|len
operator|+
name|EM_FIFO_HDR
argument_list|,
name|EM_FIFO_HDR
argument_list|)
decl_stmt|;
comment|/* tx_fifo_head is always 16 byte aligned */
name|adapter
operator|->
name|tx_fifo_head
operator|+=
name|fifo_pkt_len
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|tx_fifo_head
operator|>=
name|adapter
operator|->
name|tx_fifo_size
condition|)
block|{
name|adapter
operator|->
name|tx_fifo_head
operator|-=
name|adapter
operator|->
name|tx_fifo_size
expr_stmt|;
block|}
block|}
specifier|static
name|int
name|em_82547_tx_fifo_reset
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|tctl
decl_stmt|;
if|if
condition|(
operator|(
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|==
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDH
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDFT
argument_list|)
operator|==
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDFH
argument_list|)
operator|)
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDFTS
argument_list|)
operator|==
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDFHS
argument_list|)
operator|)
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDFPC
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Disable TX unit */
name|tctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TCTL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|tctl
operator|&
operator|~
name|E1000_TCTL_EN
argument_list|)
expr_stmt|;
comment|/* Reset FIFO pointers */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDFT
argument_list|,
name|adapter
operator|->
name|tx_head_addr
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDFH
argument_list|,
name|adapter
operator|->
name|tx_head_addr
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDFTS
argument_list|,
name|adapter
operator|->
name|tx_head_addr
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDFHS
argument_list|,
name|adapter
operator|->
name|tx_head_addr
argument_list|)
expr_stmt|;
comment|/* Re-enable TX unit */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|tctl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tx_fifo_head
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|tx_fifo_reset_cnt
operator|++
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
specifier|static
name|void
name|em_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|u32
name|reg_rctl
decl_stmt|;
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|reg_rctl
operator||=
operator|(
name|E1000_RCTL_UPE
operator||
name|E1000_RCTL_MPE
operator|)
expr_stmt|;
comment|/* Turn this on if you want to see bad packets */
if|if
condition|(
name|em_debug_sbp
condition|)
name|reg_rctl
operator||=
name|E1000_RCTL_SBP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|reg_rctl
operator||=
name|E1000_RCTL_MPE
expr_stmt|;
name|reg_rctl
operator|&=
operator|~
name|E1000_RCTL_UPE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|em_disable_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|reg_rctl
decl_stmt|;
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|(
operator|~
name|E1000_RCTL_UPE
operator|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|(
operator|~
name|E1000_RCTL_MPE
operator|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|(
operator|~
name|E1000_RCTL_SBP
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  Multicast Update  *  *  This routine is called whenever multicast address list is updated.  *  **********************************************************************/
specifier|static
name|void
name|em_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|u32
name|reg_rctl
init|=
literal|0
decl_stmt|;
name|u8
modifier|*
name|mta
decl_stmt|;
comment|/* Multicast array memory */
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"em_set_multi: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82542
operator|&&
name|adapter
operator|->
name|hw
operator|.
name|revision_id
operator|==
name|E1000_REVISION_2
condition|)
block|{
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
name|e1000_pci_clear_mwi
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|reg_rctl
operator||=
name|E1000_RCTL_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate temporary memory to setup array */
name|mta
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
operator|*
operator|(
name|ETH_ADDR_LEN
operator|*
name|MAX_NUM_MULTICAST_ADDRESSES
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mta
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"em_set_multi memory failure\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|mcnt
operator|==
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
break|break;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|&
name|mta
index|[
name|mcnt
operator|*
name|ETH_ADDR_LEN
index|]
argument_list|,
name|ETH_ADDR_LEN
argument_list|)
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mcnt
operator|>=
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
block|{
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|reg_rctl
operator||=
name|E1000_RCTL_MPE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
else|else
name|e1000_update_mc_addr_list
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|mta
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82542
operator|&&
name|adapter
operator|->
name|hw
operator|.
name|revision_id
operator|==
name|E1000_REVISION_2
condition|)
block|{
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|reg_rctl
operator|&=
operator|~
name|E1000_RCTL_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|pci_cmd_word
operator|&
name|CMD_MEM_WRT_INVALIDATE
condition|)
name|e1000_pci_set_mwi
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mta
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  Timer routine  *  *  This routine checks for link status and updates statistics.  *  **********************************************************************/
specifier|static
name|void
name|em_local_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|EM_CORE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEVICE_POLLING
name|taskqueue_enqueue
argument_list|(
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|rxtx_task
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|em_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Reset LAA into RAR[0] on 82571 */
if|if
condition|(
name|e1000_get_laa_state_82571
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
operator|==
name|TRUE
condition|)
name|e1000_rar_set
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|em_display_debug_stats
operator|&&
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|em_print_hw_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|em_smartspeed
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	 * We check the watchdog: the time since 	 * the last TX descriptor was cleaned. 	 * This implies a functional TX engine. 	 */
if|if
condition|(
operator|(
name|adapter
operator|->
name|watchdog_check
operator|==
name|TRUE
operator|)
operator|&&
operator|(
name|ticks
operator|-
name|adapter
operator|->
name|watchdog_time
operator|>
name|EM_WATCHDOG
operator|)
condition|)
goto|goto
name|hung
goto|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|em_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
return|return;
name|hung
label|:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Watchdog timeout -- resetting\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|adapter
operator|->
name|watchdog_events
operator|++
expr_stmt|;
name|em_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|em_update_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|u32
name|link_check
init|=
literal|0
decl_stmt|;
comment|/* Get the cached link value or read phy for real */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
condition|)
block|{
case|case
name|e1000_media_type_copper
case|:
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|get_link_status
condition|)
block|{
comment|/* Do the work to read phy */
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|link_check
operator|=
operator|!
name|hw
operator|->
name|mac
operator|.
name|get_link_status
expr_stmt|;
if|if
condition|(
name|link_check
condition|)
comment|/* ESB2 fix */
name|e1000_cfg_on_link_up
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
name|link_check
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|e1000_media_type_fiber
case|:
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|link_check
operator|=
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_LU
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_media_type_internal_serdes
case|:
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|link_check
operator|=
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|serdes_has_link
expr_stmt|;
break|break;
default|default:
case|case
name|e1000_media_type_unknown
case|:
break|break;
block|}
comment|/* Now check for a transition */
if|if
condition|(
name|link_check
operator|&&
operator|(
name|adapter
operator|->
name|link_active
operator|==
literal|0
operator|)
condition|)
block|{
name|e1000_get_speed_and_duplex
argument_list|(
name|hw
argument_list|,
operator|&
name|adapter
operator|->
name|link_speed
argument_list|,
operator|&
name|adapter
operator|->
name|link_duplex
argument_list|)
expr_stmt|;
comment|/* Check if we must disable SPEED_MODE bit on PCI-E */
if|if
condition|(
operator|(
name|adapter
operator|->
name|link_speed
operator|!=
name|SPEED_1000
operator|)
operator|&&
operator|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82571
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82572
operator|)
operator|)
condition|)
block|{
name|int
name|tarc0
decl_stmt|;
name|tarc0
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tarc0
operator|&=
operator|~
name|SPEED_MODE_BIT
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|tarc0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is up %d Mbps %s\n"
argument_list|,
name|adapter
operator|->
name|link_speed
argument_list|,
operator|(
operator|(
name|adapter
operator|->
name|link_duplex
operator|==
name|FULL_DUPLEX
operator|)
condition|?
literal|"Full Duplex"
else|:
literal|"Half Duplex"
operator|)
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
literal|1
expr_stmt|;
name|adapter
operator|->
name|smartspeed
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
name|adapter
operator|->
name|link_speed
operator|*
literal|1000000
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|link_check
operator|&&
operator|(
name|adapter
operator|->
name|link_active
operator|==
literal|1
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_baudrate
operator|=
name|adapter
operator|->
name|link_speed
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|link_duplex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is Down\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
literal|0
expr_stmt|;
comment|/* Link down, disable watchdog */
name|adapter
operator|->
name|watchdog_check
operator|=
name|FALSE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*********************************************************************  *  *  This routine disables all traffic on the adapter by issuing a  *  global reset on the MAC and deallocates TX/RX buffers.  *  *  This routine should always be called with BOTH the CORE  *  and TX locks.  **********************************************************************/
specifier|static
name|void
name|em_stop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|EM_CORE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|EM_TX_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"em_stop: begin"
argument_list|)
expr_stmt|;
name|em_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|tx_fifo_timer
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is no longer active */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|e1000_reset_hw
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82544
condition|)
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  *  Determine hardware revision.  *  **********************************************************************/
specifier|static
name|void
name|em_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
comment|/* Make sure our PCI config space has the necessary stuff set */
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|pci_cmd_word
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|pci_cmd_word
operator|&
name|PCIM_CMD_BUSMASTEREN
operator|)
operator|&&
operator|(
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|pci_cmd_word
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Memory Access and/or Bus Master bits "
literal|"were not set!\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|pci_cmd_word
operator||=
operator|(
name|PCIM_CMD_BUSMASTEREN
operator||
name|PCIM_CMD_MEMEN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|pci_cmd_word
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Save off the information about this board */
name|adapter
operator|->
name|hw
operator|.
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|revision_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|subsystem_vendor_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|subsystem_device_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Do Shared Code Init and Setup */
if|if
condition|(
name|e1000_set_mac_type
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Setup init failure\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
specifier|static
name|int
name|em_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|val
decl_stmt|,
name|rid
decl_stmt|,
name|error
init|=
name|E1000_SUCCESS
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|memory
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|memory
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|memory
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|memory
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|hw_addr
operator|=
operator|(
name|u8
operator|*
operator|)
operator|&
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
expr_stmt|;
comment|/* Only older adapters use IO mapping */
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>
name|e1000_82543
operator|)
operator|&&
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|<
name|e1000_82571
operator|)
condition|)
block|{
comment|/* Figure our where our IO BAR is ? */
for|for
control|(
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
init|;
name|rid
operator|<
name|PCIR_CIS
condition|;
control|)
block|{
name|val
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|EM_BAR_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|EM_BAR_TYPE_IO
condition|)
block|{
name|adapter
operator|->
name|io_rid
operator|=
name|rid
expr_stmt|;
break|break;
block|}
name|rid
operator|+=
literal|4
expr_stmt|;
comment|/* check for 64bit BAR */
if|if
condition|(
name|EM_BAR_MEM_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|EM_BAR_MEM_TYPE_64BIT
condition|)
name|rid
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|rid
operator|>=
name|PCIR_CIS
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to locate IO BAR\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|->
name|ioport
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|adapter
operator|->
name|io_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|ioport
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: "
literal|"ioport\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|->
name|hw
operator|.
name|io_base
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|io_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|ioport
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|io_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|ioport
argument_list|)
expr_stmt|;
block|}
comment|/* 	** Init the resource arrays 	**  used by MSIX setup  	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|adapter
operator|->
name|rid
index|[
name|i
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* MSI/X RID starts at 1 */
name|adapter
operator|->
name|tag
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|adapter
operator|->
name|res
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Setup MSI/X or MSI if PCI Express 	 */
if|if
condition|(
name|em_enable_msi
condition|)
name|adapter
operator|->
name|msi
operator|=
name|em_setup_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|back
operator|=
operator|&
name|adapter
operator|->
name|osdep
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Setup the Legacy or MSI Interrupt handler  *  **********************************************************************/
name|int
name|em_allocate_legacy
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Manually turn off all interrupts */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Legacy RID is 0 */
if|if
condition|(
name|adapter
operator|->
name|msi
operator|==
literal|0
condition|)
name|adapter
operator|->
name|rid
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* We allocate a single interrupt resource */
name|adapter
operator|->
name|res
index|[
literal|0
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|adapter
operator|->
name|rid
index|[
literal|0
index|]
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|res
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: "
literal|"interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|EM_LEGACY_IRQ
comment|/* We do Legacy setup */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|700000
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|em_intr
argument_list|,
name|adapter
argument_list|,
else|#
directive|else
comment|/* 6.X */
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|em_intr
argument_list|,
name|adapter
argument_list|,
endif|#
directive|endif
operator|&
name|adapter
operator|->
name|tag
index|[
literal|0
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register interrupt handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|#
directive|else
comment|/* FAST_IRQ */
comment|/* 	 * Try allocating a fast interrupt and the associated deferred 	 * processing contexts. 	 */
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|rxtx_task
argument_list|,
literal|0
argument_list|,
name|em_handle_rxtx
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|link_task
argument_list|,
literal|0
argument_list|,
name|em_handle_link
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"em_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|adapter
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|adapter
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
argument|dev
argument_list|,
argument|adapter->res[
literal|0
argument|]
argument_list|,
argument|INTR_TYPE_NET | INTR_FAST
argument_list|,
argument|em_irq_fast
argument_list|,
argument|adapter
argument_list|,
else|#
directive|else
argument|if ((error = bus_setup_intr(dev, adapter->res[
literal|0
argument|], 	    INTR_TYPE_NET, em_irq_fast, NULL, adapter,
endif|#
directive|endif
argument|&adapter->tag[
literal|0
argument|])) !=
literal|0
argument|) { 		device_printf(dev,
literal|"Failed to register fast interrupt "
literal|"handler: %d\n"
argument|, error); 		taskqueue_free(adapter->tq); 		adapter->tq = NULL; 		return (error); 	}
endif|#
directive|endif
comment|/* EM_LEGACY_IRQ */
argument|return (
literal|0
argument|); }
comment|/*********************************************************************  *  *  Setup the MSIX Interrupt handlers  *   This is not really Multiqueue, rather  *   its just multiple interrupt vectors.  *  **********************************************************************/
argument|int em_allocate_msix(struct adapter *adapter) { 	device_t dev = adapter->dev; 	int error;
comment|/* Make sure all interrupts are disabled */
argument|E1000_WRITE_REG(&adapter->hw, E1000_IMC,
literal|0xffffffff
argument|);
comment|/* First get the resources */
argument|for (int i =
literal|0
argument|; i< adapter->msi; i++) { 		adapter->res[i] = bus_alloc_resource_any(dev, 		    SYS_RES_IRQ,&adapter->rid[i], RF_ACTIVE); 		if (adapter->res[i] == NULL) { 			device_printf(dev,
literal|"Unable to allocate bus resource: "
literal|"MSIX Interrupt\n"
argument|); 			return (ENXIO); 		} 	}
comment|/* 	 * Now allocate deferred processing contexts. 	 */
argument|TASK_INIT(&adapter->rx_task,
literal|0
argument|, em_handle_rx, adapter); 	TASK_INIT(&adapter->tx_task,
literal|0
argument|, em_handle_tx, adapter);
comment|/* 	 * Handle compatibility for msi case for deferral due to 	 * trylock failure 	 */
argument|TASK_INIT(&adapter->rxtx_task,
literal|0
argument|, em_handle_tx, adapter); 	TASK_INIT(&adapter->link_task,
literal|0
argument|, em_handle_link, adapter); 	adapter->tq = taskqueue_create_fast(
literal|"em_taskq"
argument|, M_NOWAIT, 	    taskqueue_thread_enqueue,&adapter->tq); 	taskqueue_start_threads(&adapter->tq,
literal|1
argument|, PI_NET,
literal|"%s taskq"
argument|, 	    device_get_nameunit(adapter->dev));
comment|/* 	 * And setup the interrupt handlers 	 */
comment|/* First slot to RX */
argument|if ((error = bus_setup_intr(dev, adapter->res[
literal|0
argument|],
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|700000
argument|INTR_TYPE_NET | INTR_MPSAFE, NULL, em_msix_rx, adapter,
else|#
directive|else
comment|/* 6.X */
argument|INTR_TYPE_NET | INTR_MPSAFE, em_msix_rx, adapter,
endif|#
directive|endif
argument|&adapter->tag[
literal|0
argument|])) !=
literal|0
argument|) { 		device_printf(dev,
literal|"Failed to register RX handler"
argument|); 		return (error); 	}
comment|/* Next TX */
argument|if ((error = bus_setup_intr(dev, adapter->res[
literal|1
argument|],
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|700000
argument|INTR_TYPE_NET | INTR_MPSAFE, NULL, em_msix_tx, adapter,
else|#
directive|else
comment|/* 6.X */
argument|INTR_TYPE_NET | INTR_MPSAFE, em_msix_tx, adapter,
endif|#
directive|endif
argument|&adapter->tag[
literal|1
argument|])) !=
literal|0
argument|) { 		device_printf(dev,
literal|"Failed to register TX handler"
argument|); 		return (error); 	}
comment|/* And Link */
argument|if ((error = bus_setup_intr(dev, adapter->res[
literal|2
argument|],
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|700000
argument|INTR_TYPE_NET | INTR_MPSAFE, NULL, em_msix_link, adapter,
else|#
directive|else
comment|/* 6.X */
argument|INTR_TYPE_NET | INTR_MPSAFE, em_msix_link, adapter,
endif|#
directive|endif
argument|&adapter->tag[
literal|2
argument|])) !=
literal|0
argument|) { 		device_printf(dev,
literal|"Failed to register TX handler"
argument|); 		return (error); 	}  	return (
literal|0
argument|); }   static void em_free_pci_resources(struct adapter *adapter) { 	device_t dev = adapter->dev;
comment|/* Make sure the for loop below runs once */
argument|if (adapter->msi ==
literal|0
argument|) 		adapter->msi =
literal|1
argument|;
comment|/* 	 * First release all the interrupt resources: 	 *      notice that since these are just kept 	 *      in an array we can do the same logic 	 *      whether its MSIX or just legacy. 	 */
argument|for (int i =
literal|0
argument|; i< adapter->msi; i++) { 		if (adapter->tag[i] != NULL) { 			bus_teardown_intr(dev, adapter->res[i], 			    adapter->tag[i]); 			adapter->tag[i] = NULL; 		} 		if (adapter->res[i] != NULL) { 			bus_release_resource(dev, SYS_RES_IRQ, 			    adapter->rid[i], adapter->res[i]); 		} 	}  	if (adapter->msi) 		pci_release_msi(dev);  	if (adapter->msix != NULL) 		bus_release_resource(dev, SYS_RES_MEMORY, 		    PCIR_BAR(EM_MSIX_BAR), adapter->msix);  	if (adapter->memory != NULL) 		bus_release_resource(dev, SYS_RES_MEMORY, 		    PCIR_BAR(
literal|0
argument|), adapter->memory);  	if (adapter->flash != NULL) 		bus_release_resource(dev, SYS_RES_MEMORY, 		    EM_FLASH, adapter->flash);  	if (adapter->ioport != NULL) 		bus_release_resource(dev, SYS_RES_IOPORT, 		    adapter->io_rid, adapter->ioport); }
comment|/*  * Setup MSI or MSI/X  */
argument|static int em_setup_msix(struct adapter *adapter) { 	device_t dev = adapter->dev; 	int val =
literal|0
argument|;  	if (adapter->hw.mac.type< e1000_82571) 		return (
literal|0
argument|);
comment|/* Setup MSI/X for Hartwell */
argument|if (adapter->hw.mac.type == e1000_82574) {
comment|/* Map the MSIX BAR */
argument|int rid = PCIR_BAR(EM_MSIX_BAR); 		adapter->msix = bus_alloc_resource_any(dev, 		    SYS_RES_MEMORY,&rid, RF_ACTIVE);        		if (!adapter->msix) {
comment|/* May not be enabled */
argument|device_printf(adapter->dev,
literal|"Unable to map MSIX table \n"
argument|); 			goto msi;        		} 		val = pci_msix_count(dev);
comment|/* 		** 82574 can be configured for 5 but 		** we limit use to 3. 		*/
argument|if (val>
literal|3
argument|) val =
literal|3
argument|; 		if ((val)&& pci_alloc_msix(dev,&val) ==
literal|0
argument|) {                		device_printf(adapter->dev,
literal|"Using MSIX interrupts\n"
argument|); 			return (val); 		} 	} msi:        	val = pci_msi_count(dev);        	if (val ==
literal|1
argument|&& pci_alloc_msi(dev,&val) ==
literal|0
argument|) {                	adapter->msi =
literal|1
argument|;                	device_printf(adapter->dev,
literal|"Using MSI interrupt\n"
argument|); 		return (val); 	}  	return (
literal|0
argument|); }
comment|/*********************************************************************  *  *  Initialize the hardware to a configuration  *  as specified by the adapter structure.  *  **********************************************************************/
argument|static int em_hardware_init(struct adapter *adapter) { 	device_t dev = adapter->dev; 	u16 	rx_buffer_size;  	INIT_DEBUGOUT(
literal|"em_hardware_init: begin"
argument|);
comment|/* Issue a global reset */
argument|e1000_reset_hw(&adapter->hw);
comment|/* When hardware is reset, fifo_head is also reset */
argument|adapter->tx_fifo_head =
literal|0
argument|;
comment|/* Set up smart power down as default off on newer adapters. */
argument|if (!em_smart_pwr_down&& (adapter->hw.mac.type == e1000_82571 || 	    adapter->hw.mac.type == e1000_82572)) { 		u16 phy_tmp =
literal|0
argument|;
comment|/* Speed up time to link by disabling smart power down. */
argument|e1000_read_phy_reg(&adapter->hw, 		    IGP02E1000_PHY_POWER_MGMT,&phy_tmp); 		phy_tmp&= ~IGP02E1000_PM_SPD; 		e1000_write_phy_reg(&adapter->hw, 		    IGP02E1000_PHY_POWER_MGMT, phy_tmp); 	}
comment|/* 	 * These parameters control the automatic generation (Tx) and 	 * response (Rx) to Ethernet PAUSE frames. 	 * - High water mark should allow for at least two frames to be 	 *   received after sending an XOFF. 	 * - Low water mark works best when it is very near the high water mark. 	 *   This allows the receiver to restart by sending XON when it has 	 *   drained a bit. Here we use an arbitary value of 1500 which will 	 *   restart after one full frame is pulled from the buffer. There 	 *   could be several smaller frames in the buffer and if so they will 	 *   not trigger the XON until their total number reduces the buffer 	 *   by 1500. 	 * - The pause time is fairly large at 1000 x 512ns = 512 usec. 	 */
argument|rx_buffer_size = ((E1000_READ_REG(&adapter->hw, E1000_PBA)&
literal|0xffff
argument|)<<
literal|10
argument|);  	adapter->hw.fc.high_water = rx_buffer_size - 	    roundup2(adapter->max_frame_size,
literal|1024
argument|); 	adapter->hw.fc.low_water = adapter->hw.fc.high_water -
literal|1500
argument|;  	if (adapter->hw.mac.type == e1000_80003es2lan) 		adapter->hw.fc.pause_time =
literal|0xFFFF
argument|; 	else 		adapter->hw.fc.pause_time = EM_FC_PAUSE_TIME; 	adapter->hw.fc.send_xon = TRUE;
comment|/* Set Flow control, use the tunable location if sane */
argument|if ((em_fc_setting>=
literal|0
argument|) || (em_fc_setting<
literal|4
argument|))                 adapter->hw.fc.requested_mode = em_fc_setting;         else                 adapter->hw.fc.requested_mode = e1000_fc_none;
comment|/* Override - workaround for PCHLAN issue */
argument|if (adapter->hw.mac.type == e1000_pchlan)                 adapter->hw.fc.requested_mode = e1000_fc_rx_pause;  	if (e1000_init_hw(&adapter->hw)<
literal|0
argument|) { 		device_printf(dev,
literal|"Hardware Initialization Failed\n"
argument|); 		return (EIO); 	}  	e1000_check_for_link(&adapter->hw);  	return (
literal|0
argument|); }
comment|/*********************************************************************  *  *  Setup networking device structure and register an interface.  *  **********************************************************************/
argument|static void em_setup_interface(device_t dev, struct adapter *adapter) { 	struct ifnet   *ifp;  	INIT_DEBUGOUT(
literal|"em_setup_interface: begin"
argument|);  	ifp = adapter->ifp = if_alloc(IFT_ETHER); 	if (ifp == NULL) 		panic(
literal|"%s: can not if_alloc()"
argument|, device_get_nameunit(dev)); 	if_initname(ifp, device_get_name(dev), device_get_unit(dev)); 	ifp->if_mtu = ETHERMTU; 	ifp->if_init =  em_init; 	ifp->if_softc = adapter; 	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST; 	ifp->if_ioctl = em_ioctl; 	ifp->if_start = em_start; 	IFQ_SET_MAXLEN(&ifp->if_snd, adapter->num_tx_desc -
literal|1
argument|); 	ifp->if_snd.ifq_drv_maxlen = adapter->num_tx_desc -
literal|1
argument|; 	IFQ_SET_READY(&ifp->if_snd);  	ether_ifattach(ifp, adapter->hw.mac.addr);  	ifp->if_capabilities = ifp->if_capenable =
literal|0
argument|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
comment|/* Multiqueue tx functions */
argument|ifp->if_transmit = em_mq_start; 	ifp->if_qflush = em_qflush; 	adapter->br = buf_ring_alloc(
literal|4096
argument|, M_DEVBUF, M_WAITOK,&adapter->tx_mtx);
endif|#
directive|endif
argument|if (adapter->hw.mac.type>= e1000_82543) { 		int version_cap;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
argument|version_cap = IFCAP_HWCSUM;
else|#
directive|else
argument|version_cap = IFCAP_HWCSUM | IFCAP_VLAN_HWCSUM;
endif|#
directive|endif
argument|ifp->if_capabilities |= version_cap; 		ifp->if_capenable |= version_cap; 	}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
comment|/* Identify TSO capable adapters */
argument|if ((adapter->hw.mac.type> e1000_82544)&& 	    (adapter->hw.mac.type != e1000_82547)) 		ifp->if_capabilities |= IFCAP_TSO4;
comment|/* 	 * By default only enable on PCI-E, this 	 * can be overriden by ifconfig. 	 */
argument|if (adapter->hw.mac.type>= e1000_82571) 		ifp->if_capenable |= IFCAP_TSO4;
endif|#
directive|endif
comment|/* 	 * Tell the upper layer(s) we 	 * support full VLAN capability 	 */
argument|ifp->if_data.ifi_hdrlen = sizeof(struct ether_vlan_header); 	ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU; 	ifp->if_capenable |= (IFCAP_VLAN_MTU | IFCAP_VLAN_HWTAGGING);
comment|/* 	** Dont turn this on by default, if vlans are 	** created on another pseudo device (eg. lagg) 	** then vlan events are not passed thru, breaking 	** operation, but with HW FILTER off it works. If 	** using vlans directly on the em driver you can 	** enable this and get full hardware tag filtering.  	*/
argument|ifp->if_capabilities |= IFCAP_VLAN_HWFILTER;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
argument|ifp->if_capabilities |= IFCAP_POLLING;
endif|#
directive|endif
comment|/* Limit WOL to MAGIC, not clear others are used */
argument|if (adapter->wol) { 		ifp->if_capabilities |= IFCAP_WOL_MAGIC; 		ifp->if_capenable |= IFCAP_WOL_MAGIC; 	}
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
argument|ifmedia_init(&adapter->media, IFM_IMASK, 	    em_media_change, em_media_status); 	if ((adapter->hw.phy.media_type == e1000_media_type_fiber) || 	    (adapter->hw.phy.media_type == e1000_media_type_internal_serdes)) { 		u_char fiber_type = IFM_1000_SX;
comment|/* default type */
argument|if (adapter->hw.mac.type == e1000_82545) 			fiber_type = IFM_1000_LX; 		ifmedia_add(&adapter->media, IFM_ETHER | fiber_type | IFM_FDX,
literal|0
argument|, NULL); 		ifmedia_add(&adapter->media, IFM_ETHER | fiber_type,
literal|0
argument|, NULL); 	} else { 		ifmedia_add(&adapter->media, IFM_ETHER | IFM_10_T,
literal|0
argument|, NULL); 		ifmedia_add(&adapter->media, IFM_ETHER | IFM_10_T | IFM_FDX,
literal|0
argument|, NULL); 		ifmedia_add(&adapter->media, IFM_ETHER | IFM_100_TX,
literal|0
argument|, NULL); 		ifmedia_add(&adapter->media, IFM_ETHER | IFM_100_TX | IFM_FDX,
literal|0
argument|, NULL); 		if (adapter->hw.phy.type != e1000_phy_ife) { 			ifmedia_add(&adapter->media, 				IFM_ETHER | IFM_1000_T | IFM_FDX,
literal|0
argument|, NULL); 			ifmedia_add(&adapter->media, 				IFM_ETHER | IFM_1000_T,
literal|0
argument|, NULL); 		} 	} 	ifmedia_add(&adapter->media, IFM_ETHER | IFM_AUTO,
literal|0
argument|, NULL); 	ifmedia_set(&adapter->media, IFM_ETHER | IFM_AUTO); }
comment|/*********************************************************************  *  *  Workaround for SmartSpeed on 82541 and 82547 controllers  *  **********************************************************************/
argument|static void em_smartspeed(struct adapter *adapter) { 	u16 phy_tmp;  	if (adapter->link_active || (adapter->hw.phy.type != e1000_phy_igp) || 	    adapter->hw.mac.autoneg ==
literal|0
argument||| 	    (adapter->hw.phy.autoneg_advertised& ADVERTISE_1000_FULL) ==
literal|0
argument|) 		return;  	if (adapter->smartspeed ==
literal|0
argument|) {
comment|/* If Master/Slave config fault is asserted twice, 		 * we assume back-to-back */
argument|e1000_read_phy_reg(&adapter->hw, PHY_1000T_STATUS,&phy_tmp); 		if (!(phy_tmp& SR_1000T_MS_CONFIG_FAULT)) 			return; 		e1000_read_phy_reg(&adapter->hw, PHY_1000T_STATUS,&phy_tmp); 		if (phy_tmp& SR_1000T_MS_CONFIG_FAULT) { 			e1000_read_phy_reg(&adapter->hw, 			    PHY_1000T_CTRL,&phy_tmp); 			if(phy_tmp& CR_1000T_MS_ENABLE) { 				phy_tmp&= ~CR_1000T_MS_ENABLE; 				e1000_write_phy_reg(&adapter->hw, 				    PHY_1000T_CTRL, phy_tmp); 				adapter->smartspeed++; 				if(adapter->hw.mac.autoneg&& 				   !e1000_copper_link_autoneg(&adapter->hw)&& 				   !e1000_read_phy_reg(&adapter->hw, 				    PHY_CONTROL,&phy_tmp)) { 					phy_tmp |= (MII_CR_AUTO_NEG_EN | 						    MII_CR_RESTART_AUTO_NEG); 					e1000_write_phy_reg(&adapter->hw, 					    PHY_CONTROL, phy_tmp); 				} 			} 		} 		return; 	} else if(adapter->smartspeed == EM_SMARTSPEED_DOWNSHIFT) {
comment|/* If still no link, perhaps using 2/3 pair cable */
argument|e1000_read_phy_reg(&adapter->hw, PHY_1000T_CTRL,&phy_tmp); 		phy_tmp |= CR_1000T_MS_ENABLE; 		e1000_write_phy_reg(&adapter->hw, PHY_1000T_CTRL, phy_tmp); 		if(adapter->hw.mac.autoneg&& 		   !e1000_copper_link_autoneg(&adapter->hw)&& 		   !e1000_read_phy_reg(&adapter->hw, PHY_CONTROL,&phy_tmp)) { 			phy_tmp |= (MII_CR_AUTO_NEG_EN | 				    MII_CR_RESTART_AUTO_NEG); 			e1000_write_phy_reg(&adapter->hw, PHY_CONTROL, phy_tmp); 		} 	}
comment|/* Restart process after EM_SMARTSPEED_MAX iterations */
argument|if(adapter->smartspeed++ == EM_SMARTSPEED_MAX) 		adapter->smartspeed =
literal|0
argument|; }
comment|/*  * Manage DMA'able memory.  */
argument|static void em_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error) { 	if (error) 		return; 	*(bus_addr_t *) arg = segs[
literal|0
argument|].ds_addr; }  static int em_dma_malloc(struct adapter *adapter, bus_size_t size,         struct em_dma_alloc *dma, int mapflags) { 	int error;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
argument|error = bus_dma_tag_create(bus_get_dma_tag(adapter->dev),
comment|/* parent */
else|#
directive|else
argument|error = bus_dma_tag_create(NULL,
comment|/* parent */
endif|#
directive|endif
argument|EM_DBA_ALIGN,
literal|0
argument|,
comment|/* alignment, bounds */
argument|BUS_SPACE_MAXADDR,
comment|/* lowaddr */
argument|BUS_SPACE_MAXADDR,
comment|/* highaddr */
argument|NULL, NULL,
comment|/* filter, filterarg */
argument|size,
comment|/* maxsize */
literal|1
argument|,
comment|/* nsegments */
argument|size,
comment|/* maxsegsize */
literal|0
argument|,
comment|/* flags */
argument|NULL,
comment|/* lockfunc */
argument|NULL,
comment|/* lockarg */
argument|&dma->dma_tag); 	if (error) { 		device_printf(adapter->dev,
literal|"%s: bus_dma_tag_create failed: %d\n"
argument|, 		    __func__, error); 		goto fail_0; 	}  	error = bus_dmamem_alloc(dma->dma_tag, (void**)&dma->dma_vaddr, 	    BUS_DMA_NOWAIT | BUS_DMA_COHERENT,&dma->dma_map); 	if (error) { 		device_printf(adapter->dev,
literal|"%s: bus_dmamem_alloc(%ju) failed: %d\n"
argument|, 		    __func__, (uintmax_t)size, error); 		goto fail_2; 	}  	dma->dma_paddr =
literal|0
argument|; 	error = bus_dmamap_load(dma->dma_tag, dma->dma_map, dma->dma_vaddr, 	    size, em_dmamap_cb,&dma->dma_paddr, mapflags | BUS_DMA_NOWAIT); 	if (error || dma->dma_paddr ==
literal|0
argument|) { 		device_printf(adapter->dev,
literal|"%s: bus_dmamap_load failed: %d\n"
argument|, 		    __func__, error); 		goto fail_3; 	}  	return (
literal|0
argument|);  fail_3: 	bus_dmamap_unload(dma->dma_tag, dma->dma_map); fail_2: 	bus_dmamem_free(dma->dma_tag, dma->dma_vaddr, dma->dma_map); 	bus_dma_tag_destroy(dma->dma_tag); fail_0: 	dma->dma_map = NULL; 	dma->dma_tag = NULL;  	return (error); }  static void em_dma_free(struct adapter *adapter, struct em_dma_alloc *dma) { 	if (dma->dma_tag == NULL) 		return; 	if (dma->dma_map != NULL) { 		bus_dmamap_sync(dma->dma_tag, dma->dma_map, 		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE); 		bus_dmamap_unload(dma->dma_tag, dma->dma_map); 		bus_dmamem_free(dma->dma_tag, dma->dma_vaddr, dma->dma_map); 		dma->dma_map = NULL; 	} 	bus_dma_tag_destroy(dma->dma_tag); 	dma->dma_tag = NULL; }
comment|/*********************************************************************  *  *  Allocate memory for tx_buffer structures. The tx_buffer stores all  *  the information needed to transmit a packet on the wire.  *  **********************************************************************/
argument|static int em_allocate_transmit_structures(struct adapter *adapter) { 	device_t dev = adapter->dev; 	struct em_buffer *tx_buffer; 	int error;
comment|/* 	 * Create DMA tags for tx descriptors 	 */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
argument|if ((error = bus_dma_tag_create(bus_get_dma_tag(dev),
comment|/* parent */
else|#
directive|else
argument|if ((error = bus_dma_tag_create(NULL,
comment|/* parent */
endif|#
directive|endif
literal|1
argument|,
literal|0
argument|,
comment|/* alignment, bounds */
argument|BUS_SPACE_MAXADDR,
comment|/* lowaddr */
argument|BUS_SPACE_MAXADDR,
comment|/* highaddr */
argument|NULL, NULL,
comment|/* filter, filterarg */
argument|EM_TSO_SIZE,
comment|/* maxsize */
argument|EM_MAX_SCATTER,
comment|/* nsegments */
argument|EM_TSO_SEG_SIZE,
comment|/* maxsegsize */
literal|0
argument|,
comment|/* flags */
argument|NULL,
comment|/* lockfunc */
argument|NULL,
comment|/* lockarg */
argument|&adapter->txtag)) !=
literal|0
argument|) { 		device_printf(dev,
literal|"Unable to allocate TX DMA tag\n"
argument|); 		goto fail; 	}  	adapter->tx_buffer_area = malloc(sizeof(struct em_buffer) * 	    adapter->num_tx_desc, M_DEVBUF, M_NOWAIT | M_ZERO); 	if (adapter->tx_buffer_area == NULL) { 		device_printf(dev,
literal|"Unable to allocate tx_buffer memory\n"
argument|); 		error = ENOMEM; 		goto fail; 	}
comment|/* Create the descriptor buffer dma maps */
argument|for (int i =
literal|0
argument|; i< adapter->num_tx_desc; i++) { 		tx_buffer =&adapter->tx_buffer_area[i]; 		error = bus_dmamap_create(adapter->txtag,
literal|0
argument|,&tx_buffer->map); 		if (error !=
literal|0
argument|) { 			device_printf(dev,
literal|"Unable to create TX DMA map\n"
argument|); 			goto fail; 		} 		tx_buffer->next_eop = -
literal|1
argument|; 	}  	return (
literal|0
argument|); fail: 	em_free_transmit_structures(adapter); 	return (error); }
comment|/*********************************************************************  *  *  (Re)Initialize transmit structures.  *  **********************************************************************/
argument|static void em_setup_transmit_structures(struct adapter *adapter) { 	struct em_buffer *tx_buffer;
comment|/* Clear the old ring contents */
argument|bzero(adapter->tx_desc_base, 	    (sizeof(struct e1000_tx_desc)) * adapter->num_tx_desc);
comment|/* Free any existing TX buffers */
argument|for (int i =
literal|0
argument|; i< adapter->num_tx_desc; i++, tx_buffer++) { 		tx_buffer =&adapter->tx_buffer_area[i]; 		bus_dmamap_sync(adapter->txtag, tx_buffer->map, 		    BUS_DMASYNC_POSTWRITE); 		bus_dmamap_unload(adapter->txtag, tx_buffer->map); 		m_freem(tx_buffer->m_head); 		tx_buffer->m_head = NULL; 		tx_buffer->next_eop = -
literal|1
argument|; 	}
comment|/* Reset state */
argument|adapter->next_avail_tx_desc =
literal|0
argument|; 	adapter->next_tx_to_clean =
literal|0
argument|; 	adapter->num_tx_desc_avail = adapter->num_tx_desc;  	bus_dmamap_sync(adapter->txdma.dma_tag, adapter->txdma.dma_map, 	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);  	return; }
comment|/*********************************************************************  *  *  Enable transmit unit.  *  **********************************************************************/
argument|static void em_initialize_transmit_unit(struct adapter *adapter) { 	u32	tctl, tarc, tipg =
literal|0
argument|; 	u64	bus_addr;  	 INIT_DEBUGOUT(
literal|"em_initialize_transmit_unit: begin"
argument|);
comment|/* Setup the Base and Length of the Tx Descriptor Ring */
argument|bus_addr = adapter->txdma.dma_paddr; 	E1000_WRITE_REG(&adapter->hw, E1000_TDLEN(
literal|0
argument|), 	    adapter->num_tx_desc * sizeof(struct e1000_tx_desc)); 	E1000_WRITE_REG(&adapter->hw, E1000_TDBAH(
literal|0
argument|), 	    (u32)(bus_addr>>
literal|32
argument|)); 	E1000_WRITE_REG(&adapter->hw, E1000_TDBAL(
literal|0
argument|), 	    (u32)bus_addr);
comment|/* Setup the HW Tx Head and Tail descriptor pointers */
argument|E1000_WRITE_REG(&adapter->hw, E1000_TDT(
literal|0
argument|),
literal|0
argument|); 	E1000_WRITE_REG(&adapter->hw, E1000_TDH(
literal|0
argument|),
literal|0
argument|);  	HW_DEBUGOUT2(
literal|"Base = %x, Length = %x\n"
argument|, 	    E1000_READ_REG(&adapter->hw, E1000_TDBAL(
literal|0
argument|)), 	    E1000_READ_REG(&adapter->hw, E1000_TDLEN(
literal|0
argument|)));
comment|/* Set the default values for the Tx Inter Packet Gap timer */
argument|switch (adapter->hw.mac.type) { 	case e1000_82542: 		tipg = DEFAULT_82542_TIPG_IPGT; 		tipg |= DEFAULT_82542_TIPG_IPGR1<< E1000_TIPG_IPGR1_SHIFT; 		tipg |= DEFAULT_82542_TIPG_IPGR2<< E1000_TIPG_IPGR2_SHIFT; 		break; 	case e1000_80003es2lan: 		tipg = DEFAULT_82543_TIPG_IPGR1; 		tipg |= DEFAULT_80003ES2LAN_TIPG_IPGR2<< 		    E1000_TIPG_IPGR2_SHIFT; 		break; 	default: 		if ((adapter->hw.phy.media_type == e1000_media_type_fiber) || 		    (adapter->hw.phy.media_type == 		    e1000_media_type_internal_serdes)) 			tipg = DEFAULT_82543_TIPG_IPGT_FIBER; 		else 			tipg = DEFAULT_82543_TIPG_IPGT_COPPER; 		tipg |= DEFAULT_82543_TIPG_IPGR1<< E1000_TIPG_IPGR1_SHIFT; 		tipg |= DEFAULT_82543_TIPG_IPGR2<< E1000_TIPG_IPGR2_SHIFT; 	}  	E1000_WRITE_REG(&adapter->hw, E1000_TIPG, tipg); 	E1000_WRITE_REG(&adapter->hw, E1000_TIDV, adapter->tx_int_delay.value); 	if(adapter->hw.mac.type>= e1000_82540) 		E1000_WRITE_REG(&adapter->hw, E1000_TADV, 		    adapter->tx_abs_int_delay.value);  	if ((adapter->hw.mac.type == e1000_82571) || 	    (adapter->hw.mac.type == e1000_82572)) { 		tarc = E1000_READ_REG(&adapter->hw, E1000_TARC(
literal|0
argument|)); 		tarc |= SPEED_MODE_BIT; 		E1000_WRITE_REG(&adapter->hw, E1000_TARC(
literal|0
argument|), tarc); 	} else if (adapter->hw.mac.type == e1000_80003es2lan) { 		tarc = E1000_READ_REG(&adapter->hw, E1000_TARC(
literal|0
argument|)); 		tarc |=
literal|1
argument|; 		E1000_WRITE_REG(&adapter->hw, E1000_TARC(
literal|0
argument|), tarc); 		tarc = E1000_READ_REG(&adapter->hw, E1000_TARC(
literal|1
argument|)); 		tarc |=
literal|1
argument|; 		E1000_WRITE_REG(&adapter->hw, E1000_TARC(
literal|1
argument|), tarc); 	}
comment|/* Program the Transmit Control Register */
argument|tctl = E1000_READ_REG(&adapter->hw, E1000_TCTL); 	tctl&= ~E1000_TCTL_CT; 	tctl |= (E1000_TCTL_PSP | E1000_TCTL_RTLC | E1000_TCTL_EN | 		   (E1000_COLLISION_THRESHOLD<< E1000_CT_SHIFT));  	if (adapter->hw.mac.type>= e1000_82571) 		tctl |= E1000_TCTL_MULR;
comment|/* This write will effectively turn on the transmit unit. */
argument|E1000_WRITE_REG(&adapter->hw, E1000_TCTL, tctl);
comment|/* Setup Transmit Descriptor Base Settings */
argument|adapter->txd_cmd = E1000_TXD_CMD_IFCS;  	if (adapter->tx_int_delay.value>
literal|0
argument|) 		adapter->txd_cmd |= E1000_TXD_CMD_IDE; }
comment|/*********************************************************************  *  *  Free all transmit related data structures.  *  **********************************************************************/
argument|static void em_free_transmit_structures(struct adapter *adapter) { 	struct em_buffer *tx_buffer;  	INIT_DEBUGOUT(
literal|"free_transmit_structures: begin"
argument|);  	if (adapter->tx_buffer_area != NULL) { 		for (int i =
literal|0
argument|; i< adapter->num_tx_desc; i++) { 			tx_buffer =&adapter->tx_buffer_area[i]; 			if (tx_buffer->m_head != NULL) { 				bus_dmamap_sync(adapter->txtag, tx_buffer->map, 				    BUS_DMASYNC_POSTWRITE); 				bus_dmamap_unload(adapter->txtag, 				    tx_buffer->map); 				m_freem(tx_buffer->m_head); 				tx_buffer->m_head = NULL; 			} else if (tx_buffer->map != NULL) 				bus_dmamap_unload(adapter->txtag, 				    tx_buffer->map); 			if (tx_buffer->map != NULL) { 				bus_dmamap_destroy(adapter->txtag, 				    tx_buffer->map); 				tx_buffer->map = NULL; 			} 		} 	} 	if (adapter->tx_buffer_area != NULL) { 		free(adapter->tx_buffer_area, M_DEVBUF); 		adapter->tx_buffer_area = NULL; 	} 	if (adapter->txtag != NULL) { 		bus_dma_tag_destroy(adapter->txtag); 		adapter->txtag = NULL; 	}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
argument|if (adapter->br != NULL)         	buf_ring_free(adapter->br, M_DEVBUF);
endif|#
directive|endif
argument|}
comment|/*********************************************************************  *  *  The offload context needs to be set when we transfer the first  *  packet of a particular protocol (TCP/UDP). This routine has been  *  enhanced to deal with inserted VLAN headers, and IPV6 (not complete)  *  *  Added back the old method of keeping the current context type  *  and not setting if unnecessary, as this is reported to be a  *  big performance win.  -jfv  **********************************************************************/
argument|static void em_transmit_checksum_setup(struct adapter *adapter, struct mbuf *mp,     u32 *txd_upper, u32 *txd_lower) { 	struct e1000_context_desc *TXD = NULL; 	struct em_buffer *tx_buffer; 	struct ether_vlan_header *eh; 	struct ip *ip = NULL; 	struct ip6_hdr *ip6; 	int curr_txd, ehdrlen; 	u32 cmd, hdr_len, ip_hlen; 	u16 etype; 	u8 ipproto;   	cmd = hdr_len = ipproto =
literal|0
argument|; 	curr_txd = adapter->next_avail_tx_desc;
comment|/* 	 * Determine where frame payload starts. 	 * Jump over vlan headers if already present, 	 * helpful for QinQ too. 	 */
argument|eh = mtod(mp, struct ether_vlan_header *); 	if (eh->evl_encap_proto == htons(ETHERTYPE_VLAN)) { 		etype = ntohs(eh->evl_proto); 		ehdrlen = ETHER_HDR_LEN + ETHER_VLAN_ENCAP_LEN; 	} else { 		etype = ntohs(eh->evl_encap_proto); 		ehdrlen = ETHER_HDR_LEN; 	}
comment|/* 	 * We only support TCP/UDP for IPv4 and IPv6 for the moment. 	 * TODO: Support SCTP too when it hits the tree. 	 */
argument|switch (etype) { 	case ETHERTYPE_IP: 		ip = (struct ip *)(mp->m_data + ehdrlen); 		ip_hlen = ip->ip_hl<<
literal|2
argument|;
comment|/* Setup of IP header checksum. */
argument|if (mp->m_pkthdr.csum_flags& CSUM_IP) {
comment|/* 			 * Start offset for header checksum calculation. 			 * End offset for header checksum calculation. 			 * Offset of place to put the checksum. 			 */
argument|TXD = (struct e1000_context_desc *)&adapter->tx_desc_base[curr_txd]; 			TXD->lower_setup.ip_fields.ipcss = ehdrlen; 			TXD->lower_setup.ip_fields.ipcse = 			    htole16(ehdrlen + ip_hlen); 			TXD->lower_setup.ip_fields.ipcso = 			    ehdrlen + offsetof(struct ip, ip_sum); 			cmd |= E1000_TXD_CMD_IP; 			*txd_upper |= E1000_TXD_POPTS_IXSM<<
literal|8
argument|; 		}  		if (mp->m_len< ehdrlen + ip_hlen) 			return;
comment|/* failure */
argument|hdr_len = ehdrlen + ip_hlen; 		ipproto = ip->ip_p;  		break; 	case ETHERTYPE_IPV6: 		ip6 = (struct ip6_hdr *)(mp->m_data + ehdrlen); 		ip_hlen = sizeof(struct ip6_hdr);
comment|/* XXX: No header stacking. */
argument|if (mp->m_len< ehdrlen + ip_hlen) 			return;
comment|/* failure */
comment|/* IPv6 doesn't have a header checksum. */
argument|hdr_len = ehdrlen + ip_hlen; 		ipproto = ip6->ip6_nxt;  		break; 	default: 		*txd_upper =
literal|0
argument|; 		*txd_lower =
literal|0
argument|; 		return; 	}  	switch (ipproto) { 	case IPPROTO_TCP: 		if (mp->m_pkthdr.csum_flags& CSUM_TCP) { 			*txd_lower = E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D; 			*txd_upper |= E1000_TXD_POPTS_TXSM<<
literal|8
argument|;
comment|/* no need for context if already set */
argument|if (adapter->last_hw_offload == CSUM_TCP) 				return; 			adapter->last_hw_offload = CSUM_TCP;
comment|/* 			 * Start offset for payload checksum calculation. 			 * End offset for payload checksum calculation. 			 * Offset of place to put the checksum. 			 */
argument|TXD = (struct e1000_context_desc *)&adapter->tx_desc_base[curr_txd]; 			TXD->upper_setup.tcp_fields.tucss = hdr_len; 			TXD->upper_setup.tcp_fields.tucse = htole16(
literal|0
argument|); 			TXD->upper_setup.tcp_fields.tucso = 			    hdr_len + offsetof(struct tcphdr, th_sum); 			cmd |= E1000_TXD_CMD_TCP; 		} 		break; 	case IPPROTO_UDP: 	{ 		if (mp->m_pkthdr.csum_flags& CSUM_UDP) { 			*txd_lower = E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D; 			*txd_upper |= E1000_TXD_POPTS_TXSM<<
literal|8
argument|;
comment|/* no need for context if already set */
argument|if (adapter->last_hw_offload == CSUM_UDP) 				return; 			adapter->last_hw_offload = CSUM_UDP;
comment|/* 			 * Start offset for header checksum calculation. 			 * End offset for header checksum calculation. 			 * Offset of place to put the checksum. 			 */
argument|TXD = (struct e1000_context_desc *)&adapter->tx_desc_base[curr_txd]; 			TXD->upper_setup.tcp_fields.tucss = hdr_len; 			TXD->upper_setup.tcp_fields.tucse = htole16(
literal|0
argument|); 			TXD->upper_setup.tcp_fields.tucso = 			    hdr_len + offsetof(struct udphdr, uh_sum); 		}
comment|/* Fall Thru */
argument|} 	default: 		break; 	}  	TXD->tcp_seg_setup.data = htole32(
literal|0
argument|); 	TXD->cmd_and_length = 	    htole32(adapter->txd_cmd | E1000_TXD_CMD_DEXT | cmd); 	tx_buffer =&adapter->tx_buffer_area[curr_txd]; 	tx_buffer->m_head = NULL; 	tx_buffer->next_eop = -
literal|1
argument|;  	if (++curr_txd == adapter->num_tx_desc) 		curr_txd =
literal|0
argument|;  	adapter->num_tx_desc_avail--; 	adapter->next_avail_tx_desc = curr_txd; }
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
comment|/**********************************************************************  *  *  Setup work for hardware segmentation offload (TSO)  *  **********************************************************************/
argument|static bool em_tso_setup(struct adapter *adapter, struct mbuf *mp, u32 *txd_upper,    u32 *txd_lower) { 	struct e1000_context_desc *TXD; 	struct em_buffer *tx_buffer; 	struct ether_vlan_header *eh; 	struct ip *ip; 	struct ip6_hdr *ip6; 	struct tcphdr *th; 	int curr_txd, ehdrlen, hdr_len, ip_hlen, isip6; 	u16 etype;
comment|/* 	 * This function could/should be extended to support IP/IPv6 	 * fragmentation as well.  But as they say, one step at a time. 	 */
comment|/* 	 * Determine where frame payload starts. 	 * Jump over vlan headers if already present, 	 * helpful for QinQ too. 	 */
argument|eh = mtod(mp, struct ether_vlan_header *); 	if (eh->evl_encap_proto == htons(ETHERTYPE_VLAN)) { 		etype = ntohs(eh->evl_proto); 		ehdrlen = ETHER_HDR_LEN + ETHER_VLAN_ENCAP_LEN; 	} else { 		etype = ntohs(eh->evl_encap_proto); 		ehdrlen = ETHER_HDR_LEN; 	}
comment|/* Ensure we have at least the IP+TCP header in the first mbuf. */
argument|if (mp->m_len< ehdrlen + sizeof(struct ip) + sizeof(struct tcphdr)) 		return FALSE;
comment|/* -1 */
comment|/* 	 * We only support TCP for IPv4 and IPv6 (notyet) for the moment. 	 * TODO: Support SCTP too when it hits the tree. 	 */
argument|switch (etype) { 	case ETHERTYPE_IP: 		isip6 =
literal|0
argument|; 		ip = (struct ip *)(mp->m_data + ehdrlen); 		if (ip->ip_p != IPPROTO_TCP) 			return FALSE;
comment|/* 0 */
argument|ip->ip_len =
literal|0
argument|; 		ip->ip_sum =
literal|0
argument|; 		ip_hlen = ip->ip_hl<<
literal|2
argument|; 		if (mp->m_len< ehdrlen + ip_hlen + sizeof(struct tcphdr)) 			return FALSE;
comment|/* -1 */
argument|th = (struct tcphdr *)((caddr_t)ip + ip_hlen);
if|#
directive|if
literal|1
argument|th->th_sum = in_pseudo(ip->ip_src.s_addr, 		    ip->ip_dst.s_addr, htons(IPPROTO_TCP));
else|#
directive|else
argument|th->th_sum = mp->m_pkthdr.csum_data;
endif|#
directive|endif
argument|break; 	case ETHERTYPE_IPV6: 		isip6 =
literal|1
argument|; 		return FALSE;
comment|/* Not supported yet. */
argument|ip6 = (struct ip6_hdr *)(mp->m_data + ehdrlen); 		if (ip6->ip6_nxt != IPPROTO_TCP) 			return FALSE;
comment|/* 0 */
argument|ip6->ip6_plen =
literal|0
argument|; 		ip_hlen = sizeof(struct ip6_hdr);
comment|/* XXX: no header stacking. */
argument|if (mp->m_len< ehdrlen + ip_hlen + sizeof(struct tcphdr)) 			return FALSE;
comment|/* -1 */
argument|th = (struct tcphdr *)((caddr_t)ip6 + ip_hlen);
if|#
directive|if
literal|0
argument|th->th_sum = in6_pseudo(ip6->ip6_src, ip->ip6_dst, 		    htons(IPPROTO_TCP));
comment|/* XXX: function notyet. */
else|#
directive|else
argument|th->th_sum = mp->m_pkthdr.csum_data;
endif|#
directive|endif
argument|break; 	default: 		return FALSE; 	} 	hdr_len = ehdrlen + ip_hlen + (th->th_off<<
literal|2
argument|);  	*txd_lower = (E1000_TXD_CMD_DEXT |
comment|/* Extended descr type */
argument|E1000_TXD_DTYP_D |
comment|/* Data descr type */
argument|E1000_TXD_CMD_TSE);
comment|/* Do TSE on this packet */
comment|/* IP and/or TCP header checksum calculation and insertion. */
argument|*txd_upper = ((isip6 ?
literal|0
argument|: E1000_TXD_POPTS_IXSM) | 		      E1000_TXD_POPTS_TXSM)<<
literal|8
argument|;  	curr_txd = adapter->next_avail_tx_desc; 	tx_buffer =&adapter->tx_buffer_area[curr_txd]; 	TXD = (struct e1000_context_desc *)&adapter->tx_desc_base[curr_txd];
comment|/* IPv6 doesn't have a header checksum. */
argument|if (!isip6) {
comment|/* 		 * Start offset for header checksum calculation. 		 * End offset for header checksum calculation. 		 * Offset of place put the checksum. 		 */
argument|TXD->lower_setup.ip_fields.ipcss = ehdrlen; 		TXD->lower_setup.ip_fields.ipcse = 		    htole16(ehdrlen + ip_hlen -
literal|1
argument|); 		TXD->lower_setup.ip_fields.ipcso = 		    ehdrlen + offsetof(struct ip, ip_sum); 	}
comment|/* 	 * Start offset for payload checksum calculation. 	 * End offset for payload checksum calculation. 	 * Offset of place to put the checksum. 	 */
argument|TXD->upper_setup.tcp_fields.tucss = 	    ehdrlen + ip_hlen; 	TXD->upper_setup.tcp_fields.tucse =
literal|0
argument|; 	TXD->upper_setup.tcp_fields.tucso = 	    ehdrlen + ip_hlen + offsetof(struct tcphdr, th_sum);
comment|/* 	 * Payload size per packet w/o any headers. 	 * Length of all headers up to payload. 	 */
argument|TXD->tcp_seg_setup.fields.mss = htole16(mp->m_pkthdr.tso_segsz); 	TXD->tcp_seg_setup.fields.hdr_len = hdr_len;  	TXD->cmd_and_length = htole32(adapter->txd_cmd | 				E1000_TXD_CMD_DEXT |
comment|/* Extended descr */
argument|E1000_TXD_CMD_TSE |
comment|/* TSE context */
argument|(isip6 ?
literal|0
argument|: E1000_TXD_CMD_IP) |
comment|/* Do IP csum */
argument|E1000_TXD_CMD_TCP |
comment|/* Do TCP checksum */
argument|(mp->m_pkthdr.len - (hdr_len)));
comment|/* Total len */
argument|tx_buffer->m_head = NULL; 	tx_buffer->next_eop = -
literal|1
argument|;  	if (++curr_txd == adapter->num_tx_desc) 		curr_txd =
literal|0
argument|;  	adapter->num_tx_desc_avail--; 	adapter->next_avail_tx_desc = curr_txd; 	adapter->tx_tso = TRUE;  	return TRUE; }
endif|#
directive|endif
comment|/* __FreeBSD_version>= 700000 */
comment|/**********************************************************************  *  *  Examine each tx_buffer in the used queue. If the hardware is done  *  processing the packet then free associated resources. The  *  tx_buffer is put back on the free queue.  *  **********************************************************************/
argument|static void em_txeof(struct adapter *adapter) {         int first, last, done, num_avail;         struct em_buffer *tx_buffer;         struct e1000_tx_desc   *tx_desc, *eop_desc; 	struct ifnet   *ifp = adapter->ifp;  	EM_TX_LOCK_ASSERT(adapter);          if (adapter->num_tx_desc_avail == adapter->num_tx_desc)                 return;          num_avail = adapter->num_tx_desc_avail;         first = adapter->next_tx_to_clean;         tx_desc =&adapter->tx_desc_base[first];         tx_buffer =&adapter->tx_buffer_area[first]; 	last = tx_buffer->next_eop;         eop_desc =&adapter->tx_desc_base[last];
comment|/* 	 * What this does is get the index of the 	 * first descriptor AFTER the EOP of the  	 * first packet, that way we can do the 	 * simple comparison on the inner while loop. 	 */
argument|if (++last == adapter->num_tx_desc)  		last =
literal|0
argument|; 	done = last;          bus_dmamap_sync(adapter->txdma.dma_tag, adapter->txdma.dma_map,             BUS_DMASYNC_POSTREAD);          while (eop_desc->upper.fields.status& E1000_TXD_STAT_DD) {
comment|/* We clean the range of the packet */
argument|while (first != done) {                 	tx_desc->upper.data =
literal|0
argument|;                 	tx_desc->lower.data =
literal|0
argument|;                 	tx_desc->buffer_addr =
literal|0
argument|;                 	++num_avail;  			if (tx_buffer->m_head) { 				ifp->if_opackets++; 				bus_dmamap_sync(adapter->txtag, 				    tx_buffer->map, 				    BUS_DMASYNC_POSTWRITE); 				bus_dmamap_unload(adapter->txtag, 				    tx_buffer->map);                          	m_freem(tx_buffer->m_head);                         	tx_buffer->m_head = NULL;                 	} 			tx_buffer->next_eop = -
literal|1
argument|; 			adapter->watchdog_time = ticks;  	                if (++first == adapter->num_tx_desc) 				first =
literal|0
argument|;  	                tx_buffer =&adapter->tx_buffer_area[first]; 			tx_desc =&adapter->tx_desc_base[first]; 		}
comment|/* See if we can continue to the next packet */
argument|last = tx_buffer->next_eop; 		if (last != -
literal|1
argument|) {         		eop_desc =&adapter->tx_desc_base[last];
comment|/* Get new done point */
argument|if (++last == adapter->num_tx_desc) last =
literal|0
argument|; 			done = last; 		} else 			break;         }         bus_dmamap_sync(adapter->txdma.dma_tag, adapter->txdma.dma_map,             BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);          adapter->next_tx_to_clean = first;
comment|/*          * If we have enough room, clear IFF_DRV_OACTIVE to          * tell the stack that it is OK to send packets.          * If there are no pending descriptors, clear the watchdog.          */
argument|if (num_avail> EM_TX_CLEANUP_THRESHOLD) {                                 ifp->if_drv_flags&= ~IFF_DRV_OACTIVE;                 if (num_avail == adapter->num_tx_desc) { 			adapter->watchdog_check = FALSE;         		adapter->num_tx_desc_avail = num_avail; 			return; 		}          }          adapter->num_tx_desc_avail = num_avail; 	return; }
comment|/*********************************************************************  *  *  When Link is lost sometimes there is work still in the TX ring  *  which may result in a watchdog, rather than allow that we do an  *  attempted cleanup and then reinit here. Note that this has been  *  seens mostly with fiber adapters.  *  **********************************************************************/
argument|static void em_tx_purge(struct adapter *adapter) { 	if ((!adapter->link_active)&& (adapter->watchdog_check)) { 		EM_TX_LOCK(adapter); 		em_txeof(adapter); 		EM_TX_UNLOCK(adapter); 		if (adapter->watchdog_check)
comment|/* Still outstanding? */
argument|em_init_locked(adapter); 	} }
comment|/*********************************************************************  *  *  Get a buffer from system mbuf buffer pool.  *  **********************************************************************/
argument|static int em_get_buf(struct adapter *adapter, int i) { 	struct mbuf		*m; 	bus_dma_segment_t	segs[
literal|1
argument|]; 	bus_dmamap_t		map; 	struct em_buffer	*rx_buffer; 	int			error, nsegs;  	m = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR); 	if (m == NULL) { 		adapter->mbuf_cluster_failed++; 		return (ENOBUFS); 	} 	m->m_len = m->m_pkthdr.len = MCLBYTES;  	if (adapter->max_frame_size<= (MCLBYTES - ETHER_ALIGN)) 		m_adj(m, ETHER_ALIGN);
comment|/* 	 * Using memory from the mbuf cluster pool, invoke the 	 * bus_dma machinery to arrange the memory mapping. 	 */
argument|error = bus_dmamap_load_mbuf_sg(adapter->rxtag, 	    adapter->rx_sparemap, m, segs,&nsegs, BUS_DMA_NOWAIT); 	if (error !=
literal|0
argument|) { 		m_free(m); 		return (error); 	}
comment|/* If nsegs is wrong then the stack is corrupt. */
argument|KASSERT(nsegs ==
literal|1
argument|, (
literal|"Too many segments returned!"
argument|));  	rx_buffer =&adapter->rx_buffer_area[i]; 	if (rx_buffer->m_head != NULL) 		bus_dmamap_unload(adapter->rxtag, rx_buffer->map);  	map = rx_buffer->map; 	rx_buffer->map = adapter->rx_sparemap; 	adapter->rx_sparemap = map; 	bus_dmamap_sync(adapter->rxtag, rx_buffer->map, BUS_DMASYNC_PREREAD); 	rx_buffer->m_head = m;  	adapter->rx_desc_base[i].buffer_addr = htole64(segs[
literal|0
argument|].ds_addr); 	return (
literal|0
argument|); }
comment|/*********************************************************************  *  *  Allocate memory for rx_buffer structures. Since we use one  *  rx_buffer per received packet, the maximum number of rx_buffer's  *  that we'll need is equal to the number of receive descriptors  *  that we've allocated.  *  **********************************************************************/
argument|static int em_allocate_receive_structures(struct adapter *adapter) { 	device_t dev = adapter->dev; 	struct em_buffer *rx_buffer; 	int i, error;  	adapter->rx_buffer_area = malloc(sizeof(struct em_buffer) * 	    adapter->num_rx_desc, M_DEVBUF, M_NOWAIT | M_ZERO); 	if (adapter->rx_buffer_area == NULL) { 		device_printf(dev,
literal|"Unable to allocate rx_buffer memory\n"
argument|); 		return (ENOMEM); 	}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
argument|error = bus_dma_tag_create(bus_get_dma_tag(dev),
comment|/* parent */
else|#
directive|else
argument|error = bus_dma_tag_create(NULL,
comment|/* parent */
endif|#
directive|endif
literal|1
argument|,
literal|0
argument|,
comment|/* alignment, bounds */
argument|BUS_SPACE_MAXADDR,
comment|/* lowaddr */
argument|BUS_SPACE_MAXADDR,
comment|/* highaddr */
argument|NULL, NULL,
comment|/* filter, filterarg */
argument|MCLBYTES,
comment|/* maxsize */
literal|1
argument|,
comment|/* nsegments */
argument|MCLBYTES,
comment|/* maxsegsize */
literal|0
argument|,
comment|/* flags */
argument|NULL,
comment|/* lockfunc */
argument|NULL,
comment|/* lockarg */
argument|&adapter->rxtag); 	if (error) { 		device_printf(dev,
literal|"%s: bus_dma_tag_create failed %d\n"
argument|, 		    __func__, error); 		goto fail; 	}
comment|/* Create the spare map (used by getbuf) */
argument|error = bus_dmamap_create(adapter->rxtag, BUS_DMA_NOWAIT,&adapter->rx_sparemap); 	if (error) { 		device_printf(dev,
literal|"%s: bus_dmamap_create failed: %d\n"
argument|, 		    __func__, error); 		goto fail; 	}  	rx_buffer = adapter->rx_buffer_area; 	for (i =
literal|0
argument|; i< adapter->num_rx_desc; i++, rx_buffer++) { 		error = bus_dmamap_create(adapter->rxtag, BUS_DMA_NOWAIT,&rx_buffer->map); 		if (error) { 			device_printf(dev,
literal|"%s: bus_dmamap_create failed: %d\n"
argument|, 			    __func__, error); 			goto fail; 		} 	}  	return (
literal|0
argument|);  fail: 	em_free_receive_structures(adapter); 	return (error); }
comment|/*********************************************************************  *  *  (Re)initialize receive structures.  *  **********************************************************************/
argument|static int em_setup_receive_structures(struct adapter *adapter) { 	struct em_buffer *rx_buffer; 	int i, error;
comment|/* Reset descriptor ring */
argument|bzero(adapter->rx_desc_base, 	    (sizeof(struct e1000_rx_desc)) * adapter->num_rx_desc);
comment|/* Free current RX buffers. */
argument|rx_buffer = adapter->rx_buffer_area; 	for (i =
literal|0
argument|; i< adapter->num_rx_desc; i++, rx_buffer++) { 		if (rx_buffer->m_head != NULL) { 			bus_dmamap_sync(adapter->rxtag, rx_buffer->map, 			    BUS_DMASYNC_POSTREAD); 			bus_dmamap_unload(adapter->rxtag, rx_buffer->map); 			m_freem(rx_buffer->m_head); 			rx_buffer->m_head = NULL; 		}         }
comment|/* Allocate new ones. */
argument|for (i =
literal|0
argument|; i< adapter->num_rx_desc; i++) { 		error = em_get_buf(adapter, i); 		if (error)                         return (error); 	}
comment|/* Setup our descriptor pointers */
argument|adapter->next_rx_desc_to_check =
literal|0
argument|; 	bus_dmamap_sync(adapter->rxdma.dma_tag, adapter->rxdma.dma_map, 	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);  	return (
literal|0
argument|); }
comment|/*********************************************************************  *  *  Enable receive unit.  *  **********************************************************************/
define|#
directive|define
name|MAX_INTS_PER_SEC
value|8000
define|#
directive|define
name|DEFAULT_ITR
value|1000000000/(MAX_INTS_PER_SEC * 256)
argument|static void em_initialize_receive_unit(struct adapter *adapter) { 	struct ifnet	*ifp = adapter->ifp; 	u64	bus_addr; 	u32	rctl, rxcsum;  	INIT_DEBUGOUT(
literal|"em_initialize_receive_unit: begin"
argument|);
comment|/* 	 * Make sure receives are disabled while setting 	 * up the descriptor ring 	 */
argument|rctl = E1000_READ_REG(&adapter->hw, E1000_RCTL); 	E1000_WRITE_REG(&adapter->hw, E1000_RCTL, rctl& ~E1000_RCTL_EN);  	if (adapter->hw.mac.type>= e1000_82540) { 		E1000_WRITE_REG(&adapter->hw, E1000_RADV, 		    adapter->rx_abs_int_delay.value);
comment|/* 		 * Set the interrupt throttling rate. Value is calculated 		 * as DEFAULT_ITR = 1/(MAX_INTS_PER_SEC * 256ns) 		 */
argument|E1000_WRITE_REG(&adapter->hw, E1000_ITR, DEFAULT_ITR); 	}
comment|/* 	** When using MSIX interrupts we need to throttle 	** using the EITR register (82574 only) 	*/
argument|if (adapter->msix) 		for (int i =
literal|0
argument|; i<
literal|4
argument|; i++) 			E1000_WRITE_REG(&adapter->hw, 			    E1000_EITR_82574(i), DEFAULT_ITR);
comment|/* Disable accelerated ackknowledge */
argument|if (adapter->hw.mac.type == e1000_82574) 		E1000_WRITE_REG(&adapter->hw, 		    E1000_RFCTL, E1000_RFCTL_ACK_DIS);
comment|/* Setup the Base and Length of the Rx Descriptor Ring */
argument|bus_addr = adapter->rxdma.dma_paddr; 	E1000_WRITE_REG(&adapter->hw, E1000_RDLEN(
literal|0
argument|), 	    adapter->num_rx_desc * sizeof(struct e1000_rx_desc)); 	E1000_WRITE_REG(&adapter->hw, E1000_RDBAH(
literal|0
argument|), 	    (u32)(bus_addr>>
literal|32
argument|)); 	E1000_WRITE_REG(&adapter->hw, E1000_RDBAL(
literal|0
argument|), 	    (u32)bus_addr);
comment|/* Setup the Receive Control Register */
argument|rctl&= ~(
literal|3
argument|<< E1000_RCTL_MO_SHIFT); 	rctl |= E1000_RCTL_EN | E1000_RCTL_BAM | E1000_RCTL_LBM_NO | 		   E1000_RCTL_RDMTS_HALF | 		   (adapter->hw.mac.mc_filter_type<< E1000_RCTL_MO_SHIFT);
comment|/* Make sure VLAN Filters are off */
argument|rctl&= ~E1000_RCTL_VFE;  	if (e1000_tbi_sbp_enabled_82543(&adapter->hw)) 		rctl |= E1000_RCTL_SBP; 	else 		rctl&= ~E1000_RCTL_SBP;  	switch (adapter->rx_buffer_len) { 	default: 	case
literal|2048
argument|: 		rctl |= E1000_RCTL_SZ_2048; 		break; 	case
literal|4096
argument|: 		rctl |= E1000_RCTL_SZ_4096 | 		    E1000_RCTL_BSEX | E1000_RCTL_LPE; 		break; 	case
literal|8192
argument|: 		rctl |= E1000_RCTL_SZ_8192 | 		    E1000_RCTL_BSEX | E1000_RCTL_LPE; 		break; 	case
literal|16384
argument|: 		rctl |= E1000_RCTL_SZ_16384 | 		    E1000_RCTL_BSEX | E1000_RCTL_LPE; 		break; 	}  	if (ifp->if_mtu> ETHERMTU) 		rctl |= E1000_RCTL_LPE; 	else 		rctl&= ~E1000_RCTL_LPE;
comment|/* Enable 82543 Receive Checksum Offload for TCP and UDP */
argument|if ((adapter->hw.mac.type>= e1000_82543)&& 	    (ifp->if_capenable& IFCAP_RXCSUM)) { 		rxcsum = E1000_READ_REG(&adapter->hw, E1000_RXCSUM); 		rxcsum |= (E1000_RXCSUM_IPOFL | E1000_RXCSUM_TUOFL); 		E1000_WRITE_REG(&adapter->hw, E1000_RXCSUM, rxcsum); 	}
comment|/* 	** XXX TEMPORARY WORKAROUND: on some systems with 82573 	** long latencies are observed, like Lenovo X60. This 	** change eliminates the problem, but since having positive 	** values in RDTR is a known source of problems on other 	** platforms another solution is being sought. 	*/
argument|if (adapter->hw.mac.type == e1000_82573) 		E1000_WRITE_REG(&adapter->hw, E1000_RDTR,
literal|0x20
argument|);
comment|/* Enable Receives */
argument|E1000_WRITE_REG(&adapter->hw, E1000_RCTL, rctl);
comment|/* 	 * Setup the HW Rx Head and 	 * Tail Descriptor Pointers 	 */
argument|E1000_WRITE_REG(&adapter->hw, E1000_RDH(
literal|0
argument|),
literal|0
argument|); 	E1000_WRITE_REG(&adapter->hw, E1000_RDT(
literal|0
argument|), adapter->num_rx_desc -
literal|1
argument|);  	return; }
comment|/*********************************************************************  *  *  Free receive related data structures.  *  **********************************************************************/
argument|static void em_free_receive_structures(struct adapter *adapter) { 	struct em_buffer *rx_buffer; 	int i;  	INIT_DEBUGOUT(
literal|"free_receive_structures: begin"
argument|);  	if (adapter->rx_sparemap) { 		bus_dmamap_destroy(adapter->rxtag, adapter->rx_sparemap); 		adapter->rx_sparemap = NULL; 	}
comment|/* Cleanup any existing buffers */
argument|if (adapter->rx_buffer_area != NULL) { 		rx_buffer = adapter->rx_buffer_area; 		for (i =
literal|0
argument|; i< adapter->num_rx_desc; i++, rx_buffer++) { 			if (rx_buffer->m_head != NULL) { 				bus_dmamap_sync(adapter->rxtag, rx_buffer->map, 				    BUS_DMASYNC_POSTREAD); 				bus_dmamap_unload(adapter->rxtag, 				    rx_buffer->map); 				m_freem(rx_buffer->m_head); 				rx_buffer->m_head = NULL; 			} else if (rx_buffer->map != NULL) 				bus_dmamap_unload(adapter->rxtag, 				    rx_buffer->map); 			if (rx_buffer->map != NULL) { 				bus_dmamap_destroy(adapter->rxtag, 				    rx_buffer->map); 				rx_buffer->map = NULL; 			} 		} 	}  	if (adapter->rx_buffer_area != NULL) { 		free(adapter->rx_buffer_area, M_DEVBUF); 		adapter->rx_buffer_area = NULL; 	}  	if (adapter->rxtag != NULL) { 		bus_dma_tag_destroy(adapter->rxtag); 		adapter->rxtag = NULL; 	} }
comment|/*********************************************************************  *  *  This routine executes in interrupt context. It replenishes  *  the mbufs in the descriptor and sends data which has been  *  dma'ed into host memory to upper layer.  *  *  We loop at most count times if count is> 0, or until done if  *  count< 0.  *    *  For polling we also now return the number of cleaned packets  *********************************************************************/
argument|static int em_rxeof(struct adapter *adapter, int count) { 	struct ifnet	*ifp = adapter->ifp;; 	struct mbuf	*mp; 	u8		status, accept_frame =
literal|0
argument|, eop =
literal|0
argument|; 	u16 		len, desc_len, prev_len_adj; 	int		i, rx_sent =
literal|0
argument|; 	struct e1000_rx_desc   *current_desc;  	EM_RX_LOCK(adapter); 	i = adapter->next_rx_desc_to_check; 	current_desc =&adapter->rx_desc_base[i]; 	bus_dmamap_sync(adapter->rxdma.dma_tag, adapter->rxdma.dma_map, 	    BUS_DMASYNC_POSTREAD);  	if (!((current_desc->status)& E1000_RXD_STAT_DD)) { 		EM_RX_UNLOCK(adapter); 		return (rx_sent); 	}  	while ((current_desc->status& E1000_RXD_STAT_DD)&& 	    (count !=
literal|0
argument|)&& 	    (ifp->if_drv_flags& IFF_DRV_RUNNING)) { 		struct mbuf *m = NULL;  		mp = adapter->rx_buffer_area[i].m_head;
comment|/* 		 * Can't defer bus_dmamap_sync(9) because TBI_ACCEPT 		 * needs to access the last received byte in the mbuf. 		 */
argument|bus_dmamap_sync(adapter->rxtag, adapter->rx_buffer_area[i].map, 		    BUS_DMASYNC_POSTREAD);  		accept_frame =
literal|1
argument|; 		prev_len_adj =
literal|0
argument|; 		desc_len = le16toh(current_desc->length); 		status = current_desc->status; 		if (status& E1000_RXD_STAT_EOP) { 			count--; 			eop =
literal|1
argument|; 			if (desc_len< ETHER_CRC_LEN) { 				len =
literal|0
argument|; 				prev_len_adj = ETHER_CRC_LEN - desc_len; 			} else 				len = desc_len - ETHER_CRC_LEN; 		} else { 			eop =
literal|0
argument|; 			len = desc_len; 		}  		if (current_desc->errors& E1000_RXD_ERR_FRAME_ERR_MASK) { 			u8	last_byte; 			u32	pkt_len = desc_len;  			if (adapter->fmp != NULL) 				pkt_len += adapter->fmp->m_pkthdr.len;  			last_byte = *(mtod(mp, caddr_t) + desc_len -
literal|1
argument|);			 			if (TBI_ACCEPT(&adapter->hw, status, 			    current_desc->errors, pkt_len, last_byte, 			    adapter->min_frame_size, adapter->max_frame_size)) { 				e1000_tbi_adjust_stats_82543(&adapter->hw,&adapter->stats, pkt_len, 				    adapter->hw.mac.addr, 				    adapter->max_frame_size); 				if (len>
literal|0
argument|) 					len--; 			} else 				accept_frame =
literal|0
argument|; 		}  		if (accept_frame) { 			if (em_get_buf(adapter, i) !=
literal|0
argument|) { 				ifp->if_iqdrops++; 				goto discard; 			}
comment|/* Assign correct length to the current fragment */
argument|mp->m_len = len;  			if (adapter->fmp == NULL) { 				mp->m_pkthdr.len = len; 				adapter->fmp = mp;
comment|/* Store the first mbuf */
argument|adapter->lmp = mp; 			} else {
comment|/* Chain mbuf's together */
argument|mp->m_flags&= ~M_PKTHDR;
comment|/* 				 * Adjust length of previous mbuf in chain if 				 * we received less than 4 bytes in the last 				 * descriptor. 				 */
argument|if (prev_len_adj>
literal|0
argument|) { 					adapter->lmp->m_len -= prev_len_adj; 					adapter->fmp->m_pkthdr.len -= 					    prev_len_adj; 				} 				adapter->lmp->m_next = mp; 				adapter->lmp = adapter->lmp->m_next; 				adapter->fmp->m_pkthdr.len += len; 			}  			if (eop) { 				adapter->fmp->m_pkthdr.rcvif = ifp; 				ifp->if_ipackets++; 				em_receive_checksum(adapter, current_desc, 				    adapter->fmp);
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
argument|if (adapter->max_frame_size> 				    (MCLBYTES - ETHER_ALIGN)&& 				    em_fixup_rx(adapter) !=
literal|0
argument|) 					goto skip;
endif|#
directive|endif
argument|if (status& E1000_RXD_STAT_VP) {
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
argument|VLAN_INPUT_TAG_NEW(ifp, adapter->fmp, 					    (le16toh(current_desc->special)& 					    E1000_RXD_SPC_VLAN_MASK));
else|#
directive|else
argument|adapter->fmp->m_pkthdr.ether_vtag = 					    (le16toh(current_desc->special)& 					    E1000_RXD_SPC_VLAN_MASK); 					adapter->fmp->m_flags |= M_VLANTAG;
endif|#
directive|endif
argument|}
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
argument|skip:
endif|#
directive|endif
argument|m = adapter->fmp; 				adapter->fmp = NULL; 				adapter->lmp = NULL; 			} 		} else { 			ifp->if_ierrors++; discard:
comment|/* Reuse loaded DMA map and just update mbuf chain */
argument|mp = adapter->rx_buffer_area[i].m_head; 			mp->m_len = mp->m_pkthdr.len = MCLBYTES; 			mp->m_data = mp->m_ext.ext_buf; 			mp->m_next = NULL; 			if (adapter->max_frame_size<= 			    (MCLBYTES - ETHER_ALIGN)) 				m_adj(mp, ETHER_ALIGN); 			if (adapter->fmp != NULL) { 				m_freem(adapter->fmp); 				adapter->fmp = NULL; 				adapter->lmp = NULL; 			} 			m = NULL; 		}
comment|/* Zero out the receive descriptors status. */
argument|current_desc->status =
literal|0
argument|; 		bus_dmamap_sync(adapter->rxdma.dma_tag, adapter->rxdma.dma_map, 		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
comment|/* Advance our pointers to the next descriptor. */
argument|if (++i == adapter->num_rx_desc) 			i =
literal|0
argument|;
comment|/* Call into the stack */
argument|if (m != NULL) { 			adapter->next_rx_desc_to_check = i; 			EM_RX_UNLOCK(adapter); 			(*ifp->if_input)(ifp, m); 			EM_RX_LOCK(adapter); 			rx_sent++; 			i = adapter->next_rx_desc_to_check; 		} 		current_desc =&adapter->rx_desc_base[i]; 	} 	adapter->next_rx_desc_to_check = i;
comment|/* Advance the E1000's Receive Queue #0  "Tail Pointer". */
argument|if (--i<
literal|0
argument|) 		i = adapter->num_rx_desc -
literal|1
argument|; 	E1000_WRITE_REG(&adapter->hw, E1000_RDT(
literal|0
argument|), i); 	EM_RX_UNLOCK(adapter); 	return (rx_sent); }
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
comment|/*  * When jumbo frames are enabled we should realign entire payload on  * architecures with strict alignment. This is serious design mistake of 8254x  * as it nullifies DMA operations. 8254x just allows RX buffer size to be  * 2048/4096/8192/16384. What we really want is 2048 - ETHER_ALIGN to align its  * payload. On architecures without strict alignment restrictions 8254x still  * performs unaligned memory access which would reduce the performance too.  * To avoid copying over an entire frame to align, we allocate a new mbuf and  * copy ethernet header to the new mbuf. The new mbuf is prepended into the  * existing mbuf chain.  *  * Be aware, best performance of the 8254x is achived only when jumbo frame is  * not used at all on architectures with strict alignment.  */
argument|static int em_fixup_rx(struct adapter *adapter) { 	struct mbuf *m, *n; 	int error;  	error =
literal|0
argument|; 	m = adapter->fmp; 	if (m->m_len<= (MCLBYTES - ETHER_HDR_LEN)) { 		bcopy(m->m_data, m->m_data + ETHER_HDR_LEN, m->m_len); 		m->m_data += ETHER_HDR_LEN; 	} else { 		MGETHDR(n, M_DONTWAIT, MT_DATA); 		if (n != NULL) { 			bcopy(m->m_data, n->m_data, ETHER_HDR_LEN); 			m->m_data += ETHER_HDR_LEN; 			m->m_len -= ETHER_HDR_LEN; 			n->m_len = ETHER_HDR_LEN; 			M_MOVE_PKTHDR(n, m); 			n->m_next = m; 			adapter->fmp = n; 		} else { 			adapter->dropped_pkts++; 			m_freem(adapter->fmp); 			adapter->fmp = NULL; 			error = ENOMEM; 		} 	}  	return (error); }
endif|#
directive|endif
comment|/*********************************************************************  *  *  Verify that the hardware indicated that the checksum is valid.  *  Inform the stack about the status of checksum so that stack  *  doesn't spend time verifying the checksum.  *  *********************************************************************/
argument|static void em_receive_checksum(struct adapter *adapter, 	    struct e1000_rx_desc *rx_desc, struct mbuf *mp) {
comment|/* 82543 or newer only */
argument|if ((adapter->hw.mac.type< e1000_82543) ||
comment|/* Ignore Checksum bit is set */
argument|(rx_desc->status& E1000_RXD_STAT_IXSM)) { 		mp->m_pkthdr.csum_flags =
literal|0
argument|; 		return; 	}  	if (rx_desc->status& E1000_RXD_STAT_IPCS) {
comment|/* Did it pass? */
argument|if (!(rx_desc->errors& E1000_RXD_ERR_IPE)) {
comment|/* IP Checksum Good */
argument|mp->m_pkthdr.csum_flags = CSUM_IP_CHECKED; 			mp->m_pkthdr.csum_flags |= CSUM_IP_VALID;  		} else { 			mp->m_pkthdr.csum_flags =
literal|0
argument|; 		} 	}  	if (rx_desc->status& E1000_RXD_STAT_TCPCS) {
comment|/* Did it pass? */
argument|if (!(rx_desc->errors& E1000_RXD_ERR_TCPE)) { 			mp->m_pkthdr.csum_flags |= 			(CSUM_DATA_VALID | CSUM_PSEUDO_HDR); 			mp->m_pkthdr.csum_data = htons(
literal|0xffff
argument|); 		} 	} }
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700029
comment|/*  * This routine is run via an vlan  * config EVENT  */
argument|static void em_register_vlan(void *arg, struct ifnet *ifp, u16 vtag) { 	struct adapter	*adapter = ifp->if_softc; 	u32		index, bit;  	if (ifp->if_softc !=  arg)
comment|/* Not our event */
argument|return;  	if ((vtag ==
literal|0
argument|) || (vtag>
literal|4095
argument|))
comment|/* Invalid ID */
argument|return;  	index = (vtag>>
literal|5
argument|)&
literal|0x7F
argument|; 	bit = vtag&
literal|0x1F
argument|; 	em_shadow_vfta[index] |= (
literal|1
argument|<< bit); 	++adapter->num_vlans;
comment|/* Re-init to load the changes */
argument|em_init(adapter); }
comment|/*  * This routine is run via an vlan  * unconfig EVENT  */
argument|static void em_unregister_vlan(void *arg, struct ifnet *ifp, u16 vtag) { 	struct adapter	*adapter = ifp->if_softc; 	u32		index, bit;  	if (ifp->if_softc !=  arg) 		return;  	if ((vtag ==
literal|0
argument|) || (vtag>
literal|4095
argument|))
comment|/* Invalid */
argument|return;  	index = (vtag>>
literal|5
argument|)&
literal|0x7F
argument|; 	bit = vtag&
literal|0x1F
argument|; 	em_shadow_vfta[index]&= ~(
literal|1
argument|<< bit); 	--adapter->num_vlans;
comment|/* Re-init to load the changes */
argument|em_init(adapter); }  static void em_setup_vlan_hw_support(struct adapter *adapter) { 	struct e1000_hw *hw =&adapter->hw; 	u32             reg;
comment|/* 	** We get here thru init_locked, meaning 	** a soft reset, this has already cleared 	** the VFTA and other state, so if there 	** have been no vlan's registered do nothing. 	*/
argument|if (adapter->num_vlans ==
literal|0
argument|)                 return;
comment|/* 	** A soft reset zero's out the VFTA, so 	** we need to repopulate it now. 	*/
argument|for (int i =
literal|0
argument|; i< EM_VFTA_SIZE; i++)                 if (em_shadow_vfta[i] !=
literal|0
argument|) 			E1000_WRITE_REG_ARRAY(hw, E1000_VFTA,                             i, em_shadow_vfta[i]);  	reg = E1000_READ_REG(hw, E1000_CTRL); 	reg |= E1000_CTRL_VME; 	E1000_WRITE_REG(hw, E1000_CTRL, reg);
comment|/* Enable the Filter Table */
argument|reg = E1000_READ_REG(hw, E1000_RCTL); 	reg&= ~E1000_RCTL_CFIEN; 	reg |= E1000_RCTL_VFE; 	E1000_WRITE_REG(hw, E1000_RCTL, reg);
comment|/* Update the frame size */
argument|E1000_WRITE_REG(&adapter->hw, E1000_RLPML, 	    adapter->max_frame_size + VLAN_TAG_SIZE); }
endif|#
directive|endif
argument|static void em_enable_intr(struct adapter *adapter) { 	struct e1000_hw *hw =&adapter->hw; 	u32 ims_mask = IMS_ENABLE_MASK;  	if (adapter->msix) { 		E1000_WRITE_REG(hw, EM_EIAC, EM_MSIX_MASK); 		ims_mask |= EM_MSIX_MASK; 	}  	E1000_WRITE_REG(hw, E1000_IMS, ims_mask); }  static void em_disable_intr(struct adapter *adapter) { 	struct e1000_hw *hw =&adapter->hw;  	if (adapter->msix) 		E1000_WRITE_REG(hw, EM_EIAC,
literal|0
argument|); 	E1000_WRITE_REG(&adapter->hw, E1000_IMC,
literal|0xffffffff
argument|); }
comment|/*  * Bit of a misnomer, what this really means is  * to enable OS management of the system... aka  * to disable special hardware management features   */
argument|static void em_init_manageability(struct adapter *adapter) {
comment|/* A shared code workaround */
define|#
directive|define
name|E1000_82542_MANC2H
value|E1000_MANC2H
argument|if (adapter->has_manage) { 		int manc2h = E1000_READ_REG(&adapter->hw, E1000_MANC2H); 		int manc = E1000_READ_REG(&adapter->hw, E1000_MANC);
comment|/* disable hardware interception of ARP */
argument|manc&= ~(E1000_MANC_ARP_EN);
comment|/* enable receiving management packets to the host */
argument|if (adapter->hw.mac.type>= e1000_82571) { 			manc |= E1000_MANC_EN_MNG2HOST;
define|#
directive|define
name|E1000_MNG2HOST_PORT_623
value|(1<< 5)
define|#
directive|define
name|E1000_MNG2HOST_PORT_664
value|(1<< 6)
argument|manc2h |= E1000_MNG2HOST_PORT_623; 			manc2h |= E1000_MNG2HOST_PORT_664; 			E1000_WRITE_REG(&adapter->hw, E1000_MANC2H, manc2h); 		}  		E1000_WRITE_REG(&adapter->hw, E1000_MANC, manc); 	} }
comment|/*  * Give control back to hardware management  * controller if there is one.  */
argument|static void em_release_manageability(struct adapter *adapter) { 	if (adapter->has_manage) { 		int manc = E1000_READ_REG(&adapter->hw, E1000_MANC);
comment|/* re-enable hardware interception of ARP */
argument|manc |= E1000_MANC_ARP_EN;  		if (adapter->hw.mac.type>= e1000_82571) 			manc&= ~E1000_MANC_EN_MNG2HOST;  		E1000_WRITE_REG(&adapter->hw, E1000_MANC, manc); 	} }
comment|/*  * em_get_hw_control sets the {CTRL_EXT|FWSM}:DRV_LOAD bit.  * For ASF and Pass Through versions of f/w this means  * that the driver is loaded. For AMT version type f/w  * this means that the network i/f is open.  */
argument|static void em_get_hw_control(struct adapter *adapter) { 	u32 ctrl_ext, swsm;  	if (adapter->hw.mac.type == e1000_82573) { 		swsm = E1000_READ_REG(&adapter->hw, E1000_SWSM); 		E1000_WRITE_REG(&adapter->hw, E1000_SWSM, 		    swsm | E1000_SWSM_DRV_LOAD); 		return; 	}
comment|/* else */
argument|ctrl_ext = E1000_READ_REG(&adapter->hw, E1000_CTRL_EXT); 	E1000_WRITE_REG(&adapter->hw, E1000_CTRL_EXT, 	    ctrl_ext | E1000_CTRL_EXT_DRV_LOAD); 	return; }
comment|/*  * em_release_hw_control resets {CTRL_EXT|FWSM}:DRV_LOAD bit.  * For ASF and Pass Through versions of f/w this means that  * the driver is no longer loaded. For AMT versions of the  * f/w this means that the network i/f is closed.  */
argument|static void em_release_hw_control(struct adapter *adapter) { 	u32 ctrl_ext, swsm;  	if (!adapter->has_manage) 		return;  	if (adapter->hw.mac.type == e1000_82573) { 		swsm = E1000_READ_REG(&adapter->hw, E1000_SWSM); 		E1000_WRITE_REG(&adapter->hw, E1000_SWSM, 		    swsm& ~E1000_SWSM_DRV_LOAD); 		return; 	}
comment|/* else */
argument|ctrl_ext = E1000_READ_REG(&adapter->hw, E1000_CTRL_EXT); 	E1000_WRITE_REG(&adapter->hw, E1000_CTRL_EXT, 	    ctrl_ext& ~E1000_CTRL_EXT_DRV_LOAD); 	return; }  static int em_is_valid_ether_addr(u8 *addr) { 	char zero_addr[
literal|6
argument|] = {
literal|0
argument|,
literal|0
argument|,
literal|0
argument|,
literal|0
argument|,
literal|0
argument|,
literal|0
argument|};  	if ((addr[
literal|0
argument|]&
literal|1
argument|) || (!bcmp(addr, zero_addr, ETHER_ADDR_LEN))) { 		return (FALSE); 	}  	return (TRUE); }
comment|/* ** Parse the interface capabilities with regard ** to both system management and wake-on-lan for ** later use. */
argument|static void em_get_wakeup(device_t dev) { 	struct adapter	*adapter = device_get_softc(dev); 	u16		eeprom_data =
literal|0
argument|, device_id, apme_mask;  	adapter->has_manage = e1000_enable_mng_pass_thru(&adapter->hw); 	apme_mask = EM_EEPROM_APME;  	switch (adapter->hw.mac.type) { 	case e1000_82542: 	case e1000_82543: 		break; 	case e1000_82544: 		e1000_read_nvm(&adapter->hw, 		    NVM_INIT_CONTROL2_REG,
literal|1
argument|,&eeprom_data); 		apme_mask = EM_82544_APME; 		break; 	case e1000_82573: 	case e1000_82583: 		adapter->has_amt = TRUE;
comment|/* Falls thru */
argument|case e1000_82546: 	case e1000_82546_rev_3: 	case e1000_82571: 	case e1000_82572: 	case e1000_80003es2lan: 		if (adapter->hw.bus.func ==
literal|1
argument|) { 			e1000_read_nvm(&adapter->hw, 			    NVM_INIT_CONTROL3_PORT_B,
literal|1
argument|,&eeprom_data); 			break; 		} else 			e1000_read_nvm(&adapter->hw, 			    NVM_INIT_CONTROL3_PORT_A,
literal|1
argument|,&eeprom_data); 		break; 	case e1000_ich8lan: 	case e1000_ich9lan: 	case e1000_ich10lan: 	case e1000_pchlan: 		apme_mask = E1000_WUC_APME; 		adapter->has_amt = TRUE; 		eeprom_data = E1000_READ_REG(&adapter->hw, E1000_WUC); 		break; 	default: 		e1000_read_nvm(&adapter->hw, 		    NVM_INIT_CONTROL3_PORT_A,
literal|1
argument|,&eeprom_data); 		break; 	} 	if (eeprom_data& apme_mask) 		adapter->wol = (E1000_WUFC_MAG | E1000_WUFC_MC);
comment|/*          * We have the eeprom settings, now apply the special cases          * where the eeprom may be wrong or the board won't support          * wake on lan on a particular port 	 */
argument|device_id = pci_get_device(dev);         switch (device_id) { 	case E1000_DEV_ID_82546GB_PCIE: 		adapter->wol =
literal|0
argument|; 		break; 	case E1000_DEV_ID_82546EB_FIBER: 	case E1000_DEV_ID_82546GB_FIBER: 	case E1000_DEV_ID_82571EB_FIBER:
comment|/* Wake events only supported on port A for dual fiber 		 * regardless of eeprom setting */
argument|if (E1000_READ_REG(&adapter->hw, E1000_STATUS)& 		    E1000_STATUS_FUNC_1) 			adapter->wol =
literal|0
argument|; 		break; 	case E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3: 	case E1000_DEV_ID_82571EB_QUAD_COPPER: 	case E1000_DEV_ID_82571EB_QUAD_FIBER: 	case E1000_DEV_ID_82571EB_QUAD_COPPER_LP:
comment|/* if quad port adapter, disable WoL on all but port A */
argument|if (global_quad_port_a !=
literal|0
argument|) 			adapter->wol =
literal|0
argument|;
comment|/* Reset for multiple quad port adapters */
argument|if (++global_quad_port_a ==
literal|4
argument|) 			global_quad_port_a =
literal|0
argument|;                 break; 	} 	return; }
comment|/*  * Enable PCI Wake On Lan capability  */
argument|void em_enable_wakeup(device_t dev) { 	struct adapter	*adapter = device_get_softc(dev); 	struct ifnet	*ifp = adapter->ifp; 	u32		pmc, ctrl, ctrl_ext, rctl; 	u16     	status;  	if ((pci_find_extcap(dev, PCIY_PMG,&pmc) !=
literal|0
argument|)) 		return;
comment|/* Advertise the wakeup capability */
argument|ctrl = E1000_READ_REG(&adapter->hw, E1000_CTRL); 	ctrl |= (E1000_CTRL_SWDPIN2 | E1000_CTRL_SWDPIN3); 	E1000_WRITE_REG(&adapter->hw, E1000_CTRL, ctrl); 	E1000_WRITE_REG(&adapter->hw, E1000_WUC, E1000_WUC_PME_EN);
comment|/* ICH workaround code */
argument|if ((adapter->hw.mac.type == e1000_ich8lan) || 	    (adapter->hw.mac.type == e1000_pchlan) || 	    (adapter->hw.mac.type == e1000_ich9lan) || 	    (adapter->hw.mac.type == e1000_ich10lan)) { 		e1000_disable_gig_wol_ich8lan(&adapter->hw); 		e1000_hv_phy_powerdown_workaround_ich8lan(&adapter->hw); 	}
comment|/* Keep the laser running on Fiber adapters */
argument|if (adapter->hw.phy.media_type == e1000_media_type_fiber || 	    adapter->hw.phy.media_type == e1000_media_type_internal_serdes) { 		ctrl_ext = E1000_READ_REG(&adapter->hw, E1000_CTRL_EXT); 		ctrl_ext |= E1000_CTRL_EXT_SDP3_DATA; 		E1000_WRITE_REG(&adapter->hw, E1000_CTRL_EXT, ctrl_ext); 	}
comment|/* 	** Determine type of Wakeup: note that wol 	** is set with all bits on by default. 	*/
argument|if ((ifp->if_capenable& IFCAP_WOL_MAGIC) ==
literal|0
argument|) 		adapter->wol&= ~E1000_WUFC_MAG;  	if ((ifp->if_capenable& IFCAP_WOL_MCAST) ==
literal|0
argument|) 		adapter->wol&= ~E1000_WUFC_MC; 	else { 		rctl = E1000_READ_REG(&adapter->hw, E1000_RCTL); 		rctl |= E1000_RCTL_MPE; 		E1000_WRITE_REG(&adapter->hw, E1000_RCTL, rctl); 	}  	if (adapter->hw.mac.type == e1000_pchlan) { 		if (em_enable_phy_wakeup(adapter)) 			return; 	} else { 		E1000_WRITE_REG(&adapter->hw, E1000_WUC, E1000_WUC_PME_EN); 		E1000_WRITE_REG(&adapter->hw, E1000_WUFC, adapter->wol); 	}  	if (adapter->hw.phy.type == e1000_phy_igp_3) 		e1000_igp3_phy_powerdown_workaround_ich8lan(&adapter->hw);
comment|/* Request PME */
argument|status = pci_read_config(dev, pmc + PCIR_POWER_STATUS,
literal|2
argument|); 	status&= ~(PCIM_PSTAT_PME | PCIM_PSTAT_PMEENABLE); 	if (ifp->if_capenable& IFCAP_WOL) 		status |= PCIM_PSTAT_PME | PCIM_PSTAT_PMEENABLE;         pci_write_config(dev, pmc + PCIR_POWER_STATUS, status,
literal|2
argument|);  	return; }
comment|/* ** WOL in the newer chipset interfaces (pchlan) ** require thing to be copied into the phy */
argument|static int em_enable_phy_wakeup(struct adapter *adapter) { 	struct e1000_hw *hw =&adapter->hw; 	u32 mreg, ret =
literal|0
argument|; 	u16 preg;
comment|/* copy MAC RARs to PHY RARs */
argument|for (int i =
literal|0
argument|; i< adapter->hw.mac.rar_entry_count; i++) { 		mreg = E1000_READ_REG(hw, E1000_RAL(i)); 		e1000_write_phy_reg(hw, BM_RAR_L(i), (u16)(mreg&
literal|0xFFFF
argument|)); 		e1000_write_phy_reg(hw, BM_RAR_M(i), 		    (u16)((mreg>>
literal|16
argument|)&
literal|0xFFFF
argument|)); 		mreg = E1000_READ_REG(hw, E1000_RAH(i)); 		e1000_write_phy_reg(hw, BM_RAR_H(i), (u16)(mreg&
literal|0xFFFF
argument|)); 		e1000_write_phy_reg(hw, BM_RAR_CTRL(i), 		    (u16)((mreg>>
literal|16
argument|)&
literal|0xFFFF
argument|)); 	}
comment|/* copy MAC MTA to PHY MTA */
argument|for (int i =
literal|0
argument|; i< adapter->hw.mac.mta_reg_count; i++) { 		mreg = E1000_READ_REG_ARRAY(hw, E1000_MTA, i); 		e1000_write_phy_reg(hw, BM_MTA(i), (u16)(mreg&
literal|0xFFFF
argument|)); 		e1000_write_phy_reg(hw, BM_MTA(i) +
literal|1
argument|, 		    (u16)((mreg>>
literal|16
argument|)&
literal|0xFFFF
argument|)); 	}
comment|/* configure PHY Rx Control register */
argument|e1000_read_phy_reg(&adapter->hw, BM_RCTL,&preg); 	mreg = E1000_READ_REG(hw, E1000_RCTL); 	if (mreg& E1000_RCTL_UPE) 		preg |= BM_RCTL_UPE; 	if (mreg& E1000_RCTL_MPE) 		preg |= BM_RCTL_MPE; 	preg&= ~(BM_RCTL_MO_MASK); 	if (mreg& E1000_RCTL_MO_3) 		preg |= (((mreg& E1000_RCTL_MO_3)>> E1000_RCTL_MO_SHIFT)<< BM_RCTL_MO_SHIFT); 	if (mreg& E1000_RCTL_BAM) 		preg |= BM_RCTL_BAM; 	if (mreg& E1000_RCTL_PMCF) 		preg |= BM_RCTL_PMCF; 	mreg = E1000_READ_REG(hw, E1000_CTRL); 	if (mreg& E1000_CTRL_RFCE) 		preg |= BM_RCTL_RFCE; 	e1000_write_phy_reg(&adapter->hw, BM_RCTL, preg);
comment|/* enable PHY wakeup in MAC register */
argument|E1000_WRITE_REG(hw, E1000_WUC, 	    E1000_WUC_PHY_WAKE | E1000_WUC_PME_EN); 	E1000_WRITE_REG(hw, E1000_WUFC, adapter->wol);
comment|/* configure and enable PHY wakeup in PHY registers */
argument|e1000_write_phy_reg(&adapter->hw, BM_WUFC, adapter->wol); 	e1000_write_phy_reg(&adapter->hw, BM_WUC, E1000_WUC_PME_EN);
comment|/* activate PHY wakeup */
argument|ret = hw->phy.ops.acquire(hw); 	if (ret) { 		printf(
literal|"Could not acquire PHY\n"
argument|); 		return ret; 	} 	e1000_write_phy_reg_mdic(hw, IGP01E1000_PHY_PAGE_SELECT, 	                         (BM_WUC_ENABLE_PAGE<< IGP_PAGE_SHIFT)); 	ret = e1000_read_phy_reg_mdic(hw, BM_WUC_ENABLE_REG,&preg); 	if (ret) { 		printf(
literal|"Could not read PHY page 769\n"
argument|); 		goto out; 	} 	preg |= BM_WUC_ENABLE_BIT | BM_WUC_HOST_WU_BIT; 	ret = e1000_write_phy_reg_mdic(hw, BM_WUC_ENABLE_REG, preg); 	if (ret) 		printf(
literal|"Could not set PHY Host Wakeup bit\n"
argument|); out: 	hw->phy.ops.release(hw);  	return ret; }
comment|/********************************************************************* * 82544 Coexistence issue workaround. *    There are 2 issues. *       1. Transmit Hang issue. *    To detect this issue, following equation can be used... *	  SIZE[3:0] + ADDR[2:0] = SUM[3:0]. *	  If SUM[3:0] is in between 1 to 4, we will have this issue. * *       2. DAC issue. *    To detect this issue, following equation can be used... *	  SIZE[3:0] + ADDR[2:0] = SUM[3:0]. *	  If SUM[3:0] is in between 9 to c, we will have this issue. * * *    WORKAROUND: *	  Make sure we do not have ending address *	  as 1,2,3,4(Hang) or 9,a,b,c (DAC) * *************************************************************************/
argument|static u32 em_fill_descriptors (bus_addr_t address, u32 length, 		PDESC_ARRAY desc_array) { 	u32 safe_terminator;
comment|/* Since issue is sensitive to length and address.*/
comment|/* Let us first check the address...*/
argument|if (length<=
literal|4
argument|) { 		desc_array->descriptor[
literal|0
argument|].address = address; 		desc_array->descriptor[
literal|0
argument|].length = length; 		desc_array->elements =
literal|1
argument|; 		return (desc_array->elements); 	} 	safe_terminator = (u32)((((u32)address&
literal|0x7
argument|) + 	    (length&
literal|0xF
argument|))&
literal|0xF
argument|);
comment|/* if it does not fall between 0x1 to 0x4 and 0x9 to 0xC then return */
argument|if (safe_terminator ==
literal|0
argument||| 	(safe_terminator>
literal|4
argument|&& 	safe_terminator<
literal|9
argument|)   || 	(safe_terminator>
literal|0xC
argument|&& 	safe_terminator<=
literal|0xF
argument|)) { 		desc_array->descriptor[
literal|0
argument|].address = address; 		desc_array->descriptor[
literal|0
argument|].length = length; 		desc_array->elements =
literal|1
argument|; 		return (desc_array->elements); 	}  	desc_array->descriptor[
literal|0
argument|].address = address; 	desc_array->descriptor[
literal|0
argument|].length = length -
literal|4
argument|; 	desc_array->descriptor[
literal|1
argument|].address = address + (length -
literal|4
argument|); 	desc_array->descriptor[
literal|1
argument|].length =
literal|4
argument|; 	desc_array->elements =
literal|2
argument|; 	return (desc_array->elements); }
comment|/**********************************************************************  *  *  Update the board statistics counters.  *  **********************************************************************/
argument|static void em_update_stats_counters(struct adapter *adapter) { 	struct ifnet   *ifp;  	if(adapter->hw.phy.media_type == e1000_media_type_copper || 	   (E1000_READ_REG(&adapter->hw, E1000_STATUS)& E1000_STATUS_LU)) { 		adapter->stats.symerrs += E1000_READ_REG(&adapter->hw, E1000_SYMERRS); 		adapter->stats.sec += E1000_READ_REG(&adapter->hw, E1000_SEC); 	} 	adapter->stats.crcerrs += E1000_READ_REG(&adapter->hw, E1000_CRCERRS); 	adapter->stats.mpc += E1000_READ_REG(&adapter->hw, E1000_MPC); 	adapter->stats.scc += E1000_READ_REG(&adapter->hw, E1000_SCC); 	adapter->stats.ecol += E1000_READ_REG(&adapter->hw, E1000_ECOL);  	adapter->stats.mcc += E1000_READ_REG(&adapter->hw, E1000_MCC); 	adapter->stats.latecol += E1000_READ_REG(&adapter->hw, E1000_LATECOL); 	adapter->stats.colc += E1000_READ_REG(&adapter->hw, E1000_COLC); 	adapter->stats.dc += E1000_READ_REG(&adapter->hw, E1000_DC); 	adapter->stats.rlec += E1000_READ_REG(&adapter->hw, E1000_RLEC); 	adapter->stats.xonrxc += E1000_READ_REG(&adapter->hw, E1000_XONRXC); 	adapter->stats.xontxc += E1000_READ_REG(&adapter->hw, E1000_XONTXC); 	adapter->stats.xoffrxc += E1000_READ_REG(&adapter->hw, E1000_XOFFRXC); 	adapter->stats.xofftxc += E1000_READ_REG(&adapter->hw, E1000_XOFFTXC); 	adapter->stats.fcruc += E1000_READ_REG(&adapter->hw, E1000_FCRUC); 	adapter->stats.prc64 += E1000_READ_REG(&adapter->hw, E1000_PRC64); 	adapter->stats.prc127 += E1000_READ_REG(&adapter->hw, E1000_PRC127); 	adapter->stats.prc255 += E1000_READ_REG(&adapter->hw, E1000_PRC255); 	adapter->stats.prc511 += E1000_READ_REG(&adapter->hw, E1000_PRC511); 	adapter->stats.prc1023 += E1000_READ_REG(&adapter->hw, E1000_PRC1023); 	adapter->stats.prc1522 += E1000_READ_REG(&adapter->hw, E1000_PRC1522); 	adapter->stats.gprc += E1000_READ_REG(&adapter->hw, E1000_GPRC); 	adapter->stats.bprc += E1000_READ_REG(&adapter->hw, E1000_BPRC); 	adapter->stats.mprc += E1000_READ_REG(&adapter->hw, E1000_MPRC); 	adapter->stats.gptc += E1000_READ_REG(&adapter->hw, E1000_GPTC);
comment|/* For the 64-bit byte counters the low dword must be read first. */
comment|/* Both registers clear on the read of the high dword */
argument|adapter->stats.gorc += E1000_READ_REG(&adapter->hw, E1000_GORCH); 	adapter->stats.gotc += E1000_READ_REG(&adapter->hw, E1000_GOTCH);  	adapter->stats.rnbc += E1000_READ_REG(&adapter->hw, E1000_RNBC); 	adapter->stats.ruc += E1000_READ_REG(&adapter->hw, E1000_RUC); 	adapter->stats.rfc += E1000_READ_REG(&adapter->hw, E1000_RFC); 	adapter->stats.roc += E1000_READ_REG(&adapter->hw, E1000_ROC); 	adapter->stats.rjc += E1000_READ_REG(&adapter->hw, E1000_RJC);  	adapter->stats.tor += E1000_READ_REG(&adapter->hw, E1000_TORH); 	adapter->stats.tot += E1000_READ_REG(&adapter->hw, E1000_TOTH);  	adapter->stats.tpr += E1000_READ_REG(&adapter->hw, E1000_TPR); 	adapter->stats.tpt += E1000_READ_REG(&adapter->hw, E1000_TPT); 	adapter->stats.ptc64 += E1000_READ_REG(&adapter->hw, E1000_PTC64); 	adapter->stats.ptc127 += E1000_READ_REG(&adapter->hw, E1000_PTC127); 	adapter->stats.ptc255 += E1000_READ_REG(&adapter->hw, E1000_PTC255); 	adapter->stats.ptc511 += E1000_READ_REG(&adapter->hw, E1000_PTC511); 	adapter->stats.ptc1023 += E1000_READ_REG(&adapter->hw, E1000_PTC1023); 	adapter->stats.ptc1522 += E1000_READ_REG(&adapter->hw, E1000_PTC1522); 	adapter->stats.mptc += E1000_READ_REG(&adapter->hw, E1000_MPTC); 	adapter->stats.bptc += E1000_READ_REG(&adapter->hw, E1000_BPTC);  	if (adapter->hw.mac.type>= e1000_82543) { 		adapter->stats.algnerrc +=  		E1000_READ_REG(&adapter->hw, E1000_ALGNERRC); 		adapter->stats.rxerrc +=  		E1000_READ_REG(&adapter->hw, E1000_RXERRC); 		adapter->stats.tncrs +=  		E1000_READ_REG(&adapter->hw, E1000_TNCRS); 		adapter->stats.cexterr +=  		E1000_READ_REG(&adapter->hw, E1000_CEXTERR); 		adapter->stats.tsctc +=  		E1000_READ_REG(&adapter->hw, E1000_TSCTC); 		adapter->stats.tsctfc +=  		E1000_READ_REG(&adapter->hw, E1000_TSCTFC); 	} 	ifp = adapter->ifp;  	ifp->if_collisions = adapter->stats.colc;
comment|/* Rx Errors */
argument|ifp->if_ierrors = adapter->dropped_pkts + adapter->stats.rxerrc + 	    adapter->stats.crcerrs + adapter->stats.algnerrc + 	    adapter->stats.ruc + adapter->stats.roc + 	    adapter->stats.mpc + adapter->stats.cexterr;
comment|/* Tx Errors */
argument|ifp->if_oerrors = adapter->stats.ecol + 	    adapter->stats.latecol + adapter->watchdog_events; }
comment|/**********************************************************************  *  *  This routine is called only when em_display_debug_stats is enabled.  *  This routine provides a way to take a look at important statistics  *  maintained by the driver and hardware.  *  **********************************************************************/
argument|static void em_print_debug_info(struct adapter *adapter) { 	device_t dev = adapter->dev; 	u8 *hw_addr = adapter->hw.hw_addr;  	device_printf(dev,
literal|"Adapter hardware address = %p \n"
argument|, hw_addr); 	device_printf(dev,
literal|"CTRL = 0x%x RCTL = 0x%x \n"
argument|, 	    E1000_READ_REG(&adapter->hw, E1000_CTRL), 	    E1000_READ_REG(&adapter->hw, E1000_RCTL)); 	device_printf(dev,
literal|"Packet buffer = Tx=%dk Rx=%dk \n"
argument|, 	    ((E1000_READ_REG(&adapter->hw, E1000_PBA)&
literal|0xffff0000
argument|)>>
literal|16
argument|),\ 	    (E1000_READ_REG(&adapter->hw, E1000_PBA)&
literal|0xffff
argument|) ); 	device_printf(dev,
literal|"Flow control watermarks high = %d low = %d\n"
argument|, 	    adapter->hw.fc.high_water, 	    adapter->hw.fc.low_water); 	device_printf(dev,
literal|"tx_int_delay = %d, tx_abs_int_delay = %d\n"
argument|, 	    E1000_READ_REG(&adapter->hw, E1000_TIDV), 	    E1000_READ_REG(&adapter->hw, E1000_TADV)); 	device_printf(dev,
literal|"rx_int_delay = %d, rx_abs_int_delay = %d\n"
argument|, 	    E1000_READ_REG(&adapter->hw, E1000_RDTR), 	    E1000_READ_REG(&adapter->hw, E1000_RADV)); 	device_printf(dev,
literal|"fifo workaround = %lld, fifo_reset_count = %lld\n"
argument|, 	    (long long)adapter->tx_fifo_wrk_cnt, 	    (long long)adapter->tx_fifo_reset_cnt); 	device_printf(dev,
literal|"hw tdh = %d, hw tdt = %d\n"
argument|, 	    E1000_READ_REG(&adapter->hw, E1000_TDH(
literal|0
argument|)), 	    E1000_READ_REG(&adapter->hw, E1000_TDT(
literal|0
argument|))); 	device_printf(dev,
literal|"hw rdh = %d, hw rdt = %d\n"
argument|, 	    E1000_READ_REG(&adapter->hw, E1000_RDH(
literal|0
argument|)), 	    E1000_READ_REG(&adapter->hw, E1000_RDT(
literal|0
argument|))); 	device_printf(dev,
literal|"Num Tx descriptors avail = %d\n"
argument|, 	    adapter->num_tx_desc_avail); 	device_printf(dev,
literal|"Tx Descriptors not avail1 = %ld\n"
argument|, 	    adapter->no_tx_desc_avail1); 	device_printf(dev,
literal|"Tx Descriptors not avail2 = %ld\n"
argument|, 	    adapter->no_tx_desc_avail2); 	device_printf(dev,
literal|"Std mbuf failed = %ld\n"
argument|, 	    adapter->mbuf_alloc_failed); 	device_printf(dev,
literal|"Std mbuf cluster failed = %ld\n"
argument|, 	    adapter->mbuf_cluster_failed); 	device_printf(dev,
literal|"Driver dropped packets = %ld\n"
argument|, 	    adapter->dropped_pkts); 	device_printf(dev,
literal|"Driver tx dma failure in encap = %ld\n"
argument|, 		adapter->no_tx_dma_setup); }  static void em_print_hw_stats(struct adapter *adapter) { 	device_t dev = adapter->dev;  	device_printf(dev,
literal|"Excessive collisions = %lld\n"
argument|, 	    (long long)adapter->stats.ecol);
if|#
directive|if
operator|(
name|DEBUG_HW
operator|>
literal|0
operator|)
comment|/* Dont output these errors normally */
argument|device_printf(dev,
literal|"Symbol errors = %lld\n"
argument|, 	    (long long)adapter->stats.symerrs);
endif|#
directive|endif
argument|device_printf(dev,
literal|"Sequence errors = %lld\n"
argument|, 	    (long long)adapter->stats.sec); 	device_printf(dev,
literal|"Defer count = %lld\n"
argument|, 	    (long long)adapter->stats.dc); 	device_printf(dev,
literal|"Missed Packets = %lld\n"
argument|, 	    (long long)adapter->stats.mpc); 	device_printf(dev,
literal|"Receive No Buffers = %lld\n"
argument|, 	    (long long)adapter->stats.rnbc);
comment|/* RLEC is inaccurate on some hardware, calculate our own. */
argument|device_printf(dev,
literal|"Receive Length Errors = %lld\n"
argument|, 	    ((long long)adapter->stats.roc + (long long)adapter->stats.ruc)); 	device_printf(dev,
literal|"Receive errors = %lld\n"
argument|, 	    (long long)adapter->stats.rxerrc); 	device_printf(dev,
literal|"Crc errors = %lld\n"
argument|, 	    (long long)adapter->stats.crcerrs); 	device_printf(dev,
literal|"Alignment errors = %lld\n"
argument|, 	    (long long)adapter->stats.algnerrc); 	device_printf(dev,
literal|"Collision/Carrier extension errors = %lld\n"
argument|, 	    (long long)adapter->stats.cexterr); 	device_printf(dev,
literal|"RX overruns = %ld\n"
argument|, adapter->rx_overruns); 	device_printf(dev,
literal|"watchdog timeouts = %ld\n"
argument|, 	    adapter->watchdog_events); 	device_printf(dev,
literal|"RX MSIX IRQ = %ld TX MSIX IRQ = %ld"
literal|" LINK MSIX IRQ = %ld\n"
argument|, adapter->rx_irq, 	    adapter->tx_irq , adapter->link_irq); 	device_printf(dev,
literal|"XON Rcvd = %lld\n"
argument|, 	    (long long)adapter->stats.xonrxc); 	device_printf(dev,
literal|"XON Xmtd = %lld\n"
argument|, 	    (long long)adapter->stats.xontxc); 	device_printf(dev,
literal|"XOFF Rcvd = %lld\n"
argument|, 	    (long long)adapter->stats.xoffrxc); 	device_printf(dev,
literal|"XOFF Xmtd = %lld\n"
argument|, 	    (long long)adapter->stats.xofftxc); 	device_printf(dev,
literal|"Good Packets Rcvd = %lld\n"
argument|, 	    (long long)adapter->stats.gprc); 	device_printf(dev,
literal|"Good Packets Xmtd = %lld\n"
argument|, 	    (long long)adapter->stats.gptc); 	device_printf(dev,
literal|"TSO Contexts Xmtd = %lld\n"
argument|, 	    (long long)adapter->stats.tsctc); 	device_printf(dev,
literal|"TSO Contexts Failed = %lld\n"
argument|, 	    (long long)adapter->stats.tsctfc); }
comment|/**********************************************************************  *  *  This routine provides a way to dump out the adapter eeprom,  *  often a useful debug/service tool. This only dumps the first  *  32 words, stuff that matters is in that extent.  *  **********************************************************************/
argument|static void em_print_nvm_info(struct adapter *adapter) { 	u16	eeprom_data; 	int	i, j, row =
literal|0
argument|;
comment|/* Its a bit crude, but it gets the job done */
argument|printf(
literal|"\nInterface EEPROM Dump:\n"
argument|); 	printf(
literal|"Offset\n0x0000  "
argument|); 	for (i =
literal|0
argument|, j =
literal|0
argument|; i<
literal|32
argument|; i++, j++) { 		if (j ==
literal|8
argument|) {
comment|/* Make the offset block */
argument|j =
literal|0
argument|; ++row; 			printf(
literal|"\n0x00%x0  "
argument|,row); 		} 		e1000_read_nvm(&adapter->hw, i,
literal|1
argument|,&eeprom_data); 		printf(
literal|"%04x "
argument|, eeprom_data); 	} 	printf(
literal|"\n"
argument|); }  static int em_sysctl_debug_info(SYSCTL_HANDLER_ARGS) { 	struct adapter *adapter; 	int error; 	int result;  	result = -
literal|1
argument|; 	error = sysctl_handle_int(oidp,&result,
literal|0
argument|, req);  	if (error || !req->newptr) 		return (error);  	if (result ==
literal|1
argument|) { 		adapter = (struct adapter *)arg1; 		em_print_debug_info(adapter); 	}
comment|/* 	 * This value will cause a hex dump of the 	 * first 32 16-bit words of the EEPROM to 	 * the screen. 	 */
argument|if (result ==
literal|2
argument|) { 		adapter = (struct adapter *)arg1; 		em_print_nvm_info(adapter);         }  	return (error); }   static int em_sysctl_stats(SYSCTL_HANDLER_ARGS) { 	struct adapter *adapter; 	int error; 	int result;  	result = -
literal|1
argument|; 	error = sysctl_handle_int(oidp,&result,
literal|0
argument|, req);  	if (error || !req->newptr) 		return (error);  	if (result ==
literal|1
argument|) { 		adapter = (struct adapter *)arg1; 		em_print_hw_stats(adapter); 	}  	return (error); }  static int em_sysctl_int_delay(SYSCTL_HANDLER_ARGS) { 	struct em_int_delay_info *info; 	struct adapter *adapter; 	u32 regval; 	int error; 	int usecs; 	int ticks;  	info = (struct em_int_delay_info *)arg1; 	usecs = info->value; 	error = sysctl_handle_int(oidp,&usecs,
literal|0
argument|, req); 	if (error !=
literal|0
argument||| req->newptr == NULL) 		return (error); 	if (usecs<
literal|0
argument||| usecs> EM_TICKS_TO_USECS(
literal|65535
argument|)) 		return (EINVAL); 	info->value = usecs; 	ticks = EM_USECS_TO_TICKS(usecs);  	adapter = info->adapter; 	 	EM_CORE_LOCK(adapter); 	regval = E1000_READ_OFFSET(&adapter->hw, info->offset); 	regval = (regval& ~
literal|0xffff
argument|) | (ticks&
literal|0xffff
argument|);
comment|/* Handle a few special cases. */
argument|switch (info->offset) { 	case E1000_RDTR: 		break; 	case E1000_TIDV: 		if (ticks ==
literal|0
argument|) { 			adapter->txd_cmd&= ~E1000_TXD_CMD_IDE;
comment|/* Don't write 0 into the TIDV register. */
argument|regval++; 		} else 			adapter->txd_cmd |= E1000_TXD_CMD_IDE; 		break; 	} 	E1000_WRITE_OFFSET(&adapter->hw, info->offset, regval); 	EM_CORE_UNLOCK(adapter); 	return (
literal|0
argument|); }  static void em_add_int_delay_sysctl(struct adapter *adapter, const char *name, 	const char *description, struct em_int_delay_info *info, 	int offset, int value) { 	info->adapter = adapter; 	info->offset = offset; 	info->value = value; 	SYSCTL_ADD_PROC(device_get_sysctl_ctx(adapter->dev), 	    SYSCTL_CHILDREN(device_get_sysctl_tree(adapter->dev)), 	    OID_AUTO, name, CTLTYPE_INT|CTLFLAG_RW, 	    info,
literal|0
argument|, em_sysctl_int_delay,
literal|"I"
argument|, description); }
ifndef|#
directive|ifndef
name|EM_LEGACY_IRQ
argument|static void em_add_rx_process_limit(struct adapter *adapter, const char *name, 	const char *description, int *limit, int value) { 	*limit = value; 	SYSCTL_ADD_INT(device_get_sysctl_ctx(adapter->dev), 	    SYSCTL_CHILDREN(device_get_sysctl_tree(adapter->dev)), 	    OID_AUTO, name, CTLTYPE_INT|CTLFLAG_RW, limit, value, description); }
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

