begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_comment
comment|/* 82562G 10/100 Network Connection  * 82562G-2 10/100 Network Connection  * 82562GT 10/100 Network Connection  * 82562GT-2 10/100 Network Connection  * 82562V 10/100 Network Connection  * 82562V-2 10/100 Network Connection  * 82566DC-2 Gigabit Network Connection  * 82566DC Gigabit Network Connection  * 82566DM-2 Gigabit Network Connection  * 82566DM Gigabit Network Connection  * 82566MC Gigabit Network Connection  * 82566MM Gigabit Network Connection  * 82567LM Gigabit Network Connection  * 82567LF Gigabit Network Connection  * 82567V Gigabit Network Connection  * 82567LM-2 Gigabit Network Connection  * 82567LF-2 Gigabit Network Connection  * 82567V-2 Gigabit Network Connection  * 82567LF-3 Gigabit Network Connection  * 82567LM-3 Gigabit Network Connection  * 82567LM-4 Gigabit Network Connection  * 82577LM Gigabit Network Connection  * 82577LC Gigabit Network Connection  * 82578DM Gigabit Network Connection  * 82578DC Gigabit Network Connection  * 82579LM Gigabit Network Connection  * 82579V Gigabit Network Connection  * Ethernet Connection I217-LM  * Ethernet Connection I217-V  * Ethernet Connection I218-V  * Ethernet Connection I218-LM  * Ethernet Connection (2) I218-LM  * Ethernet Connection (2) I218-V  * Ethernet Connection (3) I218-LM  * Ethernet Connection (3) I218-V  */
end_comment

begin_include
include|#
directive|include
file|"e1000_api.h"
end_include

begin_function_decl
specifier|static
name|s32
name|e1000_acquire_swflag_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_release_swflag_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_acquire_nvm_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_release_nvm_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|e1000_check_mng_mode_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|e1000_check_mng_mode_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|e1000_rar_set_pch2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|e1000_rar_set_pch_lpt
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_sw_lcd_config_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_update_mc_addr_list_pch2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr_list
parameter_list|,
name|u32
name|mc_addr_count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_check_reset_block_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_phy_hw_reset_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_set_lplu_state_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_set_d0_lplu_state_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_set_d3_lplu_state_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_read_nvm_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_read_nvm_spt
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_write_nvm_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_validate_nvm_checksum_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_update_nvm_checksum_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_update_nvm_checksum_spt
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_valid_led_default_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_id_led_init_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_bus_info_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_reset_hw_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_init_hw_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_setup_link_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_setup_copper_link_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_setup_copper_link_pch_lpt
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_link_up_info_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_cleanup_led_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_led_on_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_led_off_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_k1_gig_workaround_hv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|link
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_setup_led_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_cleanup_led_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_led_on_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_led_off_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_clear_hw_cntrs_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_erase_flash_bank_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|bank
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_initialize_hw_bits_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_kmrn_lock_loss_workaround_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_read_flash_byte_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_read_flash_data_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|size
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_read_flash_data32_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_read_flash_dword_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_write_flash_data32_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_retry_write_flash_dword_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|dword
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_read_flash_word_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_retry_write_flash_byte_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|byte
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_cfg_done_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_power_down_phy_copper_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_check_for_copper_link_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_set_mdio_slow_mode_hv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_k1_workaround_lv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_gate_hw_phy_config_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|gate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_set_obff_timer_pch_lpt
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|itr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ICH GbE Flash Hardware Sequencing Flash Status Register bit breakdown */
end_comment

begin_comment
comment|/* Offset 04h HSFSTS */
end_comment

begin_union
union|union
name|ich8_hws_flash_status
block|{
struct|struct
name|ich8_hsfsts
block|{
name|u16
name|flcdone
range|:
literal|1
decl_stmt|;
comment|/* bit 0 Flash Cycle Done */
name|u16
name|flcerr
range|:
literal|1
decl_stmt|;
comment|/* bit 1 Flash Cycle Error */
name|u16
name|dael
range|:
literal|1
decl_stmt|;
comment|/* bit 2 Direct Access error Log */
name|u16
name|berasesz
range|:
literal|2
decl_stmt|;
comment|/* bit 4:3 Sector Erase Size */
name|u16
name|flcinprog
range|:
literal|1
decl_stmt|;
comment|/* bit 5 flash cycle in Progress */
name|u16
name|reserved1
range|:
literal|2
decl_stmt|;
comment|/* bit 13:6 Reserved */
name|u16
name|reserved2
range|:
literal|6
decl_stmt|;
comment|/* bit 13:6 Reserved */
name|u16
name|fldesvalid
range|:
literal|1
decl_stmt|;
comment|/* bit 14 Flash Descriptor Valid */
name|u16
name|flockdn
range|:
literal|1
decl_stmt|;
comment|/* bit 15 Flash Config Lock-Down */
block|}
name|hsf_status
struct|;
name|u16
name|regval
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* ICH GbE Flash Hardware Sequencing Flash control Register bit breakdown */
end_comment

begin_comment
comment|/* Offset 06h FLCTL */
end_comment

begin_union
union|union
name|ich8_hws_flash_ctrl
block|{
struct|struct
name|ich8_hsflctl
block|{
name|u16
name|flcgo
range|:
literal|1
decl_stmt|;
comment|/* 0 Flash Cycle Go */
name|u16
name|flcycle
range|:
literal|2
decl_stmt|;
comment|/* 2:1 Flash Cycle */
name|u16
name|reserved
range|:
literal|5
decl_stmt|;
comment|/* 7:3 Reserved  */
name|u16
name|fldbcount
range|:
literal|2
decl_stmt|;
comment|/* 9:8 Flash Data Byte Count */
name|u16
name|flockdn
range|:
literal|6
decl_stmt|;
comment|/* 15:10 Reserved */
block|}
name|hsf_ctrl
struct|;
name|u16
name|regval
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* ICH Flash Region Access Permissions */
end_comment

begin_union
union|union
name|ich8_hws_flash_regacc
block|{
struct|struct
name|ich8_flracc
block|{
name|u32
name|grra
range|:
literal|8
decl_stmt|;
comment|/* 0:7 GbE region Read Access */
name|u32
name|grwa
range|:
literal|8
decl_stmt|;
comment|/* 8:15 GbE region Write Access */
name|u32
name|gmrag
range|:
literal|8
decl_stmt|;
comment|/* 23:16 GbE Master Read Access Grant */
name|u32
name|gmwag
range|:
literal|8
decl_stmt|;
comment|/* 31:24 GbE Master Write Access Grant */
block|}
name|hsf_flregacc
struct|;
name|u16
name|regval
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/**  *  e1000_phy_is_accessible_pchlan - Check if able to access PHY registers  *  @hw: pointer to the HW structure  *  *  Test access to the PHY registers by reading the PHY ID registers.  If  *  the PHY ID is already known (e.g. resume path) compare it with known ID,  *  otherwise assume the read PHY ID is correct if it is valid.  *  *  Assumes the sw/fw/hw semaphore is already acquired.  **/
end_comment

begin_function
specifier|static
name|bool
name|e1000_phy_is_accessible_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|phy_reg
init|=
literal|0
decl_stmt|;
name|u32
name|phy_id
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
literal|0
decl_stmt|;
name|u16
name|retry_count
decl_stmt|;
name|u32
name|mac_reg
init|=
literal|0
decl_stmt|;
for|for
control|(
name|retry_count
operator|=
literal|0
init|;
name|retry_count
operator|<
literal|2
condition|;
name|retry_count
operator|++
control|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|PHY_ID1
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|||
operator|(
name|phy_reg
operator|==
literal|0xFFFF
operator|)
condition|)
continue|continue;
name|phy_id
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_reg
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|PHY_ID2
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|||
operator|(
name|phy_reg
operator|==
literal|0xFFFF
operator|)
condition|)
block|{
name|phy_id
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|phy_id
operator||=
call|(
name|u32
call|)
argument_list|(
name|phy_reg
operator|&
name|PHY_REVISION_MASK
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|id
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|id
operator|==
name|phy_id
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|phy_id
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|id
operator|=
name|phy_id
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|revision
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_reg
operator|&
operator|~
name|PHY_REVISION_MASK
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* In case the PHY needs to be in mdio slow mode, 	 * set slow mode and try to get the PHY id again. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_pch_lpt
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_set_mdio_slow_mode_hv
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|ret_val
operator|=
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_val
condition|)
return|return
name|FALSE
return|;
name|out
label|:
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_lpt
condition|)
block|{
comment|/* Only unforce SMBus if ME is not active */
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
operator|&
name|E1000_ICH_FWSM_FW_VALID
operator|)
condition|)
block|{
comment|/* Unforce SMBus mode in PHY */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|CV_SMB_CTRL
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
name|phy_reg
operator|&=
operator|~
name|CV_SMB_CTRL_FORCE_SMBUS
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|CV_SMB_CTRL
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
comment|/* Unforce SMBus mode in MAC */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|mac_reg
operator|&=
operator|~
name|E1000_CTRL_EXT_FORCE_SMBUS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_toggle_lanphypc_pch_lpt - toggle the LANPHYPC pin value  *  @hw: pointer to the HW structure  *  *  Toggling the LANPHYPC pin value fully power-cycles the PHY and is  *  used to reset the PHY to a quiescent state when necessary.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_toggle_lanphypc_pch_lpt
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|mac_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_toggle_lanphypc_pch_lpt"
argument_list|)
expr_stmt|;
comment|/* Set Phy Config Counter to 50msec */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM3
argument_list|)
expr_stmt|;
name|mac_reg
operator|&=
operator|~
name|E1000_FEXTNVM3_PHY_CFG_COUNTER_MASK
expr_stmt|;
name|mac_reg
operator||=
name|E1000_FEXTNVM3_PHY_CFG_COUNTER_50MSEC
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM3
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
comment|/* Toggle LANPHYPC Value bit */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|mac_reg
operator||=
name|E1000_CTRL_LANPHYPC_OVERRIDE
expr_stmt|;
name|mac_reg
operator|&=
operator|~
name|E1000_CTRL_LANPHYPC_VALUE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|mac_reg
operator|&=
operator|~
name|E1000_CTRL_LANPHYPC_OVERRIDE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_pch_lpt
condition|)
block|{
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u16
name|count
init|=
literal|20
decl_stmt|;
do|do
block|{
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
operator|&
name|E1000_CTRL_EXT_LPCD
operator|)
operator|&&
name|count
operator|--
condition|)
do|;
name|msec_delay
argument_list|(
literal|30
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_init_phy_workarounds_pchlan - PHY initialization workarounds  *  @hw: pointer to the HW structure  *  *  Workarounds/flow necessary for PHY initialization during driver load  *  and resume paths.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_phy_workarounds_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|mac_reg
decl_stmt|,
name|fwsm
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_phy_workarounds_pchlan"
argument_list|)
expr_stmt|;
comment|/* Gate automatic PHY configuration by hardware on managed and 	 * non-managed 82579 and newer adapters. 	 */
name|e1000_gate_hw_phy_config_ich8lan
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* It is not possible to be certain of the current state of ULP 	 * so forcibly disable it. 	 */
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|ulp_state
operator|=
name|e1000_ulp_state_unknown
expr_stmt|;
name|e1000_disable_ulp_lpt_lp
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Failed to initialize PHY flow\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* The MAC-PHY interconnect may be in SMBus mode.  If the PHY is 	 * inaccessible and resetting the PHY is not blocked, toggle the 	 * LANPHYPC Value bit to force the interconnect to PCIe mode. 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_pch_lpt
case|:
case|case
name|e1000_pch_spt
case|:
if|if
condition|(
name|e1000_phy_is_accessible_pchlan
argument_list|(
name|hw
argument_list|)
condition|)
break|break;
comment|/* Before toggling LANPHYPC, see if PHY is accessible by 		 * forcing MAC to SMBus mode first. 		 */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|mac_reg
operator||=
name|E1000_CTRL_EXT_FORCE_SMBUS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
comment|/* Wait 50 milliseconds for MAC to finish any retries 		 * that it might be trying to perform from previous 		 * attempts to acknowledge any phy read requests. 		 */
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* fall-through */
case|case
name|e1000_pch2lan
case|:
if|if
condition|(
name|e1000_phy_is_accessible_pchlan
argument_list|(
name|hw
argument_list|)
condition|)
break|break;
comment|/* fall-through */
case|case
name|e1000_pchlan
case|:
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pchlan
operator|)
operator|&&
operator|(
name|fwsm
operator|&
name|E1000_ICH_FWSM_FW_VALID
operator|)
condition|)
break|break;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_reset_block
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Required LANPHYPC toggle blocked by ME\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
break|break;
block|}
comment|/* Toggle LANPHYPC Value bit */
name|e1000_toggle_lanphypc_pch_lpt
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_lpt
condition|)
block|{
if|if
condition|(
name|e1000_phy_is_accessible_pchlan
argument_list|(
name|hw
argument_list|)
condition|)
break|break;
comment|/* Toggling LANPHYPC brings the PHY out of SMBus mode 			 * so ensure that the MAC is also out of SMBus mode 			 */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|mac_reg
operator|&=
operator|~
name|E1000_CTRL_EXT_FORCE_SMBUS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1000_phy_is_accessible_pchlan
argument_list|(
name|hw
argument_list|)
condition|)
break|break;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
block|{
comment|/* Check to see if able to reset PHY.  Print error if not */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_reset_block
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|ERROR_REPORT
argument_list|(
literal|"Reset blocked by ME\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Reset the PHY before any access to it.  Doing so, ensures 		 * that the PHY is in a known good state before we read/write 		 * PHY registers.  The generic reset is sufficient here, 		 * because we haven't determined the PHY type yet. 		 */
name|ret_val
operator|=
name|e1000_phy_hw_reset_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* On a successful reset, possibly need to wait for the PHY 		 * to quiesce to an accessible state before returning control 		 * to the calling function.  If the PHY does not quiesce, then 		 * return E1000E_BLK_PHY_RESET, as this is the condition that 		 *  the PHY is in. 		 */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_reset_block
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|ERROR_REPORT
argument_list|(
literal|"ME blocked access to PHY after reset\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
comment|/* Ungate automatic PHY configuration on non-managed 82579 */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
operator|)
operator|&&
operator|!
operator|(
name|fwsm
operator|&
name|E1000_ICH_FWSM_FW_VALID
operator|)
condition|)
block|{
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|e1000_gate_hw_phy_config_ich8lan
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_phy_params_pchlan - Initialize PHY function pointers  *  @hw: pointer to the HW structure  *  *  Initialize family-specific PHY parameters and function pointers.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_phy_params_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_phy_params_pchlan"
argument_list|)
expr_stmt|;
name|phy
operator|->
name|addr
operator|=
literal|1
expr_stmt|;
name|phy
operator|->
name|reset_delay_us
operator|=
literal|100
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|acquire
operator|=
name|e1000_acquire_swflag_ich8lan
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_reset_block
operator|=
name|e1000_check_reset_block_ich8lan
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cfg_done
operator|=
name|e1000_get_cfg_done_ich8lan
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_page
operator|=
name|e1000_set_page_igp
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|e1000_read_phy_reg_hv
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg_locked
operator|=
name|e1000_read_phy_reg_hv_locked
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg_page
operator|=
name|e1000_read_phy_reg_page_hv
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|release
operator|=
name|e1000_release_swflag_ich8lan
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|e1000_phy_hw_reset_ich8lan
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d0_lplu_state
operator|=
name|e1000_set_lplu_state_pchlan
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d3_lplu_state
operator|=
name|e1000_set_lplu_state_pchlan
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|e1000_write_phy_reg_hv
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg_locked
operator|=
name|e1000_write_phy_reg_hv_locked
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg_page
operator|=
name|e1000_write_phy_reg_page_hv
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|power_up
operator|=
name|e1000_power_up_phy_copper
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|power_down
operator|=
name|e1000_power_down_phy_copper_ich8lan
expr_stmt|;
name|phy
operator|->
name|autoneg_mask
operator|=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
name|phy
operator|->
name|id
operator|=
name|e1000_phy_unknown
expr_stmt|;
name|ret_val
operator|=
name|e1000_init_phy_workarounds_pchlan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|phy
operator|->
name|id
operator|==
name|e1000_phy_unknown
condition|)
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
default|default:
name|ret_val
operator|=
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|phy
operator|->
name|id
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|phy
operator|->
name|id
operator|!=
name|PHY_REVISION_MASK
operator|)
condition|)
break|break;
comment|/* fall-through */
case|case
name|e1000_pch2lan
case|:
case|case
name|e1000_pch_lpt
case|:
case|case
name|e1000_pch_spt
case|:
comment|/* In case the PHY needs to be in mdio slow mode, 			 * set slow mode and try to get the PHY id again. 			 */
name|ret_val
operator|=
name|e1000_set_mdio_slow_mode_hv
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
break|break;
block|}
name|phy
operator|->
name|type
operator|=
name|e1000_get_phy_type_from_id
argument_list|(
name|phy
operator|->
name|id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|type
condition|)
block|{
case|case
name|e1000_phy_82577
case|:
case|case
name|e1000_phy_82579
case|:
case|case
name|e1000_phy_i217
case|:
name|phy
operator|->
name|ops
operator|.
name|check_polarity
operator|=
name|e1000_check_polarity_82577
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_82577
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
operator|=
name|e1000_get_cable_length_82577
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_info
operator|=
name|e1000_get_phy_info_82577
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|commit
operator|=
name|e1000_phy_sw_reset_generic
expr_stmt|;
break|break;
case|case
name|e1000_phy_82578
case|:
name|phy
operator|->
name|ops
operator|.
name|check_polarity
operator|=
name|e1000_check_polarity_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
operator|=
name|e1000_get_cable_length_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_info
operator|=
name|e1000_get_phy_info_m88
expr_stmt|;
break|break;
default|default:
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
break|break;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_phy_params_ich8lan - Initialize PHY function pointers  *  @hw: pointer to the HW structure  *  *  Initialize family-specific PHY parameters and function pointers.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_phy_params_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_phy_params_ich8lan"
argument_list|)
expr_stmt|;
name|phy
operator|->
name|addr
operator|=
literal|1
expr_stmt|;
name|phy
operator|->
name|reset_delay_us
operator|=
literal|100
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|acquire
operator|=
name|e1000_acquire_swflag_ich8lan
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_reset_block
operator|=
name|e1000_check_reset_block_ich8lan
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
operator|=
name|e1000_get_cable_length_igp_2
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cfg_done
operator|=
name|e1000_get_cfg_done_ich8lan
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|e1000_read_phy_reg_igp
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|release
operator|=
name|e1000_release_swflag_ich8lan
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|e1000_phy_hw_reset_ich8lan
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d0_lplu_state
operator|=
name|e1000_set_d0_lplu_state_ich8lan
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d3_lplu_state
operator|=
name|e1000_set_d3_lplu_state_ich8lan
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|e1000_write_phy_reg_igp
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|power_up
operator|=
name|e1000_power_up_phy_copper
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|power_down
operator|=
name|e1000_power_down_phy_copper_ich8lan
expr_stmt|;
comment|/* We may need to do this twice - once for IGP and if that fails, 	 * we'll set BM func pointers and try again 	 */
name|ret_val
operator|=
name|e1000_determine_phy_address
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|e1000_write_phy_reg_bm
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|e1000_read_phy_reg_bm
expr_stmt|;
name|ret_val
operator|=
name|e1000_determine_phy_address
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Cannot determine PHY addr. Erroring out\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
name|phy
operator|->
name|id
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|e1000_phy_unknown
operator|==
name|e1000_get_phy_type_from_id
argument_list|(
name|phy
operator|->
name|id
argument_list|)
operator|)
operator|&&
operator|(
name|i
operator|++
operator|<
literal|100
operator|)
condition|)
block|{
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* Verify phy id */
switch|switch
condition|(
name|phy
operator|->
name|id
condition|)
block|{
case|case
name|IGP03E1000_E_PHY_ID
case|:
name|phy
operator|->
name|type
operator|=
name|e1000_phy_igp_3
expr_stmt|;
name|phy
operator|->
name|autoneg_mask
operator|=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg_locked
operator|=
name|e1000_read_phy_reg_igp_locked
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg_locked
operator|=
name|e1000_write_phy_reg_igp_locked
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_info
operator|=
name|e1000_get_phy_info_igp
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_polarity
operator|=
name|e1000_check_polarity_igp
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_igp
expr_stmt|;
break|break;
case|case
name|IFE_E_PHY_ID
case|:
case|case
name|IFE_PLUS_E_PHY_ID
case|:
case|case
name|IFE_C_E_PHY_ID
case|:
name|phy
operator|->
name|type
operator|=
name|e1000_phy_ife
expr_stmt|;
name|phy
operator|->
name|autoneg_mask
operator|=
name|E1000_ALL_NOT_GIG
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_info
operator|=
name|e1000_get_phy_info_ife
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_polarity
operator|=
name|e1000_check_polarity_ife
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_ife
expr_stmt|;
break|break;
case|case
name|BME1000_E_PHY_ID
case|:
name|phy
operator|->
name|type
operator|=
name|e1000_phy_bm
expr_stmt|;
name|phy
operator|->
name|autoneg_mask
operator|=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|e1000_read_phy_reg_bm
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|e1000_write_phy_reg_bm
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|commit
operator|=
name|e1000_phy_sw_reset_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_info
operator|=
name|e1000_get_phy_info_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_polarity
operator|=
name|e1000_check_polarity_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_m88
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|E1000_ERR_PHY
return|;
break|break;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_nvm_params_ich8lan - Initialize NVM function pointers  *  @hw: pointer to the HW structure  *  *  Initialize family-specific NVM parameters and function  *  pointers.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_nvm_params_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
decl_stmt|;
name|u32
name|gfpreg
decl_stmt|,
name|sector_base_addr
decl_stmt|,
name|sector_end_addr
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|u32
name|nvm_size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_nvm_params_ich8lan"
argument_list|)
expr_stmt|;
name|nvm
operator|->
name|type
operator|=
name|e1000_nvm_flash_sw
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
block|{
comment|/* in SPT, gfpreg doesn't exist. NVM size is taken from the 		 * STRAP register. This is because in SPT the GbE Flash region 		 * is no longer accessed through the flash registers. Instead, 		 * the mechanism has changed, and the Flash region access 		 * registers are now implemented in GbE memory space. 		 */
name|nvm
operator|->
name|flash_base_addr
operator|=
literal|0
expr_stmt|;
name|nvm_size
operator|=
operator|(
operator|(
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STRAP
argument_list|)
operator|>>
literal|1
operator|)
operator|&
literal|0x1F
operator|)
operator|+
literal|1
operator|)
operator|*
name|NVM_SIZE_MULTIPLIER
expr_stmt|;
name|nvm
operator|->
name|flash_bank_size
operator|=
name|nvm_size
operator|/
literal|2
expr_stmt|;
comment|/* Adjust to word count */
name|nvm
operator|->
name|flash_bank_size
operator|/=
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
expr_stmt|;
comment|/* Set the base address for flash register access */
name|hw
operator|->
name|flash_address
operator|=
name|hw
operator|->
name|hw_addr
operator|+
name|E1000_FLASH_BASE_ADDR
expr_stmt|;
block|}
else|else
block|{
comment|/* Can't read flash registers if register set isn't mapped. */
if|if
condition|(
operator|!
name|hw
operator|->
name|flash_address
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"ERROR: Flash registers not mapped\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|gfpreg
operator|=
name|E1000_READ_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_GFPREG
argument_list|)
expr_stmt|;
comment|/* sector_X_addr is a "sector"-aligned address (4096 bytes) 		 * Add 1 to sector_end_addr since this sector is included in 		 * the overall size. 		 */
name|sector_base_addr
operator|=
name|gfpreg
operator|&
name|FLASH_GFPREG_BASE_MASK
expr_stmt|;
name|sector_end_addr
operator|=
operator|(
operator|(
name|gfpreg
operator|>>
literal|16
operator|)
operator|&
name|FLASH_GFPREG_BASE_MASK
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* flash_base_addr is byte-aligned */
name|nvm
operator|->
name|flash_base_addr
operator|=
name|sector_base_addr
operator|<<
name|FLASH_SECTOR_ADDR_SHIFT
expr_stmt|;
comment|/* find total size of the NVM, then cut in half since the total 		 * size represents two separate NVM banks. 		 */
name|nvm
operator|->
name|flash_bank_size
operator|=
operator|(
operator|(
name|sector_end_addr
operator|-
name|sector_base_addr
operator|)
operator|<<
name|FLASH_SECTOR_ADDR_SHIFT
operator|)
expr_stmt|;
name|nvm
operator|->
name|flash_bank_size
operator|/=
literal|2
expr_stmt|;
comment|/* Adjust to word count */
name|nvm
operator|->
name|flash_bank_size
operator|/=
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
expr_stmt|;
block|}
name|nvm
operator|->
name|word_size
operator|=
name|E1000_SHADOW_RAM_WORDS
expr_stmt|;
comment|/* Clear shadow ram */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvm
operator|->
name|word_size
condition|;
name|i
operator|++
control|)
block|{
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|modified
operator|=
name|FALSE
expr_stmt|;
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|value
operator|=
literal|0xFFFF
expr_stmt|;
block|}
name|E1000_MUTEX_INIT
argument_list|(
operator|&
name|dev_spec
operator|->
name|nvm_mutex
argument_list|)
expr_stmt|;
name|E1000_MUTEX_INIT
argument_list|(
operator|&
name|dev_spec
operator|->
name|swflag_mutex
argument_list|)
expr_stmt|;
comment|/* Function Pointers */
name|nvm
operator|->
name|ops
operator|.
name|acquire
operator|=
name|e1000_acquire_nvm_ich8lan
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|release
operator|=
name|e1000_release_nvm_ich8lan
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
block|{
name|nvm
operator|->
name|ops
operator|.
name|read
operator|=
name|e1000_read_nvm_spt
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|update
operator|=
name|e1000_update_nvm_checksum_spt
expr_stmt|;
block|}
else|else
block|{
name|nvm
operator|->
name|ops
operator|.
name|read
operator|=
name|e1000_read_nvm_ich8lan
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|update
operator|=
name|e1000_update_nvm_checksum_ich8lan
expr_stmt|;
block|}
name|nvm
operator|->
name|ops
operator|.
name|valid_led_default
operator|=
name|e1000_valid_led_default_ich8lan
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|validate
operator|=
name|e1000_validate_nvm_checksum_ich8lan
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|write
operator|=
name|e1000_write_nvm_ich8lan
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_mac_params_ich8lan - Initialize MAC function pointers  *  @hw: pointer to the HW structure  *  *  Initialize family-specific MAC parameters and function  *  pointers.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_mac_params_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_mac_params_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Set media type function pointer */
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_copper
expr_stmt|;
comment|/* Set mta register count */
name|mac
operator|->
name|mta_reg_count
operator|=
literal|32
expr_stmt|;
comment|/* Set rar entry count */
name|mac
operator|->
name|rar_entry_count
operator|=
name|E1000_ICH_RAR_ENTRIES
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|type
operator|==
name|e1000_ich8lan
condition|)
name|mac
operator|->
name|rar_entry_count
operator|--
expr_stmt|;
comment|/* Set if part includes ASF firmware */
name|mac
operator|->
name|asf_firmware_present
operator|=
name|TRUE
expr_stmt|;
comment|/* FWSM register */
name|mac
operator|->
name|has_fwsm
operator|=
name|TRUE
expr_stmt|;
comment|/* ARC subsystem not supported */
name|mac
operator|->
name|arc_subsystem_valid
operator|=
name|FALSE
expr_stmt|;
comment|/* Adaptive IFS supported */
name|mac
operator|->
name|adaptive_ifs
operator|=
name|TRUE
expr_stmt|;
comment|/* Function pointers */
comment|/* bus type/speed/width */
name|mac
operator|->
name|ops
operator|.
name|get_bus_info
operator|=
name|e1000_get_bus_info_ich8lan
expr_stmt|;
comment|/* function id */
name|mac
operator|->
name|ops
operator|.
name|set_lan_id
operator|=
name|e1000_set_lan_id_single_port
expr_stmt|;
comment|/* reset */
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
name|e1000_reset_hw_ich8lan
expr_stmt|;
comment|/* hw initialization */
name|mac
operator|->
name|ops
operator|.
name|init_hw
operator|=
name|e1000_init_hw_ich8lan
expr_stmt|;
comment|/* link setup */
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|e1000_setup_link_ich8lan
expr_stmt|;
comment|/* physical interface setup */
name|mac
operator|->
name|ops
operator|.
name|setup_physical_interface
operator|=
name|e1000_setup_copper_link_ich8lan
expr_stmt|;
comment|/* check for link */
name|mac
operator|->
name|ops
operator|.
name|check_for_link
operator|=
name|e1000_check_for_copper_link_ich8lan
expr_stmt|;
comment|/* link info */
name|mac
operator|->
name|ops
operator|.
name|get_link_up_info
operator|=
name|e1000_get_link_up_info_ich8lan
expr_stmt|;
comment|/* multicast address update */
name|mac
operator|->
name|ops
operator|.
name|update_mc_addr_list
operator|=
name|e1000_update_mc_addr_list_generic
expr_stmt|;
comment|/* clear hardware counters */
name|mac
operator|->
name|ops
operator|.
name|clear_hw_cntrs
operator|=
name|e1000_clear_hw_cntrs_ich8lan
expr_stmt|;
comment|/* LED and other operations */
switch|switch
condition|(
name|mac
operator|->
name|type
condition|)
block|{
case|case
name|e1000_ich8lan
case|:
case|case
name|e1000_ich9lan
case|:
case|case
name|e1000_ich10lan
case|:
comment|/* check management mode */
name|mac
operator|->
name|ops
operator|.
name|check_mng_mode
operator|=
name|e1000_check_mng_mode_ich8lan
expr_stmt|;
comment|/* ID LED init */
name|mac
operator|->
name|ops
operator|.
name|id_led_init
operator|=
name|e1000_id_led_init_generic
expr_stmt|;
comment|/* blink LED */
name|mac
operator|->
name|ops
operator|.
name|blink_led
operator|=
name|e1000_blink_led_generic
expr_stmt|;
comment|/* setup LED */
name|mac
operator|->
name|ops
operator|.
name|setup_led
operator|=
name|e1000_setup_led_generic
expr_stmt|;
comment|/* cleanup LED */
name|mac
operator|->
name|ops
operator|.
name|cleanup_led
operator|=
name|e1000_cleanup_led_ich8lan
expr_stmt|;
comment|/* turn on/off LED */
name|mac
operator|->
name|ops
operator|.
name|led_on
operator|=
name|e1000_led_on_ich8lan
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|led_off
operator|=
name|e1000_led_off_ich8lan
expr_stmt|;
break|break;
case|case
name|e1000_pch2lan
case|:
name|mac
operator|->
name|rar_entry_count
operator|=
name|E1000_PCH2_RAR_ENTRIES
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|rar_set
operator|=
name|e1000_rar_set_pch2lan
expr_stmt|;
comment|/* fall-through */
case|case
name|e1000_pch_lpt
case|:
case|case
name|e1000_pch_spt
case|:
comment|/* multicast address update for pch2 */
name|mac
operator|->
name|ops
operator|.
name|update_mc_addr_list
operator|=
name|e1000_update_mc_addr_list_pch2lan
expr_stmt|;
comment|/* fall-through */
case|case
name|e1000_pchlan
case|:
comment|/* check management mode */
name|mac
operator|->
name|ops
operator|.
name|check_mng_mode
operator|=
name|e1000_check_mng_mode_pchlan
expr_stmt|;
comment|/* ID LED init */
name|mac
operator|->
name|ops
operator|.
name|id_led_init
operator|=
name|e1000_id_led_init_pchlan
expr_stmt|;
comment|/* setup LED */
name|mac
operator|->
name|ops
operator|.
name|setup_led
operator|=
name|e1000_setup_led_pchlan
expr_stmt|;
comment|/* cleanup LED */
name|mac
operator|->
name|ops
operator|.
name|cleanup_led
operator|=
name|e1000_cleanup_led_pchlan
expr_stmt|;
comment|/* turn on/off LED */
name|mac
operator|->
name|ops
operator|.
name|led_on
operator|=
name|e1000_led_on_pchlan
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|led_off
operator|=
name|e1000_led_off_pchlan
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|mac
operator|->
name|type
operator|>=
name|e1000_pch_lpt
condition|)
block|{
name|mac
operator|->
name|rar_entry_count
operator|=
name|E1000_PCH_LPT_RAR_ENTRIES
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|rar_set
operator|=
name|e1000_rar_set_pch_lpt
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_physical_interface
operator|=
name|e1000_setup_copper_link_pch_lpt
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_obff_timer
operator|=
name|e1000_set_obff_timer_pch_lpt
expr_stmt|;
block|}
comment|/* Enable PCS Lock-loss workaround for ICH8 */
if|if
condition|(
name|mac
operator|->
name|type
operator|==
name|e1000_ich8lan
condition|)
name|e1000_set_kmrn_lock_loss_workaround_ich8lan
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  __e1000_access_emi_reg_locked - Read/write EMI register  *  @hw: pointer to the HW structure  *  @addr: EMI address to program  *  @data: pointer to value to read/write from/to the EMI address  *  @read: boolean flag to indicate read or write  *  *  This helper function assumes the SW/FW/HW Semaphore is already acquired.  **/
end_comment

begin_function
specifier|static
name|s32
name|__e1000_access_emi_reg_locked
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|address
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|,
name|bool
name|read
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"__e1000_access_emi_reg_locked"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|I82579_EMI_ADDR
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|read
condition|)
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|I82579_EMI_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|I82579_EMI_DATA
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_emi_reg_locked - Read Extended Management Interface register  *  @hw: pointer to the HW structure  *  @addr: EMI address to program  *  @data: value to be read from the EMI address  *  *  Assumes the SW/FW/HW Semaphore is already acquired.  **/
end_comment

begin_function
name|s32
name|e1000_read_emi_reg_locked
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|addr
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_emi_reg_locked"
argument_list|)
expr_stmt|;
return|return
name|__e1000_access_emi_reg_locked
argument_list|(
name|hw
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_emi_reg_locked - Write Extended Management Interface register  *  @hw: pointer to the HW structure  *  @addr: EMI address to program  *  @data: value to be written to the EMI address  *  *  Assumes the SW/FW/HW Semaphore is already acquired.  **/
end_comment

begin_function
name|s32
name|e1000_write_emi_reg_locked
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|addr
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_emi_reg_locked"
argument_list|)
expr_stmt|;
return|return
name|__e1000_access_emi_reg_locked
argument_list|(
name|hw
argument_list|,
name|addr
argument_list|,
operator|&
name|data
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_eee_pchlan - Enable/disable EEE support  *  @hw: pointer to the HW structure  *  *  Enable/disable EEE based on setting in dev_spec structure, the duplex of  *  the link and the EEE capabilities of the link partner.  The LPI Control  *  register bits will remain set only if/when link is up.  *  *  EEE LPI must not be asserted earlier than one second after link is up.  *  On 82579, EEE LPI should not be enabled until such time otherwise there  *  can be link issues with some switches.  Other devices can have EEE LPI  *  enabled immediately upon link up since they have a timer in hardware which  *  prevents LPI from being asserted too early.  **/
end_comment

begin_function
name|s32
name|e1000_set_eee_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|lpa
decl_stmt|,
name|pcs_status
decl_stmt|,
name|adv
decl_stmt|,
name|adv_addr
decl_stmt|,
name|lpi_ctrl
decl_stmt|,
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_eee_pchlan"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|e1000_phy_82579
case|:
name|lpa
operator|=
name|I82579_EEE_LP_ABILITY
expr_stmt|;
name|pcs_status
operator|=
name|I82579_EEE_PCS_STATUS
expr_stmt|;
name|adv_addr
operator|=
name|I82579_EEE_ADVERTISEMENT
expr_stmt|;
break|break;
case|case
name|e1000_phy_i217
case|:
name|lpa
operator|=
name|I217_EEE_LP_ABILITY
expr_stmt|;
name|pcs_status
operator|=
name|I217_EEE_PCS_STATUS
expr_stmt|;
name|adv_addr
operator|=
name|I217_EEE_ADVERTISEMENT
expr_stmt|;
break|break;
default|default:
return|return
name|E1000_SUCCESS
return|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|I82579_LPI_CTRL
argument_list|,
operator|&
name|lpi_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
comment|/* Clear bits that enable EEE in various speeds */
name|lpi_ctrl
operator|&=
operator|~
name|I82579_LPI_CTRL_ENABLE_MASK
expr_stmt|;
comment|/* Enable EEE if not disabled by user */
if|if
condition|(
operator|!
name|dev_spec
operator|->
name|eee_disable
condition|)
block|{
comment|/* Save off link partner's EEE ability */
name|ret_val
operator|=
name|e1000_read_emi_reg_locked
argument_list|(
name|hw
argument_list|,
name|lpa
argument_list|,
operator|&
name|dev_spec
operator|->
name|eee_lp_ability
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
comment|/* Read EEE advertisement */
name|ret_val
operator|=
name|e1000_read_emi_reg_locked
argument_list|(
name|hw
argument_list|,
name|adv_addr
argument_list|,
operator|&
name|adv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
comment|/* Enable EEE only for speeds in which the link partner is 		 * EEE capable and for which we advertise EEE. 		 */
if|if
condition|(
name|adv
operator|&
name|dev_spec
operator|->
name|eee_lp_ability
operator|&
name|I82579_EEE_1000_SUPPORTED
condition|)
name|lpi_ctrl
operator||=
name|I82579_LPI_CTRL_1000_ENABLE
expr_stmt|;
if|if
condition|(
name|adv
operator|&
name|dev_spec
operator|->
name|eee_lp_ability
operator|&
name|I82579_EEE_100_SUPPORTED
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|PHY_LP_ABILITY
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|NWAY_LPAR_100TX_FD_CAPS
condition|)
name|lpi_ctrl
operator||=
name|I82579_LPI_CTRL_100_ENABLE
expr_stmt|;
else|else
comment|/* EEE is not supported in 100Half, so ignore 				 * partner's EEE in 100 ability if full-duplex 				 * is not advertised. 				 */
name|dev_spec
operator|->
name|eee_lp_ability
operator|&=
operator|~
name|I82579_EEE_100_SUPPORTED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82579
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_emi_reg_locked
argument_list|(
name|hw
argument_list|,
name|I82579_LPI_PLL_SHUT
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|data
operator|&=
operator|~
name|I82579_LPI_100_PLL_SHUT
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_emi_reg_locked
argument_list|(
name|hw
argument_list|,
name|I82579_LPI_PLL_SHUT
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* R/Clr IEEE MMD 3.1 bits 11:10 - Tx/Rx LPI Received */
name|ret_val
operator|=
name|e1000_read_emi_reg_locked
argument_list|(
name|hw
argument_list|,
name|pcs_status
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|I82579_LPI_CTRL
argument_list|,
name|lpi_ctrl
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_k1_workaround_lpt_lp - K1 workaround on Lynxpoint-LP  *  @hw:   pointer to the HW structure  *  @link: link up bool flag  *  *  When K1 is enabled for 1Gbps, the MAC can miss 2 DMA completion indications  *  preventing further DMA write requests.  Workaround the issue by disabling  *  the de-assertion of the clock request when in 1Gpbs mode.  *  Also, set appropriate Tx re-transmission timeouts for 10 and 100Half link  *  speeds in order to avoid Tx hangs.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_k1_workaround_lpt_lp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|link
parameter_list|)
block|{
name|u32
name|fextnvm6
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM6
argument_list|)
decl_stmt|;
name|u32
name|status
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|reg
decl_stmt|;
if|if
condition|(
name|link
operator|&&
operator|(
name|status
operator|&
name|E1000_STATUS_SPEED_1000
operator|)
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_read_kmrn_reg_locked
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_K1_CONFIG
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg_locked
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_K1_CONFIG
argument_list|,
name|reg
operator|&
operator|~
name|E1000_KMRNCTRLSTA_K1_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM6
argument_list|,
name|fextnvm6
operator||
name|E1000_FEXTNVM6_REQ_PLL_CLK
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg_locked
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_K1_CONFIG
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* clear FEXTNVM6 bit 8 on link down or 10/100 */
name|fextnvm6
operator|&=
operator|~
name|E1000_FEXTNVM6_REQ_PLL_CLK
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|revision
operator|>
literal|5
operator|)
operator|||
operator|!
name|link
operator|||
operator|(
operator|(
name|status
operator|&
name|E1000_STATUS_SPEED_100
operator|)
operator|&&
operator|(
name|status
operator|&
name|E1000_STATUS_FD
operator|)
operator|)
condition|)
goto|goto
name|update_fextnvm6
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|I217_INBAND_CTRL
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Clear link status transmit timeout */
name|reg
operator|&=
operator|~
name|I217_INBAND_CTRL_LINK_STAT_TX_TIMEOUT_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_SPEED_100
condition|)
block|{
comment|/* Set inband Tx timeout to 5x10us for 100Half */
name|reg
operator||=
literal|5
operator|<<
name|I217_INBAND_CTRL_LINK_STAT_TX_TIMEOUT_SHIFT
expr_stmt|;
comment|/* Do not extend the K1 entry latency for 100Half */
name|fextnvm6
operator|&=
operator|~
name|E1000_FEXTNVM6_ENABLE_K1_ENTRY_CONDITION
expr_stmt|;
block|}
else|else
block|{
comment|/* Set inband Tx timeout to 50x10us for 10Full/Half */
name|reg
operator||=
literal|50
operator|<<
name|I217_INBAND_CTRL_LINK_STAT_TX_TIMEOUT_SHIFT
expr_stmt|;
comment|/* Extend the K1 entry latency for 10 Mbps */
name|fextnvm6
operator||=
name|E1000_FEXTNVM6_ENABLE_K1_ENTRY_CONDITION
expr_stmt|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|I217_INBAND_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|update_fextnvm6
label|:
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM6
argument_list|,
name|fextnvm6
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_function
specifier|static
name|u64
name|e1000_ltr2ns
parameter_list|(
name|u16
name|ltr
parameter_list|)
block|{
name|u32
name|value
decl_stmt|,
name|scale
decl_stmt|;
comment|/* Determine the latency in nsec based on the LTR value& scale */
name|value
operator|=
name|ltr
operator|&
name|E1000_LTRV_VALUE_MASK
expr_stmt|;
name|scale
operator|=
operator|(
name|ltr
operator|&
name|E1000_LTRV_SCALE_MASK
operator|)
operator|>>
name|E1000_LTRV_SCALE_SHIFT
expr_stmt|;
return|return
name|value
operator|*
operator|(
literal|1
operator|<<
operator|(
name|scale
operator|*
name|E1000_LTRV_SCALE_FACTOR
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_platform_pm_pch_lpt - Set platform power management values  *  @hw: pointer to the HW structure  *  @link: bool indicating link status  *  *  Set the Latency Tolerance Reporting (LTR) values for the "PCIe-like"  *  GbE MAC in the Lynx Point PCH based on Rx buffer size and link speed  *  when link is up (which must not exceed the maximum latency supported  *  by the platform), otherwise specify there is no LTR requirement.  *  Unlike TRUE-PCIe devices which set the LTR maximum snoop/no-snoop  *  latencies in the LTR Extended Capability Structure in the PCIe Extended  *  Capability register set, on this device LTR is set by writing the  *  equivalent snoop/no-snoop latencies in the LTRV register in the MAC and  *  set the SEND bit to send an Intel On-chip System Fabric sideband (IOSF-SB)  *  message to the PMC.  *  *  Use the LTR value to calculate the Optimized Buffer Flush/Fill (OBFF)  *  high-water mark.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_platform_pm_pch_lpt
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|link
parameter_list|)
block|{
name|u32
name|reg
init|=
name|link
operator|<<
operator|(
name|E1000_LTRV_REQ_SHIFT
operator|+
name|E1000_LTRV_NOSNOOP_SHIFT
operator|)
operator||
name|link
operator|<<
name|E1000_LTRV_REQ_SHIFT
operator||
name|E1000_LTRV_SEND
decl_stmt|;
name|u16
name|lat_enc
init|=
literal|0
decl_stmt|;
comment|/* latency encoded */
name|s32
name|obff_hwm
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_platform_pm_pch_lpt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
condition|)
block|{
name|u16
name|speed
decl_stmt|,
name|duplex
decl_stmt|,
name|scale
init|=
literal|0
decl_stmt|;
name|u16
name|max_snoop
decl_stmt|,
name|max_nosnoop
decl_stmt|;
name|u16
name|max_ltr_enc
decl_stmt|;
comment|/* max LTR latency encoded */
name|s64
name|lat_ns
decl_stmt|;
name|s64
name|value
decl_stmt|;
name|u32
name|rxa
decl_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|mac
operator|.
name|max_frame_size
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"max_frame_size not set.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_link_up_info
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|speed
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Speed not set.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
comment|/* Rx Packet Buffer Allocation size (KB) */
name|rxa
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA
argument_list|)
operator|&
name|E1000_PBA_RXA_MASK
expr_stmt|;
comment|/* Determine the maximum latency tolerated by the device. 		 * 		 * Per the PCIe spec, the tolerated latencies are encoded as 		 * a 3-bit encoded scale (only 0-5 are valid) multiplied by 		 * a 10-bit value (0-1023) to provide a range from 1 ns to 		 * 2^25*(2^10-1) ns.  The scale is encoded as 0=2^0ns, 		 * 1=2^5ns, 2=2^10ns,...5=2^25ns. 		 */
name|lat_ns
operator|=
operator|(
operator|(
name|s64
operator|)
name|rxa
operator|*
literal|1024
operator|-
operator|(
literal|2
operator|*
operator|(
name|s64
operator|)
name|hw
operator|->
name|mac
operator|.
name|max_frame_size
operator|)
operator|)
operator|*
literal|8
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|lat_ns
operator|<
literal|0
condition|)
name|lat_ns
operator|=
literal|0
expr_stmt|;
else|else
name|lat_ns
operator|/=
name|speed
expr_stmt|;
name|value
operator|=
name|lat_ns
expr_stmt|;
while|while
condition|(
name|value
operator|>
name|E1000_LTRV_VALUE_MASK
condition|)
block|{
name|scale
operator|++
expr_stmt|;
name|value
operator|=
name|E1000_DIVIDE_ROUND_UP
argument_list|(
name|value
argument_list|,
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scale
operator|>
name|E1000_LTRV_SCALE_MAX
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Invalid LTR latency scale %d\n"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|lat_enc
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|scale
operator|<<
name|E1000_LTRV_SCALE_SHIFT
operator|)
operator||
name|value
argument_list|)
expr_stmt|;
comment|/* Determine the maximum latency tolerated by the platform */
name|e1000_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|E1000_PCI_LTR_CAP_LPT
argument_list|,
operator|&
name|max_snoop
argument_list|)
expr_stmt|;
name|e1000_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|E1000_PCI_LTR_CAP_LPT
operator|+
literal|2
argument_list|,
operator|&
name|max_nosnoop
argument_list|)
expr_stmt|;
name|max_ltr_enc
operator|=
name|E1000_MAX
argument_list|(
name|max_snoop
argument_list|,
name|max_nosnoop
argument_list|)
expr_stmt|;
if|if
condition|(
name|lat_enc
operator|>
name|max_ltr_enc
condition|)
block|{
name|lat_enc
operator|=
name|max_ltr_enc
expr_stmt|;
name|lat_ns
operator|=
name|e1000_ltr2ns
argument_list|(
name|max_ltr_enc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lat_ns
condition|)
block|{
name|lat_ns
operator|*=
name|speed
operator|*
literal|1000
expr_stmt|;
name|lat_ns
operator|/=
literal|8
expr_stmt|;
name|lat_ns
operator|/=
literal|1000000000
expr_stmt|;
name|obff_hwm
operator|=
call|(
name|s32
call|)
argument_list|(
name|rxa
operator|-
name|lat_ns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|obff_hwm
operator|<
literal|0
operator|)
operator|||
operator|(
name|obff_hwm
operator|>
name|E1000_SVT_OFF_HWM_MASK
operator|)
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Invalid high water mark %d\n"
argument_list|,
name|obff_hwm
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
block|}
comment|/* Set Snoop and No-Snoop latencies the same */
name|reg
operator||=
name|lat_enc
operator||
operator|(
name|lat_enc
operator|<<
name|E1000_LTRV_NOSNOOP_SHIFT
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LTRV
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Set OBFF high water mark */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SVT
argument_list|)
operator|&
operator|~
name|E1000_SVT_OFF_HWM_MASK
expr_stmt|;
name|reg
operator||=
name|obff_hwm
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SVT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Enable OBFF */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SVCR
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_SVCR_OFF_EN
expr_stmt|;
comment|/* Always unblock interrupts to the CPU even when the system is 	 * in OBFF mode. This ensures that small round-robin traffic 	 * (like ping) does not get dropped or experience long latency. 	 */
name|reg
operator||=
name|E1000_SVCR_OFF_MASKINT
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SVCR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_obff_timer_pch_lpt - Update Optimized Buffer Flush/Fill timer  *  @hw: pointer to the HW structure  *  @itr: interrupt throttling rate  *  *  Configure OBFF with the updated interrupt rate.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_set_obff_timer_pch_lpt
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|itr
parameter_list|)
block|{
name|u32
name|svcr
decl_stmt|;
name|s32
name|timer
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_obff_timer_pch_lpt"
argument_list|)
expr_stmt|;
comment|/* Convert ITR value into microseconds for OBFF timer */
name|timer
operator|=
name|itr
operator|&
name|E1000_ITR_MASK
expr_stmt|;
name|timer
operator|=
operator|(
name|timer
operator|*
name|E1000_ITR_MULT
operator|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
operator|(
name|timer
operator|<
literal|0
operator|)
operator|||
operator|(
name|timer
operator|>
name|E1000_ITR_MASK
operator|)
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Invalid OBFF timer %d\n"
argument_list|,
name|timer
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|svcr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SVCR
argument_list|)
expr_stmt|;
name|svcr
operator|&=
operator|~
name|E1000_SVCR_OFF_TIMER_MASK
expr_stmt|;
name|svcr
operator||=
name|timer
operator|<<
name|E1000_SVCR_OFF_TIMER_SHIFT
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SVCR
argument_list|,
name|svcr
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_enable_ulp_lpt_lp - configure Ultra Low Power mode for LynxPoint-LP  *  @hw: pointer to the HW structure  *  @to_sx: boolean indicating a system power state transition to Sx  *  *  When link is down, configure ULP mode to significantly reduce the power  *  to the PHY.  If on a Manageability Engine (ME) enabled system, tell the  *  ME firmware to start the ULP configuration.  If not on an ME enabled  *  system, configure the ULP mode by software.  */
end_comment

begin_function
name|s32
name|e1000_enable_ulp_lpt_lp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|to_sx
parameter_list|)
block|{
name|u32
name|mac_reg
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|phy_reg
decl_stmt|;
name|u16
name|oem_reg
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_pch_lpt
operator|)
operator|||
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_PCH_LPT_I217_LM
operator|)
operator|||
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_PCH_LPT_I217_V
operator|)
operator|||
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_PCH_I218_LM2
operator|)
operator|||
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_PCH_I218_V2
operator|)
operator|||
operator|(
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|ulp_state
operator|==
name|e1000_ulp_state_on
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
operator|&
name|E1000_ICH_FWSM_FW_VALID
condition|)
block|{
comment|/* Request ME configure ULP mode in the PHY */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_H2ME
argument_list|)
expr_stmt|;
name|mac_reg
operator||=
name|E1000_H2ME_ULP
operator||
name|E1000_H2ME_ENFORCE_SETTINGS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_H2ME
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|to_sx
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Poll up to 5 seconds for Cable Disconnected indication */
while|while
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXT
argument_list|)
operator|&
name|E1000_FEXT_PHY_CABLE_DISCONNECTED
operator|)
condition|)
block|{
comment|/* Bail if link is re-acquired */
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_LU
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
if|if
condition|(
name|i
operator|++
operator|==
literal|100
condition|)
break|break;
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
name|DEBUGOUT2
argument_list|(
literal|"CABLE_DISCONNECTED %s set after %dmsec\n"
argument_list|,
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXT
argument_list|)
operator|&
name|E1000_FEXT_PHY_CABLE_DISCONNECTED
operator|)
condition|?
literal|""
else|:
literal|"not"
argument_list|,
name|i
operator|*
literal|50
argument_list|)
expr_stmt|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Force SMBus mode in PHY */
name|ret_val
operator|=
name|e1000_read_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|CV_SMB_CTRL
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|phy_reg
operator||=
name|CV_SMB_CTRL_FORCE_SMBUS
expr_stmt|;
name|e1000_write_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|CV_SMB_CTRL
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
comment|/* Force SMBus mode in MAC */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|mac_reg
operator||=
name|E1000_CTRL_EXT_FORCE_SMBUS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
comment|/* Si workaround for ULP entry flow on i127/rev6 h/w.  Enable 	 * LPLU and disable Gig speed when entering ULP 	 */
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_i217
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|revision
operator|==
literal|6
operator|)
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|HV_OEM_BITS
argument_list|,
operator|&
name|oem_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|phy_reg
operator|=
name|oem_reg
expr_stmt|;
name|phy_reg
operator||=
name|HV_OEM_BITS_LPLU
operator||
name|HV_OEM_BITS_GBE_DIS
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|HV_OEM_BITS
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
comment|/* Set Inband ULP Exit, Reset to SMBus mode and 	 * Disable SMBus Release on PERST# in PHY 	 */
name|ret_val
operator|=
name|e1000_read_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|I218_ULP_CONFIG1
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|phy_reg
operator||=
operator|(
name|I218_ULP_CONFIG1_RESET_TO_SMBUS
operator||
name|I218_ULP_CONFIG1_DISABLE_SMB_PERST
operator|)
expr_stmt|;
if|if
condition|(
name|to_sx
condition|)
block|{
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_WUFC
argument_list|)
operator|&
name|E1000_WUFC_LNKC
condition|)
name|phy_reg
operator||=
name|I218_ULP_CONFIG1_WOL_HOST
expr_stmt|;
else|else
name|phy_reg
operator|&=
operator|~
name|I218_ULP_CONFIG1_WOL_HOST
expr_stmt|;
name|phy_reg
operator||=
name|I218_ULP_CONFIG1_STICKY_ULP
expr_stmt|;
name|phy_reg
operator|&=
operator|~
name|I218_ULP_CONFIG1_INBAND_EXIT
expr_stmt|;
block|}
else|else
block|{
name|phy_reg
operator||=
name|I218_ULP_CONFIG1_INBAND_EXIT
expr_stmt|;
name|phy_reg
operator|&=
operator|~
name|I218_ULP_CONFIG1_STICKY_ULP
expr_stmt|;
name|phy_reg
operator|&=
operator|~
name|I218_ULP_CONFIG1_WOL_HOST
expr_stmt|;
block|}
name|e1000_write_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|I218_ULP_CONFIG1
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
comment|/* Set Disable SMBus Release on PERST# in MAC */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM7
argument_list|)
expr_stmt|;
name|mac_reg
operator||=
name|E1000_FEXTNVM7_DISABLE_SMB_PERST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM7
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
comment|/* Commit ULP changes in PHY by starting auto ULP configuration */
name|phy_reg
operator||=
name|I218_ULP_CONFIG1_START
expr_stmt|;
name|e1000_write_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|I218_ULP_CONFIG1
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_i217
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|revision
operator|==
literal|6
operator|)
operator|&&
name|to_sx
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_LU
operator|)
condition|)
block|{
name|ret_val
operator|=
name|e1000_write_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|HV_OEM_BITS
argument_list|,
name|oem_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT1
argument_list|(
literal|"Error in ULP enable flow: %d\n"
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
else|else
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|ulp_state
operator|=
name|e1000_ulp_state_on
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_disable_ulp_lpt_lp - unconfigure Ultra Low Power mode for LynxPoint-LP  *  @hw: pointer to the HW structure  *  @force: boolean indicating whether or not to force disabling ULP  *  *  Un-configure ULP mode when link is up, the system is transitioned from  *  Sx or the driver is unloaded.  If on a Manageability Engine (ME) enabled  *  system, poll for an indication from ME that ULP has been un-configured.  *  If not on an ME enabled system, un-configure the ULP mode by software.  *  *  During nominal operation, this function is called when link is acquired  *  to disable ULP mode (force=FALSE); otherwise, for example when unloading  *  the driver or during Sx->S0 transitions, this is called with force=TRUE  *  to forcibly disable ULP.  */
end_comment

begin_function
name|s32
name|e1000_disable_ulp_lpt_lp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|mac_reg
decl_stmt|;
name|u16
name|phy_reg
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_pch_lpt
operator|)
operator|||
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_PCH_LPT_I217_LM
operator|)
operator|||
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_PCH_LPT_I217_V
operator|)
operator|||
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_PCH_I218_LM2
operator|)
operator|||
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_PCH_I218_V2
operator|)
operator|||
operator|(
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|ulp_state
operator|==
name|e1000_ulp_state_off
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
operator|&
name|E1000_ICH_FWSM_FW_VALID
condition|)
block|{
if|if
condition|(
name|force
condition|)
block|{
comment|/* Request ME un-configure ULP mode in the PHY */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_H2ME
argument_list|)
expr_stmt|;
name|mac_reg
operator|&=
operator|~
name|E1000_H2ME_ULP
expr_stmt|;
name|mac_reg
operator||=
name|E1000_H2ME_ENFORCE_SETTINGS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_H2ME
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Poll up to 300msec for ME to clear ULP_CFG_DONE. */
while|while
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
operator|&
name|E1000_FWSM_ULP_CFG_DONE
condition|)
block|{
if|if
condition|(
name|i
operator|++
operator|==
literal|30
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|DEBUGOUT1
argument_list|(
literal|"ULP_CONFIG_DONE cleared after %dmsec\n"
argument_list|,
name|i
operator|*
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
condition|)
block|{
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_H2ME
argument_list|)
expr_stmt|;
name|mac_reg
operator|&=
operator|~
name|E1000_H2ME_ENFORCE_SETTINGS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_H2ME
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Clear H2ME.ULP after ME ULP configuration */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_H2ME
argument_list|)
expr_stmt|;
name|mac_reg
operator|&=
operator|~
name|E1000_H2ME_ULP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_H2ME
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|force
condition|)
comment|/* Toggle LANPHYPC Value bit */
name|e1000_toggle_lanphypc_pch_lpt
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Unforce SMBus mode in PHY */
name|ret_val
operator|=
name|e1000_read_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|CV_SMB_CTRL
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
comment|/* The MAC might be in PCIe mode, so temporarily force to 		 * SMBus mode in order to access the PHY. 		 */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|mac_reg
operator||=
name|E1000_CTRL_EXT_FORCE_SMBUS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|CV_SMB_CTRL
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
name|phy_reg
operator|&=
operator|~
name|CV_SMB_CTRL_FORCE_SMBUS
expr_stmt|;
name|e1000_write_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|CV_SMB_CTRL
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
comment|/* Unforce SMBus mode in MAC */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|mac_reg
operator|&=
operator|~
name|E1000_CTRL_EXT_FORCE_SMBUS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
comment|/* When ULP mode was previously entered, K1 was disabled by the 	 * hardware.  Re-Enable K1 in the PHY when exiting ULP. 	 */
name|ret_val
operator|=
name|e1000_read_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|HV_PM_CTRL
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|phy_reg
operator||=
name|HV_PM_CTRL_K1_ENABLE
expr_stmt|;
name|e1000_write_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|HV_PM_CTRL
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
comment|/* Clear ULP enabled configuration */
name|ret_val
operator|=
name|e1000_read_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|I218_ULP_CONFIG1
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|phy_reg
operator|&=
operator|~
operator|(
name|I218_ULP_CONFIG1_IND
operator||
name|I218_ULP_CONFIG1_STICKY_ULP
operator||
name|I218_ULP_CONFIG1_RESET_TO_SMBUS
operator||
name|I218_ULP_CONFIG1_WOL_HOST
operator||
name|I218_ULP_CONFIG1_INBAND_EXIT
operator||
name|I218_ULP_CONFIG1_EN_ULP_LANPHYPC
operator||
name|I218_ULP_CONFIG1_DIS_CLR_STICKY_ON_PERST
operator||
name|I218_ULP_CONFIG1_DISABLE_SMB_PERST
operator|)
expr_stmt|;
name|e1000_write_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|I218_ULP_CONFIG1
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
comment|/* Commit ULP changes by starting auto ULP configuration */
name|phy_reg
operator||=
name|I218_ULP_CONFIG1_START
expr_stmt|;
name|e1000_write_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|I218_ULP_CONFIG1
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
comment|/* Clear Disable SMBus Release on PERST# in MAC */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM7
argument_list|)
expr_stmt|;
name|mac_reg
operator|&=
operator|~
name|E1000_FEXTNVM7_DISABLE_SMB_PERST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM7
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT1
argument_list|(
literal|"Error in ULP disable flow: %d\n"
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
else|else
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|ulp_state
operator|=
name|e1000_ulp_state_off
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_copper_link_ich8lan - Check for link (Copper)  *  @hw: pointer to the HW structure  *  *  Checks to see of the link status of the hardware has changed.  If a  *  change in link status has been detected, then we read the PHY registers  *  to get the current speed/duplex if link exists.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_check_for_copper_link_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
decl_stmt|,
name|tipg_reg
init|=
literal|0
decl_stmt|;
name|u16
name|emi_addr
decl_stmt|,
name|emi_val
init|=
literal|0
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|u16
name|phy_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_copper_link_ich8lan"
argument_list|)
expr_stmt|;
comment|/* We only want to go out to the PHY registers to see if Auto-Neg 	 * has completed and/or if our link status has changed.  The 	 * get_link_status flag is set upon receiving a Link Status 	 * Change or Rx Sequence Error interrupt. 	 */
if|if
condition|(
operator|!
name|mac
operator|->
name|get_link_status
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* First we want to see if the MII Status Register reports 	 * link.  If so, then we want to get the current speed/duplex 	 * of the PHY. 	 */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pchlan
condition|)
block|{
name|ret_val
operator|=
name|e1000_k1_gig_workaround_hv
argument_list|(
name|hw
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* When connected at 10Mbps half-duplex, some parts are excessively 	 * aggressive resulting in many collisions. To avoid this, increase 	 * the IPG and reduce Rx latency in the PHY. 	 */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch2lan
operator|)
operator|&&
name|link
condition|)
block|{
name|u16
name|speed
decl_stmt|,
name|duplex
decl_stmt|;
name|e1000_get_speed_and_duplex_copper_generic
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
expr_stmt|;
name|tipg_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TIPG
argument_list|)
expr_stmt|;
name|tipg_reg
operator|&=
operator|~
name|E1000_TIPG_IPGT_MASK
expr_stmt|;
if|if
condition|(
name|duplex
operator|==
name|HALF_DUPLEX
operator|&&
name|speed
operator|==
name|SPEED_10
condition|)
block|{
name|tipg_reg
operator||=
literal|0xFF
expr_stmt|;
comment|/* Reduce Rx latency in analog PHY */
name|emi_val
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
operator|&&
name|duplex
operator|==
name|FULL_DUPLEX
operator|&&
name|speed
operator|!=
name|SPEED_1000
condition|)
block|{
name|tipg_reg
operator||=
literal|0xC
expr_stmt|;
name|emi_val
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Roll back the default values */
name|tipg_reg
operator||=
literal|0x08
expr_stmt|;
name|emi_val
operator|=
literal|1
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TIPG
argument_list|,
name|tipg_reg
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
condition|)
name|emi_addr
operator|=
name|I82579_RX_CONFIG
expr_stmt|;
else|else
name|emi_addr
operator|=
name|I217_RX_CONFIG
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_emi_reg_locked
argument_list|(
name|hw
argument_list|,
name|emi_addr
argument_list|,
name|emi_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_lpt
condition|)
block|{
name|u16
name|phy_reg
decl_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_PLL_CLOCK_GATE_REG
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
name|phy_reg
operator|&=
operator|~
name|I217_PLL_CLOCK_GATE_MASK
expr_stmt|;
if|if
condition|(
name|speed
operator|==
name|SPEED_100
operator|||
name|speed
operator|==
name|SPEED_10
condition|)
name|phy_reg
operator||=
literal|0x3E8
expr_stmt|;
else|else
name|phy_reg
operator||=
literal|0xFA
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_PLL_CLOCK_GATE_REG
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|==
name|SPEED_1000
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|HV_PM_CTRL
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
name|phy_reg
operator||=
name|HV_PM_CTRL_K1_CLK_REQ
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|HV_PM_CTRL
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
block|}
block|}
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
block|{
name|u16
name|data
decl_stmt|;
name|u16
name|ptr_gap
decl_stmt|;
if|if
condition|(
name|speed
operator|==
name|SPEED_1000
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|776
argument_list|,
literal|20
argument_list|)
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|ptr_gap
operator|=
operator|(
name|data
operator|&
operator|(
literal|0x3FF
operator|<<
literal|2
operator|)
operator|)
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|ptr_gap
operator|<
literal|0x18
condition|)
block|{
name|data
operator|&=
operator|~
operator|(
literal|0x3FF
operator|<<
literal|2
operator|)
expr_stmt|;
name|data
operator||=
operator|(
literal|0x18
operator|<<
literal|2
operator|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|776
argument_list|,
literal|20
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|776
argument_list|,
literal|20
argument_list|)
argument_list|,
literal|0xC023
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
block|}
comment|/* I217 Packet Loss issue: 	 * ensure that FEXTNVM4 Beacon Duration is set correctly 	 * on power up. 	 * Set the Beacon Duration for I217 to 8 usec 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_lpt
condition|)
block|{
name|u32
name|mac_reg
decl_stmt|;
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM4
argument_list|)
expr_stmt|;
name|mac_reg
operator|&=
operator|~
name|E1000_FEXTNVM4_BEACON_DURATION_MASK
expr_stmt|;
name|mac_reg
operator||=
name|E1000_FEXTNVM4_BEACON_DURATION_8USEC
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM4
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Work-around I218 hang issue */
if|if
condition|(
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_PCH_LPTLP_I218_LM
operator|)
operator|||
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_PCH_LPTLP_I218_V
operator|)
operator|||
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_PCH_I218_LM3
operator|)
operator|||
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_PCH_I218_V3
operator|)
condition|)
block|{
name|ret_val
operator|=
name|e1000_k1_workaround_lpt_lp
argument_list|(
name|hw
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_lpt
condition|)
block|{
comment|/* Set platform power management values for 		 * Latency Tolerance Reporting (LTR) 		 * Optimized Buffer Flush/Fill (OBFF) 		 */
name|ret_val
operator|=
name|e1000_platform_pm_pch_lpt
argument_list|(
name|hw
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* Clear link partner's EEE ability */
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|eee_lp_ability
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_lpt
condition|)
block|{
name|u32
name|fextnvm6
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM6
argument_list|)
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch_spt
condition|)
block|{
comment|/* FEXTNVM6 K1-off workaround - for SPT only */
name|u32
name|pcieanacfg
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCIEANACFG
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcieanacfg
operator|&
name|E1000_FEXTNVM6_K1_OFF_ENABLE
condition|)
name|fextnvm6
operator||=
name|E1000_FEXTNVM6_K1_OFF_ENABLE
expr_stmt|;
else|else
name|fextnvm6
operator|&=
operator|~
name|E1000_FEXTNVM6_K1_OFF_ENABLE
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|disable_k1_off
operator|==
name|TRUE
condition|)
name|fextnvm6
operator|&=
operator|~
name|E1000_FEXTNVM6_K1_OFF_ENABLE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM6
argument_list|,
name|fextnvm6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|link
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* No link detected */
name|mac
operator|->
name|get_link_status
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_pch2lan
case|:
name|ret_val
operator|=
name|e1000_k1_workaround_lv
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* fall-thru */
case|case
name|e1000_pchlan
case|:
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82578
condition|)
block|{
name|ret_val
operator|=
name|e1000_link_stall_workaround_hv
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* Workaround for PCHx parts in half-duplex: 		 * Set the number of preambles removed from the packet 		 * when it is passed from the PHY to the MAC to prevent 		 * the MAC from misinterpreting the packet type. 		 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|HV_KMRN_FIFO_CTRLSTA
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
name|phy_reg
operator|&=
operator|~
name|HV_KMRN_FIFO_CTRLSTA_PREAMBLE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_FD
operator|)
operator|!=
name|E1000_STATUS_FD
condition|)
name|phy_reg
operator||=
operator|(
literal|1
operator|<<
name|HV_KMRN_FIFO_CTRLSTA_PREAMBLE_SHIFT
operator|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|HV_KMRN_FIFO_CTRLSTA
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Check if there was DownShift, must be checked 	 * immediately after link-up 	 */
name|e1000_check_downshift_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Enable/Disable EEE after link up */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|>
name|e1000_phy_82579
condition|)
block|{
name|ret_val
operator|=
name|e1000_set_eee_pchlan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* If we are forcing speed/duplex, then we simply return since 	 * we have already determined whether we have link or not. 	 */
if|if
condition|(
operator|!
name|mac
operator|->
name|autoneg
condition|)
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
comment|/* Auto-Neg is enabled.  Auto Speed Detection takes care 	 * of MAC speed/duplex configuration.  So we only need to 	 * configure Collision Distance in the MAC. 	 */
name|mac
operator|->
name|ops
operator|.
name|config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Configure Flow Control now that Auto-Neg has completed. 	 * First, we need to restore the desired flow control 	 * settings because we may have had to re-autoneg with a 	 * different link partner. 	 */
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_function_pointers_ich8lan - Initialize ICH8 function pointers  *  @hw: pointer to the HW structure  *  *  Initialize family-specific function pointers for PHY, MAC, and NVM.  **/
end_comment

begin_function
name|void
name|e1000_init_function_pointers_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_function_pointers_ich8lan"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_mac_params_ich8lan
expr_stmt|;
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_nvm_params_ich8lan
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_ich8lan
case|:
case|case
name|e1000_ich9lan
case|:
case|case
name|e1000_ich10lan
case|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_phy_params_ich8lan
expr_stmt|;
break|break;
case|case
name|e1000_pchlan
case|:
case|case
name|e1000_pch2lan
case|:
case|case
name|e1000_pch_lpt
case|:
case|case
name|e1000_pch_spt
case|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_phy_params_pchlan
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_nvm_ich8lan - Acquire NVM mutex  *  @hw: pointer to the HW structure  *  *  Acquires the mutex for performing NVM operations.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_acquire_nvm_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_nvm_ich8lan"
argument_list|)
expr_stmt|;
name|E1000_MUTEX_LOCK
argument_list|(
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|nvm_mutex
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_nvm_ich8lan - Release NVM mutex  *  @hw: pointer to the HW structure  *  *  Releases the mutex used while performing NVM operations.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_release_nvm_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_nvm_ich8lan"
argument_list|)
expr_stmt|;
name|E1000_MUTEX_UNLOCK
argument_list|(
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|nvm_mutex
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_swflag_ich8lan - Acquire software control flag  *  @hw: pointer to the HW structure  *  *  Acquires the software control flag for performing PHY and select  *  MAC CSR accesses.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_acquire_swflag_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|extcnf_ctrl
decl_stmt|,
name|timeout
init|=
name|PHY_CFG_TIMEOUT
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_swflag_ich8lan"
argument_list|)
expr_stmt|;
name|E1000_MUTEX_LOCK
argument_list|(
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|swflag_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|extcnf_ctrl
operator|&
name|E1000_EXTCNF_CTRL_SWFLAG
operator|)
condition|)
break|break;
name|msec_delay_irq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"SW has already locked the resource.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|timeout
operator|=
name|SW_FLAG_TIMEOUT
expr_stmt|;
name|extcnf_ctrl
operator||=
name|E1000_EXTCNF_CTRL_SWFLAG
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|,
name|extcnf_ctrl
argument_list|)
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extcnf_ctrl
operator|&
name|E1000_EXTCNF_CTRL_SWFLAG
condition|)
break|break;
name|msec_delay_irq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"Failed to acquire the semaphore, FW or HW has it: FWSM=0x%8.8x EXTCNF_CTRL=0x%8.8x)\n"
argument_list|,
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
argument_list|,
name|extcnf_ctrl
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator|&=
operator|~
name|E1000_EXTCNF_CTRL_SWFLAG
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|,
name|extcnf_ctrl
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|ret_val
condition|)
name|E1000_MUTEX_UNLOCK
argument_list|(
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|swflag_mutex
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_swflag_ich8lan - Release software control flag  *  @hw: pointer to the HW structure  *  *  Releases the software control flag for performing PHY and select  *  MAC CSR accesses.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_release_swflag_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|extcnf_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_swflag_ich8lan"
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extcnf_ctrl
operator|&
name|E1000_EXTCNF_CTRL_SWFLAG
condition|)
block|{
name|extcnf_ctrl
operator|&=
operator|~
name|E1000_EXTCNF_CTRL_SWFLAG
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|,
name|extcnf_ctrl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Semaphore unexpectedly released by sw/fw/hw\n"
argument_list|)
expr_stmt|;
block|}
name|E1000_MUTEX_UNLOCK
argument_list|(
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|swflag_mutex
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_mng_mode_ich8lan - Checks management mode  *  @hw: pointer to the HW structure  *  *  This checks if the adapter has any manageability enabled.  *  This is a function pointer entry point only called by read/write  *  routines for the PHY and NVM parts.  **/
end_comment

begin_function
specifier|static
name|bool
name|e1000_check_mng_mode_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|fwsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_mng_mode_ich8lan"
argument_list|)
expr_stmt|;
name|fwsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
expr_stmt|;
return|return
operator|(
name|fwsm
operator|&
name|E1000_ICH_FWSM_FW_VALID
operator|)
operator|&&
operator|(
operator|(
name|fwsm
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
operator|==
operator|(
name|E1000_ICH_MNG_IAMT_MODE
operator|<<
name|E1000_FWSM_MODE_SHIFT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_mng_mode_pchlan - Checks management mode  *  @hw: pointer to the HW structure  *  *  This checks if the adapter has iAMT enabled.  *  This is a function pointer entry point only called by read/write  *  routines for the PHY and NVM parts.  **/
end_comment

begin_function
specifier|static
name|bool
name|e1000_check_mng_mode_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|fwsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_mng_mode_pchlan"
argument_list|)
expr_stmt|;
name|fwsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
expr_stmt|;
return|return
operator|(
name|fwsm
operator|&
name|E1000_ICH_FWSM_FW_VALID
operator|)
operator|&&
operator|(
name|fwsm
operator|&
operator|(
name|E1000_ICH_MNG_IAMT_MODE
operator|<<
name|E1000_FWSM_MODE_SHIFT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_rar_set_pch2lan - Set receive address register  *  @hw: pointer to the HW structure  *  @addr: pointer to the receive address  *  @index: receive address array register  *  *  Sets the receive address array register at index to the address passed  *  in by addr.  For 82579, RAR[0] is the base address register that is to  *  contain the MAC address but RAR[1-6] are reserved for manageability (ME).  *  Use SHRA[0-3] in place of those reserved for ME.  **/
end_comment

begin_function
specifier|static
name|int
name|e1000_rar_set_pch2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|rar_low
decl_stmt|,
name|rar_high
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_rar_set_pch2lan"
argument_list|)
expr_stmt|;
comment|/* HW expects these in little endian so we reverse the byte order 	 * from network order (big endian) to little endian 	 */
name|rar_low
operator|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|rar_high
operator|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
comment|/* If MAC address zero, no need to set the AV bit */
if|if
condition|(
name|rar_low
operator|||
name|rar_high
condition|)
name|rar_high
operator||=
name|E1000_RAH_AV
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RAL
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_low
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RAH
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
comment|/* RAR[1-6] are owned by manageability.  Skip those and program the 	 * next address into the SHRA register array. 	 */
if|if
condition|(
name|index
operator|<
call|(
name|u32
call|)
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|rar_entry_count
argument_list|)
condition|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|ret_val
operator|=
name|e1000_acquire_swflag_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SHRAL
argument_list|(
name|index
operator|-
literal|1
argument_list|)
argument_list|,
name|rar_low
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SHRAH
argument_list|(
name|index
operator|-
literal|1
argument_list|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|e1000_release_swflag_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* verify the register updates */
if|if
condition|(
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SHRAL
argument_list|(
name|index
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|rar_low
operator|)
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SHRAH
argument_list|(
name|index
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|rar_high
operator|)
condition|)
return|return
name|E1000_SUCCESS
return|;
name|DEBUGOUT2
argument_list|(
literal|"SHRA[%d] might be locked by ME - FWSM=0x%8.8x\n"
argument_list|,
operator|(
name|index
operator|-
literal|1
operator|)
argument_list|,
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|DEBUGOUT1
argument_list|(
literal|"Failed to write receive address at index %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_rar_set_pch_lpt - Set receive address registers  *  @hw: pointer to the HW structure  *  @addr: pointer to the receive address  *  @index: receive address array register  *  *  Sets the receive address register array at index to the address passed  *  in by addr. For LPT, RAR[0] is the base address register that is to  *  contain the MAC address. SHRA[0-10] are the shared receive address  *  registers that are shared between the Host and manageability engine (ME).  **/
end_comment

begin_function
specifier|static
name|int
name|e1000_rar_set_pch_lpt
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|rar_low
decl_stmt|,
name|rar_high
decl_stmt|;
name|u32
name|wlock_mac
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_rar_set_pch_lpt"
argument_list|)
expr_stmt|;
comment|/* HW expects these in little endian so we reverse the byte order 	 * from network order (big endian) to little endian 	 */
name|rar_low
operator|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|rar_high
operator|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
comment|/* If MAC address zero, no need to set the AV bit */
if|if
condition|(
name|rar_low
operator|||
name|rar_high
condition|)
name|rar_high
operator||=
name|E1000_RAH_AV
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RAL
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_low
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RAH
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
comment|/* The manageability engine (ME) can lock certain SHRAR registers that 	 * it is using - those registers are unavailable for use. 	 */
if|if
condition|(
name|index
operator|<
name|hw
operator|->
name|mac
operator|.
name|rar_entry_count
condition|)
block|{
name|wlock_mac
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
operator|&
name|E1000_FWSM_WLOCK_MAC_MASK
expr_stmt|;
name|wlock_mac
operator|>>=
name|E1000_FWSM_WLOCK_MAC_SHIFT
expr_stmt|;
comment|/* Check if all SHRAR registers are locked */
if|if
condition|(
name|wlock_mac
operator|==
literal|1
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|wlock_mac
operator|==
literal|0
operator|)
operator|||
operator|(
name|index
operator|<=
name|wlock_mac
operator|)
condition|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|ret_val
operator|=
name|e1000_acquire_swflag_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SHRAL_PCH_LPT
argument_list|(
name|index
operator|-
literal|1
argument_list|)
argument_list|,
name|rar_low
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SHRAH_PCH_LPT
argument_list|(
name|index
operator|-
literal|1
argument_list|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|e1000_release_swflag_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* verify the register updates */
if|if
condition|(
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SHRAL_PCH_LPT
argument_list|(
name|index
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|rar_low
operator|)
operator|&&
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SHRAH_PCH_LPT
argument_list|(
name|index
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|rar_high
operator|)
condition|)
return|return
name|E1000_SUCCESS
return|;
block|}
block|}
name|out
label|:
name|DEBUGOUT1
argument_list|(
literal|"Failed to write receive address at index %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_mc_addr_list_pch2lan - Update Multicast addresses  *  @hw: pointer to the HW structure  *  @mc_addr_list: array of multicast addresses to program  *  @mc_addr_count: number of multicast addresses to program  *  *  Updates entire Multicast Table Array of the PCH2 MAC and PHY.  *  The caller must have a packed mc_addr_list of multicast addresses.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_update_mc_addr_list_pch2lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr_list
parameter_list|,
name|u32
name|mc_addr_count
parameter_list|)
block|{
name|u16
name|phy_reg
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_mc_addr_list_pch2lan"
argument_list|)
expr_stmt|;
name|e1000_update_mc_addr_list_generic
argument_list|(
name|hw
argument_list|,
name|mc_addr_list
argument_list|,
name|mc_addr_count
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return;
name|ret_val
operator|=
name|e1000_enable_phy_wakeup_reg_access_bm
argument_list|(
name|hw
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|mta_reg_count
condition|;
name|i
operator|++
control|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_page
argument_list|(
name|hw
argument_list|,
name|BM_MTA
argument_list|(
name|i
argument_list|)
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|mta_shadow
index|[
name|i
index|]
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_page
argument_list|(
name|hw
argument_list|,
operator|(
name|BM_MTA
argument_list|(
name|i
argument_list|)
operator|+
literal|1
operator|)
argument_list|,
call|(
name|u16
call|)
argument_list|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|mta_shadow
index|[
name|i
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|e1000_disable_phy_wakeup_reg_access_bm
argument_list|(
name|hw
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_reset_block_ich8lan - Check if PHY reset is blocked  *  @hw: pointer to the HW structure  *  *  Checks if firmware is blocking the reset of the PHY.  *  This is a function pointer entry point only called by  *  reset routines.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_check_reset_block_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|fwsm
decl_stmt|;
name|bool
name|blocked
init|=
name|FALSE
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_reset_block_ich8lan"
argument_list|)
expr_stmt|;
do|do
block|{
name|fwsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fwsm
operator|&
name|E1000_ICH_FWSM_RSPCIPHY
operator|)
condition|)
block|{
name|blocked
operator|=
name|TRUE
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|blocked
operator|=
name|FALSE
expr_stmt|;
block|}
do|while
condition|(
name|blocked
operator|&&
operator|(
name|i
operator|++
operator|<
literal|30
operator|)
condition|)
do|;
return|return
name|blocked
condition|?
name|E1000_BLK_PHY_RESET
else|:
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_smbus_addr - Write SMBus address to PHY needed during Sx states  *  @hw: pointer to the HW structure  *  *  Assumes semaphore already acquired.  *  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_write_smbus_addr
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|phy_data
decl_stmt|;
name|u32
name|strap
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STRAP
argument_list|)
decl_stmt|;
name|u32
name|freq
init|=
operator|(
name|strap
operator|&
name|E1000_STRAP_SMT_FREQ_MASK
operator|)
operator|>>
name|E1000_STRAP_SMT_FREQ_SHIFT
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|strap
operator|&=
name|E1000_STRAP_SMBUS_ADDRESS_MASK
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|HV_SMB_ADDR
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|HV_SMB_ADDR_MASK
expr_stmt|;
name|phy_data
operator||=
operator|(
name|strap
operator|>>
name|E1000_STRAP_SMBUS_ADDRESS_SHIFT
operator|)
expr_stmt|;
name|phy_data
operator||=
name|HV_SMB_ADDR_PEC_EN
operator||
name|HV_SMB_ADDR_VALID
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_i217
condition|)
block|{
comment|/* Restore SMBus frequency */
if|if
condition|(
name|freq
operator|--
condition|)
block|{
name|phy_data
operator|&=
operator|~
name|HV_SMB_ADDR_FREQ_MASK
expr_stmt|;
name|phy_data
operator||=
operator|(
name|freq
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|<<
name|HV_SMB_ADDR_FREQ_LOW_SHIFT
expr_stmt|;
name|phy_data
operator||=
operator|(
name|freq
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
operator|(
name|HV_SMB_ADDR_FREQ_HIGH_SHIFT
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Unsupported SMB frequency in PHY\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|e1000_write_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|HV_SMB_ADDR
argument_list|,
name|phy_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_sw_lcd_config_ich8lan - SW-based LCD Configuration  *  @hw:   pointer to the HW structure  *  *  SW should configure the LCD from the NVM extended configuration region  *  as a workaround for certain parts.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_sw_lcd_config_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|data
decl_stmt|,
name|cnf_size
decl_stmt|,
name|cnf_base_addr
decl_stmt|,
name|sw_cfg_mask
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|word_addr
decl_stmt|,
name|reg_data
decl_stmt|,
name|reg_addr
decl_stmt|,
name|phy_page
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_sw_lcd_config_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Initialize the PHY from the NVM on ICH platforms.  This 	 * is needed due to an issue where the NVM configuration is 	 * not properly autoloaded after power transitions. 	 * Therefore, after each PHY reset, we will load the 	 * configuration data out of the NVM manually. 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_ich8lan
case|:
if|if
condition|(
name|phy
operator|->
name|type
operator|!=
name|e1000_phy_igp_3
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_ICH8_IGP_AMT
operator|)
operator|||
operator|(
name|hw
operator|->
name|device_id
operator|==
name|E1000_DEV_ID_ICH8_IGP_C
operator|)
condition|)
block|{
name|sw_cfg_mask
operator|=
name|E1000_FEXTNVM_SW_CONFIG
expr_stmt|;
break|break;
block|}
comment|/* Fall-thru */
case|case
name|e1000_pchlan
case|:
case|case
name|e1000_pch2lan
case|:
case|case
name|e1000_pch_lpt
case|:
case|case
name|e1000_pch_spt
case|:
name|sw_cfg_mask
operator|=
name|E1000_FEXTNVM_SW_CONFIG_ICH8M
expr_stmt|;
break|break;
default|default:
return|return
name|ret_val
return|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|data
operator|&
name|sw_cfg_mask
operator|)
condition|)
goto|goto
name|release
goto|;
comment|/* Make sure HW does not configure LCD from PHY 	 * extended configuration before SW configuration 	 */
name|data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_pch2lan
operator|)
operator|&&
operator|(
name|data
operator|&
name|E1000_EXTCNF_CTRL_LCD_WRITE_ENABLE
operator|)
condition|)
goto|goto
name|release
goto|;
name|cnf_size
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_SIZE
argument_list|)
expr_stmt|;
name|cnf_size
operator|&=
name|E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH_MASK
expr_stmt|;
name|cnf_size
operator|>>=
name|E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH_SHIFT
expr_stmt|;
if|if
condition|(
operator|!
name|cnf_size
condition|)
goto|goto
name|release
goto|;
name|cnf_base_addr
operator|=
name|data
operator|&
name|E1000_EXTCNF_CTRL_EXT_CNF_POINTER_MASK
expr_stmt|;
name|cnf_base_addr
operator|>>=
name|E1000_EXTCNF_CTRL_EXT_CNF_POINTER_SHIFT
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pchlan
operator|)
operator|&&
operator|!
operator|(
name|data
operator|&
name|E1000_EXTCNF_CTRL_OEM_WRITE_ENABLE
operator|)
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>
name|e1000_pchlan
operator|)
condition|)
block|{
comment|/* HW configures the SMBus address and LEDs when the 		 * OEM and LCD Write Enable bits are set in the NVM. 		 * When both NVM bits are cleared, SW will configure 		 * them instead. 		 */
name|ret_val
operator|=
name|e1000_write_smbus_addr
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg_hv_locked
argument_list|(
name|hw
argument_list|,
name|HV_LED_CONFIG
argument_list|,
operator|(
name|u16
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
comment|/* Configure LCD from extended configuration region. */
comment|/* cnf_base_addr is in DWORD */
name|word_addr
operator|=
call|(
name|u16
call|)
argument_list|(
name|cnf_base_addr
operator|<<
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnf_size
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|(
name|word_addr
operator|+
name|i
operator|*
literal|2
operator|)
argument_list|,
literal|1
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|(
name|word_addr
operator|+
name|i
operator|*
literal|2
operator|+
literal|1
operator|)
argument_list|,
literal|1
argument_list|,
operator|&
name|reg_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
comment|/* Save off the PHY page for future writes. */
if|if
condition|(
name|reg_addr
operator|==
name|IGP01E1000_PHY_PAGE_SELECT
condition|)
block|{
name|phy_page
operator|=
name|reg_data
expr_stmt|;
continue|continue;
block|}
name|reg_addr
operator|&=
name|PHY_REG_MASK
expr_stmt|;
name|reg_addr
operator||=
name|phy_page
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
operator|(
name|u32
operator|)
name|reg_addr
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_k1_gig_workaround_hv - K1 Si workaround  *  @hw:   pointer to the HW structure  *  @link: link up bool flag  *  *  If K1 is enabled for 1Gbps, the MAC might stall when transitioning  *  from a lower speed.  This workaround disables K1 whenever link is at 1Gig  *  If link is down, the function will restore the default K1 setting located  *  in the NVM.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_k1_gig_workaround_hv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|link
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|status_reg
init|=
literal|0
decl_stmt|;
name|bool
name|k1_enable
init|=
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|nvm_k1_enabled
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_k1_gig_workaround_hv"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_pchlan
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Wrap the whole flow with the sw flag */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Disable K1 when link is 1Gbps, otherwise use the NVM setting */
if|if
condition|(
name|link
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82578
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|BM_CS_STATUS
argument_list|,
operator|&
name|status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|status_reg
operator|&=
operator|(
name|BM_CS_STATUS_LINK_UP
operator||
name|BM_CS_STATUS_RESOLVED
operator||
name|BM_CS_STATUS_SPEED_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|status_reg
operator|==
operator|(
name|BM_CS_STATUS_LINK_UP
operator||
name|BM_CS_STATUS_RESOLVED
operator||
name|BM_CS_STATUS_SPEED_1000
operator|)
condition|)
name|k1_enable
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82577
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|HV_M_STATUS
argument_list|,
operator|&
name|status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|status_reg
operator|&=
operator|(
name|HV_M_STATUS_LINK_UP
operator||
name|HV_M_STATUS_AUTONEG_COMPLETE
operator||
name|HV_M_STATUS_SPEED_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|status_reg
operator|==
operator|(
name|HV_M_STATUS_LINK_UP
operator||
name|HV_M_STATUS_AUTONEG_COMPLETE
operator||
name|HV_M_STATUS_SPEED_1000
operator|)
condition|)
name|k1_enable
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Link stall fix for link up */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|770
argument_list|,
literal|19
argument_list|)
argument_list|,
literal|0x0100
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
else|else
block|{
comment|/* Link stall fix for link down */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|770
argument_list|,
literal|19
argument_list|)
argument_list|,
literal|0x4100
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
name|ret_val
operator|=
name|e1000_configure_k1_ich8lan
argument_list|(
name|hw
argument_list|,
name|k1_enable
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_configure_k1_ich8lan - Configure K1 power state  *  @hw: pointer to the HW structure  *  @enable: K1 state to configure  *  *  Configure the K1 power state based on the provided parameter.  *  Assumes semaphore already acquired.  *  *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)  **/
end_comment

begin_function
name|s32
name|e1000_configure_k1_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|k1_enable
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u32
name|ctrl_reg
init|=
literal|0
decl_stmt|;
name|u32
name|ctrl_ext
init|=
literal|0
decl_stmt|;
name|u32
name|reg
init|=
literal|0
decl_stmt|;
name|u16
name|kmrn_reg
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_configure_k1_ich8lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_kmrn_reg_locked
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_K1_CONFIG
argument_list|,
operator|&
name|kmrn_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|k1_enable
condition|)
name|kmrn_reg
operator||=
name|E1000_KMRNCTRLSTA_K1_ENABLE
expr_stmt|;
else|else
name|kmrn_reg
operator|&=
operator|~
name|E1000_KMRNCTRLSTA_K1_ENABLE
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg_locked
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_K1_CONFIG
argument_list|,
name|kmrn_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|usec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|reg
operator|=
name|ctrl_reg
operator|&
operator|~
operator|(
name|E1000_CTRL_SPD_1000
operator||
name|E1000_CTRL_SPD_100
operator|)
expr_stmt|;
name|reg
operator||=
name|E1000_CTRL_FRCSPD
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
operator||
name|E1000_CTRL_EXT_SPD_BYPS
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_oem_bits_config_ich8lan - SW-based LCD Configuration  *  @hw:       pointer to the HW structure  *  @d0_state: boolean if entering d0 or d3 device state  *  *  SW will configure Gbe Disable and LPLU based on the NVM. The four bits are  *  collectively called OEM bits.  The OEM Write Enable bit and SW Config bit  *  in NVM determines whether HW should configure LPLU and Gbe Disable.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_oem_bits_config_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|d0_state
parameter_list|)
block|{
name|s32
name|ret_val
init|=
literal|0
decl_stmt|;
name|u32
name|mac_reg
decl_stmt|;
name|u16
name|oem_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_oem_bits_config_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_pchlan
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pchlan
condition|)
block|{
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac_reg
operator|&
name|E1000_EXTCNF_CTRL_OEM_WRITE_ENABLE
condition|)
goto|goto
name|release
goto|;
block|}
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mac_reg
operator|&
name|E1000_FEXTNVM_SW_CONFIG_ICH8M
operator|)
condition|)
goto|goto
name|release
goto|;
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|HV_OEM_BITS
argument_list|,
operator|&
name|oem_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|oem_reg
operator|&=
operator|~
operator|(
name|HV_OEM_BITS_GBE_DIS
operator||
name|HV_OEM_BITS_LPLU
operator|)
expr_stmt|;
if|if
condition|(
name|d0_state
condition|)
block|{
if|if
condition|(
name|mac_reg
operator|&
name|E1000_PHY_CTRL_GBE_DISABLE
condition|)
name|oem_reg
operator||=
name|HV_OEM_BITS_GBE_DIS
expr_stmt|;
if|if
condition|(
name|mac_reg
operator|&
name|E1000_PHY_CTRL_D0A_LPLU
condition|)
name|oem_reg
operator||=
name|HV_OEM_BITS_LPLU
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mac_reg
operator|&
operator|(
name|E1000_PHY_CTRL_GBE_DISABLE
operator||
name|E1000_PHY_CTRL_NOND0A_GBE_DISABLE
operator|)
condition|)
name|oem_reg
operator||=
name|HV_OEM_BITS_GBE_DIS
expr_stmt|;
if|if
condition|(
name|mac_reg
operator|&
operator|(
name|E1000_PHY_CTRL_D0A_LPLU
operator||
name|E1000_PHY_CTRL_NOND0A_LPLU
operator|)
condition|)
name|oem_reg
operator||=
name|HV_OEM_BITS_LPLU
expr_stmt|;
block|}
comment|/* Set Restart auto-neg to activate the bits */
if|if
condition|(
operator|(
name|d0_state
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_pchlan
operator|)
operator|)
operator|&&
operator|!
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_reset_block
argument_list|(
name|hw
argument_list|)
condition|)
name|oem_reg
operator||=
name|HV_OEM_BITS_RESTART_AN
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|HV_OEM_BITS
argument_list|,
name|oem_reg
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_mdio_slow_mode_hv - Set slow MDIO access mode  *  @hw:   pointer to the HW structure  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_set_mdio_slow_mode_hv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_mdio_slow_mode_hv"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|HV_KMRN_MODE_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator||=
name|HV_KMRN_MDIO_SLOW
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|HV_KMRN_MODE_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_hv_phy_workarounds_ich8lan - A series of Phy workarounds to be  *  done after every PHY reset.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_hv_phy_workarounds_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_hv_phy_workarounds_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_pchlan
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Set MDIO slow mode before any other MDIO access */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82577
condition|)
block|{
name|ret_val
operator|=
name|e1000_set_mdio_slow_mode_hv
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82577
operator|)
operator|&&
operator|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|revision
operator|==
literal|1
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|revision
operator|==
literal|2
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82578
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|revision
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* Disable generation of early preamble */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|769
argument_list|,
literal|25
argument_list|)
argument_list|,
literal|0x4431
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Preamble tuning for SSC */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|HV_KMRN_FIFO_CTRLSTA
argument_list|,
literal|0xA204
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82578
condition|)
block|{
comment|/* Return registers to default by doing a soft reset then 		 * writing 0x3140 to the control register. 		 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|revision
operator|<
literal|2
condition|)
block|{
name|e1000_phy_sw_reset_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
literal|0x3140
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Select page 0 */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
literal|1
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Configure the K1 Si workaround during phy reset assuming there is 	 * link so that it disables K1 if link is in 1Gbps. 	 */
name|ret_val
operator|=
name|e1000_k1_gig_workaround_hv
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Workaround for link disconnects on a busy hub in half duplex */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|BM_PORT_GEN_CFG
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|BM_PORT_GEN_CFG
argument_list|,
name|phy_data
operator|&
literal|0x00FF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
comment|/* set MSE higher to enable link to stay up when noise is high */
name|ret_val
operator|=
name|e1000_write_emi_reg_locked
argument_list|(
name|hw
argument_list|,
name|I82577_MSE_THRESHOLD
argument_list|,
literal|0x0034
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_copy_rx_addrs_to_phy_ich8lan - Copy Rx addresses from MAC to PHY  *  @hw:   pointer to the HW structure  **/
end_comment

begin_function
name|void
name|e1000_copy_rx_addrs_to_phy_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|mac_reg
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|phy_reg
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_copy_rx_addrs_to_phy_ich8lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return;
name|ret_val
operator|=
name|e1000_enable_phy_wakeup_reg_access_bm
argument_list|(
name|hw
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
comment|/* Copy both RAL/H (rar_entry_count) and SHRAL/H to PHY */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|hw
operator|->
name|mac
operator|.
name|rar_entry_count
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RAL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_page
argument_list|(
name|hw
argument_list|,
name|BM_RAR_L
argument_list|(
name|i
argument_list|)
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|mac_reg
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_page
argument_list|(
name|hw
argument_list|,
name|BM_RAR_M
argument_list|(
name|i
argument_list|)
argument_list|,
call|(
name|u16
call|)
argument_list|(
operator|(
name|mac_reg
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RAH
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_page
argument_list|(
name|hw
argument_list|,
name|BM_RAR_H
argument_list|(
name|i
argument_list|)
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|mac_reg
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_page
argument_list|(
name|hw
argument_list|,
name|BM_RAR_CTRL
argument_list|(
name|i
argument_list|)
argument_list|,
call|(
name|u16
call|)
argument_list|(
operator|(
name|mac_reg
operator|&
name|E1000_RAH_AV
operator|)
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|e1000_disable_phy_wakeup_reg_access_bm
argument_list|(
name|hw
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u32
name|e1000_calc_rx_da_crc
parameter_list|(
name|u8
name|mac
index|[]
parameter_list|)
block|{
name|u32
name|poly
init|=
literal|0xEDB88320
decl_stmt|;
comment|/* Polynomial for 802.3 CRC calculation */
name|u32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|mask
decl_stmt|,
name|crc
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_calc_rx_da_crc"
argument_list|)
expr_stmt|;
name|crc
operator|=
literal|0xffffffff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|crc
operator|=
name|crc
operator|^
name|mac
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|8
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|mask
operator|=
operator|(
name|crc
operator|&
literal|1
operator|)
operator|*
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|1
operator|)
operator|^
operator|(
name|poly
operator|&
name|mask
operator|)
expr_stmt|;
block|}
block|}
return|return
operator|~
name|crc
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_lv_jumbo_workaround_ich8lan - required for jumbo frame operation  *  with 82579 PHY  *  @hw: pointer to the HW structure  *  @enable: flag to enable/disable workaround when enabling/disabling jumbos  **/
end_comment

begin_function
name|s32
name|e1000_lv_jumbo_workaround_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|phy_reg
decl_stmt|,
name|data
decl_stmt|;
name|u32
name|mac_reg
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_lv_jumbo_workaround_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_pch2lan
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* disable Rx path while enabling/disabling workaround */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|769
argument_list|,
literal|20
argument_list|)
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|769
argument_list|,
literal|20
argument_list|)
argument_list|,
name|phy_reg
operator||
operator|(
literal|1
operator|<<
literal|14
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|enable
condition|)
block|{
comment|/* Write Rx addresses (rar_entry_count for RAL/H, and 		 * SHRAL/H) and initial CRC values to the MAC 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|rar_entry_count
condition|;
name|i
operator|++
control|)
block|{
name|u8
name|mac_addr
index|[
name|ETH_ADDR_LEN
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|u32
name|addr_high
decl_stmt|,
name|addr_low
decl_stmt|;
name|addr_high
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RAH
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|addr_high
operator|&
name|E1000_RAH_AV
operator|)
condition|)
continue|continue;
name|addr_low
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RAL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mac_addr
index|[
literal|0
index|]
operator|=
operator|(
name|addr_low
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|mac_addr
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|addr_low
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|mac_addr
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|addr_low
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|mac_addr
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|addr_low
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|mac_addr
index|[
literal|4
index|]
operator|=
operator|(
name|addr_high
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|mac_addr
index|[
literal|5
index|]
operator|=
operator|(
operator|(
name|addr_high
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCH_RAICC
argument_list|(
name|i
argument_list|)
argument_list|,
name|e1000_calc_rx_da_crc
argument_list|(
name|mac_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write Rx addresses to the PHY */
name|e1000_copy_rx_addrs_to_phy_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Enable jumbo frame workaround in the MAC */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FFLT_DBG
argument_list|)
expr_stmt|;
name|mac_reg
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|14
operator|)
expr_stmt|;
name|mac_reg
operator||=
operator|(
literal|7
operator|<<
literal|15
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FFLT_DBG
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|mac_reg
operator||=
name|E1000_RCTL_SECRC
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_kmrn_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_CTRL_OFFSET
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_CTRL_OFFSET
argument_list|,
name|data
operator||
operator|(
literal|1
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_read_kmrn_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_HD_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|~
operator|(
literal|0xF
operator|<<
literal|8
operator|)
expr_stmt|;
name|data
operator||=
operator|(
literal|0xB
operator|<<
literal|8
operator|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_HD_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Enable jumbo frame workaround in the PHY */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|769
argument_list|,
literal|23
argument_list|)
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
operator|(
literal|0x7F
operator|<<
literal|5
operator|)
expr_stmt|;
name|data
operator||=
operator|(
literal|0x37
operator|<<
literal|5
operator|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|769
argument_list|,
literal|23
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|769
argument_list|,
literal|16
argument_list|)
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|13
operator|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|769
argument_list|,
literal|16
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|776
argument_list|,
literal|20
argument_list|)
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
operator|(
literal|0x3FF
operator|<<
literal|2
operator|)
expr_stmt|;
name|data
operator||=
operator|(
name|E1000_TX_PTR_GAP
operator|<<
literal|2
operator|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|776
argument_list|,
literal|20
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|776
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|0xF100
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|HV_PM_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|HV_PM_CTRL
argument_list|,
name|data
operator||
operator|(
literal|1
operator|<<
literal|10
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
comment|/* Write MAC register values back to h/w defaults */
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FFLT_DBG
argument_list|)
expr_stmt|;
name|mac_reg
operator|&=
operator|~
operator|(
literal|0xF
operator|<<
literal|14
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FFLT_DBG
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|mac_reg
operator|&=
operator|~
name|E1000_RCTL_SECRC
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_kmrn_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_CTRL_OFFSET
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_CTRL_OFFSET
argument_list|,
name|data
operator|&
operator|~
operator|(
literal|1
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_read_kmrn_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_HD_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|~
operator|(
literal|0xF
operator|<<
literal|8
operator|)
expr_stmt|;
name|data
operator||=
operator|(
literal|0xB
operator|<<
literal|8
operator|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_HD_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Write PHY register values back to h/w defaults */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|769
argument_list|,
literal|23
argument_list|)
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
operator|(
literal|0x7F
operator|<<
literal|5
operator|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|769
argument_list|,
literal|23
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|769
argument_list|,
literal|16
argument_list|)
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|data
operator||=
operator|(
literal|1
operator|<<
literal|13
operator|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|769
argument_list|,
literal|16
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|776
argument_list|,
literal|20
argument_list|)
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
operator|(
literal|0x3FF
operator|<<
literal|2
operator|)
expr_stmt|;
name|data
operator||=
operator|(
literal|0x8
operator|<<
literal|2
operator|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|776
argument_list|,
literal|20
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|776
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|0x7E00
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|HV_PM_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|HV_PM_CTRL
argument_list|,
name|data
operator|&
operator|~
operator|(
literal|1
operator|<<
literal|10
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* re-enable Rx path after enabling/disabling workaround */
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
literal|769
argument_list|,
literal|20
argument_list|)
argument_list|,
name|phy_reg
operator|&
operator|~
operator|(
literal|1
operator|<<
literal|14
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_lv_phy_workarounds_ich8lan - A series of Phy workarounds to be  *  done after every PHY reset.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_lv_phy_workarounds_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_lv_phy_workarounds_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_pch2lan
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Set MDIO slow mode before any other MDIO access */
name|ret_val
operator|=
name|e1000_set_mdio_slow_mode_hv
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* set MSE higher to enable link to stay up when noise is high */
name|ret_val
operator|=
name|e1000_write_emi_reg_locked
argument_list|(
name|hw
argument_list|,
name|I82579_MSE_THRESHOLD
argument_list|,
literal|0x0034
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
comment|/* drop link after 5 times MSE threshold was reached */
name|ret_val
operator|=
name|e1000_write_emi_reg_locked
argument_list|(
name|hw
argument_list|,
name|I82579_MSE_LINK_DOWN
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_k1_gig_workaround_lv - K1 Si workaround  *  @hw:   pointer to the HW structure  *  *  Workaround to set the K1 beacon duration for 82579 parts in 10Mbps  *  Disable K1 for 1000 and 100 speeds  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_k1_workaround_lv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|status_reg
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_k1_workaround_lv"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_pch2lan
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Set K1 beacon duration based on 10Mbs speed */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|HV_M_STATUS
argument_list|,
operator|&
name|status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|status_reg
operator|&
operator|(
name|HV_M_STATUS_LINK_UP
operator||
name|HV_M_STATUS_AUTONEG_COMPLETE
operator|)
operator|)
operator|==
operator|(
name|HV_M_STATUS_LINK_UP
operator||
name|HV_M_STATUS_AUTONEG_COMPLETE
operator|)
condition|)
block|{
if|if
condition|(
name|status_reg
operator|&
operator|(
name|HV_M_STATUS_SPEED_1000
operator||
name|HV_M_STATUS_SPEED_100
operator|)
condition|)
block|{
name|u16
name|pm_phy_reg
decl_stmt|;
comment|/* LV 1G/100 Packet drop issue wa  */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|HV_PM_CTRL
argument_list|,
operator|&
name|pm_phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|pm_phy_reg
operator|&=
operator|~
name|HV_PM_CTRL_K1_ENABLE
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|HV_PM_CTRL
argument_list|,
name|pm_phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
name|u32
name|mac_reg
decl_stmt|;
name|mac_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM4
argument_list|)
expr_stmt|;
name|mac_reg
operator|&=
operator|~
name|E1000_FEXTNVM4_BEACON_DURATION_MASK
expr_stmt|;
name|mac_reg
operator||=
name|E1000_FEXTNVM4_BEACON_DURATION_16USEC
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM4
argument_list|,
name|mac_reg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_gate_hw_phy_config_ich8lan - disable PHY config via hardware  *  @hw:   pointer to the HW structure  *  @gate: boolean set to TRUE to gate, FALSE to ungate  *  *  Gate/ungate the automatic PHY configuration via hardware; perform  *  the configuration via software instead.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_gate_hw_phy_config_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|gate
parameter_list|)
block|{
name|u32
name|extcnf_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_gate_hw_phy_config_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_pch2lan
condition|)
return|return;
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gate
condition|)
name|extcnf_ctrl
operator||=
name|E1000_EXTCNF_CTRL_GATE_PHY_CFG
expr_stmt|;
else|else
name|extcnf_ctrl
operator|&=
operator|~
name|E1000_EXTCNF_CTRL_GATE_PHY_CFG
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|,
name|extcnf_ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_lan_init_done_ich8lan - Check for PHY config completion  *  @hw: pointer to the HW structure  *  *  Check the appropriate indication the MAC has finished configuring the  *  PHY after a software reset.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_lan_init_done_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|data
decl_stmt|,
name|loop
init|=
name|E1000_ICH8_LAN_INIT_TIMEOUT
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_lan_init_done_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Wait for basic configuration completes before proceeding */
do|do
block|{
name|data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|data
operator|&=
name|E1000_STATUS_LAN_INIT_DONE
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|!
name|data
operator|)
operator|&&
operator|--
name|loop
condition|)
do|;
comment|/* If basic configuration is incomplete before the above loop 	 * count reaches 0, loading the configuration from NVM will 	 * leave the PHY in a bad state possibly resulting in no link. 	 */
if|if
condition|(
name|loop
operator|==
literal|0
condition|)
name|DEBUGOUT
argument_list|(
literal|"LAN_INIT_DONE not set, increase timeout\n"
argument_list|)
expr_stmt|;
comment|/* Clear the Init Done bit for the next init event */
name|data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
name|E1000_STATUS_LAN_INIT_DONE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_post_phy_reset_ich8lan - Perform steps required after a PHY reset  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_post_phy_reset_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_post_phy_reset_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_reset_block
argument_list|(
name|hw
argument_list|)
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Allow time for h/w to get to quiescent state after reset */
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Perform any necessary post-reset workarounds */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_pchlan
case|:
name|ret_val
operator|=
name|e1000_hv_phy_workarounds_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
break|break;
case|case
name|e1000_pch2lan
case|:
name|ret_val
operator|=
name|e1000_lv_phy_workarounds_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
break|break;
default|default:
break|break;
block|}
comment|/* Clear the host wakeup bit after lcd reset */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pchlan
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|BM_PORT_GEN_CFG
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|BM_WUC_HOST_WU_BIT
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|BM_PORT_GEN_CFG
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Configure the LCD with the extended configuration region in NVM */
name|ret_val
operator|=
name|e1000_sw_lcd_config_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Configure the LCD with the OEM bits in NVM */
name|ret_val
operator|=
name|e1000_oem_bits_config_ich8lan
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
condition|)
block|{
comment|/* Ungate automatic PHY configuration on non-managed 82579 */
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
operator|&
name|E1000_ICH_FWSM_FW_VALID
operator|)
condition|)
block|{
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|e1000_gate_hw_phy_config_ich8lan
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Set EEE LPI Update Timer to 200usec */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_write_emi_reg_locked
argument_list|(
name|hw
argument_list|,
name|I82579_LPI_UPDATE_TIMER
argument_list|,
literal|0x1387
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_hw_reset_ich8lan - Performs a PHY reset  *  @hw: pointer to the HW structure  *  *  Resets the PHY  *  This is a function pointer entry point called by drivers  *  or other shared routines.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_phy_hw_reset_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_hw_reset_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Gate automatic PHY configuration by hardware on non-managed 82579 */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
operator|)
operator|&&
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
operator|&
name|E1000_ICH_FWSM_FW_VALID
operator|)
condition|)
name|e1000_gate_hw_phy_config_ich8lan
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_hw_reset_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
return|return
name|e1000_post_phy_reset_ich8lan
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_lplu_state_pchlan - Set Low Power Link Up state  *  @hw: pointer to the HW structure  *  @active: TRUE to enable LPLU, FALSE to disable  *  *  Sets the LPLU state according to the active flag.  For PCH, if OEM write  *  bit are disabled in the NVM, writing the LPLU bits in the MAC will not set  *  the phy speed. This function will manually set the LPLU bit and restart  *  auto-neg as hw would do. D3 and D0 LPLU will call the same function  *  since it configures the same bit.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_set_lplu_state_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|oem_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_lplu_state_pchlan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|HV_OEM_BITS
argument_list|,
operator|&
name|oem_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|active
condition|)
name|oem_reg
operator||=
name|HV_OEM_BITS_LPLU
expr_stmt|;
else|else
name|oem_reg
operator|&=
operator|~
name|HV_OEM_BITS_LPLU
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_reset_block
argument_list|(
name|hw
argument_list|)
condition|)
name|oem_reg
operator||=
name|HV_OEM_BITS_RESTART_AN
expr_stmt|;
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|HV_OEM_BITS
argument_list|,
name|oem_reg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d0_lplu_state_ich8lan - Set Low Power Linkup D0 state  *  @hw: pointer to the HW structure  *  @active: TRUE to enable LPLU, FALSE to disable  *  *  Sets the LPLU D0 state according to the active flag.  When  *  activating LPLU this function also disables smart speed  *  and vice versa.  LPLU will not be activated unless the  *  device autonegotiation advertisement meets standards of  *  either 10 or 10/100 or 10/100/1000 at all duplexes.  *  This is a function pointer entry point only called by  *  PHY setup routines.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_set_d0_lplu_state_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|phy_ctrl
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d0_lplu_state_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|e1000_phy_ife
condition|)
return|return
name|E1000_SUCCESS
return|;
name|phy_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
condition|)
block|{
name|phy_ctrl
operator||=
name|E1000_PHY_CTRL_D0A_LPLU
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|!=
name|e1000_phy_igp_3
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Call gig speed drop workaround on LPLU before accessing 		 * any PHY registers 		 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
condition|)
name|e1000_gig_downshift_workaround_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* When LPLU is enabled, we should disable SmartSpeed */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
name|phy_ctrl
operator|&=
operator|~
name|E1000_PHY_CTRL_D0A_LPLU
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|!=
name|e1000_phy_igp_3
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used 		 * during Dx states where the power conservation is most 		 * important.  During driver activity we should enable 		 * SmartSpeed, so performance is maintained. 		 */
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_on
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator||=
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_off
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d3_lplu_state_ich8lan - Set Low Power Linkup D3 state  *  @hw: pointer to the HW structure  *  @active: TRUE to enable LPLU, FALSE to disable  *  *  Sets the LPLU D3 state according to the active flag.  When  *  activating LPLU this function also disables smart speed  *  and vice versa.  LPLU will not be activated unless the  *  device autonegotiation advertisement meets standards of  *  either 10 or 10/100 or 10/100/1000 at all duplexes.  *  This is a function pointer entry point only called by  *  PHY setup routines.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_set_d3_lplu_state_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|phy_ctrl
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d3_lplu_state_ich8lan"
argument_list|)
expr_stmt|;
name|phy_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|active
condition|)
block|{
name|phy_ctrl
operator|&=
operator|~
name|E1000_PHY_CTRL_NOND0A_LPLU
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|!=
name|e1000_phy_igp_3
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used 		 * during Dx states where the power conservation is most 		 * important.  During driver activity we should enable 		 * SmartSpeed, so performance is maintained. 		 */
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_on
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator||=
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_off
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_SPEED_DUPLEX
operator|)
operator|||
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_NOT_GIG
operator|)
operator|||
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_10_SPEED
operator|)
condition|)
block|{
name|phy_ctrl
operator||=
name|E1000_PHY_CTRL_NOND0A_LPLU
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|!=
name|e1000_phy_igp_3
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Call gig speed drop workaround on LPLU before accessing 		 * any PHY registers 		 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
condition|)
name|e1000_gig_downshift_workaround_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* When LPLU is enabled, we should disable SmartSpeed */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_valid_nvm_bank_detect_ich8lan - finds out the valid bank 0 or 1  *  @hw: pointer to the HW structure  *  @bank:  pointer to the variable that returns the active bank  *  *  Reads signature byte from the NVM using the flash access registers.  *  Word 0x13 bits 15:14 = 10b indicate a valid signature for that bank.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_valid_nvm_bank_detect_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|bank
parameter_list|)
block|{
name|u32
name|eecd
decl_stmt|;
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|u32
name|bank1_offset
init|=
name|nvm
operator|->
name|flash_bank_size
operator|*
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
decl_stmt|;
name|u32
name|act_offset
init|=
name|E1000_ICH_NVM_SIG_WORD
operator|*
literal|2
operator|+
literal|1
decl_stmt|;
name|u32
name|nvm_dword
init|=
literal|0
decl_stmt|;
name|u8
name|sig_byte
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_valid_nvm_bank_detect_ich8lan"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_pch_spt
case|:
name|bank1_offset
operator|=
name|nvm
operator|->
name|flash_bank_size
expr_stmt|;
name|act_offset
operator|=
name|E1000_ICH_NVM_SIG_WORD
expr_stmt|;
comment|/* set bank to 0 in case flash read fails */
operator|*
name|bank
operator|=
literal|0
expr_stmt|;
comment|/* Check bank 0 */
name|ret_val
operator|=
name|e1000_read_flash_dword_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
argument_list|,
operator|&
name|nvm_dword
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|sig_byte
operator|=
call|(
name|u8
call|)
argument_list|(
operator|(
name|nvm_dword
operator|&
literal|0xFF00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sig_byte
operator|&
name|E1000_ICH_NVM_VALID_SIG_MASK
operator|)
operator|==
name|E1000_ICH_NVM_SIG_VALUE
condition|)
block|{
operator|*
name|bank
operator|=
literal|0
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
comment|/* Check bank 1 */
name|ret_val
operator|=
name|e1000_read_flash_dword_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
operator|+
name|bank1_offset
argument_list|,
operator|&
name|nvm_dword
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|sig_byte
operator|=
call|(
name|u8
call|)
argument_list|(
operator|(
name|nvm_dword
operator|&
literal|0xFF00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sig_byte
operator|&
name|E1000_ICH_NVM_VALID_SIG_MASK
operator|)
operator|==
name|E1000_ICH_NVM_SIG_VALUE
condition|)
block|{
operator|*
name|bank
operator|=
literal|1
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"ERROR: No valid NVM bank present\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
case|case
name|e1000_ich8lan
case|:
case|case
name|e1000_ich9lan
case|:
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eecd
operator|&
name|E1000_EECD_SEC1VAL_VALID_MASK
operator|)
operator|==
name|E1000_EECD_SEC1VAL_VALID_MASK
condition|)
block|{
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_SEC1VAL
condition|)
operator|*
name|bank
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|bank
operator|=
literal|0
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Unable to determine valid NVM bank via EEC - reading flash signature\n"
argument_list|)
expr_stmt|;
comment|/* fall-thru */
default|default:
comment|/* set bank to 0 in case flash read fails */
operator|*
name|bank
operator|=
literal|0
expr_stmt|;
comment|/* Check bank 0 */
name|ret_val
operator|=
name|e1000_read_flash_byte_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
argument_list|,
operator|&
name|sig_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|sig_byte
operator|&
name|E1000_ICH_NVM_VALID_SIG_MASK
operator|)
operator|==
name|E1000_ICH_NVM_SIG_VALUE
condition|)
block|{
operator|*
name|bank
operator|=
literal|0
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
comment|/* Check bank 1 */
name|ret_val
operator|=
name|e1000_read_flash_byte_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
operator|+
name|bank1_offset
argument_list|,
operator|&
name|sig_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|sig_byte
operator|&
name|E1000_ICH_NVM_VALID_SIG_MASK
operator|)
operator|==
name|E1000_ICH_NVM_SIG_VALUE
condition|)
block|{
operator|*
name|bank
operator|=
literal|1
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"ERROR: No valid NVM bank present\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_read_nvm_spt - NVM access for SPT  *  @hw: pointer to the HW structure  *  @offset: The offset (in bytes) of the word(s) to read.  *  @words: Size of data to read in words.  *  @data: pointer to the word(s) to read at offset.  *  *  Reads a word(s) from the NVM  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_nvm_spt
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
decl_stmt|;
name|u32
name|act_offset
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|bank
init|=
literal|0
decl_stmt|;
name|u32
name|dword
init|=
literal|0
decl_stmt|;
name|u16
name|offset_to_read
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_nvm_spt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|>=
name|nvm
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
name|nvm
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"nvm parameter(s) out of bounds\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|nvm
operator|->
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_valid_nvm_bank_detect_ich8lan
argument_list|(
name|hw
argument_list|,
operator|&
name|bank
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not detect valid bank, assuming bank 0\n"
argument_list|)
expr_stmt|;
name|bank
operator|=
literal|0
expr_stmt|;
block|}
name|act_offset
operator|=
operator|(
name|bank
operator|)
condition|?
name|nvm
operator|->
name|flash_bank_size
else|:
literal|0
expr_stmt|;
name|act_offset
operator|+=
name|offset
expr_stmt|;
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|words
operator|-
name|i
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|modified
condition|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
name|offset_to_read
operator|=
name|act_offset
operator|+
name|i
operator|-
operator|(
operator|(
name|act_offset
operator|+
name|i
operator|)
operator|%
literal|2
operator|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_flash_dword_ich8lan
argument_list|(
name|hw
argument_list|,
name|offset_to_read
argument_list|,
operator|&
name|dword
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
if|if
condition|(
operator|(
name|act_offset
operator|+
name|i
operator|)
operator|%
literal|2
operator|==
literal|0
condition|)
name|data
index|[
name|i
index|]
operator|=
call|(
name|u16
call|)
argument_list|(
name|dword
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
else|else
name|data
index|[
name|i
index|]
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|dword
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|offset_to_read
operator|=
name|act_offset
operator|+
name|i
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|modified
operator|)
operator|||
operator|!
operator|(
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
operator|+
literal|1
index|]
operator|.
name|modified
operator|)
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_flash_dword_ich8lan
argument_list|(
name|hw
argument_list|,
name|offset_to_read
argument_list|,
operator|&
name|dword
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
block|}
if|if
condition|(
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|modified
condition|)
name|data
index|[
name|i
index|]
operator|=
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|value
expr_stmt|;
else|else
name|data
index|[
name|i
index|]
operator|=
call|(
name|u16
call|)
argument_list|(
name|dword
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|modified
condition|)
name|data
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
operator|+
literal|1
index|]
operator|.
name|value
expr_stmt|;
else|else
name|data
index|[
name|i
operator|+
literal|1
index|]
operator|=
call|(
name|u16
call|)
argument_list|(
name|dword
operator|>>
literal|16
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
block|}
block|}
name|nvm
operator|->
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT1
argument_list|(
literal|"NVM read error: %d\n"
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_nvm_ich8lan - Read word(s) from the NVM  *  @hw: pointer to the HW structure  *  @offset: The offset (in bytes) of the word(s) to read.  *  @words: Size of data to read in words  *  @data: Pointer to the word(s) to read at offset.  *  *  Reads a word(s) from the NVM using the flash access registers.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_nvm_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
decl_stmt|;
name|u32
name|act_offset
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|bank
init|=
literal|0
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|word
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_nvm_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|>=
name|nvm
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
name|nvm
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"nvm parameter(s) out of bounds\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|nvm
operator|->
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_valid_nvm_bank_detect_ich8lan
argument_list|(
name|hw
argument_list|,
operator|&
name|bank
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not detect valid bank, assuming bank 0\n"
argument_list|)
expr_stmt|;
name|bank
operator|=
literal|0
expr_stmt|;
block|}
name|act_offset
operator|=
operator|(
name|bank
operator|)
condition|?
name|nvm
operator|->
name|flash_bank_size
else|:
literal|0
expr_stmt|;
name|act_offset
operator|+=
name|offset
expr_stmt|;
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|modified
condition|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|e1000_read_flash_word_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
operator|+
name|i
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
name|data
index|[
name|i
index|]
operator|=
name|word
expr_stmt|;
block|}
block|}
name|nvm
operator|->
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT1
argument_list|(
literal|"NVM read error: %d\n"
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_flash_cycle_init_ich8lan - Initialize flash  *  @hw: pointer to the HW structure  *  *  This function does initial flash setup so that a new read/write/erase cycle  *  can be started.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_flash_cycle_init_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_NVM
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_flash_cycle_init_ich8lan"
argument_list|)
expr_stmt|;
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
comment|/* Check if the flash descriptor is valid */
if|if
condition|(
operator|!
name|hsfsts
operator|.
name|hsf_status
operator|.
name|fldesvalid
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flash descriptor invalid.  SW Sequencing must be used.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
comment|/* Clear FCERR and DAEL in hw status by writing 1 */
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
operator|=
literal|1
expr_stmt|;
name|hsfsts
operator|.
name|hsf_status
operator|.
name|dael
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsfsts
operator|.
name|regval
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
else|else
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsfsts
operator|.
name|regval
argument_list|)
expr_stmt|;
comment|/* Either we should have a hardware SPI cycle in progress 	 * bit to check against, in order to start a new cycle or 	 * FDONE bit should be changed in the hardware so that it 	 * is 1 after hardware reset, which can then be used as an 	 * indication whether a cycle is in progress or has been 	 * completed. 	 */
if|if
condition|(
operator|!
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcinprog
condition|)
block|{
comment|/* There is no cycle running at present, 		 * so we can start a cycle. 		 * Begin by setting Flash Cycle Done. 		 */
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsfsts
operator|.
name|regval
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
else|else
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsfsts
operator|.
name|regval
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|s32
name|i
decl_stmt|;
comment|/* Otherwise poll for sometime so the current 		 * cycle has a chance to end before giving up. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ICH_FLASH_READ_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcinprog
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
block|{
comment|/* Successful in waiting for previous cycle to timeout, 			 * now set the Flash Cycle Done. 			 */
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsfsts
operator|.
name|regval
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
else|else
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsfsts
operator|.
name|regval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Flash controller busy, cannot get access\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_flash_cycle_ich8lan - Starts flash cycle (read/write/erase)  *  @hw: pointer to the HW structure  *  @timeout: maximum time to wait for completion  *  *  This function starts a flash cycle and waits for its completion.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_flash_cycle_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|timeout
parameter_list|)
block|{
name|union
name|ich8_hws_flash_ctrl
name|hsflctl
decl_stmt|;
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_flash_cycle_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Start a cycle by writing 1 in Flash Cycle Go in Hw Flash Control */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
operator|>>
literal|16
expr_stmt|;
else|else
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|)
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|flcgo
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsflctl
operator|.
name|regval
operator|<<
literal|16
argument_list|)
expr_stmt|;
else|else
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|,
name|hsflctl
operator|.
name|regval
argument_list|)
expr_stmt|;
comment|/* wait till FDONE bit is set to 1 */
do|do
block|{
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
condition|)
break|break;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|++
operator|<
name|timeout
condition|)
do|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
operator|&&
operator|!
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
condition|)
return|return
name|E1000_SUCCESS
return|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_flash_dword_ich8lan - Read dword from flash  *  @hw: pointer to the HW structure  *  @offset: offset to data location  *  @data: pointer to the location for storing the data  *  *  Reads the flash dword at offset into data.  Offset is converted  *  to bytes before read.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_flash_dword_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_flash_dword_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
operator|-
name|E1000_ERR_NVM
return|;
comment|/* Must convert word offset into bytes. */
name|offset
operator|<<=
literal|1
expr_stmt|;
return|return
name|e1000_read_flash_data32_ich8lan
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_flash_word_ich8lan - Read word from flash  *  @hw: pointer to the HW structure  *  @offset: offset to data location  *  @data: pointer to the location for storing the data  *  *  Reads the flash word at offset into data.  Offset is converted  *  to bytes before read.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_flash_word_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_flash_word_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
operator|-
name|E1000_ERR_NVM
return|;
comment|/* Must convert offset into bytes. */
name|offset
operator|<<=
literal|1
expr_stmt|;
return|return
name|e1000_read_flash_data_ich8lan
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|2
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_flash_byte_ich8lan - Read byte from flash  *  @hw: pointer to the HW structure  *  @offset: The offset of the byte to read.  *  @data: Pointer to a byte to store the value read.  *  *  Reads a single byte from the NVM using the flash access registers.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_flash_byte_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|word
init|=
literal|0
decl_stmt|;
comment|/* In SPT, only 32 bits access is supported, 	 * so this function should not be called. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
return|return
operator|-
name|E1000_ERR_NVM
return|;
else|else
name|ret_val
operator|=
name|e1000_read_flash_data_ich8lan
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
operator|*
name|data
operator|=
operator|(
name|u8
operator|)
name|word
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_flash_data_ich8lan - Read byte or word from NVM  *  @hw: pointer to the HW structure  *  @offset: The offset (in bytes) of the byte or word to read.  *  @size: Size of data to read, 1=byte 2=word  *  @data: Pointer to the word to store the value read.  *  *  Reads a byte or word from the NVM using the flash access registers.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_flash_data_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|size
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|union
name|ich8_hws_flash_ctrl
name|hsflctl
decl_stmt|;
name|u32
name|flash_linear_addr
decl_stmt|;
name|u32
name|flash_data
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_NVM
decl_stmt|;
name|u8
name|count
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_flash_data_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|2
operator|||
name|offset
operator|>
name|ICH_FLASH_LINEAR_ADDR_MASK
condition|)
return|return
operator|-
name|E1000_ERR_NVM
return|;
name|flash_linear_addr
operator|=
operator|(
operator|(
name|ICH_FLASH_LINEAR_ADDR_MASK
operator|&
name|offset
operator|)
operator|+
name|hw
operator|->
name|nvm
operator|.
name|flash_base_addr
operator|)
expr_stmt|;
do|do
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Steps */
name|ret_val
operator|=
name|e1000_flash_cycle_init_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
break|break;
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|)
expr_stmt|;
comment|/* 0b/1b corresponds to 1 or 2 byte size, respectively. */
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|fldbcount
operator|=
name|size
operator|-
literal|1
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|flcycle
operator|=
name|ICH_CYCLE_READ
expr_stmt|;
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|,
name|hsflctl
operator|.
name|regval
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FADDR
argument_list|,
name|flash_linear_addr
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_flash_cycle_ich8lan
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_READ_COMMAND_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* Check if FCERR is set to 1, if set to 1, clear it 		 * and try the whole sequence a few more times, else 		 * read in (shift in) the Flash Data0, the order is 		 * least significant byte first msb to lsb 		 */
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
block|{
name|flash_data
operator|=
name|E1000_READ_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FDATA0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
operator|*
name|data
operator|=
call|(
name|u8
call|)
argument_list|(
name|flash_data
operator|&
literal|0x000000FF
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
operator|*
name|data
operator|=
call|(
name|u16
call|)
argument_list|(
name|flash_data
operator|&
literal|0x0000FFFF
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* If we've gotten here, then things are probably 			 * completely hosed, but if the error condition is 			 * detected, it won't hurt to give it another try... 			 * ICH_FLASH_CYCLE_REPEAT_COUNT times. 			 */
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
condition|)
block|{
comment|/* Repeat for some time before giving up. */
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Timeout error - flash cycle did not complete.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|count
operator|++
operator|<
name|ICH_FLASH_CYCLE_REPEAT_COUNT
condition|)
do|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_flash_data32_ich8lan - Read dword from NVM  *  @hw: pointer to the HW structure  *  @offset: The offset (in bytes) of the dword to read.  *  @data: Pointer to the dword to store the value read.  *  *  Reads a byte or word from the NVM using the flash access registers.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_flash_data32_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|union
name|ich8_hws_flash_ctrl
name|hsflctl
decl_stmt|;
name|u32
name|flash_linear_addr
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_NVM
decl_stmt|;
name|u8
name|count
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_flash_data_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|ICH_FLASH_LINEAR_ADDR_MASK
operator|||
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_pch_spt
condition|)
return|return
operator|-
name|E1000_ERR_NVM
return|;
name|flash_linear_addr
operator|=
operator|(
operator|(
name|ICH_FLASH_LINEAR_ADDR_MASK
operator|&
name|offset
operator|)
operator|+
name|hw
operator|->
name|nvm
operator|.
name|flash_base_addr
operator|)
expr_stmt|;
do|do
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Steps */
name|ret_val
operator|=
name|e1000_flash_cycle_init_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
break|break;
comment|/* In SPT, This register is in Lan memory space, not flash. 		 * Therefore, only 32 bit access is supported 		 */
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
operator|>>
literal|16
expr_stmt|;
comment|/* 0b/1b corresponds to 1 or 2 byte size, respectively. */
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|fldbcount
operator|=
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|-
literal|1
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|flcycle
operator|=
name|ICH_CYCLE_READ
expr_stmt|;
comment|/* In SPT, This register is in Lan memory space, not flash. 		 * Therefore, only 32 bit access is supported 		 */
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
operator|(
name|u32
operator|)
name|hsflctl
operator|.
name|regval
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FADDR
argument_list|,
name|flash_linear_addr
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_flash_cycle_ich8lan
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_READ_COMMAND_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* Check if FCERR is set to 1, if set to 1, clear it 		 * and try the whole sequence a few more times, else 		 * read in (shift in) the Flash Data0, the order is 		 * least significant byte first msb to lsb 		 */
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
block|{
operator|*
name|data
operator|=
name|E1000_READ_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FDATA0
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* If we've gotten here, then things are probably 			 * completely hosed, but if the error condition is 			 * detected, it won't hurt to give it another try... 			 * ICH_FLASH_CYCLE_REPEAT_COUNT times. 			 */
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
condition|)
block|{
comment|/* Repeat for some time before giving up. */
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Timeout error - flash cycle did not complete.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|count
operator|++
operator|<
name|ICH_FLASH_CYCLE_REPEAT_COUNT
condition|)
do|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_nvm_ich8lan - Write word(s) to the NVM  *  @hw: pointer to the HW structure  *  @offset: The offset (in bytes) of the word(s) to write.  *  @words: Size of data to write in words  *  @data: Pointer to the word(s) to write at offset.  *  *  Writes a byte or word to the NVM using the flash access registers.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_write_nvm_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_nvm_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|>=
name|nvm
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
name|nvm
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"nvm parameter(s) out of bounds\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
name|nvm
operator|->
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|modified
operator|=
name|TRUE
expr_stmt|;
name|dev_spec
operator|->
name|shadow_ram
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|value
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
block|}
name|nvm
operator|->
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_nvm_checksum_spt - Update the checksum for NVM  *  @hw: pointer to the HW structure  *  *  The NVM checksum is updated by calling the generic update_nvm_checksum,  *  which writes the checksum to the shadow ram.  The changes in the shadow  *  ram are then committed to the EEPROM by processing each bank at a time  *  checking for the modified bit and writing only the pending changes.  *  After a successful commit, the shadow ram is cleared and is ready for  *  future writes.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_update_nvm_checksum_spt
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|act_offset
decl_stmt|,
name|new_bank_offset
decl_stmt|,
name|old_bank_offset
decl_stmt|,
name|bank
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u32
name|dword
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_nvm_checksum_spt"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_update_nvm_checksum_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|nvm
operator|->
name|type
operator|!=
name|e1000_nvm_flash_sw
condition|)
goto|goto
name|out
goto|;
name|nvm
operator|->
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* We're writing to the opposite bank so if we're on bank 1, 	 * write to bank 0 etc.  We also need to erase the segment that 	 * is going to be written 	 */
name|ret_val
operator|=
name|e1000_valid_nvm_bank_detect_ich8lan
argument_list|(
name|hw
argument_list|,
operator|&
name|bank
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not detect valid bank, assuming bank 0\n"
argument_list|)
expr_stmt|;
name|bank
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bank
operator|==
literal|0
condition|)
block|{
name|new_bank_offset
operator|=
name|nvm
operator|->
name|flash_bank_size
expr_stmt|;
name|old_bank_offset
operator|=
literal|0
expr_stmt|;
name|ret_val
operator|=
name|e1000_erase_flash_bank_ich8lan
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
else|else
block|{
name|old_bank_offset
operator|=
name|nvm
operator|->
name|flash_bank_size
expr_stmt|;
name|new_bank_offset
operator|=
literal|0
expr_stmt|;
name|ret_val
operator|=
name|e1000_erase_flash_bank_ich8lan
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_SHADOW_RAM_WORDS
condition|;
name|i
operator|+=
literal|2
control|)
block|{
comment|/* Determine whether to write the value stored 		 * in the other NVM bank or a modified value stored 		 * in the shadow RAM 		 */
name|ret_val
operator|=
name|e1000_read_flash_dword_ich8lan
argument_list|(
name|hw
argument_list|,
name|i
operator|+
name|old_bank_offset
argument_list|,
operator|&
name|dword
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|modified
condition|)
block|{
name|dword
operator|&=
literal|0xffff0000
expr_stmt|;
name|dword
operator||=
operator|(
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|value
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|modified
condition|)
block|{
name|dword
operator|&=
literal|0x0000ffff
expr_stmt|;
name|dword
operator||=
operator|(
operator|(
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|value
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_val
condition|)
break|break;
comment|/* If the word is 0x13, then make sure the signature bits 		 * (15:14) are 11b until the commit has completed. 		 * This will allow us to write 10b which indicates the 		 * signature is valid.  We want to do this after the write 		 * has completed so that we don't mark the segment valid 		 * while the write is still in progress 		 */
if|if
condition|(
name|i
operator|==
name|E1000_ICH_NVM_SIG_WORD
operator|-
literal|1
condition|)
name|dword
operator||=
name|E1000_ICH_NVM_SIG_MASK
operator|<<
literal|16
expr_stmt|;
comment|/* Convert offset to bytes. */
name|act_offset
operator|=
operator|(
name|i
operator|+
name|new_bank_offset
operator|)
operator|<<
literal|1
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Write the data to the new bank. Offset in words*/
name|act_offset
operator|=
name|i
operator|+
name|new_bank_offset
expr_stmt|;
name|ret_val
operator|=
name|e1000_retry_write_flash_dword_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
argument_list|,
name|dword
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
block|}
comment|/* Don't bother writing the segment valid bits if sector 	 * programming failed. 	 */
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flash commit failed.\n"
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* Finally validate the new segment by setting bit 15:14 	 * to 10b in word 0x13 , this can be done without an 	 * erase as well since these bits are 11 to start with 	 * and we need to change bit 14 to 0b 	 */
name|act_offset
operator|=
name|new_bank_offset
operator|+
name|E1000_ICH_NVM_SIG_WORD
expr_stmt|;
comment|/*offset in words but we read dword*/
operator|--
name|act_offset
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_flash_dword_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
argument_list|,
operator|&
name|dword
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|dword
operator|&=
literal|0xBFFFFFFF
expr_stmt|;
name|ret_val
operator|=
name|e1000_retry_write_flash_dword_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
argument_list|,
name|dword
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
comment|/* And invalidate the previously valid segment by setting 	 * its signature word (0x13) high_byte to 0b. This can be 	 * done without an erase because flash erase sets all bits 	 * to 1's. We can write 1's to 0's without an erase 	 */
name|act_offset
operator|=
operator|(
name|old_bank_offset
operator|+
name|E1000_ICH_NVM_SIG_WORD
operator|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
comment|/* offset in words but we read dword*/
name|act_offset
operator|=
name|old_bank_offset
operator|+
name|E1000_ICH_NVM_SIG_WORD
operator|-
literal|1
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_flash_dword_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
argument_list|,
operator|&
name|dword
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|dword
operator|&=
literal|0x00FFFFFF
expr_stmt|;
name|ret_val
operator|=
name|e1000_retry_write_flash_dword_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
argument_list|,
name|dword
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
comment|/* Great!  Everything worked, we can now clear the cached entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_SHADOW_RAM_WORDS
condition|;
name|i
operator|++
control|)
block|{
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|modified
operator|=
name|FALSE
expr_stmt|;
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|value
operator|=
literal|0xFFFF
expr_stmt|;
block|}
name|release
label|:
name|nvm
operator|->
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Reload the EEPROM, or else modifications will not appear 	 * until after the next adapter reset. 	 */
if|if
condition|(
operator|!
name|ret_val
condition|)
block|{
name|nvm
operator|->
name|ops
operator|.
name|reload
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT1
argument_list|(
literal|"NVM update error: %d\n"
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_nvm_checksum_ich8lan - Update the checksum for NVM  *  @hw: pointer to the HW structure  *  *  The NVM checksum is updated by calling the generic update_nvm_checksum,  *  which writes the checksum to the shadow ram.  The changes in the shadow  *  ram are then committed to the EEPROM by processing each bank at a time  *  checking for the modified bit and writing only the pending changes.  *  After a successful commit, the shadow ram is cleared and is ready for  *  future writes.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_update_nvm_checksum_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|act_offset
decl_stmt|,
name|new_bank_offset
decl_stmt|,
name|old_bank_offset
decl_stmt|,
name|bank
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_nvm_checksum_ich8lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_update_nvm_checksum_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|nvm
operator|->
name|type
operator|!=
name|e1000_nvm_flash_sw
condition|)
goto|goto
name|out
goto|;
name|nvm
operator|->
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* We're writing to the opposite bank so if we're on bank 1, 	 * write to bank 0 etc.  We also need to erase the segment that 	 * is going to be written 	 */
name|ret_val
operator|=
name|e1000_valid_nvm_bank_detect_ich8lan
argument_list|(
name|hw
argument_list|,
operator|&
name|bank
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not detect valid bank, assuming bank 0\n"
argument_list|)
expr_stmt|;
name|bank
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bank
operator|==
literal|0
condition|)
block|{
name|new_bank_offset
operator|=
name|nvm
operator|->
name|flash_bank_size
expr_stmt|;
name|old_bank_offset
operator|=
literal|0
expr_stmt|;
name|ret_val
operator|=
name|e1000_erase_flash_bank_ich8lan
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
else|else
block|{
name|old_bank_offset
operator|=
name|nvm
operator|->
name|flash_bank_size
expr_stmt|;
name|new_bank_offset
operator|=
literal|0
expr_stmt|;
name|ret_val
operator|=
name|e1000_erase_flash_bank_ich8lan
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_SHADOW_RAM_WORDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|modified
condition|)
block|{
name|data
operator|=
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|e1000_read_flash_word_ich8lan
argument_list|(
name|hw
argument_list|,
name|i
operator|+
name|old_bank_offset
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
block|}
comment|/* If the word is 0x13, then make sure the signature bits 		 * (15:14) are 11b until the commit has completed. 		 * This will allow us to write 10b which indicates the 		 * signature is valid.  We want to do this after the write 		 * has completed so that we don't mark the segment valid 		 * while the write is still in progress 		 */
if|if
condition|(
name|i
operator|==
name|E1000_ICH_NVM_SIG_WORD
condition|)
name|data
operator||=
name|E1000_ICH_NVM_SIG_MASK
expr_stmt|;
comment|/* Convert offset to bytes. */
name|act_offset
operator|=
operator|(
name|i
operator|+
name|new_bank_offset
operator|)
operator|<<
literal|1
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Write the bytes to the new bank. */
name|ret_val
operator|=
name|e1000_retry_write_flash_byte_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
argument_list|,
operator|(
name|u8
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_retry_write_flash_byte_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
operator|+
literal|1
argument_list|,
call|(
name|u8
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
block|}
comment|/* Don't bother writing the segment valid bits if sector 	 * programming failed. 	 */
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flash commit failed.\n"
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* Finally validate the new segment by setting bit 15:14 	 * to 10b in word 0x13 , this can be done without an 	 * erase as well since these bits are 11 to start with 	 * and we need to change bit 14 to 0b 	 */
name|act_offset
operator|=
name|new_bank_offset
operator|+
name|E1000_ICH_NVM_SIG_WORD
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_flash_word_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|data
operator|&=
literal|0xBFFF
expr_stmt|;
name|ret_val
operator|=
name|e1000_retry_write_flash_byte_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
operator|*
literal|2
operator|+
literal|1
argument_list|,
call|(
name|u8
call|)
argument_list|(
name|data
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
comment|/* And invalidate the previously valid segment by setting 	 * its signature word (0x13) high_byte to 0b. This can be 	 * done without an erase because flash erase sets all bits 	 * to 1's. We can write 1's to 0's without an erase 	 */
name|act_offset
operator|=
operator|(
name|old_bank_offset
operator|+
name|E1000_ICH_NVM_SIG_WORD
operator|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|ret_val
operator|=
name|e1000_retry_write_flash_byte_ich8lan
argument_list|(
name|hw
argument_list|,
name|act_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
comment|/* Great!  Everything worked, we can now clear the cached entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_SHADOW_RAM_WORDS
condition|;
name|i
operator|++
control|)
block|{
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|modified
operator|=
name|FALSE
expr_stmt|;
name|dev_spec
operator|->
name|shadow_ram
index|[
name|i
index|]
operator|.
name|value
operator|=
literal|0xFFFF
expr_stmt|;
block|}
name|release
label|:
name|nvm
operator|->
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Reload the EEPROM, or else modifications will not appear 	 * until after the next adapter reset. 	 */
if|if
condition|(
operator|!
name|ret_val
condition|)
block|{
name|nvm
operator|->
name|ops
operator|.
name|reload
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT1
argument_list|(
literal|"NVM update error: %d\n"
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_validate_nvm_checksum_ich8lan - Validate EEPROM checksum  *  @hw: pointer to the HW structure  *  *  Check to see if checksum needs to be fixed by reading bit 6 in word 0x19.  *  If the bit is 0, that the EEPROM had been modified, but the checksum was not  *  calculated, in which case we need to calculate the checksum and set bit 6.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_validate_nvm_checksum_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|u16
name|word
decl_stmt|;
name|u16
name|valid_csum_mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_validate_nvm_checksum_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Read NVM and check Invalid Image CSUM bit.  If this bit is 0, 	 * the checksum needs to be fixed.  This bit is an indication that 	 * the NVM was prepared by OEM software and did not calculate 	 * the checksum...a likely scenario. 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_pch_lpt
case|:
case|case
name|e1000_pch_spt
case|:
name|word
operator|=
name|NVM_COMPAT
expr_stmt|;
name|valid_csum_mask
operator|=
name|NVM_COMPAT_VALID_CSUM
expr_stmt|;
break|break;
default|default:
name|word
operator|=
name|NVM_FUTURE_INIT_WORD1
expr_stmt|;
name|valid_csum_mask
operator|=
name|NVM_FUTURE_INIT_WORD1_VALID_CSUM
expr_stmt|;
break|break;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|word
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
operator|(
name|data
operator|&
name|valid_csum_mask
operator|)
condition|)
block|{
name|data
operator||=
name|valid_csum_mask
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|write
argument_list|(
name|hw
argument_list|,
name|word
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|update
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|e1000_validate_nvm_checksum_generic
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_flash_data_ich8lan - Writes bytes to the NVM  *  @hw: pointer to the HW structure  *  @offset: The offset (in bytes) of the byte/word to read.  *  @size: Size of data to read, 1=byte 2=word  *  @data: The byte(s) to write to the NVM.  *  *  Writes one/two bytes to the NVM using the flash access registers.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_write_flash_data_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|size
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|union
name|ich8_hws_flash_ctrl
name|hsflctl
decl_stmt|;
name|u32
name|flash_linear_addr
decl_stmt|;
name|u32
name|flash_data
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u8
name|count
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_ich8_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
block|{
if|if
condition|(
name|size
operator|!=
literal|4
operator|||
name|offset
operator|>
name|ICH_FLASH_LINEAR_ADDR_MASK
condition|)
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|2
operator|||
name|offset
operator|>
name|ICH_FLASH_LINEAR_ADDR_MASK
condition|)
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
name|flash_linear_addr
operator|=
operator|(
operator|(
name|ICH_FLASH_LINEAR_ADDR_MASK
operator|&
name|offset
operator|)
operator|+
name|hw
operator|->
name|nvm
operator|.
name|flash_base_addr
operator|)
expr_stmt|;
do|do
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Steps */
name|ret_val
operator|=
name|e1000_flash_cycle_init_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
break|break;
comment|/* In SPT, This register is in Lan memory space, not 		 * flash.  Therefore, only 32 bit access is supported 		 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
operator|>>
literal|16
expr_stmt|;
else|else
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|)
expr_stmt|;
comment|/* 0b/1b corresponds to 1 or 2 byte size, respectively. */
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|fldbcount
operator|=
name|size
operator|-
literal|1
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|flcycle
operator|=
name|ICH_CYCLE_WRITE
expr_stmt|;
comment|/* In SPT, This register is in Lan memory space, 		 * not flash.  Therefore, only 32 bit access is 		 * supported 		 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsflctl
operator|.
name|regval
operator|<<
literal|16
argument_list|)
expr_stmt|;
else|else
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|,
name|hsflctl
operator|.
name|regval
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FADDR
argument_list|,
name|flash_linear_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
name|flash_data
operator|=
operator|(
name|u32
operator|)
name|data
operator|&
literal|0x00FF
expr_stmt|;
else|else
name|flash_data
operator|=
operator|(
name|u32
operator|)
name|data
expr_stmt|;
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FDATA0
argument_list|,
name|flash_data
argument_list|)
expr_stmt|;
comment|/* check if FCERR is set to 1 , if set to 1, clear it 		 * and try the whole sequence a few more times else done 		 */
name|ret_val
operator|=
name|e1000_flash_cycle_ich8lan
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_WRITE_COMMAND_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
break|break;
comment|/* If we're here, then things are most likely 		 * completely hosed, but if the error condition 		 * is detected, it won't hurt to give it another 		 * try...ICH_FLASH_CYCLE_REPEAT_COUNT times. 		 */
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
condition|)
comment|/* Repeat for some time before giving up. */
continue|continue;
if|if
condition|(
operator|!
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Timeout error - flash cycle did not complete.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|count
operator|++
operator|<
name|ICH_FLASH_CYCLE_REPEAT_COUNT
condition|)
do|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/** *  e1000_write_flash_data32_ich8lan - Writes 4 bytes to the NVM *  @hw: pointer to the HW structure *  @offset: The offset (in bytes) of the dwords to read. *  @data: The 4 bytes to write to the NVM. * *  Writes one/two/four bytes to the NVM using the flash access registers. **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_write_flash_data32_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|data
parameter_list|)
block|{
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|union
name|ich8_hws_flash_ctrl
name|hsflctl
decl_stmt|;
name|u32
name|flash_linear_addr
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u8
name|count
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_flash_data32_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
block|{
if|if
condition|(
name|offset
operator|>
name|ICH_FLASH_LINEAR_ADDR_MASK
condition|)
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
name|flash_linear_addr
operator|=
operator|(
operator|(
name|ICH_FLASH_LINEAR_ADDR_MASK
operator|&
name|offset
operator|)
operator|+
name|hw
operator|->
name|nvm
operator|.
name|flash_base_addr
operator|)
expr_stmt|;
do|do
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Steps */
name|ret_val
operator|=
name|e1000_flash_cycle_init_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
break|break;
comment|/* In SPT, This register is in Lan memory space, not 		 * flash.  Therefore, only 32 bit access is supported 		 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
operator|>>
literal|16
expr_stmt|;
else|else
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|)
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|fldbcount
operator|=
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|-
literal|1
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|flcycle
operator|=
name|ICH_CYCLE_WRITE
expr_stmt|;
comment|/* In SPT, This register is in Lan memory space, 		 * not flash.  Therefore, only 32 bit access is 		 * supported 		 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsflctl
operator|.
name|regval
operator|<<
literal|16
argument_list|)
expr_stmt|;
else|else
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|,
name|hsflctl
operator|.
name|regval
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FADDR
argument_list|,
name|flash_linear_addr
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FDATA0
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* check if FCERR is set to 1 , if set to 1, clear it 		 * and try the whole sequence a few more times else done 		 */
name|ret_val
operator|=
name|e1000_flash_cycle_ich8lan
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_WRITE_COMMAND_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
break|break;
comment|/* If we're here, then things are most likely 		 * completely hosed, but if the error condition 		 * is detected, it won't hurt to give it another 		 * try...ICH_FLASH_CYCLE_REPEAT_COUNT times. 		 */
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
condition|)
comment|/* Repeat for some time before giving up. */
continue|continue;
if|if
condition|(
operator|!
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Timeout error - flash cycle did not complete.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|count
operator|++
operator|<
name|ICH_FLASH_CYCLE_REPEAT_COUNT
condition|)
do|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_flash_byte_ich8lan - Write a single byte to NVM  *  @hw: pointer to the HW structure  *  @offset: The index of the byte to read.  *  @data: The byte to write to the NVM.  *  *  Writes a single byte to the NVM using the flash access registers.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_write_flash_byte_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|data
parameter_list|)
block|{
name|u16
name|word
init|=
operator|(
name|u16
operator|)
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_flash_byte_ich8lan"
argument_list|)
expr_stmt|;
return|return
name|e1000_write_flash_data_ich8lan
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|word
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** *  e1000_retry_write_flash_dword_ich8lan - Writes a dword to NVM *  @hw: pointer to the HW structure *  @offset: The offset of the word to write. *  @dword: The dword to write to the NVM. * *  Writes a single dword to the NVM using the flash access registers. *  Goes through a retry algorithm before giving up. **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_retry_write_flash_dword_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|dword
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|program_retries
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_retry_write_flash_dword_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Must convert word offset into bytes. */
name|offset
operator|<<=
literal|1
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_flash_data32_ich8lan
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|dword
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
return|return
name|ret_val
return|;
for|for
control|(
name|program_retries
operator|=
literal|0
init|;
name|program_retries
operator|<
literal|100
condition|;
name|program_retries
operator|++
control|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"Retrying Byte %8.8X at offset %u\n"
argument_list|,
name|dword
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_flash_data32_ich8lan
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|dword
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
break|break;
block|}
if|if
condition|(
name|program_retries
operator|==
literal|100
condition|)
return|return
operator|-
name|E1000_ERR_NVM
return|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_retry_write_flash_byte_ich8lan - Writes a single byte to NVM  *  @hw: pointer to the HW structure  *  @offset: The offset of the byte to write.  *  @byte: The byte to write to the NVM.  *  *  Writes a single byte to the NVM using the flash access registers.  *  Goes through a retry algorithm before giving up.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_retry_write_flash_byte_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|byte
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|program_retries
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_retry_write_flash_byte_ich8lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_flash_byte_ich8lan
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
return|return
name|ret_val
return|;
for|for
control|(
name|program_retries
operator|=
literal|0
init|;
name|program_retries
operator|<
literal|100
condition|;
name|program_retries
operator|++
control|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"Retrying Byte %2.2X at offset %u\n"
argument_list|,
name|byte
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_flash_byte_ich8lan
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
break|break;
block|}
if|if
condition|(
name|program_retries
operator|==
literal|100
condition|)
return|return
operator|-
name|E1000_ERR_NVM
return|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_erase_flash_bank_ich8lan - Erase a bank (4k) from NVM  *  @hw: pointer to the HW structure  *  @bank: 0 for first bank, 1 for second bank, etc.  *  *  Erases the bank specified. Each bank is a 4k block. Banks are 0 based.  *  bank N is 4096 * N + flash_reg_addr.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_erase_flash_bank_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|bank
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|union
name|ich8_hws_flash_status
name|hsfsts
decl_stmt|;
name|union
name|ich8_hws_flash_ctrl
name|hsflctl
decl_stmt|;
name|u32
name|flash_linear_addr
decl_stmt|;
comment|/* bank size is in 16bit words - adjust to bytes */
name|u32
name|flash_bank_size
init|=
name|nvm
operator|->
name|flash_bank_size
operator|*
literal|2
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|s32
name|count
init|=
literal|0
decl_stmt|;
name|s32
name|j
decl_stmt|,
name|iteration
decl_stmt|,
name|sector_size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_erase_flash_bank_ich8lan"
argument_list|)
expr_stmt|;
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
comment|/* Determine HW Sector size: Read BERASE bits of hw flash status 	 * register 	 * 00: The Hw sector is 256 bytes, hence we need to erase 16 	 *     consecutive sectors.  The start index for the nth Hw sector 	 *     can be calculated as = bank * 4096 + n * 256 	 * 01: The Hw sector is 4K bytes, hence we need to erase 1 sector. 	 *     The start index for the nth Hw sector can be calculated 	 *     as = bank * 4096 	 * 10: The Hw sector is 8K bytes, nth sector = bank * 8192 	 *     (ich9 only, otherwise error condition) 	 * 11: The Hw sector is 64K bytes, nth sector = bank * 65536 	 */
switch|switch
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|berasesz
condition|)
block|{
case|case
literal|0
case|:
comment|/* Hw sector size 256 */
name|sector_size
operator|=
name|ICH_FLASH_SEG_SIZE_256
expr_stmt|;
name|iteration
operator|=
name|flash_bank_size
operator|/
name|ICH_FLASH_SEG_SIZE_256
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sector_size
operator|=
name|ICH_FLASH_SEG_SIZE_4K
expr_stmt|;
name|iteration
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sector_size
operator|=
name|ICH_FLASH_SEG_SIZE_8K
expr_stmt|;
name|iteration
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sector_size
operator|=
name|ICH_FLASH_SEG_SIZE_64K
expr_stmt|;
name|iteration
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
comment|/* Start with the base address, then add the sector offset. */
name|flash_linear_addr
operator|=
name|hw
operator|->
name|nvm
operator|.
name|flash_base_addr
expr_stmt|;
name|flash_linear_addr
operator|+=
operator|(
name|bank
operator|)
condition|?
name|flash_bank_size
else|:
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iteration
condition|;
name|j
operator|++
control|)
block|{
do|do
block|{
name|u32
name|timeout
init|=
name|ICH_FLASH_ERASE_COMMAND_TIMEOUT
decl_stmt|;
comment|/* Steps */
name|ret_val
operator|=
name|e1000_flash_cycle_init_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Write a value 11 (block Erase) in Flash 			 * Cycle field in hw flash control 			 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
operator|>>
literal|16
expr_stmt|;
else|else
name|hsflctl
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|)
expr_stmt|;
name|hsflctl
operator|.
name|hsf_ctrl
operator|.
name|flcycle
operator|=
name|ICH_CYCLE_ERASE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
condition|)
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|,
name|hsflctl
operator|.
name|regval
operator|<<
literal|16
argument_list|)
expr_stmt|;
else|else
name|E1000_WRITE_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFCTL
argument_list|,
name|hsflctl
operator|.
name|regval
argument_list|)
expr_stmt|;
comment|/* Write the last 24 bits of an index within the 			 * block into Flash Linear address field in Flash 			 * Address. 			 */
name|flash_linear_addr
operator|+=
operator|(
name|j
operator|*
name|sector_size
operator|)
expr_stmt|;
name|E1000_WRITE_FLASH_REG
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_FADDR
argument_list|,
name|flash_linear_addr
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_flash_cycle_ich8lan
argument_list|(
name|hw
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
break|break;
comment|/* Check if FCERR is set to 1.  If 1, 			 * clear it and try the whole sequence 			 * a few more times else Done 			 */
name|hsfsts
operator|.
name|regval
operator|=
name|E1000_READ_FLASH_REG16
argument_list|(
name|hw
argument_list|,
name|ICH_FLASH_HSFSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcerr
condition|)
comment|/* repeat for some time before giving up */
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|hsfsts
operator|.
name|hsf_status
operator|.
name|flcdone
condition|)
return|return
name|ret_val
return|;
block|}
do|while
condition|(
operator|++
name|count
operator|<
name|ICH_FLASH_CYCLE_REPEAT_COUNT
condition|)
do|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_valid_led_default_ich8lan - Set the default LED settings  *  @hw: pointer to the HW structure  *  @data: Pointer to the LED settings  *  *  Reads the LED default settings from the NVM to data.  If the NVM LED  *  settings is all 0's or F's, set the LED default to a valid LED default  *  setting.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_valid_led_default_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_valid_led_default_ich8lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_ID_LED_SETTINGS
argument_list|,
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
operator|*
name|data
operator|==
name|ID_LED_RESERVED_0000
operator|||
operator|*
name|data
operator|==
name|ID_LED_RESERVED_FFFF
condition|)
operator|*
name|data
operator|=
name|ID_LED_DEFAULT_ICH8LAN
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_id_led_init_pchlan - store LED configurations  *  @hw: pointer to the HW structure  *  *  PCH does not control LEDs via the LEDCTL register, rather it uses  *  the PHY LED configuration register.  *  *  PCH also does not have an "always on" or "always off" mode which  *  complicates the ID feature.  Instead of using the "on" mode to indicate  *  in ledctl_mode2 the LEDs to use for ID (see e1000_id_led_init_generic()),  *  use "link_up" mode.  The LEDs will still ID on request if there is no  *  link based on logic in e1000_led_[on|off]_pchlan().  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_id_led_init_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
specifier|const
name|u32
name|ledctl_on
init|=
name|E1000_LEDCTL_MODE_LINK_UP
decl_stmt|;
specifier|const
name|u32
name|ledctl_off
init|=
name|E1000_LEDCTL_MODE_LINK_UP
operator||
name|E1000_PHY_LED0_IVRT
decl_stmt|;
name|u16
name|data
decl_stmt|,
name|i
decl_stmt|,
name|temp
decl_stmt|,
name|shift
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_id_led_init_pchlan"
argument_list|)
expr_stmt|;
comment|/* Get default ID LED modes */
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|valid_led_default
argument_list|(
name|hw
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|mac
operator|->
name|ledctl_default
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode1
operator|=
name|mac
operator|->
name|ledctl_default
expr_stmt|;
name|mac
operator|->
name|ledctl_mode2
operator|=
name|mac
operator|->
name|ledctl_default
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
operator|(
name|data
operator|>>
operator|(
name|i
operator|<<
literal|2
operator|)
operator|)
operator|&
name|E1000_LEDCTL_LED0_MODE_MASK
expr_stmt|;
name|shift
operator|=
operator|(
name|i
operator|*
literal|5
operator|)
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|ID_LED_ON1_DEF2
case|:
case|case
name|ID_LED_ON1_ON2
case|:
case|case
name|ID_LED_ON1_OFF2
case|:
name|mac
operator|->
name|ledctl_mode1
operator|&=
operator|~
operator|(
name|E1000_PHY_LED0_MASK
operator|<<
name|shift
operator|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode1
operator||=
operator|(
name|ledctl_on
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
name|ID_LED_OFF1_DEF2
case|:
case|case
name|ID_LED_OFF1_ON2
case|:
case|case
name|ID_LED_OFF1_OFF2
case|:
name|mac
operator|->
name|ledctl_mode1
operator|&=
operator|~
operator|(
name|E1000_PHY_LED0_MASK
operator|<<
name|shift
operator|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode1
operator||=
operator|(
name|ledctl_off
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
break|break;
block|}
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|ID_LED_DEF1_ON2
case|:
case|case
name|ID_LED_ON1_ON2
case|:
case|case
name|ID_LED_OFF1_ON2
case|:
name|mac
operator|->
name|ledctl_mode2
operator|&=
operator|~
operator|(
name|E1000_PHY_LED0_MASK
operator|<<
name|shift
operator|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode2
operator||=
operator|(
name|ledctl_on
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
case|case
name|ID_LED_DEF1_OFF2
case|:
case|case
name|ID_LED_ON1_OFF2
case|:
case|case
name|ID_LED_OFF1_OFF2
case|:
name|mac
operator|->
name|ledctl_mode2
operator|&=
operator|~
operator|(
name|E1000_PHY_LED0_MASK
operator|<<
name|shift
operator|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode2
operator||=
operator|(
name|ledctl_off
operator|<<
name|shift
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
break|break;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_bus_info_ich8lan - Get/Set the bus type and width  *  @hw: pointer to the HW structure  *  *  ICH8 use the PCI Express bus, but does not contain a PCI Express Capability  *  register, so the bus width is hard coded.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_bus_info_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_bus_info
modifier|*
name|bus
init|=
operator|&
name|hw
operator|->
name|bus
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_bus_info_ich8lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_bus_info_pcie_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* ICH devices are "PCI Express"-ish.  They have 	 * a configuration space, but do not contain 	 * PCI Express Capability registers, so bus width 	 * must be hardcoded. 	 */
if|if
condition|(
name|bus
operator|->
name|width
operator|==
name|e1000_bus_width_unknown
condition|)
name|bus
operator|->
name|width
operator|=
name|e1000_bus_width_pcie_x1
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_hw_ich8lan - Reset the hardware  *  @hw: pointer to the HW structure  *  *  Does a full reset of the hardware which includes a reset of the PHY and  *  MAC.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_reset_hw_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
decl_stmt|;
name|u16
name|kum_cfg
decl_stmt|;
name|u32
name|ctrl
decl_stmt|,
name|reg
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_hw_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Prevent the PCI-E bus from sticking if there is no TLP connection 	 * on the last TLP read/write transaction when MAC is reset. 	 */
name|ret_val
operator|=
name|e1000_disable_pcie_master_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT
argument_list|(
literal|"PCI-E Master disable polling has failed.\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Disable the Transmit and Receive units.  Then delay to allow 	 * any pending transactions to complete before we hit the MAC 	 * with the global reset. 	 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|E1000_TCTL_PSP
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Workaround for ICH8 bit corruption issue in FIFO memory */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
condition|)
block|{
comment|/* Set Tx and Rx buffer allocation to 8k apiece. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA
argument_list|,
name|E1000_PBA_8K
argument_list|)
expr_stmt|;
comment|/* Set Packet Buffer Size to 16k. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBS
argument_list|,
name|E1000_PBS_16K
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pchlan
condition|)
block|{
comment|/* Save the NVM K1 bit setting*/
name|ret_val
operator|=
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
name|E1000_NVM_K1_CONFIG
argument_list|,
literal|1
argument_list|,
operator|&
name|kum_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|kum_cfg
operator|&
name|E1000_NVM_K1_ENABLE
condition|)
name|dev_spec
operator|->
name|nvm_k1_enabled
operator|=
name|TRUE
expr_stmt|;
else|else
name|dev_spec
operator|->
name|nvm_k1_enabled
operator|=
name|FALSE
expr_stmt|;
block|}
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_reset_block
argument_list|(
name|hw
argument_list|)
condition|)
block|{
comment|/* Full-chip reset requires MAC and PHY reset at the same 		 * time to make sure the interface between MAC and the 		 * external PHY is reset. 		 */
name|ctrl
operator||=
name|E1000_CTRL_PHY_RST
expr_stmt|;
comment|/* Gate automatic PHY configuration by hardware on 		 * non-managed 82579 		 */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
operator|)
operator|&&
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
operator|&
name|E1000_ICH_FWSM_FW_VALID
operator|)
condition|)
name|e1000_gate_hw_phy_config_ich8lan
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|ret_val
operator|=
name|e1000_acquire_swflag_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Issuing a global reset to ich8lan\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
operator|(
name|ctrl
operator||
name|E1000_CTRL_RST
operator|)
argument_list|)
expr_stmt|;
comment|/* cannot issue a flush here because it hangs the hardware */
name|msec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Set Phy Config Counter to 50msec */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
condition|)
block|{
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM3
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|E1000_FEXTNVM3_PHY_CFG_COUNTER_MASK
expr_stmt|;
name|reg
operator||=
name|E1000_FEXTNVM3_PHY_CFG_COUNTER_50MSEC
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM3
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ret_val
condition|)
name|E1000_MUTEX_UNLOCK
argument_list|(
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
operator|.
name|swflag_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctrl
operator|&
name|E1000_CTRL_PHY_RST
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|get_cfg_done
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_post_phy_reset_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* For PCH, this write will make sure that any noise 	 * will be detected as a CRC error and be dropped rather than show up 	 * as a bad packet to the DMA engine. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pchlan
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CRC_OFFSET
argument_list|,
literal|0x65656565
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_KABGTXD
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_KABGTXD_BGSQLBIAS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_KABGTXD
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_hw_ich8lan - Initialize the hardware  *  @hw: pointer to the HW structure  *  *  Prepares the hardware for transmit and receive by doing the following:  *   - initialize hardware bits  *   - initialize LED identification  *   - setup receive address registers  *   - setup flow control  *   - setup transmit descriptors  *   - clear statistics  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_hw_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|ctrl_ext
decl_stmt|,
name|txdctl
decl_stmt|,
name|snoop
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_hw_ich8lan"
argument_list|)
expr_stmt|;
name|e1000_initialize_hw_bits_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Initialize identification LED */
name|ret_val
operator|=
name|mac
operator|->
name|ops
operator|.
name|id_led_init
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* An error is not fatal and we should not stop init due to this */
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT
argument_list|(
literal|"Error initializing identification LED\n"
argument_list|)
expr_stmt|;
comment|/* Setup the receive address. */
name|e1000_init_rx_addrs_generic
argument_list|(
name|hw
argument_list|,
name|mac
operator|->
name|rar_entry_count
argument_list|)
expr_stmt|;
comment|/* Zero out the Multicast HASH table */
name|DEBUGOUT
argument_list|(
literal|"Zeroing the MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mac
operator|->
name|mta_reg_count
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The 82578 Rx buffer will stall if wakeup is enabled in host and 	 * the ME.  Disable wakeup by clearing the host wakeup bit. 	 * Reset the phy after disabling host wakeup to reset the Rx buffer. 	 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82578
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|BM_PORT_GEN_CFG
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|BM_WUC_HOST_WU_BIT
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|BM_PORT_GEN_CFG
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_hw_reset_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* Setup link and flow control */
name|ret_val
operator|=
name|mac
operator|->
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set the transmit descriptor write-back policy for both queues */
name|txdctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|txdctl
operator|=
operator|(
operator|(
name|txdctl
operator|&
operator|~
name|E1000_TXDCTL_WTHRESH
operator|)
operator||
name|E1000_TXDCTL_FULL_TX_DESC_WB
operator|)
expr_stmt|;
name|txdctl
operator|=
operator|(
operator|(
name|txdctl
operator|&
operator|~
name|E1000_TXDCTL_PTHRESH
operator|)
operator||
name|E1000_TXDCTL_MAX_TX_DESC_PREFETCH
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|txdctl
argument_list|)
expr_stmt|;
name|txdctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|txdctl
operator|=
operator|(
operator|(
name|txdctl
operator|&
operator|~
name|E1000_TXDCTL_WTHRESH
operator|)
operator||
name|E1000_TXDCTL_FULL_TX_DESC_WB
operator|)
expr_stmt|;
name|txdctl
operator|=
operator|(
operator|(
name|txdctl
operator|&
operator|~
name|E1000_TXDCTL_PTHRESH
operator|)
operator||
name|E1000_TXDCTL_MAX_TX_DESC_PREFETCH
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|1
argument_list|)
argument_list|,
name|txdctl
argument_list|)
expr_stmt|;
comment|/* ICH8 has opposite polarity of no_snoop bits. 	 * By default, we should use snoop behavior. 	 */
if|if
condition|(
name|mac
operator|->
name|type
operator|==
name|e1000_ich8lan
condition|)
name|snoop
operator|=
name|PCIE_ICH8_SNOOP_ALL
expr_stmt|;
else|else
name|snoop
operator|=
operator|(
name|u32
operator|)
operator|~
operator|(
name|PCIE_NO_SNOOP_ALL
operator|)
expr_stmt|;
name|e1000_set_pcie_no_snoop_generic
argument_list|(
name|hw
argument_list|,
name|snoop
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_RO_DIS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
comment|/* Clear all of the statistics registers (clear on read).  It is 	 * important that we do this after we have tried to establish link 	 * because the symbol error count will increment wildly if there 	 * is no link. 	 */
name|e1000_clear_hw_cntrs_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_initialize_hw_bits_ich8lan - Initialize required hardware bits  *  @hw: pointer to the HW structure  *  *  Sets/Clears required hardware bits necessary for correctly setting up the  *  hardware for transmit and receive.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_initialize_hw_bits_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_initialize_hw_bits_ich8lan"
argument_list|)
expr_stmt|;
comment|/* Extended Device Control */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
comment|/* Enable PHY low-power state when MAC is at D3 w/o WoL */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pchlan
condition|)
name|reg
operator||=
name|E1000_CTRL_EXT_PHYPDEN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Transmit Descriptor Control 0 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Transmit Descriptor Control 1 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|1
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Transmit Arbitration Control 0 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
condition|)
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|28
operator|)
operator||
operator|(
literal|1
operator|<<
literal|29
operator|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|23
operator|)
operator||
operator|(
literal|1
operator|<<
literal|24
operator|)
operator||
operator|(
literal|1
operator|<<
literal|26
operator|)
operator||
operator|(
literal|1
operator|<<
literal|27
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Transmit Arbitration Control 1 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|)
operator|&
name|E1000_TCTL_MULR
condition|)
name|reg
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|28
operator|)
expr_stmt|;
else|else
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|28
operator|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|24
operator|)
operator||
operator|(
literal|1
operator|<<
literal|26
operator|)
operator||
operator|(
literal|1
operator|<<
literal|30
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|1
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Device Status */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
condition|)
block|{
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|31
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* work-around descriptor data corruption issue during nfs v2 udp 	 * traffic, just disable the nfs filtering capability 	 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RFCTL
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
name|E1000_RFCTL_NFSW_DIS
operator||
name|E1000_RFCTL_NFSR_DIS
operator|)
expr_stmt|;
comment|/* Disable IPv6 extension header parsing because some malformed 	 * IPv6 headers can hang the Rx. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
condition|)
name|reg
operator||=
operator|(
name|E1000_RFCTL_IPV6_EX_DIS
operator||
name|E1000_RFCTL_NEW_IPV6_EXT_DIS
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RFCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Enable ECC on Lynxpoint */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_lpt
condition|)
block|{
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBECCSTS
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_PBECCSTS_ECC_ENABLE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBECCSTS
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_CTRL_MEHE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_link_ich8lan - Setup flow control and link settings  *  @hw: pointer to the HW structure  *  *  Determines which flow control settings to use, then configures flow  *  control.  Calls the appropriate media-specific link configuration  *  function.  Assuming the adapter has a valid link partner, a valid link  *  should be established.  Assumes the hardware has previously been reset  *  and the transmitter and receiver are not enabled.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_setup_link_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_link_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_reset_block
argument_list|(
name|hw
argument_list|)
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* ICH parts do not have a word in the NVM to determine 	 * the default flow control setting, so we explicitly 	 * set it to full. 	 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|e1000_fc_default
condition|)
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|e1000_fc_full
expr_stmt|;
comment|/* Save off the requested flow control mode for use later.  Depending 	 * on the link partner's capabilities, we may or may not use this mode. 	 */
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|hw
operator|->
name|fc
operator|.
name|requested_mode
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"After fix-ups FlowControl is now = %x\n"
argument_list|,
name|hw
operator|->
name|fc
operator|.
name|current_mode
argument_list|)
expr_stmt|;
comment|/* Continue to configure the copper link. */
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_physical_interface
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCTTV
argument_list|,
name|hw
operator|->
name|fc
operator|.
name|pause_time
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82578
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82579
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_i217
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82577
operator|)
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCRTV_PCH
argument_list|,
name|hw
operator|->
name|fc
operator|.
name|refresh_time
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_REG
argument_list|(
name|BM_PORT_CTRL_PAGE
argument_list|,
literal|27
argument_list|)
argument_list|,
name|hw
operator|->
name|fc
operator|.
name|pause_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|e1000_set_fc_watermarks_generic
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_copper_link_ich8lan - Configure MAC/PHY interface  *  @hw: pointer to the HW structure  *  *  Configures the kumeran interface to the PHY to wait the appropriate time  *  when polling the PHY, then call the generic setup_copper_link to finish  *  configuring the copper link.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_setup_copper_link_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|reg_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_copper_link_ich8lan"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SLU
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Set the mac to wait the maximum time between each iteration 	 * and increase the max iterations when polling the phy; 	 * this fixes erroneous timeouts at 10Mbps. 	 */
name|ret_val
operator|=
name|e1000_write_kmrn_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_TIMEOUTS
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_read_kmrn_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_INBAND_PARAM
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|reg_data
operator||=
literal|0x3F
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_INBAND_PARAM
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|e1000_phy_igp_3
case|:
name|ret_val
operator|=
name|e1000_copper_link_setup_igp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
break|break;
case|case
name|e1000_phy_bm
case|:
case|case
name|e1000_phy_82578
case|:
name|ret_val
operator|=
name|e1000_copper_link_setup_m88
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
break|break;
case|case
name|e1000_phy_82577
case|:
case|case
name|e1000_phy_82579
case|:
name|ret_val
operator|=
name|e1000_copper_link_setup_82577
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
break|break;
case|case
name|e1000_phy_ife
case|:
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_MDIX_CONTROL
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|reg_data
operator|&=
operator|~
name|IFE_PMC_AUTO_MDIX
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|reg_data
operator|&=
operator|~
name|IFE_PMC_FORCE_MDIX
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|reg_data
operator||=
name|IFE_PMC_FORCE_MDIX
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|reg_data
operator||=
name|IFE_PMC_AUTO_MDIX
expr_stmt|;
break|break;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_MDIX_CONTROL
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|e1000_setup_copper_link_generic
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_copper_link_pch_lpt - Configure MAC/PHY interface  *  @hw: pointer to the HW structure  *  *  Calls the PHY specific link setup function and then calls the  *  generic setup_copper_link to finish configuring the link for  *  Lynxpoint PCH devices  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_setup_copper_link_pch_lpt
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_copper_link_pch_lpt"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SLU
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_copper_link_setup_82577
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
return|return
name|e1000_setup_copper_link_generic
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_link_up_info_ich8lan - Get current link speed and duplex  *  @hw: pointer to the HW structure  *  @speed: pointer to store current link speed  *  @duplex: pointer to store the current link duplex  *  *  Calls the generic get_speed_and_duplex to retrieve the current link  *  information and then calls the Kumeran lock loss workaround for links at  *  gigabit speeds.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_link_up_info_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_link_up_info_ich8lan"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_speed_and_duplex_copper_generic
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_igp_3
operator|)
operator|&&
operator|(
operator|*
name|speed
operator|==
name|SPEED_1000
operator|)
condition|)
block|{
name|ret_val
operator|=
name|e1000_kmrn_lock_loss_workaround_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_kmrn_lock_loss_workaround_ich8lan - Kumeran workaround  *  @hw: pointer to the HW structure  *  *  Work-around for 82566 Kumeran PCS lock loss:  *  On link status change (i.e. PCI reset, speed change) and link is up and  *  speed is gigabit-  *    0) if workaround is optionally disabled do nothing  *    1) wait 1ms for Kumeran link to come up  *    2) check Kumeran Diagnostic register PCS lock loss bit  *    3) if not set the link is locked (all is good), otherwise...  *    4) reset the PHY  *    5) repeat up to 10 times  *  Note: this is only called for IGP3 copper when speed is 1gb.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_kmrn_lock_loss_workaround_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
decl_stmt|;
name|u32
name|phy_ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|data
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_kmrn_lock_loss_workaround_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_spec
operator|->
name|kmrn_lock_loss_workaround_enabled
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Make sure link is up before proceeding.  If not just return. 	 * Attempting this while link is negotiating fouled up link 	 * stability 	 */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link
condition|)
return|return
name|E1000_SUCCESS
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
comment|/* read once to clear */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_KMRN_DIAG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* and again to get new status */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_KMRN_DIAG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* check for PCS lock */
if|if
condition|(
operator|!
operator|(
name|data
operator|&
name|IGP3_KMRN_DIAG_PCS_LOCK_LOSS
operator|)
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Issue PHY reset */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay_irq
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Disable GigE link negotiation */
name|phy_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|)
expr_stmt|;
name|phy_ctrl
operator||=
operator|(
name|E1000_PHY_CTRL_GBE_DISABLE
operator||
name|E1000_PHY_CTRL_NOND0A_GBE_DISABLE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
comment|/* Call gig speed drop workaround on Gig disable before accessing 	 * any PHY registers 	 */
name|e1000_gig_downshift_workaround_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* unable to acquire PCS lock */
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_kmrn_lock_loss_workaround_ich8lan - Set Kumeran workaround state  *  @hw: pointer to the HW structure  *  @state: boolean value used to set the current Kumeran workaround state  *  *  If ICH8, set the current Kumeran workaround state (enabled - TRUE  *  /disabled - FALSE).  **/
end_comment

begin_function
name|void
name|e1000_set_kmrn_lock_loss_workaround_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_kmrn_lock_loss_workaround_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_ich8lan
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Workaround applies to ICH8 only.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dev_spec
operator|->
name|kmrn_lock_loss_workaround_enabled
operator|=
name|state
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_ipg3_phy_powerdown_workaround_ich8lan - Power down workaround on D3  *  @hw: pointer to the HW structure  *  *  Workaround for 82566 power-down on D3 entry:  *    1) disable gigabit link  *    2) write VR power-down enable  *    3) read it back  *  Continue if successful, else issue LCD reset and repeat  **/
end_comment

begin_function
name|void
name|e1000_igp3_phy_powerdown_workaround_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|u8
name|retry
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_igp3_phy_powerdown_workaround_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|!=
name|e1000_phy_igp_3
condition|)
return|return;
comment|/* Try the workaround twice (if needed) */
do|do
block|{
comment|/* Disable link */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
name|E1000_PHY_CTRL_GBE_DISABLE
operator||
name|E1000_PHY_CTRL_NOND0A_GBE_DISABLE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Call gig speed drop workaround on Gig disable before 		 * accessing any PHY registers 		 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
condition|)
name|e1000_gig_downshift_workaround_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Write VR power-down enable */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_VR_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
name|IGP3_VR_CTRL_DEV_POWERDOWN_MODE_MASK
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_VR_CTRL
argument_list|,
name|data
operator||
name|IGP3_VR_CTRL_MODE_SHUTDOWN
argument_list|)
expr_stmt|;
comment|/* Read it back and test */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP3_VR_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|data
operator|&=
name|IGP3_VR_CTRL_DEV_POWERDOWN_MODE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|==
name|IGP3_VR_CTRL_MODE_SHUTDOWN
operator|)
operator|||
name|retry
condition|)
break|break;
comment|/* Issue PHY reset and repeat at most one more time */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|reg
operator||
name|E1000_CTRL_PHY_RST
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|retry
condition|)
do|;
block|}
end_function

begin_comment
comment|/**  *  e1000_gig_downshift_workaround_ich8lan - WoL from S5 stops working  *  @hw: pointer to the HW structure  *  *  Steps to take when dropping from 1Gb/s (eg. link cable removal (LSC),  *  LPLU, Gig disable, MDIC PHY reset):  *    1) Set Kumeran Near-end loopback  *    2) Clear Kumeran Near-end loopback  *  Should only be called for ICH8[m] devices with any 1G Phy.  **/
end_comment

begin_function
name|void
name|e1000_gig_downshift_workaround_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|reg_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_gig_downshift_workaround_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_ich8lan
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_ife
operator|)
condition|)
return|return;
name|ret_val
operator|=
name|e1000_read_kmrn_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_DIAG_OFFSET
argument_list|,
operator|&
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return;
name|reg_data
operator||=
name|E1000_KMRNCTRLSTA_DIAG_NELPBK
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_kmrn_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_DIAG_OFFSET
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return;
name|reg_data
operator|&=
operator|~
name|E1000_KMRNCTRLSTA_DIAG_NELPBK
expr_stmt|;
name|e1000_write_kmrn_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA_DIAG_OFFSET
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_suspend_workarounds_ich8lan - workarounds needed during S0->Sx  *  @hw: pointer to the HW structure  *  *  During S0 to Sx transition, it is possible the link remains at gig  *  instead of negotiating to a lower speed.  Before going to Sx, set  *  'Gig Disable' to force link speed negotiation to a lower speed based on  *  the LPLU setting in the NVM or custom setting.  For PCH and newer parts,  *  the OEM bits PHY register (LED, GbE disable and LPLU configurations) also  *  needs to be written.  *  Parts that support (and are linked to a partner which support) EEE in  *  100Mbps should disable LPLU since 100Mbps w/ EEE requires less power  *  than 10Mbps w/o EEE.  **/
end_comment

begin_function
name|void
name|e1000_suspend_workarounds_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_ich8lan
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|ich8lan
decl_stmt|;
name|u32
name|phy_ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_suspend_workarounds_ich8lan"
argument_list|)
expr_stmt|;
name|phy_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|)
expr_stmt|;
name|phy_ctrl
operator||=
name|E1000_PHY_CTRL_GBE_DISABLE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_i217
condition|)
block|{
name|u16
name|phy_reg
decl_stmt|,
name|device_id
init|=
name|hw
operator|->
name|device_id
decl_stmt|;
if|if
condition|(
operator|(
name|device_id
operator|==
name|E1000_DEV_ID_PCH_LPTLP_I218_LM
operator|)
operator|||
operator|(
name|device_id
operator|==
name|E1000_DEV_ID_PCH_LPTLP_I218_V
operator|)
operator|||
operator|(
name|device_id
operator|==
name|E1000_DEV_ID_PCH_I218_LM3
operator|)
operator|||
operator|(
name|device_id
operator|==
name|E1000_DEV_ID_PCH_I218_V3
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pch_spt
operator|)
condition|)
block|{
name|u32
name|fextnvm6
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM6
argument_list|)
decl_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FEXTNVM6
argument_list|,
name|fextnvm6
operator|&
operator|~
name|E1000_FEXTNVM6_REQ_PLL_CLK
argument_list|)
expr_stmt|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|dev_spec
operator|->
name|eee_disable
condition|)
block|{
name|u16
name|eee_advert
decl_stmt|;
name|ret_val
operator|=
name|e1000_read_emi_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_EEE_ADVERTISEMENT
argument_list|,
operator|&
name|eee_advert
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
comment|/* Disable LPLU if both link partners support 100BaseT 			 * EEE and 100Full is advertised on both ends of the 			 * link, and enable Auto Enable LPI since there will 			 * be no driver to enable LPI while in Sx. 			 */
if|if
condition|(
operator|(
name|eee_advert
operator|&
name|I82579_EEE_100_SUPPORTED
operator|)
operator|&&
operator|(
name|dev_spec
operator|->
name|eee_lp_ability
operator|&
name|I82579_EEE_100_SUPPORTED
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|&
name|ADVERTISE_100_FULL
operator|)
condition|)
block|{
name|phy_ctrl
operator|&=
operator|~
operator|(
name|E1000_PHY_CTRL_D0A_LPLU
operator||
name|E1000_PHY_CTRL_NOND0A_LPLU
operator|)
expr_stmt|;
comment|/* Set Auto Enable LPI after link up */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_LPI_GPIO_CTRL
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
name|phy_reg
operator||=
name|I217_LPI_GPIO_CTRL_AUTO_EN_LPI
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_LPI_GPIO_CTRL
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For i217 Intel Rapid Start Technology support, 		 * when the system is going into Sx and no manageability engine 		 * is present, the driver must configure proxy to reset only on 		 * power good.  LPI (Low Power Idle) state must also reset only 		 * on power good, as well as the MTA (Multicast table array). 		 * The SMBus release must also be disabled on LCD reset. 		 */
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
operator|&
name|E1000_ICH_FWSM_FW_VALID
operator|)
condition|)
block|{
comment|/* Enable proxy to reset only on power good. */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_PROXY_CTRL
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
name|phy_reg
operator||=
name|I217_PROXY_CTRL_AUTO_DISABLE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_PROXY_CTRL
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
comment|/* Set bit enable LPI (EEE) to reset only on 			 * power good. 			*/
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_SxCTRL
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
name|phy_reg
operator||=
name|I217_SxCTRL_ENABLE_LPI_RESET
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_SxCTRL
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
comment|/* Disable the SMB release on LCD reset. */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_MEMPWR
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
name|phy_reg
operator|&=
operator|~
name|I217_MEMPWR_DISABLE_SMB_RELEASE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_MEMPWR
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Enable MTA to reset for Intel Rapid Start Technology 		 * Support 		 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_CGFREG
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
name|phy_reg
operator||=
name|I217_CGFREG_ENABLE_MTA_RESET
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_CGFREG
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_ich8lan
condition|)
name|e1000_gig_downshift_workaround_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_pchlan
condition|)
block|{
name|e1000_oem_bits_config_ich8lan
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Reset PHY to activate OEM bits on 82577/8 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pchlan
condition|)
name|e1000_phy_hw_reset_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return;
name|e1000_write_smbus_addr
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_resume_workarounds_pchlan - workarounds needed during Sx->S0  *  @hw: pointer to the HW structure  *  *  During Sx to S0 transitions on non-managed devices or managed devices  *  on which PHY resets are not blocked, if the PHY registers cannot be  *  accessed properly by the s/w toggle the LANPHYPC value to power cycle  *  the PHY.  *  On i217, setup Intel Rapid Start Technology.  **/
end_comment

begin_function
name|u32
name|e1000_resume_workarounds_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_resume_workarounds_pchlan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_pch2lan
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ret_val
operator|=
name|e1000_init_phy_workarounds_pchlan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Failed to init PHY flow ret_val=%d\n"
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* For i217 Intel Rapid Start Technology support when the system 	 * is transitioning from Sx and no manageability engine is present 	 * configure SMBus to restore on reset, disable proxy, and enable 	 * the reset on MTA (Multicast table array). 	 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_i217
condition|)
block|{
name|u16
name|phy_reg
decl_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Failed to setup iRST\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Clear Auto Enable LPI after link up */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_LPI_GPIO_CTRL
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
name|phy_reg
operator|&=
operator|~
name|I217_LPI_GPIO_CTRL_AUTO_EN_LPI
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_LPI_GPIO_CTRL
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
operator|&
name|E1000_ICH_FWSM_FW_VALID
operator|)
condition|)
block|{
comment|/* Restore clear on SMB if no manageability engine 			 * is present 			 */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_MEMPWR
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|phy_reg
operator||=
name|I217_MEMPWR_DISABLE_SMB_RELEASE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_MEMPWR
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
comment|/* Disable Proxy */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_PROXY_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Enable reset on MTA */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_CGFREG
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|phy_reg
operator|&=
operator|~
name|I217_CGFREG_ENABLE_MTA_RESET
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_locked
argument_list|(
name|hw
argument_list|,
name|I217_CGFREG
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
name|release
label|:
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT1
argument_list|(
literal|"Error %d in resume workarounds\n"
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_cleanup_led_ich8lan - Restore the default LED operation  *  @hw: pointer to the HW structure  *  *  Return the LED back to the default configuration.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_cleanup_led_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_cleanup_led_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_ife
condition|)
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_SPECIAL_CONTROL_LED
argument_list|,
literal|0
argument_list|)
return|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_default
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_led_on_ich8lan - Turn LEDs on  *  @hw: pointer to the HW structure  *  *  Turn on the LEDs.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_led_on_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_led_on_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_ife
condition|)
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_SPECIAL_CONTROL_LED
argument_list|,
operator|(
name|IFE_PSCL_PROBE_MODE
operator||
name|IFE_PSCL_PROBE_LEDS_ON
operator|)
argument_list|)
return|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode2
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_led_off_ich8lan - Turn LEDs off  *  @hw: pointer to the HW structure  *  *  Turn off the LEDs.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_led_off_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_led_off_ich8lan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_ife
condition|)
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_SPECIAL_CONTROL_LED
argument_list|,
operator|(
name|IFE_PSCL_PROBE_MODE
operator||
name|IFE_PSCL_PROBE_LEDS_OFF
operator|)
argument_list|)
return|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode1
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_led_pchlan - Configures SW controllable LED  *  @hw: pointer to the HW structure  *  *  This prepares the SW controllable LED for use.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_setup_led_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_led_pchlan"
argument_list|)
expr_stmt|;
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|HV_LED_CONFIG
argument_list|,
operator|(
name|u16
operator|)
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_cleanup_led_pchlan - Restore the default LED operation  *  @hw: pointer to the HW structure  *  *  Return the LED back to the default configuration.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_cleanup_led_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_cleanup_led_pchlan"
argument_list|)
expr_stmt|;
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|HV_LED_CONFIG
argument_list|,
operator|(
name|u16
operator|)
name|hw
operator|->
name|mac
operator|.
name|ledctl_default
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_led_on_pchlan - Turn LEDs on  *  @hw: pointer to the HW structure  *  *  Turn on the LEDs.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_led_on_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|data
init|=
operator|(
name|u16
operator|)
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode2
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|led
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_led_on_pchlan"
argument_list|)
expr_stmt|;
comment|/* If no link, then turn LED on by setting the invert bit 	 * for each LED that's mode is "link_up" in ledctl_mode2. 	 */
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_LU
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|led
operator|=
operator|(
name|data
operator|>>
operator|(
name|i
operator|*
literal|5
operator|)
operator|)
operator|&
name|E1000_PHY_LED0_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|led
operator|&
name|E1000_PHY_LED0_MODE_MASK
operator|)
operator|!=
name|E1000_LEDCTL_MODE_LINK_UP
condition|)
continue|continue;
if|if
condition|(
name|led
operator|&
name|E1000_PHY_LED0_IVRT
condition|)
name|data
operator|&=
operator|~
operator|(
name|E1000_PHY_LED0_IVRT
operator|<<
operator|(
name|i
operator|*
literal|5
operator|)
operator|)
expr_stmt|;
else|else
name|data
operator||=
operator|(
name|E1000_PHY_LED0_IVRT
operator|<<
operator|(
name|i
operator|*
literal|5
operator|)
operator|)
expr_stmt|;
block|}
block|}
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|HV_LED_CONFIG
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_led_off_pchlan - Turn LEDs off  *  @hw: pointer to the HW structure  *  *  Turn off the LEDs.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_led_off_pchlan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|data
init|=
operator|(
name|u16
operator|)
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode1
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|led
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_led_off_pchlan"
argument_list|)
expr_stmt|;
comment|/* If no link, then turn LED off by clearing the invert bit 	 * for each LED that's mode is "link_up" in ledctl_mode1. 	 */
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_LU
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|led
operator|=
operator|(
name|data
operator|>>
operator|(
name|i
operator|*
literal|5
operator|)
operator|)
operator|&
name|E1000_PHY_LED0_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|led
operator|&
name|E1000_PHY_LED0_MODE_MASK
operator|)
operator|!=
name|E1000_LEDCTL_MODE_LINK_UP
condition|)
continue|continue;
if|if
condition|(
name|led
operator|&
name|E1000_PHY_LED0_IVRT
condition|)
name|data
operator|&=
operator|~
operator|(
name|E1000_PHY_LED0_IVRT
operator|<<
operator|(
name|i
operator|*
literal|5
operator|)
operator|)
expr_stmt|;
else|else
name|data
operator||=
operator|(
name|E1000_PHY_LED0_IVRT
operator|<<
operator|(
name|i
operator|*
literal|5
operator|)
operator|)
expr_stmt|;
block|}
block|}
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|HV_LED_CONFIG
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cfg_done_ich8lan - Read config done bit after Full or PHY reset  *  @hw: pointer to the HW structure  *  *  Read appropriate register for the config done bit for completion status  *  and configure the PHY through s/w for EEPROM-less parts.  *  *  NOTE: some silicon which is EEPROM-less will fail trying to read the  *  config done bit, so only an error is logged and continues.  If we were  *  to return with error, EEPROM-less silicon would not be able to be reset  *  or change link.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_cfg_done_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|bank
init|=
literal|0
decl_stmt|;
name|u32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cfg_done_ich8lan"
argument_list|)
expr_stmt|;
name|e1000_get_cfg_done_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Wait for indication from h/w that it has completed basic config */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_ich10lan
condition|)
block|{
name|e1000_lan_init_done_ich8lan
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|e1000_get_auto_rd_done_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
comment|/* When auto config read does not complete, do not 			 * return with an error. This can happen in situations 			 * where there is no eeprom and prevents getting link. 			 */
name|DEBUGOUT
argument_list|(
literal|"Auto Read Done did not complete\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
block|}
block|}
comment|/* Clear PHY Reset Asserted bit */
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_PHYRA
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|,
name|status
operator|&
operator|~
name|E1000_STATUS_PHYRA
argument_list|)
expr_stmt|;
else|else
name|DEBUGOUT
argument_list|(
literal|"PHY Reset Asserted not set - needs delay\n"
argument_list|)
expr_stmt|;
comment|/* If EEPROM is not marked present, init the IGP 3 PHY manually */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<=
name|e1000_ich9lan
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
operator|&
name|E1000_EECD_PRES
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_igp_3
operator|)
condition|)
block|{
name|e1000_phy_init_script_igp3
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|e1000_valid_nvm_bank_detect_ich8lan
argument_list|(
name|hw
argument_list|,
operator|&
name|bank
argument_list|)
condition|)
block|{
comment|/* Maybe we should do a basic PHY config */
name|DEBUGOUT
argument_list|(
literal|"EEPROM not present\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_CONFIG
expr_stmt|;
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  * e1000_power_down_phy_copper_ich8lan - Remove link during PHY power down  * @hw: pointer to the HW structure  *  * In the case of a PHY power down to save power, or to turn off link during a  * driver unload, or wake on lan is not enabled, remove the link.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_power_down_phy_copper_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
comment|/* If the management interface is not enabled, then power down */
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_mng_mode
argument_list|(
name|hw
argument_list|)
operator|||
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_reset_block
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
name|e1000_power_down_phy_copper
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_clear_hw_cntrs_ich8lan - Clear statistical counters  *  @hw: pointer to the HW structure  *  *  Clears hardware counters specific to the silicon family and calls  *  clear_hw_cntrs_generic to clear all general purpose counters.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_clear_hw_cntrs_ich8lan
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|phy_data
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clear_hw_cntrs_ich8lan"
argument_list|)
expr_stmt|;
name|e1000_clear_hw_cntrs_base_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ALGNERRC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXERRC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TNCRS
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CEXTERR
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTFC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPRC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPDC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IAC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXOC
argument_list|)
expr_stmt|;
comment|/* Clear PHY statistics registers */
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82578
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82579
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_i217
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82577
operator|)
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|set_page
argument_list|(
name|hw
argument_list|,
name|HV_STATS_PAGE
operator|<<
name|IGP_PAGE_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_page
argument_list|(
name|hw
argument_list|,
name|HV_SCC_UPPER
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_page
argument_list|(
name|hw
argument_list|,
name|HV_SCC_LOWER
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_page
argument_list|(
name|hw
argument_list|,
name|HV_ECOL_UPPER
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_page
argument_list|(
name|hw
argument_list|,
name|HV_ECOL_LOWER
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_page
argument_list|(
name|hw
argument_list|,
name|HV_MCC_UPPER
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_page
argument_list|(
name|hw
argument_list|,
name|HV_MCC_LOWER
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_page
argument_list|(
name|hw
argument_list|,
name|HV_LATECOL_UPPER
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_page
argument_list|(
name|hw
argument_list|,
name|HV_LATECOL_LOWER
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_page
argument_list|(
name|hw
argument_list|,
name|HV_COLC_UPPER
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_page
argument_list|(
name|hw
argument_list|,
name|HV_COLC_LOWER
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_page
argument_list|(
name|hw
argument_list|,
name|HV_DC_UPPER
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_page
argument_list|(
name|hw
argument_list|,
name|HV_DC_LOWER
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_page
argument_list|(
name|hw
argument_list|,
name|HV_TNCRS_UPPER
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_page
argument_list|(
name|hw
argument_list|,
name|HV_TNCRS_LOWER
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

