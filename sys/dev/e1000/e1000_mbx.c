begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"e1000_mbx.h"
end_include

begin_comment
comment|/**  *  e1000_null_mbx_check_for_flag - No-op function, return 0  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_null_mbx_check_for_flag
parameter_list|(
name|struct
name|e1000_hw
name|E1000_UNUSEDARG
modifier|*
name|hw
parameter_list|,
name|u16
name|E1000_UNUSEDARG
name|mbx_id
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_mbx_check_flag"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_mbx_transact - No-op function, return 0  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_null_mbx_transact
parameter_list|(
name|struct
name|e1000_hw
name|E1000_UNUSEDARG
modifier|*
name|hw
parameter_list|,
name|u32
name|E1000_UNUSEDARG
modifier|*
name|msg
parameter_list|,
name|u16
name|E1000_UNUSEDARG
name|size
parameter_list|,
name|u16
name|E1000_UNUSEDARG
name|mbx_id
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_mbx_rw_msg"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_mbx - Reads a message from the mailbox  *  @hw: pointer to the HW structure  *  @msg: The message buffer  *  @size: Length of buffer  *  @mbx_id: id of mailbox to read  *  *  returns SUCCESS if it successfuly read message from buffer  **/
end_comment

begin_function
name|s32
name|e1000_read_mbx
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|msg
parameter_list|,
name|u16
name|size
parameter_list|,
name|u16
name|mbx_id
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_mbx"
argument_list|)
expr_stmt|;
comment|/* limit read to size of mailbox */
if|if
condition|(
name|size
operator|>
name|mbx
operator|->
name|size
condition|)
name|size
operator|=
name|mbx
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|mbx
operator|->
name|ops
operator|.
name|read
condition|)
name|ret_val
operator|=
name|mbx
operator|->
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|msg
argument_list|,
name|size
argument_list|,
name|mbx_id
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_mbx - Write a message to the mailbox  *  @hw: pointer to the HW structure  *  @msg: The message buffer  *  @size: Length of buffer  *  @mbx_id: id of mailbox to write  *  *  returns SUCCESS if it successfully copied message into the buffer  **/
end_comment

begin_function
name|s32
name|e1000_write_mbx
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|msg
parameter_list|,
name|u16
name|size
parameter_list|,
name|u16
name|mbx_id
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_mbx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|mbx
operator|->
name|size
condition|)
name|ret_val
operator|=
operator|-
name|E1000_ERR_MBX
expr_stmt|;
elseif|else
if|if
condition|(
name|mbx
operator|->
name|ops
operator|.
name|write
condition|)
name|ret_val
operator|=
name|mbx
operator|->
name|ops
operator|.
name|write
argument_list|(
name|hw
argument_list|,
name|msg
argument_list|,
name|size
argument_list|,
name|mbx_id
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_msg - checks to see if someone sent us mail  *  @hw: pointer to the HW structure  *  @mbx_id: id of mailbox to check  *  *  returns SUCCESS if the Status bit was found or else ERR_MBX  **/
end_comment

begin_function
name|s32
name|e1000_check_for_msg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mbx_id
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_msg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbx
operator|->
name|ops
operator|.
name|check_for_msg
condition|)
name|ret_val
operator|=
name|mbx
operator|->
name|ops
operator|.
name|check_for_msg
argument_list|(
name|hw
argument_list|,
name|mbx_id
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_ack - checks to see if someone sent us ACK  *  @hw: pointer to the HW structure  *  @mbx_id: id of mailbox to check  *  *  returns SUCCESS if the Status bit was found or else ERR_MBX  **/
end_comment

begin_function
name|s32
name|e1000_check_for_ack
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mbx_id
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_ack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbx
operator|->
name|ops
operator|.
name|check_for_ack
condition|)
name|ret_val
operator|=
name|mbx
operator|->
name|ops
operator|.
name|check_for_ack
argument_list|(
name|hw
argument_list|,
name|mbx_id
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_rst - checks to see if other side has reset  *  @hw: pointer to the HW structure  *  @mbx_id: id of mailbox to check  *  *  returns SUCCESS if the Status bit was found or else ERR_MBX  **/
end_comment

begin_function
name|s32
name|e1000_check_for_rst
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mbx_id
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_rst"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbx
operator|->
name|ops
operator|.
name|check_for_rst
condition|)
name|ret_val
operator|=
name|mbx
operator|->
name|ops
operator|.
name|check_for_rst
argument_list|(
name|hw
argument_list|,
name|mbx_id
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_poll_for_msg - Wait for message notification  *  @hw: pointer to the HW structure  *  @mbx_id: id of mailbox to write  *  *  returns SUCCESS if it successfully received a message notification  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_poll_for_msg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mbx_id
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|int
name|countdown
init|=
name|mbx
operator|->
name|timeout
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_poll_for_msg"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|countdown
operator|||
operator|!
name|mbx
operator|->
name|ops
operator|.
name|check_for_msg
condition|)
goto|goto
name|out
goto|;
while|while
condition|(
name|countdown
operator|&&
name|mbx
operator|->
name|ops
operator|.
name|check_for_msg
argument_list|(
name|hw
argument_list|,
name|mbx_id
argument_list|)
condition|)
block|{
name|countdown
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|countdown
condition|)
break|break;
name|usec_delay
argument_list|(
name|mbx
operator|->
name|usec_delay
argument_list|)
expr_stmt|;
block|}
comment|/* if we failed, all future posted messages fail until reset */
if|if
condition|(
operator|!
name|countdown
condition|)
name|mbx
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
name|countdown
condition|?
name|E1000_SUCCESS
else|:
operator|-
name|E1000_ERR_MBX
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_poll_for_ack - Wait for message acknowledgement  *  @hw: pointer to the HW structure  *  @mbx_id: id of mailbox to write  *  *  returns SUCCESS if it successfully received a message acknowledgement  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_poll_for_ack
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mbx_id
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|int
name|countdown
init|=
name|mbx
operator|->
name|timeout
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_poll_for_ack"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|countdown
operator|||
operator|!
name|mbx
operator|->
name|ops
operator|.
name|check_for_ack
condition|)
goto|goto
name|out
goto|;
while|while
condition|(
name|countdown
operator|&&
name|mbx
operator|->
name|ops
operator|.
name|check_for_ack
argument_list|(
name|hw
argument_list|,
name|mbx_id
argument_list|)
condition|)
block|{
name|countdown
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|countdown
condition|)
break|break;
name|usec_delay
argument_list|(
name|mbx
operator|->
name|usec_delay
argument_list|)
expr_stmt|;
block|}
comment|/* if we failed, all future posted messages fail until reset */
if|if
condition|(
operator|!
name|countdown
condition|)
name|mbx
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
name|countdown
condition|?
name|E1000_SUCCESS
else|:
operator|-
name|E1000_ERR_MBX
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_posted_mbx - Wait for message notification and receive message  *  @hw: pointer to the HW structure  *  @msg: The message buffer  *  @size: Length of buffer  *  @mbx_id: id of mailbox to write  *  *  returns SUCCESS if it successfully received a message notification and  *  copied it into the receive buffer.  **/
end_comment

begin_function
name|s32
name|e1000_read_posted_mbx
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|msg
parameter_list|,
name|u16
name|size
parameter_list|,
name|u16
name|mbx_id
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_posted_mbx"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mbx
operator|->
name|ops
operator|.
name|read
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_poll_for_msg
argument_list|(
name|hw
argument_list|,
name|mbx_id
argument_list|)
expr_stmt|;
comment|/* if ack received read message, otherwise we timed out */
if|if
condition|(
operator|!
name|ret_val
condition|)
name|ret_val
operator|=
name|mbx
operator|->
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|msg
argument_list|,
name|size
argument_list|,
name|mbx_id
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_posted_mbx - Write a message to the mailbox, wait for ack  *  @hw: pointer to the HW structure  *  @msg: The message buffer  *  @size: Length of buffer  *  @mbx_id: id of mailbox to write  *  *  returns SUCCESS if it successfully copied message into the buffer and  *  received an ack to that message within delay * timeout period  **/
end_comment

begin_function
name|s32
name|e1000_write_posted_mbx
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|msg
parameter_list|,
name|u16
name|size
parameter_list|,
name|u16
name|mbx_id
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_posted_mbx"
argument_list|)
expr_stmt|;
comment|/* exit if either we can't write or there isn't a defined timeout */
if|if
condition|(
operator|!
name|mbx
operator|->
name|ops
operator|.
name|write
operator|||
operator|!
name|mbx
operator|->
name|timeout
condition|)
goto|goto
name|out
goto|;
comment|/* send msg */
name|ret_val
operator|=
name|mbx
operator|->
name|ops
operator|.
name|write
argument_list|(
name|hw
argument_list|,
name|msg
argument_list|,
name|size
argument_list|,
name|mbx_id
argument_list|)
expr_stmt|;
comment|/* if msg sent wait until we receive an ack */
if|if
condition|(
operator|!
name|ret_val
condition|)
name|ret_val
operator|=
name|e1000_poll_for_ack
argument_list|(
name|hw
argument_list|,
name|mbx_id
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_mbx_ops_generic - Initialize mbx function pointers  *  @hw: pointer to the HW structure  *  *  Sets the function pointers to no-op functions  **/
end_comment

begin_function
name|void
name|e1000_init_mbx_ops_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|init_params
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|read
operator|=
name|e1000_null_mbx_transact
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|write
operator|=
name|e1000_null_mbx_transact
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|check_for_msg
operator|=
name|e1000_null_mbx_check_for_flag
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|check_for_ack
operator|=
name|e1000_null_mbx_check_for_flag
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|check_for_rst
operator|=
name|e1000_null_mbx_check_for_flag
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|read_posted
operator|=
name|e1000_read_posted_mbx
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|write_posted
operator|=
name|e1000_write_posted_mbx
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_v2p_mailbox - read v2p mailbox  *  @hw: pointer to the HW structure  *  *  This function is used to read the v2p mailbox without losing the read to  *  clear status bits.  **/
end_comment

begin_function
specifier|static
name|u32
name|e1000_read_v2p_mailbox
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|v2p_mailbox
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_V2PMAILBOX
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|v2p_mailbox
operator||=
name|hw
operator|->
name|dev_spec
operator|.
name|vf
operator|.
name|v2p_mailbox
expr_stmt|;
name|hw
operator|->
name|dev_spec
operator|.
name|vf
operator|.
name|v2p_mailbox
operator||=
name|v2p_mailbox
operator|&
name|E1000_V2PMAILBOX_R2C_BITS
expr_stmt|;
return|return
name|v2p_mailbox
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_bit_vf - Determine if a status bit was set  *  @hw: pointer to the HW structure  *  @mask: bitmask for bits to be tested and cleared  *  *  This function is used to check for the read to clear bits within  *  the V2P mailbox.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_check_for_bit_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|mask
parameter_list|)
block|{
name|u32
name|v2p_mailbox
init|=
name|e1000_read_v2p_mailbox
argument_list|(
name|hw
argument_list|)
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
if|if
condition|(
name|v2p_mailbox
operator|&
name|mask
condition|)
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
name|hw
operator|->
name|dev_spec
operator|.
name|vf
operator|.
name|v2p_mailbox
operator|&=
operator|~
name|mask
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_msg_vf - checks to see if the PF has sent mail  *  @hw: pointer to the HW structure  *  @mbx_id: id of mailbox to check  *  *  returns SUCCESS if the PF has set the Status bit or else ERR_MBX  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_check_for_msg_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|E1000_UNUSEDARG
name|mbx_id
parameter_list|)
block|{
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_msg_vf"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e1000_check_for_bit_vf
argument_list|(
name|hw
argument_list|,
name|E1000_V2PMAILBOX_PFSTS
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
name|hw
operator|->
name|mbx
operator|.
name|stats
operator|.
name|reqs
operator|++
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_ack_vf - checks to see if the PF has ACK'd  *  @hw: pointer to the HW structure  *  @mbx_id: id of mailbox to check  *  *  returns SUCCESS if the PF has set the ACK bit or else ERR_MBX  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_check_for_ack_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|E1000_UNUSEDARG
name|mbx_id
parameter_list|)
block|{
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_ack_vf"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e1000_check_for_bit_vf
argument_list|(
name|hw
argument_list|,
name|E1000_V2PMAILBOX_PFACK
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
name|hw
operator|->
name|mbx
operator|.
name|stats
operator|.
name|acks
operator|++
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_rst_vf - checks to see if the PF has reset  *  @hw: pointer to the HW structure  *  @mbx_id: id of mailbox to check  *  *  returns TRUE if the PF has set the reset done bit or else FALSE  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_check_for_rst_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|E1000_UNUSEDARG
name|mbx_id
parameter_list|)
block|{
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_rst_vf"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e1000_check_for_bit_vf
argument_list|(
name|hw
argument_list|,
operator|(
name|E1000_V2PMAILBOX_RSTD
operator||
name|E1000_V2PMAILBOX_RSTI
operator|)
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
name|hw
operator|->
name|mbx
operator|.
name|stats
operator|.
name|rsts
operator|++
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_obtain_mbx_lock_vf - obtain mailbox lock  *  @hw: pointer to the HW structure  *  *  return SUCCESS if we obtained the mailbox lock  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_obtain_mbx_lock_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_obtain_mbx_lock_vf"
argument_list|)
expr_stmt|;
comment|/* Take ownership of the buffer */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_V2PMAILBOX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|E1000_V2PMAILBOX_VFU
argument_list|)
expr_stmt|;
comment|/* reserve mailbox for vf use */
if|if
condition|(
name|e1000_read_v2p_mailbox
argument_list|(
name|hw
argument_list|)
operator|&
name|E1000_V2PMAILBOX_VFU
condition|)
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_mbx_vf - Write a message to the mailbox  *  @hw: pointer to the HW structure  *  @msg: The message buffer  *  @size: Length of buffer  *  @mbx_id: id of mailbox to write  *  *  returns SUCCESS if it successfully copied message into the buffer  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_write_mbx_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|msg
parameter_list|,
name|u16
name|size
parameter_list|,
name|u16
name|E1000_UNUSEDARG
name|mbx_id
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_mbx_vf"
argument_list|)
expr_stmt|;
comment|/* lock the mailbox to prevent pf/vf race condition */
name|ret_val
operator|=
name|e1000_obtain_mbx_lock_vf
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out_no_write
goto|;
comment|/* flush msg and acks as we are overwriting the message buffer */
name|e1000_check_for_msg_vf
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e1000_check_for_ack_vf
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* copy the caller specified message to the mailbox memory buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VMBMEM
argument_list|(
literal|0
argument_list|)
argument_list|,
name|i
argument_list|,
name|msg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* update stats */
name|hw
operator|->
name|mbx
operator|.
name|stats
operator|.
name|msgs_tx
operator|++
expr_stmt|;
comment|/* Drop VFU and interrupt the PF to tell it a message has been sent */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_V2PMAILBOX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|E1000_V2PMAILBOX_REQ
argument_list|)
expr_stmt|;
name|out_no_write
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_mbx_vf - Reads a message from the inbox intended for vf  *  @hw: pointer to the HW structure  *  @msg: The message buffer  *  @size: Length of buffer  *  @mbx_id: id of mailbox to read  *  *  returns SUCCESS if it successfuly read message from buffer  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_mbx_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|msg
parameter_list|,
name|u16
name|size
parameter_list|,
name|u16
name|E1000_UNUSEDARG
name|mbx_id
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_mbx_vf"
argument_list|)
expr_stmt|;
comment|/* lock the mailbox to prevent pf/vf race condition */
name|ret_val
operator|=
name|e1000_obtain_mbx_lock_vf
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out_no_read
goto|;
comment|/* copy the message from the mailbox memory buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|msg
index|[
name|i
index|]
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VMBMEM
argument_list|(
literal|0
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Acknowledge receipt and release mailbox, then we're done */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_V2PMAILBOX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|E1000_V2PMAILBOX_ACK
argument_list|)
expr_stmt|;
comment|/* update stats */
name|hw
operator|->
name|mbx
operator|.
name|stats
operator|.
name|msgs_rx
operator|++
expr_stmt|;
name|out_no_read
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_mbx_params_vf - set initial values for vf mailbox  *  @hw: pointer to the HW structure  *  *  Initializes the hw->mbx struct to correct values for vf mailbox  */
end_comment

begin_function
name|s32
name|e1000_init_mbx_params_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
comment|/* start mailbox as timed out and let the reset_hw call set the timeout 	 * value to begin communications */
name|mbx
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|mbx
operator|->
name|usec_delay
operator|=
name|E1000_VF_MBX_INIT_DELAY
expr_stmt|;
name|mbx
operator|->
name|size
operator|=
name|E1000_VFMAILBOX_SIZE
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|read
operator|=
name|e1000_read_mbx_vf
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|write
operator|=
name|e1000_write_mbx_vf
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|read_posted
operator|=
name|e1000_read_posted_mbx
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|write_posted
operator|=
name|e1000_write_posted_mbx
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|check_for_msg
operator|=
name|e1000_check_for_msg_vf
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|check_for_ack
operator|=
name|e1000_check_for_ack_vf
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|check_for_rst
operator|=
name|e1000_check_for_rst_vf
expr_stmt|;
name|mbx
operator|->
name|stats
operator|.
name|msgs_tx
operator|=
literal|0
expr_stmt|;
name|mbx
operator|->
name|stats
operator|.
name|msgs_rx
operator|=
literal|0
expr_stmt|;
name|mbx
operator|->
name|stats
operator|.
name|reqs
operator|=
literal|0
expr_stmt|;
name|mbx
operator|->
name|stats
operator|.
name|acks
operator|=
literal|0
expr_stmt|;
name|mbx
operator|->
name|stats
operator|.
name|rsts
operator|=
literal|0
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|s32
name|e1000_check_for_bit_pf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|mask
parameter_list|)
block|{
name|u32
name|mbvficr
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MBVFICR
argument_list|)
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
if|if
condition|(
name|mbvficr
operator|&
name|mask
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MBVFICR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_msg_pf - checks to see if the VF has sent mail  *  @hw: pointer to the HW structure  *  @vf_number: the VF index  *  *  returns SUCCESS if the VF has set the Status bit or else ERR_MBX  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_check_for_msg_pf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|vf_number
parameter_list|)
block|{
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_msg_pf"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e1000_check_for_bit_pf
argument_list|(
name|hw
argument_list|,
name|E1000_MBVFICR_VFREQ_VF1
operator|<<
name|vf_number
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
name|hw
operator|->
name|mbx
operator|.
name|stats
operator|.
name|reqs
operator|++
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_ack_pf - checks to see if the VF has ACKed  *  @hw: pointer to the HW structure  *  @vf_number: the VF index  *  *  returns SUCCESS if the VF has set the Status bit or else ERR_MBX  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_check_for_ack_pf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|vf_number
parameter_list|)
block|{
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_ack_pf"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e1000_check_for_bit_pf
argument_list|(
name|hw
argument_list|,
name|E1000_MBVFICR_VFACK_VF1
operator|<<
name|vf_number
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
name|hw
operator|->
name|mbx
operator|.
name|stats
operator|.
name|acks
operator|++
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_rst_pf - checks to see if the VF has reset  *  @hw: pointer to the HW structure  *  @vf_number: the VF index  *  *  returns SUCCESS if the VF has set the Status bit or else ERR_MBX  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_check_for_rst_pf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|vf_number
parameter_list|)
block|{
name|u32
name|vflre
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_VFLRE
argument_list|)
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_rst_pf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflre
operator|&
operator|(
literal|1
operator|<<
name|vf_number
operator|)
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_VFLRE
argument_list|,
operator|(
literal|1
operator|<<
name|vf_number
operator|)
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mbx
operator|.
name|stats
operator|.
name|rsts
operator|++
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_obtain_mbx_lock_pf - obtain mailbox lock  *  @hw: pointer to the HW structure  *  @vf_number: the VF index  *  *  return SUCCESS if we obtained the mailbox lock  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_obtain_mbx_lock_pf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|vf_number
parameter_list|)
block|{
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MBX
decl_stmt|;
name|u32
name|p2v_mailbox
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_obtain_mbx_lock_pf"
argument_list|)
expr_stmt|;
comment|/* Take ownership of the buffer */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_P2VMAILBOX
argument_list|(
name|vf_number
argument_list|)
argument_list|,
name|E1000_P2VMAILBOX_PFU
argument_list|)
expr_stmt|;
comment|/* reserve mailbox for vf use */
name|p2v_mailbox
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_P2VMAILBOX
argument_list|(
name|vf_number
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2v_mailbox
operator|&
name|E1000_P2VMAILBOX_PFU
condition|)
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_mbx_pf - Places a message in the mailbox  *  @hw: pointer to the HW structure  *  @msg: The message buffer  *  @size: Length of buffer  *  @vf_number: the VF index  *  *  returns SUCCESS if it successfully copied message into the buffer  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_write_mbx_pf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|msg
parameter_list|,
name|u16
name|size
parameter_list|,
name|u16
name|vf_number
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_mbx_pf"
argument_list|)
expr_stmt|;
comment|/* lock the mailbox to prevent pf/vf race condition */
name|ret_val
operator|=
name|e1000_obtain_mbx_lock_pf
argument_list|(
name|hw
argument_list|,
name|vf_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out_no_write
goto|;
comment|/* flush msg and acks as we are overwriting the message buffer */
name|e1000_check_for_msg_pf
argument_list|(
name|hw
argument_list|,
name|vf_number
argument_list|)
expr_stmt|;
name|e1000_check_for_ack_pf
argument_list|(
name|hw
argument_list|,
name|vf_number
argument_list|)
expr_stmt|;
comment|/* copy the caller specified message to the mailbox memory buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VMBMEM
argument_list|(
name|vf_number
argument_list|)
argument_list|,
name|i
argument_list|,
name|msg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Interrupt VF to tell it a message has been sent and release buffer*/
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_P2VMAILBOX
argument_list|(
name|vf_number
argument_list|)
argument_list|,
name|E1000_P2VMAILBOX_STS
argument_list|)
expr_stmt|;
comment|/* update stats */
name|hw
operator|->
name|mbx
operator|.
name|stats
operator|.
name|msgs_tx
operator|++
expr_stmt|;
name|out_no_write
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_mbx_pf - Read a message from the mailbox  *  @hw: pointer to the HW structure  *  @msg: The message buffer  *  @size: Length of buffer  *  @vf_number: the VF index  *  *  This function copies a message from the mailbox buffer to the caller's  *  memory buffer.  The presumption is that the caller knows that there was  *  a message due to a VF request so no polling for message is needed.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_mbx_pf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|msg
parameter_list|,
name|u16
name|size
parameter_list|,
name|u16
name|vf_number
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_mbx_pf"
argument_list|)
expr_stmt|;
comment|/* lock the mailbox to prevent pf/vf race condition */
name|ret_val
operator|=
name|e1000_obtain_mbx_lock_pf
argument_list|(
name|hw
argument_list|,
name|vf_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out_no_read
goto|;
comment|/* copy the message to the mailbox memory buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|msg
index|[
name|i
index|]
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VMBMEM
argument_list|(
name|vf_number
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Acknowledge the message and release buffer */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_P2VMAILBOX
argument_list|(
name|vf_number
argument_list|)
argument_list|,
name|E1000_P2VMAILBOX_ACK
argument_list|)
expr_stmt|;
comment|/* update stats */
name|hw
operator|->
name|mbx
operator|.
name|stats
operator|.
name|msgs_rx
operator|++
expr_stmt|;
name|out_no_read
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_mbx_params_pf - set initial values for pf mailbox  *  @hw: pointer to the HW structure  *  *  Initializes the hw->mbx struct to correct values for pf mailbox  */
end_comment

begin_function
name|s32
name|e1000_init_mbx_params_pf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82576
case|:
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
name|mbx
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|mbx
operator|->
name|usec_delay
operator|=
literal|0
expr_stmt|;
name|mbx
operator|->
name|size
operator|=
name|E1000_VFMAILBOX_SIZE
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|read
operator|=
name|e1000_read_mbx_pf
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|write
operator|=
name|e1000_write_mbx_pf
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|read_posted
operator|=
name|e1000_read_posted_mbx
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|write_posted
operator|=
name|e1000_write_posted_mbx
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|check_for_msg
operator|=
name|e1000_check_for_msg_pf
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|check_for_ack
operator|=
name|e1000_check_for_ack_pf
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|check_for_rst
operator|=
name|e1000_check_for_rst_pf
expr_stmt|;
name|mbx
operator|->
name|stats
operator|.
name|msgs_tx
operator|=
literal|0
expr_stmt|;
name|mbx
operator|->
name|stats
operator|.
name|msgs_rx
operator|=
literal|0
expr_stmt|;
name|mbx
operator|->
name|stats
operator|.
name|reqs
operator|=
literal|0
expr_stmt|;
name|mbx
operator|->
name|stats
operator|.
name|acks
operator|=
literal|0
expr_stmt|;
name|mbx
operator|->
name|stats
operator|.
name|rsts
operator|=
literal|0
expr_stmt|;
default|default:
return|return
name|E1000_SUCCESS
return|;
block|}
block|}
end_function

end_unit

