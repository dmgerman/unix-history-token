begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"e1000_api.h"
end_include

begin_function_decl
specifier|static
name|s32
name|e1000_wait_autoneg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_access_phy_wakeup_reg_bm
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|,
name|bool
name|read
parameter_list|,
name|bool
name|page_set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u32
name|e1000_get_phy_addr_for_hv_page
parameter_list|(
name|u32
name|page
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_access_phy_debug_regs_hv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|,
name|bool
name|read
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Cable length tables */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u16
name|e1000_m88_cable_length_table
index|[]
init|=
block|{
literal|0
block|,
literal|50
block|,
literal|80
block|,
literal|110
block|,
literal|140
block|,
literal|140
block|,
name|E1000_CABLE_LENGTH_UNDEFINED
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|M88E1000_CABLE_LENGTH_TABLE_SIZE
define|\
value|(sizeof(e1000_m88_cable_length_table) / \ 		 sizeof(e1000_m88_cable_length_table[0]))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|u16
name|e1000_igp_2_cable_length_table
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|5
block|,
literal|8
block|,
literal|11
block|,
literal|13
block|,
literal|16
block|,
literal|18
block|,
literal|21
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|6
block|,
literal|10
block|,
literal|13
block|,
literal|16
block|,
literal|19
block|,
literal|23
block|,
literal|26
block|,
literal|29
block|,
literal|32
block|,
literal|35
block|,
literal|38
block|,
literal|41
block|,
literal|6
block|,
literal|10
block|,
literal|14
block|,
literal|18
block|,
literal|22
block|,
literal|26
block|,
literal|30
block|,
literal|33
block|,
literal|37
block|,
literal|41
block|,
literal|44
block|,
literal|48
block|,
literal|51
block|,
literal|54
block|,
literal|58
block|,
literal|61
block|,
literal|21
block|,
literal|26
block|,
literal|31
block|,
literal|35
block|,
literal|40
block|,
literal|44
block|,
literal|49
block|,
literal|53
block|,
literal|57
block|,
literal|61
block|,
literal|65
block|,
literal|68
block|,
literal|72
block|,
literal|75
block|,
literal|79
block|,
literal|82
block|,
literal|40
block|,
literal|45
block|,
literal|51
block|,
literal|56
block|,
literal|61
block|,
literal|66
block|,
literal|70
block|,
literal|75
block|,
literal|79
block|,
literal|83
block|,
literal|87
block|,
literal|91
block|,
literal|94
block|,
literal|98
block|,
literal|101
block|,
literal|104
block|,
literal|60
block|,
literal|66
block|,
literal|72
block|,
literal|77
block|,
literal|82
block|,
literal|87
block|,
literal|92
block|,
literal|96
block|,
literal|100
block|,
literal|104
block|,
literal|108
block|,
literal|111
block|,
literal|114
block|,
literal|117
block|,
literal|119
block|,
literal|121
block|,
literal|83
block|,
literal|89
block|,
literal|95
block|,
literal|100
block|,
literal|105
block|,
literal|109
block|,
literal|113
block|,
literal|116
block|,
literal|119
block|,
literal|122
block|,
literal|124
block|,
literal|104
block|,
literal|109
block|,
literal|114
block|,
literal|118
block|,
literal|121
block|,
literal|124
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IGP02E1000_CABLE_LENGTH_TABLE_SIZE
define|\
value|(sizeof(e1000_igp_2_cable_length_table) / \ 		 sizeof(e1000_igp_2_cable_length_table[0]))
end_define

begin_comment
comment|/**  *  e1000_init_phy_ops_generic - Initialize PHY function pointers  *  @hw: pointer to the HW structure  *  *  Setups up the function pointers to no-op functions  **/
end_comment

begin_function
name|void
name|e1000_init_phy_ops_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_phy_ops_generic"
argument_list|)
expr_stmt|;
comment|/* Initialize function pointers */
name|phy
operator|->
name|ops
operator|.
name|init_params
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|acquire
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_polarity
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_reset_block
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|commit
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|force_speed_duplex
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cfg_done
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_info
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_page
operator|=
name|e1000_null_set_page
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|e1000_null_read_reg
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg_locked
operator|=
name|e1000_null_read_reg
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg_page
operator|=
name|e1000_null_read_reg
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|release
operator|=
name|e1000_null_phy_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d0_lplu_state
operator|=
name|e1000_null_lplu_state
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d3_lplu_state
operator|=
name|e1000_null_lplu_state
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|e1000_null_write_reg
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg_locked
operator|=
name|e1000_null_write_reg
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg_page
operator|=
name|e1000_null_write_reg
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|power_up
operator|=
name|e1000_null_phy_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|power_down
operator|=
name|e1000_null_phy_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_i2c_byte
operator|=
name|e1000_read_i2c_byte_null
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_i2c_byte
operator|=
name|e1000_write_i2c_byte_null
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|cfg_on_link_up
operator|=
name|e1000_null_ops_generic
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_set_page - No-op function, return 0  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|s32
name|e1000_null_set_page
parameter_list|(
name|struct
name|e1000_hw
name|E1000_UNUSEDARG
modifier|*
name|hw
parameter_list|,
name|u16
name|E1000_UNUSEDARG
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_set_page"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_read_reg - No-op function, return 0  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|s32
name|e1000_null_read_reg
parameter_list|(
name|struct
name|e1000_hw
name|E1000_UNUSEDARG
modifier|*
name|hw
parameter_list|,
name|u32
name|E1000_UNUSEDARG
name|offset
parameter_list|,
name|u16
name|E1000_UNUSEDARG
modifier|*
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_read_reg"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_phy_generic - No-op function, return void  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|void
name|e1000_null_phy_generic
parameter_list|(
name|struct
name|e1000_hw
name|E1000_UNUSEDARG
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_phy_generic"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_lplu_state - No-op function, return 0  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|s32
name|e1000_null_lplu_state
parameter_list|(
name|struct
name|e1000_hw
name|E1000_UNUSEDARG
modifier|*
name|hw
parameter_list|,
name|bool
name|E1000_UNUSEDARG
name|active
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_lplu_state"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_write_reg - No-op function, return 0  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|s32
name|e1000_null_write_reg
parameter_list|(
name|struct
name|e1000_hw
name|E1000_UNUSEDARG
modifier|*
name|hw
parameter_list|,
name|u32
name|E1000_UNUSEDARG
name|offset
parameter_list|,
name|u16
name|E1000_UNUSEDARG
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_write_reg"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_i2c_byte_null - No-op function, return 0  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset to write  *  @dev_addr: device address  *  @data: data value read  *  **/
end_comment

begin_function
name|s32
name|e1000_read_i2c_byte_null
parameter_list|(
name|struct
name|e1000_hw
name|E1000_UNUSEDARG
modifier|*
name|hw
parameter_list|,
name|u8
name|E1000_UNUSEDARG
name|byte_offset
parameter_list|,
name|u8
name|E1000_UNUSEDARG
name|dev_addr
parameter_list|,
name|u8
name|E1000_UNUSEDARG
modifier|*
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_i2c_byte_null"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_i2c_byte_null - No-op function, return 0  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset to write  *  @dev_addr: device address  *  @data: data value to write  *  **/
end_comment

begin_function
name|s32
name|e1000_write_i2c_byte_null
parameter_list|(
name|struct
name|e1000_hw
name|E1000_UNUSEDARG
modifier|*
name|hw
parameter_list|,
name|u8
name|E1000_UNUSEDARG
name|byte_offset
parameter_list|,
name|u8
name|E1000_UNUSEDARG
name|dev_addr
parameter_list|,
name|u8
name|E1000_UNUSEDARG
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_i2c_byte_null"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_reset_block_generic - Check if PHY reset is blocked  *  @hw: pointer to the HW structure  *  *  Read the PHY management control register and check whether a PHY reset  *  is blocked.  If a reset is not blocked return E1000_SUCCESS, otherwise  *  return E1000_BLK_PHY_RESET (12).  **/
end_comment

begin_function
name|s32
name|e1000_check_reset_block_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|manc
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_reset_block"
argument_list|)
expr_stmt|;
name|manc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MANC
argument_list|)
expr_stmt|;
return|return
operator|(
name|manc
operator|&
name|E1000_MANC_BLK_PHY_RST_ON_IDE
operator|)
condition|?
name|E1000_BLK_PHY_RESET
else|:
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_id - Retrieve the PHY ID and revision  *  @hw: pointer to the HW structure  *  *  Reads the PHY registers and stores the PHY ID and possibly the PHY  *  revision in the hardware structure.  **/
end_comment

begin_function
name|s32
name|e1000_get_phy_id
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|phy_id
decl_stmt|;
name|u16
name|retry_count
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_id"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phy
operator|->
name|ops
operator|.
name|read_reg
condition|)
return|return
name|E1000_SUCCESS
return|;
while|while
condition|(
name|retry_count
operator|<
literal|2
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_ID1
argument_list|,
operator|&
name|phy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy
operator|->
name|id
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_id
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_ID2
argument_list|,
operator|&
name|phy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy
operator|->
name|id
operator||=
call|(
name|u32
call|)
argument_list|(
name|phy_id
operator|&
name|PHY_REVISION_MASK
argument_list|)
expr_stmt|;
name|phy
operator|->
name|revision
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_id
operator|&
operator|~
name|PHY_REVISION_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|id
operator|!=
literal|0
operator|&&
name|phy
operator|->
name|id
operator|!=
name|PHY_REVISION_MASK
condition|)
return|return
name|E1000_SUCCESS
return|;
name|retry_count
operator|++
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_reset_dsp_generic - Reset PHY DSP  *  @hw: pointer to the HW structure  *  *  Reset the digital signal processor.  **/
end_comment

begin_function
name|s32
name|e1000_phy_reset_dsp_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_reset_dsp_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0xC1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_GEN_CONTROL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_mdic - Read MDI control register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Reads the MDI control register in the PHY at offset and stores the  *  information read to data.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_mdic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|mdic
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_mdic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_REG_ADDRESS
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %d is out of range\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
comment|/* Set up Op-code, Phy Address, and register offset in the MDI 	 * Control register.  The MAC will take care of interfacing with the 	 * PHY to retrieve the desired data. 	 */
name|mdic
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_MDIC_REG_SHIFT
operator|)
operator||
operator|(
name|phy
operator|->
name|addr
operator|<<
name|E1000_MDIC_PHY_SHIFT
operator|)
operator||
operator|(
name|E1000_MDIC_OP_READ
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDIC
argument_list|,
name|mdic
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the MDI read completed 	 * Increasing the time out as testing showed failures with 	 * the lower time out 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|E1000_GEN_POLL_TIMEOUT
operator|*
literal|3
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay_irq
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|mdic
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|mdic
operator|&
name|E1000_MDIC_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Read did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_ERROR
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|mdic
operator|&
name|E1000_MDIC_REG_MASK
operator|)
operator|>>
name|E1000_MDIC_REG_SHIFT
operator|)
operator|!=
name|offset
condition|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"MDI Read offset error - requested %d, returned %d\n"
argument_list|,
name|offset
argument_list|,
operator|(
name|mdic
operator|&
name|E1000_MDIC_REG_MASK
operator|)
operator|>>
name|E1000_MDIC_REG_SHIFT
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
operator|*
name|data
operator|=
operator|(
name|u16
operator|)
name|mdic
expr_stmt|;
comment|/* Allow some time after each MDIC transaction to avoid 	 * reading duplicate data in the next MDIC transaction. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
condition|)
name|usec_delay_irq
argument_list|(
literal|100
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_mdic - Write MDI control register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write to register at offset  *  *  Writes data to MDI control register in the PHY at offset.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_mdic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|mdic
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_mdic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_REG_ADDRESS
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %d is out of range\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
comment|/* Set up Op-code, Phy Address, and register offset in the MDI 	 * Control register.  The MAC will take care of interfacing with the 	 * PHY to retrieve the desired data. 	 */
name|mdic
operator|=
operator|(
operator|(
operator|(
name|u32
operator|)
name|data
operator|)
operator||
operator|(
name|offset
operator|<<
name|E1000_MDIC_REG_SHIFT
operator|)
operator||
operator|(
name|phy
operator|->
name|addr
operator|<<
name|E1000_MDIC_PHY_SHIFT
operator|)
operator||
operator|(
name|E1000_MDIC_OP_WRITE
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDIC
argument_list|,
name|mdic
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the MDI read completed 	 * Increasing the time out as testing showed failures with 	 * the lower time out 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|E1000_GEN_POLL_TIMEOUT
operator|*
literal|3
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay_irq
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|mdic
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|mdic
operator|&
name|E1000_MDIC_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Write did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|mdic
operator|&
name|E1000_MDIC_ERROR
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MDI Error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|mdic
operator|&
name|E1000_MDIC_REG_MASK
operator|)
operator|>>
name|E1000_MDIC_REG_SHIFT
operator|)
operator|!=
name|offset
condition|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"MDI Write offset error - requested %d, returned %d\n"
argument_list|,
name|offset
argument_list|,
operator|(
name|mdic
operator|&
name|E1000_MDIC_REG_MASK
operator|)
operator|>>
name|E1000_MDIC_REG_SHIFT
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
comment|/* Allow some time after each MDIC transaction to avoid 	 * reading duplicate data in the next MDIC transaction. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pch2lan
condition|)
name|usec_delay_irq
argument_list|(
literal|100
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_i2c - Read PHY register using i2c  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Reads the PHY register at offset using the i2c interface and stores the  *  retrieved information in data.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_i2c
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|i2ccmd
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_i2c"
argument_list|)
expr_stmt|;
comment|/* Set up Op-code, Phy Address, and register address in the I2CCMD 	 * register.  The MAC will take care of interfacing with the 	 * PHY to retrieve the desired data. 	 */
name|i2ccmd
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_I2CCMD_REG_ADDR_SHIFT
operator|)
operator||
operator|(
name|phy
operator|->
name|addr
operator|<<
name|E1000_I2CCMD_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|E1000_I2CCMD_OPCODE_READ
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD
argument_list|,
name|i2ccmd
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the I2C read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_I2CCMD_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|i2ccmd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2CCMD Read did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_ERROR
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2CCMD Error bit set\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
comment|/* Need to byte-swap the 16-bit value. */
operator|*
name|data
operator|=
operator|(
operator|(
name|i2ccmd
operator|>>
literal|8
operator|)
operator|&
literal|0x00FF
operator|)
operator||
operator|(
operator|(
name|i2ccmd
operator|<<
literal|8
operator|)
operator|&
literal|0xFF00
operator|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_i2c - Write PHY register using i2c  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Writes the data to PHY register at the offset using the i2c interface.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_i2c
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|i2ccmd
init|=
literal|0
decl_stmt|;
name|u16
name|phy_data_swapped
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_i2c"
argument_list|)
expr_stmt|;
comment|/* Prevent overwritting SFP I2C EEPROM which is at A0 address.*/
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|==
literal|0
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|>
literal|7
operator|)
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY I2C Address %d is out of range.\n"
argument_list|,
name|hw
operator|->
name|phy
operator|.
name|addr
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
comment|/* Swap the data bytes for the I2C interface */
name|phy_data_swapped
operator|=
operator|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0x00FF
operator|)
operator||
operator|(
operator|(
name|data
operator|<<
literal|8
operator|)
operator|&
literal|0xFF00
operator|)
expr_stmt|;
comment|/* Set up Op-code, Phy Address, and register address in the I2CCMD 	 * register.  The MAC will take care of interfacing with the 	 * PHY to retrieve the desired data. 	 */
name|i2ccmd
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_I2CCMD_REG_ADDR_SHIFT
operator|)
operator||
operator|(
name|phy
operator|->
name|addr
operator|<<
name|E1000_I2CCMD_PHY_ADDR_SHIFT
operator|)
operator||
name|E1000_I2CCMD_OPCODE_WRITE
operator||
name|phy_data_swapped
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD
argument_list|,
name|i2ccmd
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the I2C read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_I2CCMD_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|i2ccmd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2CCMD Write did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_ERROR
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2CCMD Error bit set\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_sfp_data_byte - Reads SFP module data.  *  @hw: pointer to the HW structure  *  @offset: byte location offset to be read  *  @data: read data buffer pointer  *  *  Reads one byte from SFP module data stored  *  in SFP resided EEPROM memory or SFP diagnostic area.  *  Function should be called with  *  E1000_I2CCMD_SFP_DATA_ADDR(<byte offset>) for SFP module database access  *  E1000_I2CCMD_SFP_DIAG_ADDR(<byte offset>) for SFP diagnostics parameters  *  access  **/
end_comment

begin_function
name|s32
name|e1000_read_sfp_data_byte
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|u32
name|i2ccmd
init|=
literal|0
decl_stmt|;
name|u32
name|data_local
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_sfp_data_byte"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|E1000_I2CCMD_SFP_DIAG_ADDR
argument_list|(
literal|255
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2CCMD command address exceeds upper limit\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
comment|/* Set up Op-code, EEPROM Address,in the I2CCMD 	 * register. The MAC will take care of interfacing with the 	 * EEPROM to retrieve the desired data. 	 */
name|i2ccmd
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_I2CCMD_REG_ADDR_SHIFT
operator|)
operator||
name|E1000_I2CCMD_OPCODE_READ
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD
argument_list|,
name|i2ccmd
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the I2C read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_I2CCMD_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|data_local
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_local
operator|&
name|E1000_I2CCMD_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|data_local
operator|&
name|E1000_I2CCMD_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2CCMD Read did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|data_local
operator|&
name|E1000_I2CCMD_ERROR
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2CCMD Error bit set\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
operator|*
name|data
operator|=
operator|(
name|u8
operator|)
name|data_local
operator|&
literal|0xFF
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_sfp_data_byte - Writes SFP module data.  *  @hw: pointer to the HW structure  *  @offset: byte location offset to write to  *  @data: data to write  *  *  Writes one byte to SFP module data stored  *  in SFP resided EEPROM memory or SFP diagnostic area.  *  Function should be called with  *  E1000_I2CCMD_SFP_DATA_ADDR(<byte offset>) for SFP module database access  *  E1000_I2CCMD_SFP_DIAG_ADDR(<byte offset>) for SFP diagnostics parameters  *  access  **/
end_comment

begin_function
name|s32
name|e1000_write_sfp_data_byte
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u8
name|data
parameter_list|)
block|{
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|u32
name|i2ccmd
init|=
literal|0
decl_stmt|;
name|u32
name|data_local
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_sfp_data_byte"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|E1000_I2CCMD_SFP_DIAG_ADDR
argument_list|(
literal|255
argument_list|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2CCMD command address exceeds upper limit\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
comment|/* The programming interface is 16 bits wide 	 * so we need to read the whole word first 	 * then update appropriate byte lane and write 	 * the updated word back. 	 */
comment|/* Set up Op-code, EEPROM Address,in the I2CCMD 	 * register. The MAC will take care of interfacing 	 * with an EEPROM to write the data given. 	 */
name|i2ccmd
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_I2CCMD_REG_ADDR_SHIFT
operator|)
operator||
name|E1000_I2CCMD_OPCODE_READ
operator|)
expr_stmt|;
comment|/* Set a command to read single word */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD
argument_list|,
name|i2ccmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_I2CCMD_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if lastly 		 * launched I2C operation completed 		 */
name|i2ccmd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_READY
condition|)
block|{
comment|/* Check if this is READ or WRITE phase */
if|if
condition|(
operator|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_OPCODE_READ
operator|)
operator|==
name|E1000_I2CCMD_OPCODE_READ
condition|)
block|{
comment|/* Write the selected byte 				 * lane and update whole word 				 */
name|data_local
operator|=
name|i2ccmd
operator|&
literal|0xFF00
expr_stmt|;
name|data_local
operator||=
name|data
expr_stmt|;
name|i2ccmd
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_I2CCMD_REG_ADDR_SHIFT
operator|)
operator||
name|E1000_I2CCMD_OPCODE_WRITE
operator||
name|data_local
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD
argument_list|,
name|i2ccmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_READY
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2CCMD Write did not complete\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
if|if
condition|(
name|i2ccmd
operator|&
name|E1000_I2CCMD_ERROR
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2CCMD Error bit set\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_m88 - Read m88 PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Acquires semaphore, if necessary, then reads the PHY register at offset  *  and storing the retrieved information in data.  Release any acquired  *  semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_m88"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_m88 - Write m88 PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Acquires semaphore, if necessary, then writes the data to PHY register  *  at the offset.  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_m88"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_page_igp - Set page as on IGP-like PHY(s)  *  @hw: pointer to the HW structure  *  @page: page to set (shifted left when necessary)  *  *  Sets PHY page required for PHY register access.  Assumes semaphore is  *  already acquired.  Note, this function sets phy.addr to 1 so the caller  *  must set it appropriately (if necessary) after this function returns.  **/
end_comment

begin_function
name|s32
name|e1000_set_page_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|page
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_page_igp"
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Setting page 0x%x\n"
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
literal|1
expr_stmt|;
return|return
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
name|page
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  __e1000_read_phy_reg_igp - Read igp PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  @locked: semaphore has already been acquired or not  *  *  Acquires semaphore, if necessary, then reads the PHY register at offset  *  and stores the retrieved information in data.  Release any acquired  *  semaphores before exiting.  **/
end_comment

begin_function
specifier|static
name|s32
name|__e1000_read_phy_reg_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|,
name|bool
name|locked
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"__e1000_read_phy_reg_igp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
block|{
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|u16
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_igp - Read igp PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Acquires semaphore then reads the PHY register at offset and stores the  *  retrieved information in data.  *  Release the acquired semaphore before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
return|return
name|__e1000_read_phy_reg_igp
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_igp_locked - Read igp PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Reads the PHY register at offset and stores the retrieved information  *  in data.  Assumes semaphore already acquired.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_igp_locked
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
return|return
name|__e1000_read_phy_reg_igp
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_igp - Write igp PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  @locked: semaphore has already been acquired or not  *  *  Acquires semaphore, if necessary, then writes the data to PHY register  *  at the offset.  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
specifier|static
name|s32
name|__e1000_write_phy_reg_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|,
name|bool
name|locked
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_igp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
block|{
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PAGE_SELECT
argument_list|,
operator|(
name|u16
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_igp - Write igp PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Acquires semaphore then writes the data to PHY register  *  at the offset.  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
return|return
name|__e1000_write_phy_reg_igp
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_igp_locked - Write igp PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Writes the data to PHY register at the offset.  *  Assumes semaphore already acquired.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_igp_locked
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
return|return
name|__e1000_write_phy_reg_igp
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  __e1000_read_kmrn_reg - Read kumeran register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  @locked: semaphore has already been acquired or not  *  *  Acquires semaphore, if necessary.  Then reads the PHY register at offset  *  using the kumeran interface.  The information retrieved is stored in data.  *  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
specifier|static
name|s32
name|__e1000_read_kmrn_reg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|,
name|bool
name|locked
parameter_list|)
block|{
name|u32
name|kmrnctrlsta
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"__e1000_read_kmrn_reg"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
name|kmrnctrlsta
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_KMRNCTRLSTA_OFFSET_SHIFT
operator|)
operator|&
name|E1000_KMRNCTRLSTA_OFFSET
operator|)
operator||
name|E1000_KMRNCTRLSTA_REN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA
argument_list|,
name|kmrnctrlsta
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|kmrnctrlsta
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
operator|(
name|u16
operator|)
name|kmrnctrlsta
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_kmrn_reg_generic -  Read kumeran register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Acquires semaphore then reads the PHY register at offset using the  *  kumeran interface.  The information retrieved is stored in data.  *  Release the acquired semaphore before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_kmrn_reg_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
return|return
name|__e1000_read_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_kmrn_reg_locked -  Read kumeran register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Reads the PHY register at offset using the kumeran interface.  The  *  information retrieved is stored in data.  *  Assumes semaphore already acquired.  **/
end_comment

begin_function
name|s32
name|e1000_read_kmrn_reg_locked
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
return|return
name|__e1000_read_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  __e1000_write_kmrn_reg - Write kumeran register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  @locked: semaphore has already been acquired or not  *  *  Acquires semaphore, if necessary.  Then write the data to PHY register  *  at the offset using the kumeran interface.  Release any acquired semaphores  *  before exiting.  **/
end_comment

begin_function
specifier|static
name|s32
name|__e1000_write_kmrn_reg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|,
name|bool
name|locked
parameter_list|)
block|{
name|u32
name|kmrnctrlsta
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_kmrn_reg_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
name|kmrnctrlsta
operator|=
operator|(
operator|(
name|offset
operator|<<
name|E1000_KMRNCTRLSTA_OFFSET_SHIFT
operator|)
operator|&
name|E1000_KMRNCTRLSTA_OFFSET
operator|)
operator||
name|data
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_KMRNCTRLSTA
argument_list|,
name|kmrnctrlsta
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_kmrn_reg_generic -  Write kumeran register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Acquires semaphore then writes the data to the PHY register at the offset  *  using the kumeran interface.  Release the acquired semaphore before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_kmrn_reg_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
return|return
name|__e1000_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_kmrn_reg_locked -  Write kumeran register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Write the data to PHY register at the offset using the kumeran interface.  *  Assumes semaphore already acquired.  **/
end_comment

begin_function
name|s32
name|e1000_write_kmrn_reg_locked
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
return|return
name|__e1000_write_kmrn_reg
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_master_slave_mode - Setup PHY for Master/slave mode  *  @hw: pointer to the HW structure  *  *  Sets up Master/slave mode  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_set_master_slave_mode
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
comment|/* Resolve Master/Slave mode */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* load defaults for future use */
name|hw
operator|->
name|phy
operator|.
name|original_ms_type
operator|=
operator|(
name|phy_data
operator|&
name|CR_1000T_MS_ENABLE
operator|)
condition|?
operator|(
operator|(
name|phy_data
operator|&
name|CR_1000T_MS_VALUE
operator|)
condition|?
name|e1000_ms_force_master
else|:
name|e1000_ms_force_slave
operator|)
else|:
name|e1000_ms_auto
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|ms_type
condition|)
block|{
case|case
name|e1000_ms_force_master
case|:
name|phy_data
operator||=
operator|(
name|CR_1000T_MS_ENABLE
operator||
name|CR_1000T_MS_VALUE
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_ms_force_slave
case|:
name|phy_data
operator||=
name|CR_1000T_MS_ENABLE
expr_stmt|;
name|phy_data
operator|&=
operator|~
operator|(
name|CR_1000T_MS_VALUE
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_ms_auto
case|:
name|phy_data
operator|&=
operator|~
name|CR_1000T_MS_ENABLE
expr_stmt|;
comment|/* fall-through */
default|default:
break|break;
block|}
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|phy_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_copper_link_setup_82577 - Setup 82577 PHY for copper link  *  @hw: pointer to the HW structure  *  *  Sets up Carrier-sense on Transmit and downshift values.  **/
end_comment

begin_function
name|s32
name|e1000_copper_link_setup_82577
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_copper_link_setup_82577"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82580
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error resetting the PHY.\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* Enable CRS on Tx. This must be set for half-duplex operation. */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|I82577_CFG_REG
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|I82577_CFG_ASSERT_CRS_ON_TX
expr_stmt|;
comment|/* Enable downshift */
name|phy_data
operator||=
name|I82577_CFG_ENABLE_DOWNSHIFT
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|I82577_CFG_REG
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Set MDI/MDIX mode */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|I82577_PHY_CTRL_2
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|I82577_PHY_CTRL2_MDIX_CFG_MASK
expr_stmt|;
comment|/* Options: 	 *   0 - Auto (default) 	 *   1 - MDI mode 	 *   2 - MDI-X mode 	 */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|mdix
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|phy_data
operator||=
name|I82577_PHY_CTRL2_MANUAL_MDIX
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|phy_data
operator||=
name|I82577_PHY_CTRL2_AUTO_MDI_MDIX
expr_stmt|;
break|break;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|I82577_PHY_CTRL_2
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
return|return
name|e1000_set_master_slave_mode
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_copper_link_setup_m88 - Setup m88 PHY's for copper link  *  @hw: pointer to the HW structure  *  *  Sets up MDI/MDI-X and polarity for m88 PHY's.  If necessary, transmit clock  *  and downshift values are set also.  **/
end_comment

begin_function
name|s32
name|e1000_copper_link_setup_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_copper_link_setup_m88"
argument_list|)
expr_stmt|;
comment|/* Enable CRS on Tx. This must be set for half-duplex operation. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* For BM PHY this bit is downshift enable */
if|if
condition|(
name|phy
operator|->
name|type
operator|!=
name|e1000_phy_bm
condition|)
name|phy_data
operator||=
name|M88E1000_PSCR_ASSERT_CRS_ON_TX
expr_stmt|;
comment|/* Options: 	 *   MDI/MDI-X = 0 (default) 	 *   0 - Auto for all speeds 	 *   1 - MDI mode 	 *   2 - MDI-X mode 	 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes) 	 */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_MDI_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_MDIX_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_AUTO_X_1000T
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|phy_data
operator||=
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
break|break;
block|}
comment|/* Options: 	 *   disable_polarity_correction = 0 (default) 	 *       Automatic Correction for Reversed Cable Polarity 	 *   0 - Disabled 	 *   1 - Enabled 	 */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|disable_polarity_correction
condition|)
name|phy_data
operator||=
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
comment|/* Enable downshift on BM (disabled by default) */
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|e1000_phy_bm
condition|)
block|{
comment|/* For 82574/82583, first disable then enable downshift */
if|if
condition|(
name|phy
operator|->
name|id
operator|==
name|BME1000_E_PHY_ID_R2
condition|)
block|{
name|phy_data
operator|&=
operator|~
name|BME1000_PSCR_ENABLE_DOWNSHIFT
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Commit the changes. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|commit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error committing the PHY changes\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
name|phy_data
operator||=
name|BME1000_PSCR_ENABLE_DOWNSHIFT
expr_stmt|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|phy
operator|->
name|type
operator|==
name|e1000_phy_m88
operator|)
operator|&&
operator|(
name|phy
operator|->
name|revision
operator|<
name|E1000_REVISION_4
operator|)
operator|&&
operator|(
name|phy
operator|->
name|id
operator|!=
name|BME1000_E_PHY_ID_R2
operator|)
condition|)
block|{
comment|/* Force TX_CLK in the Extended PHY Specific Control Register 		 * to 25MHz clock. 		 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|M88E1000_EPSCR_TX_CLK_25
expr_stmt|;
if|if
condition|(
operator|(
name|phy
operator|->
name|revision
operator|==
name|E1000_REVISION_2
operator|)
operator|&&
operator|(
name|phy
operator|->
name|id
operator|==
name|M88E1111_I_PHY_ID
operator|)
condition|)
block|{
comment|/* 82573L PHY - set the downshift counter to 5x. */
name|phy_data
operator|&=
operator|~
name|M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK
expr_stmt|;
name|phy_data
operator||=
name|M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X
expr_stmt|;
block|}
else|else
block|{
comment|/* Configure Master and Slave downshift values */
name|phy_data
operator|&=
operator|~
operator|(
name|M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK
operator||
name|M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK
operator|)
expr_stmt|;
name|phy_data
operator||=
operator|(
name|M88E1000_EPSCR_MASTER_DOWNSHIFT_1X
operator||
name|M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X
operator|)
expr_stmt|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
if|if
condition|(
operator|(
name|phy
operator|->
name|type
operator|==
name|e1000_phy_bm
operator|)
operator|&&
operator|(
name|phy
operator|->
name|id
operator|==
name|BME1000_E_PHY_ID_R2
operator|)
condition|)
block|{
comment|/* Set PHY page 0, register 29 to 0x0003 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|29
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Set PHY page 0, register 30 to 0x0000 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|30
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* Commit the changes. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|commit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error committing the PHY changes\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|e1000_phy_82578
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* 82578 PHY - set the downshift count to 1x. */
name|phy_data
operator||=
name|I82578_EPSCR_DOWNSHIFT_ENABLE
expr_stmt|;
name|phy_data
operator|&=
operator|~
name|I82578_EPSCR_DOWNSHIFT_COUNTER_MASK
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_copper_link_setup_m88_gen2 - Setup m88 PHY's for copper link  *  @hw: pointer to the HW structure  *  *  Sets up MDI/MDI-X and polarity for i347-AT4, m88e1322 and m88e1112 PHY's.  *  Also enables and sets the downshift parameters.  **/
end_comment

begin_function
name|s32
name|e1000_copper_link_setup_m88_gen2
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_copper_link_setup_m88_gen2"
argument_list|)
expr_stmt|;
comment|/* Enable CRS on Tx. This must be set for half-duplex operation. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Options: 	 *   MDI/MDI-X = 0 (default) 	 *   0 - Auto for all speeds 	 *   1 - MDI mode 	 *   2 - MDI-X mode 	 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes) 	 */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_MDI_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|phy_data
operator||=
name|M88E1000_PSCR_MDIX_MANUAL_MODE
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* M88E1112 does not support this mode) */
if|if
condition|(
name|phy
operator|->
name|id
operator|!=
name|M88E1112_E_PHY_ID
condition|)
block|{
name|phy_data
operator||=
name|M88E1000_PSCR_AUTO_X_1000T
expr_stmt|;
break|break;
block|}
case|case
literal|0
case|:
default|default:
name|phy_data
operator||=
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
break|break;
block|}
comment|/* Options: 	 *   disable_polarity_correction = 0 (default) 	 *       Automatic Correction for Reversed Cable Polarity 	 *   0 - Disabled 	 *   1 - Enabled 	 */
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|disable_polarity_correction
condition|)
name|phy_data
operator||=
name|M88E1000_PSCR_POLARITY_REVERSAL
expr_stmt|;
comment|/* Enable downshift and setting it to X6 */
if|if
condition|(
name|phy
operator|->
name|id
operator|==
name|M88E1543_E_PHY_ID
condition|)
block|{
name|phy_data
operator|&=
operator|~
name|I347AT4_PSCR_DOWNSHIFT_ENABLE
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|commit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error committing the PHY changes\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
name|phy_data
operator|&=
operator|~
name|I347AT4_PSCR_DOWNSHIFT_MASK
expr_stmt|;
name|phy_data
operator||=
name|I347AT4_PSCR_DOWNSHIFT_6X
expr_stmt|;
name|phy_data
operator||=
name|I347AT4_PSCR_DOWNSHIFT_ENABLE
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Commit the changes. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|commit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error committing the PHY changes\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|ret_val
operator|=
name|e1000_set_master_slave_mode
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_copper_link_setup_igp - Setup igp PHY's for copper link  *  @hw: pointer to the HW structure  *  *  Sets up LPLU, MDI/MDI-X, polarity, Smartspeed and Master/Slave config for  *  igp PHY's.  **/
end_comment

begin_function
name|s32
name|e1000_copper_link_setup_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_copper_link_setup_igp"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error resetting the PHY.\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Wait 100ms for MAC to configure PHY from NVM settings, to avoid 	 * timeout issues when LFS is enabled. 	 */
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* The NVM settings will configure LPLU in D3 for 	 * non-IGP1 PHYs. 	 */
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|e1000_phy_igp
condition|)
block|{
comment|/* disable lplu d3 during driver init */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|set_d3_lplu_state
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Disabling LPLU D3\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* disable lplu d0 during driver init */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|set_d0_lplu_state
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|set_d0_lplu_state
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Disabling LPLU D0\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* Configure mdi-mdix settings */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|mdix
condition|)
block|{
case|case
literal|1
case|:
name|data
operator|&=
operator|~
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|data
operator||=
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
break|break;
case|case
literal|0
case|:
default|default:
name|data
operator||=
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
break|break;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* set auto-master slave resolution settings */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|autoneg
condition|)
block|{
comment|/* when autonegotiation advertisement is only 1000Mbps then we 		 * should disable SmartSpeed and enable Auto MasterSlave 		 * resolution as hardware default. 		 */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|ADVERTISE_1000_FULL
condition|)
block|{
comment|/* Disable SmartSpeed */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Set auto Master/Slave resolution process */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|~
name|CR_1000T_MS_ENABLE
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
name|ret_val
operator|=
name|e1000_set_master_slave_mode
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_setup_autoneg - Configure PHY for auto-negotiation  *  @hw: pointer to the HW structure  *  *  Reads the MII auto-neg advertisement register and/or the 1000T control  *  register and if the PHY is already setup for auto-negotiation, then  *  return successful.  Otherwise, setup advertisement and flow control to  *  the appropriate values for the wanted auto-negotiation.  **/
end_comment

begin_function
name|s32
name|e1000_phy_setup_autoneg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|mii_autoneg_adv_reg
decl_stmt|;
name|u16
name|mii_1000t_ctrl_reg
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_setup_autoneg"
argument_list|)
expr_stmt|;
name|phy
operator|->
name|autoneg_advertised
operator|&=
name|phy
operator|->
name|autoneg_mask
expr_stmt|;
comment|/* Read the MII Auto-Neg Advertisement Register (Address 4). */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
operator|&
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|phy
operator|->
name|autoneg_mask
operator|&
name|ADVERTISE_1000_FULL
condition|)
block|{
comment|/* Read the MII 1000Base-T Control Register (Address 9). */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
operator|&
name|mii_1000t_ctrl_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* Need to parse both autoneg_advertised and fc and set up 	 * the appropriate PHY registers.  First we will parse for 	 * autoneg_advertised software override.  Since we can advertise 	 * a plethora of combinations, we need to check each bit 	 * individually. 	 */
comment|/* First we clear all the 10/100 mb speed bits in the Auto-Neg 	 * Advertisement Register (Address 4) and the 1000 mb speed bits in 	 * the  1000Base-T Control Register (Address 9). 	 */
name|mii_autoneg_adv_reg
operator|&=
operator|~
operator|(
name|NWAY_AR_100TX_FD_CAPS
operator||
name|NWAY_AR_100TX_HD_CAPS
operator||
name|NWAY_AR_10T_FD_CAPS
operator||
name|NWAY_AR_10T_HD_CAPS
operator|)
expr_stmt|;
name|mii_1000t_ctrl_reg
operator|&=
operator|~
operator|(
name|CR_1000T_HD_CAPS
operator||
name|CR_1000T_FD_CAPS
operator|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"autoneg_advertised %x\n"
argument_list|,
name|phy
operator|->
name|autoneg_advertised
argument_list|)
expr_stmt|;
comment|/* Do we want to advertise 10 Mb Half Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_10_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 10mb Half duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_10T_HD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 10 Mb Full Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_10_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 10mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_10T_FD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 100 Mb Half Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_100_HALF
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 100mb Half duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_100TX_HD_CAPS
expr_stmt|;
block|}
comment|/* Do we want to advertise 100 Mb Full Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_100_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 100mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_100TX_FD_CAPS
expr_stmt|;
block|}
comment|/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_HALF
condition|)
name|DEBUGOUT
argument_list|(
literal|"Advertise 1000mb Half duplex request denied!\n"
argument_list|)
expr_stmt|;
comment|/* Do we want to advertise 1000 Mb Full Duplex? */
if|if
condition|(
name|phy
operator|->
name|autoneg_advertised
operator|&
name|ADVERTISE_1000_FULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Advertise 1000mb Full duplex\n"
argument_list|)
expr_stmt|;
name|mii_1000t_ctrl_reg
operator||=
name|CR_1000T_FD_CAPS
expr_stmt|;
block|}
comment|/* Check for a software override of the flow control settings, and 	 * setup the PHY advertisement registers accordingly.  If 	 * auto-negotiation is enabled, then software will have to set the 	 * "PAUSE" bits to the correct value in the Auto-Negotiation 	 * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto- 	 * negotiation. 	 * 	 * The possible values of the "fc" parameter are: 	 *      0:  Flow control is completely disabled 	 *      1:  Rx flow control is enabled (we can receive pause frames 	 *          but not send pause frames). 	 *      2:  Tx flow control is enabled (we can send pause frames 	 *          but we do not support receiving pause frames). 	 *      3:  Both Rx and Tx flow control (symmetric) are enabled. 	 *  other:  No software override.  The flow control configuration 	 *          in the EEPROM is used. 	 */
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
condition|)
block|{
case|case
name|e1000_fc_none
case|:
comment|/* Flow control (Rx& Tx) is completely disabled by a 		 * software over-ride. 		 */
name|mii_autoneg_adv_reg
operator|&=
operator|~
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_fc_rx_pause
case|:
comment|/* Rx Flow control is enabled, and Tx Flow control is 		 * disabled, by a software over-ride. 		 * 		 * Since there really isn't a way to advertise that we are 		 * capable of Rx Pause ONLY, we will advertise that we 		 * support both symmetric and asymmetric Rx PAUSE.  Later 		 * (in e1000_config_fc_after_link_up) we will disable the 		 * hw's ability to send PAUSE frames. 		 */
name|mii_autoneg_adv_reg
operator||=
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_fc_tx_pause
case|:
comment|/* Tx Flow control is enabled, and Rx Flow control is 		 * disabled, by a software over-ride. 		 */
name|mii_autoneg_adv_reg
operator||=
name|NWAY_AR_ASM_DIR
expr_stmt|;
name|mii_autoneg_adv_reg
operator|&=
operator|~
name|NWAY_AR_PAUSE
expr_stmt|;
break|break;
case|case
name|e1000_fc_full
case|:
comment|/* Flow control (both Rx and Tx) is enabled by a software 		 * over-ride. 		 */
name|mii_autoneg_adv_reg
operator||=
operator|(
name|NWAY_AR_ASM_DIR
operator||
name|NWAY_AR_PAUSE
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|DEBUGOUT1
argument_list|(
literal|"Auto-Neg Advertising %x\n"
argument_list|,
name|mii_autoneg_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|autoneg_mask
operator|&
name|ADVERTISE_1000_FULL
condition|)
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_CTRL
argument_list|,
name|mii_1000t_ctrl_reg
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_copper_link_autoneg - Setup/Enable autoneg for copper link  *  @hw: pointer to the HW structure  *  *  Performs initial bounds checking on autoneg advertisement parameter, then  *  configure to advertise the full capability.  Setup the PHY to autoneg  *  and restart the negotiation process between the link partner.  If  *  autoneg_wait_to_complete, then wait for autoneg to complete before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_copper_link_autoneg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_copper_link_autoneg"
argument_list|)
expr_stmt|;
comment|/* Perform some bounds checking on the autoneg advertisement 	 * parameter. 	 */
name|phy
operator|->
name|autoneg_advertised
operator|&=
name|phy
operator|->
name|autoneg_mask
expr_stmt|;
comment|/* If autoneg_advertised is zero, we assume it was not defaulted 	 * by the calling code so we set to advertise full capability. 	 */
if|if
condition|(
operator|!
name|phy
operator|->
name|autoneg_advertised
condition|)
name|phy
operator|->
name|autoneg_advertised
operator|=
name|phy
operator|->
name|autoneg_mask
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Reconfiguring auto-neg advertisement params\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_setup_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Setting up Auto-Negotiation\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"Restarting Auto-Neg\n"
argument_list|)
expr_stmt|;
comment|/* Restart auto-negotiation by setting the Auto Neg Enable bit and 	 * the Auto Neg Restart bit in the PHY control register. 	 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_ctrl
operator||=
operator|(
name|MII_CR_AUTO_NEG_EN
operator||
name|MII_CR_RESTART_AUTO_NEG
operator|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Does the user want to wait for Auto-Neg to complete here, or 	 * check at a later time (for example, callback routine). 	 */
if|if
condition|(
name|phy
operator|->
name|autoneg_wait_to_complete
condition|)
block|{
name|ret_val
operator|=
name|e1000_wait_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error while waiting for autoneg to complete\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
name|hw
operator|->
name|mac
operator|.
name|get_link_status
operator|=
name|TRUE
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_copper_link_generic - Configure copper link settings  *  @hw: pointer to the HW structure  *  *  Calls the appropriate function to configure the link for auto-neg or forced  *  speed and duplex.  Then we check for link, once link is established calls  *  to configure collision distance and flow control are called.  If link is  *  not established, we return -E1000_ERR_PHY (-2).  **/
end_comment

begin_function
name|s32
name|e1000_setup_copper_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_copper_link_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|autoneg
condition|)
block|{
comment|/* Setup autoneg and flow control advertisement and perform 		 * autonegotiation. 		 */
name|ret_val
operator|=
name|e1000_copper_link_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
comment|/* PHY will be set to 10H, 10F, 100H or 100F 		 * depending on user settings. 		 */
name|DEBUGOUT
argument_list|(
literal|"Forcing Speed and Duplex\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|force_speed_duplex
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error Forcing Speed and Duplex\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
comment|/* Check link status. Wait up to 100 microseconds for link to become 	 * valid. 	 */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|COPPER_LINK_UP_LIMIT
argument_list|,
literal|10
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Valid link established!!!\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"Unable to establish link!!!\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex_igp - Force speed/duplex for igp PHY  *  @hw: pointer to the HW structure  *  *  Calls the PHY setup function to force speed and duplex.  Clears the  *  auto-crossover to force MDI manually.  Waits for link and returns  *  successful if link up is successful, else -E1000_ERR_PHY (-2).  **/
end_comment

begin_function
name|s32
name|e1000_phy_force_speed_duplex_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_force_speed_duplex_igp"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|e1000_phy_force_speed_duplex_setup
argument_list|(
name|hw
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Clear Auto-Crossover to force MDI manually.  IGP requires MDI 	 * forced whenever speed and duplex are forced. 	 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCR_AUTO_MDIX
expr_stmt|;
name|phy_data
operator|&=
operator|~
name|IGP01E1000_PSCR_FORCE_MDI_MDIX
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|DEBUGOUT1
argument_list|(
literal|"IGP PSCR: %X\n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|autoneg_wait_to_complete
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Waiting for forced speed/duplex link on IGP phy.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
name|link
condition|)
name|DEBUGOUT
argument_list|(
literal|"Link taking longer than expected.\n"
argument_list|)
expr_stmt|;
comment|/* Try once more */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex_m88 - Force speed/duplex for m88 PHY  *  @hw: pointer to the HW structure  *  *  Calls the PHY setup function to force speed and duplex.  Clears the  *  auto-crossover to force MDI manually.  Resets the PHY to commit the  *  changes.  If time expires while waiting for link up, we reset the DSP.  *  After reset, TX_CLK and CRS on Tx must be set.  Return successful upon  *  successful completion, else return corresponding error code.  **/
end_comment

begin_function
name|s32
name|e1000_phy_force_speed_duplex_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_force_speed_duplex_m88"
argument_list|)
expr_stmt|;
comment|/* I210 and I211 devices support Auto-Crossover in forced operation. */
if|if
condition|(
name|phy
operator|->
name|type
operator|!=
name|e1000_phy_i210
condition|)
block|{
comment|/* Clear Auto-Crossover to force MDI manually.  M88E1000 		 * requires MDI forced whenever speed and duplex are forced. 		 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator|&=
operator|~
name|M88E1000_PSCR_AUTO_X_MODE
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|DEBUGOUT1
argument_list|(
literal|"M88E1000 PSCR: %X\n"
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|e1000_phy_force_speed_duplex_setup
argument_list|(
name|hw
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Reset the phy to commit changes. */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|commit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|phy
operator|->
name|autoneg_wait_to_complete
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Waiting for forced speed/duplex link on M88 phy.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|bool
name|reset_dsp
init|=
name|TRUE
decl_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|id
condition|)
block|{
case|case
name|I347AT4_E_PHY_ID
case|:
case|case
name|M88E1340M_E_PHY_ID
case|:
case|case
name|M88E1112_E_PHY_ID
case|:
case|case
name|M88E1543_E_PHY_ID
case|:
case|case
name|M88E1512_E_PHY_ID
case|:
case|case
name|I210_I_PHY_ID
case|:
name|reset_dsp
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|!=
name|e1000_phy_m88
condition|)
name|reset_dsp
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|reset_dsp
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Link taking longer than expected.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We didn't get link. 				 * Reset the DSP and cross our fingers. 				 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_PAGE_SELECT
argument_list|,
literal|0x001d
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_phy_reset_dsp_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
comment|/* Try once more */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|!=
name|e1000_phy_m88
condition|)
return|return
name|E1000_SUCCESS
return|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|id
operator|==
name|I347AT4_E_PHY_ID
operator|||
name|hw
operator|->
name|phy
operator|.
name|id
operator|==
name|M88E1340M_E_PHY_ID
operator|||
name|hw
operator|->
name|phy
operator|.
name|id
operator|==
name|M88E1112_E_PHY_ID
condition|)
return|return
name|E1000_SUCCESS
return|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|id
operator|==
name|I210_I_PHY_ID
condition|)
return|return
name|E1000_SUCCESS
return|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|id
operator|==
name|M88E1543_E_PHY_ID
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|id
operator|==
name|M88E1512_E_PHY_ID
operator|)
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Resetting the phy means we need to re-force TX_CLK in the 	 * Extended PHY Specific Control Register to 25MHz clock from 	 * the reset value of 2.5MHz. 	 */
name|phy_data
operator||=
name|M88E1000_EPSCR_TX_CLK_25
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_EXT_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* In addition, we must re-enable CRS on Tx for both half and full 	 * duplex. 	 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_data
operator||=
name|M88E1000_PSCR_ASSERT_CRS_ON_TX
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex_ife - Force PHY speed& duplex  *  @hw: pointer to the HW structure  *  *  Forces the speed and duplex settings of the PHY.  *  This is a function pointer entry point only called by  *  PHY setup routines.  **/
end_comment

begin_function
name|s32
name|e1000_phy_force_speed_duplex_ife
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_force_speed_duplex_ife"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|e1000_phy_force_speed_duplex_setup
argument_list|(
name|hw
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Disable MDI-X support for 10/100 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_MDIX_CONTROL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|~
name|IFE_PMC_AUTO_MDIX
expr_stmt|;
name|data
operator|&=
operator|~
name|IFE_PMC_FORCE_MDIX
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_MDIX_CONTROL
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|DEBUGOUT1
argument_list|(
literal|"IFE PMC: %X\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|autoneg_wait_to_complete
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Waiting for forced speed/duplex link on IFE phy.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
name|link
condition|)
name|DEBUGOUT
argument_list|(
literal|"Link taking longer than expected.\n"
argument_list|)
expr_stmt|;
comment|/* Try once more */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex_setup - Configure forced PHY speed/duplex  *  @hw: pointer to the HW structure  *  @phy_ctrl: pointer to current value of PHY_CONTROL  *  *  Forces speed and duplex on the PHY by doing the following: disable flow  *  control, force speed/duplex on the MAC, disable auto speed detection,  *  disable auto-negotiation, configure duplex, configure speed, configure  *  the collision distance, write configuration to CTRL register.  The  *  caller must write to the PHY_CONTROL register for these settings to  *  take affect.  **/
end_comment

begin_function
name|void
name|e1000_phy_force_speed_duplex_setup
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|phy_ctrl
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_force_speed_duplex_setup"
argument_list|)
expr_stmt|;
comment|/* Turn off flow control when forcing speed/duplex */
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|e1000_fc_none
expr_stmt|;
comment|/* Force speed/duplex on the mac */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SPD_SEL
expr_stmt|;
comment|/* Disable Auto Speed Detection */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_ASDE
expr_stmt|;
comment|/* Disable autoneg on the phy */
operator|*
name|phy_ctrl
operator|&=
operator|~
name|MII_CR_AUTO_NEG_EN
expr_stmt|;
comment|/* Forcing Full or Half Duplex? */
if|if
condition|(
name|mac
operator|->
name|forced_speed_duplex
operator|&
name|E1000_ALL_HALF_DUPLEX
condition|)
block|{
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_FD
expr_stmt|;
operator|*
name|phy_ctrl
operator|&=
operator|~
name|MII_CR_FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Half Duplex\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctrl
operator||=
name|E1000_CTRL_FD
expr_stmt|;
operator|*
name|phy_ctrl
operator||=
name|MII_CR_FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Forcing 10mb or 100mb? */
if|if
condition|(
name|mac
operator|->
name|forced_speed_duplex
operator|&
name|E1000_ALL_100_SPEED
condition|)
block|{
name|ctrl
operator||=
name|E1000_CTRL_SPD_100
expr_stmt|;
operator|*
name|phy_ctrl
operator||=
name|MII_CR_SPEED_100
expr_stmt|;
operator|*
name|phy_ctrl
operator|&=
operator|~
name|MII_CR_SPEED_1000
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Forcing 100mb\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_SPD_1000
operator||
name|E1000_CTRL_SPD_100
operator|)
expr_stmt|;
operator|*
name|phy_ctrl
operator|&=
operator|~
operator|(
name|MII_CR_SPEED_1000
operator||
name|MII_CR_SPEED_100
operator|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Forcing 10mb\n"
argument_list|)
expr_stmt|;
block|}
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d3_lplu_state_generic - Sets low power link up state for D3  *  @hw: pointer to the HW structure  *  @active: boolean used to enable/disable lplu  *  *  Success returns 0, Failure returns 1  *  *  The low power link up (lplu) state is set to the power management level D3  *  and SmartSpeed is disabled when active is TRUE, else clear lplu for D3  *  and enable Smartspeed.  LPLU and Smartspeed are mutually exclusive.  LPLU  *  is used during Dx states where the power conservation is most important.  *  During driver activity, SmartSpeed should be enabled so performance is  *  maintained.  **/
end_comment

begin_function
name|s32
name|e1000_set_d3_lplu_state_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d3_lplu_state_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
name|active
condition|)
block|{
name|data
operator|&=
operator|~
name|IGP02E1000_PM_D3_LPLU
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used 		 * during Dx states where the power conservation is most 		 * important.  During driver activity we should enable 		 * SmartSpeed, so performance is maintained. 		 */
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_on
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator||=
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_off
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_SPEED_DUPLEX
operator|)
operator|||
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_NOT_GIG
operator|)
operator|||
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_10_SPEED
operator|)
condition|)
block|{
name|data
operator||=
name|IGP02E1000_PM_D3_LPLU
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* When LPLU is enabled, we should disable SmartSpeed */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_downshift_generic - Checks whether a downshift in speed occurred  *  @hw: pointer to the HW structure  *  *  Success returns 0, Failure returns 1  *  *  A downshift is detected by querying the PHY link health.  **/
end_comment

begin_function
name|s32
name|e1000_check_downshift_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|offset
decl_stmt|,
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_downshift_generic"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|type
condition|)
block|{
case|case
name|e1000_phy_i210
case|:
case|case
name|e1000_phy_m88
case|:
case|case
name|e1000_phy_gg82563
case|:
case|case
name|e1000_phy_bm
case|:
case|case
name|e1000_phy_82578
case|:
name|offset
operator|=
name|M88E1000_PHY_SPEC_STATUS
expr_stmt|;
name|mask
operator|=
name|M88E1000_PSSR_DOWNSHIFT
expr_stmt|;
break|break;
case|case
name|e1000_phy_igp
case|:
case|case
name|e1000_phy_igp_2
case|:
case|case
name|e1000_phy_igp_3
case|:
name|offset
operator|=
name|IGP01E1000_PHY_LINK_HEALTH
expr_stmt|;
name|mask
operator|=
name|IGP01E1000_PLHR_SS_DOWNGRADE
expr_stmt|;
break|break;
default|default:
comment|/* speed downshift not supported */
name|phy
operator|->
name|speed_downgraded
operator|=
name|FALSE
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|phy
operator|->
name|speed_downgraded
operator|=
operator|!
operator|!
operator|(
name|phy_data
operator|&
name|mask
operator|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_polarity_m88 - Checks the polarity.  *  @hw: pointer to the HW structure  *  *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)  *  *  Polarity is determined based on the PHY specific status register.  **/
end_comment

begin_function
name|s32
name|e1000_check_polarity_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_polarity_m88"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|phy
operator|->
name|cable_polarity
operator|=
operator|(
operator|(
name|data
operator|&
name|M88E1000_PSSR_REV_POLARITY
operator|)
condition|?
name|e1000_rev_polarity_reversed
else|:
name|e1000_rev_polarity_normal
operator|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_polarity_igp - Checks the polarity.  *  @hw: pointer to the HW structure  *  *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)  *  *  Polarity is determined based on the PHY port status register, and the  *  current speed (since there is no polarity at 100Mbps).  **/
end_comment

begin_function
name|s32
name|e1000_check_polarity_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|,
name|offset
decl_stmt|,
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_polarity_igp"
argument_list|)
expr_stmt|;
comment|/* Polarity is determined based on the speed of 	 * our connection. 	 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|(
name|data
operator|&
name|IGP01E1000_PSSR_SPEED_MASK
operator|)
operator|==
name|IGP01E1000_PSSR_SPEED_1000MBPS
condition|)
block|{
name|offset
operator|=
name|IGP01E1000_PHY_PCS_INIT_REG
expr_stmt|;
name|mask
operator|=
name|IGP01E1000_PHY_POLARITY_MASK
expr_stmt|;
block|}
else|else
block|{
comment|/* This really only applies to 10Mbps since 		 * there is no polarity for 100Mbps (always 0). 		 */
name|offset
operator|=
name|IGP01E1000_PHY_PORT_STATUS
expr_stmt|;
name|mask
operator|=
name|IGP01E1000_PSSR_POLARITY_REVERSED
expr_stmt|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|phy
operator|->
name|cable_polarity
operator|=
operator|(
operator|(
name|data
operator|&
name|mask
operator|)
condition|?
name|e1000_rev_polarity_reversed
else|:
name|e1000_rev_polarity_normal
operator|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_polarity_ife - Check cable polarity for IFE PHY  *  @hw: pointer to the HW structure  *  *  Polarity is determined on the polarity reversal feature being enabled.  **/
end_comment

begin_function
name|s32
name|e1000_check_polarity_ife
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|offset
decl_stmt|,
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_polarity_ife"
argument_list|)
expr_stmt|;
comment|/* Polarity is determined based on the reversal feature being enabled. 	 */
if|if
condition|(
name|phy
operator|->
name|polarity_correction
condition|)
block|{
name|offset
operator|=
name|IFE_PHY_EXTENDED_STATUS_CONTROL
expr_stmt|;
name|mask
operator|=
name|IFE_PESC_POLARITY_REVERSED
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|IFE_PHY_SPECIAL_CONTROL
expr_stmt|;
name|mask
operator|=
name|IFE_PSC_FORCE_POLARITY
expr_stmt|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|phy
operator|->
name|cable_polarity
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|mask
operator|)
condition|?
name|e1000_rev_polarity_reversed
else|:
name|e1000_rev_polarity_normal
operator|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_wait_autoneg - Wait for auto-neg completion  *  @hw: pointer to the HW structure  *  *  Waits for auto-negotiation to complete or for the auto-negotiation time  *  limit to expire, which ever happens first.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_wait_autoneg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|phy_status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_wait_autoneg"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Break after autoneg completes or PHY_AUTO_NEG_LIMIT expires. */
for|for
control|(
name|i
operator|=
name|PHY_AUTO_NEG_LIMIT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
if|if
condition|(
name|phy_status
operator|&
name|MII_SR_AUTONEG_COMPLETE
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* PHY_AUTO_NEG_TIME expiration doesn't guarantee auto-negotiation 	 * has completed. 	 */
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_has_link_generic - Polls PHY for link  *  @hw: pointer to the HW structure  *  @iterations: number of times to poll for link  *  @usec_interval: delay between polling attempts  *  @success: pointer to whether polling was successful or not  *  *  Polls the PHY status register for link, 'iterations' number of times.  **/
end_comment

begin_function
name|s32
name|e1000_phy_has_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|iterations
parameter_list|,
name|u32
name|usec_interval
parameter_list|,
name|bool
modifier|*
name|success
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|phy_status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_has_link_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
condition|)
return|return
name|E1000_SUCCESS
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iterations
condition|;
name|i
operator|++
control|)
block|{
comment|/* Some PHYs require the PHY_STATUS register to be read 		 * twice due to the link bit being sticky.  No harm doing 		 * it across the board. 		 */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
comment|/* If the first read fails, another entity may have 			 * ownership of the resources, wait and try again to 			 * see if they have relinquished the resources yet. 			 */
if|if
condition|(
name|usec_interval
operator|>=
literal|1000
condition|)
name|msec_delay
argument_list|(
name|usec_interval
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|usec_delay
argument_list|(
name|usec_interval
argument_list|)
expr_stmt|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|phy_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
if|if
condition|(
name|phy_status
operator|&
name|MII_SR_LINK_STATUS
condition|)
break|break;
if|if
condition|(
name|usec_interval
operator|>=
literal|1000
condition|)
name|msec_delay
argument_list|(
name|usec_interval
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|usec_delay
argument_list|(
name|usec_interval
argument_list|)
expr_stmt|;
block|}
operator|*
name|success
operator|=
operator|(
name|i
operator|<
name|iterations
operator|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cable_length_m88 - Determine cable length for m88 PHY  *  @hw: pointer to the HW structure  *  *  Reads the PHY specific status register to retrieve the cable length  *  information.  The cable length is determined by averaging the minimum and  *  maximum values to get the "average" cable length.  The m88 PHY has four  *  possible cable length values, which are:  *	Register Value		Cable Length  *	0< 50 meters  *	1			50 - 80 meters  *	2			80 - 110 meters  *	3			110 - 140 meters  *	4> 140 meters  **/
end_comment

begin_function
name|s32
name|e1000_get_cable_length_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|index
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cable_length_m88"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|index
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_CABLE_LENGTH
operator|)
operator|>>
name|M88E1000_PSSR_CABLE_LENGTH_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|M88E1000_CABLE_LENGTH_TABLE_SIZE
operator|-
literal|1
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
name|phy
operator|->
name|min_cable_length
operator|=
name|e1000_m88_cable_length_table
index|[
name|index
index|]
expr_stmt|;
name|phy
operator|->
name|max_cable_length
operator|=
name|e1000_m88_cable_length_table
index|[
name|index
operator|+
literal|1
index|]
expr_stmt|;
name|phy
operator|->
name|cable_length
operator|=
operator|(
name|phy
operator|->
name|min_cable_length
operator|+
name|phy
operator|->
name|max_cable_length
operator|)
operator|/
literal|2
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_function
name|s32
name|e1000_get_cable_length_m88_gen2
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|phy_data2
decl_stmt|,
name|is_cm
decl_stmt|;
name|u16
name|index
decl_stmt|,
name|default_page
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cable_length_m88_gen2"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|id
condition|)
block|{
case|case
name|I210_I_PHY_ID
case|:
comment|/* Get cable length from PHY Cable Diagnostics Control Reg */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
operator|(
literal|0x7
operator|<<
name|GS40G_PAGE_SHIFT
operator|)
operator|+
operator|(
name|I347AT4_PCDL
operator|+
name|phy
operator|->
name|addr
operator|)
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Check if the unit of cable length is meters or cm */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
operator|(
literal|0x7
operator|<<
name|GS40G_PAGE_SHIFT
operator|)
operator|+
name|I347AT4_PCDC
argument_list|,
operator|&
name|phy_data2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|is_cm
operator|=
operator|!
operator|(
name|phy_data2
operator|&
name|I347AT4_PCDC_CABLE_LENGTH_UNIT
operator|)
expr_stmt|;
comment|/* Populate the phy structure with cable length in meters */
name|phy
operator|->
name|min_cable_length
operator|=
name|phy_data
operator|/
operator|(
name|is_cm
condition|?
literal|100
else|:
literal|1
operator|)
expr_stmt|;
name|phy
operator|->
name|max_cable_length
operator|=
name|phy_data
operator|/
operator|(
name|is_cm
condition|?
literal|100
else|:
literal|1
operator|)
expr_stmt|;
name|phy
operator|->
name|cable_length
operator|=
name|phy_data
operator|/
operator|(
name|is_cm
condition|?
literal|100
else|:
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|M88E1543_E_PHY_ID
case|:
case|case
name|M88E1512_E_PHY_ID
case|:
case|case
name|M88E1340M_E_PHY_ID
case|:
case|case
name|I347AT4_E_PHY_ID
case|:
comment|/* Remember the original page select and set it to 7 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|I347AT4_PAGE_SELECT
argument_list|,
operator|&
name|default_page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|I347AT4_PAGE_SELECT
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Get cable length from PHY Cable Diagnostics Control Reg */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
operator|(
name|I347AT4_PCDL
operator|+
name|phy
operator|->
name|addr
operator|)
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Check if the unit of cable length is meters or cm */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|I347AT4_PCDC
argument_list|,
operator|&
name|phy_data2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|is_cm
operator|=
operator|!
operator|(
name|phy_data2
operator|&
name|I347AT4_PCDC_CABLE_LENGTH_UNIT
operator|)
expr_stmt|;
comment|/* Populate the phy structure with cable length in meters */
name|phy
operator|->
name|min_cable_length
operator|=
name|phy_data
operator|/
operator|(
name|is_cm
condition|?
literal|100
else|:
literal|1
operator|)
expr_stmt|;
name|phy
operator|->
name|max_cable_length
operator|=
name|phy_data
operator|/
operator|(
name|is_cm
condition|?
literal|100
else|:
literal|1
operator|)
expr_stmt|;
name|phy
operator|->
name|cable_length
operator|=
name|phy_data
operator|/
operator|(
name|is_cm
condition|?
literal|100
else|:
literal|1
operator|)
expr_stmt|;
comment|/* Reset the page select to its original value */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|I347AT4_PAGE_SELECT
argument_list|,
name|default_page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
break|break;
case|case
name|M88E1112_E_PHY_ID
case|:
comment|/* Remember the original page select and set it to 5 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|I347AT4_PAGE_SELECT
argument_list|,
operator|&
name|default_page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|I347AT4_PAGE_SELECT
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1112_VCT_DSP_DISTANCE
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|index
operator|=
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_CABLE_LENGTH
operator|)
operator|>>
name|M88E1000_PSSR_CABLE_LENGTH_SHIFT
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|M88E1000_CABLE_LENGTH_TABLE_SIZE
operator|-
literal|1
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
name|phy
operator|->
name|min_cable_length
operator|=
name|e1000_m88_cable_length_table
index|[
name|index
index|]
expr_stmt|;
name|phy
operator|->
name|max_cable_length
operator|=
name|e1000_m88_cable_length_table
index|[
name|index
operator|+
literal|1
index|]
expr_stmt|;
name|phy
operator|->
name|cable_length
operator|=
operator|(
name|phy
operator|->
name|min_cable_length
operator|+
name|phy
operator|->
name|max_cable_length
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* Reset the page select to its original value */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|I347AT4_PAGE_SELECT
argument_list|,
name|default_page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
break|break;
default|default:
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cable_length_igp_2 - Determine cable length for igp2 PHY  *  @hw: pointer to the HW structure  *  *  The automatic gain control (agc) normalizes the amplitude of the  *  received signal, adjusting for the attenuation produced by the  *  cable.  By reading the AGC registers, which represent the  *  combination of coarse and fine gain value, the value can be put  *  into a lookup table to obtain the approximate cable length  *  for each channel.  **/
end_comment

begin_function
name|s32
name|e1000_get_cable_length_igp_2
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|i
decl_stmt|,
name|agc_value
init|=
literal|0
decl_stmt|;
name|u16
name|cur_agc_index
decl_stmt|,
name|max_agc_index
init|=
literal|0
decl_stmt|;
name|u16
name|min_agc_index
init|=
name|IGP02E1000_CABLE_LENGTH_TABLE_SIZE
operator|-
literal|1
decl_stmt|;
specifier|static
specifier|const
name|u16
name|agc_reg_array
index|[
name|IGP02E1000_PHY_CHANNEL_NUM
index|]
init|=
block|{
name|IGP02E1000_PHY_AGC_A
block|,
name|IGP02E1000_PHY_AGC_B
block|,
name|IGP02E1000_PHY_AGC_C
block|,
name|IGP02E1000_PHY_AGC_D
block|}
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cable_length_igp_2"
argument_list|)
expr_stmt|;
comment|/* Read the AGC registers for all channels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IGP02E1000_PHY_CHANNEL_NUM
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|agc_reg_array
index|[
name|i
index|]
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Getting bits 15:9, which represent the combination of 		 * coarse and fine gain values.  The result is a number 		 * that can be put into the lookup table to obtain the 		 * approximate cable length. 		 */
name|cur_agc_index
operator|=
operator|(
operator|(
name|phy_data
operator|>>
name|IGP02E1000_AGC_LENGTH_SHIFT
operator|)
operator|&
name|IGP02E1000_AGC_LENGTH_MASK
operator|)
expr_stmt|;
comment|/* Array index bound check. */
if|if
condition|(
operator|(
name|cur_agc_index
operator|>=
name|IGP02E1000_CABLE_LENGTH_TABLE_SIZE
operator|)
operator|||
operator|(
name|cur_agc_index
operator|==
literal|0
operator|)
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
comment|/* Remove min& max AGC values from calculation. */
if|if
condition|(
name|e1000_igp_2_cable_length_table
index|[
name|min_agc_index
index|]
operator|>
name|e1000_igp_2_cable_length_table
index|[
name|cur_agc_index
index|]
condition|)
name|min_agc_index
operator|=
name|cur_agc_index
expr_stmt|;
if|if
condition|(
name|e1000_igp_2_cable_length_table
index|[
name|max_agc_index
index|]
operator|<
name|e1000_igp_2_cable_length_table
index|[
name|cur_agc_index
index|]
condition|)
name|max_agc_index
operator|=
name|cur_agc_index
expr_stmt|;
name|agc_value
operator|+=
name|e1000_igp_2_cable_length_table
index|[
name|cur_agc_index
index|]
expr_stmt|;
block|}
name|agc_value
operator|-=
operator|(
name|e1000_igp_2_cable_length_table
index|[
name|min_agc_index
index|]
operator|+
name|e1000_igp_2_cable_length_table
index|[
name|max_agc_index
index|]
operator|)
expr_stmt|;
name|agc_value
operator|/=
operator|(
name|IGP02E1000_PHY_CHANNEL_NUM
operator|-
literal|2
operator|)
expr_stmt|;
comment|/* Calculate cable length with the error range of +/- 10 meters. */
name|phy
operator|->
name|min_cable_length
operator|=
operator|(
operator|(
operator|(
name|agc_value
operator|-
name|IGP02E1000_AGC_RANGE
operator|)
operator|>
literal|0
operator|)
condition|?
operator|(
name|agc_value
operator|-
name|IGP02E1000_AGC_RANGE
operator|)
else|:
literal|0
operator|)
expr_stmt|;
name|phy
operator|->
name|max_cable_length
operator|=
name|agc_value
operator|+
name|IGP02E1000_AGC_RANGE
expr_stmt|;
name|phy
operator|->
name|cable_length
operator|=
operator|(
name|phy
operator|->
name|min_cable_length
operator|+
name|phy
operator|->
name|max_cable_length
operator|)
operator|/
literal|2
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_info_m88 - Retrieve PHY information  *  @hw: pointer to the HW structure  *  *  Valid for only copper links.  Read the PHY status register (sticky read)  *  to verify that link is up.  Read the PHY special control register to  *  determine the polarity and 10base-T extended distance.  Read the PHY  *  special status register to determine MDI/MDIx and current speed.  If  *  speed is 1000, then determine cable length, local and remote receiver.  **/
end_comment

begin_function
name|s32
name|e1000_get_phy_info_m88
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_info_m88"
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|media_type
operator|!=
name|e1000_media_type_copper
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Phy info is only valid for copper media\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Phy info is only valid if link is up\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_CTRL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy
operator|->
name|polarity_correction
operator|=
operator|!
operator|!
operator|(
name|phy_data
operator|&
name|M88E1000_PSCR_POLARITY_REVERSAL
operator|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_check_polarity_m88
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|M88E1000_PHY_SPEC_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy
operator|->
name|is_mdix
operator|=
operator|!
operator|!
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_MDIX
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|phy_data
operator|&
name|M88E1000_PSSR_SPEED
operator|)
operator|==
name|M88E1000_PSSR_1000MBS
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|get_cable_length
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy
operator|->
name|local_rx
operator|=
operator|(
name|phy_data
operator|&
name|SR_1000T_LOCAL_RX_STATUS
operator|)
condition|?
name|e1000_1000t_rx_status_ok
else|:
name|e1000_1000t_rx_status_not_ok
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
operator|(
name|phy_data
operator|&
name|SR_1000T_REMOTE_RX_STATUS
operator|)
condition|?
name|e1000_1000t_rx_status_ok
else|:
name|e1000_1000t_rx_status_not_ok
expr_stmt|;
block|}
else|else
block|{
comment|/* Set values to "undefined" */
name|phy
operator|->
name|cable_length
operator|=
name|E1000_CABLE_LENGTH_UNDEFINED
expr_stmt|;
name|phy
operator|->
name|local_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_info_igp - Retrieve igp PHY information  *  @hw: pointer to the HW structure  *  *  Read PHY status to determine if link is up.  If link is up, then  *  set/determine 10base-T extended distance and polarity correction.  Read  *  PHY port status to determine MDI/MDIx and speed.  Based on the speed,  *  determine on the cable length, local and remote receiver.  **/
end_comment

begin_function
name|s32
name|e1000_get_phy_info_igp
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_info_igp"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Phy info is only valid if link is up\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|phy
operator|->
name|polarity_correction
operator|=
name|TRUE
expr_stmt|;
name|ret_val
operator|=
name|e1000_check_polarity_igp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy
operator|->
name|is_mdix
operator|=
operator|!
operator|!
operator|(
name|data
operator|&
name|IGP01E1000_PSSR_MDIX
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|IGP01E1000_PSSR_SPEED_MASK
operator|)
operator|==
name|IGP01E1000_PSSR_SPEED_1000MBPS
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy
operator|->
name|local_rx
operator|=
operator|(
name|data
operator|&
name|SR_1000T_LOCAL_RX_STATUS
operator|)
condition|?
name|e1000_1000t_rx_status_ok
else|:
name|e1000_1000t_rx_status_not_ok
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
operator|(
name|data
operator|&
name|SR_1000T_REMOTE_RX_STATUS
operator|)
condition|?
name|e1000_1000t_rx_status_ok
else|:
name|e1000_1000t_rx_status_not_ok
expr_stmt|;
block|}
else|else
block|{
name|phy
operator|->
name|cable_length
operator|=
name|E1000_CABLE_LENGTH_UNDEFINED
expr_stmt|;
name|phy
operator|->
name|local_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_info_ife - Retrieves various IFE PHY states  *  @hw: pointer to the HW structure  *  *  Populates "phy" structure with various feature states.  **/
end_comment

begin_function
name|s32
name|e1000_get_phy_info_ife
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_info_ife"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Phy info is only valid if link is up\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_SPECIAL_CONTROL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy
operator|->
name|polarity_correction
operator|=
operator|!
operator|(
name|data
operator|&
name|IFE_PSC_AUTO_POLARITY_DISABLE
operator|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|polarity_correction
condition|)
block|{
name|ret_val
operator|=
name|e1000_check_polarity_ife
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
comment|/* Polarity is forced */
name|phy
operator|->
name|cable_polarity
operator|=
operator|(
operator|(
name|data
operator|&
name|IFE_PSC_FORCE_POLARITY
operator|)
condition|?
name|e1000_rev_polarity_reversed
else|:
name|e1000_rev_polarity_normal
operator|)
expr_stmt|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IFE_PHY_MDIX_CONTROL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy
operator|->
name|is_mdix
operator|=
operator|!
operator|!
operator|(
name|data
operator|&
name|IFE_PMC_MDIX_STATUS
operator|)
expr_stmt|;
comment|/* The following parameters are undefined for 10/100 operation. */
name|phy
operator|->
name|cable_length
operator|=
name|E1000_CABLE_LENGTH_UNDEFINED
expr_stmt|;
name|phy
operator|->
name|local_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_sw_reset_generic - PHY software reset  *  @hw: pointer to the HW structure  *  *  Does a software reset of the PHY by reading the PHY control register and  *  setting/write the control register reset bit to the PHY.  **/
end_comment

begin_function
name|s32
name|e1000_phy_sw_reset_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_sw_reset_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy_ctrl
operator||=
name|MII_CR_RESET
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_hw_reset_generic - PHY hardware reset  *  @hw: pointer to the HW structure  *  *  Verify the reset block is not blocking us from resetting.  Acquire  *  semaphore (if necessary) and read/set/write the device control reset  *  bit in the PHY.  Wait the appropriate delay time for the device to  *  reset and release the semaphore (if necessary).  **/
end_comment

begin_function
name|s32
name|e1000_phy_hw_reset_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_hw_reset_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|ops
operator|.
name|check_reset_block
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|check_reset_block
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|E1000_SUCCESS
return|;
block|}
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_PHY_RST
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|phy
operator|->
name|reset_delay_us
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|phy
operator|->
name|ops
operator|.
name|get_cfg_done
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cfg_done_generic - Generic configuration done  *  @hw: pointer to the HW structure  *  *  Generic function to wait 10 milli-seconds for configuration to complete  *  and return success.  **/
end_comment

begin_function
name|s32
name|e1000_get_cfg_done_generic
parameter_list|(
name|struct
name|e1000_hw
name|E1000_UNUSEDARG
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cfg_done_generic"
argument_list|)
expr_stmt|;
name|msec_delay_irq
argument_list|(
literal|10
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_init_script_igp3 - Inits the IGP3 PHY  *  @hw: pointer to the HW structure  *  *  Initializes a Intel Gigabit PHY3 when an EEPROM is not present.  **/
end_comment

begin_function
name|s32
name|e1000_phy_init_script_igp3
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Running IGP 3 PHY init script\n"
argument_list|)
expr_stmt|;
comment|/* PHY init IGP 3 */
comment|/* Enable rise/fall, 10-mode work in class-A */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F5B
argument_list|,
literal|0x9018
argument_list|)
expr_stmt|;
comment|/* Remove all caps from Replica path filter */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F52
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* Bias trimming for ADC, AFE and Driver (Default) */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x2FB1
argument_list|,
literal|0x8B24
argument_list|)
expr_stmt|;
comment|/* Increase Hybrid poly bias */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x2FB2
argument_list|,
literal|0xF8F0
argument_list|)
expr_stmt|;
comment|/* Add 4% to Tx amplitude in Gig mode */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x2010
argument_list|,
literal|0x10B0
argument_list|)
expr_stmt|;
comment|/* Disable trimming (TTT) */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x2011
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* Poly DC correction to 94.6% + 2% for all channels */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x20DD
argument_list|,
literal|0x249A
argument_list|)
expr_stmt|;
comment|/* ABS DC correction to 95.9% */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x20DE
argument_list|,
literal|0x00D3
argument_list|)
expr_stmt|;
comment|/* BG temp curve trim */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x28B4
argument_list|,
literal|0x04CE
argument_list|)
expr_stmt|;
comment|/* Increasing ADC OPAMP stage 1 currents to max */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x2F70
argument_list|,
literal|0x29E4
argument_list|)
expr_stmt|;
comment|/* Force 1000 ( required for enabling PHY regs configuration) */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
literal|0x0140
argument_list|)
expr_stmt|;
comment|/* Set upd_freq to 6 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F30
argument_list|,
literal|0x1606
argument_list|)
expr_stmt|;
comment|/* Disable NPDFE */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F31
argument_list|,
literal|0xB814
argument_list|)
expr_stmt|;
comment|/* Disable adaptive fixed FFE (Default) */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F35
argument_list|,
literal|0x002A
argument_list|)
expr_stmt|;
comment|/* Enable FFE hysteresis */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F3E
argument_list|,
literal|0x0067
argument_list|)
expr_stmt|;
comment|/* Fixed FFE for short cable lengths */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F54
argument_list|,
literal|0x0065
argument_list|)
expr_stmt|;
comment|/* Fixed FFE for medium cable lengths */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F55
argument_list|,
literal|0x002A
argument_list|)
expr_stmt|;
comment|/* Fixed FFE for long cable lengths */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F56
argument_list|,
literal|0x002A
argument_list|)
expr_stmt|;
comment|/* Enable Adaptive Clip Threshold */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F72
argument_list|,
literal|0x3FB0
argument_list|)
expr_stmt|;
comment|/* AHT reset limit to 1 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F76
argument_list|,
literal|0xC0FF
argument_list|)
expr_stmt|;
comment|/* Set AHT master delay to 127 msec */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F77
argument_list|,
literal|0x1DEC
argument_list|)
expr_stmt|;
comment|/* Set scan bits for AHT */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F78
argument_list|,
literal|0xF9EF
argument_list|)
expr_stmt|;
comment|/* Set AHT Preset bits */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1F79
argument_list|,
literal|0x0210
argument_list|)
expr_stmt|;
comment|/* Change integ_factor of channel A to 3 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1895
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
comment|/* Change prop_factor of channels BCD to 8 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1796
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
comment|/* Change cg_icount + enable integbp for channels BCD */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1798
argument_list|,
literal|0xD008
argument_list|)
expr_stmt|;
comment|/* Change cg_icount + enable integbp + change prop_factor_master 	 * to 8 for channel A 	 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1898
argument_list|,
literal|0xD918
argument_list|)
expr_stmt|;
comment|/* Disable AHT in Slave mode on channel A */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x187A
argument_list|,
literal|0x0800
argument_list|)
expr_stmt|;
comment|/* Enable LPLU and disable AN to 1000 in non-D0a states, 	 * Enable SPD+B2B 	 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x0019
argument_list|,
literal|0x008D
argument_list|)
expr_stmt|;
comment|/* Enable restart AN on an1000_dis change */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x001B
argument_list|,
literal|0x2080
argument_list|)
expr_stmt|;
comment|/* Enable wh_fifo read clock in 10/100 modes */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x0014
argument_list|,
literal|0x0045
argument_list|)
expr_stmt|;
comment|/* Restart AN, Speed selection is 1000 */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x0000
argument_list|,
literal|0x1340
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_type_from_id - Get PHY type from id  *  @phy_id: phy_id read from the phy  *  *  Returns the phy type from the id.  **/
end_comment

begin_function
name|enum
name|e1000_phy_type
name|e1000_get_phy_type_from_id
parameter_list|(
name|u32
name|phy_id
parameter_list|)
block|{
name|enum
name|e1000_phy_type
name|phy_type
init|=
name|e1000_phy_unknown
decl_stmt|;
switch|switch
condition|(
name|phy_id
condition|)
block|{
case|case
name|M88E1000_I_PHY_ID
case|:
case|case
name|M88E1000_E_PHY_ID
case|:
case|case
name|M88E1111_I_PHY_ID
case|:
case|case
name|M88E1011_I_PHY_ID
case|:
case|case
name|M88E1543_E_PHY_ID
case|:
case|case
name|M88E1512_E_PHY_ID
case|:
case|case
name|I347AT4_E_PHY_ID
case|:
case|case
name|M88E1112_E_PHY_ID
case|:
case|case
name|M88E1340M_E_PHY_ID
case|:
name|phy_type
operator|=
name|e1000_phy_m88
expr_stmt|;
break|break;
case|case
name|IGP01E1000_I_PHY_ID
case|:
comment|/* IGP 1& 2 share this */
name|phy_type
operator|=
name|e1000_phy_igp_2
expr_stmt|;
break|break;
case|case
name|GG82563_E_PHY_ID
case|:
name|phy_type
operator|=
name|e1000_phy_gg82563
expr_stmt|;
break|break;
case|case
name|IGP03E1000_E_PHY_ID
case|:
name|phy_type
operator|=
name|e1000_phy_igp_3
expr_stmt|;
break|break;
case|case
name|IFE_E_PHY_ID
case|:
case|case
name|IFE_PLUS_E_PHY_ID
case|:
case|case
name|IFE_C_E_PHY_ID
case|:
name|phy_type
operator|=
name|e1000_phy_ife
expr_stmt|;
break|break;
case|case
name|BME1000_E_PHY_ID
case|:
case|case
name|BME1000_E_PHY_ID_R2
case|:
name|phy_type
operator|=
name|e1000_phy_bm
expr_stmt|;
break|break;
case|case
name|I82578_E_PHY_ID
case|:
name|phy_type
operator|=
name|e1000_phy_82578
expr_stmt|;
break|break;
case|case
name|I82577_E_PHY_ID
case|:
name|phy_type
operator|=
name|e1000_phy_82577
expr_stmt|;
break|break;
case|case
name|I82579_E_PHY_ID
case|:
name|phy_type
operator|=
name|e1000_phy_82579
expr_stmt|;
break|break;
case|case
name|I217_E_PHY_ID
case|:
name|phy_type
operator|=
name|e1000_phy_i217
expr_stmt|;
break|break;
case|case
name|I82580_I_PHY_ID
case|:
name|phy_type
operator|=
name|e1000_phy_82580
expr_stmt|;
break|break;
case|case
name|I210_I_PHY_ID
case|:
name|phy_type
operator|=
name|e1000_phy_i210
expr_stmt|;
break|break;
default|default:
name|phy_type
operator|=
name|e1000_phy_unknown
expr_stmt|;
break|break;
block|}
return|return
name|phy_type
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_determine_phy_address - Determines PHY address.  *  @hw: pointer to the HW structure  *  *  This uses a trial and error method to loop through possible PHY  *  addresses. It tests each by reading the PHY ID registers and  *  checking for a match.  **/
end_comment

begin_function
name|s32
name|e1000_determine_phy_address
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|phy_addr
init|=
literal|0
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|enum
name|e1000_phy_type
name|phy_type
init|=
name|e1000_phy_unknown
decl_stmt|;
name|hw
operator|->
name|phy
operator|.
name|id
operator|=
name|phy_type
expr_stmt|;
for|for
control|(
name|phy_addr
operator|=
literal|0
init|;
name|phy_addr
operator|<
name|E1000_MAX_PHY_ADDR
condition|;
name|phy_addr
operator|++
control|)
block|{
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|phy_addr
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|phy_type
operator|=
name|e1000_get_phy_type_from_id
argument_list|(
name|hw
operator|->
name|phy
operator|.
name|id
argument_list|)
expr_stmt|;
comment|/* If phy_type is valid, break - we found our 			 * PHY address 			 */
if|if
condition|(
name|phy_type
operator|!=
name|e1000_phy_unknown
condition|)
return|return
name|E1000_SUCCESS
return|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
literal|10
condition|)
do|;
block|}
return|return
operator|-
name|E1000_ERR_PHY_TYPE
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_addr_for_bm_page - Retrieve PHY page address  *  @page: page to access  *  *  Returns the phy address for the page requested.  **/
end_comment

begin_function
specifier|static
name|u32
name|e1000_get_phy_addr_for_bm_page
parameter_list|(
name|u32
name|page
parameter_list|,
name|u32
name|reg
parameter_list|)
block|{
name|u32
name|phy_addr
init|=
literal|2
decl_stmt|;
if|if
condition|(
operator|(
name|page
operator|>=
literal|768
operator|)
operator|||
operator|(
name|page
operator|==
literal|0
operator|&&
name|reg
operator|==
literal|25
operator|)
operator|||
operator|(
name|reg
operator|==
literal|31
operator|)
condition|)
name|phy_addr
operator|=
literal|1
expr_stmt|;
return|return
name|phy_addr
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_bm - Write BM PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Acquires semaphore, if necessary, then writes the data to PHY register  *  at the offset.  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_bm
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u32
name|page
init|=
name|offset
operator|>>
name|IGP_PAGE_SHIFT
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_bm"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Page 800 works differently than the rest so it has its own func */
if|if
condition|(
name|page
operator|==
name|BM_WUC_PAGE
condition|)
block|{
name|ret_val
operator|=
name|e1000_access_phy_wakeup_reg_bm
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|data
argument_list|,
name|FALSE
argument_list|,
name|false
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|e1000_get_phy_addr_for_bm_page
argument_list|(
name|page
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
block|{
name|u32
name|page_shift
decl_stmt|,
name|page_select
decl_stmt|;
comment|/* Page select is register 31 for phy address 1 and 22 for 		 * phy address 2 and 3. Page select is shifted only for 		 * phy address 1. 		 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|==
literal|1
condition|)
block|{
name|page_shift
operator|=
name|IGP_PAGE_SHIFT
expr_stmt|;
name|page_select
operator|=
name|IGP01E1000_PHY_PAGE_SELECT
expr_stmt|;
block|}
else|else
block|{
name|page_shift
operator|=
literal|0
expr_stmt|;
name|page_select
operator|=
name|BM_PHY_PAGE_SELECT
expr_stmt|;
block|}
comment|/* Page is shifted left, PHY expects (page x 32) */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|page_select
argument_list|,
operator|(
name|page
operator|<<
name|page_shift
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_bm - Read BM PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Acquires semaphore, if necessary, then reads the PHY register at offset  *  and storing the retrieved information in data.  Release any acquired  *  semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_bm
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u32
name|page
init|=
name|offset
operator|>>
name|IGP_PAGE_SHIFT
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_bm"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Page 800 works differently than the rest so it has its own func */
if|if
condition|(
name|page
operator|==
name|BM_WUC_PAGE
condition|)
block|{
name|ret_val
operator|=
name|e1000_access_phy_wakeup_reg_bm
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|e1000_get_phy_addr_for_bm_page
argument_list|(
name|page
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
block|{
name|u32
name|page_shift
decl_stmt|,
name|page_select
decl_stmt|;
comment|/* Page select is register 31 for phy address 1 and 22 for 		 * phy address 2 and 3. Page select is shifted only for 		 * phy address 1. 		 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|==
literal|1
condition|)
block|{
name|page_shift
operator|=
name|IGP_PAGE_SHIFT
expr_stmt|;
name|page_select
operator|=
name|IGP01E1000_PHY_PAGE_SELECT
expr_stmt|;
block|}
else|else
block|{
name|page_shift
operator|=
literal|0
expr_stmt|;
name|page_select
operator|=
name|BM_PHY_PAGE_SELECT
expr_stmt|;
block|}
comment|/* Page is shifted left, PHY expects (page x 32) */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|page_select
argument_list|,
operator|(
name|page
operator|<<
name|page_shift
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_bm2 - Read BM PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Acquires semaphore, if necessary, then reads the PHY register at offset  *  and storing the retrieved information in data.  Release any acquired  *  semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_bm2
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|page
init|=
call|(
name|u16
call|)
argument_list|(
name|offset
operator|>>
name|IGP_PAGE_SHIFT
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_bm2"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Page 800 works differently than the rest so it has its own func */
if|if
condition|(
name|page
operator|==
name|BM_WUC_PAGE
condition|)
block|{
name|ret_val
operator|=
name|e1000_access_phy_wakeup_reg_bm
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
block|{
comment|/* Page is shifted left, PHY expects (page x 32) */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_PHY_PAGE_SELECT
argument_list|,
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_bm2 - Write BM PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Acquires semaphore, if necessary, then writes the data to PHY register  *  at the offset.  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_bm2
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|page
init|=
call|(
name|u16
call|)
argument_list|(
name|offset
operator|>>
name|IGP_PAGE_SHIFT
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_bm2"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Page 800 works differently than the rest so it has its own func */
if|if
condition|(
name|page
operator|==
name|BM_WUC_PAGE
condition|)
block|{
name|ret_val
operator|=
name|e1000_access_phy_wakeup_reg_bm
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|data
argument_list|,
name|FALSE
argument_list|,
name|false
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
block|{
comment|/* Page is shifted left, PHY expects (page x 32) */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_PHY_PAGE_SELECT
argument_list|,
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
block|}
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_enable_phy_wakeup_reg_access_bm - enable access to BM wakeup registers  *  @hw: pointer to the HW structure  *  @phy_reg: pointer to store original contents of BM_WUC_ENABLE_REG  *  *  Assumes semaphore already acquired and phy_reg points to a valid memory  *  address to store contents of the BM_WUC_ENABLE_REG register.  **/
end_comment

begin_function
name|s32
name|e1000_enable_phy_wakeup_reg_access_bm
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|phy_reg
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|temp
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_enable_phy_wakeup_reg_access_bm"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phy_reg
condition|)
return|return
operator|-
name|E1000_ERR_PARAM
return|;
comment|/* All page select, port ctrl and wakeup registers use phy address 1 */
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
literal|1
expr_stmt|;
comment|/* Select Port Control Registers page */
name|ret_val
operator|=
name|e1000_set_page_igp
argument_list|(
name|hw
argument_list|,
operator|(
name|BM_PORT_CTRL_PAGE
operator|<<
name|IGP_PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not set Port Control page\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_ENABLE_REG
argument_list|,
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"Could not read PHY register %d.%d\n"
argument_list|,
name|BM_PORT_CTRL_PAGE
argument_list|,
name|BM_WUC_ENABLE_REG
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Enable both PHY wakeup mode and Wakeup register page writes. 	 * Prevent a power state change by disabling ME and Host PHY wakeup. 	 */
name|temp
operator|=
operator|*
name|phy_reg
expr_stmt|;
name|temp
operator||=
name|BM_WUC_ENABLE_BIT
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|BM_WUC_ME_WU_BIT
operator||
name|BM_WUC_HOST_WU_BIT
operator|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_ENABLE_REG
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"Could not write PHY register %d.%d\n"
argument_list|,
name|BM_PORT_CTRL_PAGE
argument_list|,
name|BM_WUC_ENABLE_REG
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Select Host Wakeup Registers page - caller now able to write 	 * registers on the Wakeup registers page 	 */
return|return
name|e1000_set_page_igp
argument_list|(
name|hw
argument_list|,
operator|(
name|BM_WUC_PAGE
operator|<<
name|IGP_PAGE_SHIFT
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_disable_phy_wakeup_reg_access_bm - disable access to BM wakeup regs  *  @hw: pointer to the HW structure  *  @phy_reg: pointer to original contents of BM_WUC_ENABLE_REG  *  *  Restore BM_WUC_ENABLE_REG to its original value.  *  *  Assumes semaphore already acquired and *phy_reg is the contents of the  *  BM_WUC_ENABLE_REG before register(s) on BM_WUC_PAGE were accessed by  *  caller.  **/
end_comment

begin_function
name|s32
name|e1000_disable_phy_wakeup_reg_access_bm
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|phy_reg
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_disable_phy_wakeup_reg_access_bm"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phy_reg
condition|)
return|return
operator|-
name|E1000_ERR_PARAM
return|;
comment|/* Select Port Control Registers page */
name|ret_val
operator|=
name|e1000_set_page_igp
argument_list|(
name|hw
argument_list|,
operator|(
name|BM_PORT_CTRL_PAGE
operator|<<
name|IGP_PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not set Port Control page\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Restore 769.17 to its original value */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_ENABLE_REG
argument_list|,
operator|*
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT2
argument_list|(
literal|"Could not restore PHY register %d.%d\n"
argument_list|,
name|BM_PORT_CTRL_PAGE
argument_list|,
name|BM_WUC_ENABLE_REG
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_access_phy_wakeup_reg_bm - Read/write BM PHY wakeup register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read or written  *  @data: pointer to the data to read or write  *  @read: determines if operation is read or write  *  @page_set: BM_WUC_PAGE already set and access enabled  *  *  Read the PHY register at offset and store the retrieved information in  *  data, or write data to PHY register at offset.  Note the procedure to  *  access the PHY wakeup registers is different than reading the other PHY  *  registers. It works as such:  *  1) Set 769.17.2 (page 769, register 17, bit 2) = 1  *  2) Set page to 800 for host (801 if we were manageability)  *  3) Write the address using the address opcode (0x11)  *  4) Read or write the data using the data opcode (0x12)  *  5) Restore 769.17.2 to its original value  *  *  Steps 1 and 2 are done by e1000_enable_phy_wakeup_reg_access_bm() and  *  step 5 is done by e1000_disable_phy_wakeup_reg_access_bm().  *  *  Assumes semaphore is already acquired.  When page_set==TRUE, assumes  *  the PHY page is set to BM_WUC_PAGE (i.e. a function in the call stack  *  is responsible for calls to e1000_[enable|disable]_phy_wakeup_reg_bm()).  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_access_phy_wakeup_reg_bm
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|,
name|bool
name|read
parameter_list|,
name|bool
name|page_set
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|reg
init|=
name|BM_PHY_REG_NUM
argument_list|(
name|offset
argument_list|)
decl_stmt|;
name|u16
name|page
init|=
name|BM_PHY_REG_PAGE
argument_list|(
name|offset
argument_list|)
decl_stmt|;
name|u16
name|phy_reg
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_access_phy_wakeup_reg_bm"
argument_list|)
expr_stmt|;
comment|/* Gig must be disabled for MDIO accesses to Host Wakeup reg page */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_pchlan
operator|)
operator|&&
operator|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PHY_CTRL
argument_list|)
operator|&
name|E1000_PHY_CTRL_GBE_DISABLE
operator|)
operator|)
condition|)
name|DEBUGOUT1
argument_list|(
literal|"Attempting to access page %d while gig enabled.\n"
argument_list|,
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page_set
condition|)
block|{
comment|/* Enable access to PHY wakeup registers */
name|ret_val
operator|=
name|e1000_enable_phy_wakeup_reg_access_bm
argument_list|(
name|hw
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not enable PHY wakeup reg access\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
name|DEBUGOUT2
argument_list|(
literal|"Accessing PHY page %d reg 0x%x\n"
argument_list|,
name|page
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Write the Wakeup register page offset value using opcode 0x11 */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_ADDRESS_OPCODE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Could not write address opcode to page %d\n"
argument_list|,
name|page
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|read
condition|)
block|{
comment|/* Read the Wakeup register page value using opcode 0x12 */
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_DATA_OPCODE
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Write the Wakeup register page value using opcode 0x12 */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|BM_WUC_DATA_OPCODE
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"Could not access PHY reg %d.%d\n"
argument_list|,
name|page
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
operator|!
name|page_set
condition|)
name|ret_val
operator|=
name|e1000_disable_phy_wakeup_reg_access_bm
argument_list|(
name|hw
argument_list|,
operator|&
name|phy_reg
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  * e1000_power_up_phy_copper - Restore copper link in case of PHY power down  * @hw: pointer to the HW structure  *  * In the case of a PHY power down to save power, or to turn off link during a  * driver unload, or wake on lan is not enabled, restore the link to previous  * settings.  **/
end_comment

begin_function
name|void
name|e1000_power_up_phy_copper
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|mii_reg
init|=
literal|0
decl_stmt|;
comment|/* The PHY will retain its settings across a power down/up cycle */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|mii_reg
argument_list|)
expr_stmt|;
name|mii_reg
operator|&=
operator|~
name|MII_CR_POWER_DOWN
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|mii_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * e1000_power_down_phy_copper - Restore copper link in case of PHY power down  * @hw: pointer to the HW structure  *  * In the case of a PHY power down to save power, or to turn off link during a  * driver unload, or wake on lan is not enabled, restore the link to previous  * settings.  **/
end_comment

begin_function
name|void
name|e1000_power_down_phy_copper
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|mii_reg
init|=
literal|0
decl_stmt|;
comment|/* The PHY will retain its settings across a power down/up cycle */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|mii_reg
argument_list|)
expr_stmt|;
name|mii_reg
operator||=
name|MII_CR_POWER_DOWN
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|mii_reg
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  __e1000_read_phy_reg_hv -  Read HV PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  @locked: semaphore has already been acquired or not  *  *  Acquires semaphore, if necessary, then reads the PHY register at offset  *  and stores the retrieved information in data.  Release any acquired  *  semaphore before exiting.  **/
end_comment

begin_function
specifier|static
name|s32
name|__e1000_read_phy_reg_hv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|,
name|bool
name|locked
parameter_list|,
name|bool
name|page_set
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|page
init|=
name|BM_PHY_REG_PAGE
argument_list|(
name|offset
argument_list|)
decl_stmt|;
name|u16
name|reg
init|=
name|BM_PHY_REG_NUM
argument_list|(
name|offset
argument_list|)
decl_stmt|;
name|u32
name|phy_addr
init|=
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|e1000_get_phy_addr_for_hv_page
argument_list|(
name|page
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"__e1000_read_phy_reg_hv"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* Page 800 works differently than the rest so it has its own func */
if|if
condition|(
name|page
operator|==
name|BM_WUC_PAGE
condition|)
block|{
name|ret_val
operator|=
name|e1000_access_phy_wakeup_reg_bm
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|,
name|page_set
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|page
operator|>
literal|0
operator|&&
name|page
operator|<
name|HV_INTC_FC_PAGE_START
condition|)
block|{
name|ret_val
operator|=
name|e1000_access_phy_debug_regs_hv
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|page_set
condition|)
block|{
if|if
condition|(
name|page
operator|==
name|HV_INTC_FC_PAGE_START
condition|)
name|page
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
block|{
comment|/* Page is shifted left, PHY expects (page x 32) */
name|ret_val
operator|=
name|e1000_set_page_igp
argument_list|(
name|hw
argument_list|,
operator|(
name|page
operator|<<
name|IGP_PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|phy_addr
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|DEBUGOUT3
argument_list|(
literal|"reading PHY page %d (or 0x%x shifted) reg 0x%x\n"
argument_list|,
name|page
argument_list|,
name|page
operator|<<
name|IGP_PAGE_SHIFT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
operator|!
name|locked
condition|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_hv -  Read HV PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Acquires semaphore then reads the PHY register at offset and stores  *  the retrieved information in data.  Release the acquired semaphore  *  before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_hv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
return|return
name|__e1000_read_phy_reg_hv
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|FALSE
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_hv_locked -  Read HV PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Reads the PHY register at offset and stores the retrieved information  *  in data.  Assumes semaphore already acquired.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_hv_locked
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
return|return
name|__e1000_read_phy_reg_hv
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_page_hv - Read HV PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Reads the PHY register at offset and stores the retrieved information  *  in data.  Assumes semaphore already acquired and page already set.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_page_hv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
return|return
name|__e1000_read_phy_reg_hv
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  __e1000_write_phy_reg_hv - Write HV PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  @locked: semaphore has already been acquired or not  *  *  Acquires semaphore, if necessary, then writes the data to PHY register  *  at the offset.  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
specifier|static
name|s32
name|__e1000_write_phy_reg_hv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|,
name|bool
name|locked
parameter_list|,
name|bool
name|page_set
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|page
init|=
name|BM_PHY_REG_PAGE
argument_list|(
name|offset
argument_list|)
decl_stmt|;
name|u16
name|reg
init|=
name|BM_PHY_REG_NUM
argument_list|(
name|offset
argument_list|)
decl_stmt|;
name|u32
name|phy_addr
init|=
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|e1000_get_phy_addr_for_hv_page
argument_list|(
name|page
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"__e1000_write_phy_reg_hv"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* Page 800 works differently than the rest so it has its own func */
if|if
condition|(
name|page
operator|==
name|BM_WUC_PAGE
condition|)
block|{
name|ret_val
operator|=
name|e1000_access_phy_wakeup_reg_bm
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|data
argument_list|,
name|FALSE
argument_list|,
name|page_set
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|page
operator|>
literal|0
operator|&&
name|page
operator|<
name|HV_INTC_FC_PAGE_START
condition|)
block|{
name|ret_val
operator|=
name|e1000_access_phy_debug_regs_hv
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
operator|&
name|data
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|page_set
condition|)
block|{
if|if
condition|(
name|page
operator|==
name|HV_INTC_FC_PAGE_START
condition|)
name|page
operator|=
literal|0
expr_stmt|;
comment|/* Workaround MDIO accesses being disabled after entering IEEE 		 * Power Down (when bit 11 of the PHY Control register is set) 		 */
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82578
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|revision
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|addr
operator|==
literal|2
operator|)
operator|&&
operator|!
operator|(
name|MAX_PHY_REG_ADDRESS
operator|&
name|reg
operator|)
operator|&&
operator|(
name|data
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|)
condition|)
block|{
name|u16
name|data2
init|=
literal|0x7EFF
decl_stmt|;
name|ret_val
operator|=
name|e1000_access_phy_debug_regs_hv
argument_list|(
name|hw
argument_list|,
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
literal|0x3
argument_list|,
operator|&
name|data2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|reg
operator|>
name|MAX_PHY_MULTI_PAGE_REG
condition|)
block|{
comment|/* Page is shifted left, PHY expects (page x 32) */
name|ret_val
operator|=
name|e1000_set_page_igp
argument_list|(
name|hw
argument_list|,
operator|(
name|page
operator|<<
name|IGP_PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
name|phy_addr
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|DEBUGOUT3
argument_list|(
literal|"writing PHY page %d (or 0x%x shifted) reg 0x%x\n"
argument_list|,
name|page
argument_list|,
name|page
operator|<<
name|IGP_PAGE_SHIFT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|MAX_PHY_REG_ADDRESS
operator|&
name|reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
operator|!
name|locked
condition|)
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_hv - Write HV PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Acquires semaphore then writes the data to PHY register at the offset.  *  Release the acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_hv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
return|return
name|__e1000_write_phy_reg_hv
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|FALSE
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_hv_locked - Write HV PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Writes the data to PHY register at the offset.  Assumes semaphore  *  already acquired.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_hv_locked
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
return|return
name|__e1000_write_phy_reg_hv
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_page_hv - Write HV PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Writes the data to PHY register at the offset.  Assumes semaphore  *  already acquired and page already set.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_page_hv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
return|return
name|__e1000_write_phy_reg_hv
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_addr_for_hv_page - Get PHY adrress based on page  *  @page: page to be accessed  **/
end_comment

begin_function
specifier|static
name|u32
name|e1000_get_phy_addr_for_hv_page
parameter_list|(
name|u32
name|page
parameter_list|)
block|{
name|u32
name|phy_addr
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|page
operator|>=
name|HV_INTC_FC_PAGE_START
condition|)
name|phy_addr
operator|=
literal|1
expr_stmt|;
return|return
name|phy_addr
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_access_phy_debug_regs_hv - Read HV PHY vendor specific high registers  *  @hw: pointer to the HW structure  *  @offset: register offset to be read or written  *  @data: pointer to the data to be read or written  *  @read: determines if operation is read or write  *  *  Reads the PHY register at offset and stores the retreived information  *  in data.  Assumes semaphore already acquired.  Note that the procedure  *  to access these regs uses the address port and data port to read/write.  *  These accesses done with PHY address 2 and without using pages.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_access_phy_debug_regs_hv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|,
name|bool
name|read
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u32
name|addr_reg
decl_stmt|;
name|u32
name|data_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_access_phy_debug_regs_hv"
argument_list|)
expr_stmt|;
comment|/* This takes care of the difference with desktop vs mobile phy */
name|addr_reg
operator|=
operator|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_82578
operator|)
condition|?
name|I82578_ADDR_REG
else|:
name|I82577_ADDR_REG
operator|)
expr_stmt|;
name|data_reg
operator|=
name|addr_reg
operator|+
literal|1
expr_stmt|;
comment|/* All operations in this function are phy address 2 */
name|hw
operator|->
name|phy
operator|.
name|addr
operator|=
literal|2
expr_stmt|;
comment|/* masking with 0x3F to remove the page from offset */
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|addr_reg
argument_list|,
operator|(
name|u16
operator|)
name|offset
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Could not write the Address Offset port register\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Read or write the data value next */
if|if
condition|(
name|read
condition|)
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|data_reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|data_reg
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT
argument_list|(
literal|"Could not access the Data port register\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_link_stall_workaround_hv - Si workaround  *  @hw: pointer to the HW structure  *  *  This function works around a Si bug where the link partner can get  *  a link up indication before the PHY does.  If small packets are sent  *  by the link partner they can be placed in the packet buffer without  *  being properly accounted for by the PHY and will stall preventing  *  further packets from being received.  The workaround is to clear the  *  packet buffer after the PHY detects link up.  **/
end_comment

begin_function
name|s32
name|e1000_link_stall_workaround_hv
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_link_stall_workaround_hv"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|!=
name|e1000_phy_82578
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Do not apply workaround if in PHY loopback bit 14 set */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|PHY_CONTROL_LB
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* check if link is up and at 1Gbps */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|BM_CS_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|(
name|BM_CS_STATUS_LINK_UP
operator||
name|BM_CS_STATUS_RESOLVED
operator||
name|BM_CS_STATUS_SPEED_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
operator|(
name|BM_CS_STATUS_LINK_UP
operator||
name|BM_CS_STATUS_RESOLVED
operator||
name|BM_CS_STATUS_SPEED_1000
operator|)
condition|)
return|return
name|E1000_SUCCESS
return|;
name|msec_delay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* flush the packets in the fifo buffer */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|HV_MUX_DATA_CTRL
argument_list|,
operator|(
name|HV_MUX_DATA_CTRL_GEN_TO_MAC
operator||
name|HV_MUX_DATA_CTRL_FORCE_SPEED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
return|return
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|HV_MUX_DATA_CTRL
argument_list|,
name|HV_MUX_DATA_CTRL_GEN_TO_MAC
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_polarity_82577 - Checks the polarity.  *  @hw: pointer to the HW structure  *  *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)  *  *  Polarity is determined based on the PHY specific status register.  **/
end_comment

begin_function
name|s32
name|e1000_check_polarity_82577
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_polarity_82577"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|I82577_PHY_STATUS_2
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|phy
operator|->
name|cable_polarity
operator|=
operator|(
operator|(
name|data
operator|&
name|I82577_PHY_STATUS2_REV_POLARITY
operator|)
condition|?
name|e1000_rev_polarity_reversed
else|:
name|e1000_rev_polarity_normal
operator|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_force_speed_duplex_82577 - Force speed/duplex for I82577 PHY  *  @hw: pointer to the HW structure  *  *  Calls the PHY setup function to force speed and duplex.  **/
end_comment

begin_function
name|s32
name|e1000_phy_force_speed_duplex_82577
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_force_speed_duplex_82577"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|e1000_phy_force_speed_duplex_setup
argument_list|(
name|hw
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|PHY_CONTROL
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|autoneg_wait_to_complete
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Waiting for forced speed/duplex link on 82577 phy\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
name|link
condition|)
name|DEBUGOUT
argument_list|(
literal|"Link taking longer than expected.\n"
argument_list|)
expr_stmt|;
comment|/* Try once more */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
name|PHY_FORCE_LIMIT
argument_list|,
literal|100000
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_info_82577 - Retrieve I82577 PHY information  *  @hw: pointer to the HW structure  *  *  Read PHY status to determine if link is up.  If link is up, then  *  set/determine 10base-T extended distance and polarity correction.  Read  *  PHY port status to determine MDI/MDIx and speed.  Based on the speed,  *  determine on the cable length, local and remote receiver.  **/
end_comment

begin_function
name|s32
name|e1000_get_phy_info_82577
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_info_82577"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Phy info is only valid if link is up\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|phy
operator|->
name|polarity_correction
operator|=
name|TRUE
expr_stmt|;
name|ret_val
operator|=
name|e1000_check_polarity_82577
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|I82577_PHY_STATUS_2
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy
operator|->
name|is_mdix
operator|=
operator|!
operator|!
operator|(
name|data
operator|&
name|I82577_PHY_STATUS2_MDIX
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|I82577_PHY_STATUS2_SPEED_MASK
operator|)
operator|==
name|I82577_PHY_STATUS2_SPEED_1000MBPS
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|get_cable_length
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_1000T_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy
operator|->
name|local_rx
operator|=
operator|(
name|data
operator|&
name|SR_1000T_LOCAL_RX_STATUS
operator|)
condition|?
name|e1000_1000t_rx_status_ok
else|:
name|e1000_1000t_rx_status_not_ok
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
operator|(
name|data
operator|&
name|SR_1000T_REMOTE_RX_STATUS
operator|)
condition|?
name|e1000_1000t_rx_status_ok
else|:
name|e1000_1000t_rx_status_not_ok
expr_stmt|;
block|}
else|else
block|{
name|phy
operator|->
name|cable_length
operator|=
name|E1000_CABLE_LENGTH_UNDEFINED
expr_stmt|;
name|phy
operator|->
name|local_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
name|phy
operator|->
name|remote_rx
operator|=
name|e1000_1000t_rx_status_undefined
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cable_length_82577 - Determine cable length for 82577 PHY  *  @hw: pointer to the HW structure  *  * Reads the diagnostic status register and verifies result is valid before  * placing it in the phy_cable_length field.  **/
end_comment

begin_function
name|s32
name|e1000_get_cable_length_82577
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_data
decl_stmt|,
name|length
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cable_length_82577"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|I82577_PHY_DIAG_STATUS
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|length
operator|=
operator|(
operator|(
name|phy_data
operator|&
name|I82577_DSTATUS_CABLE_LENGTH
operator|)
operator|>>
name|I82577_DSTATUS_CABLE_LENGTH_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
name|E1000_CABLE_LENGTH_UNDEFINED
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
name|phy
operator|->
name|cable_length
operator|=
name|length
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_gs40g - Write GS40G  PHY register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Acquires semaphore, if necessary, then writes the data to PHY register  *  at the offset.  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_gs40g
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|page
init|=
name|offset
operator|>>
name|GS40G_PAGE_SHIFT
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_gs40g"
argument_list|)
expr_stmt|;
name|offset
operator|=
name|offset
operator|&
name|GS40G_OFFSET_MASK
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|GS40G_PAGE_SELECT
argument_list|,
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_gs40g - Read GS40G  PHY register  *  @hw: pointer to the HW structure  *  @offset: lower half is register offset to read to  *     upper half is page to use.  *  @data: data to read at register offset  *  *  Acquires semaphore, if necessary, then reads the data in the PHY register  *  at the offset.  Release any acquired semaphores before exiting.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_gs40g
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|page
init|=
name|offset
operator|>>
name|GS40G_PAGE_SHIFT
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_gs40g"
argument_list|)
expr_stmt|;
name|offset
operator|=
name|offset
operator|&
name|GS40G_OFFSET_MASK
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|GS40G_PAGE_SELECT
argument_list|,
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|release
label|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_mphy - Read mPHY control register  *  @hw: pointer to the HW structure  *  @address: address to be read  *  @data: pointer to the read data  *  *  Reads the mPHY control register in the PHY at offset and stores the  *  information read to data.  **/
end_comment

begin_function
name|s32
name|e1000_read_phy_reg_mphy
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|address
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|mphy_ctrl
init|=
literal|0
decl_stmt|;
name|bool
name|locked
init|=
name|FALSE
decl_stmt|;
name|bool
name|ready
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_mphy"
argument_list|)
expr_stmt|;
comment|/* Check if mPHY is ready to read/write operations */
name|ready
operator|=
name|e1000_is_mphy_ready
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ready
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
comment|/* Check if mPHY access is disabled and enable it if so */
name|mphy_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPHY_ADDR_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mphy_ctrl
operator|&
name|E1000_MPHY_DIS_ACCESS
condition|)
block|{
name|locked
operator|=
name|TRUE
expr_stmt|;
name|ready
operator|=
name|e1000_is_mphy_ready
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ready
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
name|mphy_ctrl
operator||=
name|E1000_MPHY_ENA_ACCESS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPHY_ADDR_CTRL
argument_list|,
name|mphy_ctrl
argument_list|)
expr_stmt|;
block|}
comment|/* Set the address that we want to read */
name|ready
operator|=
name|e1000_is_mphy_ready
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ready
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
comment|/* We mask address, because we want to use only current lane */
name|mphy_ctrl
operator|=
operator|(
name|mphy_ctrl
operator|&
operator|~
name|E1000_MPHY_ADDRESS_MASK
operator|&
operator|~
name|E1000_MPHY_ADDRESS_FNC_OVERRIDE
operator|)
operator||
operator|(
name|address
operator|&
name|E1000_MPHY_ADDRESS_MASK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPHY_ADDR_CTRL
argument_list|,
name|mphy_ctrl
argument_list|)
expr_stmt|;
comment|/* Read data from the address */
name|ready
operator|=
name|e1000_is_mphy_ready
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ready
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
operator|*
name|data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPHY_DATA
argument_list|)
expr_stmt|;
comment|/* Disable access to mPHY if it was originally disabled */
if|if
condition|(
name|locked
condition|)
block|{
name|ready
operator|=
name|e1000_is_mphy_ready
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ready
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPHY_ADDR_CTRL
argument_list|,
name|E1000_MPHY_DIS_ACCESS
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_mphy - Write mPHY control register  *  @hw: pointer to the HW structure  *  @address: address to write to  *  @data: data to write to register at offset  *  @line_override: used when we want to use different line than default one  *  *  Writes data to mPHY control register.  **/
end_comment

begin_function
name|s32
name|e1000_write_phy_reg_mphy
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|address
parameter_list|,
name|u32
name|data
parameter_list|,
name|bool
name|line_override
parameter_list|)
block|{
name|u32
name|mphy_ctrl
init|=
literal|0
decl_stmt|;
name|bool
name|locked
init|=
name|FALSE
decl_stmt|;
name|bool
name|ready
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_mphy"
argument_list|)
expr_stmt|;
comment|/* Check if mPHY is ready to read/write operations */
name|ready
operator|=
name|e1000_is_mphy_ready
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ready
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
comment|/* Check if mPHY access is disabled and enable it if so */
name|mphy_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPHY_ADDR_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mphy_ctrl
operator|&
name|E1000_MPHY_DIS_ACCESS
condition|)
block|{
name|locked
operator|=
name|TRUE
expr_stmt|;
name|ready
operator|=
name|e1000_is_mphy_ready
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ready
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
name|mphy_ctrl
operator||=
name|E1000_MPHY_ENA_ACCESS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPHY_ADDR_CTRL
argument_list|,
name|mphy_ctrl
argument_list|)
expr_stmt|;
block|}
comment|/* Set the address that we want to read */
name|ready
operator|=
name|e1000_is_mphy_ready
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ready
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
comment|/* We mask address, because we want to use only current lane */
if|if
condition|(
name|line_override
condition|)
name|mphy_ctrl
operator||=
name|E1000_MPHY_ADDRESS_FNC_OVERRIDE
expr_stmt|;
else|else
name|mphy_ctrl
operator|&=
operator|~
name|E1000_MPHY_ADDRESS_FNC_OVERRIDE
expr_stmt|;
name|mphy_ctrl
operator|=
operator|(
name|mphy_ctrl
operator|&
operator|~
name|E1000_MPHY_ADDRESS_MASK
operator|)
operator||
operator|(
name|address
operator|&
name|E1000_MPHY_ADDRESS_MASK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPHY_ADDR_CTRL
argument_list|,
name|mphy_ctrl
argument_list|)
expr_stmt|;
comment|/* Read data from the address */
name|ready
operator|=
name|e1000_is_mphy_ready
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ready
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPHY_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Disable access to mPHY if it was originally disabled */
if|if
condition|(
name|locked
condition|)
block|{
name|ready
operator|=
name|e1000_is_mphy_ready
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ready
condition|)
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPHY_ADDR_CTRL
argument_list|,
name|E1000_MPHY_DIS_ACCESS
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_is_mphy_ready - Check if mPHY control register is not busy  *  @hw: pointer to the HW structure  *  *  Returns mPHY control register status.  **/
end_comment

begin_function
name|bool
name|e1000_is_mphy_ready
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|retry_count
init|=
literal|0
decl_stmt|;
name|u32
name|mphy_ctrl
init|=
literal|0
decl_stmt|;
name|bool
name|ready
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
name|retry_count
operator|<
literal|2
condition|)
block|{
name|mphy_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPHY_ADDR_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mphy_ctrl
operator|&
name|E1000_MPHY_BUSY
condition|)
block|{
name|usec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|retry_count
operator|++
expr_stmt|;
continue|continue;
block|}
name|ready
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ready
condition|)
name|DEBUGOUT
argument_list|(
literal|"ERROR READING mPHY control register, phy is busy.\n"
argument_list|)
expr_stmt|;
return|return
name|ready
return|;
block|}
end_function

end_unit

