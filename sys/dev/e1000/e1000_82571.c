begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2013, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_comment
comment|/* 82571EB Gigabit Ethernet Controller  * 82571EB Gigabit Ethernet Controller (Copper)  * 82571EB Gigabit Ethernet Controller (Fiber)  * 82571EB Dual Port Gigabit Mezzanine Adapter  * 82571EB Quad Port Gigabit Mezzanine Adapter  * 82571PT Gigabit PT Quad Port Server ExpressModule  * 82572EI Gigabit Ethernet Controller (Copper)  * 82572EI Gigabit Ethernet Controller (Fiber)  * 82572EI Gigabit Ethernet Controller  * 82573V Gigabit Ethernet Controller (Copper)  * 82573E Gigabit Ethernet Controller (Copper)  * 82573L Gigabit Ethernet Controller  * 82574L Gigabit Network Connection  * 82583V Gigabit Network Connection  */
end_comment

begin_include
include|#
directive|include
file|"e1000_api.h"
end_include

begin_function_decl
specifier|static
name|s32
name|e1000_acquire_nvm_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_release_nvm_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_write_nvm_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_update_nvm_checksum_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_validate_nvm_checksum_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_cfg_done_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_set_d0_lplu_state_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_reset_hw_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_init_hw_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_clear_vfta_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|e1000_check_mng_mode_82574
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_led_on_82574
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_setup_link_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_setup_copper_link_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_check_for_serdes_link_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_setup_fiber_serdes_link_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_valid_led_default_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_clear_hw_cntrs_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_hw_semaphore_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_fix_nvm_checksum_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_phy_id_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_put_hw_semaphore_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_put_hw_semaphore_82573
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_hw_semaphore_82574
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_put_hw_semaphore_82574
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_set_d0_lplu_state_82574
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_set_d3_lplu_state_82574
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_initialize_hw_bits_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_write_nvm_eewr_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_read_mac_addr_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_power_down_phy_copper_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  e1000_init_phy_params_82571 - Init PHY func ptrs.  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_phy_params_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_phy_params_82571"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|e1000_media_type_copper
condition|)
block|{
name|phy
operator|->
name|type
operator|=
name|e1000_phy_none
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
name|phy
operator|->
name|addr
operator|=
literal|1
expr_stmt|;
name|phy
operator|->
name|autoneg_mask
operator|=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
name|phy
operator|->
name|reset_delay_us
operator|=
literal|100
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_reset_block
operator|=
name|e1000_check_reset_block_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|e1000_phy_hw_reset_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d0_lplu_state
operator|=
name|e1000_set_d0_lplu_state_82571
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d3_lplu_state
operator|=
name|e1000_set_d3_lplu_state_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|power_up
operator|=
name|e1000_power_up_phy_copper
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|power_down
operator|=
name|e1000_power_down_phy_copper_82571
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
name|phy
operator|->
name|type
operator|=
name|e1000_phy_igp_2
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cfg_done
operator|=
name|e1000_get_cfg_done_82571
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_info
operator|=
name|e1000_get_phy_info_igp
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_polarity
operator|=
name|e1000_check_polarity_igp
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_igp
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
operator|=
name|e1000_get_cable_length_igp_2
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|e1000_read_phy_reg_igp
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|e1000_write_phy_reg_igp
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|acquire
operator|=
name|e1000_get_hw_semaphore_82571
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|release
operator|=
name|e1000_put_hw_semaphore_82571
expr_stmt|;
break|break;
case|case
name|e1000_82573
case|:
name|phy
operator|->
name|type
operator|=
name|e1000_phy_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cfg_done
operator|=
name|e1000_get_cfg_done_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_info
operator|=
name|e1000_get_phy_info_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_polarity
operator|=
name|e1000_check_polarity_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|commit
operator|=
name|e1000_phy_sw_reset_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
operator|=
name|e1000_get_cable_length_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|e1000_read_phy_reg_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|e1000_write_phy_reg_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|acquire
operator|=
name|e1000_get_hw_semaphore_82571
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|release
operator|=
name|e1000_put_hw_semaphore_82571
expr_stmt|;
break|break;
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|E1000_MUTEX_INIT
argument_list|(
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|_82571
operator|.
name|swflag_mutex
argument_list|)
expr_stmt|;
name|phy
operator|->
name|type
operator|=
name|e1000_phy_bm
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cfg_done
operator|=
name|e1000_get_cfg_done_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_info
operator|=
name|e1000_get_phy_info_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_polarity
operator|=
name|e1000_check_polarity_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|commit
operator|=
name|e1000_phy_sw_reset_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
operator|=
name|e1000_get_cable_length_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|e1000_read_phy_reg_bm2
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|e1000_write_phy_reg_bm2
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|acquire
operator|=
name|e1000_get_hw_semaphore_82574
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|release
operator|=
name|e1000_put_hw_semaphore_82574
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d0_lplu_state
operator|=
name|e1000_set_d0_lplu_state_82574
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d3_lplu_state
operator|=
name|e1000_set_d3_lplu_state_82574
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|E1000_ERR_PHY
return|;
break|break;
block|}
comment|/* This can only be done after all function pointers are setup. */
name|ret_val
operator|=
name|e1000_get_phy_id_82571
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error getting PHY ID\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* Verify phy id */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
if|if
condition|(
name|phy
operator|->
name|id
operator|!=
name|IGP01E1000_I_PHY_ID
condition|)
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
break|break;
case|case
name|e1000_82573
case|:
if|if
condition|(
name|phy
operator|->
name|id
operator|!=
name|M88E1111_I_PHY_ID
condition|)
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
break|break;
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
if|if
condition|(
name|phy
operator|->
name|id
operator|!=
name|BME1000_E_PHY_ID_R2
condition|)
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
break|break;
default|default:
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT1
argument_list|(
literal|"PHY ID unknown: type = 0x%08x\n"
argument_list|,
name|phy
operator|->
name|id
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_nvm_params_82571 - Init NVM func ptrs.  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_nvm_params_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|u32
name|eecd
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_nvm_params_82571"
argument_list|)
expr_stmt|;
name|nvm
operator|->
name|opcode_bits
operator|=
literal|8
expr_stmt|;
name|nvm
operator|->
name|delay_usec
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|nvm
operator|->
name|override
condition|)
block|{
case|case
name|e1000_nvm_override_spi_large
case|:
name|nvm
operator|->
name|page_size
operator|=
literal|32
expr_stmt|;
name|nvm
operator|->
name|address_bits
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|e1000_nvm_override_spi_small
case|:
name|nvm
operator|->
name|page_size
operator|=
literal|8
expr_stmt|;
name|nvm
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|nvm
operator|->
name|page_size
operator|=
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|?
literal|32
else|:
literal|8
expr_stmt|;
name|nvm
operator|->
name|address_bits
operator|=
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|?
literal|16
else|:
literal|8
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
if|if
condition|(
operator|(
operator|(
name|eecd
operator|>>
literal|15
operator|)
operator|&
literal|0x3
operator|)
operator|==
literal|0x3
condition|)
block|{
name|nvm
operator|->
name|type
operator|=
name|e1000_nvm_flash_hw
expr_stmt|;
name|nvm
operator|->
name|word_size
operator|=
literal|2048
expr_stmt|;
comment|/* Autonomous Flash update bit must be cleared due 			 * to Flash update issue. 			 */
name|eecd
operator|&=
operator|~
name|E1000_EECD_AUPDEN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall Through */
default|default:
name|nvm
operator|->
name|type
operator|=
name|e1000_nvm_eeprom_spi
expr_stmt|;
name|size
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|eecd
operator|&
name|E1000_EECD_SIZE_EX_MASK
operator|)
operator|>>
name|E1000_EECD_SIZE_EX_SHIFT
argument_list|)
expr_stmt|;
comment|/* Added to a constant, "size" becomes the left-shift value 		 * for setting word_size. 		 */
name|size
operator|+=
name|NVM_WORD_SIZE_BASE_SHIFT
expr_stmt|;
comment|/* EEPROM access above 16k is unsupported */
if|if
condition|(
name|size
operator|>
literal|14
condition|)
name|size
operator|=
literal|14
expr_stmt|;
name|nvm
operator|->
name|word_size
operator|=
literal|1
operator|<<
name|size
expr_stmt|;
break|break;
block|}
comment|/* Function Pointers */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|nvm
operator|->
name|ops
operator|.
name|acquire
operator|=
name|e1000_get_hw_semaphore_82574
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|release
operator|=
name|e1000_put_hw_semaphore_82574
expr_stmt|;
break|break;
default|default:
name|nvm
operator|->
name|ops
operator|.
name|acquire
operator|=
name|e1000_acquire_nvm_82571
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|release
operator|=
name|e1000_release_nvm_82571
expr_stmt|;
break|break;
block|}
name|nvm
operator|->
name|ops
operator|.
name|read
operator|=
name|e1000_read_nvm_eerd
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|update
operator|=
name|e1000_update_nvm_checksum_82571
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|validate
operator|=
name|e1000_validate_nvm_checksum_82571
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|valid_led_default
operator|=
name|e1000_valid_led_default_82571
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|write
operator|=
name|e1000_write_nvm_82571
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_mac_params_82571 - Init MAC func ptrs.  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_mac_params_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|swsm
init|=
literal|0
decl_stmt|;
name|u32
name|swsm2
init|=
literal|0
decl_stmt|;
name|bool
name|force_clear_smbi
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_mac_params_82571"
argument_list|)
expr_stmt|;
comment|/* Set media type and media-dependent function pointers */
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_82571EB_FIBER
case|:
case|case
name|E1000_DEV_ID_82572EI_FIBER
case|:
case|case
name|E1000_DEV_ID_82571EB_QUAD_FIBER
case|:
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_fiber
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_physical_interface
operator|=
name|e1000_setup_fiber_serdes_link_82571
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_for_link
operator|=
name|e1000_check_for_fiber_link_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_link_up_info
operator|=
name|e1000_get_speed_and_duplex_fiber_serdes_generic
expr_stmt|;
break|break;
case|case
name|E1000_DEV_ID_82571EB_SERDES
case|:
case|case
name|E1000_DEV_ID_82571EB_SERDES_DUAL
case|:
case|case
name|E1000_DEV_ID_82571EB_SERDES_QUAD
case|:
case|case
name|E1000_DEV_ID_82572EI_SERDES
case|:
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_internal_serdes
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_physical_interface
operator|=
name|e1000_setup_fiber_serdes_link_82571
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_for_link
operator|=
name|e1000_check_for_serdes_link_82571
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_link_up_info
operator|=
name|e1000_get_speed_and_duplex_fiber_serdes_generic
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_copper
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_physical_interface
operator|=
name|e1000_setup_copper_link_82571
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_for_link
operator|=
name|e1000_check_for_copper_link_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_link_up_info
operator|=
name|e1000_get_speed_and_duplex_copper_generic
expr_stmt|;
break|break;
block|}
comment|/* Set mta register count */
name|mac
operator|->
name|mta_reg_count
operator|=
literal|128
expr_stmt|;
comment|/* Set rar entry count */
name|mac
operator|->
name|rar_entry_count
operator|=
name|E1000_RAR_ENTRIES
expr_stmt|;
comment|/* Set if part includes ASF firmware */
name|mac
operator|->
name|asf_firmware_present
operator|=
name|TRUE
expr_stmt|;
comment|/* Adaptive IFS supported */
name|mac
operator|->
name|adaptive_ifs
operator|=
name|TRUE
expr_stmt|;
comment|/* Function pointers */
comment|/* bus type/speed/width */
name|mac
operator|->
name|ops
operator|.
name|get_bus_info
operator|=
name|e1000_get_bus_info_pcie_generic
expr_stmt|;
comment|/* reset */
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
name|e1000_reset_hw_82571
expr_stmt|;
comment|/* hw initialization */
name|mac
operator|->
name|ops
operator|.
name|init_hw
operator|=
name|e1000_init_hw_82571
expr_stmt|;
comment|/* link setup */
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|e1000_setup_link_82571
expr_stmt|;
comment|/* multicast address update */
name|mac
operator|->
name|ops
operator|.
name|update_mc_addr_list
operator|=
name|e1000_update_mc_addr_list_generic
expr_stmt|;
comment|/* writing VFTA */
name|mac
operator|->
name|ops
operator|.
name|write_vfta
operator|=
name|e1000_write_vfta_generic
expr_stmt|;
comment|/* clearing VFTA */
name|mac
operator|->
name|ops
operator|.
name|clear_vfta
operator|=
name|e1000_clear_vfta_82571
expr_stmt|;
comment|/* read mac address */
name|mac
operator|->
name|ops
operator|.
name|read_mac_addr
operator|=
name|e1000_read_mac_addr_82571
expr_stmt|;
comment|/* ID LED init */
name|mac
operator|->
name|ops
operator|.
name|id_led_init
operator|=
name|e1000_id_led_init_generic
expr_stmt|;
comment|/* setup LED */
name|mac
operator|->
name|ops
operator|.
name|setup_led
operator|=
name|e1000_setup_led_generic
expr_stmt|;
comment|/* cleanup LED */
name|mac
operator|->
name|ops
operator|.
name|cleanup_led
operator|=
name|e1000_cleanup_led_generic
expr_stmt|;
comment|/* turn off LED */
name|mac
operator|->
name|ops
operator|.
name|led_off
operator|=
name|e1000_led_off_generic
expr_stmt|;
comment|/* clear hardware counters */
name|mac
operator|->
name|ops
operator|.
name|clear_hw_cntrs
operator|=
name|e1000_clear_hw_cntrs_82571
expr_stmt|;
comment|/* MAC-specific function pointers */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
name|mac
operator|->
name|ops
operator|.
name|set_lan_id
operator|=
name|e1000_set_lan_id_single_port
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_mng_mode
operator|=
name|e1000_check_mng_mode_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|led_on
operator|=
name|e1000_led_on_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|blink_led
operator|=
name|e1000_blink_led_generic
expr_stmt|;
comment|/* FWSM register */
name|mac
operator|->
name|has_fwsm
operator|=
name|TRUE
expr_stmt|;
comment|/* ARC supported; valid only if manageability features are 		 * enabled. 		 */
name|mac
operator|->
name|arc_subsystem_valid
operator|=
operator|!
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|mac
operator|->
name|ops
operator|.
name|set_lan_id
operator|=
name|e1000_set_lan_id_single_port
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_mng_mode
operator|=
name|e1000_check_mng_mode_82574
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|led_on
operator|=
name|e1000_led_on_82574
expr_stmt|;
break|break;
default|default:
name|mac
operator|->
name|ops
operator|.
name|check_mng_mode
operator|=
name|e1000_check_mng_mode_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|led_on
operator|=
name|e1000_led_on_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|blink_led
operator|=
name|e1000_blink_led_generic
expr_stmt|;
comment|/* FWSM register */
name|mac
operator|->
name|has_fwsm
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Ensure that the inter-port SWSM.SMBI lock bit is clear before 	 * first NVM or PHY acess. This should be done for single-port 	 * devices, and for one port only on dual-port devices so that 	 * for those devices we can still use the SMBI lock to synchronize 	 * inter-port accesses to the PHY& NVM. 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
name|swsm2
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swsm2
operator|&
name|E1000_SWSM2_LOCK
operator|)
condition|)
block|{
comment|/* Only do this for the first interface on this card */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM2
argument_list|,
name|swsm2
operator||
name|E1000_SWSM2_LOCK
argument_list|)
expr_stmt|;
name|force_clear_smbi
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|force_clear_smbi
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
default|default:
name|force_clear_smbi
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|force_clear_smbi
condition|)
block|{
comment|/* Make sure SWSM.SMBI is clear */
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
if|if
condition|(
name|swsm
operator|&
name|E1000_SWSM_SMBI
condition|)
block|{
comment|/* This bit should not be set on a first interface, and 			 * indicates that the bootagent or EFI code has 			 * improperly left this bit enabled 			 */
name|DEBUGOUT
argument_list|(
literal|"Please update your 82571 Bootagent\n"
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|,
name|swsm
operator|&
operator|~
name|E1000_SWSM_SMBI
argument_list|)
expr_stmt|;
block|}
comment|/* Initialze device specific counter of SMBI acquisition timeouts. */
name|hw
operator|->
name|dev_spec
operator|.
name|_82571
operator|.
name|smb_counter
operator|=
literal|0
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_function_pointers_82571 - Init func ptrs.  *  @hw: pointer to the HW structure  *  *  Called to initialize all function pointers and parameters.  **/
end_comment

begin_function
name|void
name|e1000_init_function_pointers_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_function_pointers_82571"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_mac_params_82571
expr_stmt|;
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_nvm_params_82571
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_phy_params_82571
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_id_82571 - Retrieve the PHY ID and revision  *  @hw: pointer to the HW structure  *  *  Reads the PHY registers and stores the PHY ID and possibly the PHY  *  revision in the hardware structure.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_phy_id_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|phy_id
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_id_82571"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
comment|/* The 82571 firmware may still be configuring the PHY. 		 * In this case, we cannot access the PHY until the 		 * configuration is done.  So we explicitly set the 		 * PHY ID. 		 */
name|phy
operator|->
name|id
operator|=
name|IGP01E1000_I_PHY_ID
expr_stmt|;
break|break;
case|case
name|e1000_82573
case|:
return|return
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
return|;
break|break;
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_ID1
argument_list|,
operator|&
name|phy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy
operator|->
name|id
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_id
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_ID2
argument_list|,
operator|&
name|phy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|phy
operator|->
name|id
operator||=
call|(
name|u32
call|)
argument_list|(
name|phy_id
argument_list|)
expr_stmt|;
name|phy
operator|->
name|revision
operator|=
call|(
name|u32
call|)
argument_list|(
name|phy_id
operator|&
operator|~
name|PHY_REVISION_MASK
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|E1000_ERR_PHY
return|;
break|break;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_hw_semaphore_82571 - Acquire hardware semaphore  *  @hw: pointer to the HW structure  *  *  Acquire the HW semaphore to access the PHY or NVM  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_hw_semaphore_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|swsm
decl_stmt|;
name|s32
name|sw_timeout
init|=
name|hw
operator|->
name|nvm
operator|.
name|word_size
operator|+
literal|1
decl_stmt|;
name|s32
name|fw_timeout
init|=
name|hw
operator|->
name|nvm
operator|.
name|word_size
operator|+
literal|1
decl_stmt|;
name|s32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_hw_semaphore_82571"
argument_list|)
expr_stmt|;
comment|/* If we have timedout 3 times on trying to acquire 	 * the inter-port SMBI semaphore, there is old code 	 * operating on the other port, and it is not 	 * releasing SMBI. Modify the number of times that 	 * we try for the semaphore to interwork with this 	 * older code. 	 */
if|if
condition|(
name|hw
operator|->
name|dev_spec
operator|.
name|_82571
operator|.
name|smb_counter
operator|>
literal|2
condition|)
name|sw_timeout
operator|=
literal|1
expr_stmt|;
comment|/* Get the SW semaphore */
while|while
condition|(
name|i
operator|<
name|sw_timeout
condition|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swsm
operator|&
name|E1000_SWSM_SMBI
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|sw_timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access device - SMBI bit is set.\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|dev_spec
operator|.
name|_82571
operator|.
name|smb_counter
operator|++
expr_stmt|;
block|}
comment|/* Get the FW semaphore. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fw_timeout
condition|;
name|i
operator|++
control|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|,
name|swsm
operator||
name|E1000_SWSM_SWESMBI
argument_list|)
expr_stmt|;
comment|/* Semaphore acquired if bit latched */
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
operator|&
name|E1000_SWSM_SWESMBI
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|fw_timeout
condition|)
block|{
comment|/* Release semaphores */
name|e1000_put_hw_semaphore_82571
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Driver can't access the NVM\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_put_hw_semaphore_82571 - Release hardware semaphore  *  @hw: pointer to the HW structure  *  *  Release hardware semaphore used to access the PHY or NVM  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_put_hw_semaphore_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|swsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_put_hw_semaphore_generic"
argument_list|)
expr_stmt|;
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
name|swsm
operator|&=
operator|~
operator|(
name|E1000_SWSM_SMBI
operator||
name|E1000_SWSM_SWESMBI
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_hw_semaphore_82573 - Acquire hardware semaphore  *  @hw: pointer to the HW structure  *  *  Acquire the HW semaphore during reset.  *  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_hw_semaphore_82573
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|extcnf_ctrl
decl_stmt|;
name|s32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_hw_semaphore_82573"
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|)
expr_stmt|;
do|do
block|{
name|extcnf_ctrl
operator||=
name|E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|,
name|extcnf_ctrl
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extcnf_ctrl
operator|&
name|E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP
condition|)
break|break;
name|msec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|MDIO_OWNERSHIP_TIMEOUT
condition|)
do|;
if|if
condition|(
name|i
operator|==
name|MDIO_OWNERSHIP_TIMEOUT
condition|)
block|{
comment|/* Release semaphores */
name|e1000_put_hw_semaphore_82573
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Driver can't access the PHY\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_put_hw_semaphore_82573 - Release hardware semaphore  *  @hw: pointer to the HW structure  *  *  Release hardware semaphore used during reset.  *  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_put_hw_semaphore_82573
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|extcnf_ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_put_hw_semaphore_82573"
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|)
expr_stmt|;
name|extcnf_ctrl
operator|&=
operator|~
name|E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EXTCNF_CTRL
argument_list|,
name|extcnf_ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_hw_semaphore_82574 - Acquire hardware semaphore  *  @hw: pointer to the HW structure  *  *  Acquire the HW semaphore to access the PHY or NVM.  *  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_hw_semaphore_82574
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_hw_semaphore_82574"
argument_list|)
expr_stmt|;
name|E1000_MUTEX_LOCK
argument_list|(
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|_82571
operator|.
name|swflag_mutex
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_hw_semaphore_82573
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|E1000_MUTEX_UNLOCK
argument_list|(
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|_82571
operator|.
name|swflag_mutex
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_put_hw_semaphore_82574 - Release hardware semaphore  *  @hw: pointer to the HW structure  *  *  Release hardware semaphore used to access the PHY or NVM  *  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_put_hw_semaphore_82574
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_put_hw_semaphore_82574"
argument_list|)
expr_stmt|;
name|e1000_put_hw_semaphore_82573
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_MUTEX_UNLOCK
argument_list|(
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|_82571
operator|.
name|swflag_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d0_lplu_state_82574 - Set Low Power Linkup D0 state  *  @hw: pointer to the HW structure  *  @active: TRUE to enable LPLU, FALSE to disable  *  *  Sets the LPLU D0 state according to the active flag.  *  LPLU will not be activated unless the  *  device autonegotiation advertisement meets standards of  *  either 10 or 10/100 or 10/100/1000 at all duplexes.  *  This is a function pointer entry point only called by  *  PHY setup routines.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_set_d0_lplu_state_82574
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|u32
name|data
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_POEMB
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d0_lplu_state_82574"
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
condition|)
name|data
operator||=
name|E1000_PHY_CTRL_D0A_LPLU
expr_stmt|;
else|else
name|data
operator|&=
operator|~
name|E1000_PHY_CTRL_D0A_LPLU
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_POEMB
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d3_lplu_state_82574 - Sets low power link up state for D3  *  @hw: pointer to the HW structure  *  @active: boolean used to enable/disable lplu  *  *  The low power link up (lplu) state is set to the power management level D3  *  when active is TRUE, else clear lplu for D3. LPLU  *  is used during Dx states where the power conservation is most important.  *  During driver activity, SmartSpeed should be enabled so performance is  *  maintained.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_set_d3_lplu_state_82574
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|u32
name|data
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_POEMB
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d3_lplu_state_82574"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|active
condition|)
block|{
name|data
operator|&=
operator|~
name|E1000_PHY_CTRL_NOND0A_LPLU
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|==
name|E1000_ALL_SPEED_DUPLEX
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|==
name|E1000_ALL_NOT_GIG
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|autoneg_advertised
operator|==
name|E1000_ALL_10_SPEED
operator|)
condition|)
block|{
name|data
operator||=
name|E1000_PHY_CTRL_NOND0A_LPLU
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_POEMB
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_nvm_82571 - Request for access to the EEPROM  *  @hw: pointer to the HW structure  *  *  To gain access to the EEPROM, first we must obtain a hardware semaphore.  *  Then for non-82573 hardware, set the EEPROM access request bit and wait  *  for EEPROM access grant bit.  If the access grant bit is not set, release  *  hardware semaphore.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_acquire_nvm_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_nvm_82571"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_hw_semaphore_82571
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
break|break;
default|default:
name|ret_val
operator|=
name|e1000_acquire_nvm_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret_val
condition|)
name|e1000_put_hw_semaphore_82571
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_nvm_82571 - Release exclusive access to EEPROM  *  @hw: pointer to the HW structure  *  *  Stop any current commands to the EEPROM and clear the EEPROM request bit.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_release_nvm_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_nvm_82571"
argument_list|)
expr_stmt|;
name|e1000_release_nvm_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|e1000_put_hw_semaphore_82571
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_nvm_82571 - Write to EEPROM using appropriate interface  *  @hw: pointer to the HW structure  *  @offset: offset within the EEPROM to be written to  *  @words: number of words to write  *  @data: 16 bit word(s) to be written to the EEPROM  *  *  For non-82573 silicon, write data to EEPROM at offset using SPI interface.  *  *  If e1000_update_nvm_checksum is not called after this function, the  *  EEPROM will most likely contain an invalid checksum.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_write_nvm_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_nvm_82571"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|ret_val
operator|=
name|e1000_write_nvm_eewr_82571
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
name|ret_val
operator|=
name|e1000_write_nvm_spi
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|words
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
break|break;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_nvm_checksum_82571 - Update EEPROM checksum  *  @hw: pointer to the HW structure  *  *  Updates the EEPROM checksum by reading/adding each word of the EEPROM  *  up to the checksum.  Then calculates the EEPROM checksum and writes the  *  value to the EEPROM.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_update_nvm_checksum_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|eecd
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_nvm_checksum_82571"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_update_nvm_checksum_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* If our nvm is an EEPROM, then we're done 	 * otherwise, commit the checksum to the flash NVM. 	 */
if|if
condition|(
name|hw
operator|->
name|nvm
operator|.
name|type
operator|!=
name|e1000_nvm_flash_hw
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Check for pending operations. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_FLASH_UPDATES
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
operator|&
name|E1000_EECD_FLUPD
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|E1000_FLASH_UPDATES
condition|)
return|return
operator|-
name|E1000_ERR_NVM
return|;
comment|/* Reset the firmware if using STM opcode. */
if|if
condition|(
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FLOP
argument_list|)
operator|&
literal|0xFF00
operator|)
operator|==
name|E1000_STM_OPCODE
condition|)
block|{
comment|/* The enabling of and the actual reset must be done 		 * in two write cycles. 		 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|,
name|E1000_HICR_FW_RESET_ENABLE
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|,
name|E1000_HICR_FW_RESET
argument_list|)
expr_stmt|;
block|}
comment|/* Commit the write to flash */
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
operator||
name|E1000_EECD_FLUPD
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_FLASH_UPDATES
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
operator|&
name|E1000_EECD_FLUPD
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|E1000_FLASH_UPDATES
condition|)
return|return
operator|-
name|E1000_ERR_NVM
return|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_validate_nvm_checksum_82571 - Validate EEPROM checksum  *  @hw: pointer to the HW structure  *  *  Calculates the EEPROM checksum by reading/adding each word of the EEPROM  *  and then verifies that the sum of the EEPROM is equal to 0xBABA.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_validate_nvm_checksum_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_validate_nvm_checksum_82571"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|nvm
operator|.
name|type
operator|==
name|e1000_nvm_flash_hw
condition|)
name|e1000_fix_nvm_checksum_82571
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|e1000_validate_nvm_checksum_generic
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_nvm_eewr_82571 - Write to EEPROM for 82573 silicon  *  @hw: pointer to the HW structure  *  @offset: offset within the EEPROM to be written to  *  @words: number of words to write  *  @data: 16 bit word(s) to be written to the EEPROM  *  *  After checking for invalid values, poll the EEPROM to ensure the previous  *  command has completed before trying to write the next word.  After write  *  poll for completion.  *  *  If e1000_update_nvm_checksum is not called after this function, the  *  EEPROM will most likely contain an invalid checksum.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_write_nvm_eewr_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|eewr
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_nvm_eewr_82571"
argument_list|)
expr_stmt|;
comment|/* A check for invalid values:  offset too large, too many words, 	 * and not enough words. 	 */
if|if
condition|(
operator|(
name|offset
operator|>=
name|nvm
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
operator|(
name|nvm
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"nvm parameter(s) out of bounds\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|eewr
operator|=
operator|(
operator|(
name|data
index|[
name|i
index|]
operator|<<
name|E1000_NVM_RW_REG_DATA
operator|)
operator||
operator|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|<<
name|E1000_NVM_RW_ADDR_SHIFT
operator|)
operator||
name|E1000_NVM_RW_REG_START
operator|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_poll_eerd_eewr_done
argument_list|(
name|hw
argument_list|,
name|E1000_NVM_POLL_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EEWR
argument_list|,
name|eewr
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_poll_eerd_eewr_done
argument_list|(
name|hw
argument_list|,
name|E1000_NVM_POLL_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cfg_done_82571 - Poll for configuration done  *  @hw: pointer to the HW structure  *  *  Reads the management control register for the config done bit to be set.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_cfg_done_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|timeout
init|=
name|PHY_CFG_TIMEOUT
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cfg_done_82571"
argument_list|)
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EEMNGCTL
argument_list|)
operator|&
name|E1000_NVM_CFG_DONE_PORT_0
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"MNG configuration cycle has not completed.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_RESET
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d0_lplu_state_82571 - Set Low Power Linkup D0 state  *  @hw: pointer to the HW structure  *  @active: TRUE to enable LPLU, FALSE to disable  *  *  Sets the LPLU D0 state according to the active flag.  When activating LPLU  *  this function also disables smart speed and vice versa.  LPLU will not be  *  activated unless the device autonegotiation advertisement meets standards  *  of either 10 or 10/100 or 10/100/1000 at all duplexes.  This is a function  *  pointer entry point only called by PHY setup routines.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_set_d0_lplu_state_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d0_lplu_state_82571"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|)
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|active
condition|)
block|{
name|data
operator||=
name|IGP02E1000_PM_D0_LPLU
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* When LPLU is enabled, we should disable SmartSpeed */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
name|data
operator|&=
operator|~
name|IGP02E1000_PM_D0_LPLU
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used 		 * during Dx states where the power conservation is most 		 * important.  During driver activity we should enable 		 * SmartSpeed, so performance is maintained. 		 */
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_on
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator||=
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_off
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_hw_82571 - Reset hardware  *  @hw: pointer to the HW structure  *  *  This resets the hardware into a known state.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_reset_hw_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|,
name|ctrl_ext
decl_stmt|,
name|eecd
decl_stmt|,
name|tctl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_hw_82571"
argument_list|)
expr_stmt|;
comment|/* Prevent the PCI-E bus from sticking if there is no TLP connection 	 * on the last TLP read/write transaction when MAC is reset. 	 */
name|ret_val
operator|=
name|e1000_disable_pcie_master_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT
argument_list|(
literal|"PCI-E Master disable polling has failed.\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|)
expr_stmt|;
name|tctl
operator|&=
operator|~
name|E1000_TCTL_EN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|tctl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Must acquire the MDIO ownership before MAC reset. 	 * Ownership defaults to firmware after a reset. 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
name|ret_val
operator|=
name|e1000_get_hw_semaphore_82573
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|ret_val
operator|=
name|e1000_get_hw_semaphore_82574
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Issuing a global reset to MAC\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_RST
argument_list|)
expr_stmt|;
comment|/* Must release MDIO ownership and mutex after MAC reset. */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
comment|/* Release mutex only if the hw semaphore is acquired */
if|if
condition|(
operator|!
name|ret_val
condition|)
name|e1000_put_hw_semaphore_82573
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
comment|/* Release mutex only if the hw semaphore is acquired */
if|if
condition|(
operator|!
name|ret_val
condition|)
name|e1000_put_hw_semaphore_82574
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|hw
operator|->
name|nvm
operator|.
name|type
operator|==
name|e1000_nvm_flash_hw
condition|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_EE_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
name|ret_val
operator|=
name|e1000_get_auto_rd_done_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
comment|/* We don't want to continue accessing MAC registers. */
return|return
name|ret_val
return|;
comment|/* Phy configuration from NVM just starts after EECD_AUTO_RD is set. 	 * Need to wait for Phy configuration completion before accessing 	 * NVM and Phy. 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
comment|/* REQ and GNT bits need to be cleared when using AUTO_RD 		 * to access the EEPROM. 		 */
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_REQ
operator||
name|E1000_EECD_GNT
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_82573
case|:
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|msec_delay
argument_list|(
literal|25
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Clear any pending interrupt events. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82571
condition|)
block|{
comment|/* Install any alternate MAC address into RAR0 */
name|ret_val
operator|=
name|e1000_check_alt_mac_addr_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|e1000_set_laa_state_82571
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* Reinitialize the 82571 serdes link state machine */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
condition|)
name|hw
operator|->
name|mac
operator|.
name|serdes_link_state
operator|=
name|e1000_serdes_link_down
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_hw_82571 - Initialize hardware  *  @hw: pointer to the HW structure  *  *  This inits the hardware readying it for operation.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_hw_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|reg_data
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|rar_count
init|=
name|mac
operator|->
name|rar_entry_count
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_hw_82571"
argument_list|)
expr_stmt|;
name|e1000_initialize_hw_bits_82571
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Initialize identification LED */
name|ret_val
operator|=
name|mac
operator|->
name|ops
operator|.
name|id_led_init
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* An error is not fatal and we should not stop init due to this */
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT
argument_list|(
literal|"Error initializing identification LED\n"
argument_list|)
expr_stmt|;
comment|/* Disabling VLAN filtering */
name|DEBUGOUT
argument_list|(
literal|"Initializing the IEEE VLAN\n"
argument_list|)
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vfta
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Setup the receive address. 	 * If, however, a locally administered address was assigned to the 	 * 82571, we must reserve a RAR for it to work around an issue where 	 * resetting one port will reload the MAC on the other port. 	 */
if|if
condition|(
name|e1000_get_laa_state_82571
argument_list|(
name|hw
argument_list|)
condition|)
name|rar_count
operator|--
expr_stmt|;
name|e1000_init_rx_addrs_generic
argument_list|(
name|hw
argument_list|,
name|rar_count
argument_list|)
expr_stmt|;
comment|/* Zero out the Multicast HASH table */
name|DEBUGOUT
argument_list|(
literal|"Zeroing the MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mac
operator|->
name|mta_reg_count
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup link and flow control */
name|ret_val
operator|=
name|mac
operator|->
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set the transmit descriptor write-back policy */
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reg_data
operator|=
operator|(
operator|(
name|reg_data
operator|&
operator|~
name|E1000_TXDCTL_WTHRESH
operator|)
operator||
name|E1000_TXDCTL_FULL_TX_DESC_WB
operator||
name|E1000_TXDCTL_COUNT_DESC
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
comment|/* ...for both queues. */
switch|switch
condition|(
name|mac
operator|->
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
name|e1000_enable_tx_pkt_filtering_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GCR
argument_list|)
expr_stmt|;
name|reg_data
operator||=
name|E1000_GCR_L1_ACT_WITHOUT_L0S_RX
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GCR
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|reg_data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|reg_data
operator|=
operator|(
operator|(
name|reg_data
operator|&
operator|~
name|E1000_TXDCTL_WTHRESH
operator|)
operator||
name|E1000_TXDCTL_FULL_TX_DESC_WB
operator||
name|E1000_TXDCTL_COUNT_DESC
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|1
argument_list|)
argument_list|,
name|reg_data
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Clear all of the statistics registers (clear on read).  It is 	 * important that we do this after we have tried to establish link 	 * because the symbol error count will increment wildly if there 	 * is no link. 	 */
name|e1000_clear_hw_cntrs_82571
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_initialize_hw_bits_82571 - Initialize hardware-dependent bits  *  @hw: pointer to the HW structure  *  *  Initializes required hardware-dependent bits needed for normal operation.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_initialize_hw_bits_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_initialize_hw_bits_82571"
argument_list|)
expr_stmt|;
comment|/* Transmit Descriptor Control 0 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Transmit Descriptor Control 1 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
literal|1
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Transmit Arbitration Control 0 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
literal|0xF
operator|<<
literal|27
operator|)
expr_stmt|;
comment|/* 30:27 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|23
operator|)
operator||
operator|(
literal|1
operator|<<
literal|24
operator|)
operator||
operator|(
literal|1
operator|<<
literal|25
operator|)
operator||
operator|(
literal|1
operator|<<
literal|26
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|26
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Transmit Arbitration Control 1 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
name|reg
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
literal|29
operator|)
operator||
operator|(
literal|1
operator|<<
literal|30
operator|)
operator|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|22
operator|)
operator||
operator|(
literal|1
operator|<<
literal|24
operator|)
operator||
operator|(
literal|1
operator|<<
literal|25
operator|)
operator||
operator|(
literal|1
operator|<<
literal|26
operator|)
expr_stmt|;
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|)
operator|&
name|E1000_TCTL_MULR
condition|)
name|reg
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|28
operator|)
expr_stmt|;
else|else
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|28
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TARC
argument_list|(
literal|1
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Device Control */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|29
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Extended Device Control */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82571
condition|)
block|{
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA_ECC
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_PBA_ECC_CORR_EN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA_ECC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Workaround for hardware errata. 	 * Ensure that DMA Dynamic Clock gating is disabled on 82571 and 82572 	 */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82571
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82572
operator|)
condition|)
block|{
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|E1000_CTRL_EXT_DMA_DYN_CLK_EN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Disable IPv6 extension header parsing because some malformed 	 * IPv6 headers can hang the Rx. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<=
name|e1000_82573
condition|)
block|{
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RFCTL
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
name|E1000_RFCTL_IPV6_EX_DIS
operator||
name|E1000_RFCTL_NEW_IPV6_EXT_DIS
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RFCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* PCI-Ex Control Registers */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GCR
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GCR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Workaround for hardware errata. 		 * apply workaround for hardware errata documented in errata 		 * docs Fixes issue where some error prone or unreliable PCIe 		 * completions are occurring, particularly with ASPM enabled. 		 * Without fix, issue can cause Tx timeouts. 		 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GCR2
argument_list|)
expr_stmt|;
name|reg
operator||=
literal|1
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GCR2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_clear_vfta_82571 - Clear VLAN filter table  *  @hw: pointer to the HW structure  *  *  Clears the register array which contains the VLAN filter table by  *  setting all the values to 0.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_clear_vfta_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|offset
decl_stmt|;
name|u32
name|vfta_value
init|=
literal|0
decl_stmt|;
name|u32
name|vfta_offset
init|=
literal|0
decl_stmt|;
name|u32
name|vfta_bit_in_reg
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clear_vfta_82571"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
if|if
condition|(
name|hw
operator|->
name|mng_cookie
operator|.
name|vlan_id
operator|!=
literal|0
condition|)
block|{
comment|/* The VFTA is a 4096b bit-field, each identifying 			 * a single VLAN ID.  The following operations 			 * determine which 32b entry (i.e. offset) into the 			 * array we want to set the VLAN ID (i.e. bit) of 			 * the manageability unit. 			 */
name|vfta_offset
operator|=
operator|(
name|hw
operator|->
name|mng_cookie
operator|.
name|vlan_id
operator|>>
name|E1000_VFTA_ENTRY_SHIFT
operator|)
operator|&
name|E1000_VFTA_ENTRY_MASK
expr_stmt|;
name|vfta_bit_in_reg
operator|=
literal|1
operator|<<
operator|(
name|hw
operator|->
name|mng_cookie
operator|.
name|vlan_id
operator|&
name|E1000_VFTA_ENTRY_BIT_SHIFT_MASK
operator|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|E1000_VLAN_FILTER_TBL_SIZE
condition|;
name|offset
operator|++
control|)
block|{
comment|/* If the offset we want to clear is the same offset of the 		 * manageability VLAN ID, then clear all bits except that of 		 * the manageability unit. 		 */
name|vfta_value
operator|=
operator|(
name|offset
operator|==
name|vfta_offset
operator|)
condition|?
name|vfta_bit_in_reg
else|:
literal|0
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VFTA
argument_list|,
name|offset
argument_list|,
name|vfta_value
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_check_mng_mode_82574 - Check manageability is enabled  *  @hw: pointer to the HW structure  *  *  Reads the NVM Initialization Control Word 2 and returns TRUE  *  (>0) if any manageability is enabled, else FALSE (0).  **/
end_comment

begin_function
specifier|static
name|bool
name|e1000_check_mng_mode_82574
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_mng_mode_82574"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_INIT_CONTROL2_REG
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|&
name|E1000_NVM_INIT_CTRL2_MNGM
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_led_on_82574 - Turn LED on  *  @hw: pointer to the HW structure  *  *  Turn LED on.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_led_on_82574
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_led_on_82574"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|E1000_STATUS_LU
operator|&
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|)
condition|)
block|{
comment|/* If no link, then turn LED on by setting the invert bit 		 * for each LED that's "on" (0x0E) in ledctl_mode2. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode2
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xFF
operator|)
operator|==
name|E1000_LEDCTL_MODE_LED_ON
condition|)
name|ctrl
operator||=
operator|(
name|E1000_LEDCTL_LED0_IVRT
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_phy_82574 - check 82574 phy hung state  *  @hw: pointer to the HW structure  *  *  Returns whether phy is hung or not  **/
end_comment

begin_function
name|bool
name|e1000_check_phy_82574
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|status_1kbt
init|=
literal|0
decl_stmt|;
name|u16
name|receive_errors
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_phy_82574"
argument_list|)
expr_stmt|;
comment|/* Read PHY Receive Error counter first, if its is max - all F's then 	 * read the Base1000T status register If both are max then PHY is hung. 	 */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|E1000_RECEIVE_ERROR_COUNTER
argument_list|,
operator|&
name|receive_errors
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|receive_errors
operator|==
name|E1000_RECEIVE_ERROR_MAX
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|E1000_BASE1000T_STATUS
argument_list|,
operator|&
name|status_1kbt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|status_1kbt
operator|&
name|E1000_IDLE_ERROR_COUNT_MASK
operator|)
operator|==
name|E1000_IDLE_ERROR_COUNT_MASK
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_link_82571 - Setup flow control and link settings  *  @hw: pointer to the HW structure  *  *  Determines which flow control settings to use, then configures flow  *  control.  Calls the appropriate media-specific link configuration  *  function.  Assuming the adapter has a valid link partner, a valid link  *  should be established.  Assumes the hardware has previously been reset  *  and the transmitter and receiver are not enabled.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_setup_link_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_link_82571"
argument_list|)
expr_stmt|;
comment|/* 82573 does not have a word in the NVM to determine 	 * the default flow control setting, so we explicitly 	 * set it to full. 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|e1000_fc_default
condition|)
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|e1000_fc_full
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|e1000_setup_link_generic
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_copper_link_82571 - Configure copper link settings  *  @hw: pointer to the HW structure  *  *  Configures the link for auto-neg or forced speed and duplex.  Then we check  *  for link, once link is established calls to configure collision distance  *  and flow control are called.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_setup_copper_link_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_copper_link_82571"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SLU
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|e1000_phy_m88
case|:
case|case
name|e1000_phy_bm
case|:
name|ret_val
operator|=
name|e1000_copper_link_setup_m88
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_phy_igp_2
case|:
name|ret_val
operator|=
name|e1000_copper_link_setup_igp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|E1000_ERR_PHY
return|;
break|break;
block|}
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
return|return
name|e1000_setup_copper_link_generic
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_fiber_serdes_link_82571 - Setup link for fiber/serdes  *  @hw: pointer to the HW structure  *  *  Configures collision distance and flow control for fiber and serdes links.  *  Upon successful setup, poll for link.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_setup_fiber_serdes_link_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_fiber_serdes_link_82571"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82571
case|:
case|case
name|e1000_82572
case|:
comment|/* If SerDes loopback mode is entered, there is no form 		 * of reset to take the adapter out of that mode.  So we 		 * have to explicitly take the adapter out of loopback 		 * mode.  This prevents drivers from twiddling their thumbs 		 * if another tool failed to take it out of loopback mode. 		 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SCTL
argument_list|,
name|E1000_SCTL_DISABLE_SERDES_LOOPBACK
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|e1000_setup_fiber_serdes_link_generic
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_serdes_link_82571 - Check for link (Serdes)  *  @hw: pointer to the HW structure  *  *  Reports the link state as up or down.  *  *  If autonegotiation is supported by the link partner, the link state is  *  determined by the result of autonegotiation. This is the most likely case.  *  If autonegotiation is not supported by the link partner, and the link  *  has a valid signal, force the link up.  *  *  The link state is represented internally here by 4 states:  *  *  1) down  *  2) autoneg_progress  *  3) autoneg_complete (the link successfully autonegotiated)  *  4) forced_up (the link has been forced up, it did not autonegotiate)  *  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_check_for_serdes_link_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|rxcw
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|u32
name|status
decl_stmt|;
name|u32
name|txcw
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_serdes_link_82571"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCW
argument_list|)
expr_stmt|;
comment|/* SYNCH bit and IV bit are sticky */
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|rxcw
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rxcw
operator|&
name|E1000_RXCW_SYNCH
operator|)
operator|&&
operator|!
operator|(
name|rxcw
operator|&
name|E1000_RXCW_IV
operator|)
condition|)
block|{
comment|/* Receiver is synchronized with no invalid bits.  */
switch|switch
condition|(
name|mac
operator|->
name|serdes_link_state
condition|)
block|{
case|case
name|e1000_serdes_link_autoneg_complete
case|:
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|E1000_STATUS_LU
operator|)
condition|)
block|{
comment|/* We have lost link, retry autoneg before 				 * reporting link failure 				 */
name|mac
operator|->
name|serdes_link_state
operator|=
name|e1000_serdes_link_autoneg_progress
expr_stmt|;
name|mac
operator|->
name|serdes_has_link
operator|=
name|FALSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"AN_UP     -> AN_PROG\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|e1000_serdes_link_forced_up
case|:
comment|/* If we are receiving /C/ ordered sets, re-enable 			 * auto-negotiation in the TXCW register and disable 			 * forced link in the Device Control register in an 			 * attempt to auto-negotiate with our link partner. 			 */
if|if
condition|(
name|rxcw
operator|&
name|E1000_RXCW_C
condition|)
block|{
comment|/* Enable autoneg, and unforce link up */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
name|mac
operator|->
name|txcw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
operator|(
name|ctrl
operator|&
operator|~
name|E1000_CTRL_SLU
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|->
name|serdes_link_state
operator|=
name|e1000_serdes_link_autoneg_progress
expr_stmt|;
name|mac
operator|->
name|serdes_has_link
operator|=
name|FALSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"FORCED_UP -> AN_PROG\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|e1000_serdes_link_autoneg_progress
case|:
if|if
condition|(
name|rxcw
operator|&
name|E1000_RXCW_C
condition|)
block|{
comment|/* We received /C/ ordered sets, meaning the 				 * link partner has autonegotiated, and we can 				 * trust the Link Up (LU) status bit. 				 */
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_LU
condition|)
block|{
name|mac
operator|->
name|serdes_link_state
operator|=
name|e1000_serdes_link_autoneg_complete
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"AN_PROG   -> AN_UP\n"
argument_list|)
expr_stmt|;
name|mac
operator|->
name|serdes_has_link
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Autoneg completed, but failed. */
name|mac
operator|->
name|serdes_link_state
operator|=
name|e1000_serdes_link_down
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"AN_PROG   -> DOWN\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The link partner did not autoneg. 				 * Force link up and full duplex, and change 				 * state to forced. 				 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
operator|(
name|mac
operator|->
name|txcw
operator|&
operator|~
name|E1000_TXCW_ANE
operator|)
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_SLU
operator||
name|E1000_CTRL_FD
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Configure Flow Control after link up. */
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error config flow control\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|mac
operator|->
name|serdes_link_state
operator|=
name|e1000_serdes_link_forced_up
expr_stmt|;
name|mac
operator|->
name|serdes_has_link
operator|=
name|TRUE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"AN_PROG   -> FORCED_UP\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|e1000_serdes_link_down
case|:
default|default:
comment|/* The link was down but the receiver has now gained 			 * valid sync, so lets see if we can bring the link 			 * up. 			 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
name|mac
operator|->
name|txcw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
operator|(
name|ctrl
operator|&
operator|~
name|E1000_CTRL_SLU
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|->
name|serdes_link_state
operator|=
name|e1000_serdes_link_autoneg_progress
expr_stmt|;
name|mac
operator|->
name|serdes_has_link
operator|=
name|FALSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"DOWN      -> AN_PROG\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|rxcw
operator|&
name|E1000_RXCW_SYNCH
operator|)
condition|)
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|FALSE
expr_stmt|;
name|mac
operator|->
name|serdes_link_state
operator|=
name|e1000_serdes_link_down
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ANYSTATE  -> DOWN\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check several times, if SYNCH bit and CONFIG 			 * bit both are consistently 1 then simply ignore 			 * the IV bit and restart Autoneg 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AN_RETRY_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|rxcw
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rxcw
operator|&
name|E1000_RXCW_SYNCH
operator|)
operator|&&
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
condition|)
continue|continue;
if|if
condition|(
name|rxcw
operator|&
name|E1000_RXCW_IV
condition|)
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|FALSE
expr_stmt|;
name|mac
operator|->
name|serdes_link_state
operator|=
name|e1000_serdes_link_down
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ANYSTATE  -> DOWN\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|AN_RETRY_COUNT
condition|)
block|{
name|txcw
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|)
expr_stmt|;
name|txcw
operator||=
name|E1000_TXCW_ANE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
name|txcw
argument_list|)
expr_stmt|;
name|mac
operator|->
name|serdes_link_state
operator|=
name|e1000_serdes_link_autoneg_progress
expr_stmt|;
name|mac
operator|->
name|serdes_has_link
operator|=
name|FALSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ANYSTATE  -> AN_PROG\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_valid_led_default_82571 - Verify a valid default LED config  *  @hw: pointer to the HW structure  *  @data: pointer to the NVM (EEPROM)  *  *  Read the EEPROM for the current default LED configuration.  If the  *  LED configuration is not valid, set to a valid LED configuration.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_valid_led_default_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_valid_led_default_82571"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_ID_LED_SETTINGS
argument_list|,
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82573
case|:
case|case
name|e1000_82574
case|:
case|case
name|e1000_82583
case|:
if|if
condition|(
operator|*
name|data
operator|==
name|ID_LED_RESERVED_F746
condition|)
operator|*
name|data
operator|=
name|ID_LED_DEFAULT_82573
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|*
name|data
operator|==
name|ID_LED_RESERVED_0000
operator|||
operator|*
name|data
operator|==
name|ID_LED_RESERVED_FFFF
condition|)
operator|*
name|data
operator|=
name|ID_LED_DEFAULT
expr_stmt|;
break|break;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_laa_state_82571 - Get locally administered address state  *  @hw: pointer to the HW structure  *  *  Retrieve and return the current locally administered address state.  **/
end_comment

begin_function
name|bool
name|e1000_get_laa_state_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_laa_state_82571"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82571
condition|)
return|return
name|FALSE
return|;
return|return
name|hw
operator|->
name|dev_spec
operator|.
name|_82571
operator|.
name|laa_is_present
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_laa_state_82571 - Set locally administered address state  *  @hw: pointer to the HW structure  *  @state: enable/disable locally administered address  *  *  Enable/Disable the current locally administered address state.  **/
end_comment

begin_function
name|void
name|e1000_set_laa_state_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_laa_state_82571"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82571
condition|)
return|return;
name|hw
operator|->
name|dev_spec
operator|.
name|_82571
operator|.
name|laa_is_present
operator|=
name|state
expr_stmt|;
comment|/* If workaround is activated... */
if|if
condition|(
name|state
condition|)
comment|/* Hold a copy of the LAA in RAR[14] This is done so that 		 * between the time RAR[0] gets clobbered and the time it 		 * gets fixed, the actual LAA is in one of the RARs and no 		 * incoming packets directed to this port are dropped. 		 * Eventually the LAA will be in RAR[0] and RAR[14]. 		 */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|rar_set
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|rar_entry_count
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_fix_nvm_checksum_82571 - Fix EEPROM checksum  *  @hw: pointer to the HW structure  *  *  Verifies that the EEPROM has completed the update.  After updating the  *  EEPROM, we need to check bit 15 in work 0x23 for the checksum fix.  If  *  the checksum fix is not implemented, we need to set the bit and update  *  the checksum.  Otherwise, if bit 15 is set and the checksum is incorrect,  *  we need to return bad checksum.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_fix_nvm_checksum_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_fix_nvm_checksum_82571"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvm
operator|->
name|type
operator|!=
name|e1000_nvm_flash_hw
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* Check bit 4 of word 10h.  If it is 0, firmware is done updating 	 * 10h-12h.  Checksum may need to be fixed. 	 */
name|ret_val
operator|=
name|nvm
operator|->
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
literal|0x10
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
operator|(
name|data
operator|&
literal|0x10
operator|)
condition|)
block|{
comment|/* Read 0x23 and check bit 15.  This bit is a 1 		 * when the checksum has already been fixed.  If 		 * the checksum is still wrong and this bit is a 		 * 1, we need to return bad checksum.  Otherwise, 		 * we need to set this bit to a 1 and update the 		 * checksum. 		 */
name|ret_val
operator|=
name|nvm
operator|->
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
literal|0x23
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
operator|(
name|data
operator|&
literal|0x8000
operator|)
condition|)
block|{
name|data
operator||=
literal|0x8000
expr_stmt|;
name|ret_val
operator|=
name|nvm
operator|->
name|ops
operator|.
name|write
argument_list|(
name|hw
argument_list|,
literal|0x23
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|nvm
operator|->
name|ops
operator|.
name|update
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_mac_addr_82571 - Read device MAC address  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_mac_addr_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_mac_addr_82571"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82571
condition|)
block|{
name|s32
name|ret_val
decl_stmt|;
comment|/* If there's an alternate MAC address place it in RAR0 		 * so that it will override the Si installed default perm 		 * address. 		 */
name|ret_val
operator|=
name|e1000_check_alt_mac_addr_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
return|return
name|e1000_read_mac_addr_generic
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * e1000_power_down_phy_copper_82571 - Remove link during PHY power down  * @hw: pointer to the HW structure  *  * In the case of a PHY power down to save power, or to turn off link during a  * driver unload, or wake on lan is not enabled, remove the link.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_power_down_phy_copper_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
if|if
condition|(
operator|!
name|phy
operator|->
name|ops
operator|.
name|check_reset_block
condition|)
return|return;
comment|/* If the management interface is not enabled, then power down */
if|if
condition|(
operator|!
operator|(
name|mac
operator|->
name|ops
operator|.
name|check_mng_mode
argument_list|(
name|hw
argument_list|)
operator|||
name|phy
operator|->
name|ops
operator|.
name|check_reset_block
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
name|e1000_power_down_phy_copper
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_clear_hw_cntrs_82571 - Clear device specific hardware counters  *  @hw: pointer to the HW structure  *  *  Clears the hardware counters by reading the counter registers.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_clear_hw_cntrs_82571
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_clear_hw_cntrs_82571"
argument_list|)
expr_stmt|;
name|e1000_clear_hw_cntrs_base_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC64
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC127
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC255
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC511
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC1023
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC1522
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC64
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC127
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC255
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC511
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC1023
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC1522
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ALGNERRC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXERRC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TNCRS
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CEXTERR
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTFC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPRC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPDC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IAC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXOC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXPTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXATC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXPTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXATC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXQEC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXQMTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXDMTC
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

