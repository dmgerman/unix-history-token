begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2013, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"e1000_api.h"
end_include

begin_function_decl
specifier|static
name|void
name|e1000_reload_nvm_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  e1000_init_nvm_ops_generic - Initialize NVM function pointers  *  @hw: pointer to the HW structure  *  *  Setups up the function pointers to no-op functions  **/
end_comment

begin_function
name|void
name|e1000_init_nvm_ops_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_nvm_ops_generic"
argument_list|)
expr_stmt|;
comment|/* Initialize function pointers */
name|nvm
operator|->
name|ops
operator|.
name|init_params
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|acquire
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|read
operator|=
name|e1000_null_read_nvm
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|release
operator|=
name|e1000_null_nvm_generic
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|reload
operator|=
name|e1000_reload_nvm_generic
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|update
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|valid_led_default
operator|=
name|e1000_null_led_default
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|validate
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|write
operator|=
name|e1000_null_write_nvm
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_nvm_read - No-op function, return 0  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|s32
name|e1000_null_read_nvm
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|a
parameter_list|,
name|u16
name|b
parameter_list|,
name|u16
modifier|*
name|c
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_read_nvm"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_nvm_generic - No-op function, return void  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|void
name|e1000_null_nvm_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_nvm_generic"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_led_default - No-op function, return 0  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|s32
name|e1000_null_led_default
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_led_default"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_write_nvm - No-op function, return 0  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|s32
name|e1000_null_write_nvm
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|a
parameter_list|,
name|u16
name|b
parameter_list|,
name|u16
modifier|*
name|c
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_write_nvm"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_raise_eec_clk - Raise EEPROM clock  *  @hw: pointer to the HW structure  *  @eecd: pointer to the EEPROM  *  *  Enable/Raise the EEPROM clock bit.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_raise_eec_clk
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|eecd
parameter_list|)
block|{
operator|*
name|eecd
operator|=
operator|*
name|eecd
operator||
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
operator|*
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|hw
operator|->
name|nvm
operator|.
name|delay_usec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_lower_eec_clk - Lower EEPROM clock  *  @hw: pointer to the HW structure  *  @eecd: pointer to the EEPROM  *  *  Clear/Lower the EEPROM clock bit.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_lower_eec_clk
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|eecd
parameter_list|)
block|{
operator|*
name|eecd
operator|=
operator|*
name|eecd
operator|&
operator|~
name|E1000_EECD_SK
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
operator|*
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|hw
operator|->
name|nvm
operator|.
name|delay_usec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_shift_out_eec_bits - Shift data bits our to the EEPROM  *  @hw: pointer to the HW structure  *  @data: data to send to the EEPROM  *  @count: number of bits to shift out  *  *  We need to shift 'count' bits out to the EEPROM.  So, the value in the  *  "data" parameter will be shifted out to the EEPROM one bit at a time.  *  In order to do this, "data" must be broken down into bits.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_shift_out_eec_bits
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|data
parameter_list|,
name|u16
name|count
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|u32
name|eecd
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
decl_stmt|;
name|u32
name|mask
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_shift_out_eec_bits"
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|0x01
operator|<<
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nvm
operator|->
name|type
operator|==
name|e1000_nvm_eeprom_microwire
condition|)
name|eecd
operator|&=
operator|~
name|E1000_EECD_DO
expr_stmt|;
elseif|else
if|if
condition|(
name|nvm
operator|->
name|type
operator|==
name|e1000_nvm_eeprom_spi
condition|)
name|eecd
operator||=
name|E1000_EECD_DO
expr_stmt|;
do|do
block|{
name|eecd
operator|&=
operator|~
name|E1000_EECD_DI
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|eecd
operator||=
name|E1000_EECD_DI
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|nvm
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
name|e1000_raise_eec_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
name|e1000_lower_eec_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|mask
condition|)
do|;
name|eecd
operator|&=
operator|~
name|E1000_EECD_DI
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_shift_in_eec_bits - Shift data bits in from the EEPROM  *  @hw: pointer to the HW structure  *  @count: number of bits to shift in  *  *  In order to read a register from the EEPROM, we need to shift 'count' bits  *  in from the EEPROM.  Bits are "shifted in" by raising the clock input to  *  the EEPROM (setting the SK bit), and then reading the value of the data out  *  "DO" bit.  During this "shifting in" process the data in "DI" bit should  *  always be clear.  **/
end_comment

begin_function
specifier|static
name|u16
name|e1000_shift_in_eec_bits
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|count
parameter_list|)
block|{
name|u32
name|eecd
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_shift_in_eec_bits"
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_DO
operator||
name|E1000_EECD_DI
operator|)
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|<<=
literal|1
expr_stmt|;
name|e1000_raise_eec_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
name|E1000_EECD_DI
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_DO
condition|)
name|data
operator||=
literal|1
expr_stmt|;
name|e1000_lower_eec_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_poll_eerd_eewr_done - Poll for EEPROM read/write completion  *  @hw: pointer to the HW structure  *  @ee_reg: EEPROM flag for polling  *  *  Polls the EEPROM status bit for either read or write completion based  *  upon the value of 'ee_reg'.  **/
end_comment

begin_function
name|s32
name|e1000_poll_eerd_eewr_done
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|int
name|ee_reg
parameter_list|)
block|{
name|u32
name|attempts
init|=
literal|100000
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|reg
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_poll_eerd_eewr_done"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attempts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ee_reg
operator|==
name|E1000_NVM_POLL_READ
condition|)
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EERD
argument_list|)
expr_stmt|;
else|else
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EEWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|E1000_NVM_RW_REG_DONE
condition|)
return|return
name|E1000_SUCCESS
return|;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_nvm_generic - Generic request for access to EEPROM  *  @hw: pointer to the HW structure  *  *  Set the EEPROM access request bit and wait for EEPROM access grant bit.  *  Return successful if access grant bit set, else clear the request for  *  EEPROM access and return -E1000_ERR_NVM (-1).  **/
end_comment

begin_function
name|s32
name|e1000_acquire_nvm_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|eecd
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
decl_stmt|;
name|s32
name|timeout
init|=
name|E1000_NVM_GRANT_ATTEMPTS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_nvm_generic"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
operator||
name|E1000_EECD_REQ
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_GNT
condition|)
break|break;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|eecd
operator|&=
operator|~
name|E1000_EECD_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Could not acquire NVM grant\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_standby_nvm - Return EEPROM to standby state  *  @hw: pointer to the HW structure  *  *  Return the EEPROM to a standby state.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_standby_nvm
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|u32
name|eecd
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_standby_nvm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvm
operator|->
name|type
operator|==
name|e1000_nvm_eeprom_microwire
condition|)
block|{
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_CS
operator||
name|E1000_EECD_SK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|nvm
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
name|e1000_raise_eec_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
comment|/* Select EEPROM */
name|eecd
operator||=
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|nvm
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
name|e1000_lower_eec_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nvm
operator|->
name|type
operator|==
name|e1000_nvm_eeprom_spi
condition|)
block|{
comment|/* Toggle CS to flush commands */
name|eecd
operator||=
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|nvm
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
name|nvm
operator|->
name|delay_usec
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_stop_nvm - Terminate EEPROM command  *  @hw: pointer to the HW structure  *  *  Terminates the current command by inverting the EEPROM's chip select pin.  **/
end_comment

begin_function
name|void
name|e1000_stop_nvm
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|eecd
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_stop_nvm"
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|nvm
operator|.
name|type
operator|==
name|e1000_nvm_eeprom_spi
condition|)
block|{
comment|/* Pull CS high */
name|eecd
operator||=
name|E1000_EECD_CS
expr_stmt|;
name|e1000_lower_eec_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|nvm
operator|.
name|type
operator|==
name|e1000_nvm_eeprom_microwire
condition|)
block|{
comment|/* CS on Microwire is active-high */
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_CS
operator||
name|E1000_EECD_DI
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|e1000_raise_eec_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
name|e1000_lower_eec_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|eecd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_release_nvm_generic - Release exclusive access to EEPROM  *  @hw: pointer to the HW structure  *  *  Stop any current commands to the EEPROM and clear the EEPROM request bit.  **/
end_comment

begin_function
name|void
name|e1000_release_nvm_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|eecd
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_nvm_generic"
argument_list|)
expr_stmt|;
name|e1000_stop_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
expr_stmt|;
name|eecd
operator|&=
operator|~
name|E1000_EECD_REQ
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_ready_nvm_eeprom - Prepares EEPROM for read/write  *  @hw: pointer to the HW structure  *  *  Setups the EEPROM for reading and writing.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_ready_nvm_eeprom
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|u32
name|eecd
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
decl_stmt|;
name|u8
name|spi_stat_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_ready_nvm_eeprom"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvm
operator|->
name|type
operator|==
name|e1000_nvm_eeprom_microwire
condition|)
block|{
comment|/* Clear SK and DI */
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_DI
operator||
name|E1000_EECD_SK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
comment|/* Set CS */
name|eecd
operator||=
name|E1000_EECD_CS
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nvm
operator|->
name|type
operator|==
name|e1000_nvm_eeprom_spi
condition|)
block|{
name|u16
name|timeout
init|=
name|NVM_MAX_RETRY_SPI
decl_stmt|;
comment|/* Clear SK and CS */
name|eecd
operator|&=
operator|~
operator|(
name|E1000_EECD_CS
operator||
name|E1000_EECD_SK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Read "Status Register" repeatedly until the LSB is cleared. 		 * The EEPROM will signal that the command has been completed 		 * by clearing bit 0 of the internal status register.  If it's 		 * not cleared within 'timeout', then error out. 		 */
while|while
condition|(
name|timeout
condition|)
block|{
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
name|NVM_RDSR_OPCODE_SPI
argument_list|,
name|hw
operator|->
name|nvm
operator|.
name|opcode_bits
argument_list|)
expr_stmt|;
name|spi_stat_reg
operator|=
operator|(
name|u8
operator|)
name|e1000_shift_in_eec_bits
argument_list|(
name|hw
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|spi_stat_reg
operator|&
name|NVM_STATUS_RDY_SPI
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|e1000_standby_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"SPI NVM Status error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_nvm_spi - Read EEPROM's using SPI  *  @hw: pointer to the HW structure  *  @offset: offset of word in the EEPROM to read  *  @words: number of words to read  *  @data: word read from the EEPROM  *  *  Reads a 16 bit word from the EEPROM.  **/
end_comment

begin_function
name|s32
name|e1000_read_nvm_spi
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|word_in
decl_stmt|;
name|u8
name|read_opcode
init|=
name|NVM_READ_OPCODE_SPI
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_nvm_spi"
argument_list|)
expr_stmt|;
comment|/* A check for invalid values:  offset too large, too many words, 	 * and not enough words. 	 */
if|if
condition|(
operator|(
name|offset
operator|>=
name|nvm
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
operator|(
name|nvm
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"nvm parameter(s) out of bounds\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
name|ret_val
operator|=
name|nvm
operator|->
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_ready_nvm_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|e1000_standby_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nvm
operator|->
name|address_bits
operator|==
literal|8
operator|)
operator|&&
operator|(
name|offset
operator|>=
literal|128
operator|)
condition|)
name|read_opcode
operator||=
name|NVM_A8_OPCODE_SPI
expr_stmt|;
comment|/* Send the READ command (opcode + addr) */
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
name|read_opcode
argument_list|,
name|nvm
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|offset
operator|*
literal|2
argument_list|)
argument_list|,
name|nvm
operator|->
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Read the data.  SPI NVMs increment the address with each byte 	 * read and will roll over if reading beyond the end.  This allows 	 * us to read the whole NVM from any offset 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|word_in
operator|=
name|e1000_shift_in_eec_bits
argument_list|(
name|hw
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
operator|(
name|word_in
operator|>>
literal|8
operator|)
operator||
operator|(
name|word_in
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
name|release
label|:
name|nvm
operator|->
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_nvm_microwire - Reads EEPROM's using microwire  *  @hw: pointer to the HW structure  *  @offset: offset of word in the EEPROM to read  *  @words: number of words to read  *  @data: word read from the EEPROM  *  *  Reads a 16 bit word from the EEPROM.  **/
end_comment

begin_function
name|s32
name|e1000_read_nvm_microwire
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u8
name|read_opcode
init|=
name|NVM_READ_OPCODE_MICROWIRE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_nvm_microwire"
argument_list|)
expr_stmt|;
comment|/* A check for invalid values:  offset too large, too many words, 	 * and not enough words. 	 */
if|if
condition|(
operator|(
name|offset
operator|>=
name|nvm
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
operator|(
name|nvm
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"nvm parameter(s) out of bounds\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
name|ret_val
operator|=
name|nvm
operator|->
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_ready_nvm_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
comment|/* Send the READ command (opcode + addr) */
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
name|read_opcode
argument_list|,
name|nvm
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|offset
operator|+
name|i
argument_list|)
argument_list|,
name|nvm
operator|->
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Read the data.  For microwire, each word requires the 		 * overhead of setup and tear-down. 		 */
name|data
index|[
name|i
index|]
operator|=
name|e1000_shift_in_eec_bits
argument_list|(
name|hw
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|e1000_standby_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
name|release
label|:
name|nvm
operator|->
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_nvm_eerd - Reads EEPROM using EERD register  *  @hw: pointer to the HW structure  *  @offset: offset of word in the EEPROM to read  *  @words: number of words to read  *  @data: word read from the EEPROM  *  *  Reads a 16 bit word from the EEPROM using the EERD register.  **/
end_comment

begin_function
name|s32
name|e1000_read_nvm_eerd
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|eerd
init|=
literal|0
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_nvm_eerd"
argument_list|)
expr_stmt|;
comment|/* A check for invalid values:  offset too large, too many words, 	 * too many words for the offset, and not enough words. 	 */
if|if
condition|(
operator|(
name|offset
operator|>=
name|nvm
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
operator|(
name|nvm
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"nvm parameter(s) out of bounds\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|eerd
operator|=
operator|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|<<
name|E1000_NVM_RW_ADDR_SHIFT
operator|)
operator|+
name|E1000_NVM_RW_REG_START
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EERD
argument_list|,
name|eerd
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_poll_eerd_eewr_done
argument_list|(
name|hw
argument_list|,
name|E1000_NVM_POLL_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
break|break;
name|data
index|[
name|i
index|]
operator|=
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EERD
argument_list|)
operator|>>
name|E1000_NVM_RW_REG_DATA
operator|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_nvm_spi - Write to EEPROM using SPI  *  @hw: pointer to the HW structure  *  @offset: offset within the EEPROM to be written to  *  @words: number of words to write  *  @data: 16 bit word(s) to be written to the EEPROM  *  *  Writes data to EEPROM at offset using SPI interface.  *  *  If e1000_update_nvm_checksum is not called after this function , the  *  EEPROM will most likely contain an invalid checksum.  **/
end_comment

begin_function
name|s32
name|e1000_write_nvm_spi
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_NVM
decl_stmt|;
name|u16
name|widx
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_nvm_spi"
argument_list|)
expr_stmt|;
comment|/* A check for invalid values:  offset too large, too many words, 	 * and not enough words. 	 */
if|if
condition|(
operator|(
name|offset
operator|>=
name|nvm
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
operator|(
name|nvm
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"nvm parameter(s) out of bounds\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
while|while
condition|(
name|widx
operator|<
name|words
condition|)
block|{
name|u8
name|write_opcode
init|=
name|NVM_WRITE_OPCODE_SPI
decl_stmt|;
name|ret_val
operator|=
name|nvm
operator|->
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_ready_nvm_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|nvm
operator|->
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|e1000_standby_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Send the WRITE ENABLE command (8 bit opcode) */
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
name|NVM_WREN_OPCODE_SPI
argument_list|,
name|nvm
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|e1000_standby_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Some SPI eeproms use the 8th address bit embedded in the 		 * opcode 		 */
if|if
condition|(
operator|(
name|nvm
operator|->
name|address_bits
operator|==
literal|8
operator|)
operator|&&
operator|(
name|offset
operator|>=
literal|128
operator|)
condition|)
name|write_opcode
operator||=
name|NVM_A8_OPCODE_SPI
expr_stmt|;
comment|/* Send the Write command (8-bit opcode + addr) */
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
name|write_opcode
argument_list|,
name|nvm
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
call|(
name|u16
call|)
argument_list|(
operator|(
name|offset
operator|+
name|widx
operator|)
operator|*
literal|2
argument_list|)
argument_list|,
name|nvm
operator|->
name|address_bits
argument_list|)
expr_stmt|;
comment|/* Loop to allow for up to whole page write of eeprom */
while|while
condition|(
name|widx
operator|<
name|words
condition|)
block|{
name|u16
name|word_out
init|=
name|data
index|[
name|widx
index|]
decl_stmt|;
name|word_out
operator|=
operator|(
name|word_out
operator|>>
literal|8
operator|)
operator||
operator|(
name|word_out
operator|<<
literal|8
operator|)
expr_stmt|;
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
name|word_out
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|widx
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|offset
operator|+
name|widx
operator|)
operator|*
literal|2
operator|)
operator|%
name|nvm
operator|->
name|page_size
operator|)
operator|==
literal|0
condition|)
block|{
name|e1000_standby_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_nvm_microwire - Writes EEPROM using microwire  *  @hw: pointer to the HW structure  *  @offset: offset within the EEPROM to be written to  *  @words: number of words to write  *  @data: 16 bit word(s) to be written to the EEPROM  *  *  Writes data to EEPROM at offset using microwire interface.  *  *  If e1000_update_nvm_checksum is not called after this function , the  *  EEPROM will most likely contain an invalid checksum.  **/
end_comment

begin_function
name|s32
name|e1000_write_nvm_microwire
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u32
name|eecd
decl_stmt|;
name|u16
name|words_written
init|=
literal|0
decl_stmt|;
name|u16
name|widx
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_nvm_microwire"
argument_list|)
expr_stmt|;
comment|/* A check for invalid values:  offset too large, too many words, 	 * and not enough words. 	 */
if|if
condition|(
operator|(
name|offset
operator|>=
name|nvm
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
operator|(
name|nvm
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"nvm parameter(s) out of bounds\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
name|ret_val
operator|=
name|nvm
operator|->
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|e1000_ready_nvm_eeprom
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|release
goto|;
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
name|NVM_EWEN_OPCODE_MICROWIRE
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|nvm
operator|->
name|opcode_bits
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|nvm
operator|->
name|address_bits
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|e1000_standby_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
while|while
condition|(
name|words_written
operator|<
name|words
condition|)
block|{
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
name|NVM_WRITE_OPCODE_MICROWIRE
argument_list|,
name|nvm
operator|->
name|opcode_bits
argument_list|)
expr_stmt|;
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|offset
operator|+
name|words_written
argument_list|)
argument_list|,
name|nvm
operator|->
name|address_bits
argument_list|)
expr_stmt|;
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
name|data
index|[
name|words_written
index|]
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|e1000_standby_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|widx
operator|=
literal|0
init|;
name|widx
operator|<
literal|200
condition|;
name|widx
operator|++
control|)
block|{
name|eecd
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_DO
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|widx
operator|==
literal|200
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Write did not complete\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|e1000_standby_nvm
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|words_written
operator|++
expr_stmt|;
block|}
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
name|NVM_EWDS_OPCODE_MICROWIRE
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|nvm
operator|->
name|opcode_bits
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|e1000_shift_out_eec_bits
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
call|(
name|u16
call|)
argument_list|(
name|nvm
operator|->
name|address_bits
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|release
label|:
name|nvm
operator|->
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_pba_string_generic - Read device part number  *  @hw: pointer to the HW structure  *  @pba_num: pointer to device part number  *  @pba_num_size: size of part number buffer  *  *  Reads the product board assembly (PBA) number from the EEPROM and stores  *  the value in pba_num.  **/
end_comment

begin_function
name|s32
name|e1000_read_pba_string_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|pba_num
parameter_list|,
name|u32
name|pba_num_size
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|nvm_data
decl_stmt|;
name|u16
name|pba_ptr
decl_stmt|;
name|u16
name|offset
decl_stmt|;
name|u16
name|length
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_pba_string_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pba_num
operator|==
name|NULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PBA string buffer was null\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_INVALID_ARGUMENT
return|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_PBA_OFFSET_0
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_PBA_OFFSET_1
argument_list|,
literal|1
argument_list|,
operator|&
name|pba_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* if nvm_data is not ptr guard the PBA must be in legacy format which 	 * means pba_ptr is actually our second data word for the PBA number 	 * and we can decode it into an ascii string 	 */
if|if
condition|(
name|nvm_data
operator|!=
name|NVM_PBA_PTR_GUARD
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM PBA number is not stored as string\n"
argument_list|)
expr_stmt|;
comment|/* make sure callers buffer is big enough to store the PBA */
if|if
condition|(
name|pba_num_size
operator|<
name|E1000_PBANUM_LENGTH
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PBA string buffer too small\n"
argument_list|)
expr_stmt|;
return|return
name|E1000_ERR_NO_SPACE
return|;
block|}
comment|/* extract hex string from data and pba_ptr */
name|pba_num
index|[
literal|0
index|]
operator|=
operator|(
name|nvm_data
operator|>>
literal|12
operator|)
operator|&
literal|0xF
expr_stmt|;
name|pba_num
index|[
literal|1
index|]
operator|=
operator|(
name|nvm_data
operator|>>
literal|8
operator|)
operator|&
literal|0xF
expr_stmt|;
name|pba_num
index|[
literal|2
index|]
operator|=
operator|(
name|nvm_data
operator|>>
literal|4
operator|)
operator|&
literal|0xF
expr_stmt|;
name|pba_num
index|[
literal|3
index|]
operator|=
name|nvm_data
operator|&
literal|0xF
expr_stmt|;
name|pba_num
index|[
literal|4
index|]
operator|=
operator|(
name|pba_ptr
operator|>>
literal|12
operator|)
operator|&
literal|0xF
expr_stmt|;
name|pba_num
index|[
literal|5
index|]
operator|=
operator|(
name|pba_ptr
operator|>>
literal|8
operator|)
operator|&
literal|0xF
expr_stmt|;
name|pba_num
index|[
literal|6
index|]
operator|=
literal|'-'
expr_stmt|;
name|pba_num
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|pba_num
index|[
literal|8
index|]
operator|=
operator|(
name|pba_ptr
operator|>>
literal|4
operator|)
operator|&
literal|0xF
expr_stmt|;
name|pba_num
index|[
literal|9
index|]
operator|=
name|pba_ptr
operator|&
literal|0xF
expr_stmt|;
comment|/* put a null character on the end of our string */
name|pba_num
index|[
literal|10
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* switch all the data but the '-' to hex char */
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
literal|10
condition|;
name|offset
operator|++
control|)
block|{
if|if
condition|(
name|pba_num
index|[
name|offset
index|]
operator|<
literal|0xA
condition|)
name|pba_num
index|[
name|offset
index|]
operator|+=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|pba_num
index|[
name|offset
index|]
operator|<
literal|0x10
condition|)
name|pba_num
index|[
name|offset
index|]
operator|+=
literal|'A'
operator|-
literal|0xA
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|pba_ptr
argument_list|,
literal|1
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|length
operator|==
literal|0xFFFF
operator|||
name|length
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM PBA number section invalid length\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM_PBA_SECTION
return|;
block|}
comment|/* check if pba_num buffer is big enough */
if|if
condition|(
name|pba_num_size
operator|<
operator|(
operator|(
operator|(
name|u32
operator|)
name|length
operator|*
literal|2
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PBA string buffer too small\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NO_SPACE
return|;
block|}
comment|/* trim pba length from start of string */
name|pba_ptr
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|length
condition|;
name|offset
operator|++
control|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|pba_ptr
operator|+
name|offset
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|pba_num
index|[
name|offset
operator|*
literal|2
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|nvm_data
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|pba_num
index|[
operator|(
name|offset
operator|*
literal|2
operator|)
operator|+
literal|1
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|nvm_data
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
name|pba_num
index|[
name|offset
operator|*
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_pba_length_generic - Read device part number length  *  @hw: pointer to the HW structure  *  @pba_num_size: size of part number buffer  *  *  Reads the product board assembly (PBA) number length from the EEPROM and  *  stores the value in pba_num_size.  **/
end_comment

begin_function
name|s32
name|e1000_read_pba_length_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|pba_num_size
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|nvm_data
decl_stmt|;
name|u16
name|pba_ptr
decl_stmt|;
name|u16
name|length
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_pba_length_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pba_num_size
operator|==
name|NULL
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"PBA buffer size was null\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_INVALID_ARGUMENT
return|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_PBA_OFFSET_0
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_PBA_OFFSET_1
argument_list|,
literal|1
argument_list|,
operator|&
name|pba_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* if data is not ptr guard the PBA must be in legacy format */
if|if
condition|(
name|nvm_data
operator|!=
name|NVM_PBA_PTR_GUARD
condition|)
block|{
operator|*
name|pba_num_size
operator|=
name|E1000_PBANUM_LENGTH
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|pba_ptr
argument_list|,
literal|1
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|length
operator|==
literal|0xFFFF
operator|||
name|length
operator|==
literal|0
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM PBA number section invalid length\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM_PBA_SECTION
return|;
block|}
comment|/* Convert from length in u16 values to u8 chars, add 1 for NULL, 	 * and subtract 2 because length field is included in length. 	 */
operator|*
name|pba_num_size
operator|=
operator|(
operator|(
name|u32
operator|)
name|length
operator|*
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_pba_raw  *  @hw: pointer to the HW structure  *  @eeprom_buf: optional pointer to EEPROM image  *  @eeprom_buf_size: size of EEPROM image in words  *  @max_pba_block_size: PBA block size limit  *  @pba: pointer to output PBA structure  *  *  Reads PBA from EEPROM image when eeprom_buf is not NULL.  *  Reads PBA from physical EEPROM device when eeprom_buf is NULL.  *  **/
end_comment

begin_function
name|s32
name|e1000_read_pba_raw
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|eeprom_buf
parameter_list|,
name|u32
name|eeprom_buf_size
parameter_list|,
name|u16
name|max_pba_block_size
parameter_list|,
name|struct
name|e1000_pba
modifier|*
name|pba
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|pba_block_size
decl_stmt|;
if|if
condition|(
name|pba
operator|==
name|NULL
condition|)
return|return
operator|-
name|E1000_ERR_PARAM
return|;
if|if
condition|(
name|eeprom_buf
operator|==
name|NULL
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
name|NVM_PBA_OFFSET_0
argument_list|,
literal|2
argument_list|,
operator|&
name|pba
operator|->
name|word
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
if|if
condition|(
name|eeprom_buf_size
operator|>
name|NVM_PBA_OFFSET_1
condition|)
block|{
name|pba
operator|->
name|word
index|[
literal|0
index|]
operator|=
name|eeprom_buf
index|[
name|NVM_PBA_OFFSET_0
index|]
expr_stmt|;
name|pba
operator|->
name|word
index|[
literal|1
index|]
operator|=
name|eeprom_buf
index|[
name|NVM_PBA_OFFSET_1
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
block|}
if|if
condition|(
name|pba
operator|->
name|word
index|[
literal|0
index|]
operator|==
name|NVM_PBA_PTR_GUARD
condition|)
block|{
if|if
condition|(
name|pba
operator|->
name|pba_block
operator|==
name|NULL
condition|)
return|return
operator|-
name|E1000_ERR_PARAM
return|;
name|ret_val
operator|=
name|e1000_get_pba_block_size
argument_list|(
name|hw
argument_list|,
name|eeprom_buf
argument_list|,
name|eeprom_buf_size
argument_list|,
operator|&
name|pba_block_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|pba_block_size
operator|>
name|max_pba_block_size
condition|)
return|return
operator|-
name|E1000_ERR_PARAM
return|;
if|if
condition|(
name|eeprom_buf
operator|==
name|NULL
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
name|pba
operator|->
name|word
index|[
literal|1
index|]
argument_list|,
name|pba_block_size
argument_list|,
name|pba
operator|->
name|pba_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
if|if
condition|(
name|eeprom_buf_size
operator|>
call|(
name|u32
call|)
argument_list|(
name|pba
operator|->
name|word
index|[
literal|1
index|]
operator|+
name|pba
operator|->
name|pba_block
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|pba
operator|->
name|pba_block
argument_list|,
operator|&
name|eeprom_buf
index|[
name|pba
operator|->
name|word
index|[
literal|1
index|]
index|]
argument_list|,
name|pba_block_size
operator|*
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_pba_raw  *  @hw: pointer to the HW structure  *  @eeprom_buf: optional pointer to EEPROM image  *  @eeprom_buf_size: size of EEPROM image in words  *  @pba: pointer to PBA structure  *  *  Writes PBA to EEPROM image when eeprom_buf is not NULL.  *  Writes PBA to physical EEPROM device when eeprom_buf is NULL.  *  **/
end_comment

begin_function
name|s32
name|e1000_write_pba_raw
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|eeprom_buf
parameter_list|,
name|u32
name|eeprom_buf_size
parameter_list|,
name|struct
name|e1000_pba
modifier|*
name|pba
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
if|if
condition|(
name|pba
operator|==
name|NULL
condition|)
return|return
operator|-
name|E1000_ERR_PARAM
return|;
if|if
condition|(
name|eeprom_buf
operator|==
name|NULL
condition|)
block|{
name|ret_val
operator|=
name|e1000_write_nvm
argument_list|(
name|hw
argument_list|,
name|NVM_PBA_OFFSET_0
argument_list|,
literal|2
argument_list|,
operator|&
name|pba
operator|->
name|word
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
if|if
condition|(
name|eeprom_buf_size
operator|>
name|NVM_PBA_OFFSET_1
condition|)
block|{
name|eeprom_buf
index|[
name|NVM_PBA_OFFSET_0
index|]
operator|=
name|pba
operator|->
name|word
index|[
literal|0
index|]
expr_stmt|;
name|eeprom_buf
index|[
name|NVM_PBA_OFFSET_1
index|]
operator|=
name|pba
operator|->
name|word
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
block|}
if|if
condition|(
name|pba
operator|->
name|word
index|[
literal|0
index|]
operator|==
name|NVM_PBA_PTR_GUARD
condition|)
block|{
if|if
condition|(
name|pba
operator|->
name|pba_block
operator|==
name|NULL
condition|)
return|return
operator|-
name|E1000_ERR_PARAM
return|;
if|if
condition|(
name|eeprom_buf
operator|==
name|NULL
condition|)
block|{
name|ret_val
operator|=
name|e1000_write_nvm
argument_list|(
name|hw
argument_list|,
name|pba
operator|->
name|word
index|[
literal|1
index|]
argument_list|,
name|pba
operator|->
name|pba_block
index|[
literal|0
index|]
argument_list|,
name|pba
operator|->
name|pba_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
if|if
condition|(
name|eeprom_buf_size
operator|>
call|(
name|u32
call|)
argument_list|(
name|pba
operator|->
name|word
index|[
literal|1
index|]
operator|+
name|pba
operator|->
name|pba_block
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|eeprom_buf
index|[
name|pba
operator|->
name|word
index|[
literal|1
index|]
index|]
argument_list|,
name|pba
operator|->
name|pba_block
argument_list|,
name|pba
operator|->
name|pba_block
index|[
literal|0
index|]
operator|*
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_pba_block_size  *  @hw: pointer to the HW structure  *  @eeprom_buf: optional pointer to EEPROM image  *  @eeprom_buf_size: size of EEPROM image in words  *  @pba_data_size: pointer to output variable  *  *  Returns the size of the PBA block in words. Function operates on EEPROM  *  image if the eeprom_buf pointer is not NULL otherwise it accesses physical  *  EEPROM device.  *  **/
end_comment

begin_function
name|s32
name|e1000_get_pba_block_size
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|eeprom_buf
parameter_list|,
name|u32
name|eeprom_buf_size
parameter_list|,
name|u16
modifier|*
name|pba_block_size
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|pba_word
index|[
literal|2
index|]
decl_stmt|;
name|u16
name|length
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_pba_block_size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom_buf
operator|==
name|NULL
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
name|NVM_PBA_OFFSET_0
argument_list|,
literal|2
argument_list|,
operator|&
name|pba_word
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
if|if
condition|(
name|eeprom_buf_size
operator|>
name|NVM_PBA_OFFSET_1
condition|)
block|{
name|pba_word
index|[
literal|0
index|]
operator|=
name|eeprom_buf
index|[
name|NVM_PBA_OFFSET_0
index|]
expr_stmt|;
name|pba_word
index|[
literal|1
index|]
operator|=
name|eeprom_buf
index|[
name|NVM_PBA_OFFSET_1
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
block|}
if|if
condition|(
name|pba_word
index|[
literal|0
index|]
operator|==
name|NVM_PBA_PTR_GUARD
condition|)
block|{
if|if
condition|(
name|eeprom_buf
operator|==
name|NULL
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
name|pba_word
index|[
literal|1
index|]
operator|+
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
else|else
block|{
if|if
condition|(
name|eeprom_buf_size
operator|>
name|pba_word
index|[
literal|1
index|]
condition|)
name|length
operator|=
name|eeprom_buf
index|[
name|pba_word
index|[
literal|1
index|]
operator|+
literal|0
index|]
expr_stmt|;
else|else
return|return
operator|-
name|E1000_ERR_PARAM
return|;
block|}
if|if
condition|(
name|length
operator|==
literal|0xFFFF
operator|||
name|length
operator|==
literal|0
condition|)
return|return
operator|-
name|E1000_ERR_NVM_PBA_SECTION
return|;
block|}
else|else
block|{
comment|/* PBA number in legacy format, there is no PBA Block. */
name|length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pba_block_size
operator|!=
name|NULL
condition|)
operator|*
name|pba_block_size
operator|=
name|length
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_mac_addr_generic - Read device MAC address  *  @hw: pointer to the HW structure  *  *  Reads the device MAC address from the EEPROM and stores the value.  *  Since devices with two ports use the same EEPROM, we increment the  *  last bit in the MAC address for the second port.  **/
end_comment

begin_function
name|s32
name|e1000_read_mac_addr_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|rar_high
decl_stmt|;
name|u32
name|rar_low
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|rar_high
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RAH
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rar_low
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RAL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_RAL_MAC_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|hw
operator|->
name|mac
operator|.
name|perm_addr
index|[
name|i
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|rar_low
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_RAH_MAC_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|hw
operator|->
name|mac
operator|.
name|perm_addr
index|[
name|i
operator|+
literal|4
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|rar_high
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETH_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
name|i
index|]
operator|=
name|hw
operator|->
name|mac
operator|.
name|perm_addr
index|[
name|i
index|]
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_validate_nvm_checksum_generic - Validate EEPROM checksum  *  @hw: pointer to the HW structure  *  *  Calculates the EEPROM checksum by reading/adding each word of the EEPROM  *  and then verifies that the sum of the EEPROM is equal to 0xBABA.  **/
end_comment

begin_function
name|s32
name|e1000_validate_nvm_checksum_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|checksum
init|=
literal|0
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|nvm_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_validate_nvm_checksum_generic"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|NVM_CHECKSUM_REG
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|checksum
operator|+=
name|nvm_data
expr_stmt|;
block|}
if|if
condition|(
name|checksum
operator|!=
operator|(
name|u16
operator|)
name|NVM_SUM
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Checksum Invalid\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_nvm_checksum_generic - Update EEPROM checksum  *  @hw: pointer to the HW structure  *  *  Updates the EEPROM checksum by reading/adding each word of the EEPROM  *  up to the checksum.  Then calculates the EEPROM checksum and writes the  *  value to the EEPROM.  **/
end_comment

begin_function
name|s32
name|e1000_update_nvm_checksum_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|checksum
init|=
literal|0
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|nvm_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_nvm_checksum"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVM_CHECKSUM_REG
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error while updating checksum.\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|checksum
operator|+=
name|nvm_data
expr_stmt|;
block|}
name|checksum
operator|=
operator|(
name|u16
operator|)
name|NVM_SUM
operator|-
name|checksum
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|write
argument_list|(
name|hw
argument_list|,
name|NVM_CHECKSUM_REG
argument_list|,
literal|1
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT
argument_list|(
literal|"NVM Write Error while updating checksum.\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_reload_nvm_generic - Reloads EEPROM  *  @hw: pointer to the HW structure  *  *  Reloads the EEPROM by setting the "Reinitialize from EEPROM" bit in the  *  extended control register.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_reload_nvm_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl_ext
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_reload_nvm_generic"
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_EE_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

