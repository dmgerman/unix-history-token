begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2012, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"e1000_api.h"
end_include

begin_function_decl
specifier|static
name|s32
name|e1000_validate_mdi_setting_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_set_lan_id_multi_port_pcie
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_config_collision_dist_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_rar_set_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  e1000_init_mac_ops_generic - Initialize MAC function pointers  *  @hw: pointer to the HW structure  *  *  Setups up the function pointers to no-op functions  **/
end_comment

begin_function
name|void
name|e1000_init_mac_ops_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_mac_ops_generic"
argument_list|)
expr_stmt|;
comment|/* General Setup */
name|mac
operator|->
name|ops
operator|.
name|init_params
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|init_hw
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_physical_interface
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_bus_info
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_lan_id
operator|=
name|e1000_set_lan_id_multi_port_pcie
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|read_mac_addr
operator|=
name|e1000_read_mac_addr_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|config_collision_dist
operator|=
name|e1000_config_collision_dist_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_hw_cntrs
operator|=
name|e1000_null_mac_generic
expr_stmt|;
comment|/* LED */
name|mac
operator|->
name|ops
operator|.
name|cleanup_led
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_led
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|blink_led
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|led_on
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|led_off
operator|=
name|e1000_null_ops_generic
expr_stmt|;
comment|/* LINK */
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_link_up_info
operator|=
name|e1000_null_link_info
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|check_for_link
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|wait_autoneg
operator|=
name|e1000_wait_autoneg_generic
expr_stmt|;
comment|/* Management */
name|mac
operator|->
name|ops
operator|.
name|check_mng_mode
operator|=
name|e1000_null_mng_mode
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|mng_host_if_write
operator|=
name|e1000_mng_host_if_write_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|mng_write_cmd_header
operator|=
name|e1000_mng_write_cmd_header_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|mng_enable_host_if
operator|=
name|e1000_mng_enable_host_if_generic
expr_stmt|;
comment|/* VLAN, MC, etc. */
name|mac
operator|->
name|ops
operator|.
name|update_mc_addr_list
operator|=
name|e1000_null_update_mc
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vfta
operator|=
name|e1000_null_mac_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|write_vfta
operator|=
name|e1000_null_write_vfta
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|rar_set
operator|=
name|e1000_rar_set_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|validate_mdi_setting
operator|=
name|e1000_validate_mdi_setting_generic
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_ops_generic - No-op function, returns 0  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|s32
name|e1000_null_ops_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_ops_generic"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_mac_generic - No-op function, return void  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|void
name|e1000_null_mac_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_mac_generic"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_link_info - No-op function, return 0  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|s32
name|e1000_null_link_info
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|s
parameter_list|,
name|u16
modifier|*
name|d
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_link_info"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_mng_mode - No-op function, return FALSE  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|bool
name|e1000_null_mng_mode
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_mng_mode"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_update_mc - No-op function, return void  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|void
name|e1000_null_update_mc
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|h
parameter_list|,
name|u32
name|a
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_update_mc"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_write_vfta - No-op function, return void  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|void
name|e1000_null_write_vfta
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|a
parameter_list|,
name|u32
name|b
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_write_vfta"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_null_rar_set - No-op function, return void  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|void
name|e1000_null_rar_set
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|h
parameter_list|,
name|u32
name|a
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_null_rar_set"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_bus_info_pci_generic - Get PCI(x) bus information  *  @hw: pointer to the HW structure  *  *  Determines and stores the system bus information for a particular  *  network interface.  The following bus information is determined and stored:  *  bus speed, bus width, type (PCI/PCIx), and PCI(-x) function.  **/
end_comment

begin_function
name|s32
name|e1000_get_bus_info_pci_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|e1000_bus_info
modifier|*
name|bus
init|=
operator|&
name|hw
operator|->
name|bus
decl_stmt|;
name|u32
name|status
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_bus_info_pci_generic"
argument_list|)
expr_stmt|;
comment|/* PCI or PCI-X? */
name|bus
operator|->
name|type
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_PCIX_MODE
operator|)
condition|?
name|e1000_bus_type_pcix
else|:
name|e1000_bus_type_pci
expr_stmt|;
comment|/* Bus speed */
if|if
condition|(
name|bus
operator|->
name|type
operator|==
name|e1000_bus_type_pci
condition|)
block|{
name|bus
operator|->
name|speed
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_PCI66
operator|)
condition|?
name|e1000_bus_speed_66
else|:
name|e1000_bus_speed_33
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|status
operator|&
name|E1000_STATUS_PCIX_SPEED
condition|)
block|{
case|case
name|E1000_STATUS_PCIX_SPEED_66
case|:
name|bus
operator|->
name|speed
operator|=
name|e1000_bus_speed_66
expr_stmt|;
break|break;
case|case
name|E1000_STATUS_PCIX_SPEED_100
case|:
name|bus
operator|->
name|speed
operator|=
name|e1000_bus_speed_100
expr_stmt|;
break|break;
case|case
name|E1000_STATUS_PCIX_SPEED_133
case|:
name|bus
operator|->
name|speed
operator|=
name|e1000_bus_speed_133
expr_stmt|;
break|break;
default|default:
name|bus
operator|->
name|speed
operator|=
name|e1000_bus_speed_reserved
expr_stmt|;
break|break;
block|}
block|}
comment|/* Bus width */
name|bus
operator|->
name|width
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_BUS64
operator|)
condition|?
name|e1000_bus_width_64
else|:
name|e1000_bus_width_32
expr_stmt|;
comment|/* Which PCI(-X) function? */
name|mac
operator|->
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_bus_info_pcie_generic - Get PCIe bus information  *  @hw: pointer to the HW structure  *  *  Determines and stores the system bus information for a particular  *  network interface.  The following bus information is determined and stored:  *  bus speed, bus width, type (PCIe), and PCIe function.  **/
end_comment

begin_function
name|s32
name|e1000_get_bus_info_pcie_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|e1000_bus_info
modifier|*
name|bus
init|=
operator|&
name|hw
operator|->
name|bus
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|pcie_link_status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_bus_info_pcie_generic"
argument_list|)
expr_stmt|;
name|bus
operator|->
name|type
operator|=
name|e1000_bus_type_pci_express
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_pcie_cap_reg
argument_list|(
name|hw
argument_list|,
name|PCIE_LINK_STATUS
argument_list|,
operator|&
name|pcie_link_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|bus
operator|->
name|width
operator|=
name|e1000_bus_width_unknown
expr_stmt|;
name|bus
operator|->
name|speed
operator|=
name|e1000_bus_speed_unknown
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|pcie_link_status
operator|&
name|PCIE_LINK_SPEED_MASK
condition|)
block|{
case|case
name|PCIE_LINK_SPEED_2500
case|:
name|bus
operator|->
name|speed
operator|=
name|e1000_bus_speed_2500
expr_stmt|;
break|break;
case|case
name|PCIE_LINK_SPEED_5000
case|:
name|bus
operator|->
name|speed
operator|=
name|e1000_bus_speed_5000
expr_stmt|;
break|break;
default|default:
name|bus
operator|->
name|speed
operator|=
name|e1000_bus_speed_unknown
expr_stmt|;
break|break;
block|}
name|bus
operator|->
name|width
operator|=
operator|(
expr|enum
name|e1000_bus_width
operator|)
operator|(
operator|(
name|pcie_link_status
operator|&
name|PCIE_LINK_WIDTH_MASK
operator|)
operator|>>
name|PCIE_LINK_WIDTH_SHIFT
operator|)
expr_stmt|;
block|}
name|mac
operator|->
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_lan_id_multi_port_pcie - Set LAN id for PCIe multiple port devices  *  *  @hw: pointer to the HW structure  *  *  Determines the LAN function id by reading memory-mapped registers  *  and swaps the port value if requested.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_set_lan_id_multi_port_pcie
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_bus_info
modifier|*
name|bus
init|=
operator|&
name|hw
operator|->
name|bus
decl_stmt|;
name|u32
name|reg
decl_stmt|;
comment|/* 	 * The status register reports the correct function number 	 * for the device regardless of function swap state. 	 */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|bus
operator|->
name|func
operator|=
operator|(
name|reg
operator|&
name|E1000_STATUS_FUNC_MASK
operator|)
operator|>>
name|E1000_STATUS_FUNC_SHIFT
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_lan_id_multi_port_pci - Set LAN id for PCI multiple port devices  *  @hw: pointer to the HW structure  *  *  Determines the LAN function id by reading PCI config space.  **/
end_comment

begin_function
name|void
name|e1000_set_lan_id_multi_port_pci
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_bus_info
modifier|*
name|bus
init|=
operator|&
name|hw
operator|->
name|bus
decl_stmt|;
name|u16
name|pci_header_type
decl_stmt|;
name|u32
name|status
decl_stmt|;
name|e1000_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCI_HEADER_TYPE_REGISTER
argument_list|,
operator|&
name|pci_header_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_header_type
operator|&
name|PCI_HEADER_TYPE_MULTIFUNC
condition|)
block|{
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|bus
operator|->
name|func
operator|=
operator|(
name|status
operator|&
name|E1000_STATUS_FUNC_MASK
operator|)
operator|>>
name|E1000_STATUS_FUNC_SHIFT
expr_stmt|;
block|}
else|else
block|{
name|bus
operator|->
name|func
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_set_lan_id_single_port - Set LAN id for a single port device  *  @hw: pointer to the HW structure  *  *  Sets the LAN function id to zero for a single port device.  **/
end_comment

begin_function
name|void
name|e1000_set_lan_id_single_port
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_bus_info
modifier|*
name|bus
init|=
operator|&
name|hw
operator|->
name|bus
decl_stmt|;
name|bus
operator|->
name|func
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_clear_vfta_generic - Clear VLAN filter table  *  @hw: pointer to the HW structure  *  *  Clears the register array which contains the VLAN filter table by  *  setting all the values to 0.  **/
end_comment

begin_function
name|void
name|e1000_clear_vfta_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|offset
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clear_vfta_generic"
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|E1000_VLAN_FILTER_TBL_SIZE
condition|;
name|offset
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VFTA
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_write_vfta_generic - Write value to VLAN filter table  *  @hw: pointer to the HW structure  *  @offset: register offset in VLAN filter table  *  @value: register value written to VLAN filter table  *  *  Writes value at the given offset in the register array which stores  *  the VLAN filter table.  **/
end_comment

begin_function
name|void
name|e1000_write_vfta_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|value
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_vfta_generic"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VFTA
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_rx_addrs_generic - Initialize receive address's  *  @hw: pointer to the HW structure  *  @rar_count: receive address registers  *  *  Setup the receive address registers by setting the base receive address  *  register to the devices MAC address and clearing all the other receive  *  address registers to 0.  **/
end_comment

begin_function
name|void
name|e1000_init_rx_addrs_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|rar_count
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u8
name|mac_addr
index|[
name|ETH_ADDR_LEN
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_rx_addrs_generic"
argument_list|)
expr_stmt|;
comment|/* Setup the receive address */
name|DEBUGOUT
argument_list|(
literal|"Programming MAC Address into RAR[0]\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|rar_set
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Zero out the other (rar_entry_count - 1) receive addresses */
name|DEBUGOUT1
argument_list|(
literal|"Clearing RAR[1-%u]\n"
argument_list|,
name|rar_count
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rar_count
condition|;
name|i
operator|++
control|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|rar_set
argument_list|(
name|hw
argument_list|,
name|mac_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_alt_mac_addr_generic - Check for alternate MAC addr  *  @hw: pointer to the HW structure  *  *  Checks the nvm for an alternate MAC address.  An alternate MAC address  *  can be setup by pre-boot software and must be treated like a permanent  *  address and must override the actual permanent MAC address. If an  *  alternate MAC address is found it is programmed into RAR0, replacing  *  the permanent address that was installed into RAR0 by the Si on reset.  *  This function will return SUCCESS unless it encounters an error while  *  reading the EEPROM.  **/
end_comment

begin_function
name|s32
name|e1000_check_alt_mac_addr_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|offset
decl_stmt|,
name|nvm_alt_mac_addr_offset
decl_stmt|,
name|nvm_data
decl_stmt|;
name|u8
name|alt_mac_addr
index|[
name|ETH_ADDR_LEN
index|]
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_alt_mac_addr_generic"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_COMPAT
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* not supported on older hardware or 82573 */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_82571
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82573
operator|)
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* 	 * Alternate MAC address is handled by the option ROM for 82580 	 * and newer. SW support not required. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_82580
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_ALT_MAC_ADDR_PTR
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_alt_mac_addr_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
operator|(
name|nvm_alt_mac_addr_offset
operator|==
literal|0xFFFF
operator|)
operator|||
operator|(
name|nvm_alt_mac_addr_offset
operator|==
literal|0x0000
operator|)
condition|)
comment|/* There is no Alternate MAC Address */
return|return
name|E1000_SUCCESS
return|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
name|E1000_FUNC_1
condition|)
name|nvm_alt_mac_addr_offset
operator|+=
name|E1000_ALT_MAC_ADDRESS_OFFSET_LAN1
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
name|E1000_FUNC_2
condition|)
name|nvm_alt_mac_addr_offset
operator|+=
name|E1000_ALT_MAC_ADDRESS_OFFSET_LAN2
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
name|E1000_FUNC_3
condition|)
name|nvm_alt_mac_addr_offset
operator|+=
name|E1000_ALT_MAC_ADDRESS_OFFSET_LAN3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETH_ADDR_LEN
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|offset
operator|=
name|nvm_alt_mac_addr_offset
operator|+
operator|(
name|i
operator|>>
literal|1
operator|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|alt_mac_addr
index|[
name|i
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|nvm_data
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|alt_mac_addr
index|[
name|i
operator|+
literal|1
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|nvm_data
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* if multicast bit is set, the alternate address will not be used */
if|if
condition|(
name|alt_mac_addr
index|[
literal|0
index|]
operator|&
literal|0x01
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Ignoring Alternate Mac Address with MC bit set\n"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
comment|/* 	 * We have a valid alternate MAC address, and we want to treat it the 	 * same as the normal permanent MAC address stored by the HW into the 	 * RAR. Do this by mapping this address into RAR0. 	 */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|rar_set
argument_list|(
name|hw
argument_list|,
name|alt_mac_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_rar_set_generic - Set receive address register  *  @hw: pointer to the HW structure  *  @addr: pointer to the receive address  *  @index: receive address array register  *  *  Sets the receive address array register at index to the address passed  *  in by addr.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_rar_set_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|index
parameter_list|)
block|{
name|u32
name|rar_low
decl_stmt|,
name|rar_high
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_rar_set_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * HW expects these in little endian so we reverse the byte order 	 * from network order (big endian) to little endian 	 */
name|rar_low
operator|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|rar_high
operator|=
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|u32
operator|)
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
comment|/* If MAC address zero, no need to set the AV bit */
if|if
condition|(
name|rar_low
operator|||
name|rar_high
condition|)
name|rar_high
operator||=
name|E1000_RAH_AV
expr_stmt|;
comment|/* 	 * Some bridges will combine consecutive 32-bit writes into 	 * a single burst write, which will malfunction on some parts. 	 * The flushes avoid this. 	 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RAL
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_low
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RAH
argument_list|(
name|index
argument_list|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_hash_mc_addr_generic - Generate a multicast hash value  *  @hw: pointer to the HW structure  *  @mc_addr: pointer to a multicast address  *  *  Generates a multicast address hash value which is used to determine  *  the multicast filter table array address and new table value.  **/
end_comment

begin_function
name|u32
name|e1000_hash_mc_addr_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr
parameter_list|)
block|{
name|u32
name|hash_value
decl_stmt|,
name|hash_mask
decl_stmt|;
name|u8
name|bit_shift
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_hash_mc_addr_generic"
argument_list|)
expr_stmt|;
comment|/* Register count multiplied by bits per register */
name|hash_mask
operator|=
operator|(
name|hw
operator|->
name|mac
operator|.
name|mta_reg_count
operator|*
literal|32
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 	 * For a mc_filter_type of 0, bit_shift is the number of left-shifts 	 * where 0xFF would still fall within the hash mask. 	 */
while|while
condition|(
name|hash_mask
operator|>>
name|bit_shift
operator|!=
literal|0xFF
condition|)
name|bit_shift
operator|++
expr_stmt|;
comment|/* 	 * The portion of the address that is used for the hash table 	 * is determined by the mc_filter_type setting. 	 * The algorithm is such that there is a total of 8 bits of shifting. 	 * The bit_shift for a mc_filter_type of 0 represents the number of 	 * left-shifts where the MSB of mc_addr[5] would still fall within 	 * the hash_mask.  Case 0 does this exactly.  Since there are a total 	 * of 8 bits of shifting, then mc_addr[4] will shift right the 	 * remaining number of bits. Thus 8 - bit_shift.  The rest of the 	 * cases are a variation of this algorithm...essentially raising the 	 * number of bits to shift mc_addr[5] left, while still keeping the 	 * 8-bit shifting total. 	 * 	 * For example, given the following Destination MAC Address and an 	 * mta register count of 128 (thus a 4096-bit vector and 0xFFF mask), 	 * we can see that the bit_shift for case 0 is 4.  These are the hash 	 * values resulting from each mc_filter_type... 	 * [0] [1] [2] [3] [4] [5] 	 * 01  AA  00  12  34  56 	 * LSB		 MSB 	 * 	 * case 0: hash_value = ((0x34>> 4) | (0x56<< 4))& 0xFFF = 0x563 	 * case 1: hash_value = ((0x34>> 3) | (0x56<< 5))& 0xFFF = 0xAC6 	 * case 2: hash_value = ((0x34>> 2) | (0x56<< 6))& 0xFFF = 0x163 	 * case 3: hash_value = ((0x34>> 0) | (0x56<< 8))& 0xFFF = 0x634 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
condition|)
block|{
default|default:
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|bit_shift
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bit_shift
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|bit_shift
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
name|hash_value
operator|=
name|hash_mask
operator|&
operator|(
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
operator|(
literal|8
operator|-
name|bit_shift
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
name|bit_shift
operator|)
operator|)
operator|)
expr_stmt|;
return|return
name|hash_value
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_mc_addr_list_generic - Update Multicast addresses  *  @hw: pointer to the HW structure  *  @mc_addr_list: array of multicast addresses to program  *  @mc_addr_count: number of multicast addresses to program  *  *  Updates entire Multicast Table Array.  *  The caller must have a packed mc_addr_list of multicast addresses.  **/
end_comment

begin_function
name|void
name|e1000_update_mc_addr_list_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr_list
parameter_list|,
name|u32
name|mc_addr_count
parameter_list|)
block|{
name|u32
name|hash_value
decl_stmt|,
name|hash_bit
decl_stmt|,
name|hash_reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_mc_addr_list_generic"
argument_list|)
expr_stmt|;
comment|/* clear mta_shadow */
name|memset
argument_list|(
operator|&
name|hw
operator|->
name|mac
operator|.
name|mta_shadow
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|mta_shadow
argument_list|)
argument_list|)
expr_stmt|;
comment|/* update mta_shadow from mc_addr_list */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u32
operator|)
name|i
operator|<
name|mc_addr_count
condition|;
name|i
operator|++
control|)
block|{
name|hash_value
operator|=
name|e1000_hash_mc_addr_generic
argument_list|(
name|hw
argument_list|,
name|mc_addr_list
argument_list|)
expr_stmt|;
name|hash_reg
operator|=
operator|(
name|hash_value
operator|>>
literal|5
operator|)
operator|&
operator|(
name|hw
operator|->
name|mac
operator|.
name|mta_reg_count
operator|-
literal|1
operator|)
expr_stmt|;
name|hash_bit
operator|=
name|hash_value
operator|&
literal|0x1F
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|mta_shadow
index|[
name|hash_reg
index|]
operator||=
operator|(
literal|1
operator|<<
name|hash_bit
operator|)
expr_stmt|;
name|mc_addr_list
operator|+=
operator|(
name|ETH_ADDR_LEN
operator|)
expr_stmt|;
block|}
comment|/* replace the entire MTA table */
for|for
control|(
name|i
operator|=
name|hw
operator|->
name|mac
operator|.
name|mta_reg_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|i
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|mta_shadow
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_pcix_mmrbc_workaround_generic - Fix incorrect MMRBC value  *  @hw: pointer to the HW structure  *  *  In certain situations, a system BIOS may report that the PCIx maximum  *  memory read byte count (MMRBC) value is higher than than the actual  *  value. We check the PCIx command register with the current PCIx status  *  register.  **/
end_comment

begin_function
name|void
name|e1000_pcix_mmrbc_workaround_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|cmd_mmrbc
decl_stmt|;
name|u16
name|pcix_cmd
decl_stmt|;
name|u16
name|pcix_stat_hi_word
decl_stmt|;
name|u16
name|stat_mmrbc
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_pcix_mmrbc_workaround_generic"
argument_list|)
expr_stmt|;
comment|/* Workaround for PCI-X issue when BIOS sets MMRBC incorrectly */
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|type
operator|!=
name|e1000_bus_type_pcix
condition|)
return|return;
name|e1000_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_COMMAND_REGISTER
argument_list|,
operator|&
name|pcix_cmd
argument_list|)
expr_stmt|;
name|e1000_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_STATUS_REGISTER_HI
argument_list|,
operator|&
name|pcix_stat_hi_word
argument_list|)
expr_stmt|;
name|cmd_mmrbc
operator|=
operator|(
name|pcix_cmd
operator|&
name|PCIX_COMMAND_MMRBC_MASK
operator|)
operator|>>
name|PCIX_COMMAND_MMRBC_SHIFT
expr_stmt|;
name|stat_mmrbc
operator|=
operator|(
name|pcix_stat_hi_word
operator|&
name|PCIX_STATUS_HI_MMRBC_MASK
operator|)
operator|>>
name|PCIX_STATUS_HI_MMRBC_SHIFT
expr_stmt|;
if|if
condition|(
name|stat_mmrbc
operator|==
name|PCIX_STATUS_HI_MMRBC_4K
condition|)
name|stat_mmrbc
operator|=
name|PCIX_STATUS_HI_MMRBC_2K
expr_stmt|;
if|if
condition|(
name|cmd_mmrbc
operator|>
name|stat_mmrbc
condition|)
block|{
name|pcix_cmd
operator|&=
operator|~
name|PCIX_COMMAND_MMRBC_MASK
expr_stmt|;
name|pcix_cmd
operator||=
name|stat_mmrbc
operator|<<
name|PCIX_COMMAND_MMRBC_SHIFT
expr_stmt|;
name|e1000_write_pci_cfg
argument_list|(
name|hw
argument_list|,
name|PCIX_COMMAND_REGISTER
argument_list|,
operator|&
name|pcix_cmd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_clear_hw_cntrs_base_generic - Clear base hardware counters  *  @hw: pointer to the HW structure  *  *  Clears the base hardware counters by reading the counter registers.  **/
end_comment

begin_function
name|void
name|e1000_clear_hw_cntrs_base_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_clear_hw_cntrs_base_generic"
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CRCERRS
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SYMERRS
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SCC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ECOL
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MCC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LATECOL
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_COLC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SEC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RLEC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_XONRXC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_XONTXC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_XOFFRXC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_XOFFTXC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCRUC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GPRC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_BPRC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPRC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GPTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GORCL
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GORCH
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GOTCL
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GOTCH
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RNBC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RUC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RFC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ROC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RJC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TORL
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TORH
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TOTL
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TOTH
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TPR
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TPT
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_BPTC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_copper_link_generic - Check for link (Copper)  *  @hw: pointer to the HW structure  *  *  Checks to see of the link status of the hardware has changed.  If a  *  change in link status has been detected, then we read the PHY registers  *  to get the current speed/duplex if link exists.  **/
end_comment

begin_function
name|s32
name|e1000_check_for_copper_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|bool
name|link
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_copper_link"
argument_list|)
expr_stmt|;
comment|/* 	 * We only want to go out to the PHY registers to see if Auto-Neg 	 * has completed and/or if our link status has changed.  The 	 * get_link_status flag is set upon receiving a Link Status 	 * Change or Rx Sequence Error interrupt. 	 */
if|if
condition|(
operator|!
name|mac
operator|->
name|get_link_status
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* 	 * First we want to see if the MII Status Register reports 	 * link.  If so, then we want to get the current speed/duplex 	 * of the PHY. 	 */
name|ret_val
operator|=
name|e1000_phy_has_link_generic
argument_list|(
name|hw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
name|link
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* No link detected */
name|mac
operator|->
name|get_link_status
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Check if there was DownShift, must be checked 	 * immediately after link-up 	 */
name|e1000_check_downshift_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 	 * If we are forcing speed/duplex, then we simply return since 	 * we have already determined whether we have link or not. 	 */
if|if
condition|(
operator|!
name|mac
operator|->
name|autoneg
condition|)
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
comment|/* 	 * Auto-Neg is enabled.  Auto Speed Detection takes care 	 * of MAC speed/duplex configuration.  So we only need to 	 * configure Collision Distance in the MAC. 	 */
name|mac
operator|->
name|ops
operator|.
name|config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 	 * Configure Flow Control now that Auto-Neg has completed. 	 * First, we need to restore the desired flow control 	 * settings because we may have had to re-autoneg with a 	 * different link partner. 	 */
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_fiber_link_generic - Check for link (Fiber)  *  @hw: pointer to the HW structure  *  *  Checks for link up on the hardware.  If link is not up and we have  *  a signal, then we need to force link up.  **/
end_comment

begin_function
name|s32
name|e1000_check_for_fiber_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|rxcw
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|u32
name|status
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_fiber_link_generic"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|rxcw
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCW
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't have link (auto-negotiation failed or link partner 	 * cannot auto-negotiate), the cable is plugged in (we have signal), 	 * and our link partner is not trying to auto-negotiate with us (we 	 * are receiving idles or data), we need to force link up. We also 	 * need to give auto-negotiation time to complete, in case the cable 	 * was just plugged in. The autoneg_failed flag does this. 	 */
comment|/* (ctrl& E1000_CTRL_SWDPIN1) == 1 == have signal */
if|if
condition|(
operator|(
name|ctrl
operator|&
name|E1000_CTRL_SWDPIN1
operator|)
operator|&&
operator|!
operator|(
name|status
operator|&
name|E1000_STATUS_LU
operator|)
operator|&&
operator|!
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|mac
operator|->
name|autoneg_failed
condition|)
block|{
name|mac
operator|->
name|autoneg_failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"NOT Rx'ing /C/, disable AutoNeg and force link.\n"
argument_list|)
expr_stmt|;
comment|/* Disable auto-negotiation in the TXCW register */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
operator|(
name|mac
operator|->
name|txcw
operator|&
operator|~
name|E1000_TXCW_ANE
operator|)
argument_list|)
expr_stmt|;
comment|/* Force link-up and also force full-duplex. */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_SLU
operator||
name|E1000_CTRL_FD
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Configure Flow Control after forcing link up. */
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ctrl
operator|&
name|E1000_CTRL_SLU
operator|)
operator|&&
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
condition|)
block|{
comment|/* 		 * If we are forcing link and we are receiving /C/ ordered 		 * sets, re-enable auto-negotiation in the TXCW register 		 * and disable forced link in the Device Control register 		 * in an attempt to auto-negotiate with our link partner. 		 */
name|DEBUGOUT
argument_list|(
literal|"Rx'ing /C/, enable AutoNeg and stop forcing link.\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
name|mac
operator|->
name|txcw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
operator|(
name|ctrl
operator|&
operator|~
name|E1000_CTRL_SLU
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|->
name|serdes_has_link
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_serdes_link_generic - Check for link (Serdes)  *  @hw: pointer to the HW structure  *  *  Checks for link up on the hardware.  If link is not up and we have  *  a signal, then we need to force link up.  **/
end_comment

begin_function
name|s32
name|e1000_check_for_serdes_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|rxcw
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|u32
name|status
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_serdes_link_generic"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
name|rxcw
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCW
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't have link (auto-negotiation failed or link partner 	 * cannot auto-negotiate), and our link partner is not trying to 	 * auto-negotiate with us (we are receiving idles or data), 	 * we need to force link up. We also need to give auto-negotiation 	 * time to complete. 	 */
comment|/* (ctrl& E1000_CTRL_SWDPIN1) == 1 == have signal */
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|E1000_STATUS_LU
operator|)
operator|&&
operator|!
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|mac
operator|->
name|autoneg_failed
condition|)
block|{
name|mac
operator|->
name|autoneg_failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
name|DEBUGOUT
argument_list|(
literal|"NOT Rx'ing /C/, disable AutoNeg and force link.\n"
argument_list|)
expr_stmt|;
comment|/* Disable auto-negotiation in the TXCW register */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
operator|(
name|mac
operator|->
name|txcw
operator|&
operator|~
name|E1000_TXCW_ANE
operator|)
argument_list|)
expr_stmt|;
comment|/* Force link-up and also force full-duplex. */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
operator|(
name|E1000_CTRL_SLU
operator||
name|E1000_CTRL_FD
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Configure Flow Control after forcing link up. */
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ctrl
operator|&
name|E1000_CTRL_SLU
operator|)
operator|&&
operator|(
name|rxcw
operator|&
name|E1000_RXCW_C
operator|)
condition|)
block|{
comment|/* 		 * If we are forcing link and we are receiving /C/ ordered 		 * sets, re-enable auto-negotiation in the TXCW register 		 * and disable forced link in the Device Control register 		 * in an attempt to auto-negotiate with our link partner. 		 */
name|DEBUGOUT
argument_list|(
literal|"Rx'ing /C/, enable AutoNeg and stop forcing link.\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
name|mac
operator|->
name|txcw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
operator|(
name|ctrl
operator|&
operator|~
name|E1000_CTRL_SLU
operator|)
argument_list|)
expr_stmt|;
name|mac
operator|->
name|serdes_has_link
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|E1000_TXCW_ANE
operator|&
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * If we force link for non-auto-negotiation switch, check 		 * link status based on MAC synchronization for internal 		 * serdes media type. 		 */
comment|/* SYNCH bit and IV bit are sticky. */
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|rxcw
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCW
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxcw
operator|&
name|E1000_RXCW_SYNCH
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|rxcw
operator|&
name|E1000_RXCW_IV
operator|)
condition|)
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|TRUE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"SERDES: Link up - forced.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|FALSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"SERDES: Link down - force failed.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|E1000_TXCW_ANE
operator|&
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|)
condition|)
block|{
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_LU
condition|)
block|{
comment|/* SYNCH bit and IV bit are sticky, so reread rxcw. */
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|rxcw
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCW
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxcw
operator|&
name|E1000_RXCW_SYNCH
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|rxcw
operator|&
name|E1000_RXCW_IV
operator|)
condition|)
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|TRUE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"SERDES: Link up - autoneg completed successfully.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|FALSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"SERDES: Link down - invalid codewords detected in autoneg.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|FALSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"SERDES: Link down - no sync.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|FALSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"SERDES: Link down - autoneg failed\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_default_fc_generic - Set flow control default values  *  @hw: pointer to the HW structure  *  *  Read the EEPROM for the default values for flow control and store the  *  values.  **/
end_comment

begin_function
name|s32
name|e1000_set_default_fc_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|nvm_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_default_fc_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Read and store word 0x0F of the EEPROM. This word contains bits 	 * that determine the hardware's default PAUSE (flow control) mode, 	 * a bit that determines whether the HW defaults to enabling or 	 * disabling auto-negotiation, and the direction of the 	 * SW defined pins. If there is no SW over-ride of the flow 	 * control setting, then the variable hw->fc will 	 * be initialized based on a value in the EEPROM. 	 */
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_INIT_CONTROL2_REG
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|nvm_data
operator|&
name|NVM_WORD0F_PAUSE_MASK
operator|)
condition|)
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|e1000_fc_none
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|nvm_data
operator|&
name|NVM_WORD0F_PAUSE_MASK
operator|)
operator|==
name|NVM_WORD0F_ASM_DIR
condition|)
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|e1000_fc_tx_pause
expr_stmt|;
else|else
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|e1000_fc_full
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_link_generic - Setup flow control and link settings  *  @hw: pointer to the HW structure  *  *  Determines which flow control settings to use, then configures flow  *  control.  Calls the appropriate media-specific link configuration  *  function.  Assuming the adapter has a valid link partner, a valid link  *  should be established.  Assumes the hardware has previously been reset  *  and the transmitter and receiver are not enabled.  **/
end_comment

begin_function
name|s32
name|e1000_setup_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_link_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * In the case of the phy reset being blocked, we already have a link. 	 * We do not need to set it up again. 	 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_reset_block
operator|&&
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|check_reset_block
argument_list|(
name|hw
argument_list|)
condition|)
return|return
name|E1000_SUCCESS
return|;
comment|/* 	 * If requested flow control is set to default, set flow control 	 * based on the EEPROM flow control settings. 	 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|e1000_fc_default
condition|)
block|{
name|ret_val
operator|=
name|e1000_set_default_fc_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
block|}
comment|/* 	 * Save off the requested flow control mode for use later.  Depending 	 * on the link partner's capabilities, we may or may not use this mode. 	 */
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|hw
operator|->
name|fc
operator|.
name|requested_mode
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"After fix-ups FlowControl is now = %x\n"
argument_list|,
name|hw
operator|->
name|fc
operator|.
name|current_mode
argument_list|)
expr_stmt|;
comment|/* Call the necessary media_type subroutine to configure the link. */
name|ret_val
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_physical_interface
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* 	 * Initialize the flow control address, type, and PAUSE timer 	 * registers to their default values.  This is done even if flow 	 * control is disabled, because it does not hurt anything to 	 * initialize these registers. 	 */
name|DEBUGOUT
argument_list|(
literal|"Initializing the Flow Control address, type and timer regs\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCT
argument_list|,
name|FLOW_CONTROL_TYPE
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCAH
argument_list|,
name|FLOW_CONTROL_ADDRESS_HIGH
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCAL
argument_list|,
name|FLOW_CONTROL_ADDRESS_LOW
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCTTV
argument_list|,
name|hw
operator|->
name|fc
operator|.
name|pause_time
argument_list|)
expr_stmt|;
return|return
name|e1000_set_fc_watermarks_generic
argument_list|(
name|hw
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_commit_fc_settings_generic - Configure flow control  *  @hw: pointer to the HW structure  *  *  Write the flow control settings to the Transmit Config Word Register (TXCW)  *  base on the flow control settings in e1000_mac_info.  **/
end_comment

begin_function
name|s32
name|e1000_commit_fc_settings_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|txcw
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_commit_fc_settings_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Check for a software override of the flow control settings, and 	 * setup the device accordingly.  If auto-negotiation is enabled, then 	 * software will have to set the "PAUSE" bits to the correct value in 	 * the Transmit Config Word Register (TXCW) and re-start auto- 	 * negotiation.  However, if auto-negotiation is disabled, then 	 * software will have to manually configure the two flow control enable 	 * bits in the CTRL register. 	 * 	 * The possible values of the "fc" parameter are: 	 *      0:  Flow control is completely disabled 	 *      1:  Rx flow control is enabled (we can receive pause frames, 	 *          but not send pause frames). 	 *      2:  Tx flow control is enabled (we can send pause frames but we 	 *          do not support receiving pause frames). 	 *      3:  Both Rx and Tx flow control (symmetric) are enabled. 	 */
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
condition|)
block|{
case|case
name|e1000_fc_none
case|:
comment|/* Flow control completely disabled by a software over-ride. */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_fc_rx_pause
case|:
comment|/* 		 * Rx Flow control is enabled and Tx Flow control is disabled 		 * by a software over-ride. Since there really isn't a way to 		 * advertise that we are capable of Rx Pause ONLY, we will 		 * advertise that we support both symmetric and asymmetric Rx 		 * PAUSE.  Later, we will disable the adapter's ability to send 		 * PAUSE frames. 		 */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_PAUSE_MASK
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_fc_tx_pause
case|:
comment|/* 		 * Tx Flow control is enabled, and Rx Flow control is disabled, 		 * by a software over-ride. 		 */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_ASM_DIR
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_fc_full
case|:
comment|/* 		 * Flow control (both Rx and Tx) is enabled by a software 		 * over-ride. 		 */
name|txcw
operator|=
operator|(
name|E1000_TXCW_ANE
operator||
name|E1000_TXCW_FD
operator||
name|E1000_TXCW_PAUSE_MASK
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
break|break;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXCW
argument_list|,
name|txcw
argument_list|)
expr_stmt|;
name|mac
operator|->
name|txcw
operator|=
name|txcw
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_poll_fiber_serdes_link_generic - Poll for link up  *  @hw: pointer to the HW structure  *  *  Polls for link up by reading the status register, if link fails to come  *  up with auto-negotiation, then the link is forced if a signal is detected.  **/
end_comment

begin_function
name|s32
name|e1000_poll_fiber_serdes_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|status
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_poll_fiber_serdes_link_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * If we have a signal (the cable is plugged in, or assumed TRUE for 	 * serdes media) then poll for a "Link-Up" indication in the Device 	 * Status Register.  Time-out if a link isn't seen in 500 milliseconds 	 * seconds (Auto-negotiation should complete in less than 500 	 * milliseconds even if the other end is doing it in SW). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIBER_LINK_UP_LIMIT
condition|;
name|i
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_LU
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|FIBER_LINK_UP_LIMIT
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Never got a valid link from auto-neg!!!\n"
argument_list|)
expr_stmt|;
name|mac
operator|->
name|autoneg_failed
operator|=
name|TRUE
expr_stmt|;
comment|/* 		 * AutoNeg failed to achieve a link, so we'll call 		 * mac->check_for_link. This routine will force the 		 * link up if we detect a signal. This will allow us to 		 * communicate with non-autonegotiating link partners. 		 */
name|ret_val
operator|=
name|mac
operator|->
name|ops
operator|.
name|check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error while checking for link\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|mac
operator|->
name|autoneg_failed
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|mac
operator|->
name|autoneg_failed
operator|=
name|FALSE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Valid Link Found\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_fiber_serdes_link_generic - Setup link for fiber/serdes  *  @hw: pointer to the HW structure  *  *  Configures collision distance and flow control for fiber and serdes  *  links.  Upon successful setup, poll for link.  **/
end_comment

begin_function
name|s32
name|e1000_setup_fiber_serdes_link_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_fiber_serdes_link_generic"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
comment|/* Take the link out of reset */
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_LRST
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_commit_fc_settings_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* 	 * Since auto-negotiation is enabled, take the link out of reset (the 	 * link will be in reset, because we previously reset the chip). This 	 * will restart auto-negotiation.  If auto-negotiation is successful 	 * then the link-up status bit will be set and the flow control enable 	 * bits (RFCE and TFCE) will be set according to their negotiated value. 	 */
name|DEBUGOUT
argument_list|(
literal|"Auto-negotiation enabled\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * For these adapters, the SW definable pin 1 is set when the optics 	 * detect a signal.  If we have a signal, then poll for a "Link-Up" 	 * indication. 	 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
operator|||
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
operator|&
name|E1000_CTRL_SWDPIN1
operator|)
condition|)
block|{
name|ret_val
operator|=
name|e1000_poll_fiber_serdes_link_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGOUT
argument_list|(
literal|"No signal detected\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_config_collision_dist_generic - Configure collision distance  *  @hw: pointer to the HW structure  *  *  Configures the collision distance to the default value and is used  *  during link setup.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_config_collision_dist_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|tctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_config_collision_dist_generic"
argument_list|)
expr_stmt|;
name|tctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|)
expr_stmt|;
name|tctl
operator|&=
operator|~
name|E1000_TCTL_COLD
expr_stmt|;
name|tctl
operator||=
name|E1000_COLLISION_DISTANCE
operator|<<
name|E1000_COLD_SHIFT
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|tctl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_fc_watermarks_generic - Set flow control high/low watermarks  *  @hw: pointer to the HW structure  *  *  Sets the flow control high/low threshold (watermark) registers.  If  *  flow control XON frame transmission is enabled, then set XON frame  *  transmission as well.  **/
end_comment

begin_function
name|s32
name|e1000_set_fc_watermarks_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|fcrtl
init|=
literal|0
decl_stmt|,
name|fcrth
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_fc_watermarks_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Set the flow control receive threshold registers.  Normally, 	 * these registers will be set to a default threshold that may be 	 * adjusted later by the driver's runtime code.  However, if the 	 * ability to transmit pause frames is not enabled, then these 	 * registers will be set to 0. 	 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|&
name|e1000_fc_tx_pause
condition|)
block|{
comment|/* 		 * We need to set up the Receive Threshold high and low water 		 * marks as well as (optionally) enabling the transmission of 		 * XON frames. 		 */
name|fcrtl
operator|=
name|hw
operator|->
name|fc
operator|.
name|low_water
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|send_xon
condition|)
name|fcrtl
operator||=
name|E1000_FCRTL_XONE
expr_stmt|;
name|fcrth
operator|=
name|hw
operator|->
name|fc
operator|.
name|high_water
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCRTL
argument_list|,
name|fcrtl
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCRTH
argument_list|,
name|fcrth
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_force_mac_fc_generic - Force the MAC's flow control settings  *  @hw: pointer to the HW structure  *  *  Force the MAC's flow control settings.  Sets the TFCE and RFCE bits in the  *  device control register to reflect the adapter settings.  TFCE and RFCE  *  need to be explicitly set by software when a copper PHY is used because  *  autonegotiation is managed by the PHY rather than the MAC.  Software must  *  also configure these bits when link is forced on a fiber connection.  **/
end_comment

begin_function
name|s32
name|e1000_force_mac_fc_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_force_mac_fc_generic"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
comment|/* 	 * Because we didn't get link via the internal auto-negotiation 	 * mechanism (we either forced link or we got link via PHY 	 * auto-neg), we have to manually enable/disable transmit an 	 * receive flow control. 	 * 	 * The "Case" statement below enables/disable flow control 	 * according to the "hw->fc.current_mode" parameter. 	 * 	 * The possible values of the "fc" parameter are: 	 *      0:  Flow control is completely disabled 	 *      1:  Rx flow control is enabled (we can receive pause 	 *          frames but not send pause frames). 	 *      2:  Tx flow control is enabled (we can send pause frames 	 *          frames but we do not receive pause frames). 	 *      3:  Both Rx and Tx flow control (symmetric) is enabled. 	 *  other:  No other values should be possible at this point. 	 */
name|DEBUGOUT1
argument_list|(
literal|"hw->fc.current_mode = %u\n"
argument_list|,
name|hw
operator|->
name|fc
operator|.
name|current_mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
condition|)
block|{
case|case
name|e1000_fc_none
case|:
name|ctrl
operator|&=
operator|(
operator|~
operator|(
name|E1000_CTRL_TFCE
operator||
name|E1000_CTRL_RFCE
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_fc_rx_pause
case|:
name|ctrl
operator|&=
operator|(
operator|~
name|E1000_CTRL_TFCE
operator|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_RFCE
expr_stmt|;
break|break;
case|case
name|e1000_fc_tx_pause
case|:
name|ctrl
operator|&=
operator|(
operator|~
name|E1000_CTRL_RFCE
operator|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_TFCE
expr_stmt|;
break|break;
case|case
name|e1000_fc_full
case|:
name|ctrl
operator||=
operator|(
name|E1000_CTRL_TFCE
operator||
name|E1000_CTRL_RFCE
operator|)
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_config_fc_after_link_up_generic - Configures flow control after link  *  @hw: pointer to the HW structure  *  *  Checks the status of auto-negotiation after link up to ensure that the  *  speed and duplex were not forced.  If the link needed to be forced, then  *  flow control needs to be forced also.  If auto-negotiation is enabled  *  and did not fail, then we configure flow control based on our link  *  partner.  **/
end_comment

begin_function
name|s32
name|e1000_config_fc_after_link_up_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|mii_status_reg
decl_stmt|,
name|mii_nway_adv_reg
decl_stmt|,
name|mii_nway_lp_ability_reg
decl_stmt|;
name|u16
name|speed
decl_stmt|,
name|duplex
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_config_fc_after_link_up_generic"
argument_list|)
expr_stmt|;
comment|/* 	 * Check for the case where we have fiber media and auto-neg failed 	 * so we had to force link.  In this case, we need to force the 	 * configuration of the MAC to match the "fc" parameter. 	 */
if|if
condition|(
name|mac
operator|->
name|autoneg_failed
condition|)
block|{
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_fiber
operator|||
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
condition|)
name|ret_val
operator|=
name|e1000_force_mac_fc_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
name|ret_val
operator|=
name|e1000_force_mac_fc_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error forcing flow control settings\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* 	 * Check for the case where we have copper media and auto-neg is 	 * enabled.  In this case, we need to check and see if Auto-Neg 	 * has completed, and if so, how the PHY and link partner has 	 * flow control configured. 	 */
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
operator|)
operator|&&
name|mac
operator|->
name|autoneg
condition|)
block|{
comment|/* 		 * Read the MII Status Register and check to see if AutoNeg 		 * has completed.  We read this twice because this reg has 		 * some "sticky" (latched) bits. 		 */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_STATUS
argument_list|,
operator|&
name|mii_status_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
operator|!
operator|(
name|mii_status_reg
operator|&
name|MII_SR_AUTONEG_COMPLETE
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Copper PHY and Auto Neg has not completed.\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* 		 * The AutoNeg process has completed, so we now need to 		 * read both the Auto Negotiation Advertisement 		 * Register (Address 4) and the Auto_Negotiation Base 		 * Page Ability Register (Address 5) to determine how 		 * flow control was negotiated. 		 */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_AUTONEG_ADV
argument_list|,
operator|&
name|mii_nway_adv_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|PHY_LP_ABILITY
argument_list|,
operator|&
name|mii_nway_lp_ability_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* 		 * Two bits in the Auto Negotiation Advertisement Register 		 * (Address 4) and two bits in the Auto Negotiation Base 		 * Page Ability Register (Address 5) determine flow control 		 * for both the PHY and the link partner.  The following 		 * table, taken out of the IEEE 802.3ab/D6.0 dated March 25, 		 * 1999, describes these PAUSE resolution bits and how flow 		 * control is determined based upon these settings. 		 * NOTE:  DC = Don't Care 		 * 		 *   LOCAL DEVICE  |   LINK PARTNER 		 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution 		 *-------|---------|-------|---------|-------------------- 		 *   0   |    0    |  DC   |   DC    | e1000_fc_none 		 *   0   |    1    |   0   |   DC    | e1000_fc_none 		 *   0   |    1    |   1   |    0    | e1000_fc_none 		 *   0   |    1    |   1   |    1    | e1000_fc_tx_pause 		 *   1   |    0    |   0   |   DC    | e1000_fc_none 		 *   1   |   DC    |   1   |   DC    | e1000_fc_full 		 *   1   |    1    |   0   |    0    | e1000_fc_none 		 *   1   |    1    |   0   |    1    | e1000_fc_rx_pause 		 * 		 * Are both PAUSE bits set to 1?  If so, this implies 		 * Symmetric Flow Control is enabled at both ends.  The 		 * ASM_DIR bits are irrelevant per the spec. 		 * 		 * For Symmetric Flow Control: 		 * 		 *   LOCAL DEVICE  |   LINK PARTNER 		 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result 		 *-------|---------|-------|---------|-------------------- 		 *   1   |   DC    |   1   |   DC    | E1000_fc_full 		 * 		 */
if|if
condition|(
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
condition|)
block|{
comment|/* 			 * Now we need to check if the user selected Rx ONLY 			 * of pause frames.  In this case, we had to advertise 			 * FULL flow control because we could not advertise Rx 			 * ONLY. Hence, we must now check to see if we need to 			 * turn OFF the TRANSMISSION of PAUSE frames. 			 */
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|==
name|e1000_fc_full
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|e1000_fc_full
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = FULL.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|e1000_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = Rx PAUSE frames only.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * For receiving PAUSE frames ONLY. 		 * 		 *   LOCAL DEVICE  |   LINK PARTNER 		 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result 		 *-------|---------|-------|---------|-------------------- 		 *   0   |    1    |   1   |    1    | e1000_fc_tx_pause 		 */
elseif|else
if|if
condition|(
operator|!
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_ASM_DIR
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_ASM_DIR
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|e1000_fc_tx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = Tx PAUSE frames only.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * For transmitting PAUSE frames ONLY. 		 * 		 *   LOCAL DEVICE  |   LINK PARTNER 		 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result 		 *-------|---------|-------|---------|-------------------- 		 *   1   |    1    |   0   |    1    | e1000_fc_rx_pause 		 */
elseif|else
if|if
condition|(
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_adv_reg
operator|&
name|NWAY_AR_ASM_DIR
operator|)
operator|&&
operator|!
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_PAUSE
operator|)
operator|&&
operator|(
name|mii_nway_lp_ability_reg
operator|&
name|NWAY_LPAR_ASM_DIR
operator|)
condition|)
block|{
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|e1000_fc_rx_pause
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = Rx PAUSE frames only.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Per the IEEE spec, at this point flow control 			 * should be disabled. 			 */
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|e1000_fc_none
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Flow Control = NONE.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now we need to do one last check...  If we auto- 		 * negotiated to HALF DUPLEX, flow control should not be 		 * enabled per IEEE 802.3 spec. 		 */
name|ret_val
operator|=
name|mac
operator|->
name|ops
operator|.
name|get_link_up_info
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error getting link speed and duplex\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|duplex
operator|==
name|HALF_DUPLEX
condition|)
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|=
name|e1000_fc_none
expr_stmt|;
comment|/* 		 * Now we call a subroutine to actually force the MAC 		 * controller to use the correct flow control settings. 		 */
name|ret_val
operator|=
name|e1000_force_mac_fc_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error forcing flow control settings\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_speed_and_duplex_copper_generic - Retrieve current speed/duplex  *  @hw: pointer to the HW structure  *  @speed: stores the current speed  *  @duplex: stores the current duplex  *  *  Read the status register for the current speed/duplex and store the current  *  speed and duplex for copper connections.  **/
end_comment

begin_function
name|s32
name|e1000_get_speed_and_duplex_copper_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
block|{
name|u32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_speed_and_duplex_copper_generic"
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_SPEED_1000
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"1000 Mbs, "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_SPEED_100
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_100
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"100 Mbs, "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|speed
operator|=
name|SPEED_10
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"10 Mbs, "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_FD
condition|)
block|{
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Half Duplex\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_speed_and_duplex_fiber_generic - Retrieve current speed/duplex  *  @hw: pointer to the HW structure  *  @speed: stores the current speed  *  @duplex: stores the current duplex  *  *  Sets the speed and duplex to gigabit full duplex (the only possible option)  *  for fiber/serdes links.  **/
end_comment

begin_function
name|s32
name|e1000_get_speed_and_duplex_fiber_serdes_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_speed_and_duplex_fiber_serdes_generic"
argument_list|)
expr_stmt|;
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_hw_semaphore_generic - Acquire hardware semaphore  *  @hw: pointer to the HW structure  *  *  Acquire the HW semaphore to access the PHY or NVM  **/
end_comment

begin_function
name|s32
name|e1000_get_hw_semaphore_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|swsm
decl_stmt|;
name|s32
name|timeout
init|=
name|hw
operator|->
name|nvm
operator|.
name|word_size
operator|+
literal|1
decl_stmt|;
name|s32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_hw_semaphore_generic"
argument_list|)
expr_stmt|;
comment|/* Get the SW semaphore */
while|while
condition|(
name|i
operator|<
name|timeout
condition|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swsm
operator|&
name|E1000_SWSM_SMBI
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access device - SMBI bit is set.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
comment|/* Get the FW semaphore. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|,
name|swsm
operator||
name|E1000_SWSM_SWESMBI
argument_list|)
expr_stmt|;
comment|/* Semaphore acquired if bit latched */
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
operator|&
name|E1000_SWSM_SWESMBI
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|timeout
condition|)
block|{
comment|/* Release semaphores */
name|e1000_put_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Driver can't access the NVM\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_put_hw_semaphore_generic - Release hardware semaphore  *  @hw: pointer to the HW structure  *  *  Release hardware semaphore used to access the PHY or NVM  **/
end_comment

begin_function
name|void
name|e1000_put_hw_semaphore_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|swsm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_put_hw_semaphore_generic"
argument_list|)
expr_stmt|;
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
name|swsm
operator|&=
operator|~
operator|(
name|E1000_SWSM_SMBI
operator||
name|E1000_SWSM_SWESMBI
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|,
name|swsm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_auto_rd_done_generic - Check for auto read completion  *  @hw: pointer to the HW structure  *  *  Check EEPROM for Auto Read done bit.  **/
end_comment

begin_function
name|s32
name|e1000_get_auto_rd_done_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_auto_rd_done_generic"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|AUTO_READ_DONE_TIMEOUT
condition|)
block|{
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
operator|&
name|E1000_EECD_AUTO_RD
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|AUTO_READ_DONE_TIMEOUT
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Auto read by HW from NVM has not completed.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_RESET
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_valid_led_default_generic - Verify a valid default LED config  *  @hw: pointer to the HW structure  *  @data: pointer to the NVM (EEPROM)  *  *  Read the EEPROM for the current default LED configuration.  If the  *  LED configuration is not valid, set to a valid LED configuration.  **/
end_comment

begin_function
name|s32
name|e1000_valid_led_default_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_valid_led_default_generic"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_ID_LED_SETTINGS
argument_list|,
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
operator|*
name|data
operator|==
name|ID_LED_RESERVED_0000
operator|||
operator|*
name|data
operator|==
name|ID_LED_RESERVED_FFFF
condition|)
operator|*
name|data
operator|=
name|ID_LED_DEFAULT
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_id_led_init_generic -  *  @hw: pointer to the HW structure  *  **/
end_comment

begin_function
name|s32
name|e1000_id_led_init_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
specifier|const
name|u32
name|ledctl_mask
init|=
literal|0x000000FF
decl_stmt|;
specifier|const
name|u32
name|ledctl_on
init|=
name|E1000_LEDCTL_MODE_LED_ON
decl_stmt|;
specifier|const
name|u32
name|ledctl_off
init|=
name|E1000_LEDCTL_MODE_LED_OFF
decl_stmt|;
name|u16
name|data
decl_stmt|,
name|i
decl_stmt|,
name|temp
decl_stmt|;
specifier|const
name|u16
name|led_mask
init|=
literal|0x0F
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_id_led_init_generic"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|valid_led_default
argument_list|(
name|hw
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|mac
operator|->
name|ledctl_default
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode1
operator|=
name|mac
operator|->
name|ledctl_default
expr_stmt|;
name|mac
operator|->
name|ledctl_mode2
operator|=
name|mac
operator|->
name|ledctl_default
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
operator|(
name|data
operator|>>
operator|(
name|i
operator|<<
literal|2
operator|)
operator|)
operator|&
name|led_mask
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|ID_LED_ON1_DEF2
case|:
case|case
name|ID_LED_ON1_ON2
case|:
case|case
name|ID_LED_ON1_OFF2
case|:
name|mac
operator|->
name|ledctl_mode1
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode1
operator||=
name|ledctl_on
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|ID_LED_OFF1_DEF2
case|:
case|case
name|ID_LED_OFF1_ON2
case|:
case|case
name|ID_LED_OFF1_OFF2
case|:
name|mac
operator|->
name|ledctl_mode1
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode1
operator||=
name|ledctl_off
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
break|break;
block|}
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
name|ID_LED_DEF1_ON2
case|:
case|case
name|ID_LED_ON1_ON2
case|:
case|case
name|ID_LED_OFF1_ON2
case|:
name|mac
operator|->
name|ledctl_mode2
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode2
operator||=
name|ledctl_on
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|ID_LED_DEF1_OFF2
case|:
case|case
name|ID_LED_ON1_OFF2
case|:
case|case
name|ID_LED_OFF1_OFF2
case|:
name|mac
operator|->
name|ledctl_mode2
operator|&=
operator|~
operator|(
name|ledctl_mask
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|mac
operator|->
name|ledctl_mode2
operator||=
name|ledctl_off
operator|<<
operator|(
name|i
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
break|break;
block|}
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_led_generic - Configures SW controllable LED  *  @hw: pointer to the HW structure  *  *  This prepares the SW controllable LED for use and saves the current state  *  of the LED so it can be later restored.  **/
end_comment

begin_function
name|s32
name|e1000_setup_led_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ledctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_led_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|setup_led
operator|!=
name|e1000_setup_led_generic
condition|)
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_fiber
condition|)
block|{
name|ledctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ledctl_default
operator|=
name|ledctl
expr_stmt|;
comment|/* Turn off LED0 */
name|ledctl
operator|&=
operator|~
operator|(
name|E1000_LEDCTL_LED0_IVRT
operator||
name|E1000_LEDCTL_LED0_BLINK
operator||
name|E1000_LEDCTL_LED0_MODE_MASK
operator|)
expr_stmt|;
name|ledctl
operator||=
operator|(
name|E1000_LEDCTL_MODE_LED_OFF
operator|<<
name|E1000_LEDCTL_LED0_MODE_SHIFT
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|ledctl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode1
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_cleanup_led_generic - Set LED config to default operation  *  @hw: pointer to the HW structure  *  *  Remove the current LED configuration and set the LED configuration  *  to the default value, saved from the EEPROM.  **/
end_comment

begin_function
name|s32
name|e1000_cleanup_led_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_cleanup_led_generic"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_default
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_blink_led_generic - Blink LED  *  @hw: pointer to the HW structure  *  *  Blink the LEDs which are set to be on.  **/
end_comment

begin_function
name|s32
name|e1000_blink_led_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ledctl_blink
init|=
literal|0
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_blink_led_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_fiber
condition|)
block|{
comment|/* always blink LED0 for PCI-E fiber */
name|ledctl_blink
operator|=
name|E1000_LEDCTL_LED0_BLINK
operator||
operator|(
name|E1000_LEDCTL_MODE_LED_ON
operator|<<
name|E1000_LEDCTL_LED0_MODE_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * set the blink bit for each LED that's "on" (0x0E) 		 * in ledctl_mode2 		 */
name|ledctl_blink
operator|=
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode2
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xFF
operator|)
operator|==
name|E1000_LEDCTL_MODE_LED_ON
condition|)
name|ledctl_blink
operator||=
operator|(
name|E1000_LEDCTL_LED0_BLINK
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|ledctl_blink
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_led_on_generic - Turn LED on  *  @hw: pointer to the HW structure  *  *  Turn LED on.  **/
end_comment

begin_function
name|s32
name|e1000_led_on_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_led_on_generic"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
condition|)
block|{
case|case
name|e1000_media_type_fiber
case|:
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator|&=
operator|~
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_media_type_copper
case|:
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode2
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_led_off_generic - Turn LED off  *  @hw: pointer to the HW structure  *  *  Turn LED off.  **/
end_comment

begin_function
name|s32
name|e1000_led_off_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_led_off_generic"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
condition|)
block|{
case|case
name|e1000_media_type_fiber
case|:
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIN0
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SWDPIO0
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_media_type_copper
case|:
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LEDCTL
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|ledctl_mode1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_pcie_no_snoop_generic - Set PCI-express capabilities  *  @hw: pointer to the HW structure  *  @no_snoop: bitmap of snoop events  *  *  Set the PCI-express register to snoop for events enabled in 'no_snoop'.  **/
end_comment

begin_function
name|void
name|e1000_set_pcie_no_snoop_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|no_snoop
parameter_list|)
block|{
name|u32
name|gcr
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_pcie_no_snoop_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|type
operator|!=
name|e1000_bus_type_pci_express
condition|)
return|return;
if|if
condition|(
name|no_snoop
condition|)
block|{
name|gcr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GCR
argument_list|)
expr_stmt|;
name|gcr
operator|&=
operator|~
operator|(
name|PCIE_NO_SNOOP_ALL
operator|)
expr_stmt|;
name|gcr
operator||=
name|no_snoop
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GCR
argument_list|,
name|gcr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_disable_pcie_master_generic - Disables PCI-express master access  *  @hw: pointer to the HW structure  *  *  Returns E1000_SUCCESS if successful, else returns -10  *  (-E1000_ERR_MASTER_REQUESTS_PENDING) if master disable bit has not caused  *  the master requests to be disabled.  *  *  Disables PCI-Express master access and verifies there are no pending  *  requests.  **/
end_comment

begin_function
name|s32
name|e1000_disable_pcie_master_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|timeout
init|=
name|MASTER_DISABLE_TIMEOUT
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_disable_pcie_master_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|type
operator|!=
name|e1000_bus_type_pci_express
condition|)
return|return
name|E1000_SUCCESS
return|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_GIO_MASTER_DISABLE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_GIO_MASTER_ENABLE
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Master requests are pending.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_MASTER_REQUESTS_PENDING
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_adaptive_generic - Reset Adaptive Interframe Spacing  *  @hw: pointer to the HW structure  *  *  Reset the Adaptive Interframe Spacing throttle to default values.  **/
end_comment

begin_function
name|void
name|e1000_reset_adaptive_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_adaptive_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mac
operator|->
name|adaptive_ifs
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Not in Adaptive IFS mode!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|mac
operator|->
name|current_ifs_val
operator|=
literal|0
expr_stmt|;
name|mac
operator|->
name|ifs_min_val
operator|=
name|IFS_MIN
expr_stmt|;
name|mac
operator|->
name|ifs_max_val
operator|=
name|IFS_MAX
expr_stmt|;
name|mac
operator|->
name|ifs_step_size
operator|=
name|IFS_STEP
expr_stmt|;
name|mac
operator|->
name|ifs_ratio
operator|=
name|IFS_RATIO
expr_stmt|;
name|mac
operator|->
name|in_ifs_mode
operator|=
name|FALSE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_AIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_adaptive_generic - Update Adaptive Interframe Spacing  *  @hw: pointer to the HW structure  *  *  Update the Adaptive Interframe Spacing Throttle value based on the  *  time between transmitted packets and time between collisions.  **/
end_comment

begin_function
name|void
name|e1000_update_adaptive_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_adaptive_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mac
operator|->
name|adaptive_ifs
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Not in Adaptive IFS mode!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|mac
operator|->
name|collision_delta
operator|*
name|mac
operator|->
name|ifs_ratio
operator|)
operator|>
name|mac
operator|->
name|tx_packet_delta
condition|)
block|{
if|if
condition|(
name|mac
operator|->
name|tx_packet_delta
operator|>
name|MIN_NUM_XMITS
condition|)
block|{
name|mac
operator|->
name|in_ifs_mode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|current_ifs_val
operator|<
name|mac
operator|->
name|ifs_max_val
condition|)
block|{
if|if
condition|(
operator|!
name|mac
operator|->
name|current_ifs_val
condition|)
name|mac
operator|->
name|current_ifs_val
operator|=
name|mac
operator|->
name|ifs_min_val
expr_stmt|;
else|else
name|mac
operator|->
name|current_ifs_val
operator|+=
name|mac
operator|->
name|ifs_step_size
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_AIT
argument_list|,
name|mac
operator|->
name|current_ifs_val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|mac
operator|->
name|in_ifs_mode
operator|&&
operator|(
name|mac
operator|->
name|tx_packet_delta
operator|<=
name|MIN_NUM_XMITS
operator|)
condition|)
block|{
name|mac
operator|->
name|current_ifs_val
operator|=
literal|0
expr_stmt|;
name|mac
operator|->
name|in_ifs_mode
operator|=
name|FALSE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_AIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_validate_mdi_setting_generic - Verify MDI/MDIx settings  *  @hw: pointer to the HW structure  *  *  Verify that when not using auto-negotiation that MDI/MDIx is correctly  *  set, which is forced to MDI mode only.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_validate_mdi_setting_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_validate_mdi_setting_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|mac
operator|.
name|autoneg
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|mdix
operator|==
literal|0
operator|||
name|hw
operator|->
name|phy
operator|.
name|mdix
operator|==
literal|3
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Invalid MDI setting detected\n"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|mdix
operator|=
literal|1
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_8bit_ctrl_reg_generic - Write a 8bit CTRL register  *  @hw: pointer to the HW structure  *  @reg: 32bit register offset such as E1000_SCTL  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Writes an address/data control type register.  There are several of these  *  and they all have the format address<< 8 | data and bit 31 is polled for  *  completion.  **/
end_comment

begin_function
name|s32
name|e1000_write_8bit_ctrl_reg_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u8
name|data
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|regvalue
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_8bit_ctrl_reg_generic"
argument_list|)
expr_stmt|;
comment|/* Set up the address and data */
name|regvalue
operator|=
operator|(
operator|(
name|u32
operator|)
name|data
operator|)
operator||
operator|(
name|offset
operator|<<
name|E1000_GEN_CTL_ADDRESS_SHIFT
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|reg
argument_list|,
name|regvalue
argument_list|)
expr_stmt|;
comment|/* Poll the ready bit to see if the MDI read completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_GEN_POLL_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|regvalue
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regvalue
operator|&
name|E1000_GEN_CTL_READY
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|regvalue
operator|&
name|E1000_GEN_CTL_READY
operator|)
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"Reg %08x did not indicate ready\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

end_unit

