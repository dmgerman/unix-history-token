begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_rss.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_include
include|#
directive|include
file|"opt_altq.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"if_igb.h"
end_include

begin_comment
comment|/*********************************************************************  *  Driver version:  *********************************************************************/
end_comment

begin_decl_stmt
name|char
name|igb_driver_version
index|[]
init|=
literal|"2.5.2"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  PCI Device ID Table  *  *  Used by probe to select devices to load on  *  Last field stores an index into e1000_strings  *  Last entry must be all 0s  *  *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|igb_vendor_info_t
name|igb_vendor_info_array
index|[]
init|=
block|{
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82575EB_COPPER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82575EB_FIBER_SERDES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82575GB_QUAD_COPPER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82576
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82576_NS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82576_NS_SERDES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82576_FIBER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82576_SERDES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82576_SERDES_QUAD
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82576_QUAD_COPPER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82576_QUAD_COPPER_ET2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82576_VF
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82580_COPPER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82580_FIBER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82580_SERDES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82580_SGMII
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82580_COPPER_DUAL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_82580_QUAD_FIBER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_DH89XXCC_SERDES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_DH89XXCC_SGMII
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_DH89XXCC_SFP
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_DH89XXCC_BACKPLANE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I350_COPPER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I350_FIBER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I350_SERDES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I350_SGMII
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I350_VF
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I210_COPPER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I210_COPPER_IT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I210_COPPER_OEM1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I210_COPPER_FLASHLESS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I210_SERDES_FLASHLESS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I210_FIBER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I210_SERDES
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I210_SGMII
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I211_COPPER
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I354_BACKPLANE_1GBPS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I354_BACKPLANE_2_5GBPS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IGB_INTEL_VENDOR_ID
block|,
name|E1000_DEV_ID_I354_SGMII
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* required last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Table of branding strings for all supported NICs.  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|igb_strings
index|[]
init|=
block|{
literal|"Intel(R) PRO/1000 Network Connection"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|igb_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
end_ifndef

begin_function_decl
specifier|static
name|int
name|igb_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_mq_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_deferred_mq_start
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|igb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_start_locked
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|igb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|igb_get_counter
parameter_list|(
name|if_t
parameter_list|,
name|ift_counter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_stop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_allocate_msix
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_allocate_legacy
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_setup_msix
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_local_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_reset
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_setup_interface
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_allocate_queues
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_configure_queues
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_allocate_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_setup_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_setup_transmit_ring
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_initialize_transmit_units
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_free_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_free_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_allocate_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_setup_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_setup_receive_ring
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_initialize_receive_units
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_free_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_free_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_free_receive_ring
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|igb_txeof
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|igb_rx_discard
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|igb_rx_input
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|igb_rxeof
parameter_list|(
name|struct
name|igb_queue
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_rx_checksum
parameter_list|(
name|u32
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_tx_ctx_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_tso_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_disable_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_update_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_refresh_mbufs
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_register_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_unregister_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_setup_vlan_hw_support
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_xmit
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_dma_malloc
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|struct
name|igb_dma_alloc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_dma_free
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|struct
name|igb_dma_alloc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_sysctl_nvm_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_print_nvm_info
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_is_valid_ether_addr
parameter_list|(
name|u8
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_add_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_vf_init_stats
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_update_vf_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Management and WOL Support */
end_comment

begin_function_decl
specifier|static
name|void
name|igb_init_manageability
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_release_manageability
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_get_hw_control
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_release_hw_control
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_enable_wakeup
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_led_func
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_irq_fast
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_msix_que
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_msix_link
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_handle_que
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_handle_link
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_handle_link_locked
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_set_sysctl_value
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_set_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_sysctl_dmac
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_sysctl_eee
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_decl_stmt
specifier|static
name|poll_handler_t
name|igb_poll
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* POLLING */
end_comment

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|igb_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|igb_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|igb_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|igb_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|igb_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|igb_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|igb_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|igb_driver
init|=
block|{
literal|"igb"
block|,
name|igb_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|adapter
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|igb_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|igb
argument_list|,
name|pci
argument_list|,
name|igb_driver
argument_list|,
name|igb_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|igb
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|igb
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|igb
argument_list|,
name|netmap
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_comment
comment|/*********************************************************************  *  Tunable default values.  *********************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|igb
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"IGB driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Descriptor defaults */
end_comment

begin_decl_stmt
specifier|static
name|int
name|igb_rxd
init|=
name|IGB_DEFAULT_RXD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|igb_txd
init|=
name|IGB_DEFAULT_TXD
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_igb
argument_list|,
name|OID_AUTO
argument_list|,
name|rxd
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|igb_rxd
argument_list|,
literal|0
argument_list|,
literal|"Number of receive descriptors per queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_igb
argument_list|,
name|OID_AUTO
argument_list|,
name|txd
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|igb_txd
argument_list|,
literal|0
argument_list|,
literal|"Number of transmit descriptors per queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** AIM: Adaptive Interrupt Moderation ** which means that the interrupt rate ** is varied over time based on the ** traffic for that interrupt vector */
end_comment

begin_decl_stmt
specifier|static
name|int
name|igb_enable_aim
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_igb
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_aim
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|igb_enable_aim
argument_list|,
literal|0
argument_list|,
literal|"Enable adaptive interrupt moderation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * MSIX should be the default for best performance,  * but this allows it to be forced off for testing.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|igb_enable_msix
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_igb
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_msix
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|igb_enable_msix
argument_list|,
literal|0
argument_list|,
literal|"Enable MSI-X interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Tuneable Interrupt rate */
end_comment

begin_decl_stmt
specifier|static
name|int
name|igb_max_interrupt_rate
init|=
literal|8000
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_igb
argument_list|,
name|OID_AUTO
argument_list|,
name|max_interrupt_rate
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|igb_max_interrupt_rate
argument_list|,
literal|0
argument_list|,
literal|"Maximum interrupts per second"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
end_ifndef

begin_comment
comment|/* ** Tuneable number of buffers in the buf-ring (drbr_xxx) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|igb_buf_ring_size
init|=
name|IGB_BR_SIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_igb
argument_list|,
name|OID_AUTO
argument_list|,
name|buf_ring_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|igb_buf_ring_size
argument_list|,
literal|0
argument_list|,
literal|"Size of the bufring"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Header split causes the packet header to ** be dma'd to a seperate mbuf from the payload. ** this can have memory alignment benefits. But ** another plus is that small packets often fit ** into the header and thus use no cluster. Its ** a very workload dependent type feature. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|igb_header_split
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_igb
argument_list|,
name|OID_AUTO
argument_list|,
name|header_split
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|igb_header_split
argument_list|,
literal|0
argument_list|,
literal|"Enable receive mbuf header split"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** This will autoconfigure based on the ** number of CPUs and max supported ** MSIX messages if left at 0. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|igb_num_queues
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_igb
argument_list|,
name|OID_AUTO
argument_list|,
name|num_queues
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|igb_num_queues
argument_list|,
literal|0
argument_list|,
literal|"Number of queues to configure, 0 indicates autoconfigure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Global variable to store last used CPU when binding queues ** to CPUs in igb_allocate_msix.  Starts at CPU_FIRST and increments when a ** queue is bound to a cpu. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|igb_last_bind_cpu
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many packets rxeof tries to clean at a time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|igb_rx_process_limit
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_igb
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_process_limit
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|igb_rx_process_limit
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of received packets to process at a time, -1 means unlimited"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_comment
comment|/* see ixgbe.c for details */
end_comment

begin_include
include|#
directive|include
file|<dev/netmap/if_igb_netmap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_comment
comment|/*********************************************************************  *  Device identification routine  *  *  igb_probe determines if the driver should be loaded on  *  adapter based on PCI vendor/device id of the adapter.  *  *  return BUS_PROBE_DEFAULT on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
name|adapter_name
index|[
literal|256
index|]
decl_stmt|;
name|uint16_t
name|pci_vendor_id
init|=
literal|0
decl_stmt|;
name|uint16_t
name|pci_device_id
init|=
literal|0
decl_stmt|;
name|uint16_t
name|pci_subvendor_id
init|=
literal|0
decl_stmt|;
name|uint16_t
name|pci_subdevice_id
init|=
literal|0
decl_stmt|;
name|igb_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"igb_probe: begin"
argument_list|)
expr_stmt|;
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_vendor_id
operator|!=
name|IGB_INTEL_VENDOR_ID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|igb_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subvendor_id
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subdevice_id
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|adapter_name
argument_list|,
literal|"%s, Version - %s"
argument_list|,
name|igb_strings
index|[
name|ent
operator|->
name|index
index|]
argument_list|,
name|igb_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|adapter_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device initialization routine  *  *  The attach entry point is called when the driver is being loaded.  *  This routine identifies the type of hardware, allocates all resources  *  and initializes the hardware.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u16
name|eeprom_data
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"igb_attach: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"igb"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Disabled by device hint\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|dev
operator|=
name|adapter
operator|->
name|osdep
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|IGB_CORE_LOCK_INIT
argument_list|(
name|adapter
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SYSCTLs */
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nvm"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|igb_sysctl_nvm_info
argument_list|,
literal|"I"
argument_list|,
literal|"NVM Information"
argument_list|)
expr_stmt|;
name|igb_set_sysctl_value
argument_list|(
name|adapter
argument_list|,
literal|"enable_aim"
argument_list|,
literal|"Interrupt Moderation"
argument_list|,
operator|&
name|adapter
operator|->
name|enable_aim
argument_list|,
name|igb_enable_aim
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|igb_set_flowcntl
argument_list|,
literal|"I"
argument_list|,
literal|"Flow Control"
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
operator|&
name|adapter
operator|->
name|core_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Determine hardware and mac info */
name|igb_identify_hardware
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Setup PCI resources */
if|if
condition|(
name|igb_allocate_pci_resources
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Allocation of PCI resources failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_pci
goto|;
block|}
comment|/* Do Shared Code initialization */
if|if
condition|(
name|e1000_setup_init_funcs
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Setup of Shared code failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_pci
goto|;
block|}
name|e1000_get_bus_info
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Sysctl for limiting the amount of work done in the taskqueue */
name|igb_set_sysctl_value
argument_list|(
name|adapter
argument_list|,
literal|"rx_processing_limit"
argument_list|,
literal|"max number of rx packets to process"
argument_list|,
operator|&
name|adapter
operator|->
name|rx_process_limit
argument_list|,
name|igb_rx_process_limit
argument_list|)
expr_stmt|;
comment|/* 	 * Validate number of transmit and receive descriptors. It 	 * must not exceed hardware maximum, and must be multiple 	 * of E1000_DBA_ALIGN. 	 */
if|if
condition|(
operator|(
operator|(
name|igb_txd
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
operator|)
operator|%
name|IGB_DBA_ALIGN
operator|)
operator|!=
literal|0
operator|||
operator|(
name|igb_txd
operator|>
name|IGB_MAX_TXD
operator|)
operator|||
operator|(
name|igb_txd
operator|<
name|IGB_MIN_TXD
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using %d TX descriptors instead of %d!\n"
argument_list|,
name|IGB_DEFAULT_TXD
argument_list|,
name|igb_txd
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_tx_desc
operator|=
name|IGB_DEFAULT_TXD
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|num_tx_desc
operator|=
name|igb_txd
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|igb_rxd
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_rx_desc
argument_list|)
operator|)
operator|%
name|IGB_DBA_ALIGN
operator|)
operator|!=
literal|0
operator|||
operator|(
name|igb_rxd
operator|>
name|IGB_MAX_RXD
operator|)
operator|||
operator|(
name|igb_rxd
operator|<
name|IGB_MIN_RXD
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using %d RX descriptors instead of %d!\n"
argument_list|,
name|IGB_DEFAULT_RXD
argument_list|,
name|igb_rxd
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_rx_desc
operator|=
name|IGB_DEFAULT_RXD
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|num_rx_desc
operator|=
name|igb_rxd
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_wait_to_complete
operator|=
name|FALSE
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
name|AUTONEG_ADV_DEFAULT
expr_stmt|;
comment|/* Copper options */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
block|{
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|mdix
operator|=
name|AUTO_ALL_MODES
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|disable_polarity_correction
operator|=
name|FALSE
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|ms_type
operator|=
name|IGB_MASTER_SLAVE
expr_stmt|;
block|}
comment|/* 	 * Set the frame limits assuming 	 * standard ethernet sized frames. 	 */
name|adapter
operator|->
name|max_frame_size
operator|=
name|ETHERMTU
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHERNET_FCS_SIZE
expr_stmt|;
comment|/* 	** Allocate and Setup Queues 	*/
if|if
condition|(
name|igb_allocate_queues
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_pci
goto|;
block|}
comment|/* Allocate the appropriate stats memory */
if|if
condition|(
name|adapter
operator|->
name|vf_ifp
condition|)
block|{
name|adapter
operator|->
name|stats
operator|=
operator|(
expr|struct
name|e1000_vf_stats
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof \
argument_list|(
expr|struct
name|e1000_vf_stats
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|igb_vf_init_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
else|else
name|adapter
operator|->
name|stats
operator|=
operator|(
expr|struct
name|e1000_hw_stats
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof \
argument_list|(
expr|struct
name|e1000_hw_stats
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|stats
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can not allocate stats memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Allocate multicast array memory. */
name|adapter
operator|->
name|mta
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
operator|*
name|ETH_ADDR_LEN
operator|*
name|MAX_NUM_MULTICAST_ADDRESSES
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|mta
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can not allocate multicast setup array\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Some adapter-specific advanced features */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_i350
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dmac"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|igb_sysctl_dmac
argument_list|,
literal|"I"
argument_list|,
literal|"DMA Coalesce"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"eee_disabled"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|adapter
argument_list|,
literal|0
argument_list|,
name|igb_sysctl_eee
argument_list|,
literal|"I"
argument_list|,
literal|"Disable Energy Efficient Ethernet"
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_i354
condition|)
name|e1000_set_eee_i354
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
else|else
name|e1000_set_eee_i350
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	** Start from a known state, this is 	** important in reading the nvm and 	** mac from that. 	*/
name|e1000_reset_hw
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Make sure we have a good EEPROM before we read from it */
if|if
condition|(
operator|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|!=
name|e1000_i210
operator|)
operator|&&
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|!=
name|e1000_i211
operator|)
operator|)
operator|&&
operator|(
name|e1000_validate_nvm_checksum
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* 		** Some PCI-E parts fail the first check due to 		** the link being in sleep state, call it again, 		** if it fails a second time its a real issue. 		*/
if|if
condition|(
name|e1000_validate_nvm_checksum
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The EEPROM Checksum Is Not Valid\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
block|}
comment|/* 	** Copy the permanent MAC address out of the EEPROM 	*/
if|if
condition|(
name|e1000_read_mac_addr
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"EEPROM read error while reading MAC"
literal|" address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Check its sanity */
if|if
condition|(
operator|!
name|igb_is_valid_ether_addr
argument_list|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid MAC address\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Setup OS specific network interface */
if|if
condition|(
name|igb_setup_interface
argument_list|(
name|dev
argument_list|,
name|adapter
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err_late
goto|;
comment|/* Now get a good starting state */
name|igb_reset
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Initialize statistics */
name|igb_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|get_link_status
operator|=
literal|1
expr_stmt|;
name|igb_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Indicate SOL/IDER usage */
if|if
condition|(
name|e1000_check_reset_block
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PHY reset is blocked due to SOL/IDER session.\n"
argument_list|)
expr_stmt|;
comment|/* Determine if we have to control management hardware */
name|adapter
operator|->
name|has_manage
operator|=
name|e1000_enable_mng_pass_thru
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* 	 * Setup Wake-on-Lan 	 */
comment|/* APME bit in EEPROM is mapped to WUC.APME */
name|eeprom_data
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUC
argument_list|)
operator|&
name|E1000_WUC_APME
expr_stmt|;
if|if
condition|(
name|eeprom_data
condition|)
name|adapter
operator|->
name|wol
operator|=
name|E1000_WUFC_MAG
expr_stmt|;
comment|/* Register for VLAN events */
name|adapter
operator|->
name|vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|igb_register_vlan
argument_list|,
name|adapter
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|igb_unregister_vlan
argument_list|,
name|adapter
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|igb_add_hw_stats
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is not active */
name|adapter
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|adapter
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|adapter
operator|->
name|led_dev
operator|=
name|led_create
argument_list|(
name|igb_led_func
argument_list|,
name|adapter
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  	** Configure Interrupts 	*/
if|if
condition|(
operator|(
name|adapter
operator|->
name|msix
operator|>
literal|1
operator|)
operator|&&
operator|(
name|igb_enable_msix
operator|)
condition|)
name|error
operator|=
name|igb_allocate_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
comment|/* MSI or Legacy */
name|error
operator|=
name|igb_allocate_legacy
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_late
goto|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|igb_netmap_attach
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|INIT_DEBUGOUT
argument_list|(
literal|"igb_attach: end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_late
label|:
name|igb_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|igb_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|err_pci
label|:
name|igb_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|mta
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|IGB_CORE_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device removal routine  *  *  The detach entry point is called when the driver is being removed.  *  This routine stops the adapter and deallocates all the resources  *  that were allocated for driver operation.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"igb_detach: begin"
argument_list|)
expr_stmt|;
comment|/* Make sure VLANS are not using driver */
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Vlan in use, detach first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|ether_ifdetach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|led_dev
operator|!=
name|NULL
condition|)
name|led_destroy
argument_list|(
name|adapter
operator|->
name|led_dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|in_detach
operator|=
literal|1
expr_stmt|;
name|igb_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|e1000_phy_hw_reset
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Give control back to firmware */
name|igb_release_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|wol
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
name|E1000_WUC_PME_EN
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUFC
argument_list|,
name|adapter
operator|->
name|wol
argument_list|)
expr_stmt|;
name|igb_enable_wakeup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Unregister VLAN events */
if|if
condition|(
name|adapter
operator|->
name|vlan_attach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|adapter
operator|->
name|vlan_attach
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|vlan_detach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|adapter
operator|->
name|vlan_detach
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|netmap_detach
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|igb_free_pci_resources
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|igb_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|mta
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|adapter
operator|->
name|mta
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|IGB_CORE_LOCK_DESTROY
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Shutdown entry point  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
name|igb_suspend
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Suspend/resume device methods.  */
end_comment

begin_function
specifier|static
name|int
name|igb_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_release_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_release_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|wol
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
name|E1000_WUC_PME_EN
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUFC
argument_list|,
name|adapter
operator|->
name|wol
argument_list|)
expr_stmt|;
name|igb_enable_wakeup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|igb_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_init_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
name|adapter
operator|->
name|link_active
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|IGB_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
comment|/* Process the stack queue only if not depleted */
if|if
condition|(
operator|(
operator|(
name|txr
operator|->
name|queue_status
operator|&
name|IGB_QUEUE_DEPLETED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|igb_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|igb_start_locked
argument_list|(
name|txr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IGB_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
block|}
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IGB_LEGACY_TX
end_ifdef

begin_comment
comment|/*********************************************************************  *  Transmit entry point  *  *  igb_start is called by the stack to initiate a transmit.  *  The driver will remain in this routine as long as there are  *  packets to transmit and transmit resources are available.  *  In case resources are not available stack is notified and  *  the packet is requeued.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_start_locked
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|IGB_TX_LOCK_ASSERT
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
condition|)
return|return;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
return|return;
comment|/* Call cleanup if number of TX descriptors low */
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<=
name|IGB_TX_CLEANUP_THRESHOLD
condition|)
name|igb_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<=
name|IGB_MAX_SCATTER
condition|)
block|{
name|txr
operator|->
name|queue_status
operator||=
name|IGB_QUEUE_DEPLETED
expr_stmt|;
break|break;
block|}
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 *  Encapsulation can modify our pointer, and or make it 		 *  NULL on failure.  In that event, we can't requeue. 		 */
if|if
condition|(
name|igb_xmit
argument_list|(
name|txr
argument_list|,
operator|&
name|m_head
argument_list|)
condition|)
block|{
if|if
condition|(
name|m_head
operator|!=
name|NULL
condition|)
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<=
name|IGB_MAX_SCATTER
condition|)
name|txr
operator|->
name|queue_status
operator||=
name|IGB_QUEUE_DEPLETED
expr_stmt|;
break|break;
block|}
comment|/* Send a copy of the frame to the BPF listener */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
comment|/* Set watchdog on */
name|txr
operator|->
name|watchdog_time
operator|=
name|ticks
expr_stmt|;
name|txr
operator|->
name|queue_status
operator||=
name|IGB_QUEUE_WORKING
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Legacy TX driver routine, called from the  * stack, always uses tx[0], and spins for it.  * Should not be used with multiqueue tx  */
end_comment

begin_function
specifier|static
name|void
name|igb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IGB_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|igb_start_locked
argument_list|(
name|txr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|IGB_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ~IGB_LEGACY_TX */
end_comment

begin_comment
comment|/* ** Multiqueue Transmit Entry: **  quick turnaround to the stack ** */
end_comment

begin_function
specifier|static
name|int
name|igb_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|igb_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|uint32_t
name|bucket_id
decl_stmt|;
endif|#
directive|endif
comment|/* Which queue to use */
comment|/* 	 * When doing RSS, map it to the same outbound queue 	 * as the incoming flow would be mapped to. 	 * 	 * If everything is setup correctly, it should be the 	 * same bucket that the current CPU we're on is. 	 */
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
block|{
ifdef|#
directive|ifdef
name|RSS
if|if
condition|(
name|rss_hash2bucket
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
argument_list|,
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
argument_list|,
operator|&
name|bucket_id
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX TODO: spit out something if bucket_id> num_queues? */
name|i
operator|=
name|bucket_id
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|i
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|i
operator|=
name|curcpu
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
block|}
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|IGB_TX_TRYLOCK
argument_list|(
name|txr
argument_list|)
condition|)
block|{
name|igb_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|IGB_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
else|else
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|txr
operator|->
name|txq_task
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|igb_mq_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|enq
init|=
literal|0
decl_stmt|;
name|IGB_TX_LOCK_ASSERT
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|)
operator|||
name|adapter
operator|->
name|link_active
operator|==
literal|0
condition|)
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* Process the queue */
while|while
condition|(
operator|(
name|next
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|igb_xmit
argument_list|(
name|txr
argument_list|,
operator|&
name|next
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
comment|/* It was freed, move forward */
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  				 * Still have one left, it may not be 				 * the same since the transmit function 				 * may have changed it. 				 */
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
expr_stmt|;
name|enq
operator|++
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|m_flags
operator|&
name|M_MCAST
operator|&&
name|adapter
operator|->
name|vf_ifp
condition|)
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OMCASTS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|enq
operator|>
literal|0
condition|)
block|{
comment|/* Set the watchdog */
name|txr
operator|->
name|queue_status
operator||=
name|IGB_QUEUE_WORKING
expr_stmt|;
name|txr
operator|->
name|watchdog_time
operator|=
name|ticks
expr_stmt|;
block|}
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<=
name|IGB_TX_CLEANUP_THRESHOLD
condition|)
name|igb_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<=
name|IGB_MAX_SCATTER
condition|)
name|txr
operator|->
name|queue_status
operator||=
name|IGB_QUEUE_DEPLETED
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called from a taskqueue to drain queued transmit packets.  */
end_comment

begin_function
specifier|static
name|void
name|igb_deferred_mq_start
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|IGB_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|igb_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|IGB_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Flush all ring buffers */
end_comment

begin_function
specifier|static
name|void
name|igb_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|IGB_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txr
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IGB_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ~IGB_LEGACY_TX */
end_comment

begin_comment
comment|/*********************************************************************  *  Ioctl entry point  *  *  igb_ioctl is called when the user wants to configure the  *  interface.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
endif|#
directive|endif
name|bool
name|avoid_reset
init|=
name|FALSE
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|in_detach
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* 		** Calling init results in link renegotiation, 		** so we avoid doing it when possible. 		*/
if|if
condition|(
name|avoid_reset
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|igb_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
operator|)
condition|)
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
block|{
name|int
name|max_frame_size
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|max_frame_size
operator|=
literal|9234
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|max_frame_size
operator|-
name|ETHER_HDR_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|adapter
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
expr_stmt|;
name|igb_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCSIFFLAGS
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd:\ 		    SIOCSIFFLAGS (Set Interface Flags)"
argument_list|)
expr_stmt|;
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|adapter
operator|->
name|if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
name|igb_disable_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_set_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|igb_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|igb_stop
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOC(ADD|DEL)MULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
condition|)
endif|#
directive|endif
name|igb_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
comment|/* Check SOL/IDER usage */
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1000_check_reset_block
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
condition|)
block|{
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Media change is"
literal|" blocked due to SOL/IDER session.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
case|case
name|SIOCGIFMEDIA
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: \ 		    SIOCxIFMEDIA (Get/Set Interface Media)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|mask
decl_stmt|,
name|reinit
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl rcv'd: SIOCSIFCAP (Set Capabilities)"
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|mask
operator|&
name|IFCAP_POLLING
condition|)
block|{
if|if
condition|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|error
operator|=
name|ether_poll_register
argument_list|(
name|igb_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING
expr_stmt|;
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Enable interrupt even in error case */
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_POLLING
expr_stmt|;
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|mask
operator|&
name|IFCAP_HWCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_HWCSUM
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO6
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|reinit
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|igb_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Init entry point  *  *  This routine is used in two ways. It is used by the stack as  *  init entry point in network interface structure. It is also used  *  by the driver as a hw/sw initialization routine to get to a  *  consistent state.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_init_locked
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"igb_init: begin"
argument_list|)
expr_stmt|;
name|IGB_CORE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* Get the latest mac address, User can use a LAA */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Put the address into the Receive Address Array */
name|e1000_rar_set
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|igb_reset
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_VET
argument_list|,
name|ETHERTYPE_VLAN
argument_list|)
expr_stmt|;
comment|/* Set hardware offload abilities */
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82576
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_SCTP
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
comment|/* Configure for OS presence */
name|igb_init_manageability
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Prepare transmit descriptors and buffers */
name|igb_setup_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_initialize_transmit_units
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Setup Multicast table */
name|igb_set_multi
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	** Figure out the desired mbuf pool 	** for doing jumbo/packetsplit 	*/
if|if
condition|(
name|adapter
operator|->
name|max_frame_size
operator|<=
literal|2048
condition|)
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MCLBYTES
expr_stmt|;
elseif|else
if|if
condition|(
name|adapter
operator|->
name|max_frame_size
operator|<=
literal|4096
condition|)
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUMPAGESIZE
expr_stmt|;
else|else
name|adapter
operator|->
name|rx_mbuf_sz
operator|=
name|MJUM9BYTES
expr_stmt|;
comment|/* Prepare receive descriptors and buffers */
if|if
condition|(
name|igb_setup_receive_structures
argument_list|(
name|adapter
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup receive structures\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|igb_initialize_receive_units
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|e1000_rx_fifo_flush_82575
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Enable VLAN support */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|igb_setup_vlan_hw_support
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Don't lose promiscuous settings */
name|igb_set_promisc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|igb_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|e1000_clear_hw_cntrs_base_generic
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix
operator|>
literal|1
condition|)
comment|/* Set up queue routing */
name|igb_configure_queues
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* this clears any pending interrupts */
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* 	 * Only enable interrupts if we are not polling, make sure 	 * they are off otherwise. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|igb_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* DEVICE_POLLING */
block|{
name|igb_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICS
argument_list|,
name|E1000_ICS_LSC
argument_list|)
expr_stmt|;
block|}
comment|/* Set Energy Efficient Ethernet */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_i354
condition|)
name|e1000_set_eee_i354
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
else|else
name|e1000_set_eee_i350
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|igb_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_handle_que
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|igb_queue
modifier|*
name|que
init|=
name|context
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|que
operator|->
name|adapter
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|bool
name|more
decl_stmt|;
name|more
operator|=
name|igb_rxeof
argument_list|(
name|que
argument_list|,
name|adapter
operator|->
name|rx_process_limit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|IGB_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|igb_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
comment|/* Process the stack queue only if not depleted */
if|if
condition|(
operator|(
operator|(
name|txr
operator|->
name|queue_status
operator|&
name|IGB_QUEUE_DEPLETED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|igb_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|igb_start_locked
argument_list|(
name|txr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IGB_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
comment|/* Do we need another? */
if|if
condition|(
name|more
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|que_task
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
return|return;
endif|#
directive|endif
comment|/* Reenable this interrupt */
if|if
condition|(
name|que
operator|->
name|eims
condition|)
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIMS
argument_list|,
name|que
operator|->
name|eims
argument_list|)
expr_stmt|;
else|else
name|igb_enable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deal with link in a sleepable context */
end_comment

begin_function
specifier|static
name|void
name|igb_handle_link
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|context
decl_stmt|;
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_handle_link_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_handle_link_locked
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|IGB_CORE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|get_link_status
operator|=
literal|1
expr_stmt|;
name|igb_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
name|adapter
operator|->
name|link_active
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|IGB_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
comment|/* Process the stack queue only if not depleted */
if|if
condition|(
operator|(
operator|(
name|txr
operator|->
name|queue_status
operator|&
name|IGB_QUEUE_DEPLETED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|igb_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|igb_start_locked
argument_list|(
name|txr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IGB_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSI/Legacy Deferred  *  Interrupt Service routine    *  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_irq_fast
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|igb_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|u32
name|reg_icr
decl_stmt|;
name|reg_icr
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
comment|/* Hot eject?  */
if|if
condition|(
name|reg_icr
operator|==
literal|0xffffffff
condition|)
return|return
name|FILTER_STRAY
return|;
comment|/* Definitely not our interrupt.  */
if|if
condition|(
name|reg_icr
operator|==
literal|0x0
condition|)
return|return
name|FILTER_STRAY
return|;
if|if
condition|(
operator|(
name|reg_icr
operator|&
name|E1000_ICR_INT_ASSERTED
operator|)
operator|==
literal|0
condition|)
return|return
name|FILTER_STRAY
return|;
comment|/* 	 * Mask interrupts until the taskqueue is finished running.  This is 	 * cheap, just assume that it is needed.  This also works around the 	 * MSI message reordering errata on certain systems. 	 */
name|igb_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|que_task
argument_list|)
expr_stmt|;
comment|/* Link status change */
if|if
condition|(
name|reg_icr
operator|&
operator|(
name|E1000_ICR_RXSEQ
operator||
name|E1000_ICR_LSC
operator|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|link_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_icr
operator|&
name|E1000_ICR_RXO
condition|)
name|adapter
operator|->
name|rx_overruns
operator|++
expr_stmt|;
return|return
name|FILTER_HANDLED
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
end_if

begin_define
define|#
directive|define
name|POLL_RETURN_COUNT
parameter_list|(
name|a
parameter_list|)
value|(a)
end_define

begin_function
specifier|static
name|int
else|#
directive|else
define|#
directive|define
name|POLL_RETURN_COUNT
parameter_list|(
name|a
parameter_list|)
specifier|static
name|void
endif|#
directive|endif
name|igb_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|igb_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|u32
name|reg_icr
decl_stmt|,
name|rx_done
init|=
literal|0
decl_stmt|;
name|u32
name|loop
init|=
name|IGB_MAX_LOOP
decl_stmt|;
name|bool
name|more
decl_stmt|;
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
name|POLL_RETURN_COUNT
argument_list|(
name|rx_done
argument_list|)
return|;
block|}
if|if
condition|(
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
condition|)
block|{
name|reg_icr
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
comment|/* Link status change */
if|if
condition|(
name|reg_icr
operator|&
operator|(
name|E1000_ICR_RXSEQ
operator||
name|E1000_ICR_LSC
operator|)
condition|)
name|igb_handle_link_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_icr
operator|&
name|E1000_ICR_RXO
condition|)
name|adapter
operator|->
name|rx_overruns
operator|++
expr_stmt|;
block|}
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|txr
operator|=
name|que
operator|->
name|txr
expr_stmt|;
name|igb_rxeof
argument_list|(
name|que
argument_list|,
name|count
argument_list|,
operator|&
name|rx_done
argument_list|)
expr_stmt|;
name|IGB_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
do|do
block|{
name|more
operator|=
name|igb_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|loop
operator|--
operator|&&
name|more
condition|)
do|;
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|igb_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|igb_start_locked
argument_list|(
name|txr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IGB_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
return|return
name|POLL_RETURN_COUNT
argument_list|(
name|rx_done
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_comment
comment|/*********************************************************************  *  *  MSIX Que Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_msix_que
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|igb_queue
modifier|*
name|que
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|que
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|que
operator|->
name|rxr
decl_stmt|;
name|u32
name|newitr
init|=
literal|0
decl_stmt|;
name|bool
name|more_rx
decl_stmt|;
comment|/* Ignore spurious interrupts */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIMC
argument_list|,
name|que
operator|->
name|eims
argument_list|)
expr_stmt|;
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
name|IGB_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|igb_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
comment|/* Process the stack queue only if not depleted */
if|if
condition|(
operator|(
operator|(
name|txr
operator|->
name|queue_status
operator|&
name|IGB_QUEUE_DEPLETED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|igb_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|igb_start_locked
argument_list|(
name|txr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IGB_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|more_rx
operator|=
name|igb_rxeof
argument_list|(
name|que
argument_list|,
name|adapter
operator|->
name|rx_process_limit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|enable_aim
operator|==
name|FALSE
condition|)
goto|goto
name|no_calc
goto|;
comment|/* 	** Do Adaptive Interrupt Moderation:         **  - Write out last calculated setting 	**  - Calculate based on average size over 	**    the last interval. 	*/
if|if
condition|(
name|que
operator|->
name|eitr_setting
condition|)
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EITR
argument_list|(
name|que
operator|->
name|msix
argument_list|)
argument_list|,
name|que
operator|->
name|eitr_setting
argument_list|)
expr_stmt|;
name|que
operator|->
name|eitr_setting
operator|=
literal|0
expr_stmt|;
comment|/* Idle, do nothing */
if|if
condition|(
operator|(
name|txr
operator|->
name|bytes
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rxr
operator|->
name|bytes
operator|==
literal|0
operator|)
condition|)
goto|goto
name|no_calc
goto|;
comment|/* Used half Default if sub-gig */
if|if
condition|(
name|adapter
operator|->
name|link_speed
operator|!=
literal|1000
condition|)
name|newitr
operator|=
name|IGB_DEFAULT_ITR
operator|/
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|txr
operator|->
name|bytes
operator|)
operator|&&
operator|(
name|txr
operator|->
name|packets
operator|)
condition|)
name|newitr
operator|=
name|txr
operator|->
name|bytes
operator|/
name|txr
operator|->
name|packets
expr_stmt|;
if|if
condition|(
operator|(
name|rxr
operator|->
name|bytes
operator|)
operator|&&
operator|(
name|rxr
operator|->
name|packets
operator|)
condition|)
name|newitr
operator|=
name|max
argument_list|(
name|newitr
argument_list|,
operator|(
name|rxr
operator|->
name|bytes
operator|/
name|rxr
operator|->
name|packets
operator|)
argument_list|)
expr_stmt|;
name|newitr
operator|+=
literal|24
expr_stmt|;
comment|/* account for hardware frame, crc */
comment|/* set an upper boundary */
name|newitr
operator|=
name|min
argument_list|(
name|newitr
argument_list|,
literal|3000
argument_list|)
expr_stmt|;
comment|/* Be nice to the mid range */
if|if
condition|(
operator|(
name|newitr
operator|>
literal|300
operator|)
operator|&&
operator|(
name|newitr
operator|<
literal|1200
operator|)
condition|)
name|newitr
operator|=
operator|(
name|newitr
operator|/
literal|3
operator|)
expr_stmt|;
else|else
name|newitr
operator|=
operator|(
name|newitr
operator|/
literal|2
operator|)
expr_stmt|;
block|}
name|newitr
operator|&=
literal|0x7FFC
expr_stmt|;
comment|/* Mask invalid bits */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
name|newitr
operator||=
name|newitr
operator|<<
literal|16
expr_stmt|;
else|else
name|newitr
operator||=
name|E1000_EITR_CNT_IGNR
expr_stmt|;
comment|/* save for next interrupt */
name|que
operator|->
name|eitr_setting
operator|=
name|newitr
expr_stmt|;
comment|/* Reset state */
name|txr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
name|no_calc
label|:
comment|/* Schedule a clean task if needed*/
if|if
condition|(
name|more_rx
condition|)
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|que_task
argument_list|)
expr_stmt|;
else|else
comment|/* Reenable this interrupt */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIMS
argument_list|,
name|que
operator|->
name|eims
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX Link Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_msix_link
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|u32
name|icr
decl_stmt|;
operator|++
name|adapter
operator|->
name|link_irq
expr_stmt|;
name|icr
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|icr
operator|&
name|E1000_ICR_LSC
operator|)
condition|)
goto|goto
name|spurious
goto|;
name|igb_handle_link
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spurious
label|:
comment|/* Rearm */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|E1000_IMS_LSC
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIMS
argument_list|,
name|adapter
operator|->
name|link_mask
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called whenever the user queries the status of  *  the interface using ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"igb_media_status: begin"
argument_list|)
expr_stmt|;
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
block|{
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|link_speed
condition|)
block|{
case|case
literal|10
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
break|break;
case|case
literal|100
case|:
comment|/* 		** Support for 100Mb SFP - these are Fiber  		** but the media type appears as serdes 		*/
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_FX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
break|break;
case|case
literal|1000
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
expr_stmt|;
break|break;
case|case
literal|2500
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_2500_SX
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|adapter
operator|->
name|link_duplex
operator|==
name|FULL_DUPLEX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_HDX
expr_stmt|;
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called when the user changes speed/duplex using  *  media/mediopt option with ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|adapter
operator|->
name|media
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"igb_media_change: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
name|AUTONEG_ADV_DEFAULT
expr_stmt|;
break|break;
case|case
name|IFM_1000_LX
case|:
case|case
name|IFM_1000_SX
case|:
case|case
name|IFM_1000_T
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|DO_AUTO_NEG
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
name|ADVERTISE_1000_FULL
expr_stmt|;
break|break;
case|case
name|IFM_100_TX
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|FALSE
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifm
operator|->
name|ifm_media
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
condition|)
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_100_FULL
expr_stmt|;
else|else
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_100_HALF
expr_stmt|;
break|break;
case|case
name|IFM_10_T
case|:
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|autoneg
operator|=
name|FALSE
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|autoneg_advertised
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifm
operator|->
name|ifm_media
operator|&
name|IFM_GMASK
operator|)
operator|==
name|IFM_FDX
condition|)
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_10_FULL
expr_stmt|;
else|else
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|forced_speed_duplex
operator|=
name|ADVERTISE_10_HALF
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Unsupported media type\n"
argument_list|)
expr_stmt|;
block|}
name|igb_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine maps the mbufs to Advanced TX descriptors.  *    **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_xmit
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_headp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|u32
name|olinfo_status
init|=
literal|0
decl_stmt|,
name|cmd_type_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|,
name|nsegs
decl_stmt|;
name|int
name|first
decl_stmt|;
name|bool
name|remap
init|=
name|TRUE
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|IGB_MAX_SCATTER
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|igb_tx_buf
modifier|*
name|txbuf
decl_stmt|;
name|union
name|e1000_adv_tx_desc
modifier|*
name|txd
init|=
name|NULL
decl_stmt|;
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
comment|/* Basic descriptor defines */
name|cmd_type_len
operator|=
operator|(
name|E1000_ADVTXD_DTYP_DATA
operator||
name|E1000_ADVTXD_DCMD_IFCS
operator||
name|E1000_ADVTXD_DCMD_DEXT
operator|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
name|cmd_type_len
operator||=
name|E1000_ADVTXD_DCMD_VLE
expr_stmt|;
comment|/*          * Important to capture the first descriptor          * used because it will contain the index of          * the one we tell the hardware to report back          */
name|first
operator|=
name|txr
operator|->
name|next_avail_desc
expr_stmt|;
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
name|map
operator|=
name|txbuf
operator|->
name|map
expr_stmt|;
comment|/* 	 * Map the packet for DMA. 	 */
name|retry
label|:
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
operator|*
name|m_headp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EFBIG
case|:
comment|/* Try it again? - one try */
if|if
condition|(
name|remap
operator|==
name|TRUE
condition|)
block|{
name|remap
operator|=
name|FALSE
expr_stmt|;
name|m
operator|=
name|m_defrag
argument_list|(
operator|*
name|m_headp
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|adapter
operator|->
name|mbuf_defrag_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m_headp
operator|=
name|m
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
else|else
return|return
operator|(
name|error
operator|)
return|;
default|default:
name|txr
operator|->
name|no_tx_dma_setup
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Make certain there are enough descriptors */
if|if
condition|(
name|nsegs
operator|>
name|txr
operator|->
name|tx_avail
operator|-
literal|2
condition|)
block|{
name|txr
operator|->
name|no_desc_avail
operator|++
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
comment|/* 	** Set up the appropriate offload context 	** this will consume the first descriptor 	*/
name|error
operator|=
name|igb_tx_ctx_setup
argument_list|(
name|txr
argument_list|,
name|m_head
argument_list|,
operator|&
name|cmd_type_len
argument_list|,
operator|&
name|olinfo_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 82575 needs the queue index added */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
name|olinfo_status
operator||=
name|txr
operator|->
name|me
operator|<<
literal|4
expr_stmt|;
name|i
operator|=
name|txr
operator|->
name|next_avail_desc
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsegs
condition|;
name|j
operator|++
control|)
block|{
name|bus_size_t
name|seglen
decl_stmt|;
name|bus_addr_t
name|segaddr
decl_stmt|;
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|i
index|]
expr_stmt|;
name|seglen
operator|=
name|segs
index|[
name|j
index|]
operator|.
name|ds_len
expr_stmt|;
name|segaddr
operator|=
name|htole64
argument_list|(
name|segs
index|[
name|j
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|buffer_addr
operator|=
name|segaddr
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|cmd_type_len
operator|=
name|htole32
argument_list|(
name|E1000_TXD_CMD_IFCS
operator||
name|cmd_type_len
operator||
name|seglen
argument_list|)
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|olinfo_status
operator|=
name|htole32
argument_list|(
name|olinfo_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|txr
operator|->
name|num_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|txd
operator|->
name|read
operator|.
name|cmd_type_len
operator||=
name|htole32
argument_list|(
name|E1000_TXD_CMD_EOP
operator||
name|E1000_TXD_CMD_RS
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tx_avail
operator|-=
name|nsegs
expr_stmt|;
name|txr
operator|->
name|next_avail_desc
operator|=
name|i
expr_stmt|;
name|txbuf
operator|->
name|m_head
operator|=
name|m_head
expr_stmt|;
comment|/* 	** Here we swap the map so the last descriptor, 	** which gets the completion interrupt has the 	** real map, and the first descriptor gets the 	** unused map from this descriptor. 	*/
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
operator|.
name|map
operator|=
name|txbuf
operator|->
name|map
expr_stmt|;
name|txbuf
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Set the EOP descriptor that will be marked done */
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
name|txbuf
operator|->
name|eop
operator|=
name|txd
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Advance the Transmit Descriptor Tail (Tdt), this tells the 	 * hardware that this frame is available to transmit. 	 */
operator|++
name|txr
operator|->
name|total_packets
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_set_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|vf_ifp
condition|)
block|{
name|e1000_promisc_set_vf
argument_list|(
name|hw
argument_list|,
name|e1000_promisc_enabled
argument_list|)
expr_stmt|;
return|return;
block|}
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|reg
operator||=
operator|(
name|E1000_RCTL_UPE
operator||
name|E1000_RCTL_MPE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|reg
operator||=
name|E1000_RCTL_MPE
expr_stmt|;
name|reg
operator|&=
operator|~
name|E1000_RCTL_UPE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|igb_disable_promisc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|vf_ifp
condition|)
block|{
name|e1000_promisc_set_vf
argument_list|(
name|hw
argument_list|,
name|e1000_promisc_disabled
argument_list|)
expr_stmt|;
return|return;
block|}
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|(
operator|~
name|E1000_RCTL_UPE
operator|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|mcnt
operator|=
name|MAX_NUM_MULTICAST_ADDRESSES
expr_stmt|;
else|else
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|mcnt
operator|==
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
break|break;
name|mcnt
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Don't disable if in MAX groups */
if|if
condition|(
name|mcnt
operator|<
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
name|reg
operator|&=
operator|(
operator|~
name|E1000_RCTL_MPE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Multicast Update  *  *  This routine is called whenever multicast address list is updated.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_set_multi
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|u32
name|reg_rctl
init|=
literal|0
decl_stmt|;
name|u8
modifier|*
name|mta
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"igb_set_multi: begin"
argument_list|)
expr_stmt|;
name|mta
operator|=
name|adapter
operator|->
name|mta
expr_stmt|;
name|bzero
argument_list|(
name|mta
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|ETH_ADDR_LEN
operator|*
name|MAX_NUM_MULTICAST_ADDRESSES
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|mcnt
operator|==
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
break|break;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|&
name|mta
index|[
name|mcnt
operator|*
name|ETH_ADDR_LEN
index|]
argument_list|,
name|ETH_ADDR_LEN
argument_list|)
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mcnt
operator|>=
name|MAX_NUM_MULTICAST_ADDRESSES
condition|)
block|{
name|reg_rctl
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|reg_rctl
operator||=
name|E1000_RCTL_MPE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg_rctl
argument_list|)
expr_stmt|;
block|}
else|else
name|e1000_update_mc_addr_list
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|mta
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Timer routine:  *  	This routine checks for link status,  *	updates statistics, and does the watchdog.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_local_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|igb_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|int
name|hung
init|=
literal|0
decl_stmt|,
name|busy
init|=
literal|0
decl_stmt|;
name|IGB_CORE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_update_link_status
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|igb_update_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/*         ** Check the TX queues status 	**	- central locked handling of OACTIVE 	**	- watchdog only if all queues show hung         */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
operator|,
name|txr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|txr
operator|->
name|queue_status
operator|&
name|IGB_QUEUE_HUNG
operator|)
operator|&&
operator|(
name|adapter
operator|->
name|pause_frames
operator|==
literal|0
operator|)
condition|)
operator|++
name|hung
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|queue_status
operator|&
name|IGB_QUEUE_DEPLETED
condition|)
operator|++
name|busy
expr_stmt|;
if|if
condition|(
operator|(
name|txr
operator|->
name|queue_status
operator|&
name|IGB_QUEUE_IDLE
operator|)
operator|==
literal|0
condition|)
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|que_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hung
operator|==
name|adapter
operator|->
name|num_queues
condition|)
goto|goto
name|timeout
goto|;
if|if
condition|(
name|busy
operator|==
name|adapter
operator|->
name|num_queues
condition|)
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|&&
operator|(
name|busy
operator|<
name|adapter
operator|->
name|num_queues
operator|)
condition|)
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|adapter
operator|->
name|pause_frames
operator|=
literal|0
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|igb_local_timer
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEVICE_POLLING
comment|/* Schedule all queue interrupts - deadlock protection */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EICS
argument_list|,
name|adapter
operator|->
name|que_mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
name|timeout
label|:
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Watchdog timeout -- resetting\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Queue(%d) tdh = %d, hw tdt = %d\n"
argument_list|,
name|txr
operator|->
name|me
argument_list|,
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDH
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|)
argument_list|,
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TX(%d) desc avail = %d,"
literal|"Next TX to Clean = %d\n"
argument_list|,
name|txr
operator|->
name|me
argument_list|,
name|txr
operator|->
name|tx_avail
argument_list|,
name|txr
operator|->
name|next_to_clean
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|adapter
operator|->
name|watchdog_events
operator|++
expr_stmt|;
name|igb_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_update_link_status
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|e1000_fc_info
modifier|*
name|fc
init|=
operator|&
name|hw
operator|->
name|fc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|u32
name|link_check
decl_stmt|,
name|thstat
decl_stmt|,
name|ctrl
decl_stmt|;
name|char
modifier|*
name|flowctl
init|=
name|NULL
decl_stmt|;
name|link_check
operator|=
name|thstat
operator|=
name|ctrl
operator|=
literal|0
expr_stmt|;
comment|/* Get the cached link value or read for real */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
condition|)
block|{
case|case
name|e1000_media_type_copper
case|:
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|get_link_status
condition|)
block|{
comment|/* Do the work to read phy */
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|link_check
operator|=
operator|!
name|hw
operator|->
name|mac
operator|.
name|get_link_status
expr_stmt|;
block|}
else|else
name|link_check
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|e1000_media_type_fiber
case|:
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|link_check
operator|=
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_LU
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_media_type_internal_serdes
case|:
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|link_check
operator|=
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|serdes_has_link
expr_stmt|;
break|break;
comment|/* VF device is type_unknown */
case|case
name|e1000_media_type_unknown
case|:
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|link_check
operator|=
operator|!
name|hw
operator|->
name|mac
operator|.
name|get_link_status
expr_stmt|;
comment|/* Fall thru */
default|default:
break|break;
block|}
comment|/* Check for thermal downshift or shutdown */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i350
condition|)
block|{
name|thstat
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_THSTAT
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
block|}
comment|/* Get the flow control for display */
switch|switch
condition|(
name|fc
operator|->
name|current_mode
condition|)
block|{
case|case
name|e1000_fc_rx_pause
case|:
name|flowctl
operator|=
literal|"RX"
expr_stmt|;
break|break;
case|case
name|e1000_fc_tx_pause
case|:
name|flowctl
operator|=
literal|"TX"
expr_stmt|;
break|break;
case|case
name|e1000_fc_full
case|:
name|flowctl
operator|=
literal|"Full"
expr_stmt|;
break|break;
case|case
name|e1000_fc_none
case|:
default|default:
name|flowctl
operator|=
literal|"None"
expr_stmt|;
break|break;
block|}
comment|/* Now we check if a transition has happened */
if|if
condition|(
name|link_check
operator|&&
operator|(
name|adapter
operator|->
name|link_active
operator|==
literal|0
operator|)
condition|)
block|{
name|e1000_get_speed_and_duplex
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
operator|&
name|adapter
operator|->
name|link_speed
argument_list|,
operator|&
name|adapter
operator|->
name|link_duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is up %d Mbps %s,"
literal|" Flow Control: %s\n"
argument_list|,
name|adapter
operator|->
name|link_speed
argument_list|,
operator|(
operator|(
name|adapter
operator|->
name|link_duplex
operator|==
name|FULL_DUPLEX
operator|)
condition|?
literal|"Full Duplex"
else|:
literal|"Half Duplex"
operator|)
argument_list|,
name|flowctl
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
name|adapter
operator|->
name|link_speed
operator|*
literal|1000000
expr_stmt|;
if|if
condition|(
operator|(
name|ctrl
operator|&
name|E1000_CTRL_EXT_LINK_MODE_GMII
operator|)
operator|&&
operator|(
name|thstat
operator|&
name|E1000_THSTAT_LINK_THROTTLE
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link: thermal downshift\n"
argument_list|)
expr_stmt|;
comment|/* Delay Link Up for Phy update */
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i210
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i211
operator|)
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|id
operator|==
name|I210_I_PHY_ID
operator|)
condition|)
name|msec_delay
argument_list|(
name|I210_LINK_DELAY
argument_list|)
expr_stmt|;
comment|/* Reset if the media type changed. */
if|if
condition|(
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
operator|.
name|media_changed
condition|)
block|{
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
operator|.
name|media_changed
operator|=
name|false
expr_stmt|;
name|adapter
operator|->
name|flags
operator||=
name|IGB_MEDIA_RESET
expr_stmt|;
name|igb_reset
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
comment|/* This can sleep */
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|link_check
operator|&&
operator|(
name|adapter
operator|->
name|link_active
operator|==
literal|1
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_baudrate
operator|=
name|adapter
operator|->
name|link_speed
operator|=
literal|0
expr_stmt|;
name|adapter
operator|->
name|link_duplex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is Down\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctrl
operator|&
name|E1000_CTRL_EXT_LINK_MODE_GMII
operator|)
operator|&&
operator|(
name|thstat
operator|&
name|E1000_THSTAT_PWR_DOWN
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link: thermal shutdown\n"
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_active
operator|=
literal|0
expr_stmt|;
comment|/* This can sleep */
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
comment|/* Reset queue state */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
name|txr
operator|->
name|queue_status
operator|=
name|IGB_QUEUE_IDLE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine disables all traffic on the adapter by issuing a  *  global reset on the MAC and deallocates TX/RX buffers.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_stop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|IGB_CORE_LOCK_ASSERT
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"igb_stop: begin"
argument_list|)
expr_stmt|;
name|igb_disable_intr
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|adapter
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is no longer active */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
comment|/* Disarm watchdog timer. */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|IGB_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|txr
operator|->
name|queue_status
operator|=
name|IGB_QUEUE_IDLE
expr_stmt|;
name|IGB_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
name|e1000_reset_hw
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e1000_led_off
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|e1000_cleanup_led
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Determine hardware revision.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_identify_hardware
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
comment|/* Make sure our PCI config space has the necessary stuff set */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|bus
operator|.
name|pci_cmd_word
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Save off the information about this board */
name|adapter
operator|->
name|hw
operator|.
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|revision_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|subsystem_vendor_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|subsystem_device_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set MAC type early for PCI setup */
name|e1000_set_mac_type
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* Are we a VF device? */
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_vfadapt
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_vfadapt_i350
operator|)
condition|)
name|adapter
operator|->
name|vf_ifp
operator|=
literal|1
expr_stmt|;
else|else
name|adapter
operator|->
name|vf_ifp
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|igb_allocate_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|pci_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|pci_mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|adapter
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|adapter
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|hw_addr
operator|=
operator|(
name|u8
operator|*
operator|)
operator|&
name|adapter
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
expr_stmt|;
name|adapter
operator|->
name|num_queues
operator|=
literal|1
expr_stmt|;
comment|/* Defaults for Legacy or MSI */
comment|/* This will setup either MSI/X or MSI */
name|adapter
operator|->
name|msix
operator|=
name|igb_setup_msix
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|back
operator|=
operator|&
name|adapter
operator|->
name|osdep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup the Legacy or MSI Interrupt handler  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_allocate_legacy
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|igb_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|,
name|rid
init|=
literal|0
decl_stmt|;
comment|/* Turn off all interrupts */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* MSI RID is 1 */
if|if
condition|(
name|adapter
operator|->
name|msix
operator|==
literal|1
condition|)
name|rid
operator|=
literal|1
expr_stmt|;
comment|/* We allocate a single interrupt resource */
name|adapter
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: "
literal|"interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
name|TASK_INIT
argument_list|(
operator|&
name|txr
operator|->
name|txq_task
argument_list|,
literal|0
argument_list|,
name|igb_deferred_mq_start
argument_list|,
name|txr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Try allocating a fast interrupt and the associated deferred 	 * processing contexts. 	 */
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|que_task
argument_list|,
literal|0
argument_list|,
name|igb_handle_que
argument_list|,
name|que
argument_list|)
expr_stmt|;
comment|/* Make tasklet for deferred link handling */
name|TASK_INIT
argument_list|(
operator|&
name|adapter
operator|->
name|link_task
argument_list|,
literal|0
argument_list|,
name|igb_handle_link
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"igb_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|igb_irq_fast
argument_list|,
name|NULL
argument_list|,
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register fast interrupt "
literal|"handler: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup the MSIX Queue Interrupt handlers:   *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_allocate_msix
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|igb_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|vector
init|=
literal|0
decl_stmt|;
name|int
name|cpu_id
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|cpuset_t
name|cpu_mask
decl_stmt|;
endif|#
directive|endif
comment|/* Be sure to start with all interrupts disabled */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* 	 * If we're doing RSS, the number of queues needs to 	 * match the number of RSS buckets that are configured. 	 * 	 * + If there's more queues than RSS buckets, we'll end 	 *   up with queues that get no traffic. 	 * 	 * + If there's more RSS buckets than queues, we'll end 	 *   up having multiple RSS buckets map to the same queue, 	 *   so there'll be some contention. 	 */
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|!=
name|rss_getnumbuckets
argument_list|()
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: number of queues (%d) != number of RSS buckets (%d)"
literal|"; performance will be impacted.\n"
argument_list|,
name|__func__
argument_list|,
name|adapter
operator|->
name|num_queues
argument_list|,
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|que
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|que
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: "
literal|"MSIX Queue Interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|igb_msix_que
argument_list|,
name|que
argument_list|,
operator|&
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|que
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register Queue handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|,
literal|"que %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|que
operator|->
name|msix
operator|=
name|vector
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
name|que
operator|->
name|eims
operator|=
name|E1000_EICR_TX_QUEUE0
operator|<<
name|i
expr_stmt|;
else|else
name|que
operator|->
name|eims
operator|=
literal|1
operator|<<
name|vector
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* 		 * The queue ID is used as the RSS layer bucket ID. 		 * We look up the queue ID -> RSS CPU ID and select 		 * that. 		 */
name|cpu_id
operator|=
name|rss_getcpu
argument_list|(
name|i
operator|%
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 		 * Bind the msix vector, and thus the 		 * rings to the corresponding cpu. 		 * 		 * This just happens to match the default RSS round-robin 		 * bucket -> queue -> CPU allocation. 		 */
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|igb_last_bind_cpu
operator|<
literal|0
condition|)
name|igb_last_bind_cpu
operator|=
name|CPU_FIRST
argument_list|()
expr_stmt|;
name|cpu_id
operator|=
name|igb_last_bind_cpu
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
block|{
name|bus_bind_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Bound queue %d to RSS bucket %d\n"
argument_list|,
name|i
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
else|#
directive|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Bound queue %d to cpu %d\n"
argument_list|,
name|i
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|txr
operator|->
name|txq_task
argument_list|,
literal|0
argument_list|,
name|igb_deferred_mq_start
argument_list|,
name|que
operator|->
name|txr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make tasklet for deferred handling */
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|que_task
argument_list|,
literal|0
argument_list|,
name|igb_handle_que
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|taskqueue_create
argument_list|(
literal|"igb_que"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
block|{
comment|/* 			 * Only pin the taskqueue thread to a CPU if 			 * RSS is in use. 			 * 			 * This again just happens to match the default RSS 			 * round-robin bucket -> queue -> CPU allocation. 			 */
ifdef|#
directive|ifdef
name|RSS
name|CPU_SETOF
argument_list|(
name|cpu_id
argument_list|,
operator|&
name|cpu_mask
argument_list|)
expr_stmt|;
name|taskqueue_start_threads_cpuset
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
operator|&
name|cpu_mask
argument_list|,
literal|"%s que (bucket %d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
else|#
directive|else
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s que (qid %d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s que"
argument_list|,
name|device_get_nameunit
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Finally update the last bound CPU id */
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
name|igb_last_bind_cpu
operator|=
name|CPU_NEXT
argument_list|(
name|igb_last_bind_cpu
argument_list|)
expr_stmt|;
block|}
comment|/* And Link */
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|adapter
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: "
literal|"MSIX Link Interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|igb_msix_link
argument_list|,
name|adapter
argument_list|,
operator|&
name|adapter
operator|->
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register Link handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|adapter
operator|->
name|tag
argument_list|,
literal|"link"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adapter
operator|->
name|linkvec
operator|=
name|vector
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_configure_queues
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|igb_queue
modifier|*
name|que
decl_stmt|;
name|u32
name|tmp
decl_stmt|,
name|ivar
init|=
literal|0
decl_stmt|,
name|newitr
init|=
literal|0
decl_stmt|;
comment|/* First turn on RSS capability */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|!=
name|e1000_82575
condition|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GPIE
argument_list|,
name|E1000_GPIE_MSIX_MODE
operator||
name|E1000_GPIE_EIAME
operator||
name|E1000_GPIE_PBA
operator||
name|E1000_GPIE_NSICR
argument_list|)
expr_stmt|;
comment|/* Turn on MSIX */
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82580
case|:
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
case|case
name|e1000_i210
case|:
case|case
name|e1000_i211
case|:
case|case
name|e1000_vfadapt
case|:
case|case
name|e1000_vfadapt_i350
case|:
comment|/* RX entries */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|index
init|=
name|i
operator|>>
literal|1
decl_stmt|;
name|ivar
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
block|{
name|ivar
operator|&=
literal|0xFF00FFFF
expr_stmt|;
name|ivar
operator||=
operator|(
name|que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|16
expr_stmt|;
block|}
else|else
block|{
name|ivar
operator|&=
literal|0xFFFFFF00
expr_stmt|;
name|ivar
operator||=
name|que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
block|}
comment|/* TX entries */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|index
init|=
name|i
operator|>>
literal|1
decl_stmt|;
name|ivar
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
block|{
name|ivar
operator|&=
literal|0x00FFFFFF
expr_stmt|;
name|ivar
operator||=
operator|(
name|que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|24
expr_stmt|;
block|}
else|else
block|{
name|ivar
operator|&=
literal|0xFFFF00FF
expr_stmt|;
name|ivar
operator||=
operator|(
name|que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|8
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|que_mask
operator||=
name|que
operator|->
name|eims
expr_stmt|;
block|}
comment|/* And for the link interrupt */
name|ivar
operator|=
operator|(
name|adapter
operator|->
name|linkvec
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|8
expr_stmt|;
name|adapter
operator|->
name|link_mask
operator|=
literal|1
operator|<<
name|adapter
operator|->
name|linkvec
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR_MISC
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_82576
case|:
comment|/* RX entries */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|index
init|=
name|i
operator|&
literal|0x7
decl_stmt|;
comment|/* Each IVAR has two entries */
name|ivar
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|8
condition|)
block|{
name|ivar
operator|&=
literal|0xFFFFFF00
expr_stmt|;
name|ivar
operator||=
name|que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
expr_stmt|;
block|}
else|else
block|{
name|ivar
operator|&=
literal|0xFF00FFFF
expr_stmt|;
name|ivar
operator||=
operator|(
name|que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|16
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|que_mask
operator||=
name|que
operator|->
name|eims
expr_stmt|;
block|}
comment|/* TX entries */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|index
init|=
name|i
operator|&
literal|0x7
decl_stmt|;
comment|/* Each IVAR has two entries */
name|ivar
operator|=
name|E1000_READ_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|8
condition|)
block|{
name|ivar
operator|&=
literal|0xFFFF00FF
expr_stmt|;
name|ivar
operator||=
operator|(
name|que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|8
expr_stmt|;
block|}
else|else
block|{
name|ivar
operator|&=
literal|0x00FFFFFF
expr_stmt|;
name|ivar
operator||=
operator|(
name|que
operator|->
name|msix
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|24
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR0
argument_list|,
name|index
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|que_mask
operator||=
name|que
operator|->
name|eims
expr_stmt|;
block|}
comment|/* And for the link interrupt */
name|ivar
operator|=
operator|(
name|adapter
operator|->
name|linkvec
operator||
name|E1000_IVAR_VALID
operator|)
operator|<<
literal|8
expr_stmt|;
name|adapter
operator|->
name|link_mask
operator|=
literal|1
operator|<<
name|adapter
operator|->
name|linkvec
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IVAR_MISC
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_82575
case|:
comment|/* enable MSI-X support*/
name|tmp
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|tmp
operator||=
name|E1000_CTRL_EXT_PBA_CLR
expr_stmt|;
comment|/* Auto-Mask interrupts upon ICR read. */
name|tmp
operator||=
name|E1000_CTRL_EXT_EIAME
expr_stmt|;
name|tmp
operator||=
name|E1000_CTRL_EXT_IRCA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Queues */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|tmp
operator|=
name|E1000_EICR_RX_QUEUE0
operator|<<
name|i
expr_stmt|;
name|tmp
operator||=
name|E1000_EICR_TX_QUEUE0
operator|<<
name|i
expr_stmt|;
name|que
operator|->
name|eims
operator|=
name|tmp
expr_stmt|;
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MSIXBM
argument_list|(
literal|0
argument_list|)
argument_list|,
name|i
argument_list|,
name|que
operator|->
name|eims
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|que_mask
operator||=
name|que
operator|->
name|eims
expr_stmt|;
block|}
comment|/* Link */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MSIXBM
argument_list|(
name|adapter
operator|->
name|linkvec
argument_list|)
argument_list|,
name|E1000_EIMS_OTHER
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|link_mask
operator||=
name|E1000_EIMS_OTHER
expr_stmt|;
default|default:
break|break;
block|}
comment|/* Set the starting interrupt rate */
if|if
condition|(
name|igb_max_interrupt_rate
operator|>
literal|0
condition|)
name|newitr
operator|=
operator|(
literal|4000000
operator|/
name|igb_max_interrupt_rate
operator|)
operator|&
literal|0x7FFC
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
name|newitr
operator||=
name|newitr
operator|<<
literal|16
expr_stmt|;
else|else
name|newitr
operator||=
name|E1000_EITR_CNT_IGNR
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EITR
argument_list|(
name|que
operator|->
name|msix
argument_list|)
argument_list|,
name|newitr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_free_pci_resources
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|igb_queue
modifier|*
name|que
init|=
name|adapter
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
comment|/* 	** There is a slight possibility of a failure mode 	** in attach that will result in entering this function 	** before interrupt resources have been initialized, and 	** in that case we do not want to execute the loops below 	** We can detect this reliably by the state of the adapter 	** res pointer. 	*/
if|if
condition|(
name|adapter
operator|->
name|res
operator|==
name|NULL
condition|)
goto|goto
name|mem
goto|;
comment|/* 	 * First release all the interrupt resources: 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|rid
operator|=
name|que
operator|->
name|msix
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|que
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
name|que
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|que
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|que
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
comment|/* Clean the Legacy or Link interrupt last */
if|if
condition|(
name|adapter
operator|->
name|linkvec
condition|)
comment|/* we are doing MSIX */
name|rid
operator|=
name|adapter
operator|->
name|linkvec
operator|+
literal|1
expr_stmt|;
else|else
operator|(
name|adapter
operator|->
name|msix
operator|!=
literal|0
operator|)
condition|?
operator|(
name|rid
operator|=
literal|1
operator|)
else|:
operator|(
name|rid
operator|=
literal|0
operator|)
expr_stmt|;
name|que
operator|=
name|adapter
operator|->
name|queues
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|adapter
operator|->
name|link_task
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|res
argument_list|,
name|adapter
operator|->
name|tag
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|adapter
operator|->
name|res
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
if|if
condition|(
name|que
operator|->
name|tq
operator|!=
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
name|taskqueue_drain
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|txr
operator|->
name|txq_task
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|taskqueue_drain
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|que_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
block|}
name|mem
label|:
if|if
condition|(
name|adapter
operator|->
name|msix
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|adapter
operator|->
name|memrid
argument_list|,
name|adapter
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|pci_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|adapter
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup Either MSI/X or MSI  */
end_comment

begin_function
specifier|static
name|int
name|igb_setup_msix
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|bar
decl_stmt|,
name|want
decl_stmt|,
name|queues
decl_stmt|,
name|msgs
decl_stmt|,
name|maxqueues
decl_stmt|;
comment|/* tuneable override */
if|if
condition|(
name|igb_enable_msix
operator|==
literal|0
condition|)
goto|goto
name|msi
goto|;
comment|/* First try MSI/X */
name|msgs
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgs
operator|==
literal|0
condition|)
goto|goto
name|msi
goto|;
comment|/* 	** Some new devices, as with ixgbe, now may 	** use a different BAR, so we need to keep 	** track of which is used. 	*/
name|adapter
operator|->
name|memrid
operator|=
name|PCIR_BAR
argument_list|(
name|IGB_MSIX_BAR
argument_list|)
expr_stmt|;
name|bar
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|adapter
operator|->
name|memrid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|bar
operator|==
literal|0
condition|)
comment|/* use next bar */
name|adapter
operator|->
name|memrid
operator|+=
literal|4
expr_stmt|;
name|adapter
operator|->
name|msix_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|adapter
operator|->
name|memrid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|==
name|NULL
condition|)
block|{
comment|/* May not be enabled */
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Unable to map MSIX table \n"
argument_list|)
expr_stmt|;
goto|goto
name|msi
goto|;
block|}
name|queues
operator|=
operator|(
name|mp_ncpus
operator|>
operator|(
name|msgs
operator|-
literal|1
operator|)
operator|)
condition|?
operator|(
name|msgs
operator|-
literal|1
operator|)
else|:
name|mp_ncpus
expr_stmt|;
comment|/* Override via tuneable */
if|if
condition|(
name|igb_num_queues
operator|!=
literal|0
condition|)
name|queues
operator|=
name|igb_num_queues
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* If we're doing RSS, clamp at the number of RSS buckets */
if|if
condition|(
name|queues
operator|>
name|rss_getnumbuckets
argument_list|()
condition|)
name|queues
operator|=
name|rss_getnumbuckets
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Sanity check based on HW */
switch|switch
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82575
case|:
name|maxqueues
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|e1000_82576
case|:
case|case
name|e1000_82580
case|:
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
name|maxqueues
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|e1000_i210
case|:
name|maxqueues
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|e1000_i211
case|:
name|maxqueues
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
comment|/* VF interfaces */
name|maxqueues
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Final clamp on the actual hardware capability */
if|if
condition|(
name|queues
operator|>
name|maxqueues
condition|)
name|queues
operator|=
name|maxqueues
expr_stmt|;
comment|/* 	** One vector (RX/TX pair) per queue 	** plus an additional for Link interrupt 	*/
name|want
operator|=
name|queues
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|msgs
operator|>=
name|want
condition|)
name|msgs
operator|=
name|want
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"MSIX Configuration Problem, "
literal|"%d vectors configured, but %d queues wanted!\n"
argument_list|,
name|msgs
argument_list|,
name|want
argument_list|)
expr_stmt|;
goto|goto
name|msi
goto|;
block|}
if|if
condition|(
operator|(
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|msgs
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|msgs
operator|==
name|want
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"Using MSIX interrupts with %d vectors\n"
argument_list|,
name|msgs
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|num_queues
operator|=
name|queues
expr_stmt|;
return|return
operator|(
name|msgs
operator|)
return|;
block|}
comment|/* 	** If MSIX alloc failed or provided us with 	** less than needed, free and fall through to MSI 	*/
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|msi
label|:
if|if
condition|(
name|adapter
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
name|IGB_MSIX_BAR
argument_list|)
argument_list|,
name|adapter
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|msix_mem
operator|=
name|NULL
expr_stmt|;
block|}
name|msgs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|msgs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|" Using an MSI interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|msgs
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|" Using a Legacy interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize the DMA Coalescing feature  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_init_dmac
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|u32
name|pba
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|dmac
decl_stmt|,
name|reg
init|=
operator|~
name|E1000_DMACR_DMAC_EN
decl_stmt|;
name|u16
name|hwm
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i211
condition|)
return|return;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>
name|e1000_82580
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|dmac
operator|==
literal|0
condition|)
block|{
comment|/* Disabling it */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMACR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DMA Coalescing enabled\n"
argument_list|)
expr_stmt|;
comment|/* Set starting threshold */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMCTXTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hwm
operator|=
literal|64
operator|*
name|pba
operator|-
name|adapter
operator|->
name|max_frame_size
operator|/
literal|16
expr_stmt|;
if|if
condition|(
name|hwm
operator|<
literal|64
operator|*
operator|(
name|pba
operator|-
literal|6
operator|)
condition|)
name|hwm
operator|=
literal|64
operator|*
operator|(
name|pba
operator|-
literal|6
operator|)
expr_stmt|;
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCRTC
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|E1000_FCRTC_RTH_COAL_MASK
expr_stmt|;
name|reg
operator||=
operator|(
operator|(
name|hwm
operator|<<
name|E1000_FCRTC_RTH_COAL_SHIFT
operator|)
operator|&
name|E1000_FCRTC_RTH_COAL_MASK
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCRTC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|dmac
operator|=
name|pba
operator|-
name|adapter
operator|->
name|max_frame_size
operator|/
literal|512
expr_stmt|;
if|if
condition|(
name|dmac
operator|<
name|pba
operator|-
literal|10
condition|)
name|dmac
operator|=
name|pba
operator|-
literal|10
expr_stmt|;
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMACR
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|E1000_DMACR_DMACTHR_MASK
expr_stmt|;
name|reg
operator|=
operator|(
operator|(
name|dmac
operator|<<
name|E1000_DMACR_DMACTHR_SHIFT
operator|)
operator|&
name|E1000_DMACR_DMACTHR_MASK
operator|)
expr_stmt|;
comment|/* transition to L0x or L1 if available..*/
name|reg
operator||=
operator|(
name|E1000_DMACR_DMAC_EN
operator||
name|E1000_DMACR_DMAC_LX_MASK
operator|)
expr_stmt|;
comment|/* Check if status is 2.5Gb backplane connection 		* before configuration of watchdog timer, which is 		* in msec values in 12.8usec intervals 		* watchdog timer= msec values in 32usec intervals 		* for non 2.5Gb connection 		*/
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i354
condition|)
block|{
name|int
name|status
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|E1000_STATUS_2P5_SKU
operator|)
operator|&&
operator|(
operator|!
operator|(
name|status
operator|&
name|E1000_STATUS_2P5_SKU_OVER
operator|)
operator|)
condition|)
name|reg
operator||=
operator|(
operator|(
name|adapter
operator|->
name|dmac
operator|*
literal|5
operator|)
operator|>>
literal|6
operator|)
expr_stmt|;
else|else
name|reg
operator||=
operator|(
name|adapter
operator|->
name|dmac
operator|>>
literal|5
operator|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator||=
operator|(
name|adapter
operator|->
name|dmac
operator|>>
literal|5
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMACR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMCRTRH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the interval before transition */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMCTLX
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i350
condition|)
name|reg
operator||=
name|IGB_DMCTLX_DCFLUSH_DIS
expr_stmt|;
comment|/* 		** in 2.5Gb connection, TTLX unit is 0.4 usec 		** which is 0x4*2 = 0xA. But delay is still 4 usec 		*/
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i354
condition|)
block|{
name|int
name|status
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|E1000_STATUS_2P5_SKU
operator|)
operator|&&
operator|(
operator|!
operator|(
name|status
operator|&
name|E1000_STATUS_2P5_SKU_OVER
operator|)
operator|)
condition|)
name|reg
operator||=
literal|0xA
expr_stmt|;
else|else
name|reg
operator||=
literal|0x4
expr_stmt|;
block|}
else|else
block|{
name|reg
operator||=
literal|0x4
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMCTLX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* free space in tx packet buffer to wake from DMA coal */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMCTXTH
argument_list|,
operator|(
name|IGB_TXPBSIZE
operator|-
operator|(
literal|2
operator|*
name|adapter
operator|->
name|max_frame_size
operator|)
operator|)
operator|>>
literal|6
argument_list|)
expr_stmt|;
comment|/* make low power state decision controlled by DMA coal */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCIEMISC
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|E1000_PCIEMISC_LX_DECISION
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCIEMISC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82580
condition|)
block|{
name|u32
name|reg
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCIEMISC
argument_list|)
decl_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCIEMISC
argument_list|,
name|reg
operator|&
operator|~
name|E1000_PCIEMISC_LX_DECISION
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DMACR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Set up an fresh starting state  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_reset
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|e1000_fc_info
modifier|*
name|fc
init|=
operator|&
name|hw
operator|->
name|fc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|u32
name|pba
init|=
literal|0
decl_stmt|;
name|u16
name|hwm
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"igb_reset: begin"
argument_list|)
expr_stmt|;
comment|/* Let the firmware know the OS is in control */
name|igb_get_hw_control
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	 * Packet Buffer Allocation (PBA) 	 * Writing PBA sets the receive portion of the buffer 	 * the remainder is used for the transmit buffer. 	 */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82575
case|:
name|pba
operator|=
name|E1000_PBA_32K
expr_stmt|;
break|break;
case|case
name|e1000_82576
case|:
case|case
name|e1000_vfadapt
case|:
name|pba
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXPBS
argument_list|)
expr_stmt|;
name|pba
operator|&=
name|E1000_RXPBS_SIZE_MASK_82576
expr_stmt|;
break|break;
case|case
name|e1000_82580
case|:
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
case|case
name|e1000_vfadapt_i350
case|:
name|pba
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXPBS
argument_list|)
expr_stmt|;
name|pba
operator|=
name|e1000_rxpbs_adjust_82580
argument_list|(
name|pba
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_i210
case|:
case|case
name|e1000_i211
case|:
name|pba
operator|=
name|E1000_PBA_34K
expr_stmt|;
default|default:
break|break;
block|}
comment|/* Special needs in case of Jumbo frames */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82575
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
operator|)
condition|)
block|{
name|u32
name|tx_space
decl_stmt|,
name|min_tx
decl_stmt|,
name|min_rx
decl_stmt|;
name|pba
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA
argument_list|)
expr_stmt|;
name|tx_space
operator|=
name|pba
operator|>>
literal|16
expr_stmt|;
name|pba
operator|&=
literal|0xffff
expr_stmt|;
name|min_tx
operator|=
operator|(
name|adapter
operator|->
name|max_frame_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
operator|-
name|ETHERNET_FCS_SIZE
operator|)
operator|*
literal|2
expr_stmt|;
name|min_tx
operator|=
name|roundup2
argument_list|(
name|min_tx
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|min_tx
operator|>>=
literal|10
expr_stmt|;
name|min_rx
operator|=
name|adapter
operator|->
name|max_frame_size
expr_stmt|;
name|min_rx
operator|=
name|roundup2
argument_list|(
name|min_rx
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|min_rx
operator|>>=
literal|10
expr_stmt|;
if|if
condition|(
name|tx_space
operator|<
name|min_tx
operator|&&
operator|(
operator|(
name|min_tx
operator|-
name|tx_space
operator|)
operator|<
name|pba
operator|)
condition|)
block|{
name|pba
operator|=
name|pba
operator|-
operator|(
name|min_tx
operator|-
name|tx_space
operator|)
expr_stmt|;
comment|/*                          * if short on rx space, rx wins                          * and must trump tx adjustment 			 */
if|if
condition|(
name|pba
operator|<
name|min_rx
condition|)
name|pba
operator|=
name|min_rx
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA
argument_list|,
name|pba
argument_list|)
expr_stmt|;
block|}
name|INIT_DEBUGOUT1
argument_list|(
literal|"igb_init: pba=%dK"
argument_list|,
name|pba
argument_list|)
expr_stmt|;
comment|/* 	 * These parameters control the automatic generation (Tx) and 	 * response (Rx) to Ethernet PAUSE frames. 	 * - High water mark should allow for at least two frames to be 	 *   received after sending an XOFF. 	 * - Low water mark works best when it is very near the high water mark. 	 *   This allows the receiver to restart by sending XON when it has 	 *   drained a bit. 	 */
name|hwm
operator|=
name|min
argument_list|(
operator|(
operator|(
name|pba
operator|<<
literal|10
operator|)
operator|*
literal|9
operator|/
literal|10
operator|)
argument_list|,
operator|(
operator|(
name|pba
operator|<<
literal|10
operator|)
operator|-
literal|2
operator|*
name|adapter
operator|->
name|max_frame_size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_82576
condition|)
block|{
name|fc
operator|->
name|high_water
operator|=
name|hwm
operator|&
literal|0xFFF8
expr_stmt|;
comment|/* 8-byte granularity */
name|fc
operator|->
name|low_water
operator|=
name|fc
operator|->
name|high_water
operator|-
literal|8
expr_stmt|;
block|}
else|else
block|{
name|fc
operator|->
name|high_water
operator|=
name|hwm
operator|&
literal|0xFFF0
expr_stmt|;
comment|/* 16-byte granularity */
name|fc
operator|->
name|low_water
operator|=
name|fc
operator|->
name|high_water
operator|-
literal|16
expr_stmt|;
block|}
name|fc
operator|->
name|pause_time
operator|=
name|IGB_FC_PAUSE_TIME
expr_stmt|;
name|fc
operator|->
name|send_xon
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|fc
condition|)
name|fc
operator|->
name|requested_mode
operator|=
name|adapter
operator|->
name|fc
expr_stmt|;
else|else
name|fc
operator|->
name|requested_mode
operator|=
name|e1000_fc_default
expr_stmt|;
comment|/* Issue a global reset */
name|e1000_reset_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset for AutoMediaDetect */
if|if
condition|(
name|adapter
operator|->
name|flags
operator|&
name|IGB_MEDIA_RESET
condition|)
block|{
name|e1000_setup_init_funcs
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|e1000_get_bus_info
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|flags
operator|&=
operator|~
name|IGB_MEDIA_RESET
expr_stmt|;
block|}
if|if
condition|(
name|e1000_init_hw
argument_list|(
name|hw
argument_list|)
operator|<
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hardware Initialization Failed\n"
argument_list|)
expr_stmt|;
comment|/* Setup DMA Coalescing */
name|igb_init_dmac
argument_list|(
name|adapter
argument_list|,
name|pba
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_VET
argument_list|,
name|ETHERTYPE_VLAN
argument_list|)
expr_stmt|;
name|e1000_get_phy_info
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|e1000_check_for_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup networking device structure and register an interface.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_setup_interface
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"igb_setup_interface: begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|igb_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|adapter
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|igb_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_get_counter
operator|=
name|igb_get_counter
expr_stmt|;
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
name|ifp
operator|->
name|if_transmit
operator|=
name|igb_mq_start
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|igb_qflush
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_start
operator|=
name|igb_start
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|adapter
operator|->
name|num_tx_desc
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|adapter
operator|->
name|num_tx_desc
operator|-
literal|1
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|ifp
operator|->
name|if_capenable
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWCSUM
operator||
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_JUMBO_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* Don't enable LRO by default */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_LRO
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_POLLING
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Tell the upper layer(s) we 	 * support full VLAN capability. 	 */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_MTU
expr_stmt|;
comment|/* 	** Don't turn this on by default, if vlans are 	** created on another pseudo device (eg. lagg) 	** then vlan events are not passed thru, breaking 	** operation, but with HW FILTER off it works. If 	** using vlans directly on the igb driver you can 	** enable this and get full hardware tag filtering. 	*/
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
name|ifmedia_init
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|igb_media_change
argument_list|,
name|igb_media_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_fiber
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
operator|)
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|type
operator|!=
name|e1000_phy_ife
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|ifmedia_add
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|adapter
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Manage DMA'able memory.  */
end_comment

begin_function
specifier|static
name|void
name|igb_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
condition|)
return|return;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|igb_dma_malloc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|struct
name|igb_dma_alloc
modifier|*
name|dma
parameter_list|,
name|int
name|mapflags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent */
name|IGB_DBA_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|size
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: bus_dma_tag_create failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_0
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: bus_dmamem_alloc(%ju) failed: %d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|size
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_2
goto|;
block|}
name|dma
operator|->
name|dma_paddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|size
argument_list|,
name|igb_dmamap_cb
argument_list|,
operator|&
name|dma
operator|->
name|dma_paddr
argument_list|,
name|mapflags
operator||
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|dma
operator|->
name|dma_paddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|adapter
operator|->
name|dev
argument_list|,
literal|"%s: bus_dmamap_load failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_3
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail_3
label|:
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|fail_2
label|:
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|fail_0
label|:
name|dma
operator|->
name|dma_tag
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_dma_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|igb_dma_alloc
modifier|*
name|dma
parameter_list|)
block|{
if|if
condition|(
name|dma
operator|->
name|dma_tag
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dma
operator|->
name|dma_paddr
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_paddr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dma
operator|->
name|dma_vaddr
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_vaddr
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_tag
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for the transmit and receive rings, and then  *  the descriptors associated with each, called only once at attach.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_allocate_queues
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|igb_queue
modifier|*
name|que
init|=
name|NULL
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|NULL
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|NULL
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|tsize
decl_stmt|,
name|error
init|=
name|E1000_SUCCESS
decl_stmt|;
name|int
name|txconf
init|=
literal|0
decl_stmt|,
name|rxconf
init|=
literal|0
decl_stmt|;
comment|/* First allocate the top level queue structs */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|queues
operator|=
operator|(
expr|struct
name|igb_queue
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|igb_queue
argument_list|)
operator|*
name|adapter
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate queue memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Next allocate the TX ring struct memory */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|tx_rings
operator|=
operator|(
expr|struct
name|tx_ring
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tx_ring
argument_list|)
operator|*
name|adapter
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX ring memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|tx_fail
goto|;
block|}
comment|/* Now allocate the RX */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|rx_rings
operator|=
operator|(
expr|struct
name|rx_ring
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rx_ring
argument_list|)
operator|*
name|adapter
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RX ring memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|rx_fail
goto|;
block|}
name|tsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|e1000_adv_tx_desc
argument_list|)
argument_list|,
name|IGB_DBA_ALIGN
argument_list|)
expr_stmt|;
comment|/* 	 * Now set up the TX queues, txconf is needed to handle the 	 * possibility that things fail midcourse and we need to 	 * undo memory gracefully 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txconf
operator|++
control|)
block|{
comment|/* Set up some basics */
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|txr
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|txr
operator|->
name|me
operator|=
name|i
expr_stmt|;
name|txr
operator|->
name|num_desc
operator|=
name|adapter
operator|->
name|num_tx_desc
expr_stmt|;
comment|/* Initialize the TX lock */
name|snprintf
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:tx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|txr
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|txr
operator|->
name|tx_mtx
argument_list|,
name|txr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|igb_dma_malloc
argument_list|(
name|adapter
argument_list|,
name|tsize
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
name|txr
operator|->
name|tx_base
operator|=
operator|(
expr|union
name|e1000_adv_tx_desc
operator|*
operator|)
name|txr
operator|->
name|txdma
operator|.
name|dma_vaddr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|tx_base
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
comment|/* Now allocate transmit buffers for the ring */
if|if
condition|(
name|igb_allocate_transmit_buffers
argument_list|(
name|txr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up transmit buffers\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
comment|/* Allocate a buf ring */
name|txr
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
name|igb_buf_ring_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|txr
operator|->
name|tx_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Next the RX queues... 	 */
name|rsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|e1000_adv_rx_desc
argument_list|)
argument_list|,
name|IGB_DBA_ALIGN
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxconf
operator|++
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|rxr
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|rxr
operator|->
name|me
operator|=
name|i
expr_stmt|;
comment|/* Initialize the RX lock */
name|snprintf
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:rx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|txr
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rxr
operator|->
name|rx_mtx
argument_list|,
name|rxr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|igb_dma_malloc
argument_list|(
name|adapter
argument_list|,
name|rsize
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RxDescriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
name|rxr
operator|->
name|rx_base
operator|=
operator|(
expr|union
name|e1000_adv_rx_desc
operator|*
operator|)
name|rxr
operator|->
name|rxdma
operator|.
name|dma_vaddr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|rx_base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* Allocate receive buffers for the ring*/
if|if
condition|(
name|igb_allocate_receive_buffers
argument_list|(
name|rxr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up receive buffers\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
block|}
comment|/* 	** Finally set up the queue holding structs 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|que
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|que
operator|->
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|que
operator|->
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err_rx_desc
label|:
for|for
control|(
name|rxr
operator|=
name|adapter
operator|->
name|rx_rings
init|;
name|rxconf
operator|>
literal|0
condition|;
name|rxr
operator|++
operator|,
name|rxconf
operator|--
control|)
name|igb_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|)
expr_stmt|;
name|err_tx_desc
label|:
for|for
control|(
name|txr
operator|=
name|adapter
operator|->
name|tx_rings
init|;
name|txconf
operator|>
literal|0
condition|;
name|txr
operator|++
operator|,
name|txconf
operator|--
control|)
name|igb_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|rx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rx_fail
label|:
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
name|buf_ring_free
argument_list|(
name|txr
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|adapter
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|tx_fail
label|:
name|free
argument_list|(
name|adapter
operator|->
name|queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for tx_buffer structures. The tx_buffer stores all  *  the information needed to transmit a packet on the wire. This is  *  called only once at attach, setup is done every reset.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_allocate_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|igb_tx_buf
modifier|*
name|txbuf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Setup DMA descriptor areas. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|IGB_TSO_SIZE
argument_list|,
comment|/* maxsize */
name|IGB_MAX_SCATTER
argument_list|,
comment|/* nsegments */
name|PAGE_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|txr
operator|->
name|txtag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|txr
operator|->
name|tx_buffers
operator|=
operator|(
expr|struct
name|igb_tx_buf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|igb_tx_buf
argument_list|)
operator|*
name|adapter
operator|->
name|num_tx_desc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate tx_buffer memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create the descriptor buffer dma maps */
name|txbuf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
operator|,
name|txbuf
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
literal|0
argument_list|,
operator|&
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create TX DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
literal|0
return|;
name|fail
label|:
comment|/* We free all, it handles case where we are in the middle */
name|igb_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize a transmit ring.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_setup_transmit_ring
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|igb_tx_buf
modifier|*
name|txbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
comment|/* Clear the old descriptor contents */
name|IGB_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|slot
operator|=
name|netmap_reset
argument_list|(
name|na
argument_list|,
name|NR_TX
argument_list|,
name|txr
operator|->
name|me
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|tx_base
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|e1000_adv_tx_desc
argument_list|)
operator|)
operator|*
name|adapter
operator|->
name|num_tx_desc
argument_list|)
expr_stmt|;
comment|/* Reset indices */
name|txr
operator|->
name|next_avail_desc
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|next_to_clean
operator|=
literal|0
expr_stmt|;
comment|/* Free any existing tx buffers. */
name|txbuf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
operator|,
name|txbuf
operator|++
control|)
block|{
if|if
condition|(
name|txbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|txbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|slot
condition|)
block|{
name|int
name|si
init|=
name|netmap_idx_n2k
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|txr
operator|->
name|me
index|]
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* no need to set the address */
name|netmap_load_map
argument_list|(
name|na
argument_list|,
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|,
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
operator|+
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
comment|/* clear the watch index */
name|txbuf
operator|->
name|eop
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Set number of descriptors available */
name|txr
operator|->
name|tx_avail
operator|=
name|adapter
operator|->
name|num_tx_desc
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|IGB_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize all transmit rings.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_setup_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
name|igb_setup_transmit_ring
argument_list|(
name|txr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Enable transmit unit.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_initialize_transmit_units
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|tctl
decl_stmt|,
name|txdctl
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"igb_initialize_transmit_units: begin"
argument_list|)
expr_stmt|;
name|tctl
operator|=
name|txdctl
operator|=
literal|0
expr_stmt|;
comment|/* Setup the Tx Descriptor Rings */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|u64
name|bus_addr
init|=
name|txr
operator|->
name|txdma
operator|.
name|dma_paddr
decl_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDLEN
argument_list|(
name|i
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_tx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDBAH
argument_list|(
name|i
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|bus_addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDBAL
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|bus_addr
argument_list|)
expr_stmt|;
comment|/* Setup the HW Tx Head and Tail descriptor pointers */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HW_DEBUGOUT2
argument_list|(
literal|"Base = %x, Length = %x\n"
argument_list|,
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDBAL
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TDLEN
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|queue_status
operator|=
name|IGB_QUEUE_IDLE
expr_stmt|;
name|txdctl
operator||=
name|IGB_TX_PTHRESH
expr_stmt|;
name|txdctl
operator||=
name|IGB_TX_HTHRESH
operator|<<
literal|8
expr_stmt|;
name|txdctl
operator||=
name|IGB_TX_WTHRESH
operator|<<
literal|16
expr_stmt|;
name|txdctl
operator||=
name|E1000_TXDCTL_QUEUE_ENABLE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|txdctl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adapter
operator|->
name|vf_ifp
condition|)
return|return;
name|e1000_config_collision_dist
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Program the Transmit Control Register */
name|tctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|)
expr_stmt|;
name|tctl
operator|&=
operator|~
name|E1000_TCTL_CT
expr_stmt|;
name|tctl
operator||=
operator|(
name|E1000_TCTL_PSP
operator||
name|E1000_TCTL_RTLC
operator||
name|E1000_TCTL_EN
operator||
operator|(
name|E1000_COLLISION_THRESHOLD
operator|<<
name|E1000_CT_SHIFT
operator|)
operator|)
expr_stmt|;
comment|/* This write will effectively turn on the transmit unit. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|tctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free all transmit rings.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_free_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|IGB_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|igb_free_transmit_buffers
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|igb_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|)
expr_stmt|;
name|IGB_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|IGB_TX_LOCK_DESTROY
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|adapter
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free transmit ring related data structures.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_free_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|igb_tx_buf
modifier|*
name|tx_buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"free_transmit_ring: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_buffers
operator|==
name|NULL
condition|)
return|return;
name|tx_buffer
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
operator|,
name|tx_buffer
operator|++
control|)
block|{
if|if
condition|(
name|tx_buffer
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tx_buffer
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tx_buffer
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tx_buffer
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
if|if
condition|(
name|txr
operator|->
name|br
operator|!=
name|NULL
condition|)
name|buf_ring_free
argument_list|(
name|txr
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|txr
operator|->
name|tx_buffers
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|txr
operator|->
name|tx_buffers
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tx_buffers
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txr
operator|->
name|txtag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|)
expr_stmt|;
name|txr
operator|->
name|txtag
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Setup work for hardware segmentation offload (TSO) on  *  adapters using advanced tx descriptors  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_tso_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|u32
modifier|*
name|cmd_type_len
parameter_list|,
name|u32
modifier|*
name|olinfo_status
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|e1000_adv_tx_context_desc
modifier|*
name|TXD
decl_stmt|;
name|u32
name|vlan_macip_lens
init|=
literal|0
decl_stmt|,
name|type_tucmd_mlhl
init|=
literal|0
decl_stmt|;
name|u32
name|mss_l4len_idx
init|=
literal|0
decl_stmt|,
name|paylen
decl_stmt|;
name|u16
name|vtag
init|=
literal|0
decl_stmt|,
name|eh_type
decl_stmt|;
name|int
name|ctxd
decl_stmt|,
name|ehdrlen
decl_stmt|,
name|ip_hlen
decl_stmt|,
name|tcp_hlen
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
endif|#
directive|endif
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
comment|/* 	 * Determine where frame payload starts. 	 * Jump over vlan headers if already present 	 */
name|eh
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|eh_type
operator|=
name|eh
operator|->
name|evl_proto
expr_stmt|;
block|}
else|else
block|{
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|eh_type
operator|=
name|eh
operator|->
name|evl_encap_proto
expr_stmt|;
block|}
switch|switch
condition|(
name|ntohs
argument_list|(
name|eh_type
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
comment|/* XXX-BZ For now we do not pretend to support ext. hdrs. */
if|if
condition|(
name|ip6
operator|->
name|ip6_nxt
operator|!=
name|IPPROTO_TCP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ip_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6
operator|+
name|ip_hlen
operator|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in6_cksum_pseudo
argument_list|(
name|ip6
argument_list|,
literal|0
argument_list|,
name|IPPROTO_TCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_IPV6
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|!=
name|IPPROTO_TCP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|ip_hlen
operator|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_IPV4
expr_stmt|;
comment|/* Tell transmit desc to also do IPv4 checksum. */
operator|*
name|olinfo_status
operator||=
name|E1000_TXD_POPTS_IXSM
operator|<<
literal|8
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"%s: CSUM_TSO but no supported IP version (0x%04x)"
argument_list|,
name|__func__
argument_list|,
name|ntohs
argument_list|(
name|eh_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|ctxd
operator|=
name|txr
operator|->
name|next_avail_desc
expr_stmt|;
name|TXD
operator|=
operator|(
expr|struct
name|e1000_adv_tx_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|ctxd
index|]
expr_stmt|;
name|tcp_hlen
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
comment|/* This is used in the transmit desc in encap */
name|paylen
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|ehdrlen
operator|-
name|ip_hlen
operator|-
name|tcp_hlen
expr_stmt|;
comment|/* VLAN MACLEN IPLEN */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|vtag
operator|=
name|htole16
argument_list|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|vlan_macip_lens
operator||=
operator|(
name|vtag
operator|<<
name|E1000_ADVTXD_VLAN_SHIFT
operator|)
expr_stmt|;
block|}
name|vlan_macip_lens
operator||=
name|ehdrlen
operator|<<
name|E1000_ADVTXD_MACLEN_SHIFT
expr_stmt|;
name|vlan_macip_lens
operator||=
name|ip_hlen
expr_stmt|;
name|TXD
operator|->
name|vlan_macip_lens
operator|=
name|htole32
argument_list|(
name|vlan_macip_lens
argument_list|)
expr_stmt|;
comment|/* ADV DTYPE TUCMD */
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_DCMD_DEXT
operator||
name|E1000_ADVTXD_DTYP_CTXT
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_L4T_TCP
expr_stmt|;
name|TXD
operator|->
name|type_tucmd_mlhl
operator|=
name|htole32
argument_list|(
name|type_tucmd_mlhl
argument_list|)
expr_stmt|;
comment|/* MSS L4LEN IDX */
name|mss_l4len_idx
operator||=
operator|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|<<
name|E1000_ADVTXD_MSS_SHIFT
operator|)
expr_stmt|;
name|mss_l4len_idx
operator||=
operator|(
name|tcp_hlen
operator|<<
name|E1000_ADVTXD_L4LEN_SHIFT
operator|)
expr_stmt|;
comment|/* 82575 needs the queue index added */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
name|mss_l4len_idx
operator||=
name|txr
operator|->
name|me
operator|<<
literal|4
expr_stmt|;
name|TXD
operator|->
name|mss_l4len_idx
operator|=
name|htole32
argument_list|(
name|mss_l4len_idx
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|seqnum_seed
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|ctxd
operator|==
name|txr
operator|->
name|num_desc
condition|)
name|ctxd
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|tx_avail
operator|--
expr_stmt|;
name|txr
operator|->
name|next_avail_desc
operator|=
name|ctxd
expr_stmt|;
operator|*
name|cmd_type_len
operator||=
name|E1000_ADVTXD_DCMD_TSE
expr_stmt|;
operator|*
name|olinfo_status
operator||=
name|E1000_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
operator|*
name|olinfo_status
operator||=
name|paylen
operator|<<
name|E1000_ADVTXD_PAYLEN_SHIFT
expr_stmt|;
operator|++
name|txr
operator|->
name|tso_tx
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Advanced Context Descriptor setup for VLAN, CSUM or TSO  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_tx_ctx_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|u32
modifier|*
name|cmd_type_len
parameter_list|,
name|u32
modifier|*
name|olinfo_status
parameter_list|)
block|{
name|struct
name|e1000_adv_tx_context_desc
modifier|*
name|TXD
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|u32
name|vlan_macip_lens
init|=
literal|0
decl_stmt|,
name|type_tucmd_mlhl
init|=
literal|0
decl_stmt|,
name|mss_l4len_idx
init|=
literal|0
decl_stmt|;
name|int
name|ehdrlen
decl_stmt|,
name|ip_hlen
init|=
literal|0
decl_stmt|;
name|u16
name|etype
decl_stmt|;
name|u8
name|ipproto
init|=
literal|0
decl_stmt|;
name|int
name|offload
init|=
name|TRUE
decl_stmt|;
name|int
name|ctxd
init|=
name|txr
operator|->
name|next_avail_desc
decl_stmt|;
name|u16
name|vtag
init|=
literal|0
decl_stmt|;
comment|/* First check if TSO is to be used */
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
return|return
operator|(
name|igb_tso_setup
argument_list|(
name|txr
argument_list|,
name|mp
argument_list|,
name|cmd_type_len
argument_list|,
name|olinfo_status
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_OFFLOAD
operator|)
operator|==
literal|0
condition|)
name|offload
operator|=
name|FALSE
expr_stmt|;
comment|/* Indicate the whole packet as payload when not doing TSO */
operator|*
name|olinfo_status
operator||=
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|<<
name|E1000_ADVTXD_PAYLEN_SHIFT
expr_stmt|;
comment|/* Now ready a context descriptor */
name|TXD
operator|=
operator|(
expr|struct
name|e1000_adv_tx_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|ctxd
index|]
expr_stmt|;
comment|/* 	** In advanced descriptors the vlan tag must  	** be placed into the context descriptor. Hence 	** we need to make one even if not doing offloads. 	*/
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|vtag
operator|=
name|htole16
argument_list|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|vlan_macip_lens
operator||=
operator|(
name|vtag
operator|<<
name|E1000_ADVTXD_VLAN_SHIFT
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offload
operator|==
name|FALSE
condition|)
comment|/* ... no offload to do */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Determine where frame payload starts. 	 * Jump over vlan headers if already present, 	 * helpful for QinQ too. 	 */
name|eh
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
else|else
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
block|}
comment|/* Set the ether header length */
name|vlan_macip_lens
operator||=
name|ehdrlen
operator|<<
name|E1000_ADVTXD_MACLEN_SHIFT
expr_stmt|;
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|ipproto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_IPV4
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|ip_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
comment|/* XXX-BZ this will go badly in case of ext hdrs. */
name|ipproto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_IPV6
expr_stmt|;
break|break;
default|default:
name|offload
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|vlan_macip_lens
operator||=
name|ip_hlen
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_DCMD_DEXT
operator||
name|E1000_ADVTXD_DTYP_CTXT
expr_stmt|;
switch|switch
condition|(
name|ipproto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
condition|)
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_L4T_TCP
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
condition|)
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_L4T_UDP
expr_stmt|;
break|break;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
case|case
name|IPPROTO_SCTP
case|:
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_SCTP
condition|)
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_L4T_SCTP
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|offload
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|offload
condition|)
comment|/* For the TX descriptor setup */
operator|*
name|olinfo_status
operator||=
name|E1000_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
comment|/* 82575 needs the queue index added */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
name|mss_l4len_idx
operator|=
name|txr
operator|->
name|me
operator|<<
literal|4
expr_stmt|;
comment|/* Now copy bits into descriptor */
name|TXD
operator|->
name|vlan_macip_lens
operator|=
name|htole32
argument_list|(
name|vlan_macip_lens
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|type_tucmd_mlhl
operator|=
name|htole32
argument_list|(
name|type_tucmd_mlhl
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|seqnum_seed
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|mss_l4len_idx
operator|=
name|htole32
argument_list|(
name|mss_l4len_idx
argument_list|)
expr_stmt|;
comment|/* We've consumed the first desc, adjust counters */
if|if
condition|(
operator|++
name|ctxd
operator|==
name|txr
operator|->
name|num_desc
condition|)
name|ctxd
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|next_avail_desc
operator|=
name|ctxd
expr_stmt|;
operator|--
name|txr
operator|->
name|tx_avail
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Examine each tx_buffer in the used queue. If the hardware is done  *  processing the packet then free associated resources. The  *  tx_buffer is put back on the free queue.  *  *  TRUE return means there's work in the ring to clean, FALSE its empty.  **********************************************************************/
end_comment

begin_function
specifier|static
name|bool
name|igb_txeof
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|u32
name|work
decl_stmt|,
name|processed
init|=
literal|0
decl_stmt|;
name|u16
name|limit
init|=
name|txr
operator|->
name|process_limit
decl_stmt|;
name|struct
name|igb_tx_buf
modifier|*
name|buf
decl_stmt|;
name|union
name|e1000_adv_tx_desc
modifier|*
name|txd
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txr
operator|->
name|tx_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|netmap_tx_irq
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|me
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|==
name|txr
operator|->
name|num_desc
condition|)
block|{
name|txr
operator|->
name|queue_status
operator|=
name|IGB_QUEUE_IDLE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Get work starting point */
name|work
operator|=
name|txr
operator|->
name|next_to_clean
expr_stmt|;
name|buf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|work
index|]
expr_stmt|;
name|txd
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|work
index|]
expr_stmt|;
name|work
operator|-=
name|txr
operator|->
name|num_desc
expr_stmt|;
comment|/* The distance to ring end */
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
do|do
block|{
name|union
name|e1000_adv_tx_desc
modifier|*
name|eop
init|=
name|buf
operator|->
name|eop
decl_stmt|;
if|if
condition|(
name|eop
operator|==
name|NULL
condition|)
comment|/* No work */
break|break;
if|if
condition|(
operator|(
name|eop
operator|->
name|wb
operator|.
name|status
operator|&
name|E1000_TXD_STAT_DD
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* I/O not complete */
if|if
condition|(
name|buf
operator|->
name|m_head
condition|)
block|{
name|txr
operator|->
name|bytes
operator|+=
name|buf
operator|->
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|buf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
name|buf
operator|->
name|eop
operator|=
name|NULL
expr_stmt|;
operator|++
name|txr
operator|->
name|tx_avail
expr_stmt|;
comment|/* We clean the range if multi segment */
while|while
condition|(
name|txd
operator|!=
name|eop
condition|)
block|{
operator|++
name|txd
expr_stmt|;
operator|++
name|buf
expr_stmt|;
operator|++
name|work
expr_stmt|;
comment|/* wrap the ring? */
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|work
argument_list|)
condition|)
block|{
name|work
operator|-=
name|txr
operator|->
name|num_desc
expr_stmt|;
name|buf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
name|txd
operator|=
name|txr
operator|->
name|tx_base
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|m_head
condition|)
block|{
name|txr
operator|->
name|bytes
operator|+=
name|buf
operator|->
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|buf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
operator|++
name|txr
operator|->
name|tx_avail
expr_stmt|;
name|buf
operator|->
name|eop
operator|=
name|NULL
expr_stmt|;
block|}
operator|++
name|txr
operator|->
name|packets
expr_stmt|;
operator|++
name|processed
expr_stmt|;
name|txr
operator|->
name|watchdog_time
operator|=
name|ticks
expr_stmt|;
comment|/* Try the next packet */
operator|++
name|txd
expr_stmt|;
operator|++
name|buf
expr_stmt|;
operator|++
name|work
expr_stmt|;
comment|/* reset with a wrap */
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|work
argument_list|)
condition|)
block|{
name|work
operator|-=
name|txr
operator|->
name|num_desc
expr_stmt|;
name|buf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
name|txd
operator|=
name|txr
operator|->
name|tx_base
expr_stmt|;
block|}
name|prefetch
argument_list|(
name|txd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|__predict_true
argument_list|(
operator|--
name|limit
argument_list|)
condition|)
do|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|work
operator|+=
name|txr
operator|->
name|num_desc
expr_stmt|;
name|txr
operator|->
name|next_to_clean
operator|=
name|work
expr_stmt|;
comment|/* 	** Watchdog calculation, we know there's 	** work outstanding or the first return 	** would have been taken, so none processed 	** for too long indicates a hang. 	*/
if|if
condition|(
operator|(
operator|!
name|processed
operator|)
operator|&&
operator|(
operator|(
name|ticks
operator|-
name|txr
operator|->
name|watchdog_time
operator|)
operator|>
name|IGB_WATCHDOG
operator|)
condition|)
name|txr
operator|->
name|queue_status
operator||=
name|IGB_QUEUE_HUNG
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|>=
name|IGB_QUEUE_THRESHOLD
condition|)
name|txr
operator|->
name|queue_status
operator|&=
operator|~
name|IGB_QUEUE_DEPLETED
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|==
name|txr
operator|->
name|num_desc
condition|)
block|{
name|txr
operator|->
name|queue_status
operator|=
name|IGB_QUEUE_IDLE
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Refresh mbuf buffers for RX descriptor rings  *   - now keeps its own state so discards due to resource  *     exhaustion are unnecessary, if an mbuf cannot be obtained  *     it just returns, keeping its placeholder, thus it can simply  *     be recalled to try again.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_refresh_mbufs
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|bus_dma_segment_t
name|hseg
index|[
literal|1
index|]
decl_stmt|;
name|bus_dma_segment_t
name|pseg
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|igb_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mh
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nsegs
decl_stmt|,
name|error
decl_stmt|;
name|bool
name|refreshed
init|=
name|FALSE
decl_stmt|;
name|i
operator|=
name|j
operator|=
name|rxr
operator|->
name|next_to_refresh
expr_stmt|;
comment|/* 	** Get one descriptor beyond 	** our work mark to control 	** the loop.         */
if|if
condition|(
operator|++
name|j
operator|==
name|adapter
operator|->
name|num_rx_desc
condition|)
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|!=
name|limit
condition|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
comment|/* No hdr mbuf used with header split off */
if|if
condition|(
name|rxr
operator|->
name|hdr_split
operator|==
name|FALSE
condition|)
goto|goto
name|no_split
goto|;
if|if
condition|(
name|rxbuf
operator|->
name|m_head
operator|==
name|NULL
condition|)
block|{
name|mh
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
goto|goto
name|update
goto|;
block|}
else|else
name|mh
operator|=
name|rxbuf
operator|->
name|m_head
expr_stmt|;
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mh
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
name|mh
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
name|mh
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
comment|/* Get the memory mapping */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|rxbuf
operator|->
name|hmap
argument_list|,
name|mh
argument_list|,
name|hseg
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Refresh mbufs: hdr dmamap load"
literal|" failure - %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
goto|goto
name|update
goto|;
block|}
name|rxbuf
operator|->
name|m_head
operator|=
name|mh
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|rxbuf
operator|->
name|hmap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
operator|.
name|read
operator|.
name|hdr_addr
operator|=
name|htole64
argument_list|(
name|hseg
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|no_split
label|:
if|if
condition|(
name|rxbuf
operator|->
name|m_pack
operator|==
name|NULL
condition|)
block|{
name|mp
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|adapter
operator|->
name|rx_mbuf_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
goto|goto
name|update
goto|;
block|}
else|else
name|mp
operator|=
name|rxbuf
operator|->
name|m_pack
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mp
operator|->
name|m_len
operator|=
name|adapter
operator|->
name|rx_mbuf_sz
expr_stmt|;
comment|/* Get the memory mapping */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|mp
argument_list|,
name|pseg
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Refresh mbufs: payload dmamap load"
literal|" failure - %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_pack
operator|=
name|NULL
expr_stmt|;
goto|goto
name|update
goto|;
block|}
name|rxbuf
operator|->
name|m_pack
operator|=
name|mp
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
name|htole64
argument_list|(
name|pseg
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|refreshed
operator|=
name|TRUE
expr_stmt|;
comment|/* I feel wefreshed :) */
name|i
operator|=
name|j
expr_stmt|;
comment|/* our next is precalculated */
name|rxr
operator|->
name|next_to_refresh
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|++
name|j
operator|==
name|adapter
operator|->
name|num_rx_desc
condition|)
name|j
operator|=
literal|0
expr_stmt|;
block|}
name|update
label|:
if|if
condition|(
name|refreshed
condition|)
comment|/* update tail */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|rxr
operator|->
name|next_to_refresh
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for rx_buffer structures. Since we use one  *  rx_buffer per received packet, the maximum number of rx_buffer's  *  that we'll need is equal to the number of receive descriptors  *  that we've allocated.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_allocate_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|igb_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bsize
decl_stmt|,
name|error
decl_stmt|;
name|bsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|igb_rx_buf
argument_list|)
operator|*
name|adapter
operator|->
name|num_rx_desc
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rxr
operator|->
name|rx_buffers
operator|=
operator|(
expr|struct
name|igb_rx_buf
operator|*
operator|)
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate rx_buffer memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MSIZE
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MSIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|rxr
operator|->
name|htag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MJUM9BYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MJUM9BYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|rxr
operator|->
name|ptag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX payload DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|i
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
literal|0
argument_list|,
operator|&
name|rxbuf
operator|->
name|hmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX head DMA maps\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
literal|0
argument_list|,
operator|&
name|rxbuf
operator|->
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX packet DMA maps\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
comment|/* Frees all, but can handle partial completion */
name|igb_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_free_receive_ring
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|struct
name|igb_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|i
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|rxbuf
operator|->
name|hmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|rxbuf
operator|->
name|hmap
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_head
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rxbuf
operator|->
name|m_pack
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_pack
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|m_pack
argument_list|)
expr_stmt|;
block|}
name|rxbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|rxbuf
operator|->
name|m_pack
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize a receive ring and its buffers.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_setup_receive_ring
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|igb_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|bus_dma_segment_t
name|pseg
index|[
literal|1
index|]
decl_stmt|,
name|hseg
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|lro
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|nsegs
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|rxr
operator|->
name|adapter
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|adapter
operator|=
name|rxr
operator|->
name|adapter
expr_stmt|;
name|dev
operator|=
name|adapter
operator|->
name|dev
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
comment|/* Clear the ring contents */
name|IGB_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|slot
operator|=
name|netmap_reset
argument_list|(
name|na
argument_list|,
name|NR_RX
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|rsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|e1000_adv_rx_desc
argument_list|)
argument_list|,
name|IGB_DBA_ALIGN
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|rx_base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* 	** Free current RX buffer structures and their mbufs 	*/
name|igb_free_receive_ring
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
comment|/* Configure for header split? */
if|if
condition|(
name|igb_header_split
condition|)
name|rxr
operator|->
name|hdr_split
operator|=
name|TRUE
expr_stmt|;
comment|/* Now replenish the ring mbufs */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|mbuf
modifier|*
name|mh
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|j
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|slot
condition|)
block|{
comment|/* slot sj is mapped to the j-th NIC-ring entry */
name|int
name|sj
init|=
name|netmap_idx_n2k
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|rxr
operator|->
name|me
index|]
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|uint64_t
name|paddr
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|PNMB
argument_list|(
name|na
argument_list|,
name|slot
operator|+
name|sj
argument_list|,
operator|&
name|paddr
argument_list|)
expr_stmt|;
name|netmap_load_map
argument_list|(
name|na
argument_list|,
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Update descriptor */
name|rxr
operator|->
name|rx_base
index|[
name|j
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
name|htole64
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
if|if
condition|(
name|rxr
operator|->
name|hdr_split
operator|==
name|FALSE
condition|)
goto|goto
name|skip_head
goto|;
comment|/* First the header */
name|rxbuf
operator|->
name|m_head
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|m_head
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_adj
argument_list|(
name|rxbuf
operator|->
name|m_head
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
name|mh
operator|=
name|rxbuf
operator|->
name|m_head
expr_stmt|;
name|mh
operator|->
name|m_len
operator|=
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MHLEN
expr_stmt|;
name|mh
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
comment|/* Get the memory mapping */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|rxbuf
operator|->
name|hmap
argument_list|,
name|rxbuf
operator|->
name|m_head
argument_list|,
name|hseg
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
comment|/* Nothing elegant to do here */
goto|goto
name|fail
goto|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|rxbuf
operator|->
name|hmap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Update descriptor */
name|rxr
operator|->
name|rx_base
index|[
name|j
index|]
operator|.
name|read
operator|.
name|hdr_addr
operator|=
name|htole64
argument_list|(
name|hseg
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|skip_head
label|:
comment|/* Now the payload cluster */
name|rxbuf
operator|->
name|m_pack
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|adapter
operator|->
name|rx_mbuf_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|m_pack
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|mp
operator|=
name|rxbuf
operator|->
name|m_pack
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mp
operator|->
name|m_len
operator|=
name|adapter
operator|->
name|rx_mbuf_sz
expr_stmt|;
comment|/* Get the memory mapping */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|mp
argument_list|,
name|pseg
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Update descriptor */
name|rxr
operator|->
name|rx_base
index|[
name|j
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
name|htole64
argument_list|(
name|pseg
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
comment|/* Setup our descriptor indices */
name|rxr
operator|->
name|next_to_check
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|next_to_refresh
operator|=
name|adapter
operator|->
name|num_rx_desc
operator|-
literal|1
expr_stmt|;
name|rxr
operator|->
name|lro_enabled
operator|=
name|FALSE
expr_stmt|;
name|rxr
operator|->
name|rx_split_packets
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|rx_bytes
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|rxr
operator|->
name|lmp
operator|=
name|NULL
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	** Now set up the LRO interface, we 	** also only do head split when LRO 	** is enabled, since so often they 	** are undesireable in similar setups. 	*/
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
condition|)
block|{
name|error
operator|=
name|tcp_lro_init
argument_list|(
name|lro
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"LRO Initialization failed!\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|INIT_DEBUGOUT
argument_list|(
literal|"RX LRO Initialized\n"
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|lro_enabled
operator|=
name|TRUE
expr_stmt|;
name|lro
operator|->
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
block|}
name|IGB_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|igb_free_receive_ring
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|IGB_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize all receive rings.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_setup_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
if|if
condition|(
name|igb_setup_receive_ring
argument_list|(
name|rxr
argument_list|)
condition|)
goto|goto
name|fail
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
comment|/* 	 * Free RX buffers allocated so far, we will only handle 	 * the rings that completed, the failing case will have 	 * cleaned up for itself. 'i' is the endpoint. 	 */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|j
index|]
expr_stmt|;
name|IGB_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|igb_free_receive_ring
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|IGB_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialise the RSS mapping for NICs that support multiple transmit/  * receive rings.  */
end_comment

begin_function
specifier|static
name|void
name|igb_initialise_rss_mapping
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|queue_id
decl_stmt|;
name|u32
name|reta
decl_stmt|;
name|u32
name|rss_key
index|[
literal|10
index|]
decl_stmt|,
name|mrqc
decl_stmt|,
name|shift
init|=
literal|0
decl_stmt|;
comment|/* XXX? */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
name|shift
operator|=
literal|6
expr_stmt|;
comment|/* 	 * The redirection table controls which destination 	 * queue each bucket redirects traffic to. 	 * Each DWORD represents four queues, with the LSB 	 * being the first queue in the DWORD. 	 * 	 * This just allocates buckets to queues using round-robin 	 * allocation. 	 * 	 * NOTE: It Just Happens to line up with the default 	 * RSS allocation method. 	 */
comment|/* Warning FM follows */
name|reta
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|RSS
name|queue_id
operator|=
name|rss_get_indirection_to_bucket
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * If we have more queues than buckets, we'll 		 * end up mapping buckets to a subset of the 		 * queues. 		 * 		 * If we have more buckets than queues, we'll 		 * end up instead assigning multiple buckets 		 * to queues. 		 * 		 * Both are suboptimal, but we need to handle 		 * the case so we don't go out of bounds 		 * indexing arrays and such. 		 */
name|queue_id
operator|=
name|queue_id
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
else|#
directive|else
name|queue_id
operator|=
operator|(
name|i
operator|%
name|adapter
operator|->
name|num_queues
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* Adjust if required */
name|queue_id
operator|=
name|queue_id
operator|<<
name|shift
expr_stmt|;
comment|/* 		 * The low 8 bits are for hash value (n+0); 		 * The next 8 bits are for hash value (n+1), etc. 		 */
name|reta
operator|=
name|reta
operator|>>
literal|8
expr_stmt|;
name|reta
operator|=
name|reta
operator||
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|queue_id
operator|)
operator|<<
literal|24
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RETA
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
argument_list|,
name|reta
argument_list|)
expr_stmt|;
name|reta
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Now fill in hash table */
comment|/* 	 * MRQC: Multiple Receive Queues Command 	 * Set queuing to RSS control, number depends on the device. 	 */
name|mrqc
operator|=
name|E1000_MRQC_ENABLE_RSS_8Q
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* XXX ew typecasting */
name|rss_getkey
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|rss_key
argument_list|)
expr_stmt|;
else|#
directive|else
name|arc4rand
argument_list|(
operator|&
name|rss_key
argument_list|,
sizeof|sizeof
argument_list|(
name|rss_key
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_RSSRK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|i
argument_list|,
name|rss_key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Configure the RSS fields to hash upon. 	 */
name|mrqc
operator||=
operator|(
name|E1000_MRQC_RSS_FIELD_IPV4
operator||
name|E1000_MRQC_RSS_FIELD_IPV4_TCP
operator|)
expr_stmt|;
name|mrqc
operator||=
operator|(
name|E1000_MRQC_RSS_FIELD_IPV6
operator||
name|E1000_MRQC_RSS_FIELD_IPV6_TCP
operator|)
expr_stmt|;
name|mrqc
operator||=
operator|(
name|E1000_MRQC_RSS_FIELD_IPV4_UDP
operator||
name|E1000_MRQC_RSS_FIELD_IPV6_UDP
operator|)
expr_stmt|;
name|mrqc
operator||=
operator|(
name|E1000_MRQC_RSS_FIELD_IPV6_UDP_EX
operator||
name|E1000_MRQC_RSS_FIELD_IPV6_TCP_EX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MRQC
argument_list|,
name|mrqc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Enable receive unit.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_initialize_receive_units
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|rctl
decl_stmt|,
name|rxcsum
decl_stmt|,
name|psize
decl_stmt|,
name|srrctl
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"igb_initialize_receive_unit: begin"
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure receives are disabled while setting 	 * up the descriptor ring 	 */
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|rctl
operator|&
operator|~
name|E1000_RCTL_EN
argument_list|)
expr_stmt|;
comment|/* 	** Set up for header split 	*/
if|if
condition|(
name|igb_header_split
condition|)
block|{
comment|/* Use a standard mbuf for the header */
name|srrctl
operator||=
name|IGB_HDR_BUF
operator|<<
name|E1000_SRRCTL_BSIZEHDRSIZE_SHIFT
expr_stmt|;
name|srrctl
operator||=
name|E1000_SRRCTL_DESCTYPE_HDR_SPLIT_ALWAYS
expr_stmt|;
block|}
else|else
name|srrctl
operator||=
name|E1000_SRRCTL_DESCTYPE_ADV_ONEBUF
expr_stmt|;
comment|/* 	** Set up for jumbo frames 	*/
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|rctl
operator||=
name|E1000_RCTL_LPE
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|rx_mbuf_sz
operator|==
name|MJUMPAGESIZE
condition|)
block|{
name|srrctl
operator||=
literal|4096
operator|>>
name|E1000_SRRCTL_BSIZEPKT_SHIFT
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_SZ_4096
operator||
name|E1000_RCTL_BSEX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adapter
operator|->
name|rx_mbuf_sz
operator|>
name|MJUMPAGESIZE
condition|)
block|{
name|srrctl
operator||=
literal|8192
operator|>>
name|E1000_SRRCTL_BSIZEPKT_SHIFT
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_SZ_8192
operator||
name|E1000_RCTL_BSEX
expr_stmt|;
block|}
comment|/* Set maximum packet len */
name|psize
operator|=
name|adapter
operator|->
name|max_frame_size
expr_stmt|;
comment|/* are we on a vlan? */
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
name|psize
operator|+=
name|VLAN_TAG_SIZE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RLPML
argument_list|,
name|psize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rctl
operator|&=
operator|~
name|E1000_RCTL_LPE
expr_stmt|;
name|srrctl
operator||=
literal|2048
operator|>>
name|E1000_SRRCTL_BSIZEPKT_SHIFT
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_SZ_2048
expr_stmt|;
block|}
comment|/* 	 * If TX flow control is disabled and there's>1 queue defined, 	 * enable DROP. 	 * 	 * This drops frames rather than hanging the RX MAC for all queues. 	 */
if|if
condition|(
operator|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
operator|)
operator|&&
operator|(
name|adapter
operator|->
name|fc
operator|==
name|e1000_fc_none
operator|||
name|adapter
operator|->
name|fc
operator|==
name|e1000_fc_rx_pause
operator|)
condition|)
block|{
name|srrctl
operator||=
name|E1000_SRRCTL_DROP_EN
expr_stmt|;
block|}
comment|/* Setup the Base and Length of the Rx Descriptor Rings */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|u64
name|bus_addr
init|=
name|rxr
operator|->
name|rxdma
operator|.
name|dma_paddr
decl_stmt|;
name|u32
name|rxdctl
decl_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDLEN
argument_list|(
name|i
argument_list|)
argument_list|,
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_rx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDBAH
argument_list|(
name|i
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|bus_addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDBAL
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|bus_addr
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SRRCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|srrctl
argument_list|)
expr_stmt|;
comment|/* Enable this Queue */
name|rxdctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|rxdctl
operator||=
name|E1000_RXDCTL_QUEUE_ENABLE
expr_stmt|;
name|rxdctl
operator|&=
literal|0xFFF00000
expr_stmt|;
name|rxdctl
operator||=
name|IGB_RX_PTHRESH
expr_stmt|;
name|rxdctl
operator||=
name|IGB_RX_HTHRESH
operator|<<
literal|8
expr_stmt|;
name|rxdctl
operator||=
name|IGB_RX_WTHRESH
operator|<<
literal|16
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxdctl
argument_list|)
expr_stmt|;
block|}
comment|/* 	** Setup for RX MultiQueue 	*/
name|rxcsum
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCSUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
block|{
comment|/* rss setup */
name|igb_initialise_rss_mapping
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 		** NOTE: Receive Full-Packet Checksum Offload  		** is mutually exclusive with Multiqueue. However 		** this is not the same as TCP/IP checksums which 		** still work. 		*/
name|rxcsum
operator||=
name|E1000_RXCSUM_PCSD
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
comment|/* For SCTP Offload */
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82576
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
condition|)
name|rxcsum
operator||=
name|E1000_RXCSUM_CRCOFL
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Non RSS setup */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
name|rxcsum
operator||=
name|E1000_RXCSUM_IPPCSE
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82576
condition|)
name|rxcsum
operator||=
name|E1000_RXCSUM_CRCOFL
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|rxcsum
operator|&=
operator|~
name|E1000_RXCSUM_TUOFL
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXCSUM
argument_list|,
name|rxcsum
argument_list|)
expr_stmt|;
comment|/* Setup the Receive Control Register */
name|rctl
operator|&=
operator|~
operator|(
literal|3
operator|<<
name|E1000_RCTL_MO_SHIFT
operator|)
expr_stmt|;
name|rctl
operator||=
name|E1000_RCTL_EN
operator||
name|E1000_RCTL_BAM
operator||
name|E1000_RCTL_LBM_NO
operator||
name|E1000_RCTL_RDMTS_HALF
operator||
operator|(
name|hw
operator|->
name|mac
operator|.
name|mc_filter_type
operator|<<
name|E1000_RCTL_MO_SHIFT
operator|)
expr_stmt|;
comment|/* Strip CRC bytes. */
name|rctl
operator||=
name|E1000_RCTL_SECRC
expr_stmt|;
comment|/* Make sure VLAN Filters are off */
name|rctl
operator|&=
operator|~
name|E1000_RCTL_VFE
expr_stmt|;
comment|/* Don't store bad packets */
name|rctl
operator|&=
operator|~
name|E1000_RCTL_SBP
expr_stmt|;
comment|/* Enable Receives */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the HW Rx Head and Tail Descriptor Pointers 	 *   - needs to be after enable 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDH
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxr
operator|->
name|next_to_check
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* 		 * an init() while a netmap client is active must 		 * preserve the rx buffers passed to userspace. 		 * In this driver it means we adjust RDT to 		 * something different from next_to_refresh 		 * (which is not used in netmap mode). 		 */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
decl_stmt|;
name|int
name|t
init|=
name|rxr
operator|->
name|next_to_refresh
operator|-
name|nm_kr_rxspace
argument_list|(
name|kring
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|>=
name|adapter
operator|->
name|num_rx_desc
condition|)
name|t
operator|-=
name|adapter
operator|->
name|num_rx_desc
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|t
operator|+=
name|adapter
operator|->
name|num_rx_desc
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDT
argument_list|(
name|i
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDT
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxr
operator|->
name|next_to_refresh
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free receive rings.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_free_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|lro
decl_stmt|;
name|igb_free_receive_buffers
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|tcp_lro_free
argument_list|(
name|lro
argument_list|)
expr_stmt|;
name|igb_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|adapter
operator|->
name|rx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free receive ring data structures.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_free_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|struct
name|igb_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"free_receive_structures: begin"
argument_list|)
expr_stmt|;
comment|/* Cleanup any existing buffers */
if|if
condition|(
name|rxr
operator|->
name|rx_buffers
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|i
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|rxbuf
operator|->
name|hmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|rxbuf
operator|->
name|hmap
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_head
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rxbuf
operator|->
name|m_pack
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|m_pack
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|m_pack
argument_list|)
expr_stmt|;
block|}
name|rxbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|rxbuf
operator|->
name|m_pack
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|hmap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|rxbuf
operator|->
name|hmap
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|hmap
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rxbuf
operator|->
name|pmap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|pmap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rxr
operator|->
name|rx_buffers
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rxr
operator|->
name|rx_buffers
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|rx_buffers
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rxr
operator|->
name|htag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|rxr
operator|->
name|htag
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|htag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rxr
operator|->
name|ptag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|ptag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|igb_rx_discard
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|igb_rx_buf
modifier|*
name|rbuf
decl_stmt|;
name|rbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
comment|/* Partially received? Free the chain */
if|if
condition|(
name|rxr
operator|->
name|fmp
operator|!=
name|NULL
condition|)
block|{
name|rxr
operator|->
name|fmp
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|rxr
operator|->
name|fmp
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|rxr
operator|->
name|lmp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	** With advanced descriptors the writeback 	** clobbers the buffer addrs, so its easier 	** to just free the existing mbufs and take 	** the normal refresh path to get new buffers 	** and mapping. 	*/
if|if
condition|(
name|rbuf
operator|->
name|m_head
condition|)
block|{
name|m_free
argument_list|(
name|rbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|rbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|rbuf
operator|->
name|hmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rbuf
operator|->
name|m_pack
condition|)
block|{
name|m_free
argument_list|(
name|rbuf
operator|->
name|m_pack
argument_list|)
expr_stmt|;
name|rbuf
operator|->
name|m_pack
operator|=
name|NULL
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rbuf
operator|->
name|pmap
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|igb_rx_input
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u32
name|ptype
parameter_list|)
block|{
comment|/* 	 * ATM LRO is only for IPv4/TCP packets and TCP checksum of the packet 	 * should be computed by hardware. Also it should not have VLAN tag in 	 * ethernet header. 	 */
if|if
condition|(
name|rxr
operator|->
name|lro_enabled
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ptype
operator|&
name|E1000_RXDADV_PKTTYPE_ETQF
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ptype
operator|&
operator|(
name|E1000_RXDADV_PKTTYPE_IPV4
operator||
name|E1000_RXDADV_PKTTYPE_TCP
operator|)
operator|)
operator|==
operator|(
name|E1000_RXDADV_PKTTYPE_IPV4
operator||
name|E1000_RXDADV_PKTTYPE_TCP
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
operator|)
operator|==
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
condition|)
block|{
comment|/* 		 * Send to the stack if: 		 **  - LRO not enabled, or 		 **  - no LRO resources, or 		 **  - lro enqueue fails 		 */
if|if
condition|(
name|rxr
operator|->
name|lro
operator|.
name|lro_cnt
operator|!=
literal|0
condition|)
if|if
condition|(
name|tcp_lro_rx
argument_list|(
operator|&
name|rxr
operator|->
name|lro
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
block|}
name|IGB_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IGB_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine executes in interrupt context. It replenishes  *  the mbufs in the descriptor and sends data which has been  *  dma'ed into host memory to upper layer.  *  *  We loop at most count times if count is> 0, or until done if  *  count< 0.  *  *  Return TRUE if more to clean, FALSE otherwise  *********************************************************************/
end_comment

begin_function
specifier|static
name|bool
name|igb_rxeof
parameter_list|(
name|struct
name|igb_queue
modifier|*
name|que
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|done
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|que
operator|->
name|adapter
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|lro
decl_stmt|;
name|struct
name|lro_entry
modifier|*
name|queued
decl_stmt|;
name|int
name|i
decl_stmt|,
name|processed
init|=
literal|0
decl_stmt|,
name|rxdone
init|=
literal|0
decl_stmt|;
name|u32
name|ptype
decl_stmt|,
name|staterr
init|=
literal|0
decl_stmt|;
name|union
name|e1000_adv_rx_desc
modifier|*
name|cur
decl_stmt|;
name|IGB_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
comment|/* Sync the ring. */
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|netmap_rx_irq
argument_list|(
name|ifp
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
operator|&
name|processed
argument_list|)
condition|)
block|{
name|IGB_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
comment|/* Main clean loop */
for|for
control|(
name|i
operator|=
name|rxr
operator|->
name|next_to_check
init|;
name|count
operator|!=
literal|0
condition|;
control|)
block|{
name|struct
name|mbuf
modifier|*
name|sendmp
decl_stmt|,
modifier|*
name|mh
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|struct
name|igb_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|u16
name|hlen
decl_stmt|,
name|plen
decl_stmt|,
name|hdr
decl_stmt|,
name|vtag
decl_stmt|,
name|pkt_info
decl_stmt|;
name|bool
name|eop
init|=
name|FALSE
decl_stmt|;
name|cur
operator|=
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
expr_stmt|;
name|staterr
operator|=
name|le32toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|staterr
operator|&
name|E1000_RXD_STAT_DD
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
name|count
operator|--
expr_stmt|;
name|sendmp
operator|=
name|mh
operator|=
name|mp
operator|=
name|NULL
expr_stmt|;
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
operator|=
literal|0
expr_stmt|;
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
name|plen
operator|=
name|le16toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|length
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|le32toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|lower
operator|.
name|lo_dword
operator|.
name|data
argument_list|)
operator|&
name|IGB_PKTTYPE_MASK
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_i350
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_i354
operator|)
operator|)
operator|&&
operator|(
name|staterr
operator|&
name|E1000_RXDEXT_STATERR_LB
operator|)
condition|)
name|vtag
operator|=
name|be16toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|vlan
argument_list|)
expr_stmt|;
else|else
name|vtag
operator|=
name|le16toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|vlan
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|le16toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|lower
operator|.
name|lo_dword
operator|.
name|hs_rss
operator|.
name|hdr_info
argument_list|)
expr_stmt|;
name|pkt_info
operator|=
name|le16toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|lower
operator|.
name|lo_dword
operator|.
name|hs_rss
operator|.
name|pkt_info
argument_list|)
expr_stmt|;
name|eop
operator|=
operator|(
operator|(
name|staterr
operator|&
name|E1000_RXD_STAT_EOP
operator|)
operator|==
name|E1000_RXD_STAT_EOP
operator|)
expr_stmt|;
comment|/* 		 * Free the frame (all segments) if we're at EOP and 		 * it's an error. 		 * 		 * The datasheet states that EOP + status is only valid for 		 * the final segment in a multi-segment frame. 		 */
if|if
condition|(
name|eop
operator|&&
operator|(
operator|(
name|staterr
operator|&
name|E1000_RXDEXT_ERR_FRAME_ERR_MASK
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|adapter
operator|->
name|dropped_pkts
operator|++
expr_stmt|;
operator|++
name|rxr
operator|->
name|rx_discarded
expr_stmt|;
name|igb_rx_discard
argument_list|(
name|rxr
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|next_desc
goto|;
block|}
comment|/* 		** The way the hardware is configured to 		** split, it will ONLY use the header buffer 		** when header split is enabled, otherwise we 		** get normal behavior, ie, both header and 		** payload are DMA'd into the payload buffer. 		** 		** The fmp test is to catch the case where a 		** packet spans multiple descriptors, in that 		** case only the first header is valid. 		*/
if|if
condition|(
name|rxr
operator|->
name|hdr_split
operator|&&
name|rxr
operator|->
name|fmp
operator|==
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|rxbuf
operator|->
name|hmap
argument_list|)
expr_stmt|;
name|hlen
operator|=
operator|(
name|hdr
operator|&
name|E1000_RXDADV_HDRBUFLEN_MASK
operator|)
operator|>>
name|E1000_RXDADV_HDRBUFLEN_SHIFT
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
name|IGB_HDR_BUF
condition|)
name|hlen
operator|=
name|IGB_HDR_BUF
expr_stmt|;
name|mh
operator|=
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
operator|.
name|m_head
expr_stmt|;
name|mh
operator|->
name|m_len
operator|=
name|hlen
expr_stmt|;
comment|/* clear buf pointer for refresh */
name|rxbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
comment|/* 			** Get the payload length, this 			** could be zero if its a small 			** packet. 			*/
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
block|{
name|mp
operator|=
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
operator|.
name|m_pack
expr_stmt|;
name|mp
operator|->
name|m_len
operator|=
name|plen
expr_stmt|;
name|mh
operator|->
name|m_next
operator|=
name|mp
expr_stmt|;
comment|/* clear buf pointer */
name|rxbuf
operator|->
name|m_pack
operator|=
name|NULL
expr_stmt|;
name|rxr
operator|->
name|rx_split_packets
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			** Either no header split, or a 			** secondary piece of a fragmented 			** split packet. 			*/
name|mh
operator|=
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
operator|.
name|m_pack
expr_stmt|;
name|mh
operator|->
name|m_len
operator|=
name|plen
expr_stmt|;
comment|/* clear buf info for refresh */
name|rxbuf
operator|->
name|m_pack
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|)
expr_stmt|;
operator|++
name|processed
expr_stmt|;
comment|/* So we know when to refresh */
comment|/* Initial frame - setup */
if|if
condition|(
name|rxr
operator|->
name|fmp
operator|==
name|NULL
condition|)
block|{
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mh
operator|->
name|m_len
expr_stmt|;
comment|/* Save the head of the chain */
name|rxr
operator|->
name|fmp
operator|=
name|mh
expr_stmt|;
name|rxr
operator|->
name|lmp
operator|=
name|mh
expr_stmt|;
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
block|{
comment|/* Add payload if split */
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
name|rxr
operator|->
name|lmp
operator|=
name|mh
operator|->
name|m_next
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Chain mbuf's together */
name|rxr
operator|->
name|lmp
operator|->
name|m_next
operator|=
name|mh
expr_stmt|;
name|rxr
operator|->
name|lmp
operator|=
name|rxr
operator|->
name|lmp
operator|->
name|m_next
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|mh
operator|->
name|m_len
expr_stmt|;
block|}
if|if
condition|(
name|eop
condition|)
block|{
name|rxr
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|rxr
operator|->
name|rx_packets
operator|++
expr_stmt|;
comment|/* capture data for AIM */
name|rxr
operator|->
name|packets
operator|++
expr_stmt|;
name|rxr
operator|->
name|bytes
operator|+=
name|rxr
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|rxr
operator|->
name|rx_bytes
operator|+=
name|rxr
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|igb_rx_checksum
argument_list|(
name|staterr
argument_list|,
name|rxr
operator|->
name|fmp
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|staterr
operator|&
name|E1000_RXD_STAT_VP
operator|)
operator|!=
literal|0
condition|)
block|{
name|rxr
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|vtag
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
comment|/* 			 * In case of multiqueue, we have RXCSUM.PCSD bit set 			 * and never cleared. This means we have RSS hash 			 * available to be used. 			 */
if|if
condition|(
name|adapter
operator|->
name|num_queues
operator|>
literal|1
condition|)
block|{
name|rxr
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|le32toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|lower
operator|.
name|hi_dword
operator|.
name|rss
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pkt_info
operator|&
name|E1000_RXDADV_RSSTYPE_MASK
condition|)
block|{
case|case
name|E1000_RXDADV_RSSTYPE_IPV4_TCP
case|:
name|M_HASHTYPE_SET
argument_list|(
name|rxr
operator|->
name|fmp
argument_list|,
name|M_HASHTYPE_RSS_TCP_IPV4
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_RXDADV_RSSTYPE_IPV4
case|:
name|M_HASHTYPE_SET
argument_list|(
name|rxr
operator|->
name|fmp
argument_list|,
name|M_HASHTYPE_RSS_IPV4
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_RXDADV_RSSTYPE_IPV6_TCP
case|:
name|M_HASHTYPE_SET
argument_list|(
name|rxr
operator|->
name|fmp
argument_list|,
name|M_HASHTYPE_RSS_TCP_IPV6
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_RXDADV_RSSTYPE_IPV6_EX
case|:
name|M_HASHTYPE_SET
argument_list|(
name|rxr
operator|->
name|fmp
argument_list|,
name|M_HASHTYPE_RSS_IPV6_EX
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_RXDADV_RSSTYPE_IPV6
case|:
name|M_HASHTYPE_SET
argument_list|(
name|rxr
operator|->
name|fmp
argument_list|,
name|M_HASHTYPE_RSS_IPV6
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1000_RXDADV_RSSTYPE_IPV6_TCP_EX
case|:
name|M_HASHTYPE_SET
argument_list|(
name|rxr
operator|->
name|fmp
argument_list|,
name|M_HASHTYPE_RSS_TCP_IPV6_EX
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* XXX fallthrough */
name|M_HASHTYPE_SET
argument_list|(
name|rxr
operator|->
name|fmp
argument_list|,
name|M_HASHTYPE_OPAQUE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
name|rxr
operator|->
name|fmp
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|que
operator|->
name|msix
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|rxr
operator|->
name|fmp
argument_list|,
name|M_HASHTYPE_OPAQUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sendmp
operator|=
name|rxr
operator|->
name|fmp
expr_stmt|;
comment|/* Make sure to set M_PKTHDR. */
name|sendmp
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|rxr
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|rxr
operator|->
name|lmp
operator|=
name|NULL
expr_stmt|;
block|}
name|next_desc
label|:
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Advance our pointers to the next descriptor. */
if|if
condition|(
operator|++
name|i
operator|==
name|adapter
operator|->
name|num_rx_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* 		** Send to the stack or LRO 		*/
if|if
condition|(
name|sendmp
operator|!=
name|NULL
condition|)
block|{
name|rxr
operator|->
name|next_to_check
operator|=
name|i
expr_stmt|;
name|igb_rx_input
argument_list|(
name|rxr
argument_list|,
name|ifp
argument_list|,
name|sendmp
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|i
operator|=
name|rxr
operator|->
name|next_to_check
expr_stmt|;
name|rxdone
operator|++
expr_stmt|;
block|}
comment|/* Every 8 descriptors we go to refresh mbufs */
if|if
condition|(
name|processed
operator|==
literal|8
condition|)
block|{
name|igb_refresh_mbufs
argument_list|(
name|rxr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|processed
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Catch any remainders */
if|if
condition|(
name|igb_rx_unrefreshed
argument_list|(
name|rxr
argument_list|)
condition|)
name|igb_refresh_mbufs
argument_list|(
name|rxr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|next_to_check
operator|=
name|i
expr_stmt|;
comment|/* 	 * Flush any outstanding LRO work 	 */
while|while
condition|(
operator|(
name|queued
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|tcp_lro_flush
argument_list|(
name|lro
argument_list|,
name|queued
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|!=
name|NULL
condition|)
operator|*
name|done
operator|+=
name|rxdone
expr_stmt|;
name|IGB_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|staterr
operator|&
name|E1000_RXD_STAT_DD
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Verify that the hardware indicated that the checksum is valid.  *  Inform the stack about the status of checksum so that stack  *  doesn't spend time verifying the checksum.  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_rx_checksum
parameter_list|(
name|u32
name|staterr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|u32
name|ptype
parameter_list|)
block|{
name|u16
name|status
init|=
operator|(
name|u16
operator|)
name|staterr
decl_stmt|;
name|u8
name|errors
init|=
call|(
name|u8
call|)
argument_list|(
name|staterr
operator|>>
literal|24
argument_list|)
decl_stmt|;
name|int
name|sctp
decl_stmt|;
comment|/* Ignore Checksum bit is set */
if|if
condition|(
name|status
operator|&
name|E1000_RXD_STAT_IXSM
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ptype
operator|&
name|E1000_RXDADV_PKTTYPE_ETQF
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ptype
operator|&
name|E1000_RXDADV_PKTTYPE_SCTP
operator|)
operator|!=
literal|0
condition|)
name|sctp
operator|=
literal|1
expr_stmt|;
else|else
name|sctp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_RXD_STAT_IPCS
condition|)
block|{
comment|/* Did it pass? */
if|if
condition|(
operator|!
operator|(
name|errors
operator|&
name|E1000_RXD_ERR_IPE
operator|)
condition|)
block|{
comment|/* IP Checksum Good */
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
else|else
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
operator|(
name|E1000_RXD_STAT_TCPCS
operator||
name|E1000_RXD_STAT_UDPCS
operator|)
condition|)
block|{
name|u64
name|type
init|=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
if|if
condition|(
name|sctp
condition|)
comment|/* reassign */
name|type
operator|=
name|CSUM_SCTP_VALID
expr_stmt|;
endif|#
directive|endif
comment|/* Did it pass? */
if|if
condition|(
operator|!
operator|(
name|errors
operator|&
name|E1000_RXD_ERR_TCPE
operator|)
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|type
expr_stmt|;
if|if
condition|(
name|sctp
operator|==
literal|0
condition|)
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * This routine is run via an vlan  * config EVENT  */
end_comment

begin_function
specifier|static
name|void
name|igb_register_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u32
name|index
decl_stmt|,
name|bit
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|vtag
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bit
operator|=
name|vtag
operator|&
literal|0x1F
expr_stmt|;
name|adapter
operator|->
name|shadow_vfta
index|[
name|index
index|]
operator||=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
operator|++
name|adapter
operator|->
name|num_vlans
expr_stmt|;
comment|/* Change hw filter setting */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|igb_setup_vlan_hw_support
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is run via an vlan  * unconfig EVENT  */
end_comment

begin_function
specifier|static
name|void
name|igb_unregister_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u32
name|index
decl_stmt|,
name|bit
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|vtag
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bit
operator|=
name|vtag
operator|&
literal|0x1F
expr_stmt|;
name|adapter
operator|->
name|shadow_vfta
index|[
name|index
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
operator|--
name|adapter
operator|->
name|num_vlans
expr_stmt|;
comment|/* Change hw filter setting */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|igb_setup_vlan_hw_support
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_setup_vlan_hw_support
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|u32
name|reg
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|vf_ifp
condition|)
block|{
name|e1000_rlpml_set_vf
argument_list|(
name|hw
argument_list|,
name|adapter
operator|->
name|max_frame_size
operator|+
name|VLAN_TAG_SIZE
argument_list|)
expr_stmt|;
return|return;
block|}
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_CTRL_VME
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Enable the Filter Table */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
block|{
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|E1000_RCTL_CFIEN
expr_stmt|;
name|reg
operator||=
name|E1000_RCTL_VFE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Update the frame size */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_RLPML
argument_list|,
name|adapter
operator|->
name|max_frame_size
operator|+
name|VLAN_TAG_SIZE
argument_list|)
expr_stmt|;
comment|/* Don't bother with table if no vlans */
if|if
condition|(
operator|(
name|adapter
operator|->
name|num_vlans
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
operator|)
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* 	** A soft reset zero's out the VFTA, so 	** we need to repopulate it now. 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|IGB_VFTA_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|adapter
operator|->
name|shadow_vfta
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|adapter
operator|->
name|vf_ifp
condition|)
name|e1000_vfta_set_vf
argument_list|(
name|hw
argument_list|,
name|adapter
operator|->
name|shadow_vfta
index|[
name|i
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|e1000_write_vfta
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
name|adapter
operator|->
name|shadow_vfta
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|igb_enable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
comment|/* With RSS set up what to auto clear */
if|if
condition|(
name|adapter
operator|->
name|msix_mem
condition|)
block|{
name|u32
name|mask
init|=
operator|(
name|adapter
operator|->
name|que_mask
operator||
name|adapter
operator|->
name|link_mask
operator|)
decl_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIAC
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIAM
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIMS
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|E1000_IMS_LSC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMS
argument_list|,
name|IMS_ENABLE_MASK
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_FLUSH
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_disable_intr
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|adapter
operator|->
name|msix_mem
condition|)
block|{
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIMC
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EIAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Bit of a misnomer, what this really means is  * to enable OS management of the system... aka  * to disable special hardware management features   */
end_comment

begin_function
specifier|static
name|void
name|igb_init_manageability
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|adapter
operator|->
name|has_manage
condition|)
block|{
name|int
name|manc2h
init|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC2H
argument_list|)
decl_stmt|;
name|int
name|manc
init|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC
argument_list|)
decl_stmt|;
comment|/* disable hardware interception of ARP */
name|manc
operator|&=
operator|~
operator|(
name|E1000_MANC_ARP_EN
operator|)
expr_stmt|;
comment|/* enable receiving management packets to the host */
name|manc
operator||=
name|E1000_MANC_EN_MNG2HOST
expr_stmt|;
name|manc2h
operator||=
literal|1
operator|<<
literal|5
expr_stmt|;
comment|/* Mng Port 623 */
name|manc2h
operator||=
literal|1
operator|<<
literal|6
expr_stmt|;
comment|/* Mng Port 664 */
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC2H
argument_list|,
name|manc2h
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC
argument_list|,
name|manc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Give control back to hardware management  * controller if there is one.  */
end_comment

begin_function
specifier|static
name|void
name|igb_release_manageability
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
if|if
condition|(
name|adapter
operator|->
name|has_manage
condition|)
block|{
name|int
name|manc
init|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC
argument_list|)
decl_stmt|;
comment|/* re-enable hardware interception of ARP */
name|manc
operator||=
name|E1000_MANC_ARP_EN
expr_stmt|;
name|manc
operator|&=
operator|~
name|E1000_MANC_EN_MNG2HOST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_MANC
argument_list|,
name|manc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * igb_get_hw_control sets CTRL_EXT:DRV_LOAD bit.  * For ASF and Pass Through versions of f/w this means that  * the driver is loaded.   *  */
end_comment

begin_function
specifier|static
name|void
name|igb_get_hw_control
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|ctrl_ext
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|vf_ifp
condition|)
return|return;
comment|/* Let firmware know the driver has taken over */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
operator||
name|E1000_CTRL_EXT_DRV_LOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * igb_release_hw_control resets CTRL_EXT:DRV_LOAD bit.  * For ASF and Pass Through versions of f/w this means that the  * driver is no longer loaded.  *  */
end_comment

begin_function
specifier|static
name|void
name|igb_release_hw_control
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u32
name|ctrl_ext
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|vf_ifp
condition|)
return|return;
comment|/* Let firmware taken over control of h/w */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
operator|&
operator|~
name|E1000_CTRL_EXT_DRV_LOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|igb_is_valid_ether_addr
parameter_list|(
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|char
name|zero_addr
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|addr
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|||
operator|(
operator|!
name|bcmp
argument_list|(
name|addr
argument_list|,
name|zero_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable PCI Wake On Lan capability  */
end_comment

begin_function
specifier|static
name|void
name|igb_enable_wakeup
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u16
name|cap
decl_stmt|,
name|status
decl_stmt|;
name|u8
name|id
decl_stmt|;
comment|/* First find the capabilities pointer*/
name|cap
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CAP_PTR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Read the PM Capabilities */
name|id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|PCIY_PMG
condition|)
comment|/* Something wrong */
return|return;
comment|/* OK, we have the power capabilities, so 	   now get the status register */
name|cap
operator|+=
name|PCIR_POWER_STATUS
expr_stmt|;
name|status
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|cap
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|status
operator||=
name|PCIM_PSTAT_PME
operator||
name|PCIM_PSTAT_PMEENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|cap
argument_list|,
name|status
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_led_func
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
name|e1000_setup_led
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|e1000_led_on
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e1000_led_off
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
name|e1000_cleanup_led
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
block|}
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|igb_get_vf_counter
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|e1000_vf_stats
modifier|*
name|stats
decl_stmt|;
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|uint64_t
name|rv
decl_stmt|;
endif|#
directive|endif
name|adapter
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|(
expr|struct
name|e1000_vf_stats
operator|*
operator|)
name|adapter
operator|->
name|stats
expr_stmt|;
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
name|IFCOUNTER_IPACKETS
case|:
return|return
operator|(
name|stats
operator|->
name|gprc
operator|)
return|;
case|case
name|IFCOUNTER_OPACKETS
case|:
return|return
operator|(
name|stats
operator|->
name|gptc
operator|)
return|;
case|case
name|IFCOUNTER_IBYTES
case|:
return|return
operator|(
name|stats
operator|->
name|gorc
operator|)
return|;
case|case
name|IFCOUNTER_OBYTES
case|:
return|return
operator|(
name|stats
operator|->
name|gotc
operator|)
return|;
case|case
name|IFCOUNTER_IMCASTS
case|:
return|return
operator|(
name|stats
operator|->
name|mprc
operator|)
return|;
case|case
name|IFCOUNTER_IERRORS
case|:
return|return
operator|(
name|adapter
operator|->
name|dropped_pkts
operator|)
return|;
case|case
name|IFCOUNTER_OERRORS
case|:
return|return
operator|(
name|adapter
operator|->
name|watchdog_events
operator|)
return|;
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
case|case
name|IFCOUNTER_OQDROPS
case|:
name|rv
operator|=
literal|0
expr_stmt|;
name|txr
operator|=
name|adapter
operator|->
name|tx_rings
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
name|rv
operator|+=
name|txr
operator|->
name|br
operator|->
name|br_drops
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
endif|#
directive|endif
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|igb_get_counter
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|e1000_hw_stats
modifier|*
name|stats
decl_stmt|;
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|uint64_t
name|rv
decl_stmt|;
endif|#
directive|endif
name|adapter
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|vf_ifp
condition|)
return|return
operator|(
name|igb_get_vf_counter
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
name|stats
operator|=
operator|(
expr|struct
name|e1000_hw_stats
operator|*
operator|)
name|adapter
operator|->
name|stats
expr_stmt|;
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
name|IFCOUNTER_IPACKETS
case|:
return|return
operator|(
name|stats
operator|->
name|gprc
operator|)
return|;
case|case
name|IFCOUNTER_OPACKETS
case|:
return|return
operator|(
name|stats
operator|->
name|gptc
operator|)
return|;
case|case
name|IFCOUNTER_IBYTES
case|:
return|return
operator|(
name|stats
operator|->
name|gorc
operator|)
return|;
case|case
name|IFCOUNTER_OBYTES
case|:
return|return
operator|(
name|stats
operator|->
name|gotc
operator|)
return|;
case|case
name|IFCOUNTER_IMCASTS
case|:
return|return
operator|(
name|stats
operator|->
name|mprc
operator|)
return|;
case|case
name|IFCOUNTER_OMCASTS
case|:
return|return
operator|(
name|stats
operator|->
name|mptc
operator|)
return|;
case|case
name|IFCOUNTER_IERRORS
case|:
return|return
operator|(
name|adapter
operator|->
name|dropped_pkts
operator|+
name|stats
operator|->
name|rxerrc
operator|+
name|stats
operator|->
name|crcerrs
operator|+
name|stats
operator|->
name|algnerrc
operator|+
name|stats
operator|->
name|ruc
operator|+
name|stats
operator|->
name|roc
operator|+
name|stats
operator|->
name|cexterr
operator|)
return|;
case|case
name|IFCOUNTER_OERRORS
case|:
return|return
operator|(
name|stats
operator|->
name|ecol
operator|+
name|stats
operator|->
name|latecol
operator|+
name|adapter
operator|->
name|watchdog_events
operator|)
return|;
case|case
name|IFCOUNTER_COLLISIONS
case|:
return|return
operator|(
name|stats
operator|->
name|colc
operator|)
return|;
case|case
name|IFCOUNTER_IQDROPS
case|:
return|return
operator|(
name|stats
operator|->
name|mpc
operator|)
return|;
ifndef|#
directive|ifndef
name|IGB_LEGACY_TX
case|case
name|IFCOUNTER_OQDROPS
case|:
name|rv
operator|=
literal|0
expr_stmt|;
name|txr
operator|=
name|adapter
operator|->
name|tx_rings
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
name|rv
operator|+=
name|txr
operator|->
name|br
operator|->
name|br_drops
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
endif|#
directive|endif
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Update the board statistics counters.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_update_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|e1000_hw_stats
modifier|*
name|stats
decl_stmt|;
comment|/*  	** The virtual function adapter has only a 	** small controlled set of stats, do only  	** those and return. 	*/
if|if
condition|(
name|adapter
operator|->
name|vf_ifp
condition|)
block|{
name|igb_update_vf_stats_counters
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
name|stats
operator|=
operator|(
expr|struct
name|e1000_hw_stats
operator|*
operator|)
name|adapter
operator|->
name|stats
expr_stmt|;
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
operator|||
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_LU
operator|)
condition|)
block|{
name|stats
operator|->
name|symerrs
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SYMERRS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|sec
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SEC
argument_list|)
expr_stmt|;
block|}
name|stats
operator|->
name|crcerrs
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CRCERRS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mpc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|scc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SCC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ecol
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ECOL
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mcc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MCC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|latecol
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LATECOL
argument_list|)
expr_stmt|;
name|stats
operator|->
name|colc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_COLC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|dc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rlec
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RLEC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|xonrxc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_XONRXC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|xontxc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_XONTXC
argument_list|)
expr_stmt|;
comment|/* 	** For watchdog management we need to know if we have been 	** paused during the last interval, so capture that here. 	*/
name|adapter
operator|->
name|pause_frames
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_XOFFRXC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|xoffrxc
operator|+=
name|adapter
operator|->
name|pause_frames
expr_stmt|;
name|stats
operator|->
name|xofftxc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_XOFFTXC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|fcruc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FCRUC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|prc64
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC64
argument_list|)
expr_stmt|;
name|stats
operator|->
name|prc127
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC127
argument_list|)
expr_stmt|;
name|stats
operator|->
name|prc255
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC255
argument_list|)
expr_stmt|;
name|stats
operator|->
name|prc511
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC511
argument_list|)
expr_stmt|;
name|stats
operator|->
name|prc1023
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC1023
argument_list|)
expr_stmt|;
name|stats
operator|->
name|prc1522
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC1522
argument_list|)
expr_stmt|;
name|stats
operator|->
name|gprc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GPRC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|bprc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_BPRC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mprc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPRC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|gptc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GPTC
argument_list|)
expr_stmt|;
comment|/* For the 64-bit byte counters the low dword must be read first. */
comment|/* Both registers clear on the read of the high dword */
name|stats
operator|->
name|gorc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GORCL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GORCH
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|stats
operator|->
name|gotc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GOTCL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GOTCH
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|stats
operator|->
name|rnbc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RNBC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ruc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RUC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rfc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RFC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|roc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ROC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rjc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RJC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mgprc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPRC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mgpdc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPDC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mgptc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tor
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TORL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TORH
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|stats
operator|->
name|tot
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TOTL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TOTH
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|stats
operator|->
name|tpr
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TPR
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tpt
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TPT
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ptc64
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC64
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ptc127
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC127
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ptc255
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC255
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ptc511
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC511
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ptc1023
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC1023
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ptc1522
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC1522
argument_list|)
expr_stmt|;
name|stats
operator|->
name|mptc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|bptc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_BPTC
argument_list|)
expr_stmt|;
comment|/* Interrupt Counts */
name|stats
operator|->
name|iac
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IAC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|icrxptc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXPTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|icrxatc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXATC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ictxptc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXPTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ictxatc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXATC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ictxqec
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXQEC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|ictxqmtc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXQMTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|icrxdmtc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXDMTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|icrxoc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXOC
argument_list|)
expr_stmt|;
comment|/* Host to Card Statistics */
name|stats
operator|->
name|cbtmpc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CBTMPC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|htdpmc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HTDPMC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|cbrdpc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CBRDPC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|cbrmpc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CBRMPC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rpthc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RPTHC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|hgptc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGPTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|htcbdpc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HTCBDPC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|hgorc
operator|+=
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGORCL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGORCH
argument_list|)
operator|<<
literal|32
operator|)
operator|)
expr_stmt|;
name|stats
operator|->
name|hgotc
operator|+=
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGOTCL
argument_list|)
operator|+
operator|(
operator|(
name|u64
operator|)
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGOTCH
argument_list|)
operator|<<
literal|32
operator|)
operator|)
expr_stmt|;
name|stats
operator|->
name|lenerrs
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LENERRS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|scvpc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SCVPC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|hrmpc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HRMPC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|algnerrc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ALGNERRC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|rxerrc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXERRC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tncrs
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TNCRS
argument_list|)
expr_stmt|;
name|stats
operator|->
name|cexterr
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CEXTERR
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tsctc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tsctfc
operator|+=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTFC
argument_list|)
expr_stmt|;
comment|/* Driver specific counters */
name|adapter
operator|->
name|device_control
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|rx_control
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|int_mask
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMS
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|eint_mask
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EIMS
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|packet_buf_alloc_tx
operator|=
operator|(
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
name|adapter
operator|->
name|packet_buf_alloc_rx
operator|=
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PBA
argument_list|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Initialize the VF board statistics counters.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_vf_init_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|e1000_vf_stats
modifier|*
name|stats
decl_stmt|;
name|stats
operator|=
operator|(
expr|struct
name|e1000_vf_stats
operator|*
operator|)
name|adapter
operator|->
name|stats
expr_stmt|;
if|if
condition|(
name|stats
operator|==
name|NULL
condition|)
return|return;
name|stats
operator|->
name|last_gprc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_VFGPRC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|last_gorc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_VFGORC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|last_gptc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_VFGPTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|last_gotc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_VFGOTC
argument_list|)
expr_stmt|;
name|stats
operator|->
name|last_mprc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_VFMPRC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Update the VF board statistics counters.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_update_vf_stats_counters
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|struct
name|e1000_vf_stats
modifier|*
name|stats
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|link_speed
operator|==
literal|0
condition|)
return|return;
name|stats
operator|=
operator|(
expr|struct
name|e1000_vf_stats
operator|*
operator|)
name|adapter
operator|->
name|stats
expr_stmt|;
name|UPDATE_VF_REG
argument_list|(
name|E1000_VFGPRC
argument_list|,
name|stats
operator|->
name|last_gprc
argument_list|,
name|stats
operator|->
name|gprc
argument_list|)
expr_stmt|;
name|UPDATE_VF_REG
argument_list|(
name|E1000_VFGORC
argument_list|,
name|stats
operator|->
name|last_gorc
argument_list|,
name|stats
operator|->
name|gorc
argument_list|)
expr_stmt|;
name|UPDATE_VF_REG
argument_list|(
name|E1000_VFGPTC
argument_list|,
name|stats
operator|->
name|last_gptc
argument_list|,
name|stats
operator|->
name|gptc
argument_list|)
expr_stmt|;
name|UPDATE_VF_REG
argument_list|(
name|E1000_VFGOTC
argument_list|,
name|stats
operator|->
name|last_gotc
argument_list|,
name|stats
operator|->
name|gotc
argument_list|)
expr_stmt|;
name|UPDATE_VF_REG
argument_list|(
name|E1000_VFMPRC
argument_list|,
name|stats
operator|->
name|last_mprc
argument_list|,
name|stats
operator|->
name|mprc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Export a single 32-bit register via a read-only sysctl. */
end_comment

begin_function
specifier|static
name|int
name|igb_sysctl_reg_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|u_int
name|val
decl_stmt|;
name|adapter
operator|=
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|val
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|oidp
operator|->
name|oid_arg2
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **  Tuneable interrupt rate handler */
end_comment

begin_function
specifier|static
name|int
name|igb_sysctl_interrupt_rate_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|igb_queue
modifier|*
name|que
init|=
operator|(
operator|(
expr|struct
name|igb_queue
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|usec
decl_stmt|,
name|rate
decl_stmt|;
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
operator|&
name|que
operator|->
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_EITR
argument_list|(
name|que
operator|->
name|msix
argument_list|)
argument_list|)
expr_stmt|;
name|usec
operator|=
operator|(
operator|(
name|reg
operator|&
literal|0x7FFC
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|usec
operator|>
literal|0
condition|)
name|rate
operator|=
literal|1000000
operator|/
name|usec
expr_stmt|;
else|else
name|rate
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|rate
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add sysctl variables, one per statistic, to the system.  */
end_comment

begin_function
specifier|static
name|void
name|igb_add_hw_stats
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
decl_stmt|;
name|struct
name|e1000_hw_stats
modifier|*
name|stats
init|=
name|adapter
operator|->
name|stats
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|stat_node
decl_stmt|,
modifier|*
name|queue_node
decl_stmt|,
modifier|*
name|int_node
decl_stmt|,
modifier|*
name|host_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|stat_list
decl_stmt|,
modifier|*
name|queue_list
decl_stmt|,
modifier|*
name|int_list
decl_stmt|,
modifier|*
name|host_list
decl_stmt|;
define|#
directive|define
name|QUEUE_NAME_LEN
value|32
name|char
name|namebuf
index|[
name|QUEUE_NAME_LEN
index|]
decl_stmt|;
comment|/* Driver Statistics */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"link_irq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|link_irq
argument_list|,
literal|"Link MSIX IRQ Handled"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|dropped_pkts
argument_list|,
literal|"Driver dropped packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_dma_fail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|no_tx_dma_setup
argument_list|,
literal|"Driver tx dma failure in xmit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_overruns"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|rx_overruns
argument_list|,
literal|"RX overruns"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"watchdog_timeouts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|watchdog_events
argument_list|,
literal|"Watchdog timeouts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"device_control"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|device_control
argument_list|,
literal|"Device Control Register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_control"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|rx_control
argument_list|,
literal|"Receiver Control Register"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"interrupt_mask"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|int_mask
argument_list|,
literal|"Interrupt Mask"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"extended_int_mask"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|eint_mask
argument_list|,
literal|"Extended Interrupt Mask"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_buf_alloc"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|packet_buf_alloc_tx
argument_list|,
literal|"Transmit Buffer Packet Allocation"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_buf_alloc"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|packet_buf_alloc_rx
argument_list|,
literal|"Receive Buffer Packet Allocation"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc_high_water"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|high_water
argument_list|,
literal|0
argument_list|,
literal|"Flow Control High Watermark"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc_low_water"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|low_water
argument_list|,
literal|0
argument_list|,
literal|"Flow Control Low Watermark"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|lro
decl_stmt|;
name|snprintf
argument_list|(
name|namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"queue%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"interrupt_rate"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
argument_list|)
argument_list|,
name|igb_sysctl_interrupt_rate_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Interrupt Rate"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txd_head"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_TDH
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|,
name|igb_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Transmit Descriptor Head"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txd_tail"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_TDT
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|,
name|igb_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Transmit Descriptor Tail"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_desc_avail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|no_desc_avail
argument_list|,
literal|"Queue Descriptors Unavailable"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txr
operator|->
name|total_packets
argument_list|,
literal|"Queue Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxd_head"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_RDH
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|igb_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Receive Descriptor Head"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxd_tail"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|adapter
argument_list|,
name|E1000_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|igb_sysctl_reg_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"Receive Descriptor Tail"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxr
operator|->
name|rx_packets
argument_list|,
literal|"Queue Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxr
operator|->
name|rx_bytes
argument_list|,
literal|"Queue Bytes Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_queued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|lro
operator|->
name|lro_queued
argument_list|,
literal|0
argument_list|,
literal|"LRO Queued"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_flushed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|lro
operator|->
name|lro_flushed
argument_list|,
literal|0
argument_list|,
literal|"LRO Flushed"
argument_list|)
expr_stmt|;
block|}
comment|/* MAC stats get their own sub node */
name|stat_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mac_stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"MAC Statistics"
argument_list|)
expr_stmt|;
name|stat_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|stat_node
argument_list|)
expr_stmt|;
comment|/* 	** VF adapter has a very limited set of stats 	** since its not managing the metal, so to speak. 	*/
if|if
condition|(
name|adapter
operator|->
name|vf_ifp
condition|)
block|{
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gprc
argument_list|,
literal|"Good Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gptc
argument_list|,
literal|"Good Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_octets_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gorc
argument_list|,
literal|"Good Octets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_octets_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gotc
argument_list|,
literal|"Good Octets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mcast_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mprc
argument_list|,
literal|"Multicast Packets Received"
argument_list|)
expr_stmt|;
return|return;
block|}
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"excess_coll"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ecol
argument_list|,
literal|"Excessive collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"single_coll"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|scc
argument_list|,
literal|"Single collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"multiple_coll"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mcc
argument_list|,
literal|"Multiple collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"late_coll"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|latecol
argument_list|,
literal|"Late collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"collision_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|colc
argument_list|,
literal|"Collision Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"symbol_errors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|symerrs
argument_list|,
literal|"Symbol Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sequence_errors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|sec
argument_list|,
literal|"Sequence Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"defer_count"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|dc
argument_list|,
literal|"Defer Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"missed_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mpc
argument_list|,
literal|"Missed Packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_length_errors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rlec
argument_list|,
literal|"Receive Length Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_no_buff"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rnbc
argument_list|,
literal|"Receive No Buffers"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_undersize"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ruc
argument_list|,
literal|"Receive Undersize"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_fragmented"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rfc
argument_list|,
literal|"Fragmented Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_oversize"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|roc
argument_list|,
literal|"Oversized Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_jabber"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rjc
argument_list|,
literal|"Recevied Jabber"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"recv_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rxerrc
argument_list|,
literal|"Receive Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"crc_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|crcerrs
argument_list|,
literal|"CRC errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"alignment_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|algnerrc
argument_list|,
literal|"Alignment Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_no_crs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tncrs
argument_list|,
literal|"Transmit with No CRS"
argument_list|)
expr_stmt|;
comment|/* On 82575 these are collision counts */
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"coll_ext_errs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|cexterr
argument_list|,
literal|"Collision/Carrier extension errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xon_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|xonrxc
argument_list|,
literal|"XON Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xon_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|xontxc
argument_list|,
literal|"XON Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xoff_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|xoffrxc
argument_list|,
literal|"XOFF Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xoff_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|xofftxc
argument_list|,
literal|"XOFF Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"unsupported_fc_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|fcruc
argument_list|,
literal|"Unsupported Flow Control Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mgmt_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mgprc
argument_list|,
literal|"Management Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mgmt_pkts_drop"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mgpdc
argument_list|,
literal|"Management Packets Dropped"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mgmt_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mgptc
argument_list|,
literal|"Management Packets Transmitted"
argument_list|)
expr_stmt|;
comment|/* Packet Reception Stats */
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tpr
argument_list|,
literal|"Total Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gprc
argument_list|,
literal|"Good Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bcast_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|bprc
argument_list|,
literal|"Broadcast Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mcast_pkts_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mprc
argument_list|,
literal|"Multicast Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_64"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc64
argument_list|,
literal|"64 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_65_127"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc127
argument_list|,
literal|"65-127 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_128_255"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc255
argument_list|,
literal|"128-255 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_256_511"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc511
argument_list|,
literal|"256-511 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_512_1023"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc1023
argument_list|,
literal|"512-1023 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frames_1024_1522"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|prc1522
argument_list|,
literal|"1023-1522 byte frames received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_octets_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gorc
argument_list|,
literal|"Good Octets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_octets_recvd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tor
argument_list|,
literal|"Total Octets Received"
argument_list|)
expr_stmt|;
comment|/* Packet Transmission Stats */
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_octets_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gotc
argument_list|,
literal|"Good Octets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_octets_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tot
argument_list|,
literal|"Total Octets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"total_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tpt
argument_list|,
literal|"Total Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"good_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|gptc
argument_list|,
literal|"Good Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bcast_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|bptc
argument_list|,
literal|"Broadcast Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mcast_pkts_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mptc
argument_list|,
literal|"Multicast Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_64"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc64
argument_list|,
literal|"64 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_65_127"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc127
argument_list|,
literal|"65-127 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_128_255"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc255
argument_list|,
literal|"128-255 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_256_511"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc511
argument_list|,
literal|"256-511 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_512_1023"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc1023
argument_list|,
literal|"512-1023 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frames_1024_1522"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ptc1522
argument_list|,
literal|"1024-1522 byte frames transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_txd"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tsctc
argument_list|,
literal|"TSO Contexts Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_ctx_fail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tsctfc
argument_list|,
literal|"TSO Contexts Failed"
argument_list|)
expr_stmt|;
comment|/* Interrupt Stats */
name|int_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"interrupts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Interrupt Statistics"
argument_list|)
expr_stmt|;
name|int_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|int_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"asserts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|iac
argument_list|,
literal|"Interrupt Assertion Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_pkt_timer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|icrxptc
argument_list|,
literal|"Interrupt Cause Rx Pkt Timer Expire Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_abs_timer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|icrxatc
argument_list|,
literal|"Interrupt Cause Rx Abs Timer Expire Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_pkt_timer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ictxptc
argument_list|,
literal|"Interrupt Cause Tx Pkt Timer Expire Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_abs_timer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ictxatc
argument_list|,
literal|"Interrupt Cause Tx Abs Timer Expire Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_queue_empty"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ictxqec
argument_list|,
literal|"Interrupt Cause Tx Queue Empty Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_queue_min_thresh"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|ictxqmtc
argument_list|,
literal|"Interrupt Cause Tx Queue Min Thresh Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_desc_min_thresh"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|icrxdmtc
argument_list|,
literal|"Interrupt Cause Rx Desc Min Thresh Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|int_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_overrun"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|icrxoc
argument_list|,
literal|"Interrupt Cause Receiver Overrun Count"
argument_list|)
expr_stmt|;
comment|/* Host to Card Stats */
name|host_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"host"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Host to Card Statistics"
argument_list|)
expr_stmt|;
name|host_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|host_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|host_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"breaker_tx_pkt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|cbtmpc
argument_list|,
literal|"Circuit Breaker Tx Packet Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|host_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"host_tx_pkt_discard"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|htdpmc
argument_list|,
literal|"Host Transmit Discarded Packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|host_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_pkt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rpthc
argument_list|,
literal|"Rx Packets To Host"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|host_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"breaker_rx_pkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|cbrmpc
argument_list|,
literal|"Circuit Breaker Rx Packet Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|host_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"breaker_rx_pkt_drop"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|cbrdpc
argument_list|,
literal|"Circuit Breaker Rx Dropped Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|host_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_good_pkt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|hgptc
argument_list|,
literal|"Host Good Packets Tx Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|host_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"breaker_tx_pkt_drop"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|htcbdpc
argument_list|,
literal|"Host Tx Circuit Breaker Dropped Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|host_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_good_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|hgorc
argument_list|,
literal|"Host Good Octets Received Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|host_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_good_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|hgotc
argument_list|,
literal|"Host Good Octets Transmit Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|host_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"length_errors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|lenerrs
argument_list|,
literal|"Length Errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|host_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"serdes_violation_pkt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|scvpc
argument_list|,
literal|"SerDes/SGMII Code Violation Pkt Count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|host_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"header_redir_missed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|hrmpc
argument_list|,
literal|"Header Redirection Missed Packet Count"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  This routine provides a way to dump out the adapter eeprom,  *  often a useful debug/service tool. This only dumps the first  *  32 words, stuff that matters is in that extent.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_sysctl_nvm_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * This value will cause a hex dump of the 	 * first 32 16-bit words of the EEPROM to 	 * the screen. 	 */
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|adapter
operator|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
expr_stmt|;
name|igb_print_nvm_info
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_print_nvm_info
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|u16
name|eeprom_data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|row
init|=
literal|0
decl_stmt|;
comment|/* Its a bit crude, but it gets the job done */
name|printf
argument_list|(
literal|"\nInterface EEPROM Dump:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Offset\n0x0000  "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
literal|8
condition|)
block|{
comment|/* Make the offset block */
name|j
operator|=
literal|0
expr_stmt|;
operator|++
name|row
expr_stmt|;
name|printf
argument_list|(
literal|"\n0x00%x0  "
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
name|e1000_read_nvm
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|eeprom_data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%04x "
argument_list|,
name|eeprom_data
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_set_sysctl_value
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|description
parameter_list|,
name|int
modifier|*
name|limit
parameter_list|,
name|int
name|value
parameter_list|)
block|{
operator|*
name|limit
operator|=
name|value
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|limit
argument_list|,
name|value
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Set flow control using sysctl: ** Flow control values: ** 	0 - off **	1 - rx pause **	2 - tx pause **	3 - full */
end_comment

begin_function
specifier|static
name|int
name|igb_set_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
specifier|static
name|int
name|input
init|=
literal|3
decl_stmt|;
comment|/* default is full */
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|input
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|input
condition|)
block|{
case|case
name|e1000_fc_rx_pause
case|:
case|case
name|e1000_fc_tx_pause
case|:
case|case
name|e1000_fc_full
case|:
case|case
name|e1000_fc_none
case|:
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|requested_mode
operator|=
name|input
expr_stmt|;
name|adapter
operator|->
name|fc
operator|=
name|input
expr_stmt|;
break|break;
default|default:
comment|/* Do nothing */
return|return
operator|(
name|error
operator|)
return|;
block|}
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|current_mode
operator|=
name|adapter
operator|->
name|hw
operator|.
name|fc
operator|.
name|requested_mode
expr_stmt|;
name|e1000_force_mac_fc
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|)
expr_stmt|;
comment|/* XXX TODO: update DROP_EN on each RX queue if appropriate */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Manage DMA Coalesce: ** Control values: ** 	0/1 - off/on **	Legal timer values are: **	250,500,1000-10000 in thousands */
end_comment

begin_function
specifier|static
name|int
name|igb_sysctl_dmac
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|adapter
operator|->
name|dmac
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|adapter
operator|->
name|dmac
condition|)
block|{
case|case
literal|0
case|:
comment|/* Disabling */
break|break;
case|case
literal|1
case|:
comment|/* Just enable and use default */
name|adapter
operator|->
name|dmac
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
literal|250
case|:
case|case
literal|500
case|:
case|case
literal|1000
case|:
case|case
literal|2000
case|:
case|case
literal|3000
case|:
case|case
literal|4000
case|:
case|case
literal|5000
case|:
case|case
literal|6000
case|:
case|case
literal|7000
case|:
case|case
literal|8000
case|:
case|case
literal|9000
case|:
case|case
literal|10000
case|:
comment|/* Legal values - allow */
break|break;
default|default:
comment|/* Do nothing, illegal value */
name|adapter
operator|->
name|dmac
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Reinit the interface */
name|igb_init
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Manage Energy Efficient Ethernet: ** Control values: **     0/1 - enabled/disabled */
end_comment

begin_function
specifier|static
name|int
name|igb_sysctl_eee
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
operator|(
expr|struct
name|adapter
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|value
decl_stmt|;
name|value
operator|=
name|adapter
operator|->
name|hw
operator|.
name|dev_spec
operator|.
name|_82575
operator|.
name|eee_disable
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|IGB_CORE_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|hw
operator|.
name|dev_spec
operator|.
name|_82575
operator|.
name|eee_disable
operator|=
operator|(
name|value
operator|!=
literal|0
operator|)
expr_stmt|;
name|igb_init_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|IGB_CORE_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

