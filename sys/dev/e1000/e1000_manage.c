begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************   SPDX-License-Identifier: BSD-3-Clause    Copyright (c) 2001-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"e1000_api.h"
end_include

begin_comment
comment|/**  *  e1000_calculate_checksum - Calculate checksum for buffer  *  @buffer: pointer to EEPROM  *  @length: size of EEPROM to calculate a checksum for  *  *  Calculates the checksum for some buffer on a specified length.  The  *  checksum calculated is returned.  **/
end_comment

begin_function
name|u8
name|e1000_calculate_checksum
parameter_list|(
name|u8
modifier|*
name|buffer
parameter_list|,
name|u32
name|length
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u8
name|sum
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_calculate_checksum"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|buffer
index|[
name|i
index|]
expr_stmt|;
return|return
call|(
name|u8
call|)
argument_list|(
literal|0
operator|-
name|sum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_mng_enable_host_if_generic - Checks host interface is enabled  *  @hw: pointer to the HW structure  *  *  Returns E1000_success upon success, else E1000_ERR_HOST_INTERFACE_COMMAND  *  *  This function checks whether the HOST IF is enabled for command operation  *  and also checks whether the previous command is completed.  It busy waits  *  in case of previous command is not completed.  **/
end_comment

begin_function
name|s32
name|e1000_mng_enable_host_if_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|hicr
decl_stmt|;
name|u8
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_mng_enable_host_if_generic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|mac
operator|.
name|arc_subsystem_valid
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"ARC subsystem not valid.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
comment|/* Check that the host interface is enabled. */
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hicr
operator|&
name|E1000_HICR_EN
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"E1000_HOST_EN bit disabled.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
comment|/* check the previous command is completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_MNG_DHCP_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hicr
operator|&
name|E1000_HICR_C
operator|)
condition|)
break|break;
name|msec_delay_irq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|E1000_MNG_DHCP_COMMAND_TIMEOUT
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Previous command timeout failed .\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_mng_mode_generic - Generic check management mode  *  @hw: pointer to the HW structure  *  *  Reads the firmware semaphore register and returns TRUE (>0) if  *  manageability is enabled, else FALSE (0).  **/
end_comment

begin_function
name|bool
name|e1000_check_mng_mode_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|fwsm
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_mng_mode_generic"
argument_list|)
expr_stmt|;
return|return
operator|(
name|fwsm
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
operator|==
operator|(
name|E1000_MNG_IAMT_MODE
operator|<<
name|E1000_FWSM_MODE_SHIFT
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_enable_tx_pkt_filtering_generic - Enable packet filtering on Tx  *  @hw: pointer to the HW structure  *  *  Enables packet filtering on transmit packets if manageability is enabled  *  and host interface is enabled.  **/
end_comment

begin_function
name|bool
name|e1000_enable_tx_pkt_filtering_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_host_mng_dhcp_cookie
modifier|*
name|hdr
init|=
operator|&
name|hw
operator|->
name|mng_cookie
decl_stmt|;
name|u32
modifier|*
name|buffer
init|=
operator|(
name|u32
operator|*
operator|)
operator|&
name|hw
operator|->
name|mng_cookie
decl_stmt|;
name|u32
name|offset
decl_stmt|;
name|s32
name|ret_val
decl_stmt|,
name|hdr_csum
decl_stmt|,
name|csum
decl_stmt|;
name|u8
name|i
decl_stmt|,
name|len
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_enable_tx_pkt_filtering_generic"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|tx_pkt_filtering
operator|=
name|TRUE
expr_stmt|;
comment|/* No manageability, no filtering */
if|if
condition|(
operator|!
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_mng_mode
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|tx_pkt_filtering
operator|=
name|FALSE
expr_stmt|;
return|return
name|hw
operator|->
name|mac
operator|.
name|tx_pkt_filtering
return|;
block|}
comment|/* If we can't read from the host interface for whatever 	 * reason, disable filtering. 	 */
name|ret_val
operator|=
name|e1000_mng_enable_host_if_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|tx_pkt_filtering
operator|=
name|FALSE
expr_stmt|;
return|return
name|hw
operator|->
name|mac
operator|.
name|tx_pkt_filtering
return|;
block|}
comment|/* Read in the header.  Length and offset are in dwords. */
name|len
operator|=
name|E1000_MNG_DHCP_COOKIE_LENGTH
operator|>>
literal|2
expr_stmt|;
name|offset
operator|=
name|E1000_MNG_DHCP_COOKIE_OFFSET
operator|>>
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|buffer
operator|+
name|i
operator|)
operator|=
name|E1000_READ_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|offset
operator|+
name|i
argument_list|)
expr_stmt|;
name|hdr_csum
operator|=
name|hdr
operator|->
name|checksum
expr_stmt|;
name|hdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
name|csum
operator|=
name|e1000_calculate_checksum
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|hdr
argument_list|,
name|E1000_MNG_DHCP_COOKIE_LENGTH
argument_list|)
expr_stmt|;
comment|/* If either the checksums or signature don't match, then 	 * the cookie area isn't considered valid, in which case we 	 * take the safe route of assuming Tx filtering is enabled. 	 */
if|if
condition|(
operator|(
name|hdr_csum
operator|!=
name|csum
operator|)
operator|||
operator|(
name|hdr
operator|->
name|signature
operator|!=
name|E1000_IAMT_SIGNATURE
operator|)
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|tx_pkt_filtering
operator|=
name|TRUE
expr_stmt|;
return|return
name|hw
operator|->
name|mac
operator|.
name|tx_pkt_filtering
return|;
block|}
comment|/* Cookie area is valid, make the final check for filtering. */
if|if
condition|(
operator|!
operator|(
name|hdr
operator|->
name|status
operator|&
name|E1000_MNG_DHCP_COOKIE_STATUS_PARSING
operator|)
condition|)
name|hw
operator|->
name|mac
operator|.
name|tx_pkt_filtering
operator|=
name|FALSE
expr_stmt|;
return|return
name|hw
operator|->
name|mac
operator|.
name|tx_pkt_filtering
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_mng_write_cmd_header_generic - Writes manageability command header  *  @hw: pointer to the HW structure  *  @hdr: pointer to the host interface command header  *  *  Writes the command header after does the checksum calculation.  **/
end_comment

begin_function
name|s32
name|e1000_mng_write_cmd_header_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|e1000_host_mng_command_header
modifier|*
name|hdr
parameter_list|)
block|{
name|u16
name|i
decl_stmt|,
name|length
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|e1000_host_mng_command_header
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_mng_write_cmd_header_generic"
argument_list|)
expr_stmt|;
comment|/* Write the whole command header structure with new checksum. */
name|hdr
operator|->
name|checksum
operator|=
name|e1000_calculate_checksum
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|hdr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|length
operator|>>=
literal|2
expr_stmt|;
comment|/* Write the relevant command block into the ram area. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|E1000_WRITE_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|i
argument_list|,
operator|*
operator|(
operator|(
name|u32
operator|*
operator|)
name|hdr
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_mng_host_if_write_generic - Write to the manageability host interface  *  @hw: pointer to the HW structure  *  @buffer: pointer to the host interface buffer  *  @length: size of the buffer  *  @offset: location in the buffer to write to  *  @sum: sum of the data (not checksum)  *  *  This function writes the buffer content at the offset given on the host if.  *  It also does alignment considerations to do the writes in most efficient  *  way.  Also fills up the sum of the buffer in *buffer parameter.  **/
end_comment

begin_function
name|s32
name|e1000_mng_host_if_write_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|buffer
parameter_list|,
name|u16
name|length
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u8
modifier|*
name|sum
parameter_list|)
block|{
name|u8
modifier|*
name|tmp
decl_stmt|;
name|u8
modifier|*
name|bufptr
init|=
name|buffer
decl_stmt|;
name|u32
name|data
init|=
literal|0
decl_stmt|;
name|u16
name|remaining
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|prev_bytes
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_mng_host_if_write_generic"
argument_list|)
expr_stmt|;
comment|/* sum = only sum of the data and it is not checksum */
if|if
condition|(
name|length
operator|==
literal|0
operator|||
name|offset
operator|+
name|length
operator|>
name|E1000_HI_MAX_MNG_DATA_LENGTH
condition|)
return|return
operator|-
name|E1000_ERR_PARAM
return|;
name|tmp
operator|=
operator|(
name|u8
operator|*
operator|)
operator|&
name|data
expr_stmt|;
name|prev_bytes
operator|=
name|offset
operator|&
literal|0x3
expr_stmt|;
name|offset
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|prev_bytes
condition|)
block|{
name|data
operator|=
name|E1000_READ_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|prev_bytes
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
operator|=
operator|*
name|bufptr
operator|++
expr_stmt|;
operator|*
name|sum
operator|+=
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|length
operator|-=
name|j
operator|-
name|prev_bytes
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
name|remaining
operator|=
name|length
operator|&
literal|0x3
expr_stmt|;
name|length
operator|-=
name|remaining
expr_stmt|;
comment|/* Calculate length in DWORDs */
name|length
operator|>>=
literal|2
expr_stmt|;
comment|/* The device driver writes the relevant command block into the 	 * ram area. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
operator|=
operator|*
name|bufptr
operator|++
expr_stmt|;
operator|*
name|sum
operator|+=
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|offset
operator|+
name|i
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remaining
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
name|remaining
condition|)
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
operator|=
operator|*
name|bufptr
operator|++
expr_stmt|;
else|else
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
name|sum
operator|+=
operator|*
operator|(
name|tmp
operator|+
name|j
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|offset
operator|+
name|i
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_mng_write_dhcp_info_generic - Writes DHCP info to host interface  *  @hw: pointer to the HW structure  *  @buffer: pointer to the host interface  *  @length: size of the buffer  *  *  Writes the DHCP information to the host interface.  **/
end_comment

begin_function
name|s32
name|e1000_mng_write_dhcp_info_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|buffer
parameter_list|,
name|u16
name|length
parameter_list|)
block|{
name|struct
name|e1000_host_mng_command_header
name|hdr
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u32
name|hicr
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_mng_write_dhcp_info_generic"
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|command_id
operator|=
name|E1000_MNG_DHCP_TX_PAYLOAD_CMD
expr_stmt|;
name|hdr
operator|.
name|command_length
operator|=
name|length
expr_stmt|;
name|hdr
operator|.
name|reserved1
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|reserved2
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
comment|/* Enable the host interface */
name|ret_val
operator|=
name|e1000_mng_enable_host_if_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Populate the host interface with the contents of "buffer". */
name|ret_val
operator|=
name|e1000_mng_host_if_write_generic
argument_list|(
name|hw
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
operator|&
operator|(
name|hdr
operator|.
name|checksum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Write the manageability command header */
name|ret_val
operator|=
name|e1000_mng_write_cmd_header_generic
argument_list|(
name|hw
argument_list|,
operator|&
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Tell the ARC a new command is pending. */
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|,
name|hicr
operator||
name|E1000_HICR_C
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_enable_mng_pass_thru - Check if management passthrough is needed  *  @hw: pointer to the HW structure  *  *  Verifies the hardware needs to leave interface enabled so that frames can  *  be directed to and from the management interface.  **/
end_comment

begin_function
name|bool
name|e1000_enable_mng_pass_thru
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|manc
decl_stmt|;
name|u32
name|fwsm
decl_stmt|,
name|factps
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_enable_mng_pass_thru"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hw
operator|->
name|mac
operator|.
name|asf_firmware_present
condition|)
return|return
name|FALSE
return|;
name|manc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MANC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|manc
operator|&
name|E1000_MANC_RCV_TCO_EN
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|has_fwsm
condition|)
block|{
name|fwsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
expr_stmt|;
name|factps
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FACTPS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|factps
operator|&
name|E1000_FACTPS_MNGCG
operator|)
operator|&&
operator|(
operator|(
name|fwsm
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
operator|==
operator|(
name|e1000_mng_mode_pt
operator|<<
name|E1000_FWSM_MODE_SHIFT
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82574
operator|)
operator|||
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82583
operator|)
condition|)
block|{
name|u16
name|data
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|factps
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FACTPS
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_read_nvm
argument_list|(
name|hw
argument_list|,
name|NVM_INIT_CONTROL2_REG
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
operator|(
name|factps
operator|&
name|E1000_FACTPS_MNGCG
operator|)
operator|&&
operator|(
operator|(
name|data
operator|&
name|E1000_NVM_INIT_CTRL2_MNGM
operator|)
operator|==
operator|(
name|e1000_mng_mode_pt
operator|<<
literal|13
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|manc
operator|&
name|E1000_MANC_SMBUS_EN
operator|)
operator|&&
operator|!
operator|(
name|manc
operator|&
name|E1000_MANC_ASF_EN
operator|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_host_interface_command - Writes buffer to host interface  *  @hw: pointer to the HW structure  *  @buffer: contains a command to write  *  @length: the byte length of the buffer, must be multiple of 4 bytes  *  *  Writes a buffer to the Host Interface.  Upon success, returns E1000_SUCCESS  *  else returns E1000_ERR_HOST_INTERFACE_COMMAND.  **/
end_comment

begin_function
name|s32
name|e1000_host_interface_command
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|buffer
parameter_list|,
name|u32
name|length
parameter_list|)
block|{
name|u32
name|hicr
decl_stmt|,
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_host_interface_command"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|mac
operator|.
name|arc_subsystem_valid
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Hardware doesn't support host interface command.\n"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
if|if
condition|(
operator|!
name|hw
operator|->
name|mac
operator|.
name|asf_firmware_present
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Firmware is not present.\n"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
if|if
condition|(
name|length
operator|==
literal|0
operator|||
name|length
operator|&
literal|0x3
operator|||
name|length
operator|>
name|E1000_HI_MAX_BLOCK_BYTE_LENGTH
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Buffer length failure.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
comment|/* Check that the host interface is enabled. */
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hicr
operator|&
name|E1000_HICR_EN
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"E1000_HOST_EN bit disabled.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
comment|/* Calculate length in DWORDs */
name|length
operator|>>=
literal|2
expr_stmt|;
comment|/* The device driver writes the relevant command block 	 * into the ram area. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|i
argument_list|,
operator|*
operator|(
operator|(
name|u32
operator|*
operator|)
name|buffer
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* Setting this bit tells the ARC that a new command is pending. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|,
name|hicr
operator||
name|E1000_HICR_C
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_HI_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hicr
operator|&
name|E1000_HICR_C
operator|)
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Check command successful completion. */
if|if
condition|(
name|i
operator|==
name|E1000_HI_COMMAND_TIMEOUT
operator|||
operator|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|)
operator|&
name|E1000_HICR_SV
operator|)
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Command has failed with no status valid.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
operator|*
operator|(
operator|(
name|u32
operator|*
operator|)
name|buffer
operator|+
name|i
operator|)
operator|=
name|E1000_READ_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_load_firmware - Writes proxy FW code buffer to host interface  *                        and execute.  *  @hw: pointer to the HW structure  *  @buffer: contains a firmware to write  *  @length: the byte length of the buffer, must be multiple of 4 bytes  *  *  Upon success returns E1000_SUCCESS, returns E1000_ERR_CONFIG if not enabled  *  in HW else returns E1000_ERR_HOST_INTERFACE_COMMAND.  **/
end_comment

begin_function
name|s32
name|e1000_load_firmware
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|buffer
parameter_list|,
name|u32
name|length
parameter_list|)
block|{
name|u32
name|hicr
decl_stmt|,
name|hibba
decl_stmt|,
name|fwsm
decl_stmt|,
name|icr
decl_stmt|,
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_load_firmware"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_i210
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Hardware doesn't support loading FW by the driver\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
comment|/* Check that the host interface is enabled. */
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hicr
operator|&
name|E1000_HICR_EN
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"E1000_HOST_EN bit disabled.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|hicr
operator|&
name|E1000_HICR_MEMORY_BASE_EN
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"E1000_HICR_MEMORY_BASE_EN bit disabled.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_CONFIG
return|;
block|}
if|if
condition|(
name|length
operator|==
literal|0
operator|||
name|length
operator|&
literal|0x3
operator|||
name|length
operator|>
name|E1000_HI_FW_MAX_LENGTH
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Buffer length failure.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_INVALID_ARGUMENT
return|;
block|}
comment|/* Clear notification from ROM-FW by reading ICR register */
name|icr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICR_V2
argument_list|)
expr_stmt|;
comment|/* Reset ROM-FW */
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|)
expr_stmt|;
name|hicr
operator||=
name|E1000_HICR_FW_RESET_ENABLE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|,
name|hicr
argument_list|)
expr_stmt|;
name|hicr
operator||=
name|E1000_HICR_FW_RESET
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|,
name|hicr
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Wait till MAC notifies about its readiness after ROM-FW reset */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|E1000_HI_COMMAND_TIMEOUT
operator|*
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|icr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICR_V2
argument_list|)
expr_stmt|;
if|if
condition|(
name|icr
operator|&
name|E1000_ICR_MNG
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Check for timeout */
if|if
condition|(
name|i
operator|==
name|E1000_HI_COMMAND_TIMEOUT
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"FW reset failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
comment|/* Wait till MAC is ready to accept new FW code */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_HI_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|fwsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fwsm
operator|&
name|E1000_FWSM_FW_VALID
operator|)
operator|&&
operator|(
operator|(
name|fwsm
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
operator|>>
name|E1000_FWSM_MODE_SHIFT
operator|==
name|E1000_FWSM_HI_EN_ONLY_MODE
operator|)
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Check for timeout */
if|if
condition|(
name|i
operator|==
name|E1000_HI_COMMAND_TIMEOUT
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"FW reset failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
comment|/* Calculate length in DWORDs */
name|length
operator|>>=
literal|2
expr_stmt|;
comment|/* The device driver writes the relevant FW code block 	 * into the ram area in DWORDs via 1kB ram addressing window. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|%
name|E1000_HI_FW_BLOCK_DWORD_LENGTH
operator|)
condition|)
block|{
comment|/* Point to correct 1kB ram window */
name|hibba
operator|=
name|E1000_HI_FW_BASE_ADDRESS
operator|+
operator|(
operator|(
name|E1000_HI_FW_BLOCK_DWORD_LENGTH
operator|<<
literal|2
operator|)
operator|*
operator|(
name|i
operator|/
name|E1000_HI_FW_BLOCK_DWORD_LENGTH
operator|)
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HIBBA
argument_list|,
name|hibba
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_REG_ARRAY_DWORD
argument_list|(
name|hw
argument_list|,
name|E1000_HOST_IF
argument_list|,
name|i
operator|%
name|E1000_HI_FW_BLOCK_DWORD_LENGTH
argument_list|,
operator|*
operator|(
operator|(
name|u32
operator|*
operator|)
name|buffer
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Setting this bit tells the ARC that a new FW is ready to execute. */
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|,
name|hicr
operator||
name|E1000_HICR_C
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_HI_COMMAND_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|hicr
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HICR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hicr
operator|&
name|E1000_HICR_C
operator|)
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Check for successful FW start. */
if|if
condition|(
name|i
operator|==
name|E1000_HI_COMMAND_TIMEOUT
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"New FW did not start within timeout period.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_HOST_INTERFACE_COMMAND
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

end_unit

