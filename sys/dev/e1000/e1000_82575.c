begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2014, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_comment
comment|/*  * 82575EB Gigabit Network Connection  * 82575EB Gigabit Backplane Connection  * 82575GB Gigabit Network Connection  * 82576 Gigabit Network Connection  * 82576 Quad Port Gigabit Mezzanine Adapter  * 82580 Gigabit Network Connection  * I350 Gigabit Network Connection  */
end_comment

begin_include
include|#
directive|include
file|"e1000_api.h"
end_include

begin_include
include|#
directive|include
file|"e1000_i210.h"
end_include

begin_function_decl
specifier|static
name|s32
name|e1000_init_phy_params_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_init_mac_params_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_acquire_phy_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_release_phy_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_acquire_nvm_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_release_nvm_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_check_for_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_check_for_link_media_swap
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_cfg_done_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_link_up_info_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_phy_hw_reset_sgmii_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_read_phy_reg_sgmii_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_reset_hw_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_reset_hw_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_read_phy_reg_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_write_phy_reg_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_set_d0_lplu_state_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_set_d3_lplu_state_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_set_d0_lplu_state_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_setup_copper_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_setup_serdes_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_media_type_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_set_sfp_media_type_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_valid_led_default_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_write_phy_reg_sgmii_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_clear_hw_cntrs_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_acquire_swfw_sync_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_pcs_speed_and_duplex_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_phy_id_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_release_swfw_sync_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|e1000_sgmii_active_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_reset_init_script_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_read_mac_addr_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_config_collision_dist_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_power_down_phy_copper_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_shutdown_serdes_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_power_up_serdes_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_set_pcie_completion_timeout
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_reset_mdicnfg_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_validate_nvm_checksum_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_update_nvm_checksum_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_update_nvm_checksum_with_offset
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_validate_nvm_checksum_with_offset
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_validate_nvm_checksum_i350
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_update_nvm_checksum_i350
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_write_vfta_i350
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_clear_vfta_i350
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_i2c_start
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_i2c_stop
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_clock_in_i2c_byte
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_clock_out_i2c_byte
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_i2c_ack
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_clock_in_i2c_bit
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_clock_out_i2c_bit
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_raise_i2c_clk
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_lower_i2c_clk
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_set_i2c_data
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|,
name|bool
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|e1000_get_i2c_data
parameter_list|(
name|u32
modifier|*
name|i2cctl
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|u16
name|e1000_82580_rxpbs_table
index|[]
init|=
block|{
literal|36
block|,
literal|72
block|,
literal|144
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|35
block|,
literal|70
block|,
literal|140
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|E1000_82580_RXPBS_TABLE_SIZE
define|\
value|(sizeof(e1000_82580_rxpbs_table) / \ 	 sizeof(e1000_82580_rxpbs_table[0]))
end_define

begin_comment
comment|/**  *  e1000_sgmii_uses_mdio_82575 - Determine if I2C pins are for external MDIO  *  @hw: pointer to the HW structure  *  *  Called to determine if the I2C pins are being used for I2C or as an  *  external MDIO interface since the two options are mutually exclusive.  **/
end_comment

begin_function
specifier|static
name|bool
name|e1000_sgmii_uses_mdio_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
init|=
literal|0
decl_stmt|;
name|bool
name|ext_mdio
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_sgmii_uses_mdio_82575"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82575
case|:
case|case
name|e1000_82576
case|:
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDIC
argument_list|)
expr_stmt|;
name|ext_mdio
operator|=
operator|!
operator|!
operator|(
name|reg
operator|&
name|E1000_MDIC_DEST
operator|)
expr_stmt|;
break|break;
case|case
name|e1000_82580
case|:
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
case|case
name|e1000_i210
case|:
case|case
name|e1000_i211
case|:
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDICNFG
argument_list|)
expr_stmt|;
name|ext_mdio
operator|=
operator|!
operator|!
operator|(
name|reg
operator|&
name|E1000_MDICNFG_EXT_MDIO
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|ext_mdio
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_phy_params_82575 - Init PHY func ptrs.  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_phy_params_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|ctrl_ext
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_phy_params_82575"
argument_list|)
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_i2c_byte
operator|=
name|e1000_read_i2c_byte_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_i2c_byte
operator|=
name|e1000_write_i2c_byte_generic
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|e1000_media_type_copper
condition|)
block|{
name|phy
operator|->
name|type
operator|=
name|e1000_phy_none
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|phy
operator|->
name|ops
operator|.
name|power_up
operator|=
name|e1000_power_up_phy_copper
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|power_down
operator|=
name|e1000_power_down_phy_copper_82575
expr_stmt|;
name|phy
operator|->
name|autoneg_mask
operator|=
name|AUTONEG_ADVERTISE_SPEED_DEFAULT
expr_stmt|;
name|phy
operator|->
name|reset_delay_us
operator|=
literal|100
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|acquire
operator|=
name|e1000_acquire_phy_82575
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_reset_block
operator|=
name|e1000_check_reset_block_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|commit
operator|=
name|e1000_phy_sw_reset_generic
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cfg_done
operator|=
name|e1000_get_cfg_done_82575
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|release
operator|=
name|e1000_release_phy_82575
expr_stmt|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|e1000_phy_hw_reset_sgmii_82575
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_I2C_ENA
expr_stmt|;
block|}
else|else
block|{
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|e1000_phy_hw_reset_generic
expr_stmt|;
name|ctrl_ext
operator|&=
operator|~
name|E1000_CTRL_I2C_ENA
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|e1000_reset_mdicnfg_82580
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
operator|&&
operator|!
name|e1000_sgmii_uses_mdio_82575
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|e1000_read_phy_reg_sgmii_82575
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|e1000_write_phy_reg_sgmii_82575
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82580
case|:
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|e1000_read_phy_reg_82580
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|e1000_write_phy_reg_82580
expr_stmt|;
break|break;
case|case
name|e1000_i210
case|:
case|case
name|e1000_i211
case|:
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|e1000_read_phy_reg_gs40g
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|e1000_write_phy_reg_gs40g
expr_stmt|;
break|break;
default|default:
name|phy
operator|->
name|ops
operator|.
name|read_reg
operator|=
name|e1000_read_phy_reg_igp
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|write_reg
operator|=
name|e1000_write_phy_reg_igp
expr_stmt|;
block|}
block|}
comment|/* Set phy->phy_addr and phy->id. */
name|ret_val
operator|=
name|e1000_get_phy_id_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Verify phy id and set remaining function pointers */
switch|switch
condition|(
name|phy
operator|->
name|id
condition|)
block|{
case|case
name|M88E1543_E_PHY_ID
case|:
case|case
name|M88E1512_E_PHY_ID
case|:
case|case
name|I347AT4_E_PHY_ID
case|:
case|case
name|M88E1112_E_PHY_ID
case|:
case|case
name|M88E1340M_E_PHY_ID
case|:
case|case
name|M88E1111_I_PHY_ID
case|:
name|phy
operator|->
name|type
operator|=
name|e1000_phy_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_polarity
operator|=
name|e1000_check_polarity_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_info
operator|=
name|e1000_get_phy_info_m88
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|id
operator|==
name|I347AT4_E_PHY_ID
operator|||
name|phy
operator|->
name|id
operator|==
name|M88E1112_E_PHY_ID
operator|||
name|phy
operator|->
name|id
operator|==
name|M88E1340M_E_PHY_ID
condition|)
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
operator|=
name|e1000_get_cable_length_m88_gen2
expr_stmt|;
elseif|else
if|if
condition|(
name|phy
operator|->
name|id
operator|==
name|M88E1543_E_PHY_ID
operator|||
name|phy
operator|->
name|id
operator|==
name|M88E1512_E_PHY_ID
condition|)
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
operator|=
name|e1000_get_cable_length_m88_gen2
expr_stmt|;
else|else
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
operator|=
name|e1000_get_cable_length_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_m88
expr_stmt|;
comment|/* Check if this PHY is confgured for media swap. */
if|if
condition|(
name|phy
operator|->
name|id
operator|==
name|M88E1112_E_PHY_ID
condition|)
block|{
name|u16
name|data
decl_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1112_PAGE_ADDR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1112_MAC_CTRL_1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|=
operator|(
name|data
operator|&
name|E1000_M88E1112_MAC_CTRL_1_MODE_MASK
operator|)
operator|>>
name|E1000_M88E1112_MAC_CTRL_1_MODE_SHIFT
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|E1000_M88E1112_AUTO_COPPER_SGMII
operator|||
name|data
operator|==
name|E1000_M88E1112_AUTO_COPPER_BASEX
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_for_link
operator|=
name|e1000_check_for_link_media_swap
expr_stmt|;
block|}
if|if
condition|(
name|phy
operator|->
name|id
operator|==
name|M88E1512_E_PHY_ID
condition|)
block|{
name|ret_val
operator|=
name|e1000_initialize_M88E1512_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|IGP03E1000_E_PHY_ID
case|:
case|case
name|IGP04E1000_E_PHY_ID
case|:
name|phy
operator|->
name|type
operator|=
name|e1000_phy_igp_3
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_polarity
operator|=
name|e1000_check_polarity_igp
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_info
operator|=
name|e1000_get_phy_info_igp
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
operator|=
name|e1000_get_cable_length_igp_2
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_igp
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d0_lplu_state
operator|=
name|e1000_set_d0_lplu_state_82575
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d3_lplu_state
operator|=
name|e1000_set_d3_lplu_state_generic
expr_stmt|;
break|break;
case|case
name|I82580_I_PHY_ID
case|:
case|case
name|I350_I_PHY_ID
case|:
name|phy
operator|->
name|type
operator|=
name|e1000_phy_82580
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_polarity
operator|=
name|e1000_check_polarity_82577
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_82577
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
operator|=
name|e1000_get_cable_length_82577
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_info
operator|=
name|e1000_get_phy_info_82577
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d0_lplu_state
operator|=
name|e1000_set_d0_lplu_state_82580
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d3_lplu_state
operator|=
name|e1000_set_d3_lplu_state_82580
expr_stmt|;
break|break;
case|case
name|I210_I_PHY_ID
case|:
name|phy
operator|->
name|type
operator|=
name|e1000_phy_i210
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_polarity
operator|=
name|e1000_check_polarity_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_info
operator|=
name|e1000_get_phy_info_m88
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_cable_length
operator|=
name|e1000_get_cable_length_m88_gen2
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d0_lplu_state
operator|=
name|e1000_set_d0_lplu_state_82580
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|set_d3_lplu_state
operator|=
name|e1000_set_d3_lplu_state_82580
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|force_speed_duplex
operator|=
name|e1000_phy_force_speed_duplex_m88
expr_stmt|;
break|break;
default|default:
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_nvm_params_82575 - Init NVM func ptrs.  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|s32
name|e1000_init_nvm_params_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|u32
name|eecd
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_nvm_params_82575"
argument_list|)
expr_stmt|;
name|size
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|eecd
operator|&
name|E1000_EECD_SIZE_EX_MASK
operator|)
operator|>>
name|E1000_EECD_SIZE_EX_SHIFT
argument_list|)
expr_stmt|;
comment|/* 	 * Added to a constant, "size" becomes the left-shift value 	 * for setting word_size. 	 */
name|size
operator|+=
name|NVM_WORD_SIZE_BASE_SHIFT
expr_stmt|;
comment|/* Just in case size is out of range, cap it to the largest 	 * EEPROM size supported 	 */
if|if
condition|(
name|size
operator|>
literal|15
condition|)
name|size
operator|=
literal|15
expr_stmt|;
name|nvm
operator|->
name|word_size
operator|=
literal|1
operator|<<
name|size
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_i210
condition|)
block|{
name|nvm
operator|->
name|opcode_bits
operator|=
literal|8
expr_stmt|;
name|nvm
operator|->
name|delay_usec
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|nvm
operator|->
name|override
condition|)
block|{
case|case
name|e1000_nvm_override_spi_large
case|:
name|nvm
operator|->
name|page_size
operator|=
literal|32
expr_stmt|;
name|nvm
operator|->
name|address_bits
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|e1000_nvm_override_spi_small
case|:
name|nvm
operator|->
name|page_size
operator|=
literal|8
expr_stmt|;
name|nvm
operator|->
name|address_bits
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|nvm
operator|->
name|page_size
operator|=
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|?
literal|32
else|:
literal|8
expr_stmt|;
name|nvm
operator|->
name|address_bits
operator|=
name|eecd
operator|&
name|E1000_EECD_ADDR_BITS
condition|?
literal|16
else|:
literal|8
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nvm
operator|->
name|word_size
operator|==
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
name|nvm
operator|->
name|page_size
operator|=
literal|128
expr_stmt|;
name|nvm
operator|->
name|type
operator|=
name|e1000_nvm_eeprom_spi
expr_stmt|;
block|}
else|else
block|{
name|nvm
operator|->
name|type
operator|=
name|e1000_nvm_flash_hw
expr_stmt|;
block|}
comment|/* Function Pointers */
name|nvm
operator|->
name|ops
operator|.
name|acquire
operator|=
name|e1000_acquire_nvm_82575
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|release
operator|=
name|e1000_release_nvm_82575
expr_stmt|;
if|if
condition|(
name|nvm
operator|->
name|word_size
operator|<
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
name|nvm
operator|->
name|ops
operator|.
name|read
operator|=
name|e1000_read_nvm_eerd
expr_stmt|;
else|else
name|nvm
operator|->
name|ops
operator|.
name|read
operator|=
name|e1000_read_nvm_spi
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|write
operator|=
name|e1000_write_nvm_spi
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|validate
operator|=
name|e1000_validate_nvm_checksum_generic
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|update
operator|=
name|e1000_update_nvm_checksum_generic
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|valid_led_default
operator|=
name|e1000_valid_led_default_82575
expr_stmt|;
comment|/* override generic family function pointers for specific descendants */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82580
case|:
name|nvm
operator|->
name|ops
operator|.
name|validate
operator|=
name|e1000_validate_nvm_checksum_82580
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|update
operator|=
name|e1000_update_nvm_checksum_82580
expr_stmt|;
break|break;
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
name|nvm
operator|->
name|ops
operator|.
name|validate
operator|=
name|e1000_validate_nvm_checksum_i350
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|update
operator|=
name|e1000_update_nvm_checksum_i350
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_mac_params_82575 - Init MAC func ptrs.  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_mac_params_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|e1000_dev_spec_82575
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_mac_params_82575"
argument_list|)
expr_stmt|;
comment|/* Derives media type */
name|e1000_get_media_type_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set mta register count */
name|mac
operator|->
name|mta_reg_count
operator|=
literal|128
expr_stmt|;
comment|/* Set uta register count */
name|mac
operator|->
name|uta_reg_count
operator|=
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82575
operator|)
condition|?
literal|0
else|:
literal|128
expr_stmt|;
comment|/* Set rar entry count */
name|mac
operator|->
name|rar_entry_count
operator|=
name|E1000_RAR_ENTRIES_82575
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|type
operator|==
name|e1000_82576
condition|)
name|mac
operator|->
name|rar_entry_count
operator|=
name|E1000_RAR_ENTRIES_82576
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|type
operator|==
name|e1000_82580
condition|)
name|mac
operator|->
name|rar_entry_count
operator|=
name|E1000_RAR_ENTRIES_82580
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|type
operator|==
name|e1000_i350
operator|||
name|mac
operator|->
name|type
operator|==
name|e1000_i354
condition|)
name|mac
operator|->
name|rar_entry_count
operator|=
name|E1000_RAR_ENTRIES_I350
expr_stmt|;
comment|/* Enable EEE default settings for EEE supported devices */
if|if
condition|(
name|mac
operator|->
name|type
operator|>=
name|e1000_i350
condition|)
name|dev_spec
operator|->
name|eee_disable
operator|=
name|FALSE
expr_stmt|;
comment|/* Allow a single clear of the SW semaphore on I210 and newer */
if|if
condition|(
name|mac
operator|->
name|type
operator|>=
name|e1000_i210
condition|)
name|dev_spec
operator|->
name|clear_semaphore_once
operator|=
name|TRUE
expr_stmt|;
comment|/* Set if part includes ASF firmware */
name|mac
operator|->
name|asf_firmware_present
operator|=
name|TRUE
expr_stmt|;
comment|/* FWSM register */
name|mac
operator|->
name|has_fwsm
operator|=
name|TRUE
expr_stmt|;
comment|/* ARC supported; valid only if manageability features are enabled. */
name|mac
operator|->
name|arc_subsystem_valid
operator|=
operator|!
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_FWSM
argument_list|)
operator|&
name|E1000_FWSM_MODE_MASK
operator|)
expr_stmt|;
comment|/* Function pointers */
comment|/* bus type/speed/width */
name|mac
operator|->
name|ops
operator|.
name|get_bus_info
operator|=
name|e1000_get_bus_info_pcie_generic
expr_stmt|;
comment|/* reset */
if|if
condition|(
name|mac
operator|->
name|type
operator|>=
name|e1000_82580
condition|)
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
name|e1000_reset_hw_82580
expr_stmt|;
else|else
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
name|e1000_reset_hw_82575
expr_stmt|;
comment|/* hw initialization */
if|if
condition|(
operator|(
name|mac
operator|->
name|type
operator|==
name|e1000_i210
operator|)
operator|||
operator|(
name|mac
operator|->
name|type
operator|==
name|e1000_i211
operator|)
condition|)
name|mac
operator|->
name|ops
operator|.
name|init_hw
operator|=
name|e1000_init_hw_i210
expr_stmt|;
else|else
name|mac
operator|->
name|ops
operator|.
name|init_hw
operator|=
name|e1000_init_hw_82575
expr_stmt|;
comment|/* link setup */
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|e1000_setup_link_generic
expr_stmt|;
comment|/* physical interface link setup */
name|mac
operator|->
name|ops
operator|.
name|setup_physical_interface
operator|=
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
operator|)
condition|?
name|e1000_setup_copper_link_82575
else|:
name|e1000_setup_serdes_link_82575
expr_stmt|;
comment|/* physical interface shutdown */
name|mac
operator|->
name|ops
operator|.
name|shutdown_serdes
operator|=
name|e1000_shutdown_serdes_link_82575
expr_stmt|;
comment|/* physical interface power up */
name|mac
operator|->
name|ops
operator|.
name|power_up_serdes
operator|=
name|e1000_power_up_serdes_link_82575
expr_stmt|;
comment|/* check for link */
name|mac
operator|->
name|ops
operator|.
name|check_for_link
operator|=
name|e1000_check_for_link_82575
expr_stmt|;
comment|/* read mac address */
name|mac
operator|->
name|ops
operator|.
name|read_mac_addr
operator|=
name|e1000_read_mac_addr_82575
expr_stmt|;
comment|/* configure collision distance */
name|mac
operator|->
name|ops
operator|.
name|config_collision_dist
operator|=
name|e1000_config_collision_dist_82575
expr_stmt|;
comment|/* multicast address update */
name|mac
operator|->
name|ops
operator|.
name|update_mc_addr_list
operator|=
name|e1000_update_mc_addr_list_generic
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i350
operator|||
name|mac
operator|->
name|type
operator|==
name|e1000_i354
condition|)
block|{
comment|/* writing VFTA */
name|mac
operator|->
name|ops
operator|.
name|write_vfta
operator|=
name|e1000_write_vfta_i350
expr_stmt|;
comment|/* clearing VFTA */
name|mac
operator|->
name|ops
operator|.
name|clear_vfta
operator|=
name|e1000_clear_vfta_i350
expr_stmt|;
block|}
else|else
block|{
comment|/* writing VFTA */
name|mac
operator|->
name|ops
operator|.
name|write_vfta
operator|=
name|e1000_write_vfta_generic
expr_stmt|;
comment|/* clearing VFTA */
name|mac
operator|->
name|ops
operator|.
name|clear_vfta
operator|=
name|e1000_clear_vfta_generic
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_82580
condition|)
name|mac
operator|->
name|ops
operator|.
name|validate_mdi_setting
operator|=
name|e1000_validate_mdi_setting_crossover_generic
expr_stmt|;
comment|/* ID LED init */
name|mac
operator|->
name|ops
operator|.
name|id_led_init
operator|=
name|e1000_id_led_init_generic
expr_stmt|;
comment|/* blink LED */
name|mac
operator|->
name|ops
operator|.
name|blink_led
operator|=
name|e1000_blink_led_generic
expr_stmt|;
comment|/* setup LED */
name|mac
operator|->
name|ops
operator|.
name|setup_led
operator|=
name|e1000_setup_led_generic
expr_stmt|;
comment|/* cleanup LED */
name|mac
operator|->
name|ops
operator|.
name|cleanup_led
operator|=
name|e1000_cleanup_led_generic
expr_stmt|;
comment|/* turn on/off LED */
name|mac
operator|->
name|ops
operator|.
name|led_on
operator|=
name|e1000_led_on_generic
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|led_off
operator|=
name|e1000_led_off_generic
expr_stmt|;
comment|/* clear hardware counters */
name|mac
operator|->
name|ops
operator|.
name|clear_hw_cntrs
operator|=
name|e1000_clear_hw_cntrs_82575
expr_stmt|;
comment|/* link info */
name|mac
operator|->
name|ops
operator|.
name|get_link_up_info
operator|=
name|e1000_get_link_up_info_82575
expr_stmt|;
comment|/* acquire SW_FW sync */
name|mac
operator|->
name|ops
operator|.
name|acquire_swfw_sync
operator|=
name|e1000_acquire_swfw_sync_82575
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|release_swfw_sync
operator|=
name|e1000_release_swfw_sync_82575
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|type
operator|>=
name|e1000_i210
condition|)
block|{
name|mac
operator|->
name|ops
operator|.
name|acquire_swfw_sync
operator|=
name|e1000_acquire_swfw_sync_i210
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|release_swfw_sync
operator|=
name|e1000_release_swfw_sync_i210
expr_stmt|;
block|}
comment|/* set lan id for port to determine which phy lock to use */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|set_lan_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_function_pointers_82575 - Init func ptrs.  *  @hw: pointer to the HW structure  *  *  Called to initialize all function pointers and parameters.  **/
end_comment

begin_function
name|void
name|e1000_init_function_pointers_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_function_pointers_82575"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_mac_params_82575
expr_stmt|;
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_nvm_params_82575
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_phy_params_82575
expr_stmt|;
name|hw
operator|->
name|mbx
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_mbx_params_pf
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_phy_82575 - Acquire rights to access PHY  *  @hw: pointer to the HW structure  *  *  Acquire access rights to the correct PHY.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_acquire_phy_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|mask
init|=
name|E1000_SWFW_PHY0_SM
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_phy_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
name|E1000_FUNC_1
condition|)
name|mask
operator|=
name|E1000_SWFW_PHY1_SM
expr_stmt|;
elseif|else
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
name|E1000_FUNC_2
condition|)
name|mask
operator|=
name|E1000_SWFW_PHY2_SM
expr_stmt|;
elseif|else
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
name|E1000_FUNC_3
condition|)
name|mask
operator|=
name|E1000_SWFW_PHY3_SM
expr_stmt|;
return|return
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_phy_82575 - Release rights to access PHY  *  @hw: pointer to the HW structure  *  *  A wrapper to release access rights to the correct PHY.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_release_phy_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u16
name|mask
init|=
name|E1000_SWFW_PHY0_SM
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_phy_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
name|E1000_FUNC_1
condition|)
name|mask
operator|=
name|E1000_SWFW_PHY1_SM
expr_stmt|;
elseif|else
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
name|E1000_FUNC_2
condition|)
name|mask
operator|=
name|E1000_SWFW_PHY2_SM
expr_stmt|;
elseif|else
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
name|E1000_FUNC_3
condition|)
name|mask
operator|=
name|E1000_SWFW_PHY3_SM
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_sgmii_82575 - Read PHY register using sgmii  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Reads the PHY register at offset using the serial gigabit media independent  *  interface and stores the retrieved information in data.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_phy_reg_sgmii_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_PARAM
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_sgmii_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|E1000_MAX_SGMII_PHY_REG_ADDR
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %u is out of range\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg_i2c
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_sgmii_82575 - Write PHY register using sgmii  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write at register offset  *  *  Writes the data to PHY register at the offset using the serial gigabit  *  media independent interface.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_write_phy_reg_sgmii_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_PARAM
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_sgmii_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|E1000_MAX_SGMII_PHY_REG_ADDR
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY Address %d is out of range\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_write_phy_reg_i2c
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_phy_id_82575 - Retrieve PHY addr and id  *  @hw: pointer to the HW structure  *  *  Retrieves the PHY address and ID for both PHY's which do and do not use  *  sgmi interface.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_phy_id_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|phy_id
decl_stmt|;
name|u32
name|ctrl_ext
decl_stmt|;
name|u32
name|mdic
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_phy_id_82575"
argument_list|)
expr_stmt|;
comment|/* some i354 devices need an extra read for phy id */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i354
condition|)
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* 	 * For SGMII PHYs, we try the list of possible addresses until 	 * we find one that works.  For non-SGMII PHYs 	 * (e.g. integrated copper PHYs), an address of 1 should 	 * work.  The result of this function should mean phy->phy_addr 	 * and phy->id are set correctly. 	 */
if|if
condition|(
operator|!
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|phy
operator|->
name|addr
operator|=
literal|1
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|e1000_sgmii_uses_mdio_82575
argument_list|(
name|hw
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82575
case|:
case|case
name|e1000_82576
case|:
name|mdic
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDIC
argument_list|)
expr_stmt|;
name|mdic
operator|&=
name|E1000_MDIC_PHY_MASK
expr_stmt|;
name|phy
operator|->
name|addr
operator|=
name|mdic
operator|>>
name|E1000_MDIC_PHY_SHIFT
expr_stmt|;
break|break;
case|case
name|e1000_82580
case|:
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
case|case
name|e1000_i210
case|:
case|case
name|e1000_i211
case|:
name|mdic
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDICNFG
argument_list|)
expr_stmt|;
name|mdic
operator|&=
name|E1000_MDICNFG_PHY_MASK
expr_stmt|;
name|phy
operator|->
name|addr
operator|=
name|mdic
operator|>>
name|E1000_MDICNFG_PHY_SHIFT
expr_stmt|;
break|break;
default|default:
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
name|ret_val
operator|=
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Power on sgmii phy if it is disabled */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
operator|&
operator|~
name|E1000_CTRL_EXT_SDP3_DATA
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|300
argument_list|)
expr_stmt|;
comment|/* 	 * The address field in the I2CCMD register is 3 bits and 0 is invalid. 	 * Therefore, we need to test 1-7 	 */
for|for
control|(
name|phy
operator|->
name|addr
operator|=
literal|1
init|;
name|phy
operator|->
name|addr
operator|<
literal|8
condition|;
name|phy
operator|->
name|addr
operator|++
control|)
block|{
name|ret_val
operator|=
name|e1000_read_phy_reg_sgmii_82575
argument_list|(
name|hw
argument_list|,
name|PHY_ID1
argument_list|,
operator|&
name|phy_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
block|{
name|DEBUGOUT2
argument_list|(
literal|"Vendor ID 0x%08X read at address %u\n"
argument_list|,
name|phy_id
argument_list|,
name|phy
operator|->
name|addr
argument_list|)
expr_stmt|;
comment|/* 			 * At the time of this writing, The M88 part is 			 * the only supported SGMII PHY product. 			 */
if|if
condition|(
name|phy_id
operator|==
name|M88_VENDOR
condition|)
break|break;
block|}
else|else
block|{
name|DEBUGOUT1
argument_list|(
literal|"PHY address %u was unreadable\n"
argument_list|,
name|phy
operator|->
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* A valid PHY type couldn't be found. */
if|if
condition|(
name|phy
operator|->
name|addr
operator|==
literal|8
condition|)
block|{
name|phy
operator|->
name|addr
operator|=
literal|0
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|e1000_get_phy_id
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* restore previous sfp cage power state */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_phy_hw_reset_sgmii_82575 - Performs a PHY reset  *  @hw: pointer to the HW structure  *  *  Resets the PHY using the serial gigabit media independent interface.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_phy_hw_reset_sgmii_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_phy_hw_reset_sgmii_82575"
argument_list|)
expr_stmt|;
comment|/* 	 * This isn't a TRUE "hard" reset, but is the only reset 	 * available to us at this time. 	 */
name|DEBUGOUT
argument_list|(
literal|"Soft resetting SGMII attached PHY...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * SFP documentation requires the following to configure the SPF module 	 * to work on SGMII.  No further documentation is given. 	 */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
literal|0x1B
argument_list|,
literal|0x8084
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|commit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|phy
operator|->
name|id
operator|==
name|M88E1512_E_PHY_ID
condition|)
name|ret_val
operator|=
name|e1000_initialize_M88E1512_phy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d0_lplu_state_82575 - Set Low Power Linkup D0 state  *  @hw: pointer to the HW structure  *  @active: TRUE to enable LPLU, FALSE to disable  *  *  Sets the LPLU D0 state according to the active flag.  When  *  activating LPLU this function also disables smart speed  *  and vice versa.  LPLU will not be activated unless the  *  device autonegotiation advertisement meets standards of  *  either 10 or 10/100 or 10/100/1000 at all duplexes.  *  This is a function pointer entry point only called by  *  PHY setup routines.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_set_d0_lplu_state_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d0_lplu_state_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
operator|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|active
condition|)
block|{
name|data
operator||=
name|IGP02E1000_PM_D0_LPLU
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* When LPLU is enabled, we should disable SmartSpeed */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|data
operator|&=
operator|~
name|IGP02E1000_PM_D0_LPLU
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP02E1000_PHY_POWER_MGMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* 		 * LPLU and SmartSpeed are mutually exclusive.  LPLU is used 		 * during Dx states where the power conservation is most 		 * important.  During driver activity we should enable 		 * SmartSpeed, so performance is maintained. 		 */
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_on
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator||=
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_off
condition|)
block|{
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|data
operator|&=
operator|~
name|IGP01E1000_PSCFR_SMART_SPEED
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|IGP01E1000_PHY_PORT_CONFIG
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d0_lplu_state_82580 - Set Low Power Linkup D0 state  *  @hw: pointer to the HW structure  *  @active: TRUE to enable LPLU, FALSE to disable  *  *  Sets the LPLU D0 state according to the active flag.  When  *  activating LPLU this function also disables smart speed  *  and vice versa.  LPLU will not be activated unless the  *  device autonegotiation advertisement meets standards of  *  either 10 or 10/100 or 10/100/1000 at all duplexes.  *  This is a function pointer entry point only called by  *  PHY setup routines.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_set_d0_lplu_state_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d0_lplu_state_82580"
argument_list|)
expr_stmt|;
name|data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_82580_PHY_POWER_MGMT
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
condition|)
block|{
name|data
operator||=
name|E1000_82580_PM_D0_LPLU
expr_stmt|;
comment|/* When LPLU is enabled, we should disable SmartSpeed */
name|data
operator|&=
operator|~
name|E1000_82580_PM_SPD
expr_stmt|;
block|}
else|else
block|{
name|data
operator|&=
operator|~
name|E1000_82580_PM_D0_LPLU
expr_stmt|;
comment|/* 		 * LPLU and SmartSpeed are mutually exclusive.  LPLU is used 		 * during Dx states where the power conservation is most 		 * important.  During driver activity we should enable 		 * SmartSpeed, so performance is maintained. 		 */
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_on
condition|)
name|data
operator||=
name|E1000_82580_PM_SPD
expr_stmt|;
elseif|else
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_off
condition|)
name|data
operator|&=
operator|~
name|E1000_82580_PM_SPD
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_82580_PHY_POWER_MGMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_d3_lplu_state_82580 - Sets low power link up state for D3  *  @hw: pointer to the HW structure  *  @active: boolean used to enable/disable lplu  *  *  Success returns 0, Failure returns 1  *  *  The low power link up (lplu) state is set to the power management level D3  *  and SmartSpeed is disabled when active is TRUE, else clear lplu for D3  *  and enable Smartspeed.  LPLU and Smartspeed are mutually exclusive.  LPLU  *  is used during Dx states where the power conservation is most important.  *  During driver activity, SmartSpeed should be enabled so performance is  *  maintained.  **/
end_comment

begin_function
name|s32
name|e1000_set_d3_lplu_state_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|u32
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_d3_lplu_state_82580"
argument_list|)
expr_stmt|;
name|data
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_82580_PHY_POWER_MGMT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|active
condition|)
block|{
name|data
operator|&=
operator|~
name|E1000_82580_PM_D3_LPLU
expr_stmt|;
comment|/* 		 * LPLU and SmartSpeed are mutually exclusive.  LPLU is used 		 * during Dx states where the power conservation is most 		 * important.  During driver activity we should enable 		 * SmartSpeed, so performance is maintained. 		 */
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_on
condition|)
name|data
operator||=
name|E1000_82580_PM_SPD
expr_stmt|;
elseif|else
if|if
condition|(
name|phy
operator|->
name|smart_speed
operator|==
name|e1000_smart_speed_off
condition|)
name|data
operator|&=
operator|~
name|E1000_82580_PM_SPD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_SPEED_DUPLEX
operator|)
operator|||
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_NOT_GIG
operator|)
operator|||
operator|(
name|phy
operator|->
name|autoneg_advertised
operator|==
name|E1000_ALL_10_SPEED
operator|)
condition|)
block|{
name|data
operator||=
name|E1000_82580_PM_D3_LPLU
expr_stmt|;
comment|/* When LPLU is enabled, we should disable SmartSpeed */
name|data
operator|&=
operator|~
name|E1000_82580_PM_SPD
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_82580_PHY_POWER_MGMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_nvm_82575 - Request for access to EEPROM  *  @hw: pointer to the HW structure  *  *  Acquire the necessary semaphores for exclusive access to the EEPROM.  *  Set the EEPROM access request bit and wait for EEPROM access grant bit.  *  Return successful if access grant bit set, else clear the request for  *  EEPROM access and return -E1000_ERR_NVM (-1).  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_acquire_nvm_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_nvm_82575"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_acquire_swfw_sync_82575
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Check if there is some access 	 * error this access may hook on 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_i350
condition|)
block|{
name|u32
name|eecd
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
decl_stmt|;
if|if
condition|(
name|eecd
operator|&
operator|(
name|E1000_EECD_BLOCKED
operator||
name|E1000_EECD_ABORT
operator||
name|E1000_EECD_TIMEOUT
operator|)
condition|)
block|{
comment|/* Clear all access error flags */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
operator||
name|E1000_EECD_ERROR_CLR
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Nvm bit banging access error detected and cleared.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82580
condition|)
block|{
name|u32
name|eecd
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
decl_stmt|;
if|if
condition|(
name|eecd
operator|&
name|E1000_EECD_BLOCKED
condition|)
block|{
comment|/* Clear access error flag */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|eecd
operator||
name|E1000_EECD_BLOCKED
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Nvm bit banging access error detected and cleared.\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|ret_val
operator|=
name|e1000_acquire_nvm_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|e1000_release_swfw_sync_82575
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_nvm_82575 - Release exclusive access to EEPROM  *  @hw: pointer to the HW structure  *  *  Stop any current commands to the EEPROM and clear the EEPROM request bit,  *  then release the semaphores acquired.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_release_nvm_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_nvm_82575"
argument_list|)
expr_stmt|;
name|e1000_release_nvm_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|e1000_release_swfw_sync_82575
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_swfw_sync_82575 - Acquire SW/FW semaphore  *  @hw: pointer to the HW structure  *  @mask: specifies which semaphore to acquire  *  *  Acquire the SW/FW semaphore to access the PHY or NVM.  The mask  *  will also specify which port we're acquiring the lock for.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_acquire_swfw_sync_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
block|{
name|u32
name|swfw_sync
decl_stmt|;
name|u32
name|swmask
init|=
name|mask
decl_stmt|;
name|u32
name|fwmask
init|=
name|mask
operator|<<
literal|16
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|s32
name|i
init|=
literal|0
decl_stmt|,
name|timeout
init|=
literal|200
decl_stmt|;
comment|/* FIXME: find real value to use here */
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_swfw_sync_82575"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|timeout
condition|)
block|{
if|if
condition|(
name|e1000_get_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|swfw_sync
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swfw_sync
operator|&
operator|(
name|fwmask
operator||
name|swmask
operator|)
operator|)
condition|)
break|break;
comment|/* 		 * Firmware currently using resource (fwmask) 		 * or other software thread using resource (swmask) 		 */
name|e1000_put_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay_irq
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access resource, SW_FW_SYNC timeout.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|swfw_sync
operator||=
name|swmask
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|,
name|swfw_sync
argument_list|)
expr_stmt|;
name|e1000_put_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_swfw_sync_82575 - Release SW/FW semaphore  *  @hw: pointer to the HW structure  *  @mask: specifies which semaphore to acquire  *  *  Release the SW/FW semaphore used to access the PHY or NVM.  The mask  *  will also specify which port we're releasing the lock for.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_release_swfw_sync_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
block|{
name|u32
name|swfw_sync
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_swfw_sync_82575"
argument_list|)
expr_stmt|;
while|while
condition|(
name|e1000_get_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
operator|!=
name|E1000_SUCCESS
condition|)
empty_stmt|;
comment|/* Empty */
name|swfw_sync
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|)
expr_stmt|;
name|swfw_sync
operator|&=
operator|~
name|mask
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|,
name|swfw_sync
argument_list|)
expr_stmt|;
name|e1000_put_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_cfg_done_82575 - Read config done bit  *  @hw: pointer to the HW structure  *  *  Read the management control register for the config done bit for  *  completion status.  NOTE: silicon which is EEPROM-less will fail trying  *  to read the config done bit, so an error is *ONLY* logged and returns  *  E1000_SUCCESS.  If we were to return with error, EEPROM-less silicon  *  would not be able to be reset or change link.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_cfg_done_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|timeout
init|=
name|PHY_CFG_TIMEOUT
decl_stmt|;
name|u32
name|mask
init|=
name|E1000_NVM_CFG_DONE_PORT_0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_cfg_done_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
name|E1000_FUNC_1
condition|)
name|mask
operator|=
name|E1000_NVM_CFG_DONE_PORT_1
expr_stmt|;
elseif|else
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
name|E1000_FUNC_2
condition|)
name|mask
operator|=
name|E1000_NVM_CFG_DONE_PORT_2
expr_stmt|;
elseif|else
if|if
condition|(
name|hw
operator|->
name|bus
operator|.
name|func
operator|==
name|E1000_FUNC_3
condition|)
name|mask
operator|=
name|E1000_NVM_CFG_DONE_PORT_3
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EEMNGCTL
argument_list|)
operator|&
name|mask
condition|)
break|break;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timeout
condition|)
name|DEBUGOUT
argument_list|(
literal|"MNG configuration cycle has not completed.\n"
argument_list|)
expr_stmt|;
comment|/* If EEPROM is not marked present, init the PHY manually */
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
operator|&
name|E1000_EECD_PRES
operator|)
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|e1000_phy_igp_3
operator|)
condition|)
name|e1000_phy_init_script_igp3
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_link_up_info_82575 - Get link speed/duplex info  *  @hw: pointer to the HW structure  *  @speed: stores the current speed  *  @duplex: stores the current duplex  *  *  This is a wrapper function, if using the serial gigabit media independent  *  interface, use PCS to retrieve the link speed and duplex information.  *  Otherwise, use the generic function to get the link speed and duplex info.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_link_up_info_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_link_up_info_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|e1000_media_type_copper
condition|)
name|ret_val
operator|=
name|e1000_get_pcs_speed_and_duplex_82575
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
name|e1000_get_speed_and_duplex_copper_generic
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_link_82575 - Check for link  *  @hw: pointer to the HW structure  *  *  If sgmii is enabled, then use the pcs register to determine link, otherwise  *  use the generic interface for determining link.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_check_for_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|speed
decl_stmt|,
name|duplex
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_link_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|e1000_media_type_copper
condition|)
block|{
name|ret_val
operator|=
name|e1000_get_pcs_speed_and_duplex_82575
argument_list|(
name|hw
argument_list|,
operator|&
name|speed
argument_list|,
operator|&
name|duplex
argument_list|)
expr_stmt|;
comment|/* 		 * Use this flag to determine if link needs to be checked or 		 * not.  If we have link clear the flag so that we do not 		 * continue to check for link. 		 */
name|hw
operator|->
name|mac
operator|.
name|get_link_status
operator|=
operator|!
name|hw
operator|->
name|mac
operator|.
name|serdes_has_link
expr_stmt|;
comment|/* 		 * Configure Flow Control now that Auto-Neg has completed. 		 * First, we need to restore the desired flow control 		 * settings because we may have had to re-autoneg with a 		 * different link partner. 		 */
name|ret_val
operator|=
name|e1000_config_fc_after_link_up_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT
argument_list|(
literal|"Error configuring flow control\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|e1000_check_for_copper_link_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_link_media_swap - Check which M88E1112 interface linked  *  @hw: pointer to the HW structure  *  *  Poll the M88E1112 interfaces to see which interface achieved link.  */
end_comment

begin_function
specifier|static
name|s32
name|e1000_check_for_link_media_swap
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|u8
name|port
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_link_media_swap"
argument_list|)
expr_stmt|;
comment|/* Check the copper medium. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1112_PAGE_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1112_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|data
operator|&
name|E1000_M88E1112_STATUS_LINK
condition|)
name|port
operator|=
name|E1000_MEDIA_PORT_COPPER
expr_stmt|;
comment|/* Check the other medium. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1112_PAGE_ADDR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1112_STATUS
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* reset page to 0 */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1112_PAGE_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|data
operator|&
name|E1000_M88E1112_STATUS_LINK
condition|)
name|port
operator|=
name|E1000_MEDIA_PORT_OTHER
expr_stmt|;
comment|/* Determine if a swap needs to happen. */
if|if
condition|(
name|port
operator|&&
operator|(
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
operator|.
name|media_port
operator|!=
name|port
operator|)
condition|)
block|{
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
operator|.
name|media_port
operator|=
name|port
expr_stmt|;
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
operator|.
name|media_changed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|e1000_check_for_link_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_power_up_serdes_link_82575 - Power up the serdes link after shutdown  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_power_up_serdes_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_power_up_serdes_link_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|e1000_media_type_internal_serdes
operator|)
operator|&&
operator|!
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
condition|)
return|return;
comment|/* Enable PCS to turn on link */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_CFG0
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_PCS_CFG_PCS_EN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_CFG0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Power up the laser */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|E1000_CTRL_EXT_SDP3_DATA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* flush the write to verify completion */
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_pcs_speed_and_duplex_82575 - Retrieve current speed/duplex  *  @hw: pointer to the HW structure  *  @speed: stores the current speed  *  @duplex: stores the current duplex  *  *  Using the physical coding sub-layer (PCS), retrieve the current speed and  *  duplex, then store the values in the pointers provided.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_pcs_speed_and_duplex_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|u32
name|pcs
decl_stmt|;
name|u32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_pcs_speed_and_duplex_82575"
argument_list|)
expr_stmt|;
comment|/* 	 * Read the PCS Status register for link state. For non-copper mode, 	 * the status register is not accurate. The PCS status register is 	 * used instead. 	 */
name|pcs
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_LSTAT
argument_list|)
expr_stmt|;
comment|/* 	 * The link up bit determines when link is up on autoneg. 	 */
if|if
condition|(
name|pcs
operator|&
name|E1000_PCS_LSTS_LINK_OK
condition|)
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|TRUE
expr_stmt|;
comment|/* Detect and store PCS speed */
if|if
condition|(
name|pcs
operator|&
name|E1000_PCS_LSTS_SPEED_1000
condition|)
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
elseif|else
if|if
condition|(
name|pcs
operator|&
name|E1000_PCS_LSTS_SPEED_100
condition|)
operator|*
name|speed
operator|=
name|SPEED_100
expr_stmt|;
else|else
operator|*
name|speed
operator|=
name|SPEED_10
expr_stmt|;
comment|/* Detect and store PCS duplex */
if|if
condition|(
name|pcs
operator|&
name|E1000_PCS_LSTS_DUPLEX_FULL
condition|)
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
else|else
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
comment|/* Check if it is an I354 2.5Gb backplane connection. */
if|if
condition|(
name|mac
operator|->
name|type
operator|==
name|e1000_i354
condition|)
block|{
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|E1000_STATUS_2P5_SKU
operator|)
operator|&&
operator|!
operator|(
name|status
operator|&
name|E1000_STATUS_2P5_SKU_OVER
operator|)
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_2500
expr_stmt|;
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"2500 Mbs, "
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|mac
operator|->
name|serdes_has_link
operator|=
name|FALSE
expr_stmt|;
operator|*
name|speed
operator|=
literal|0
expr_stmt|;
operator|*
name|duplex
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_shutdown_serdes_link_82575 - Remove link during power down  *  @hw: pointer to the HW structure  *  *  In the case of serdes shut down sfp and PCS on driver unload  *  when management pass thru is not enabled.  **/
end_comment

begin_function
name|void
name|e1000_shutdown_serdes_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_shutdown_serdes_link_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|e1000_media_type_internal_serdes
operator|)
operator|&&
operator|!
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|e1000_enable_mng_pass_thru
argument_list|(
name|hw
argument_list|)
condition|)
block|{
comment|/* Disable PCS to turn off link */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_CFG0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|E1000_PCS_CFG_PCS_EN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_CFG0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* shutdown the laser */
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|reg
operator||=
name|E1000_CTRL_EXT_SDP3_DATA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* flush the write to verify completion */
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_hw_82575 - Reset hardware  *  @hw: pointer to the HW structure  *  *  This resets the hardware into a known state.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_reset_hw_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_hw_82575"
argument_list|)
expr_stmt|;
comment|/* 	 * Prevent the PCI-E bus from sticking if there is no TLP connection 	 * on the last TLP read/write transaction when MAC is reset. 	 */
name|ret_val
operator|=
name|e1000_disable_pcie_master_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT
argument_list|(
literal|"PCI-E Master disable polling has failed.\n"
argument_list|)
expr_stmt|;
comment|/* set the completion timeout for interface */
name|ret_val
operator|=
name|e1000_set_pcie_completion_timeout
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT
argument_list|(
literal|"PCI-E Set completion timeout has failed.\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|E1000_TCTL_PSP
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Issuing a global reset to MAC\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_RST
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_auto_rd_done_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
comment|/* 		 * When auto config read does not complete, do not 		 * return with an error. This can happen in situations 		 * where there is no eeprom and prevents getting link. 		 */
name|DEBUGOUT
argument_list|(
literal|"Auto Read Done did not complete\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If EEPROM is not present, run manual init scripts */
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
operator|&
name|E1000_EECD_PRES
operator|)
condition|)
name|e1000_reset_init_script_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupt events. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
comment|/* Install any alternate MAC address into RAR0 */
name|ret_val
operator|=
name|e1000_check_alt_mac_addr_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_hw_82575 - Initialize hardware  *  @hw: pointer to the HW structure  *  *  This inits the hardware readying it for operation.  **/
end_comment

begin_function
name|s32
name|e1000_init_hw_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|rar_count
init|=
name|mac
operator|->
name|rar_entry_count
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_hw_82575"
argument_list|)
expr_stmt|;
comment|/* Initialize identification LED */
name|ret_val
operator|=
name|mac
operator|->
name|ops
operator|.
name|id_led_init
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error initializing identification LED\n"
argument_list|)
expr_stmt|;
comment|/* This is not fatal and we should not stop init due to this */
block|}
comment|/* Disabling VLAN filtering */
name|DEBUGOUT
argument_list|(
literal|"Initializing the IEEE VLAN\n"
argument_list|)
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vfta
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Setup the receive address */
name|e1000_init_rx_addrs_generic
argument_list|(
name|hw
argument_list|,
name|rar_count
argument_list|)
expr_stmt|;
comment|/* Zero out the Multicast HASH table */
name|DEBUGOUT
argument_list|(
literal|"Zeroing the MTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mac
operator|->
name|mta_reg_count
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_MTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Zero out the Unicast HASH table */
name|DEBUGOUT
argument_list|(
literal|"Zeroing the UTA\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mac
operator|->
name|uta_reg_count
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_UTA
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup link and flow control */
name|ret_val
operator|=
name|mac
operator|->
name|ops
operator|.
name|setup_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Set the default MTU size */
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
operator|.
name|mtu
operator|=
literal|1500
expr_stmt|;
comment|/* 	 * Clear all of the statistics registers (clear on read).  It is 	 * important that we do this after we have tried to establish link 	 * because the symbol error count will increment wildly if there 	 * is no link. 	 */
name|e1000_clear_hw_cntrs_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_copper_link_82575 - Configure copper link settings  *  @hw: pointer to the HW structure  *  *  Configures the link for auto-neg or forced speed and duplex.  Then we check  *  for link, once link is established calls to configure collision distance  *  and flow control are called.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_setup_copper_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|u32
name|phpm_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_copper_link_82575"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl
operator||=
name|E1000_CTRL_SLU
expr_stmt|;
name|ctrl
operator|&=
operator|~
operator|(
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FRCDPX
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Clear Go Link Disconnect bit on supported devices */
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82580
case|:
case|case
name|e1000_i350
case|:
case|case
name|e1000_i210
case|:
case|case
name|e1000_i211
case|:
name|phpm_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_82580_PHY_POWER_MGMT
argument_list|)
expr_stmt|;
name|phpm_reg
operator|&=
operator|~
name|E1000_82580_PM_GO_LINKD
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_82580_PHY_POWER_MGMT
argument_list|,
name|phpm_reg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|ret_val
operator|=
name|e1000_setup_serdes_link_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
condition|)
block|{
comment|/* allow time for SFP cage time to power up phy */
name|msec_delay
argument_list|(
literal|300
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error resetting the PHY.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|e1000_phy_i210
case|:
case|case
name|e1000_phy_m88
case|:
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|id
condition|)
block|{
case|case
name|I347AT4_E_PHY_ID
case|:
case|case
name|M88E1112_E_PHY_ID
case|:
case|case
name|M88E1340M_E_PHY_ID
case|:
case|case
name|M88E1543_E_PHY_ID
case|:
case|case
name|M88E1512_E_PHY_ID
case|:
case|case
name|I210_I_PHY_ID
case|:
name|ret_val
operator|=
name|e1000_copper_link_setup_m88_gen2
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret_val
operator|=
name|e1000_copper_link_setup_m88
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|e1000_phy_igp_3
case|:
name|ret_val
operator|=
name|e1000_copper_link_setup_igp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_phy_82580
case|:
name|ret_val
operator|=
name|e1000_copper_link_setup_82577
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_setup_copper_link_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_serdes_link_82575 - Setup link for serdes  *  @hw: pointer to the HW structure  *  *  Configure the physical coding sub-layer (PCS) link.  The PCS link is  *  used on copper connections where the serialized gigabit media independent  *  interface (sgmii), or serdes fiber is being used.  Configures the link  *  for auto-negotiation or forces speed/duplex.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_setup_serdes_link_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ctrl_ext
decl_stmt|,
name|ctrl_reg
decl_stmt|,
name|reg
decl_stmt|,
name|anadv_reg
decl_stmt|;
name|bool
name|pcs_autoneg
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_serdes_link_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|e1000_media_type_internal_serdes
operator|)
operator|&&
operator|!
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
condition|)
return|return
name|ret_val
return|;
comment|/* 	 * On the 82575, SerDes loopback mode persists until it is 	 * explicitly turned off or a power cycle is performed.  A read to 	 * the register does not indicate its status.  Therefore, we ensure 	 * loopback mode is disabled during initialization. 	 */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SCTL
argument_list|,
name|E1000_SCTL_DISABLE_SERDES_LOOPBACK
argument_list|)
expr_stmt|;
comment|/* power on the sfp cage if present */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|&=
operator|~
name|E1000_CTRL_EXT_SDP3_DATA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|ctrl_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|ctrl_reg
operator||=
name|E1000_CTRL_SLU
expr_stmt|;
comment|/* set both sw defined pins on 82575/82576*/
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82575
operator|||
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82576
condition|)
name|ctrl_reg
operator||=
name|E1000_CTRL_SWDPIN0
operator||
name|E1000_CTRL_SWDPIN1
expr_stmt|;
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_LCTL
argument_list|)
expr_stmt|;
comment|/* default pcs_autoneg to the same setting as mac autoneg */
name|pcs_autoneg
operator|=
name|hw
operator|->
name|mac
operator|.
name|autoneg
expr_stmt|;
switch|switch
condition|(
name|ctrl_ext
operator|&
name|E1000_CTRL_EXT_LINK_MODE_MASK
condition|)
block|{
case|case
name|E1000_CTRL_EXT_LINK_MODE_SGMII
case|:
comment|/* sgmii mode lets the phy handle forcing speed/duplex */
name|pcs_autoneg
operator|=
name|TRUE
expr_stmt|;
comment|/* autoneg time out should be disabled for SGMII mode */
name|reg
operator|&=
operator|~
operator|(
name|E1000_PCS_LCTL_AN_TIMEOUT
operator|)
expr_stmt|;
break|break;
case|case
name|E1000_CTRL_EXT_LINK_MODE_1000BASE_KX
case|:
comment|/* disable PCS autoneg and support parallel detect only */
name|pcs_autoneg
operator|=
name|FALSE
expr_stmt|;
comment|/* fall through to default case */
default|default:
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82575
operator|||
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82576
condition|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_COMPAT
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
if|if
condition|(
name|data
operator|&
name|E1000_EEPROM_PCS_AUTONEG_DISABLE_BIT
condition|)
name|pcs_autoneg
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* 		 * non-SGMII modes only supports a speed of 1000/Full for the 		 * link so it is best to just force the MAC and let the pcs 		 * link either autoneg or be forced to 1000/Full 		 */
name|ctrl_reg
operator||=
name|E1000_CTRL_SPD_1000
operator||
name|E1000_CTRL_FRCSPD
operator||
name|E1000_CTRL_FD
operator||
name|E1000_CTRL_FRCDPX
expr_stmt|;
comment|/* set speed of 1000/Full if speed/duplex is forced */
name|reg
operator||=
name|E1000_PCS_LCTL_FSV_1000
operator||
name|E1000_PCS_LCTL_FDV_FULL
expr_stmt|;
break|break;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl_reg
argument_list|)
expr_stmt|;
comment|/* 	 * New SerDes mode allows for forcing speed or autonegotiating speed 	 * at 1gb. Autoneg should be default set by most drivers. This is the 	 * mode that will be compatible with older link partners and switches. 	 * However, both are supported by the hardware and some drivers/tools. 	 */
name|reg
operator|&=
operator|~
operator|(
name|E1000_PCS_LCTL_AN_ENABLE
operator||
name|E1000_PCS_LCTL_FLV_LINK_UP
operator||
name|E1000_PCS_LCTL_FSD
operator||
name|E1000_PCS_LCTL_FORCE_LINK
operator|)
expr_stmt|;
if|if
condition|(
name|pcs_autoneg
condition|)
block|{
comment|/* Set PCS register for autoneg */
name|reg
operator||=
name|E1000_PCS_LCTL_AN_ENABLE
operator||
comment|/* Enable Autoneg */
name|E1000_PCS_LCTL_AN_RESTART
expr_stmt|;
comment|/* Restart autoneg */
comment|/* Disable force flow control for autoneg */
name|reg
operator|&=
operator|~
name|E1000_PCS_LCTL_FORCE_FCTRL
expr_stmt|;
comment|/* Configure flow control advertisement for autoneg */
name|anadv_reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_ANADV
argument_list|)
expr_stmt|;
name|anadv_reg
operator|&=
operator|~
operator|(
name|E1000_TXCW_ASM_DIR
operator||
name|E1000_TXCW_PAUSE
operator|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
condition|)
block|{
case|case
name|e1000_fc_full
case|:
case|case
name|e1000_fc_rx_pause
case|:
name|anadv_reg
operator||=
name|E1000_TXCW_ASM_DIR
expr_stmt|;
name|anadv_reg
operator||=
name|E1000_TXCW_PAUSE
expr_stmt|;
break|break;
case|case
name|e1000_fc_tx_pause
case|:
name|anadv_reg
operator||=
name|E1000_TXCW_ASM_DIR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_ANADV
argument_list|,
name|anadv_reg
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Configuring Autoneg:PCS_LCTL=0x%08X\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set PCS register for forced link */
name|reg
operator||=
name|E1000_PCS_LCTL_FSD
expr_stmt|;
comment|/* Force Speed */
comment|/* Force flow control for forced link */
name|reg
operator||=
name|E1000_PCS_LCTL_FORCE_FCTRL
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Configuring Forced Link:PCS_LCTL=0x%08X\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_LCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pcs_autoneg
operator|&&
operator|!
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
condition|)
name|e1000_force_mac_fc_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_media_type_82575 - derives current media type.  *  @hw: pointer to the HW structure  *  *  The media type is chosen reflecting few settings.  *  The following are taken into account:  *  - link mode set in the current port Init Control Word #3  *  - current link mode settings in CSR register  *  - MDIO vs. I2C PHY control interface chosen  *  - SFP module media type  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_media_type_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_82575
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|ctrl_ext
init|=
literal|0
decl_stmt|;
name|u32
name|link_mode
init|=
literal|0
decl_stmt|;
comment|/* Set internal phy as default */
name|dev_spec
operator|->
name|sgmii_active
operator|=
name|FALSE
expr_stmt|;
name|dev_spec
operator|->
name|module_plugged
operator|=
name|FALSE
expr_stmt|;
comment|/* Get CSR setting */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
comment|/* extract link mode setting */
name|link_mode
operator|=
name|ctrl_ext
operator|&
name|E1000_CTRL_EXT_LINK_MODE_MASK
expr_stmt|;
switch|switch
condition|(
name|link_mode
condition|)
block|{
case|case
name|E1000_CTRL_EXT_LINK_MODE_1000BASE_KX
case|:
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_internal_serdes
expr_stmt|;
break|break;
case|case
name|E1000_CTRL_EXT_LINK_MODE_GMII
case|:
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_copper
expr_stmt|;
break|break;
case|case
name|E1000_CTRL_EXT_LINK_MODE_SGMII
case|:
comment|/* Get phy control interface type set (MDIO vs. I2C)*/
if|if
condition|(
name|e1000_sgmii_uses_mdio_82575
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_copper
expr_stmt|;
name|dev_spec
operator|->
name|sgmii_active
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* fall through for I2C based SGMII */
case|case
name|E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES
case|:
comment|/* read media type from SFP EEPROM */
name|ret_val
operator|=
name|e1000_set_sfp_media_type_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|!=
name|E1000_SUCCESS
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_unknown
operator|)
condition|)
block|{
comment|/* 			 * If media type was not identified then return media 			 * type defined by the CTRL_EXT settings. 			 */
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_internal_serdes
expr_stmt|;
if|if
condition|(
name|link_mode
operator|==
name|E1000_CTRL_EXT_LINK_MODE_SGMII
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_copper
expr_stmt|;
name|dev_spec
operator|->
name|sgmii_active
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
block|}
comment|/* do not change link mode for 100BaseFX */
if|if
condition|(
name|dev_spec
operator|->
name|eth_flags
operator|.
name|e100_base_fx
condition|)
break|break;
comment|/* change current link mode setting */
name|ctrl_ext
operator|&=
operator|~
name|E1000_CTRL_EXT_LINK_MODE_MASK
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_copper
condition|)
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_LINK_MODE_SGMII
expr_stmt|;
else|else
name|ctrl_ext
operator||=
name|E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_sfp_media_type_82575 - derives SFP module media type.  *  @hw: pointer to the HW structure  *  *  The media type is chosen based on SFP module.  *  compatibility flags retrieved from SFP ID EEPROM.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_set_sfp_media_type_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_ERR_CONFIG
decl_stmt|;
name|u32
name|ctrl_ext
init|=
literal|0
decl_stmt|;
name|struct
name|e1000_dev_spec_82575
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
decl_stmt|;
name|struct
name|sfp_e1000_flags
modifier|*
name|eth_flags
init|=
operator|&
name|dev_spec
operator|->
name|eth_flags
decl_stmt|;
name|u8
name|tranceiver_type
init|=
literal|0
decl_stmt|;
name|s32
name|timeout
init|=
literal|3
decl_stmt|;
comment|/* Turn I2C interface ON and power on sfp cage */
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|&=
operator|~
name|E1000_CTRL_EXT_SDP3_DATA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
operator||
name|E1000_CTRL_I2C_ENA
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Read SFP module data */
while|while
condition|(
name|timeout
condition|)
block|{
name|ret_val
operator|=
name|e1000_read_sfp_data_byte
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD_SFP_DATA_ADDR
argument_list|(
name|E1000_SFF_IDENTIFIER_OFFSET
argument_list|)
argument_list|,
operator|&
name|tranceiver_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|timeout
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_sfp_data_byte
argument_list|(
name|hw
argument_list|,
name|E1000_I2CCMD_SFP_DATA_ADDR
argument_list|(
name|E1000_SFF_ETH_FLAGS_OFFSET
argument_list|)
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|eth_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|out
goto|;
comment|/* Check if there is some SFP module plugged and powered */
if|if
condition|(
operator|(
name|tranceiver_type
operator|==
name|E1000_SFF_IDENTIFIER_SFP
operator|)
operator|||
operator|(
name|tranceiver_type
operator|==
name|E1000_SFF_IDENTIFIER_SFF
operator|)
condition|)
block|{
name|dev_spec
operator|->
name|module_plugged
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|eth_flags
operator|->
name|e1000_base_lx
operator|||
name|eth_flags
operator|->
name|e1000_base_sx
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_internal_serdes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eth_flags
operator|->
name|e100_base_fx
condition|)
block|{
name|dev_spec
operator|->
name|sgmii_active
operator|=
name|TRUE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_internal_serdes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eth_flags
operator|->
name|e1000_base_t
condition|)
block|{
name|dev_spec
operator|->
name|sgmii_active
operator|=
name|TRUE
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_copper
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_unknown
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"PHY module has not been recognized\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_unknown
expr_stmt|;
block|}
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
name|out
label|:
comment|/* Restore I2C interface setting */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_valid_led_default_82575 - Verify a valid default LED config  *  @hw: pointer to the HW structure  *  @data: pointer to the NVM (EEPROM)  *  *  Read the EEPROM for the current default LED configuration.  If the  *  LED configuration is not valid, set to a valid LED configuration.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_valid_led_default_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_valid_led_default_82575"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_ID_LED_SETTINGS
argument_list|,
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|*
name|data
operator|==
name|ID_LED_RESERVED_0000
operator|||
operator|*
name|data
operator|==
name|ID_LED_RESERVED_FFFF
condition|)
block|{
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
condition|)
block|{
case|case
name|e1000_media_type_internal_serdes
case|:
operator|*
name|data
operator|=
name|ID_LED_DEFAULT_82575_SERDES
expr_stmt|;
break|break;
case|case
name|e1000_media_type_copper
case|:
default|default:
operator|*
name|data
operator|=
name|ID_LED_DEFAULT
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_sgmii_active_82575 - Return sgmii state  *  @hw: pointer to the HW structure  *  *  82575 silicon has a serialized gigabit media independent interface (sgmii)  *  which can be enabled for use in the embedded applications.  Simply  *  return the current state of the sgmii interface.  **/
end_comment

begin_function
specifier|static
name|bool
name|e1000_sgmii_active_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_dev_spec_82575
modifier|*
name|dev_spec
init|=
operator|&
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
decl_stmt|;
return|return
name|dev_spec
operator|->
name|sgmii_active
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_init_script_82575 - Inits HW defaults after reset  *  @hw: pointer to the HW structure  *  *  Inits recommended HW defaults after a reset when there is no EEPROM  *  detected. This is only for the 82575.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_reset_init_script_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_init_script_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Running reset init script for 82575\n"
argument_list|)
expr_stmt|;
comment|/* SerDes configuration via SERDESCTRL */
name|e1000_write_8bit_ctrl_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_SCTL
argument_list|,
literal|0x00
argument_list|,
literal|0x0C
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_SCTL
argument_list|,
literal|0x01
argument_list|,
literal|0x78
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_SCTL
argument_list|,
literal|0x1B
argument_list|,
literal|0x23
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_SCTL
argument_list|,
literal|0x23
argument_list|,
literal|0x15
argument_list|)
expr_stmt|;
comment|/* CCM configuration via CCMCTL register */
name|e1000_write_8bit_ctrl_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_CCMCTL
argument_list|,
literal|0x14
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_CCMCTL
argument_list|,
literal|0x10
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* PCIe lanes configuration */
name|e1000_write_8bit_ctrl_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_GIOCTL
argument_list|,
literal|0x00
argument_list|,
literal|0xEC
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_GIOCTL
argument_list|,
literal|0x61
argument_list|,
literal|0xDF
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_GIOCTL
argument_list|,
literal|0x34
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_GIOCTL
argument_list|,
literal|0x2F
argument_list|,
literal|0x81
argument_list|)
expr_stmt|;
comment|/* PCIe PLL Configuration */
name|e1000_write_8bit_ctrl_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_SCCTL
argument_list|,
literal|0x02
argument_list|,
literal|0x47
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_SCCTL
argument_list|,
literal|0x14
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|e1000_write_8bit_ctrl_reg_generic
argument_list|(
name|hw
argument_list|,
name|E1000_SCCTL
argument_list|,
literal|0x10
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_mac_addr_82575 - Read device MAC address  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_mac_addr_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_mac_addr_82575"
argument_list|)
expr_stmt|;
comment|/* 	 * If there's an alternate MAC address place it in RAR0 	 * so that it will override the Si installed default perm 	 * address. 	 */
name|ret_val
operator|=
name|e1000_check_alt_mac_addr_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_mac_addr_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_config_collision_dist_82575 - Configure collision distance  *  @hw: pointer to the HW structure  *  *  Configures the collision distance to the default value and is used  *  during link setup.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_config_collision_dist_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|tctl_ext
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_config_collision_dist_82575"
argument_list|)
expr_stmt|;
name|tctl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL_EXT
argument_list|)
expr_stmt|;
name|tctl_ext
operator|&=
operator|~
name|E1000_TCTL_EXT_COLD
expr_stmt|;
name|tctl_ext
operator||=
name|E1000_COLLISION_DISTANCE
operator|<<
name|E1000_TCTL_EXT_COLD_SHIFT
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL_EXT
argument_list|,
name|tctl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * e1000_power_down_phy_copper_82575 - Remove link during PHY power down  * @hw: pointer to the HW structure  *  * In the case of a PHY power down to save power, or to turn off link during a  * driver unload, or wake on lan is not enabled, remove the link.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_power_down_phy_copper_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|phy
operator|->
name|ops
operator|.
name|check_reset_block
operator|)
condition|)
return|return;
comment|/* If the management interface is not enabled, then power down */
if|if
condition|(
operator|!
operator|(
name|e1000_enable_mng_pass_thru
argument_list|(
name|hw
argument_list|)
operator|||
name|phy
operator|->
name|ops
operator|.
name|check_reset_block
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
name|e1000_power_down_phy_copper
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_clear_hw_cntrs_82575 - Clear device specific hardware counters  *  @hw: pointer to the HW structure  *  *  Clears the hardware counters by reading the counter registers.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_clear_hw_cntrs_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_clear_hw_cntrs_82575"
argument_list|)
expr_stmt|;
name|e1000_clear_hw_cntrs_base_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC64
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC127
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC255
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC511
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC1023
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PRC1522
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC64
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC127
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC255
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC511
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC1023
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_PTC1522
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ALGNERRC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXERRC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TNCRS
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CEXTERR
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TSCTFC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPRC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPDC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MGTPTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IAC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXOC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXPTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXATC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXPTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXATC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXQEC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICTXQMTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICRXDMTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CBTMPC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HTDPMC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CBRMPC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RPTHC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGPTC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HTCBDPC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGORCL
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGORCH
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGOTCL
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_HGOTCH
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_LENERRS
argument_list|)
expr_stmt|;
comment|/* This register should not be read in copper configurations */
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|==
name|e1000_media_type_internal_serdes
operator|)
operator|||
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
condition|)
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SCVPC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_rx_fifo_flush_82575 - Clean rx fifo after Rx enable  *  @hw: pointer to the HW structure  *  *  After rx enable if managability is enabled then there is likely some  *  bad data at the start of the fifo and possibly in the DMA fifo.  This  *  function clears the fifos and flushes any packets that came in as rx was  *  being enabled.  **/
end_comment

begin_function
name|void
name|e1000_rx_fifo_flush_82575
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|rctl
decl_stmt|,
name|rlpml
decl_stmt|,
name|rxdctl
index|[
literal|4
index|]
decl_stmt|,
name|rfctl
decl_stmt|,
name|temp_rctl
decl_stmt|,
name|rx_enabled
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ms_wait
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_rx_fifo_workaround_82575"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82575
operator|||
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MANC
argument_list|)
operator|&
name|E1000_MANC_RCV_TCO_EN
operator|)
condition|)
return|return;
comment|/* Disable all Rx queues */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|rxdctl
index|[
name|i
index|]
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxdctl
index|[
name|i
index|]
operator|&
operator|~
name|E1000_RXDCTL_QUEUE_ENABLE
argument_list|)
expr_stmt|;
block|}
comment|/* Poll all queues to verify they have shut down */
for|for
control|(
name|ms_wait
operator|=
literal|0
init|;
name|ms_wait
operator|<
literal|10
condition|;
name|ms_wait
operator|++
control|)
block|{
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rx_enabled
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|rx_enabled
operator||=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rx_enabled
operator|&
name|E1000_RXDCTL_QUEUE_ENABLE
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|ms_wait
operator|==
literal|10
condition|)
name|DEBUGOUT
argument_list|(
literal|"Queue disable timed out after 10ms\n"
argument_list|)
expr_stmt|;
comment|/* Clear RLPML, RCTL.SBP, RFCTL.LEF, and set RCTL.LPE so that all 	 * incoming packets are rejected.  Set enable and wait 2ms so that 	 * any packet that was coming in as RCTL.EN was set is flushed 	 */
name|rfctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RFCTL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RFCTL
argument_list|,
name|rfctl
operator|&
operator|~
name|E1000_RFCTL_LEF
argument_list|)
expr_stmt|;
name|rlpml
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RLPML
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RLPML
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|)
expr_stmt|;
name|temp_rctl
operator|=
name|rctl
operator|&
operator|~
operator|(
name|E1000_RCTL_EN
operator||
name|E1000_RCTL_SBP
operator|)
expr_stmt|;
name|temp_rctl
operator||=
name|E1000_RCTL_LPE
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|temp_rctl
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|temp_rctl
operator||
name|E1000_RCTL_EN
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable Rx queues that were previously enabled and restore our 	 * previous state 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RXDCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxdctl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
name|rctl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RLPML
argument_list|,
name|rlpml
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RFCTL
argument_list|,
name|rfctl
argument_list|)
expr_stmt|;
comment|/* Flush receive errors generated by workaround */
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ROC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RNBC
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MPC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_pcie_completion_timeout - set pci-e completion timeout  *  @hw: pointer to the HW structure  *  *  The defaults for 82575 and 82576 should be in the range of 50us to 50ms,  *  however the hardware default for these parts is 500us to 1ms which is less  *  than the 10ms recommended by the pci-e spec.  To address this we need to  *  increase the value to either 10ms to 200ms for capability version 1 config,  *  or 16ms to 55ms for version 2.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_set_pcie_completion_timeout
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|gcr
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GCR
argument_list|)
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|pcie_devctl2
decl_stmt|;
comment|/* only take action if timeout value is defaulted to 0 */
if|if
condition|(
name|gcr
operator|&
name|E1000_GCR_CMPL_TMOUT_MASK
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * if capababilities version is type 1 we can write the 	 * timeout of 10ms to 200ms through the GCR register 	 */
if|if
condition|(
operator|!
operator|(
name|gcr
operator|&
name|E1000_GCR_CAP_VER2
operator|)
condition|)
block|{
name|gcr
operator||=
name|E1000_GCR_CMPL_TMOUT_10ms
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * for version 2 capabilities we need to write the config space 	 * directly in order to set the completion timeout value for 	 * 16ms to 55ms 	 */
name|ret_val
operator|=
name|e1000_read_pcie_cap_reg
argument_list|(
name|hw
argument_list|,
name|PCIE_DEVICE_CONTROL2
argument_list|,
operator|&
name|pcie_devctl2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|pcie_devctl2
operator||=
name|PCIE_DEVICE_CONTROL2_16ms
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_pcie_cap_reg
argument_list|(
name|hw
argument_list|,
name|PCIE_DEVICE_CONTROL2
argument_list|,
operator|&
name|pcie_devctl2
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* disable completion timeout resend */
name|gcr
operator|&=
operator|~
name|E1000_GCR_CMPL_TMOUT_RESEND
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_GCR
argument_list|,
name|gcr
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_vmdq_set_anti_spoofing_pf - enable or disable anti-spoofing  *  @hw: pointer to the hardware struct  *  @enable: state to enter, either enabled or disabled  *  @pf: Physical Function pool - do not set anti-spoofing for the PF  *  *  enables/disables L2 switch anti-spoofing functionality.  **/
end_comment

begin_function
name|void
name|e1000_vmdq_set_anti_spoofing_pf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|enable
parameter_list|,
name|int
name|pf
parameter_list|)
block|{
name|u32
name|reg_val
decl_stmt|,
name|reg_offset
decl_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82576
case|:
name|reg_offset
operator|=
name|E1000_DTXSWC
expr_stmt|;
break|break;
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
name|reg_offset
operator|=
name|E1000_TXSWC
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|reg_val
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|reg_val
operator||=
operator|(
name|E1000_DTXSWC_MAC_SPOOF_MASK
operator||
name|E1000_DTXSWC_VLAN_SPOOF_MASK
operator|)
expr_stmt|;
comment|/* The PF can spoof - it has to in order to 		 * support emulation mode NICs 		 */
name|reg_val
operator|^=
operator|(
literal|1
operator|<<
name|pf
operator||
literal|1
operator|<<
operator|(
name|pf
operator|+
name|MAX_NUM_VFS
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|reg_val
operator|&=
operator|~
operator|(
name|E1000_DTXSWC_MAC_SPOOF_MASK
operator||
name|E1000_DTXSWC_VLAN_SPOOF_MASK
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|reg_offset
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_vmdq_set_loopback_pf - enable or disable vmdq loopback  *  @hw: pointer to the hardware struct  *  @enable: state to enter, either enabled or disabled  *  *  enables/disables L2 switch loopback functionality.  **/
end_comment

begin_function
name|void
name|e1000_vmdq_set_loopback_pf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|u32
name|dtxswc
decl_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
condition|)
block|{
case|case
name|e1000_82576
case|:
name|dtxswc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DTXSWC
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|dtxswc
operator||=
name|E1000_DTXSWC_VMDQ_LOOPBACK_EN
expr_stmt|;
else|else
name|dtxswc
operator|&=
operator|~
name|E1000_DTXSWC_VMDQ_LOOPBACK_EN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_DTXSWC
argument_list|,
name|dtxswc
argument_list|)
expr_stmt|;
break|break;
case|case
name|e1000_i350
case|:
case|case
name|e1000_i354
case|:
name|dtxswc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXSWC
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|dtxswc
operator||=
name|E1000_DTXSWC_VMDQ_LOOPBACK_EN
expr_stmt|;
else|else
name|dtxswc
operator|&=
operator|~
name|E1000_DTXSWC_VMDQ_LOOPBACK_EN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TXSWC
argument_list|,
name|dtxswc
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Currently no other hardware supports loopback */
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_vmdq_set_replication_pf - enable or disable vmdq replication  *  @hw: pointer to the hardware struct  *  @enable: state to enter, either enabled or disabled  *  *  enables/disables replication of packets across multiple pools.  **/
end_comment

begin_function
name|void
name|e1000_vmdq_set_replication_pf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|u32
name|vt_ctl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_VT_CTL
argument_list|)
decl_stmt|;
if|if
condition|(
name|enable
condition|)
name|vt_ctl
operator||=
name|E1000_VT_CTL_VM_REPL_EN
expr_stmt|;
else|else
name|vt_ctl
operator|&=
operator|~
name|E1000_VT_CTL_VM_REPL_EN
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_VT_CTL
argument_list|,
name|vt_ctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_phy_reg_82580 - Read 82580 MDI control register  *  @hw: pointer to the HW structure  *  @offset: register offset to be read  *  @data: pointer to the read data  *  *  Reads the MDI control register in the PHY at offset and stores the  *  information read to data.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_phy_reg_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_phy_reg_82580"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_phy_reg_82580 - Write 82580 MDI control register  *  @hw: pointer to the HW structure  *  @offset: register offset to write to  *  @data: data to write to register at offset  *  *  Writes data to MDI control register in the PHY at offset.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_write_phy_reg_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_phy_reg_82580"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_write_phy_reg_mdic
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_mdicnfg_82580 - Reset MDICNFG destination and com_mdio bits  *  @hw: pointer to the HW structure  *  *  This resets the the MDICNFG.Destination and MDICNFG.Com_MDIO bits based on  *  the values found in the EEPROM.  This addresses an issue in which these  *  bits are not restored from EEPROM after reset.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_reset_mdicnfg_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|mdicnfg
decl_stmt|;
name|u16
name|nvm_data
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_mdicnfg_82580"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|!=
name|e1000_82580
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|e1000_sgmii_active_82575
argument_list|(
name|hw
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_INIT_CONTROL3_PORT_A
operator|+
name|NVM_82580_LAN_FUNC_OFFSET
argument_list|(
name|hw
operator|->
name|bus
operator|.
name|func
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mdicnfg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDICNFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvm_data
operator|&
name|NVM_WORD24_EXT_MDIO
condition|)
name|mdicnfg
operator||=
name|E1000_MDICNFG_EXT_MDIO
expr_stmt|;
if|if
condition|(
name|nvm_data
operator|&
name|NVM_WORD24_COM_MDIO
condition|)
name|mdicnfg
operator||=
name|E1000_MDICNFG_COM_MDIO
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDICNFG
argument_list|,
name|mdicnfg
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_hw_82580 - Reset hardware  *  @hw: pointer to the HW structure  *  *  This resets function or entire device (all ports, etc.)  *  to a known state.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_reset_hw_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
comment|/* BH SW mailbox bit in SW_FW_SYNC */
name|u16
name|swmbsw_mask
init|=
name|E1000_SW_SYNCH_MB
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|bool
name|global_device_reset
init|=
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
operator|.
name|global_device_reset
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_hw_82580"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
operator|.
name|global_device_reset
operator|=
name|FALSE
expr_stmt|;
comment|/* 82580 does not reliably do global_device_reset due to hw errata */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|==
name|e1000_82580
condition|)
name|global_device_reset
operator|=
name|FALSE
expr_stmt|;
comment|/* Get current control state. */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
comment|/* 	 * Prevent the PCI-E bus from sticking if there is no TLP connection 	 * on the last TLP read/write transaction when MAC is reset. 	 */
name|ret_val
operator|=
name|e1000_disable_pcie_master_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT
argument_list|(
literal|"PCI-E Master disable polling has failed.\n"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Masking off all interrupts\n"
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_TCTL
argument_list|,
name|E1000_TCTL_PSP
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Determine whether or not a global dev reset is requested */
if|if
condition|(
name|global_device_reset
operator|&&
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swmbsw_mask
argument_list|)
condition|)
name|global_device_reset
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|global_device_reset
operator|&&
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STAT_DEV_RST_SET
operator|)
condition|)
name|ctrl
operator||=
name|E1000_CTRL_DEV_RST
expr_stmt|;
else|else
name|ctrl
operator||=
name|E1000_CTRL_RST
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|E1000_DEV_ID_DH89XXCC_SGMII
case|:
break|break;
default|default:
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Add delay to insure DEV_RST or RST has time to complete */
name|msec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_get_auto_rd_done_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
comment|/* 		 * When auto config read does not complete, do not 		 * return with an error. This can happen in situations 		 * where there is no eeprom and prevents getting link. 		 */
name|DEBUGOUT
argument_list|(
literal|"Auto Read Done did not complete\n"
argument_list|)
expr_stmt|;
block|}
comment|/* clear global device reset status bit */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|,
name|E1000_STAT_DEV_RST_SET
argument_list|)
expr_stmt|;
comment|/* Clear any pending interrupt events. */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IMC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_ICR
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_reset_mdicnfg_82580
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT
argument_list|(
literal|"Could not reset MDICNFG based on EEPROM\n"
argument_list|)
expr_stmt|;
comment|/* Install any alternate MAC address into RAR0 */
name|ret_val
operator|=
name|e1000_check_alt_mac_addr_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Release semaphore */
if|if
condition|(
name|global_device_reset
condition|)
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swmbsw_mask
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_rxpbs_adjust_82580 - adjust RXPBS value to reflect actual Rx PBA size  *  @data: data received by reading RXPBS register  *  *  The 82580 uses a table based approach for packet buffer allocation sizes.  *  This function converts the retrieved value into the correct table value  *     0x0 0x1 0x2 0x3 0x4 0x5 0x6 0x7  *  0x0 36  72 144   1   2   4   8  16  *  0x8 35  70 140 rsv rsv rsv rsv rsv  */
end_comment

begin_function
name|u16
name|e1000_rxpbs_adjust_82580
parameter_list|(
name|u32
name|data
parameter_list|)
block|{
name|u16
name|ret_val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|data
operator|<
name|E1000_82580_RXPBS_TABLE_SIZE
condition|)
name|ret_val
operator|=
name|e1000_82580_rxpbs_table
index|[
name|data
index|]
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_validate_nvm_checksum_with_offset - Validate EEPROM  *  checksum  *  @hw: pointer to the HW structure  *  @offset: offset in words of the checksum protected region  *  *  Calculates the EEPROM checksum by reading/adding each word of the EEPROM  *  and then verifies that the sum of the EEPROM is equal to 0xBABA.  **/
end_comment

begin_function
name|s32
name|e1000_validate_nvm_checksum_with_offset
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|checksum
init|=
literal|0
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|nvm_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_validate_nvm_checksum_with_offset"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|offset
init|;
name|i
operator|<
operator|(
operator|(
name|NVM_CHECKSUM_REG
operator|+
name|offset
operator|)
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|checksum
operator|+=
name|nvm_data
expr_stmt|;
block|}
if|if
condition|(
name|checksum
operator|!=
operator|(
name|u16
operator|)
name|NVM_SUM
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Checksum Invalid\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_nvm_checksum_with_offset - Update EEPROM  *  checksum  *  @hw: pointer to the HW structure  *  @offset: offset in words of the checksum protected region  *  *  Updates the EEPROM checksum by reading/adding each word of the EEPROM  *  up to the checksum.  Then calculates the EEPROM checksum and writes the  *  value to the EEPROM.  **/
end_comment

begin_function
name|s32
name|e1000_update_nvm_checksum_with_offset
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|checksum
init|=
literal|0
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|nvm_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_nvm_checksum_with_offset"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|offset
init|;
name|i
operator|<
operator|(
name|NVM_CHECKSUM_REG
operator|+
name|offset
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error while updating checksum.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|checksum
operator|+=
name|nvm_data
expr_stmt|;
block|}
name|checksum
operator|=
operator|(
name|u16
operator|)
name|NVM_SUM
operator|-
name|checksum
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|write
argument_list|(
name|hw
argument_list|,
operator|(
name|NVM_CHECKSUM_REG
operator|+
name|offset
operator|)
argument_list|,
literal|1
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
name|DEBUGOUT
argument_list|(
literal|"NVM Write Error while updating checksum.\n"
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_validate_nvm_checksum_82580 - Validate EEPROM checksum  *  @hw: pointer to the HW structure  *  *  Calculates the EEPROM section checksum by reading/adding each word of  *  the EEPROM and then verifies that the sum of the EEPROM is  *  equal to 0xBABA.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_validate_nvm_checksum_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|eeprom_regions_count
init|=
literal|1
decl_stmt|;
name|u16
name|j
decl_stmt|,
name|nvm_data
decl_stmt|;
name|u16
name|nvm_offset
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_validate_nvm_checksum_82580"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_COMPATIBILITY_REG_3
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nvm_data
operator|&
name|NVM_COMPATIBILITY_BIT_MASK
condition|)
block|{
comment|/* if chekcsums compatibility bit is set validate checksums 		 * for all 4 ports. */
name|eeprom_regions_count
operator|=
literal|4
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|eeprom_regions_count
condition|;
name|j
operator|++
control|)
block|{
name|nvm_offset
operator|=
name|NVM_82580_LAN_FUNC_OFFSET
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_validate_nvm_checksum_with_offset
argument_list|(
name|hw
argument_list|,
name|nvm_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_nvm_checksum_82580 - Update EEPROM checksum  *  @hw: pointer to the HW structure  *  *  Updates the EEPROM section checksums for all 4 ports by reading/adding  *  each word of the EEPROM up to the checksum.  Then calculates the EEPROM  *  checksum and writes the value to the EEPROM.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_update_nvm_checksum_82580
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|j
decl_stmt|,
name|nvm_data
decl_stmt|;
name|u16
name|nvm_offset
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_nvm_checksum_82580"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_COMPATIBILITY_REG_3
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error while updating checksum compatibility bit.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|nvm_data
operator|&
name|NVM_COMPATIBILITY_BIT_MASK
operator|)
condition|)
block|{
comment|/* set compatibility bit to validate checksums appropriately */
name|nvm_data
operator|=
name|nvm_data
operator||
name|NVM_COMPATIBILITY_BIT_MASK
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|write
argument_list|(
name|hw
argument_list|,
name|NVM_COMPATIBILITY_REG_3
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Write Error while updating checksum compatibility bit.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|nvm_offset
operator|=
name|NVM_82580_LAN_FUNC_OFFSET
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_update_nvm_checksum_with_offset
argument_list|(
name|hw
argument_list|,
name|nvm_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_validate_nvm_checksum_i350 - Validate EEPROM checksum  *  @hw: pointer to the HW structure  *  *  Calculates the EEPROM section checksum by reading/adding each word of  *  the EEPROM and then verifies that the sum of the EEPROM is  *  equal to 0xBABA.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_validate_nvm_checksum_i350
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|j
decl_stmt|;
name|u16
name|nvm_offset
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_validate_nvm_checksum_i350"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|nvm_offset
operator|=
name|NVM_82580_LAN_FUNC_OFFSET
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_validate_nvm_checksum_with_offset
argument_list|(
name|hw
argument_list|,
name|nvm_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_nvm_checksum_i350 - Update EEPROM checksum  *  @hw: pointer to the HW structure  *  *  Updates the EEPROM section checksums for all 4 ports by reading/adding  *  each word of the EEPROM up to the checksum.  Then calculates the EEPROM  *  checksum and writes the value to the EEPROM.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_update_nvm_checksum_i350
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|j
decl_stmt|;
name|u16
name|nvm_offset
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_nvm_checksum_i350"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|nvm_offset
operator|=
name|NVM_82580_LAN_FUNC_OFFSET
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_update_nvm_checksum_with_offset
argument_list|(
name|hw
argument_list|,
name|nvm_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  __e1000_access_emi_reg - Read/write EMI register  *  @hw: pointer to the HW structure  *  @addr: EMI address to program  *  @data: pointer to value to read/write from/to the EMI address  *  @read: boolean flag to indicate read or write  **/
end_comment

begin_function
specifier|static
name|s32
name|__e1000_access_emi_reg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|address
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|,
name|bool
name|read
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"__e1000_access_emi_reg"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_EMIADD
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|read
condition|)
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|E1000_EMIDATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_EMIDATA
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_emi_reg - Read Extended Management Interface register  *  @hw: pointer to the HW structure  *  @addr: EMI address to program  *  @data: value to be read from the EMI address  **/
end_comment

begin_function
name|s32
name|e1000_read_emi_reg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|addr
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_emi_reg"
argument_list|)
expr_stmt|;
return|return
name|__e1000_access_emi_reg
argument_list|(
name|hw
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_initialize_M88E1512_phy - Initialize M88E1512 PHY  *  @hw: pointer to the HW structure  *  *  Initialize Marverl 1512 to work correctly with Avoton.  **/
end_comment

begin_function
name|s32
name|e1000_initialize_M88E1512_phy
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_initialize_M88E1512_phy"
argument_list|)
expr_stmt|;
comment|/* Check if this is correct PHY. */
if|if
condition|(
name|phy
operator|->
name|id
operator|!=
name|M88E1512_E_PHY_ID
condition|)
goto|goto
name|out
goto|;
comment|/* Switch to PHY page 0xFF. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1543_PAGE_ADDR
argument_list|,
literal|0x00FF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1512_CFG_REG_2
argument_list|,
literal|0x214B
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1512_CFG_REG_1
argument_list|,
literal|0x2144
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1512_CFG_REG_2
argument_list|,
literal|0x0C28
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1512_CFG_REG_1
argument_list|,
literal|0x2146
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1512_CFG_REG_2
argument_list|,
literal|0xB233
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1512_CFG_REG_1
argument_list|,
literal|0x214D
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1512_CFG_REG_2
argument_list|,
literal|0xCC0C
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1512_CFG_REG_1
argument_list|,
literal|0x2159
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Switch to PHY page 0xFB. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1543_PAGE_ADDR
argument_list|,
literal|0x00FB
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1512_CFG_REG_3
argument_list|,
literal|0x000D
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Switch to PHY page 0x12. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1543_PAGE_ADDR
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Change mode to SGMII-to-Copper */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1512_MODE
argument_list|,
literal|0x8001
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Return the PHY to page 0. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1543_PAGE_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|commit
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Error committing the PHY changes\n"
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
name|msec_delay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_eee_i350 - Enable/disable EEE support  *  @hw: pointer to the HW structure  *  *  Enable/disable EEE based on setting in dev_spec structure.  *  **/
end_comment

begin_function
name|s32
name|e1000_set_eee_i350
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|ipcnfg
decl_stmt|,
name|eeer
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_eee_i350"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|<
name|e1000_i350
operator|)
operator|||
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|e1000_media_type_copper
operator|)
condition|)
goto|goto
name|out
goto|;
name|ipcnfg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IPCNFG
argument_list|)
expr_stmt|;
name|eeer
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EEER
argument_list|)
expr_stmt|;
comment|/* enable or disable per user setting */
if|if
condition|(
operator|!
operator|(
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
operator|.
name|eee_disable
operator|)
condition|)
block|{
name|u32
name|eee_su
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EEE_SU
argument_list|)
decl_stmt|;
name|ipcnfg
operator||=
operator|(
name|E1000_IPCNFG_EEE_1G_AN
operator||
name|E1000_IPCNFG_EEE_100M_AN
operator|)
expr_stmt|;
name|eeer
operator||=
operator|(
name|E1000_EEER_TX_LPI_EN
operator||
name|E1000_EEER_RX_LPI_EN
operator||
name|E1000_EEER_LPI_FC
operator|)
expr_stmt|;
comment|/* This bit should not be set in normal operation. */
if|if
condition|(
name|eee_su
operator|&
name|E1000_EEE_SU_LPI_CLK_STP
condition|)
name|DEBUGOUT
argument_list|(
literal|"LPI Clock Stop Bit should not be set!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ipcnfg
operator|&=
operator|~
operator|(
name|E1000_IPCNFG_EEE_1G_AN
operator||
name|E1000_IPCNFG_EEE_100M_AN
operator|)
expr_stmt|;
name|eeer
operator|&=
operator|~
operator|(
name|E1000_EEER_TX_LPI_EN
operator||
name|E1000_EEER_RX_LPI_EN
operator||
name|E1000_EEER_LPI_FC
operator|)
expr_stmt|;
block|}
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IPCNFG
argument_list|,
name|ipcnfg
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EEER
argument_list|,
name|eeer
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_IPCNFG
argument_list|)
expr_stmt|;
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EEER
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_eee_i354 - Enable/disable EEE support  *  @hw: pointer to the HW structure  *  *  Enable/disable EEE legacy mode based on setting in dev_spec structure.  *  **/
end_comment

begin_function
name|s32
name|e1000_set_eee_i354
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_eee_i354"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|e1000_media_type_copper
operator|)
operator|||
operator|(
operator|(
name|phy
operator|->
name|id
operator|!=
name|M88E1543_E_PHY_ID
operator|)
operator|&&
operator|(
name|phy
operator|->
name|id
operator|!=
name|M88E1512_E_PHY_ID
operator|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
operator|.
name|eee_disable
condition|)
block|{
comment|/* Switch to PHY page 18. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1543_PAGE_ADDR
argument_list|,
literal|18
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1543_EEE_CTRL_1
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator||=
name|E1000_M88E1543_EEE_CTRL_1_MS
expr_stmt|;
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1543_EEE_CTRL_1
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Return the PHY to page 0. */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_M88E1543_PAGE_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
comment|/* Turn on EEE advertisement. */
name|ret_val
operator|=
name|e1000_read_xmdio_reg
argument_list|(
name|hw
argument_list|,
name|E1000_EEE_ADV_ADDR_I354
argument_list|,
name|E1000_EEE_ADV_DEV_I354
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator||=
name|E1000_EEE_ADV_100_SUPPORTED
operator||
name|E1000_EEE_ADV_1000_SUPPORTED
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_xmdio_reg
argument_list|(
name|hw
argument_list|,
name|E1000_EEE_ADV_ADDR_I354
argument_list|,
name|E1000_EEE_ADV_DEV_I354
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Turn off EEE advertisement. */
name|ret_val
operator|=
name|e1000_read_xmdio_reg
argument_list|(
name|hw
argument_list|,
name|E1000_EEE_ADV_ADDR_I354
argument_list|,
name|E1000_EEE_ADV_DEV_I354
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
name|phy_data
operator|&=
operator|~
operator|(
name|E1000_EEE_ADV_100_SUPPORTED
operator||
name|E1000_EEE_ADV_1000_SUPPORTED
operator|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_xmdio_reg
argument_list|(
name|hw
argument_list|,
name|E1000_EEE_ADV_ADDR_I354
argument_list|,
name|E1000_EEE_ADV_DEV_I354
argument_list|,
name|phy_data
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_eee_status_i354 - Get EEE status  *  @hw: pointer to the HW structure  *  @status: EEE status  *  *  Get EEE status by guessing based on whether Tx or Rx LPI indications have  *  been received.  **/
end_comment

begin_function
name|s32
name|e1000_get_eee_status_i354
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|status
parameter_list|)
block|{
name|struct
name|e1000_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|phy_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_eee_status_i354"
argument_list|)
expr_stmt|;
comment|/* Check if EEE is supported on this device. */
if|if
condition|(
operator|(
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|!=
name|e1000_media_type_copper
operator|)
operator|||
operator|(
operator|(
name|phy
operator|->
name|id
operator|!=
name|M88E1543_E_PHY_ID
operator|)
operator|&&
operator|(
name|phy
operator|->
name|id
operator|!=
name|M88E1512_E_PHY_ID
operator|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|ret_val
operator|=
name|e1000_read_xmdio_reg
argument_list|(
name|hw
argument_list|,
name|E1000_PCS_STATUS_ADDR_I354
argument_list|,
name|E1000_PCS_STATUS_DEV_I354
argument_list|,
operator|&
name|phy_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
goto|goto
name|out
goto|;
operator|*
name|status
operator|=
name|phy_data
operator|&
operator|(
name|E1000_PCS_STATUS_TX_LPI_RCVD
operator||
name|E1000_PCS_STATUS_RX_LPI_RCVD
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/* Due to a hw errata, if the host tries to  configure the VFTA register  * while performing queries from the BMC or DMA, then the VFTA in some  * cases won't be written.  */
end_comment

begin_comment
comment|/**  *  e1000_clear_vfta_i350 - Clear VLAN filter table  *  @hw: pointer to the HW structure  *  *  Clears the register array which contains the VLAN filter table by  *  setting all the values to 0.  **/
end_comment

begin_function
name|void
name|e1000_clear_vfta_i350
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clear_vfta_350"
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|E1000_VLAN_FILTER_TBL_SIZE
condition|;
name|offset
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VFTA
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  e1000_write_vfta_i350 - Write value to VLAN filter table  *  @hw: pointer to the HW structure  *  @offset: register offset in VLAN filter table  *  @value: register value written to VLAN filter table  *  *  Writes value at the given offset in the register array which stores  *  the VLAN filter table.  **/
end_comment

begin_function
name|void
name|e1000_write_vfta_i350
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|offset
parameter_list|,
name|u32
name|value
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_vfta_350"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|E1000_WRITE_REG_ARRAY
argument_list|(
name|hw
argument_list|,
name|E1000_VFTA
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_i2c_bb - Enable I2C bit-bang  *  @hw: pointer to the HW structure  *  *  Enable I2C bit-bang interface  *  **/
end_comment

begin_function
name|s32
name|e1000_set_i2c_bb
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|ctrl_ext
decl_stmt|,
name|i2cparams
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_i2c_bb"
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
name|E1000_CTRL_I2C_ENA
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|i2cparams
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|)
expr_stmt|;
name|i2cparams
operator||=
name|E1000_I2CBB_EN
expr_stmt|;
name|i2cparams
operator||=
name|E1000_I2C_DATA_OE_N
expr_stmt|;
name|i2cparams
operator||=
name|E1000_I2C_CLK_OE_N
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|,
name|i2cparams
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_i2c_byte_generic - Reads 8 bit word over I2C  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset to read  *  @dev_addr: device address  *  @data: value read  *  *  Performs byte read operation over I2C interface at  *  a specified device address.  **/
end_comment

begin_function
name|s32
name|e1000_read_i2c_byte_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|max_retry
init|=
literal|10
decl_stmt|;
name|u32
name|retry
init|=
literal|1
decl_stmt|;
name|u16
name|swfw_mask
init|=
literal|0
decl_stmt|;
name|bool
name|nack
init|=
name|TRUE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_i2c_byte_generic"
argument_list|)
expr_stmt|;
name|swfw_mask
operator|=
name|E1000_SWFW_PHY0_SM
expr_stmt|;
do|do
block|{
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
operator|!=
name|E1000_SUCCESS
condition|)
block|{
name|status
operator|=
name|E1000_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|read_byte_out
goto|;
block|}
name|e1000_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Device Address and write indication */
name|status
operator|=
name|e1000_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|dev_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|e1000_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|e1000_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|e1000_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|e1000_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Device Address and read indication */
name|status
operator|=
name|e1000_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
operator|(
name|dev_addr
operator||
literal|0x1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|e1000_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|e1000_clock_in_i2c_byte
argument_list|(
name|hw
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|e1000_clock_out_i2c_bit
argument_list|(
name|hw
argument_list|,
name|nack
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|e1000_i2c_stop
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
name|fail
label|:
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|e1000_i2c_bus_clear
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
if|if
condition|(
name|retry
operator|<
name|max_retry
condition|)
name|DEBUGOUT
argument_list|(
literal|"I2C byte read error - Retrying.\n"
argument_list|)
expr_stmt|;
else|else
name|DEBUGOUT
argument_list|(
literal|"I2C byte read error.\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|retry
operator|<
name|max_retry
condition|)
do|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|read_byte_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_i2c_byte_generic - Writes 8 bit word over I2C  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset to write  *  @dev_addr: device address  *  @data: value to write  *  *  Performs byte write operation over I2C interface at  *  a specified device address.  **/
end_comment

begin_function
name|s32
name|e1000_write_i2c_byte_generic
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|max_retry
init|=
literal|1
decl_stmt|;
name|u32
name|retry
init|=
literal|0
decl_stmt|;
name|u16
name|swfw_mask
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_i2c_byte_generic"
argument_list|)
expr_stmt|;
name|swfw_mask
operator|=
name|E1000_SWFW_PHY0_SM
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
operator|!=
name|E1000_SUCCESS
condition|)
block|{
name|status
operator|=
name|E1000_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|write_byte_out
goto|;
block|}
do|do
block|{
name|e1000_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|e1000_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|dev_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|e1000_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|e1000_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|byte_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|e1000_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|e1000_clock_out_i2c_byte
argument_list|(
name|hw
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|e1000_get_i2c_ack
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|e1000_i2c_stop
argument_list|(
name|hw
argument_list|)
expr_stmt|;
break|break;
name|fail
label|:
name|e1000_i2c_bus_clear
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
if|if
condition|(
name|retry
operator|<
name|max_retry
condition|)
name|DEBUGOUT
argument_list|(
literal|"I2C byte write error - Retrying.\n"
argument_list|)
expr_stmt|;
else|else
name|DEBUGOUT
argument_list|(
literal|"I2C byte write error.\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|retry
operator|<
name|max_retry
condition|)
do|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|swfw_mask
argument_list|)
expr_stmt|;
name|write_byte_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_i2c_start - Sets I2C start condition  *  @hw: pointer to hardware structure  *  *  Sets I2C start condition (High -> Low on SDA while SCL is High)  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_i2c_start
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i2cctl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_i2c_start"
argument_list|)
expr_stmt|;
comment|/* Start condition must begin with data and clock high */
name|e1000_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|e1000_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Setup time for start condition (4.7us) */
name|usec_delay
argument_list|(
name|E1000_I2C_T_SU_STA
argument_list|)
expr_stmt|;
name|e1000_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Hold time for start condition (4us) */
name|usec_delay
argument_list|(
name|E1000_I2C_T_HD_STA
argument_list|)
expr_stmt|;
name|e1000_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum low period of clock is 4.7 us */
name|usec_delay
argument_list|(
name|E1000_I2C_T_LOW
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_i2c_stop - Sets I2C stop condition  *  @hw: pointer to hardware structure  *  *  Sets I2C stop condition (Low -> High on SDA while SCL is High)  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_i2c_stop
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i2cctl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_i2c_stop"
argument_list|)
expr_stmt|;
comment|/* Stop condition must begin with data low and clock high */
name|e1000_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e1000_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Setup time for stop condition (4us) */
name|usec_delay
argument_list|(
name|E1000_I2C_T_SU_STO
argument_list|)
expr_stmt|;
name|e1000_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* bus free time between stop and start (4.7us)*/
name|usec_delay
argument_list|(
name|E1000_I2C_T_BUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_clock_in_i2c_byte - Clocks in one byte via I2C  *  @hw: pointer to hardware structure  *  @data: data byte to clock in  *  *  Clocks in one byte data via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_clock_in_i2c_byte
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|i
decl_stmt|;
name|bool
name|bit
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clock_in_i2c_byte"
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|e1000_clock_in_i2c_bit
argument_list|(
name|hw
argument_list|,
operator|&
name|bit
argument_list|)
expr_stmt|;
operator|*
name|data
operator||=
name|bit
operator|<<
name|i
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_clock_out_i2c_byte - Clocks out one byte via I2C  *  @hw: pointer to hardware structure  *  @data: data byte clocked out  *  *  Clocks out one byte data via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_clock_out_i2c_byte
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|E1000_SUCCESS
decl_stmt|;
name|s32
name|i
decl_stmt|;
name|u32
name|i2cctl
decl_stmt|;
name|bool
name|bit
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clock_out_i2c_byte"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|bit
operator|=
operator|(
name|data
operator|>>
name|i
operator|)
operator|&
literal|0x1
expr_stmt|;
name|status
operator|=
name|e1000_clock_out_i2c_bit
argument_list|(
name|hw
argument_list|,
name|bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
break|break;
block|}
comment|/* Release SDA line (set high) */
name|i2cctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|)
expr_stmt|;
name|i2cctl
operator||=
name|E1000_I2C_DATA_OE_N
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|,
name|i2cctl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_i2c_ack - Polls for I2C ACK  *  @hw: pointer to hardware structure  *  *  Clocks in/out one bit via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_i2c_ack
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|i
init|=
literal|0
decl_stmt|;
name|u32
name|i2cctl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|)
decl_stmt|;
name|u32
name|timeout
init|=
literal|10
decl_stmt|;
name|bool
name|ack
init|=
name|TRUE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_i2c_ack"
argument_list|)
expr_stmt|;
name|e1000_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum high period of clock is 4us */
name|usec_delay
argument_list|(
name|E1000_I2C_T_HIGH
argument_list|)
expr_stmt|;
comment|/* Wait until SCL returns high */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|i2cctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|i2cctl
operator|&
name|E1000_I2C_CLK_IN
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|i2cctl
operator|&
name|E1000_I2C_CLK_IN
operator|)
condition|)
return|return
name|E1000_ERR_I2C
return|;
name|ack
operator|=
name|e1000_get_i2c_data
argument_list|(
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"I2C ack was not received.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_ERR_I2C
expr_stmt|;
block|}
name|e1000_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum low period of clock is 4.7 us */
name|usec_delay
argument_list|(
name|E1000_I2C_T_LOW
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_clock_in_i2c_bit - Clocks in one bit via I2C data/clock  *  @hw: pointer to hardware structure  *  @data: read data value  *  *  Clocks in one bit via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_clock_in_i2c_bit
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
modifier|*
name|data
parameter_list|)
block|{
name|u32
name|i2cctl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clock_in_i2c_bit"
argument_list|)
expr_stmt|;
name|e1000_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum high period of clock is 4us */
name|usec_delay
argument_list|(
name|E1000_I2C_T_HIGH
argument_list|)
expr_stmt|;
name|i2cctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|e1000_get_i2c_data
argument_list|(
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
name|e1000_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum low period of clock is 4.7 us */
name|usec_delay
argument_list|(
name|E1000_I2C_T_LOW
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_clock_out_i2c_bit - Clocks in/out one bit via I2C data/clock  *  @hw: pointer to hardware structure  *  @data: data value to write  *  *  Clocks out one bit via I2C data/clock  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_clock_out_i2c_bit
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|data
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|u32
name|i2cctl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_clock_out_i2c_bit"
argument_list|)
expr_stmt|;
name|status
operator|=
name|e1000_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|E1000_SUCCESS
condition|)
block|{
name|e1000_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum high period of clock is 4us */
name|usec_delay
argument_list|(
name|E1000_I2C_T_HIGH
argument_list|)
expr_stmt|;
name|e1000_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Minimum low period of clock is 4.7 us. 		 * This also takes care of the data hold time. 		 */
name|usec_delay
argument_list|(
name|E1000_I2C_T_LOW
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|E1000_ERR_I2C
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"I2C data was not set to %X\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_raise_i2c_clk - Raises the I2C SCL clock  *  @hw: pointer to hardware structure  *  @i2cctl: Current value of I2CCTL register  *  *  Raises the I2C clock line '0'->'1'  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_raise_i2c_clk
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_raise_i2c_clk"
argument_list|)
expr_stmt|;
operator|*
name|i2cctl
operator||=
name|E1000_I2C_CLK_OUT
expr_stmt|;
operator|*
name|i2cctl
operator|&=
operator|~
name|E1000_I2C_CLK_OE_N
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|,
operator|*
name|i2cctl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* SCL rise time (1000ns) */
name|usec_delay
argument_list|(
name|E1000_I2C_T_RISE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_lower_i2c_clk - Lowers the I2C SCL clock  *  @hw: pointer to hardware structure  *  @i2cctl: Current value of I2CCTL register  *  *  Lowers the I2C clock line '1'->'0'  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_lower_i2c_clk
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_lower_i2c_clk"
argument_list|)
expr_stmt|;
operator|*
name|i2cctl
operator|&=
operator|~
name|E1000_I2C_CLK_OUT
expr_stmt|;
operator|*
name|i2cctl
operator|&=
operator|~
name|E1000_I2C_CLK_OE_N
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|,
operator|*
name|i2cctl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* SCL fall time (300ns) */
name|usec_delay
argument_list|(
name|E1000_I2C_T_FALL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_set_i2c_data - Sets the I2C data bit  *  @hw: pointer to hardware structure  *  @i2cctl: Current value of I2CCTL register  *  @data: I2C data value (0 or 1) to set  *  *  Sets the I2C data bit  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_set_i2c_data
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|i2cctl
parameter_list|,
name|bool
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_set_i2c_data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
operator|*
name|i2cctl
operator||=
name|E1000_I2C_DATA_OUT
expr_stmt|;
else|else
operator|*
name|i2cctl
operator|&=
operator|~
name|E1000_I2C_DATA_OUT
expr_stmt|;
operator|*
name|i2cctl
operator|&=
operator|~
name|E1000_I2C_DATA_OE_N
expr_stmt|;
operator|*
name|i2cctl
operator||=
name|E1000_I2C_CLK_OE_N
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|,
operator|*
name|i2cctl
argument_list|)
expr_stmt|;
name|E1000_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Data rise/fall (1000ns/300ns) and set-up time (250ns) */
name|usec_delay
argument_list|(
name|E1000_I2C_T_RISE
operator|+
name|E1000_I2C_T_FALL
operator|+
name|E1000_I2C_T_SU_DATA
argument_list|)
expr_stmt|;
operator|*
name|i2cctl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|e1000_get_i2c_data
argument_list|(
name|i2cctl
argument_list|)
condition|)
block|{
name|status
operator|=
name|E1000_ERR_I2C
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Error - I2C data was not set to %X.\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_i2c_data - Reads the I2C SDA data bit  *  @hw: pointer to hardware structure  *  @i2cctl: Current value of I2CCTL register  *  *  Returns the I2C data bit value  **/
end_comment

begin_function
specifier|static
name|bool
name|e1000_get_i2c_data
parameter_list|(
name|u32
modifier|*
name|i2cctl
parameter_list|)
block|{
name|bool
name|data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_i2c_data"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|i2cctl
operator|&
name|E1000_I2C_DATA_IN
condition|)
name|data
operator|=
literal|1
expr_stmt|;
else|else
name|data
operator|=
literal|0
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_i2c_bus_clear - Clears the I2C bus  *  @hw: pointer to hardware structure  *  *  Clears the I2C bus by sending nine clock pulses.  *  Used when data line is stuck low.  **/
end_comment

begin_function
name|void
name|e1000_i2c_bus_clear
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|i2cctl
init|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_I2CPARAMS
argument_list|)
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_i2c_bus_clear"
argument_list|)
expr_stmt|;
name|e1000_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|e1000_set_i2c_data
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
name|e1000_raise_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Min high period of clock is 4us */
name|usec_delay
argument_list|(
name|E1000_I2C_T_HIGH
argument_list|)
expr_stmt|;
name|e1000_lower_i2c_clk
argument_list|(
name|hw
argument_list|,
operator|&
name|i2cctl
argument_list|)
expr_stmt|;
comment|/* Min low period of clock is 4.7us*/
name|usec_delay
argument_list|(
name|E1000_I2C_T_LOW
argument_list|)
expr_stmt|;
block|}
name|e1000_i2c_start
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Put the i2c bus back to default state */
name|e1000_i2c_stop
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

