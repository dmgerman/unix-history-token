begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2014, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"e1000_api.h"
end_include

begin_function_decl
specifier|static
name|s32
name|e1000_acquire_nvm_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_release_nvm_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_hw_semaphore_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_write_nvm_srwr
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_pool_flash_update_done_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_valid_led_default_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  e1000_acquire_nvm_i210 - Request for access to EEPROM  *  @hw: pointer to the HW structure  *  *  Acquire the necessary semaphores for exclusive access to the EEPROM.  *  Set the EEPROM access request bit and wait for EEPROM access grant bit.  *  Return successful if access grant bit set, else clear the request for  *  EEPROM access and return -E1000_ERR_NVM (-1).  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_acquire_nvm_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_nvm_i210"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_acquire_swfw_sync_i210
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_nvm_i210 - Release exclusive access to EEPROM  *  @hw: pointer to the HW structure  *  *  Stop any current commands to the EEPROM and clear the EEPROM request bit,  *  then release the semaphores acquired.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_release_nvm_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_nvm_i210"
argument_list|)
expr_stmt|;
name|e1000_release_swfw_sync_i210
argument_list|(
name|hw
argument_list|,
name|E1000_SWFW_EEP_SM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_swfw_sync_i210 - Acquire SW/FW semaphore  *  @hw: pointer to the HW structure  *  @mask: specifies which semaphore to acquire  *  *  Acquire the SW/FW semaphore to access the PHY or NVM.  The mask  *  will also specify which port we're acquiring the lock for.  **/
end_comment

begin_function
name|s32
name|e1000_acquire_swfw_sync_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
block|{
name|u32
name|swfw_sync
decl_stmt|;
name|u32
name|swmask
init|=
name|mask
decl_stmt|;
name|u32
name|fwmask
init|=
name|mask
operator|<<
literal|16
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|s32
name|i
init|=
literal|0
decl_stmt|,
name|timeout
init|=
literal|200
decl_stmt|;
comment|/* FIXME: find real value to use here */
name|DEBUGFUNC
argument_list|(
literal|"e1000_acquire_swfw_sync_i210"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|timeout
condition|)
block|{
if|if
condition|(
name|e1000_get_hw_semaphore_i210
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|swfw_sync
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swfw_sync
operator|&
operator|(
name|fwmask
operator||
name|swmask
operator|)
operator|)
condition|)
break|break;
comment|/* 		 * Firmware currently using resource (fwmask) 		 * or other software thread using resource (swmask) 		 */
name|e1000_put_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|msec_delay_irq
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access resource, SW_FW_SYNC timeout.\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_SWFW_SYNC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|swfw_sync
operator||=
name|swmask
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|,
name|swfw_sync
argument_list|)
expr_stmt|;
name|e1000_put_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_swfw_sync_i210 - Release SW/FW semaphore  *  @hw: pointer to the HW structure  *  @mask: specifies which semaphore to acquire  *  *  Release the SW/FW semaphore used to access the PHY or NVM.  The mask  *  will also specify which port we're releasing the lock for.  **/
end_comment

begin_function
name|void
name|e1000_release_swfw_sync_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|mask
parameter_list|)
block|{
name|u32
name|swfw_sync
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_release_swfw_sync_i210"
argument_list|)
expr_stmt|;
while|while
condition|(
name|e1000_get_hw_semaphore_i210
argument_list|(
name|hw
argument_list|)
operator|!=
name|E1000_SUCCESS
condition|)
empty_stmt|;
comment|/* Empty */
name|swfw_sync
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|)
expr_stmt|;
name|swfw_sync
operator|&=
operator|~
name|mask
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SW_FW_SYNC
argument_list|,
name|swfw_sync
argument_list|)
expr_stmt|;
name|e1000_put_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_hw_semaphore_i210 - Acquire hardware semaphore  *  @hw: pointer to the HW structure  *  *  Acquire the HW semaphore to access the PHY or NVM  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_hw_semaphore_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|swsm
decl_stmt|;
name|s32
name|timeout
init|=
name|hw
operator|->
name|nvm
operator|.
name|word_size
operator|+
literal|1
decl_stmt|;
name|s32
name|i
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_hw_semaphore_i210"
argument_list|)
expr_stmt|;
comment|/* Get the SW semaphore */
while|while
condition|(
name|i
operator|<
name|timeout
condition|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swsm
operator|&
name|E1000_SWSM_SMBI
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|timeout
condition|)
block|{
comment|/* In rare circumstances, the SW semaphore may already be held 		 * unintentionally. Clear the semaphore once before giving up. 		 */
if|if
condition|(
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
operator|.
name|clear_semaphore_once
condition|)
block|{
name|hw
operator|->
name|dev_spec
operator|.
name|_82575
operator|.
name|clear_semaphore_once
operator|=
name|FALSE
expr_stmt|;
name|e1000_put_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|swsm
operator|&
name|E1000_SWSM_SMBI
operator|)
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we do not have the semaphore here, we have to give up. */
if|if
condition|(
name|i
operator|==
name|timeout
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Driver can't access device - SMBI bit is set.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
block|}
comment|/* Get the FW semaphore. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
name|swsm
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|,
name|swsm
operator||
name|E1000_SWSM_SWESMBI
argument_list|)
expr_stmt|;
comment|/* Semaphore acquired if bit latched */
if|if
condition|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SWSM
argument_list|)
operator|&
name|E1000_SWSM_SWESMBI
condition|)
break|break;
name|usec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|timeout
condition|)
block|{
comment|/* Release semaphores */
name|e1000_put_hw_semaphore_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Driver can't access the NVM\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|E1000_ERR_NVM
return|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_nvm_srrd_i210 - Reads Shadow Ram using EERD register  *  @hw: pointer to the HW structure  *  @offset: offset of word in the Shadow Ram to read  *  @words: number of words to read  *  @data: word read from the Shadow Ram  *  *  Reads a 16 bit word from the Shadow Ram using the EERD register.  *  Uses necessary synchronization semaphores.  **/
end_comment

begin_function
name|s32
name|e1000_read_nvm_srrd_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|count
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_nvm_srrd_i210"
argument_list|)
expr_stmt|;
comment|/* We cannot hold synchronization semaphores for too long, 	 * because of forceful takeover procedure. However it is more efficient 	 * to read in bursts than synchronizing access for each word. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|+=
name|E1000_EERD_EEWR_MAX_COUNT
control|)
block|{
name|count
operator|=
operator|(
name|words
operator|-
name|i
operator|)
operator|/
name|E1000_EERD_EEWR_MAX_COUNT
operator|>
literal|0
condition|?
name|E1000_EERD_EEWR_MAX_COUNT
else|:
operator|(
name|words
operator|-
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
operator|==
name|E1000_SUCCESS
condition|)
block|{
name|status
operator|=
name|e1000_read_nvm_eerd
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|data
operator|+
name|i
argument_list|)
expr_stmt|;
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|E1000_ERR_SWFW_SYNC
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
break|break;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_nvm_srwr_i210 - Write to Shadow RAM using EEWR  *  @hw: pointer to the HW structure  *  @offset: offset within the Shadow RAM to be written to  *  @words: number of words to write  *  @data: 16 bit word(s) to be written to the Shadow RAM  *  *  Writes data to Shadow RAM at offset using EEWR register.  *  *  If e1000_update_nvm_checksum is not called after this function , the  *  data will not be committed to FLASH and also Shadow RAM will most likely  *  contain an invalid checksum.  *  *  If error code is returned, data and Shadow RAM may be inconsistent - buffer  *  partially written.  **/
end_comment

begin_function
name|s32
name|e1000_write_nvm_srwr_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|count
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_nvm_srwr_i210"
argument_list|)
expr_stmt|;
comment|/* We cannot hold synchronization semaphores for too long, 	 * because of forceful takeover procedure. However it is more efficient 	 * to write in bursts than synchronizing access for each word. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|+=
name|E1000_EERD_EEWR_MAX_COUNT
control|)
block|{
name|count
operator|=
operator|(
name|words
operator|-
name|i
operator|)
operator|/
name|E1000_EERD_EEWR_MAX_COUNT
operator|>
literal|0
condition|?
name|E1000_EERD_EEWR_MAX_COUNT
else|:
operator|(
name|words
operator|-
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
operator|==
name|E1000_SUCCESS
condition|)
block|{
name|status
operator|=
name|e1000_write_nvm_srwr
argument_list|(
name|hw
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|data
operator|+
name|i
argument_list|)
expr_stmt|;
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|E1000_ERR_SWFW_SYNC
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
break|break;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_nvm_srwr - Write to Shadow Ram using EEWR  *  @hw: pointer to the HW structure  *  @offset: offset within the Shadow Ram to be written to  *  @words: number of words to write  *  @data: 16 bit word(s) to be written to the Shadow Ram  *  *  Writes data to Shadow Ram at offset using EEWR register.  *  *  If e1000_update_nvm_checksum is not called after this function , the  *  Shadow Ram will most likely contain an invalid checksum.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_write_nvm_srwr
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|k
decl_stmt|,
name|eewr
init|=
literal|0
decl_stmt|;
name|u32
name|attempts
init|=
literal|100000
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_write_nvm_srwr"
argument_list|)
expr_stmt|;
comment|/* 	 * A check for invalid values:  offset too large, too many words, 	 * too many words for the offset, and not enough words. 	 */
if|if
condition|(
operator|(
name|offset
operator|>=
name|nvm
operator|->
name|word_size
operator|)
operator|||
operator|(
name|words
operator|>
operator|(
name|nvm
operator|->
name|word_size
operator|-
name|offset
operator|)
operator|)
operator|||
operator|(
name|words
operator|==
literal|0
operator|)
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"nvm parameter(s) out of bounds\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|E1000_ERR_NVM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|eewr
operator|=
operator|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|<<
name|E1000_NVM_RW_ADDR_SHIFT
operator|)
operator||
operator|(
name|data
index|[
name|i
index|]
operator|<<
name|E1000_NVM_RW_REG_DATA
operator|)
operator||
name|E1000_NVM_RW_REG_START
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SRWR
argument_list|,
name|eewr
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|attempts
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|E1000_NVM_RW_REG_DONE
operator|&
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_SRWR
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Shadow RAM write EEWR timed out\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/** e1000_read_invm_word_i210 - Reads OTP  *  @hw: pointer to the HW structure  *  @address: the word address (aka eeprom offset) to read  *  @data: pointer to the data read  *  *  Reads 16-bit words from the OTP. Return error when the word is not  *  stored in OTP.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_invm_word_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|address
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|status
init|=
operator|-
name|E1000_ERR_INVM_VALUE_NOT_FOUND
decl_stmt|;
name|u32
name|invm_dword
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|u8
name|record_type
decl_stmt|,
name|word_address
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_invm_word_i210"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_INVM_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|invm_dword
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_INVM_DATA_REG
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get record type */
name|record_type
operator|=
name|INVM_DWORD_TO_RECORD_TYPE
argument_list|(
name|invm_dword
argument_list|)
expr_stmt|;
if|if
condition|(
name|record_type
operator|==
name|E1000_INVM_UNINITIALIZED_STRUCTURE
condition|)
break|break;
if|if
condition|(
name|record_type
operator|==
name|E1000_INVM_CSR_AUTOLOAD_STRUCTURE
condition|)
name|i
operator|+=
name|E1000_INVM_CSR_AUTOLOAD_DATA_SIZE_IN_DWORDS
expr_stmt|;
if|if
condition|(
name|record_type
operator|==
name|E1000_INVM_RSA_KEY_SHA256_STRUCTURE
condition|)
name|i
operator|+=
name|E1000_INVM_RSA_KEY_SHA256_DATA_SIZE_IN_DWORDS
expr_stmt|;
if|if
condition|(
name|record_type
operator|==
name|E1000_INVM_WORD_AUTOLOAD_STRUCTURE
condition|)
block|{
name|word_address
operator|=
name|INVM_DWORD_TO_WORD_ADDRESS
argument_list|(
name|invm_dword
argument_list|)
expr_stmt|;
if|if
condition|(
name|word_address
operator|==
name|address
condition|)
block|{
operator|*
name|data
operator|=
name|INVM_DWORD_TO_WORD_DATA
argument_list|(
name|invm_dword
argument_list|)
expr_stmt|;
name|DEBUGOUT2
argument_list|(
literal|"Read INVM Word 0x%02x = %x"
argument_list|,
name|address
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_SUCCESS
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|E1000_SUCCESS
condition|)
name|DEBUGOUT1
argument_list|(
literal|"Requested word 0x%02x not found in OTP\n"
argument_list|,
name|address
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/** e1000_read_invm_i210 - Read invm wrapper function for I210/I211  *  @hw: pointer to the HW structure  *  @address: the word address (aka eeprom offset) to read  *  @data: pointer to the data read  *  *  Wrapper function to return data formerly found in the NVM.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_invm_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|offset
parameter_list|,
name|u16
name|E1000_UNUSEDARG
name|words
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_invm_i210"
argument_list|)
expr_stmt|;
comment|/* Only the MAC addr is required to be present in the iNVM */
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|NVM_MAC_ADDR
case|:
name|ret_val
operator|=
name|e1000_read_invm_word_i210
argument_list|(
name|hw
argument_list|,
operator|(
name|u8
operator|)
name|offset
argument_list|,
operator|&
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ret_val
operator||=
name|e1000_read_invm_word_i210
argument_list|(
name|hw
argument_list|,
operator|(
name|u8
operator|)
name|offset
operator|+
literal|1
argument_list|,
operator|&
name|data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ret_val
operator||=
name|e1000_read_invm_word_i210
argument_list|(
name|hw
argument_list|,
operator|(
name|u8
operator|)
name|offset
operator|+
literal|2
argument_list|,
operator|&
name|data
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
name|DEBUGOUT
argument_list|(
literal|"MAC Addr not found in iNVM\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NVM_INIT_CTRL_2
case|:
name|ret_val
operator|=
name|e1000_read_invm_word_i210
argument_list|(
name|hw
argument_list|,
operator|(
name|u8
operator|)
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
block|{
operator|*
name|data
operator|=
name|NVM_INIT_CTRL_2_DEFAULT_I211
expr_stmt|;
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|NVM_INIT_CTRL_4
case|:
name|ret_val
operator|=
name|e1000_read_invm_word_i210
argument_list|(
name|hw
argument_list|,
operator|(
name|u8
operator|)
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
block|{
operator|*
name|data
operator|=
name|NVM_INIT_CTRL_4_DEFAULT_I211
expr_stmt|;
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|NVM_LED_1_CFG
case|:
name|ret_val
operator|=
name|e1000_read_invm_word_i210
argument_list|(
name|hw
argument_list|,
operator|(
name|u8
operator|)
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
block|{
operator|*
name|data
operator|=
name|NVM_LED_1_CFG_DEFAULT_I211
expr_stmt|;
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|NVM_LED_0_2_CFG
case|:
name|ret_val
operator|=
name|e1000_read_invm_word_i210
argument_list|(
name|hw
argument_list|,
operator|(
name|u8
operator|)
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
block|{
operator|*
name|data
operator|=
name|NVM_LED_0_2_CFG_DEFAULT_I211
expr_stmt|;
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|NVM_ID_LED_SETTINGS
case|:
name|ret_val
operator|=
name|e1000_read_invm_word_i210
argument_list|(
name|hw
argument_list|,
operator|(
name|u8
operator|)
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
block|{
operator|*
name|data
operator|=
name|ID_LED_RESERVED_FFFF
expr_stmt|;
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|NVM_SUB_DEV_ID
case|:
operator|*
name|data
operator|=
name|hw
operator|->
name|subsystem_device_id
expr_stmt|;
break|break;
case|case
name|NVM_SUB_VEN_ID
case|:
operator|*
name|data
operator|=
name|hw
operator|->
name|subsystem_vendor_id
expr_stmt|;
break|break;
case|case
name|NVM_DEV_ID
case|:
operator|*
name|data
operator|=
name|hw
operator|->
name|device_id
expr_stmt|;
break|break;
case|case
name|NVM_VEN_ID
case|:
operator|*
name|data
operator|=
name|hw
operator|->
name|vendor_id
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT1
argument_list|(
literal|"NVM word 0x%02x is not mapped.\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|NVM_RESERVED_WORD
expr_stmt|;
break|break;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_validate_nvm_checksum_i210 - Validate EEPROM checksum  *  @hw: pointer to the HW structure  *  *  Calculates the EEPROM checksum by reading/adding each word of the EEPROM  *  and then verifies that the sum of the EEPROM is equal to 0xBABA.  **/
end_comment

begin_function
name|s32
name|e1000_validate_nvm_checksum_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|E1000_SUCCESS
decl_stmt|;
name|s32
function_decl|(
modifier|*
name|read_op_ptr
function_decl|)
parameter_list|(
name|struct
name|e1000_hw
modifier|*
parameter_list|,
name|u16
parameter_list|,
name|u16
parameter_list|,
name|u16
modifier|*
parameter_list|)
function_decl|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_validate_nvm_checksum_i210"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
operator|==
name|E1000_SUCCESS
condition|)
block|{
comment|/* 		 * Replace the read function with semaphore grabbing with 		 * the one that skips this for a while. 		 * We have semaphore taken already here. 		 */
name|read_op_ptr
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
expr_stmt|;
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
operator|=
name|e1000_read_nvm_eerd
expr_stmt|;
name|status
operator|=
name|e1000_validate_nvm_checksum_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Revert original read operation. */
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
operator|=
name|read_op_ptr
expr_stmt|;
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|E1000_ERR_SWFW_SYNC
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_nvm_checksum_i210 - Update EEPROM checksum  *  @hw: pointer to the HW structure  *  *  Updates the EEPROM checksum by reading/adding each word of the EEPROM  *  up to the checksum.  Then calculates the EEPROM checksum and writes the  *  value to the EEPROM. Next commit EEPROM data onto the Flash.  **/
end_comment

begin_function
name|s32
name|e1000_update_nvm_checksum_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u16
name|checksum
init|=
literal|0
decl_stmt|;
name|u16
name|i
decl_stmt|,
name|nvm_data
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_nvm_checksum_i210"
argument_list|)
expr_stmt|;
comment|/* 	 * Read the first word from the EEPROM. If this times out or fails, do 	 * not continue or we could be in for a very long wait while every 	 * EEPROM read fails 	 */
name|ret_val
operator|=
name|e1000_read_nvm_eerd
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|acquire
argument_list|(
name|hw
argument_list|)
operator|==
name|E1000_SUCCESS
condition|)
block|{
comment|/* 		 * Do not use hw->nvm.ops.write, hw->nvm.ops.read 		 * because we do not want to take the synchronization 		 * semaphores twice here. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVM_CHECKSUM_REG
condition|;
name|i
operator|++
control|)
block|{
name|ret_val
operator|=
name|e1000_read_nvm_eerd
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|nvm_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error while updating checksum.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|checksum
operator|+=
name|nvm_data
expr_stmt|;
block|}
name|checksum
operator|=
operator|(
name|u16
operator|)
name|NVM_SUM
operator|-
name|checksum
expr_stmt|;
name|ret_val
operator|=
name|e1000_write_nvm_srwr
argument_list|(
name|hw
argument_list|,
name|NVM_CHECKSUM_REG
argument_list|,
literal|1
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
block|{
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"NVM Write Error while updating checksum.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|release
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_update_flash_i210
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|E1000_ERR_SWFW_SYNC
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_flash_presence_i210 - Check if flash device is detected.  *  @hw: pointer to the HW structure  *  **/
end_comment

begin_function
name|bool
name|e1000_get_flash_presence_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|eec
init|=
literal|0
decl_stmt|;
name|bool
name|ret_val
init|=
name|FALSE
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_flash_presence_i210"
argument_list|)
expr_stmt|;
name|eec
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eec
operator|&
name|E1000_EECD_FLASH_DETECTED_I210
condition|)
name|ret_val
operator|=
name|TRUE
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_flash_i210 - Commit EEPROM to the flash  *  @hw: pointer to the HW structure  *  **/
end_comment

begin_function
name|s32
name|e1000_update_flash_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u32
name|flup
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_flash_i210"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_pool_flash_update_done_i210
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
operator|-
name|E1000_ERR_NVM
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Flash update time out\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|flup
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
operator||
name|E1000_EECD_FLUPD_I210
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|,
name|flup
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_pool_flash_update_done_i210
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|==
name|E1000_SUCCESS
condition|)
name|DEBUGOUT
argument_list|(
literal|"Flash update complete\n"
argument_list|)
expr_stmt|;
else|else
name|DEBUGOUT
argument_list|(
literal|"Flash update time out\n"
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_pool_flash_update_done_i210 - Pool FLUDONE status.  *  @hw: pointer to the HW structure  *  **/
end_comment

begin_function
name|s32
name|e1000_pool_flash_update_done_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_NVM
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_pool_flash_update_done_i210"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_FLUDONE_ATTEMPTS
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EECD
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|E1000_EECD_FLUDONE_I210
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
break|break;
block|}
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_nvm_params_i210 - Initialize i210 NVM function pointers  *  @hw: pointer to the HW structure  *  *  Initialize the i210/i211 NVM parameters and function pointers.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_nvm_params_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|struct
name|e1000_nvm_info
modifier|*
name|nvm
init|=
operator|&
name|hw
operator|->
name|nvm
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_nvm_params_i210"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|e1000_init_nvm_params_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|acquire
operator|=
name|e1000_acquire_nvm_i210
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|release
operator|=
name|e1000_release_nvm_i210
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|valid_led_default
operator|=
name|e1000_valid_led_default_i210
expr_stmt|;
if|if
condition|(
name|e1000_get_flash_presence_i210
argument_list|(
name|hw
argument_list|)
condition|)
block|{
name|hw
operator|->
name|nvm
operator|.
name|type
operator|=
name|e1000_nvm_flash_hw
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|read
operator|=
name|e1000_read_nvm_srrd_i210
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|write
operator|=
name|e1000_write_nvm_srwr_i210
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|validate
operator|=
name|e1000_validate_nvm_checksum_i210
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|update
operator|=
name|e1000_update_nvm_checksum_i210
expr_stmt|;
block|}
else|else
block|{
name|hw
operator|->
name|nvm
operator|.
name|type
operator|=
name|e1000_nvm_invm
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|read
operator|=
name|e1000_read_invm_i210
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|write
operator|=
name|e1000_null_write_nvm
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|validate
operator|=
name|e1000_null_ops_generic
expr_stmt|;
name|nvm
operator|->
name|ops
operator|.
name|update
operator|=
name|e1000_null_ops_generic
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_function_pointers_i210 - Init func ptrs.  *  @hw: pointer to the HW structure  *  *  Called to initialize all function pointers and parameters.  **/
end_comment

begin_function
name|void
name|e1000_init_function_pointers_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|e1000_init_function_pointers_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_nvm_params_i210
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_valid_led_default_i210 - Verify a valid default LED config  *  @hw: pointer to the HW structure  *  @data: pointer to the NVM (EEPROM)  *  *  Read the EEPROM for the current default LED configuration.  If the  *  LED configuration is not valid, set to a valid LED configuration.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_valid_led_default_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_valid_led_default_i210"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|NVM_ID_LED_SETTINGS
argument_list|,
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"NVM Read Error\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|*
name|data
operator|==
name|ID_LED_RESERVED_0000
operator|||
operator|*
name|data
operator|==
name|ID_LED_RESERVED_FFFF
condition|)
block|{
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|media_type
condition|)
block|{
case|case
name|e1000_media_type_internal_serdes
case|:
operator|*
name|data
operator|=
name|ID_LED_DEFAULT_I210_SERDES
expr_stmt|;
break|break;
case|case
name|e1000_media_type_copper
case|:
default|default:
operator|*
name|data
operator|=
name|ID_LED_DEFAULT_I210
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  __e1000_access_xmdio_reg - Read/write XMDIO register  *  @hw: pointer to the HW structure  *  @address: XMDIO address to program  *  @dev_addr: device address to program  *  @data: pointer to value to read/write from/to the XMDIO address  *  @read: boolean flag to indicate read or write  **/
end_comment

begin_function
specifier|static
name|s32
name|__e1000_access_xmdio_reg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|address
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|,
name|bool
name|read
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"__e1000_access_xmdio_reg"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_MMDAC
argument_list|,
name|dev_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_MMDAAD
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_MMDAC
argument_list|,
name|E1000_MMDAC_FUNC_DATA
operator||
name|dev_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
if|if
condition|(
name|read
condition|)
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|E1000_MMDAAD
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_MMDAAD
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Recalibrate the device back to 0 */
name|ret_val
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg
argument_list|(
name|hw
argument_list|,
name|E1000_MMDAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_xmdio_reg - Read XMDIO register  *  @hw: pointer to the HW structure  *  @addr: XMDIO address to program  *  @dev_addr: device address to program  *  @data: value to be read from the EMI address  **/
end_comment

begin_function
name|s32
name|e1000_read_xmdio_reg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|addr
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u16
modifier|*
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_xmdio_reg"
argument_list|)
expr_stmt|;
return|return
name|__e1000_access_xmdio_reg
argument_list|(
name|hw
argument_list|,
name|addr
argument_list|,
name|dev_addr
argument_list|,
name|data
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_write_xmdio_reg - Write XMDIO register  *  @hw: pointer to the HW structure  *  @addr: XMDIO address to program  *  @dev_addr: device address to program  *  @data: value to be written to the XMDIO address  **/
end_comment

begin_function
name|s32
name|e1000_write_xmdio_reg
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|addr
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u16
name|data
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_read_xmdio_reg"
argument_list|)
expr_stmt|;
return|return
name|__e1000_access_xmdio_reg
argument_list|(
name|hw
argument_list|,
name|addr
argument_list|,
name|dev_addr
argument_list|,
operator|&
name|data
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * e1000_pll_workaround_i210  * @hw: pointer to the HW structure  *  * Works around an errata in the PLL circuit where it occasionally  * provides the wrong clock frequency after power up.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_pll_workaround_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|u32
name|wuc
decl_stmt|,
name|mdicnfg
decl_stmt|,
name|ctrl
decl_stmt|,
name|ctrl_ext
decl_stmt|,
name|reg_val
decl_stmt|;
name|u16
name|nvm_word
decl_stmt|,
name|phy_word
decl_stmt|,
name|pci_word
decl_stmt|,
name|tmp_nvm
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get and set needed register values */
name|wuc
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_WUC
argument_list|)
expr_stmt|;
name|mdicnfg
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDICNFG
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|mdicnfg
operator|&
operator|~
name|E1000_MDICNFG_EXT_MDIO
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDICNFG
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* Get data from NVM, or set default */
name|ret_val
operator|=
name|e1000_read_invm_word_i210
argument_list|(
name|hw
argument_list|,
name|E1000_INVM_AUTOLOAD
argument_list|,
operator|&
name|nvm_word
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
name|nvm_word
operator|=
name|E1000_INVM_DEFAULT_AL
expr_stmt|;
name|tmp_nvm
operator|=
name|nvm_word
operator||
name|E1000_INVM_PLL_WO_VAL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|E1000_MAX_PLL_TRIES
condition|;
name|i
operator|++
control|)
block|{
comment|/* check current state directly from internal PHY */
name|e1000_read_phy_reg_gs40g
argument_list|(
name|hw
argument_list|,
operator|(
name|E1000_PHY_PLL_FREQ_PAGE
operator||
name|E1000_PHY_PLL_FREQ_REG
operator|)
argument_list|,
operator|&
name|phy_word
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|phy_word
operator|&
name|E1000_PHY_PLL_UNCONF
operator|)
operator|!=
name|E1000_PHY_PLL_UNCONF
condition|)
block|{
name|ret_val
operator|=
name|E1000_SUCCESS
expr_stmt|;
break|break;
block|}
else|else
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_PHY
expr_stmt|;
block|}
comment|/* directly reset the internal PHY */
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_PHY_RST
argument_list|)
expr_stmt|;
name|ctrl_ext
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|)
expr_stmt|;
name|ctrl_ext
operator||=
operator|(
name|E1000_CTRL_EXT_PHYPDEN
operator||
name|E1000_CTRL_EXT_SDLPE
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL_EXT
argument_list|,
name|ctrl_ext
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_val
operator|=
operator|(
name|E1000_INVM_AUTOLOAD
operator|<<
literal|4
operator|)
operator||
operator|(
name|tmp_nvm
operator|<<
literal|16
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EEARBC_I210
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|e1000_read_pci_cfg
argument_list|(
name|hw
argument_list|,
name|E1000_PCI_PMCSR
argument_list|,
operator|&
name|pci_word
argument_list|)
expr_stmt|;
name|pci_word
operator||=
name|E1000_PCI_PMCSR_D3
expr_stmt|;
name|e1000_write_pci_cfg
argument_list|(
name|hw
argument_list|,
name|E1000_PCI_PMCSR
argument_list|,
operator|&
name|pci_word
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|pci_word
operator|&=
operator|~
name|E1000_PCI_PMCSR_D3
expr_stmt|;
name|e1000_write_pci_cfg
argument_list|(
name|hw
argument_list|,
name|E1000_PCI_PMCSR
argument_list|,
operator|&
name|pci_word
argument_list|)
expr_stmt|;
name|reg_val
operator|=
operator|(
name|E1000_INVM_AUTOLOAD
operator|<<
literal|4
operator|)
operator||
operator|(
name|nvm_word
operator|<<
literal|16
operator|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_EEARBC_I210
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* restore WUC register */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_WUC
argument_list|,
name|wuc
argument_list|)
expr_stmt|;
block|}
comment|/* restore MDICNFG setting */
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_MDICNFG
argument_list|,
name|mdicnfg
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_hw_i210 - Init hw for I210/I211  *  @hw: pointer to the HW structure  *  *  Called to initialize hw for i210 hw family.  **/
end_comment

begin_function
name|s32
name|e1000_init_hw_i210
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_hw_i210"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|mac
operator|.
name|type
operator|>=
name|e1000_i210
operator|)
operator|&&
operator|!
operator|(
name|e1000_get_flash_presence_i210
argument_list|(
name|hw
argument_list|)
operator|)
condition|)
block|{
name|ret_val
operator|=
name|e1000_pll_workaround_i210
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|E1000_SUCCESS
condition|)
return|return
name|ret_val
return|;
block|}
name|ret_val
operator|=
name|e1000_init_hw_82575
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

end_unit

