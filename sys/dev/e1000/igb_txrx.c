begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"if_em.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RSS
end_ifdef

begin_include
include|#
directive|include
file|<net/rss_config.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_rss.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VERBOSE_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
value|device_printf
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*********************************************************************  *  Local Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|igb_isc_txd_encap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_isc_txd_flush
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|txqid
parameter_list|,
name|uint32_t
name|pidx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_isc_txd_credits_update
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|txqid
parameter_list|,
name|uint32_t
name|cidx
parameter_list|,
name|bool
name|clear
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_isc_rxd_refill
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|uint8_t
name|flid
name|__unused
parameter_list|,
name|uint32_t
name|pidx
parameter_list|,
name|uint64_t
modifier|*
name|paddrs
parameter_list|,
name|caddr_t
modifier|*
name|vaddrs
name|__unused
parameter_list|,
name|uint16_t
name|count
parameter_list|,
name|uint16_t
name|buf_len
name|__unused
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_isc_rxd_flush
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|uint8_t
name|flid
name|__unused
parameter_list|,
name|uint32_t
name|pidx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_isc_rxd_available
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|uint32_t
name|idx
parameter_list|,
name|int
name|budget
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_isc_rxd_pkt_get
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_tx_ctx_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|,
name|u32
modifier|*
name|cmd_type_len
parameter_list|,
name|u32
modifier|*
name|olinfo_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_tso_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|,
name|u32
modifier|*
name|cmd_type_len
parameter_list|,
name|u32
modifier|*
name|olinfo_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|igb_rx_checksum
parameter_list|(
name|u32
name|staterr
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|,
name|u32
name|ptype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|igb_determine_rsstype
parameter_list|(
name|u16
name|pkt_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|igb_if_enable_intr
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|em_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|if_txrx
name|igb_txrx
init|=
block|{
name|igb_isc_txd_encap
block|,
name|igb_isc_txd_flush
block|,
name|igb_isc_txd_credits_update
block|,
name|igb_isc_rxd_available
block|,
name|igb_isc_rxd_pkt_get
block|,
name|igb_isc_rxd_refill
block|,
name|igb_isc_rxd_flush
block|,
name|em_intr
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|if_shared_ctx_t
name|em_sctx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**********************************************************************  *  *  Setup work for hardware segmentation offload (TSO) on  *  adapters using advanced tx descriptors  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_tso_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|,
name|u32
modifier|*
name|cmd_type_len
parameter_list|,
name|u32
modifier|*
name|olinfo_status
parameter_list|)
block|{
name|struct
name|e1000_adv_tx_context_desc
modifier|*
name|TXD
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|u32
name|type_tucmd_mlhl
init|=
literal|0
decl_stmt|,
name|vlan_macip_lens
init|=
literal|0
decl_stmt|;
name|u32
name|mss_l4len_idx
init|=
literal|0
decl_stmt|;
name|u32
name|paylen
decl_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|ipi_etype
condition|)
block|{
case|case
name|ETHERTYPE_IPV6
case|:
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_IPV6
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IP
case|:
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_IPV4
expr_stmt|;
comment|/* Tell transmit desc to also do IPv4 checksum. */
operator|*
name|olinfo_status
operator||=
name|E1000_TXD_POPTS_IXSM
operator|<<
literal|8
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: CSUM_TSO but no supported IP version (0x%04x)"
argument_list|,
name|__func__
argument_list|,
name|ntohs
argument_list|(
name|pi
operator|->
name|ipi_etype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|TXD
operator|=
operator|(
expr|struct
name|e1000_adv_tx_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|pi
operator|->
name|ipi_pidx
index|]
expr_stmt|;
comment|/* This is used in the transmit desc in encap */
name|paylen
operator|=
name|pi
operator|->
name|ipi_len
operator|-
name|pi
operator|->
name|ipi_ehdrlen
operator|-
name|pi
operator|->
name|ipi_ip_hlen
operator|-
name|pi
operator|->
name|ipi_tcp_hlen
expr_stmt|;
comment|/* VLAN MACLEN IPLEN */
if|if
condition|(
name|pi
operator|->
name|ipi_mflags
operator|&
name|M_VLANTAG
condition|)
block|{
name|vlan_macip_lens
operator||=
operator|(
name|pi
operator|->
name|ipi_vtag
operator|<<
name|E1000_ADVTXD_VLAN_SHIFT
operator|)
expr_stmt|;
block|}
name|vlan_macip_lens
operator||=
name|pi
operator|->
name|ipi_ehdrlen
operator|<<
name|E1000_ADVTXD_MACLEN_SHIFT
expr_stmt|;
name|vlan_macip_lens
operator||=
name|pi
operator|->
name|ipi_ip_hlen
expr_stmt|;
name|TXD
operator|->
name|vlan_macip_lens
operator|=
name|htole32
argument_list|(
name|vlan_macip_lens
argument_list|)
expr_stmt|;
comment|/* ADV DTYPE TUCMD */
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_DCMD_DEXT
operator||
name|E1000_ADVTXD_DTYP_CTXT
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_L4T_TCP
expr_stmt|;
name|TXD
operator|->
name|type_tucmd_mlhl
operator|=
name|htole32
argument_list|(
name|type_tucmd_mlhl
argument_list|)
expr_stmt|;
comment|/* MSS L4LEN IDX */
name|mss_l4len_idx
operator||=
operator|(
name|pi
operator|->
name|ipi_tso_segsz
operator|<<
name|E1000_ADVTXD_MSS_SHIFT
operator|)
expr_stmt|;
name|mss_l4len_idx
operator||=
operator|(
name|pi
operator|->
name|ipi_tcp_hlen
operator|<<
name|E1000_ADVTXD_L4LEN_SHIFT
operator|)
expr_stmt|;
comment|/* 82575 needs the queue index added */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
name|mss_l4len_idx
operator||=
name|txr
operator|->
name|me
operator|<<
literal|4
expr_stmt|;
name|TXD
operator|->
name|mss_l4len_idx
operator|=
name|htole32
argument_list|(
name|mss_l4len_idx
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|seqnum_seed
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|cmd_type_len
operator||=
name|E1000_ADVTXD_DCMD_TSE
expr_stmt|;
operator|*
name|olinfo_status
operator||=
name|E1000_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
operator|*
name|olinfo_status
operator||=
name|paylen
operator|<<
name|E1000_ADVTXD_PAYLEN_SHIFT
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Advanced Context Descriptor setup for VLAN, CSUM or TSO  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_tx_ctx_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|,
name|u32
modifier|*
name|cmd_type_len
parameter_list|,
name|u32
modifier|*
name|olinfo_status
parameter_list|)
block|{
name|struct
name|e1000_adv_tx_context_desc
modifier|*
name|TXD
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|u32
name|vlan_macip_lens
decl_stmt|,
name|type_tucmd_mlhl
decl_stmt|;
name|u32
name|mss_l4len_idx
decl_stmt|;
name|mss_l4len_idx
operator|=
name|vlan_macip_lens
operator|=
name|type_tucmd_mlhl
operator|=
literal|0
expr_stmt|;
name|int
name|offload
init|=
name|TRUE
decl_stmt|;
comment|/* First check if TSO is to be used */
if|if
condition|(
name|pi
operator|->
name|ipi_csum_flags
operator|&
name|CSUM_TSO
condition|)
return|return
operator|(
name|igb_tso_setup
argument_list|(
name|txr
argument_list|,
name|pi
argument_list|,
name|cmd_type_len
argument_list|,
name|olinfo_status
argument_list|)
operator|)
return|;
comment|/* Indicate the whole packet as payload when not doing TSO */
operator|*
name|olinfo_status
operator||=
name|pi
operator|->
name|ipi_len
operator|<<
name|E1000_ADVTXD_PAYLEN_SHIFT
expr_stmt|;
comment|/* Now ready a context descriptor */
name|TXD
operator|=
operator|(
expr|struct
name|e1000_adv_tx_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|pi
operator|->
name|ipi_pidx
index|]
expr_stmt|;
comment|/* 	** In advanced descriptors the vlan tag must  	** be placed into the context descriptor. Hence 	** we need to make one even if not doing offloads. 	*/
if|if
condition|(
name|pi
operator|->
name|ipi_mflags
operator|&
name|M_VLANTAG
condition|)
block|{
name|vlan_macip_lens
operator||=
operator|(
name|pi
operator|->
name|ipi_vtag
operator|<<
name|E1000_ADVTXD_VLAN_SHIFT
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pi
operator|->
name|ipi_csum_flags
operator|&
name|CSUM_OFFLOAD
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Set the ether header length */
name|vlan_macip_lens
operator||=
name|pi
operator|->
name|ipi_ehdrlen
operator|<<
name|E1000_ADVTXD_MACLEN_SHIFT
expr_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|ipi_etype
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_IPV4
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_IPV6
expr_stmt|;
break|break;
default|default:
name|offload
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|vlan_macip_lens
operator||=
name|pi
operator|->
name|ipi_ip_hlen
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_DCMD_DEXT
operator||
name|E1000_ADVTXD_DTYP_CTXT
expr_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|ipi_ipproto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1000000
if|if
condition|(
name|pi
operator|->
name|ipi_csum_flags
operator|&
operator|(
name|CSUM_IP_TCP
operator||
name|CSUM_IP6_TCP
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|pi
operator|->
name|ipi_csum_flags
operator|&
name|CSUM_TCP
condition|)
endif|#
directive|endif
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_L4T_TCP
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1000000
if|if
condition|(
name|pi
operator|->
name|ipi_csum_flags
operator|&
operator|(
name|CSUM_IP_UDP
operator||
name|CSUM_IP6_UDP
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|pi
operator|->
name|ipi_csum_flags
operator|&
name|CSUM_UDP
condition|)
endif|#
directive|endif
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_L4T_UDP
expr_stmt|;
break|break;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
case|case
name|IPPROTO_SCTP
case|:
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1000000
if|if
condition|(
name|pi
operator|->
name|ipi_csum_flags
operator|&
operator|(
name|CSUM_IP_SCTP
operator||
name|CSUM_IP6_SCTP
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|pi
operator|->
name|ipi_csum_flags
operator|&
name|CSUM_SCTP
condition|)
endif|#
directive|endif
name|type_tucmd_mlhl
operator||=
name|E1000_ADVTXD_TUCMD_L4T_SCTP
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|offload
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|offload
condition|)
comment|/* For the TX descriptor setup */
operator|*
name|olinfo_status
operator||=
name|E1000_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
comment|/* 82575 needs the queue index added */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
name|mss_l4len_idx
operator|=
name|txr
operator|->
name|me
operator|<<
literal|4
expr_stmt|;
comment|/* Now copy bits into descriptor */
name|TXD
operator|->
name|vlan_macip_lens
operator|=
name|htole32
argument_list|(
name|vlan_macip_lens
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|type_tucmd_mlhl
operator|=
name|htole32
argument_list|(
name|type_tucmd_mlhl
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|seqnum_seed
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|mss_l4len_idx
operator|=
name|htole32
argument_list|(
name|mss_l4len_idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|igb_isc_txd_encap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|sc
operator|->
name|shared
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|que
init|=
operator|&
name|sc
operator|->
name|tx_queues
index|[
name|pi
operator|->
name|ipi_qsidx
index|]
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|int
name|nsegs
init|=
name|pi
operator|->
name|ipi_nsegs
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
init|=
name|pi
operator|->
name|ipi_segs
decl_stmt|;
name|struct
name|em_txbuffer
modifier|*
name|txbuf
decl_stmt|;
name|union
name|e1000_adv_tx_desc
modifier|*
name|txd
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|first
decl_stmt|,
name|pidx_last
decl_stmt|;
name|u32
name|olinfo_status
decl_stmt|,
name|cmd_type_len
decl_stmt|;
name|pidx_last
operator|=
name|olinfo_status
operator|=
literal|0
expr_stmt|;
comment|/* Basic descriptor defines */
name|cmd_type_len
operator|=
operator|(
name|E1000_ADVTXD_DTYP_DATA
operator||
name|E1000_ADVTXD_DCMD_IFCS
operator||
name|E1000_ADVTXD_DCMD_DEXT
operator|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|ipi_mflags
operator|&
name|M_VLANTAG
condition|)
name|cmd_type_len
operator||=
name|E1000_ADVTXD_DCMD_VLE
expr_stmt|;
name|first
operator|=
name|i
operator|=
name|pi
operator|->
name|ipi_pidx
expr_stmt|;
comment|/* Consume the first descriptor */
name|i
operator|+=
name|igb_tx_ctx_setup
argument_list|(
name|txr
argument_list|,
name|pi
argument_list|,
operator|&
name|cmd_type_len
argument_list|,
operator|&
name|olinfo_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* 82575 needs the queue index added */
if|if
condition|(
name|sc
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_82575
condition|)
name|olinfo_status
operator||=
name|txr
operator|->
name|me
operator|<<
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsegs
condition|;
name|j
operator|++
control|)
block|{
name|bus_size_t
name|seglen
decl_stmt|;
name|bus_addr_t
name|segaddr
decl_stmt|;
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|=
operator|(
expr|union
name|e1000_adv_tx_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|i
index|]
expr_stmt|;
name|seglen
operator|=
name|segs
index|[
name|j
index|]
operator|.
name|ds_len
expr_stmt|;
name|segaddr
operator|=
name|htole64
argument_list|(
name|segs
index|[
name|j
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|buffer_addr
operator|=
name|segaddr
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|cmd_type_len
operator|=
name|htole32
argument_list|(
name|E1000_TXD_CMD_IFCS
operator||
name|cmd_type_len
operator||
name|seglen
argument_list|)
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|olinfo_status
operator|=
name|htole32
argument_list|(
name|olinfo_status
argument_list|)
expr_stmt|;
name|pidx_last
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|txd
operator|->
name|read
operator|.
name|cmd_type_len
operator||=
name|htole32
argument_list|(
name|E1000_TXD_CMD_EOP
operator||
name|E1000_TXD_CMD_RS
argument_list|)
expr_stmt|;
comment|/* Set the EOP descriptor that will be marked done */
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
name|txbuf
operator|->
name|eop
operator|=
name|pidx_last
expr_stmt|;
name|pi
operator|->
name|ipi_new_pidx
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_isc_txd_flush
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|txqid
parameter_list|,
name|uint32_t
name|pidx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|que
init|=
operator|&
name|adapter
operator|->
name|tx_queues
index|[
name|txqid
index|]
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|igb_isc_txd_credits_update
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|txqid
parameter_list|,
name|uint32_t
name|cidx_init
parameter_list|,
name|bool
name|clear
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|adapter
operator|->
name|shared
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|que
init|=
operator|&
name|adapter
operator|->
name|tx_queues
index|[
name|txqid
index|]
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|u32
name|cidx
decl_stmt|,
name|ntxd
decl_stmt|,
name|processed
init|=
literal|0
decl_stmt|;
name|struct
name|em_txbuffer
modifier|*
name|buf
decl_stmt|;
name|union
name|e1000_adv_tx_desc
modifier|*
name|txd
decl_stmt|,
modifier|*
name|eop
decl_stmt|;
name|int
name|limit
decl_stmt|;
name|cidx
operator|=
name|cidx_init
expr_stmt|;
name|buf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|cidx
index|]
expr_stmt|;
name|txd
operator|=
operator|(
expr|union
name|e1000_adv_tx_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|cidx
index|]
expr_stmt|;
name|ntxd
operator|=
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
expr_stmt|;
name|limit
operator|=
name|adapter
operator|->
name|tx_process_limit
expr_stmt|;
do|do
block|{
if|if
condition|(
name|buf
operator|->
name|eop
operator|==
operator|-
literal|1
condition|)
comment|/* No work */
break|break;
name|eop
operator|=
operator|(
expr|union
name|e1000_adv_tx_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|buf
operator|->
name|eop
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|eop
operator|->
name|wb
operator|.
name|status
operator|&
name|E1000_TXD_STAT_DD
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* I/O not complete */
if|if
condition|(
name|clear
condition|)
name|buf
operator|->
name|eop
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* clear indicate processed */
comment|/* We clean the range if multi segment */
while|while
condition|(
name|txd
operator|!=
name|eop
condition|)
block|{
operator|++
name|txd
expr_stmt|;
operator|++
name|buf
expr_stmt|;
comment|/* wrap the ring? */
if|if
condition|(
operator|++
name|cidx
operator|==
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
condition|)
block|{
name|cidx
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
name|txd
operator|=
operator|(
expr|union
name|e1000_adv_tx_desc
operator|*
operator|)
name|txr
operator|->
name|tx_base
expr_stmt|;
block|}
name|buf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|cidx
index|]
expr_stmt|;
if|if
condition|(
name|clear
condition|)
name|buf
operator|->
name|eop
operator|=
operator|-
literal|1
expr_stmt|;
name|processed
operator|++
expr_stmt|;
block|}
name|processed
operator|++
expr_stmt|;
comment|/* Try the next packet */
name|txd
operator|++
expr_stmt|;
name|buf
operator|++
expr_stmt|;
comment|/* reset with a wrap */
if|if
condition|(
operator|++
name|cidx
operator|==
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
condition|)
block|{
name|cidx
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
name|txd
operator|=
operator|(
expr|union
name|e1000_adv_tx_desc
operator|*
operator|)
name|txr
operator|->
name|tx_base
expr_stmt|;
block|}
name|prefetch
argument_list|(
name|txd
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|txd
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|__predict_true
argument_list|(
operator|--
name|limit
argument_list|)
operator|&&
name|cidx
operator|!=
name|cidx_init
condition|)
do|;
return|return
operator|(
name|processed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|igb_isc_rxd_refill
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|uint8_t
name|flid
name|__unused
parameter_list|,
name|uint32_t
name|pidx
parameter_list|,
name|uint64_t
modifier|*
name|paddrs
parameter_list|,
name|caddr_t
modifier|*
name|vaddrs
name|__unused
parameter_list|,
name|uint16_t
name|count
parameter_list|,
name|uint16_t
name|buf_len
name|__unused
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|sc
operator|->
name|shared
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
init|=
operator|&
name|sc
operator|->
name|rx_queues
index|[
name|rxqid
index|]
decl_stmt|;
name|union
name|e1000_adv_rx_desc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|next_pidx
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|next_pidx
operator|=
name|pidx
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|(
expr|union
name|e1000_adv_rx_desc
operator|*
operator|)
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|next_pidx
index|]
expr_stmt|;
name|rxd
operator|->
name|read
operator|.
name|pkt_addr
operator|=
name|htole64
argument_list|(
name|paddrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|next_pidx
operator|==
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
condition|)
name|next_pidx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|igb_isc_rxd_flush
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|uint8_t
name|flid
name|__unused
parameter_list|,
name|uint32_t
name|pidx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
init|=
operator|&
name|sc
operator|->
name|rx_queues
index|[
name|rxqid
index|]
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
name|E1000_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|igb_isc_rxd_available
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|uint32_t
name|idx
parameter_list|,
name|int
name|budget
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|sc
operator|->
name|shared
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
init|=
operator|&
name|sc
operator|->
name|rx_queues
index|[
name|rxqid
index|]
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|union
name|e1000_adv_rx_desc
modifier|*
name|rxd
decl_stmt|;
name|u32
name|staterr
init|=
literal|0
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|,
name|iter
decl_stmt|;
for|for
control|(
name|iter
operator|=
name|cnt
operator|=
literal|0
operator|,
name|i
operator|=
name|idx
init|;
name|iter
operator|<
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
operator|&&
name|iter
operator|<=
name|budget
condition|;
control|)
block|{
name|rxd
operator|=
operator|(
expr|union
name|e1000_adv_rx_desc
operator|*
operator|)
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
expr_stmt|;
name|staterr
operator|=
name|le32toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|staterr
operator|&
name|E1000_RXD_STAT_DD
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|++
name|i
operator|==
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|staterr
operator|&
name|E1000_RXD_STAT_EOP
condition|)
name|cnt
operator|++
expr_stmt|;
name|iter
operator|++
expr_stmt|;
block|}
block|{
name|struct
name|e1000_hw
modifier|*
name|hw
init|=
operator|&
name|sc
operator|->
name|hw
decl_stmt|;
name|int
name|rdt
decl_stmt|,
name|rdh
decl_stmt|;
name|rdt
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|rdh
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_RDH
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|iflib_get_dev
argument_list|(
name|sc
operator|->
name|ctx
argument_list|)
argument_list|,
literal|"sidx:%d eidx:%d iter=%d pktcnt=%d RDT=%d RDH=%d\n"
argument_list|,
name|idx
argument_list|,
name|i
argument_list|,
name|iter
argument_list|,
name|cnt
argument_list|,
name|rdt
argument_list|,
name|rdh
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************  * Routine sends data which has been dma'ed into host memory  * to upper layer. Initialize ri structure.   *  * Returns 0 upon success, errno on failure  ***************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_isc_rxd_pkt_get
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|adapter
operator|->
name|shared
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
init|=
operator|&
name|adapter
operator|->
name|rx_queues
index|[
name|ri
operator|->
name|iri_qsidx
index|]
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|iflib_get_ifp
argument_list|(
name|adapter
operator|->
name|ctx
argument_list|)
decl_stmt|;
name|union
name|e1000_adv_rx_desc
modifier|*
name|rxd
decl_stmt|;
name|u16
name|pkt_info
decl_stmt|,
name|len
decl_stmt|;
name|u16
name|vtag
init|=
literal|0
decl_stmt|;
name|u32
name|ptype
decl_stmt|;
name|u32
name|staterr
init|=
literal|0
decl_stmt|;
name|bool
name|eop
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|cidx
init|=
name|ri
operator|->
name|iri_cidx
decl_stmt|;
do|do
block|{
name|rxd
operator|=
operator|(
expr|union
name|e1000_adv_rx_desc
operator|*
operator|)
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|cidx
index|]
expr_stmt|;
name|staterr
operator|=
name|le32toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
argument_list|)
expr_stmt|;
name|pkt_info
operator|=
name|le16toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|lower
operator|.
name|lo_dword
operator|.
name|hs_rss
operator|.
name|pkt_info
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|staterr
operator|&
name|E1000_RXD_STAT_DD
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|upper
operator|.
name|length
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|le32toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|lower
operator|.
name|lo_dword
operator|.
name|data
argument_list|)
operator|&
name|IGB_PKTTYPE_MASK
expr_stmt|;
name|ri
operator|->
name|iri_len
operator|+=
name|len
expr_stmt|;
name|rxr
operator|->
name|rx_bytes
operator|+=
name|ri
operator|->
name|iri_len
expr_stmt|;
name|rxd
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
operator|=
literal|0
expr_stmt|;
name|eop
operator|=
operator|(
operator|(
name|staterr
operator|&
name|E1000_RXD_STAT_EOP
operator|)
operator|==
name|E1000_RXD_STAT_EOP
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_i350
operator|)
operator|||
operator|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|==
name|e1000_i354
operator|)
operator|)
operator|&&
operator|(
name|staterr
operator|&
name|E1000_RXDEXT_STATERR_LB
operator|)
condition|)
name|vtag
operator|=
name|be16toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|upper
operator|.
name|vlan
argument_list|)
expr_stmt|;
else|else
name|vtag
operator|=
name|le16toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|upper
operator|.
name|vlan
argument_list|)
expr_stmt|;
comment|/* Make sure bad packets are discarded */
if|if
condition|(
name|eop
operator|&&
operator|(
operator|(
name|staterr
operator|&
name|E1000_RXDEXT_ERR_FRAME_ERR_MASK
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|adapter
operator|->
name|dropped_pkts
operator|++
expr_stmt|;
operator|++
name|rxr
operator|->
name|rx_discarded
expr_stmt|;
return|return
operator|(
name|EBADMSG
operator|)
return|;
block|}
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_flid
operator|=
literal|0
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_idx
operator|=
name|cidx
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|++
name|cidx
operator|==
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
condition|)
name|cidx
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|rxr
operator|->
name|hdr_split
operator|==
name|TRUE
condition|)
block|{
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_flid
operator|=
literal|1
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_idx
operator|=
name|cidx
expr_stmt|;
if|if
condition|(
operator|++
name|cidx
operator|==
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
condition|)
name|cidx
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|eop
condition|)
do|;
name|rxr
operator|->
name|rx_packets
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|igb_rx_checksum
argument_list|(
name|staterr
argument_list|,
name|ri
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|staterr
operator|&
name|E1000_RXD_STAT_VP
operator|)
operator|!=
literal|0
condition|)
block|{
name|ri
operator|->
name|iri_vtag
operator|=
name|vtag
expr_stmt|;
name|ri
operator|->
name|iri_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
name|ri
operator|->
name|iri_flowid
operator|=
name|le32toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|lower
operator|.
name|hi_dword
operator|.
name|rss
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_rsstype
operator|=
name|igb_determine_rsstype
argument_list|(
name|pkt_info
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_nfrags
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Verify that the hardware indicated that the checksum is valid.  *  Inform the stack about the status of checksum so that stack  *  doesn't spend time verifying the checksum.  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|igb_rx_checksum
parameter_list|(
name|u32
name|staterr
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|,
name|u32
name|ptype
parameter_list|)
block|{
name|u16
name|status
init|=
operator|(
name|u16
operator|)
name|staterr
decl_stmt|;
name|u8
name|errors
init|=
call|(
name|u8
call|)
argument_list|(
name|staterr
operator|>>
literal|24
argument_list|)
decl_stmt|;
name|bool
name|sctp
init|=
name|FALSE
decl_stmt|;
comment|/* Ignore Checksum bit is set */
if|if
condition|(
name|status
operator|&
name|E1000_RXD_STAT_IXSM
condition|)
block|{
name|ri
operator|->
name|iri_csum_flags
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ptype
operator|&
name|E1000_RXDADV_PKTTYPE_ETQF
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ptype
operator|&
name|E1000_RXDADV_PKTTYPE_SCTP
operator|)
operator|!=
literal|0
condition|)
name|sctp
operator|=
literal|1
expr_stmt|;
else|else
name|sctp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_RXD_STAT_IPCS
condition|)
block|{
comment|/* Did it pass? */
if|if
condition|(
operator|!
operator|(
name|errors
operator|&
name|E1000_RXD_ERR_IPE
operator|)
condition|)
block|{
comment|/* IP Checksum Good */
name|ri
operator|->
name|iri_csum_flags
operator|=
name|CSUM_IP_CHECKED
expr_stmt|;
name|ri
operator|->
name|iri_csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
else|else
name|ri
operator|->
name|iri_csum_flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
operator|(
name|E1000_RXD_STAT_TCPCS
operator||
name|E1000_RXD_STAT_UDPCS
operator|)
condition|)
block|{
name|u64
name|type
init|=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
if|if
condition|(
name|sctp
condition|)
comment|/* reassign */
name|type
operator|=
name|CSUM_SCTP_VALID
expr_stmt|;
endif|#
directive|endif
comment|/* Did it pass? */
if|if
condition|(
operator|!
operator|(
name|errors
operator|&
name|E1000_RXD_ERR_TCPE
operator|)
condition|)
block|{
name|ri
operator|->
name|iri_csum_flags
operator||=
name|type
expr_stmt|;
if|if
condition|(
name|sctp
operator|==
literal|0
condition|)
name|ri
operator|->
name|iri_csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/********************************************************************  *  *  Parse the packet type to determine the appropriate hash  *  ******************************************************************/
end_comment

begin_function
specifier|static
name|int
name|igb_determine_rsstype
parameter_list|(
name|u16
name|pkt_info
parameter_list|)
block|{
switch|switch
condition|(
name|pkt_info
operator|&
name|E1000_RXDADV_RSSTYPE_MASK
condition|)
block|{
case|case
name|E1000_RXDADV_RSSTYPE_IPV4_TCP
case|:
return|return
name|M_HASHTYPE_RSS_TCP_IPV4
return|;
case|case
name|E1000_RXDADV_RSSTYPE_IPV4
case|:
return|return
name|M_HASHTYPE_RSS_IPV4
return|;
case|case
name|E1000_RXDADV_RSSTYPE_IPV6_TCP
case|:
return|return
name|M_HASHTYPE_RSS_TCP_IPV6
return|;
case|case
name|E1000_RXDADV_RSSTYPE_IPV6_EX
case|:
return|return
name|M_HASHTYPE_RSS_IPV6_EX
return|;
case|case
name|E1000_RXDADV_RSSTYPE_IPV6
case|:
return|return
name|M_HASHTYPE_RSS_IPV6
return|;
case|case
name|E1000_RXDADV_RSSTYPE_IPV6_TCP_EX
case|:
return|return
name|M_HASHTYPE_RSS_TCP_IPV6_EX
return|;
default|default:
return|return
name|M_HASHTYPE_OPAQUE
return|;
block|}
block|}
end_function

end_unit

