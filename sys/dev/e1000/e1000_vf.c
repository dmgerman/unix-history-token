begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2014, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"e1000_api.h"
end_include

begin_function_decl
specifier|static
name|s32
name|e1000_init_phy_params_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_init_nvm_params_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_release_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_acquire_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_setup_link_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_bus_info_pcie_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_init_mac_params_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_check_for_link_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_get_link_up_info_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_init_hw_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_reset_hw_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|e1000_update_mc_addr_list_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|e1000_rar_set_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|e1000_read_mac_addr_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  e1000_init_phy_params_vf - Inits PHY params  *  @hw: pointer to the HW structure  *  *  Doesn't do much - there's no PHY available to the VF.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_phy_params_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_phy_params_vf"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|type
operator|=
name|e1000_phy_vf
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|acquire
operator|=
name|e1000_acquire_vf
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|release
operator|=
name|e1000_release_vf
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_nvm_params_vf - Inits NVM params  *  @hw: pointer to the HW structure  *  *  Doesn't do much - there's no NVM available to the VF.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_nvm_params_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_nvm_params_vf"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|nvm
operator|.
name|type
operator|=
name|e1000_nvm_none
expr_stmt|;
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|acquire
operator|=
name|e1000_acquire_vf
expr_stmt|;
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|release
operator|=
name|e1000_release_vf
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_mac_params_vf - Inits MAC params  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_mac_params_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_mac_params_vf"
argument_list|)
expr_stmt|;
comment|/* Set media type */
comment|/* 	 * Virtual functions don't care what they're media type is as they 	 * have no direct access to the PHY, or the media.  That is handled 	 * by the physical function driver. 	 */
name|hw
operator|->
name|phy
operator|.
name|media_type
operator|=
name|e1000_media_type_unknown
expr_stmt|;
comment|/* No ASF features for the VF driver */
name|mac
operator|->
name|asf_firmware_present
operator|=
name|FALSE
expr_stmt|;
comment|/* ARC subsystem not supported */
name|mac
operator|->
name|arc_subsystem_valid
operator|=
name|FALSE
expr_stmt|;
comment|/* Disable adaptive IFS mode so the generic funcs don't do anything */
name|mac
operator|->
name|adaptive_ifs
operator|=
name|FALSE
expr_stmt|;
comment|/* VF's have no MTA Registers - PF feature only */
name|mac
operator|->
name|mta_reg_count
operator|=
literal|128
expr_stmt|;
comment|/* VF's have no access to RAR entries  */
name|mac
operator|->
name|rar_entry_count
operator|=
literal|1
expr_stmt|;
comment|/* Function pointers */
comment|/* link setup */
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|e1000_setup_link_vf
expr_stmt|;
comment|/* bus type/speed/width */
name|mac
operator|->
name|ops
operator|.
name|get_bus_info
operator|=
name|e1000_get_bus_info_pcie_vf
expr_stmt|;
comment|/* reset */
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
name|e1000_reset_hw_vf
expr_stmt|;
comment|/* hw initialization */
name|mac
operator|->
name|ops
operator|.
name|init_hw
operator|=
name|e1000_init_hw_vf
expr_stmt|;
comment|/* check for link */
name|mac
operator|->
name|ops
operator|.
name|check_for_link
operator|=
name|e1000_check_for_link_vf
expr_stmt|;
comment|/* link info */
name|mac
operator|->
name|ops
operator|.
name|get_link_up_info
operator|=
name|e1000_get_link_up_info_vf
expr_stmt|;
comment|/* multicast address update */
name|mac
operator|->
name|ops
operator|.
name|update_mc_addr_list
operator|=
name|e1000_update_mc_addr_list_vf
expr_stmt|;
comment|/* set mac address */
name|mac
operator|->
name|ops
operator|.
name|rar_set
operator|=
name|e1000_rar_set_vf
expr_stmt|;
comment|/* read mac address */
name|mac
operator|->
name|ops
operator|.
name|read_mac_addr
operator|=
name|e1000_read_mac_addr_vf
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_function_pointers_vf - Inits function pointers  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
name|void
name|e1000_init_function_pointers_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_function_pointers_vf"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_mac_params_vf
expr_stmt|;
name|hw
operator|->
name|nvm
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_nvm_params_vf
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_phy_params_vf
expr_stmt|;
name|hw
operator|->
name|mbx
operator|.
name|ops
operator|.
name|init_params
operator|=
name|e1000_init_mbx_params_vf
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_acquire_vf - Acquire rights to access PHY or NVM.  *  @hw: pointer to the HW structure  *  *  There is no PHY or NVM so we want all attempts to acquire these to fail.  *  In addition, the MAC registers to access PHY/NVM don't exist so we don't  *  even want any SW to attempt to use them.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_acquire_vf
parameter_list|(
name|struct
name|e1000_hw
name|E1000_UNUSEDARG
modifier|*
name|hw
parameter_list|)
block|{
return|return
operator|-
name|E1000_ERR_PHY
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_release_vf - Release PHY or NVM  *  @hw: pointer to the HW structure  *  *  There is no PHY or NVM so we want all attempts to acquire these to fail.  *  In addition, the MAC registers to access PHY/NVM don't exist so we don't  *  even want any SW to attempt to use them.  **/
end_comment

begin_function
specifier|static
name|void
name|e1000_release_vf
parameter_list|(
name|struct
name|e1000_hw
name|E1000_UNUSEDARG
modifier|*
name|hw
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/**  *  e1000_setup_link_vf - Sets up link.  *  @hw: pointer to the HW structure  *  *  Virtual functions cannot change link.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_setup_link_vf
parameter_list|(
name|struct
name|e1000_hw
name|E1000_UNUSEDARG
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_setup_link_vf"
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_bus_info_pcie_vf - Gets the bus info.  *  @hw: pointer to the HW structure  *  *  Virtual functions are not really on their own bus.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_bus_info_pcie_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_bus_info
modifier|*
name|bus
init|=
operator|&
name|hw
operator|->
name|bus
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_bus_info_pcie_vf"
argument_list|)
expr_stmt|;
comment|/* Do not set type PCI-E because we don't want disable master to run */
name|bus
operator|->
name|type
operator|=
name|e1000_bus_type_reserved
expr_stmt|;
name|bus
operator|->
name|speed
operator|=
name|e1000_bus_speed_2500
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_get_link_up_info_vf - Gets link info.  *  @hw: pointer to the HW structure  *  @speed: pointer to 16 bit value to store link speed.  *  @duplex: pointer to 16 bit value to store duplex.  *  *  Since we cannot read the PHY and get accurate link info, we must rely upon  *  the status register's data which is often stale and inaccurate.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_get_link_up_info_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
modifier|*
name|speed
parameter_list|,
name|u16
modifier|*
name|duplex
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_get_link_up_info_vf"
argument_list|)
expr_stmt|;
name|status
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_SPEED_1000
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"1000 Mbs, "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_SPEED_100
condition|)
block|{
operator|*
name|speed
operator|=
name|SPEED_100
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"100 Mbs, "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|speed
operator|=
name|SPEED_10
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"10 Mbs, "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|E1000_STATUS_FD
condition|)
block|{
operator|*
name|duplex
operator|=
name|FULL_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Full Duplex\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|duplex
operator|=
name|HALF_DUPLEX
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Half Duplex\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_reset_hw_vf - Resets the HW  *  @hw: pointer to the HW structure  *  *  VF's provide a function level reset. This is done using bit 26 of ctrl_reg.  *  This is all the reset we can perform on a VF.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_reset_hw_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|u32
name|timeout
init|=
name|E1000_VF_INIT_TIMEOUT
decl_stmt|;
name|s32
name|ret_val
init|=
operator|-
name|E1000_ERR_MAC_INIT
decl_stmt|;
name|u32
name|ctrl
decl_stmt|,
name|msgbuf
index|[
literal|3
index|]
decl_stmt|;
name|u8
modifier|*
name|addr
init|=
operator|(
name|u8
operator|*
operator|)
operator|(
operator|&
name|msgbuf
index|[
literal|1
index|]
operator|)
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_reset_hw_vf"
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Issuing a function level reset to MAC\n"
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|)
expr_stmt|;
name|E1000_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|E1000_CTRL
argument_list|,
name|ctrl
operator||
name|E1000_CTRL_RST
argument_list|)
expr_stmt|;
comment|/* we cannot reset while the RSTI / RSTD bits are asserted */
while|while
condition|(
operator|!
name|mbx
operator|->
name|ops
operator|.
name|check_for_rst
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|)
operator|&&
name|timeout
condition|)
block|{
name|timeout
operator|--
expr_stmt|;
name|usec_delay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
condition|)
block|{
comment|/* mailbox timeout can now become active */
name|mbx
operator|->
name|timeout
operator|=
name|E1000_VF_MBX_INIT_TIMEOUT
expr_stmt|;
name|msgbuf
index|[
literal|0
index|]
operator|=
name|E1000_VF_RESET
expr_stmt|;
name|mbx
operator|->
name|ops
operator|.
name|write_posted
argument_list|(
name|hw
argument_list|,
name|msgbuf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* set our "perm_addr" based on info provided by PF */
name|ret_val
operator|=
name|mbx
operator|->
name|ops
operator|.
name|read_posted
argument_list|(
name|hw
argument_list|,
name|msgbuf
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
block|{
if|if
condition|(
name|msgbuf
index|[
literal|0
index|]
operator|==
operator|(
name|E1000_VF_RESET
operator||
name|E1000_VT_MSGTYPE_ACK
operator|)
condition|)
name|memcpy
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|perm_addr
argument_list|,
name|addr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
operator|-
name|E1000_ERR_MAC_INIT
expr_stmt|;
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_init_hw_vf - Inits the HW  *  @hw: pointer to the HW structure  *  *  Not much to do here except clear the PF Reset indication if there is one.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_init_hw_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"e1000_init_hw_vf"
argument_list|)
expr_stmt|;
comment|/* attempt to set and restore our mac address */
name|e1000_rar_set_vf
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_rar_set_vf - set device MAC address  *  @hw: pointer to the HW structure  *  @addr: pointer to the receive address  *  @index receive address array register  **/
end_comment

begin_function
specifier|static
name|int
name|e1000_rar_set_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|addr
parameter_list|,
name|u32
name|E1000_UNUSEDARG
name|index
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|u32
name|msgbuf
index|[
literal|3
index|]
decl_stmt|;
name|u8
modifier|*
name|msg_addr
init|=
operator|(
name|u8
operator|*
operator|)
operator|(
operator|&
name|msgbuf
index|[
literal|1
index|]
operator|)
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|memset
argument_list|(
name|msgbuf
argument_list|,
literal|0
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|msgbuf
index|[
literal|0
index|]
operator|=
name|E1000_VF_SET_MAC_ADDR
expr_stmt|;
name|memcpy
argument_list|(
name|msg_addr
argument_list|,
name|addr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|mbx
operator|->
name|ops
operator|.
name|write_posted
argument_list|(
name|hw
argument_list|,
name|msgbuf
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|ret_val
operator|=
name|mbx
operator|->
name|ops
operator|.
name|read_posted
argument_list|(
name|hw
argument_list|,
name|msgbuf
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msgbuf
index|[
literal|0
index|]
operator|&=
operator|~
name|E1000_VT_MSGTYPE_CTS
expr_stmt|;
comment|/* if nacked the address was rejected, use "perm_addr" */
if|if
condition|(
operator|!
name|ret_val
operator|&&
operator|(
name|msgbuf
index|[
literal|0
index|]
operator|==
operator|(
name|E1000_VF_SET_MAC_ADDR
operator||
name|E1000_VT_MSGTYPE_NACK
operator|)
operator|)
condition|)
name|e1000_read_mac_addr_vf
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_hash_mc_addr_vf - Generate a multicast hash value  *  @hw: pointer to the HW structure  *  @mc_addr: pointer to a multicast address  *  *  Generates a multicast address hash value which is used to determine  *  the multicast filter table array address and new table value.  **/
end_comment

begin_function
specifier|static
name|u32
name|e1000_hash_mc_addr_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr
parameter_list|)
block|{
name|u32
name|hash_value
decl_stmt|,
name|hash_mask
decl_stmt|;
name|u8
name|bit_shift
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_hash_mc_addr_generic"
argument_list|)
expr_stmt|;
comment|/* Register count multiplied by bits per register */
name|hash_mask
operator|=
operator|(
name|hw
operator|->
name|mac
operator|.
name|mta_reg_count
operator|*
literal|32
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 	 * The bit_shift is the number of left-shifts 	 * where 0xFF would still fall within the hash mask. 	 */
while|while
condition|(
name|hash_mask
operator|>>
name|bit_shift
operator|!=
literal|0xFF
condition|)
name|bit_shift
operator|++
expr_stmt|;
name|hash_value
operator|=
name|hash_mask
operator|&
operator|(
operator|(
operator|(
name|mc_addr
index|[
literal|4
index|]
operator|>>
operator|(
literal|8
operator|-
name|bit_shift
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|mc_addr
index|[
literal|5
index|]
operator|)
operator|<<
name|bit_shift
operator|)
operator|)
operator|)
expr_stmt|;
return|return
name|hash_value
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e1000_write_msg_read_ack
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u32
modifier|*
name|msg
parameter_list|,
name|u16
name|size
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|u32
name|retmsg
index|[
name|E1000_VFMAILBOX_SIZE
index|]
decl_stmt|;
name|s32
name|retval
init|=
name|mbx
operator|->
name|ops
operator|.
name|write_posted
argument_list|(
name|hw
argument_list|,
name|msg
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
name|mbx
operator|->
name|ops
operator|.
name|read_posted
argument_list|(
name|hw
argument_list|,
name|retmsg
argument_list|,
name|E1000_VFMAILBOX_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_update_mc_addr_list_vf - Update Multicast addresses  *  @hw: pointer to the HW structure  *  @mc_addr_list: array of multicast addresses to program  *  @mc_addr_count: number of multicast addresses to program  *  *  Updates the Multicast Table Array.  *  The caller must have a packed mc_addr_list of multicast addresses.  **/
end_comment

begin_function
name|void
name|e1000_update_mc_addr_list_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|mc_addr_list
parameter_list|,
name|u32
name|mc_addr_count
parameter_list|)
block|{
name|u32
name|msgbuf
index|[
name|E1000_VFMAILBOX_SIZE
index|]
decl_stmt|;
name|u16
modifier|*
name|hash_list
init|=
operator|(
name|u16
operator|*
operator|)
operator|&
name|msgbuf
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|hash_value
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_update_mc_addr_list_vf"
argument_list|)
expr_stmt|;
comment|/* Each entry in the list uses 1 16 bit word.  We have 30 	 * 16 bit words available in our HW msg buffer (minus 1 for the 	 * msg type).  That's 30 hash values if we pack 'em right.  If 	 * there are more than 30 MC addresses to add then punt the 	 * extras for now and then add code to handle more than 30 later. 	 * It would be unusual for a server to request that many multi-cast 	 * addresses except for in large enterprise network environments. 	 */
name|DEBUGOUT1
argument_list|(
literal|"MC Addr Count = %d\n"
argument_list|,
name|mc_addr_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc_addr_count
operator|>
literal|30
condition|)
block|{
name|msgbuf
index|[
literal|0
index|]
operator||=
name|E1000_VF_SET_MULTICAST_OVERFLOW
expr_stmt|;
name|mc_addr_count
operator|=
literal|30
expr_stmt|;
block|}
name|msgbuf
index|[
literal|0
index|]
operator|=
name|E1000_VF_SET_MULTICAST
expr_stmt|;
name|msgbuf
index|[
literal|0
index|]
operator||=
name|mc_addr_count
operator|<<
name|E1000_VT_MSGINFO_SHIFT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc_addr_count
condition|;
name|i
operator|++
control|)
block|{
name|hash_value
operator|=
name|e1000_hash_mc_addr_vf
argument_list|(
name|hw
argument_list|,
name|mc_addr_list
argument_list|)
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"Hash value = 0x%03X\n"
argument_list|,
name|hash_value
argument_list|)
expr_stmt|;
name|hash_list
index|[
name|i
index|]
operator|=
name|hash_value
operator|&
literal|0x0FFF
expr_stmt|;
name|mc_addr_list
operator|+=
name|ETH_ADDR_LEN
expr_stmt|;
block|}
name|e1000_write_msg_read_ack
argument_list|(
name|hw
argument_list|,
name|msgbuf
argument_list|,
name|E1000_VFMAILBOX_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_vfta_set_vf - Set/Unset vlan filter table address  *  @hw: pointer to the HW structure  *  @vid: determines the vfta register and bit to set/unset  *  @set: if TRUE then set bit, else clear bit  **/
end_comment

begin_function
name|void
name|e1000_vfta_set_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|vid
parameter_list|,
name|bool
name|set
parameter_list|)
block|{
name|u32
name|msgbuf
index|[
literal|2
index|]
decl_stmt|;
name|msgbuf
index|[
literal|0
index|]
operator|=
name|E1000_VF_SET_VLAN
expr_stmt|;
name|msgbuf
index|[
literal|1
index|]
operator|=
name|vid
expr_stmt|;
comment|/* Setting the 8 bit field MSG INFO to TRUE indicates "add" */
if|if
condition|(
name|set
condition|)
name|msgbuf
index|[
literal|0
index|]
operator||=
name|E1000_VF_SET_VLAN_ADD
expr_stmt|;
name|e1000_write_msg_read_ack
argument_list|(
name|hw
argument_list|,
name|msgbuf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** e1000_rlpml_set_vf - Set the maximum receive packet length  *  @hw: pointer to the HW structure  *  @max_size: value to assign to max frame size  **/
end_comment

begin_function
name|void
name|e1000_rlpml_set_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|max_size
parameter_list|)
block|{
name|u32
name|msgbuf
index|[
literal|2
index|]
decl_stmt|;
name|msgbuf
index|[
literal|0
index|]
operator|=
name|E1000_VF_SET_LPE
expr_stmt|;
name|msgbuf
index|[
literal|1
index|]
operator|=
name|max_size
expr_stmt|;
name|e1000_write_msg_read_ack
argument_list|(
name|hw
argument_list|,
name|msgbuf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  e1000_promisc_set_vf - Set flags for Unicast or Multicast promisc  *  @hw: pointer to the HW structure  *  @uni: boolean indicating unicast promisc status  *  @multi: boolean indicating multicast promisc status  **/
end_comment

begin_function
name|s32
name|e1000_promisc_set_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|,
name|enum
name|e1000_promisc_type
name|type
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|u32
name|msgbuf
init|=
name|E1000_VF_SET_PROMISC
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|e1000_promisc_multicast
case|:
name|msgbuf
operator||=
name|E1000_VF_SET_PROMISC_MULTICAST
expr_stmt|;
break|break;
case|case
name|e1000_promisc_enabled
case|:
name|msgbuf
operator||=
name|E1000_VF_SET_PROMISC_MULTICAST
expr_stmt|;
case|case
name|e1000_promisc_unicast
case|:
name|msgbuf
operator||=
name|E1000_VF_SET_PROMISC_UNICAST
expr_stmt|;
case|case
name|e1000_promisc_disabled
case|:
break|break;
default|default:
return|return
operator|-
name|E1000_ERR_MAC_INIT
return|;
block|}
name|ret_val
operator|=
name|mbx
operator|->
name|ops
operator|.
name|write_posted
argument_list|(
name|hw
argument_list|,
operator|&
name|msgbuf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
name|ret_val
operator|=
name|mbx
operator|->
name|ops
operator|.
name|read_posted
argument_list|(
name|hw
argument_list|,
operator|&
name|msgbuf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
operator|&&
operator|!
operator|(
name|msgbuf
operator|&
name|E1000_VT_MSGTYPE_ACK
operator|)
condition|)
name|ret_val
operator|=
operator|-
name|E1000_ERR_MAC_INIT
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_read_mac_addr_vf - Read device MAC address  *  @hw: pointer to the HW structure  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_read_mac_addr_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETH_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|hw
operator|->
name|mac
operator|.
name|addr
index|[
name|i
index|]
operator|=
name|hw
operator|->
name|mac
operator|.
name|perm_addr
index|[
name|i
index|]
expr_stmt|;
return|return
name|E1000_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  e1000_check_for_link_vf - Check for link for a virtual interface  *  @hw: pointer to the HW structure  *  *  Checks to see if the underlying PF is still talking to the VF and  *  if it is then it reports the link state to the hardware, otherwise  *  it reports link down and returns an error.  **/
end_comment

begin_function
specifier|static
name|s32
name|e1000_check_for_link_vf
parameter_list|(
name|struct
name|e1000_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|e1000_mbx_info
modifier|*
name|mbx
init|=
operator|&
name|hw
operator|->
name|mbx
decl_stmt|;
name|struct
name|e1000_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|s32
name|ret_val
init|=
name|E1000_SUCCESS
decl_stmt|;
name|u32
name|in_msg
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"e1000_check_for_link_vf"
argument_list|)
expr_stmt|;
comment|/* 	 * We only want to run this if there has been a rst asserted. 	 * in this case that could mean a link change, device reset, 	 * or a virtual function reset 	 */
comment|/* If we were hit with a reset or timeout drop the link */
if|if
condition|(
operator|!
name|mbx
operator|->
name|ops
operator|.
name|check_for_rst
argument_list|(
name|hw
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|mbx
operator|->
name|timeout
condition|)
name|mac
operator|->
name|get_link_status
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|mac
operator|->
name|get_link_status
condition|)
goto|goto
name|out
goto|;
comment|/* if link status is down no point in checking to see if pf is up */
if|if
condition|(
operator|!
operator|(
name|E1000_READ_REG
argument_list|(
name|hw
argument_list|,
name|E1000_STATUS
argument_list|)
operator|&
name|E1000_STATUS_LU
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* if the read failed it could just be a mailbox collision, best wait 	 * until we are called again and don't report an error */
if|if
condition|(
name|mbx
operator|->
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
operator|&
name|in_msg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* if incoming message isn't clear to send we are waiting on response */
if|if
condition|(
operator|!
operator|(
name|in_msg
operator|&
name|E1000_VT_MSGTYPE_CTS
operator|)
condition|)
block|{
comment|/* message is not CTS and is NACK we have lost CTS status */
if|if
condition|(
name|in_msg
operator|&
name|E1000_VT_MSGTYPE_NACK
condition|)
name|ret_val
operator|=
operator|-
name|E1000_ERR_MAC_INIT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* at this point we know the PF is talking to us, check and see if 	 * we are still accepting timeout or if we had a timeout failure. 	 * if we failed then we will need to reinit */
if|if
condition|(
operator|!
name|mbx
operator|->
name|timeout
condition|)
block|{
name|ret_val
operator|=
operator|-
name|E1000_ERR_MAC_INIT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* if we passed all the tests above then the link is up and we no 	 * longer need to check for link */
name|mac
operator|->
name|get_link_status
operator|=
name|FALSE
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

end_unit

