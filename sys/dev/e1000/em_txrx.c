begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016-2017 Matt Macy<mmacy@nextbsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"if_em.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RSS
end_ifdef

begin_include
include|#
directive|include
file|<net/rss_config.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_rss.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VERBOSE_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
value|device_printf
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*********************************************************************  *  Local Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|em_tso_setup
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|,
name|u32
modifier|*
name|txd_upper
parameter_list|,
name|u32
modifier|*
name|txd_lower
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_transmit_checksum_setup
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|,
name|u32
modifier|*
name|txd_upper
parameter_list|,
name|u32
modifier|*
name|txd_lower
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_isc_txd_encap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_isc_txd_flush
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|txqid
parameter_list|,
name|qidx_t
name|pidx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_isc_txd_credits_update
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|txqid
parameter_list|,
name|bool
name|clear
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_isc_rxd_refill
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_rxd_update_t
name|iru
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_isc_rxd_flush
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|uint8_t
name|flid
name|__unused
parameter_list|,
name|qidx_t
name|pidx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_isc_rxd_available
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|qidx_t
name|idx
parameter_list|,
name|qidx_t
name|budget
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_isc_rxd_pkt_get
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lem_isc_rxd_refill
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_rxd_update_t
name|iru
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lem_isc_rxd_available
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|qidx_t
name|idx
parameter_list|,
name|qidx_t
name|budget
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lem_isc_rxd_pkt_get
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lem_receive_checksum
parameter_list|(
name|int
name|status
parameter_list|,
name|int
name|errors
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|em_receive_checksum
parameter_list|(
name|uint32_t
name|status
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|em_determine_rsstype
parameter_list|(
name|u32
name|pkt_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|em_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|if_txrx
name|em_txrx
init|=
block|{
name|em_isc_txd_encap
block|,
name|em_isc_txd_flush
block|,
name|em_isc_txd_credits_update
block|,
name|em_isc_rxd_available
block|,
name|em_isc_rxd_pkt_get
block|,
name|em_isc_rxd_refill
block|,
name|em_isc_rxd_flush
block|,
name|em_intr
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|if_txrx
name|lem_txrx
init|=
block|{
name|em_isc_txd_encap
block|,
name|em_isc_txd_flush
block|,
name|em_isc_txd_credits_update
block|,
name|lem_isc_rxd_available
block|,
name|lem_isc_rxd_pkt_get
block|,
name|lem_isc_rxd_refill
block|,
name|em_isc_rxd_flush
block|,
name|em_intr
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|if_shared_ctx_t
name|em_sctx
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|em_dump_rs
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|if_softc_ctx_t
name|scctx
init|=
name|adapter
operator|->
name|shared
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|qidx_t
name|i
decl_stmt|,
name|ntxd
decl_stmt|,
name|qid
decl_stmt|,
name|cur
decl_stmt|;
name|int16_t
name|rs_cidx
decl_stmt|;
name|uint8_t
name|status
decl_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ntxd
operator|=
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|adapter
operator|->
name|tx_num_queues
condition|;
name|qid
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|adapter
operator|->
name|tx_queues
index|[
name|qid
index|]
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
name|rs_cidx
operator|=
name|txr
operator|->
name|tx_rs_cidx
expr_stmt|;
if|if
condition|(
name|rs_cidx
operator|!=
name|txr
operator|->
name|tx_rs_pidx
condition|)
block|{
name|cur
operator|=
name|txr
operator|->
name|tx_rsq
index|[
name|rs_cidx
index|]
expr_stmt|;
name|status
operator|=
name|txr
operator|->
name|tx_base
index|[
name|cur
index|]
operator|.
name|upper
operator|.
name|fields
operator|.
name|status
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|E1000_TXD_STAT_DD
operator|)
condition|)
name|printf
argument_list|(
literal|"qid[%d]->tx_rsq[%d]: %d clear "
argument_list|,
name|qid
argument_list|,
name|rs_cidx
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rs_cidx
operator|=
operator|(
name|rs_cidx
operator|-
literal|1
operator|)
operator|&
operator|(
name|ntxd
operator|-
literal|1
operator|)
expr_stmt|;
name|cur
operator|=
name|txr
operator|->
name|tx_rsq
index|[
name|rs_cidx
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"qid[%d]->tx_rsq[rs_cidx-1=%d]: %d  "
argument_list|,
name|qid
argument_list|,
name|rs_cidx
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"cidx_prev=%d rs_pidx=%d "
argument_list|,
name|txr
operator|->
name|tx_cidx_processed
argument_list|,
name|txr
operator|->
name|tx_rs_pidx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntxd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|txr
operator|->
name|tx_base
index|[
name|i
index|]
operator|.
name|upper
operator|.
name|fields
operator|.
name|status
operator|&
name|E1000_TXD_STAT_DD
condition|)
name|printf
argument_list|(
literal|"%d set "
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Setup work for hardware segmentation offload (TSO) on  *  adapters using advanced tx descriptors  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_tso_setup
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|,
name|u32
modifier|*
name|txd_upper
parameter_list|,
name|u32
modifier|*
name|txd_lower
parameter_list|)
block|{
name|if_softc_ctx_t
name|scctx
init|=
name|adapter
operator|->
name|shared
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|que
init|=
operator|&
name|adapter
operator|->
name|tx_queues
index|[
name|pi
operator|->
name|ipi_qsidx
index|]
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|e1000_context_desc
modifier|*
name|TXD
decl_stmt|;
name|int
name|cur
decl_stmt|,
name|hdr_len
decl_stmt|;
name|hdr_len
operator|=
name|pi
operator|->
name|ipi_ehdrlen
operator|+
name|pi
operator|->
name|ipi_ip_hlen
operator|+
name|pi
operator|->
name|ipi_tcp_hlen
expr_stmt|;
operator|*
name|txd_lower
operator|=
operator|(
name|E1000_TXD_CMD_DEXT
operator||
comment|/* Extended descr type */
name|E1000_TXD_DTYP_D
operator||
comment|/* Data descr type */
name|E1000_TXD_CMD_TSE
operator|)
expr_stmt|;
comment|/* Do TSE on this packet */
comment|/* IP and/or TCP header checksum calculation and insertion. */
operator|*
name|txd_upper
operator|=
operator|(
name|E1000_TXD_POPTS_IXSM
operator||
name|E1000_TXD_POPTS_TXSM
operator|)
operator|<<
literal|8
expr_stmt|;
name|cur
operator|=
name|pi
operator|->
name|ipi_pidx
expr_stmt|;
name|TXD
operator|=
operator|(
expr|struct
name|e1000_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|cur
index|]
expr_stmt|;
comment|/* 	 * Start offset for header checksum calculation. 	 * End offset for header checksum calculation. 	 * Offset of place put the checksum. 	 */
name|TXD
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcss
operator|=
name|pi
operator|->
name|ipi_ehdrlen
expr_stmt|;
name|TXD
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcse
operator|=
name|htole16
argument_list|(
name|pi
operator|->
name|ipi_ehdrlen
operator|+
name|pi
operator|->
name|ipi_ip_hlen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcso
operator|=
name|pi
operator|->
name|ipi_ehdrlen
operator|+
name|offsetof
argument_list|(
expr|struct
name|ip
argument_list|,
name|ip_sum
argument_list|)
expr_stmt|;
comment|/* 	 * Start offset for payload checksum calculation. 	 * End offset for payload checksum calculation. 	 * Offset of place to put the checksum. 	 */
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucss
operator|=
name|pi
operator|->
name|ipi_ehdrlen
operator|+
name|pi
operator|->
name|ipi_ip_hlen
expr_stmt|;
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucse
operator|=
literal|0
expr_stmt|;
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucso
operator|=
name|pi
operator|->
name|ipi_ehdrlen
operator|+
name|pi
operator|->
name|ipi_ip_hlen
operator|+
name|offsetof
argument_list|(
expr|struct
name|tcphdr
argument_list|,
name|th_sum
argument_list|)
expr_stmt|;
comment|/* 	 * Payload size per packet w/o any headers. 	 * Length of all headers up to payload. 	 */
name|TXD
operator|->
name|tcp_seg_setup
operator|.
name|fields
operator|.
name|mss
operator|=
name|htole16
argument_list|(
name|pi
operator|->
name|ipi_tso_segsz
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|tcp_seg_setup
operator|.
name|fields
operator|.
name|hdr_len
operator|=
name|hdr_len
expr_stmt|;
name|TXD
operator|->
name|cmd_and_length
operator|=
name|htole32
argument_list|(
name|adapter
operator|->
name|txd_cmd
operator||
name|E1000_TXD_CMD_DEXT
operator||
comment|/* Extended descr */
name|E1000_TXD_CMD_TSE
operator||
comment|/* TSE context */
name|E1000_TXD_CMD_IP
operator||
comment|/* Do IP csum */
name|E1000_TXD_CMD_TCP
operator||
comment|/* Do TCP checksum */
operator|(
name|pi
operator|->
name|ipi_len
operator|-
name|hdr_len
operator|)
argument_list|)
expr_stmt|;
comment|/* Total len */
name|txr
operator|->
name|tx_tso
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|++
name|cur
operator|==
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
condition|)
block|{
name|cur
operator|=
literal|0
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|iflib_get_dev
argument_list|(
name|adapter
operator|->
name|ctx
argument_list|)
argument_list|,
literal|"%s: pidx: %d cur: %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|pi
operator|->
name|ipi_pidx
argument_list|,
name|cur
argument_list|)
expr_stmt|;
return|return
operator|(
name|cur
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TSO_WORKAROUND
value|4
end_define

begin_define
define|#
directive|define
name|DONT_FORCE_CTX
value|1
end_define

begin_comment
comment|/*********************************************************************  *  The offload context is protocol specific (TCP/UDP) and thus  *  only needs to be set when the protocol changes. The occasion  *  of a context change can be a performance detriment, and  *  might be better just disabled. The reason arises in the way  *  in which the controller supports pipelined requests from the  *  Tx data DMA. Up to four requests can be pipelined, and they may  *  belong to the same packet or to multiple packets. However all  *  requests for one packet are issued before a request is issued  *  for a subsequent packet and if a request for the next packet  *  requires a context change, that request will be stalled  *  until the previous request completes. This means setting up  *  a new context effectively disables pipelined Tx data DMA which  *  in turn greatly slow down performance to send small sized  *  frames.  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_transmit_checksum_setup
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|,
name|u32
modifier|*
name|txd_upper
parameter_list|,
name|u32
modifier|*
name|txd_lower
parameter_list|)
block|{
name|struct
name|e1000_context_desc
modifier|*
name|TXD
init|=
name|NULL
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|adapter
operator|->
name|shared
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|que
init|=
operator|&
name|adapter
operator|->
name|tx_queues
index|[
name|pi
operator|->
name|ipi_qsidx
index|]
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|int
name|csum_flags
init|=
name|pi
operator|->
name|ipi_csum_flags
decl_stmt|;
name|int
name|cur
decl_stmt|,
name|hdr_len
decl_stmt|;
name|u32
name|cmd
decl_stmt|;
name|cur
operator|=
name|pi
operator|->
name|ipi_pidx
expr_stmt|;
name|hdr_len
operator|=
name|pi
operator|->
name|ipi_ehdrlen
operator|+
name|pi
operator|->
name|ipi_ip_hlen
expr_stmt|;
name|cmd
operator|=
name|adapter
operator|->
name|txd_cmd
expr_stmt|;
comment|/* 	 * The 82574L can only remember the *last* context used 	 * regardless of queue that it was use for.  We cannot reuse 	 * contexts on this hardware platform and must generate a new 	 * context every time.  82574L hardware spec, section 7.2.6, 	 * second note. 	 */
if|if
condition|(
name|DONT_FORCE_CTX
operator|&&
name|adapter
operator|->
name|tx_num_queues
operator|==
literal|1
operator|&&
name|txr
operator|->
name|csum_lhlen
operator|==
name|pi
operator|->
name|ipi_ehdrlen
operator|&&
name|txr
operator|->
name|csum_iphlen
operator|==
name|pi
operator|->
name|ipi_ip_hlen
operator|&&
name|txr
operator|->
name|csum_flags
operator|==
name|csum_flags
condition|)
block|{
comment|/* 		 * Same csum offload context as the previous packets; 		 * just return. 		 */
operator|*
name|txd_upper
operator|=
name|txr
operator|->
name|csum_txd_upper
expr_stmt|;
operator|*
name|txd_lower
operator|=
name|txr
operator|->
name|csum_txd_lower
expr_stmt|;
return|return
operator|(
name|cur
operator|)
return|;
block|}
name|TXD
operator|=
operator|(
expr|struct
name|e1000_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|cur
index|]
expr_stmt|;
if|if
condition|(
name|csum_flags
operator|&
name|CSUM_IP
condition|)
block|{
operator|*
name|txd_upper
operator||=
name|E1000_TXD_POPTS_IXSM
operator|<<
literal|8
expr_stmt|;
comment|/* 		 * Start offset for header checksum calculation. 		 * End offset for header checksum calculation. 		 * Offset of place to put the checksum. 		 */
name|TXD
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcss
operator|=
name|pi
operator|->
name|ipi_ehdrlen
expr_stmt|;
name|TXD
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcse
operator|=
name|htole16
argument_list|(
name|hdr_len
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|lower_setup
operator|.
name|ip_fields
operator|.
name|ipcso
operator|=
name|pi
operator|->
name|ipi_ehdrlen
operator|+
name|offsetof
argument_list|(
expr|struct
name|ip
argument_list|,
name|ip_sum
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|E1000_TXD_CMD_IP
expr_stmt|;
block|}
if|if
condition|(
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
condition|)
block|{
name|uint8_t
name|tucso
decl_stmt|;
operator|*
name|txd_upper
operator||=
name|E1000_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
operator|*
name|txd_lower
operator|=
name|E1000_TXD_CMD_DEXT
operator||
name|E1000_TXD_DTYP_D
expr_stmt|;
if|if
condition|(
name|csum_flags
operator|&
name|CSUM_TCP
condition|)
block|{
name|tucso
operator|=
name|hdr_len
operator|+
name|offsetof
argument_list|(
expr|struct
name|tcphdr
argument_list|,
name|th_sum
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|E1000_TXD_CMD_TCP
expr_stmt|;
block|}
else|else
name|tucso
operator|=
name|hdr_len
operator|+
name|offsetof
argument_list|(
expr|struct
name|udphdr
argument_list|,
name|uh_sum
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucss
operator|=
name|hdr_len
expr_stmt|;
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucse
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|upper_setup
operator|.
name|tcp_fields
operator|.
name|tucso
operator|=
name|tucso
expr_stmt|;
block|}
name|txr
operator|->
name|csum_lhlen
operator|=
name|pi
operator|->
name|ipi_ehdrlen
expr_stmt|;
name|txr
operator|->
name|csum_iphlen
operator|=
name|pi
operator|->
name|ipi_ip_hlen
expr_stmt|;
name|txr
operator|->
name|csum_flags
operator|=
name|csum_flags
expr_stmt|;
name|txr
operator|->
name|csum_txd_upper
operator|=
operator|*
name|txd_upper
expr_stmt|;
name|txr
operator|->
name|csum_txd_lower
operator|=
operator|*
name|txd_lower
expr_stmt|;
name|TXD
operator|->
name|tcp_seg_setup
operator|.
name|data
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|cmd_and_length
operator|=
name|htole32
argument_list|(
name|E1000_TXD_CMD_IFCS
operator||
name|E1000_TXD_CMD_DEXT
operator||
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|cur
operator|==
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
condition|)
block|{
name|cur
operator|=
literal|0
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|iflib_get_dev
argument_list|(
name|adapter
operator|->
name|ctx
argument_list|)
argument_list|,
literal|"checksum_setup csum_flags=%x txd_upper=%x txd_lower=%x hdr_len=%d cmd=%x\n"
argument_list|,
name|csum_flags
argument_list|,
operator|*
name|txd_upper
argument_list|,
operator|*
name|txd_lower
argument_list|,
name|hdr_len
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|cur
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_isc_txd_encap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|sc
operator|->
name|shared
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|que
init|=
operator|&
name|sc
operator|->
name|tx_queues
index|[
name|pi
operator|->
name|ipi_qsidx
index|]
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
init|=
name|pi
operator|->
name|ipi_segs
decl_stmt|;
name|int
name|nsegs
init|=
name|pi
operator|->
name|ipi_nsegs
decl_stmt|;
name|int
name|csum_flags
init|=
name|pi
operator|->
name|ipi_csum_flags
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|first
decl_stmt|,
name|pidx_last
decl_stmt|;
name|u32
name|txd_flags
decl_stmt|,
name|txd_upper
init|=
literal|0
decl_stmt|,
name|txd_lower
init|=
literal|0
decl_stmt|;
name|struct
name|e1000_tx_desc
modifier|*
name|ctxd
init|=
name|NULL
decl_stmt|;
name|bool
name|do_tso
decl_stmt|,
name|tso_desc
decl_stmt|;
name|qidx_t
name|ntxd
decl_stmt|;
name|txd_flags
operator|=
name|pi
operator|->
name|ipi_flags
operator|&
name|IPI_TX_INTR
condition|?
name|E1000_TXD_CMD_RS
else|:
literal|0
expr_stmt|;
name|i
operator|=
name|first
operator|=
name|pi
operator|->
name|ipi_pidx
expr_stmt|;
name|do_tso
operator|=
operator|(
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
expr_stmt|;
name|tso_desc
operator|=
name|FALSE
expr_stmt|;
name|ntxd
operator|=
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * TSO Hardware workaround, if this packet is not 	 * TSO, and is only a single descriptor long, and 	 * it follows a TSO burst, then we need to add a 	 * sentinel descriptor to prevent premature writeback. 	 */
if|if
condition|(
operator|(
operator|!
name|do_tso
operator|)
operator|&&
operator|(
name|txr
operator|->
name|tx_tso
operator|==
name|TRUE
operator|)
condition|)
block|{
if|if
condition|(
name|nsegs
operator|==
literal|1
condition|)
name|tso_desc
operator|=
name|TRUE
expr_stmt|;
name|txr
operator|->
name|tx_tso
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Do hardware assists */
if|if
condition|(
name|do_tso
condition|)
block|{
name|i
operator|=
name|em_tso_setup
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
operator|&
name|txd_upper
argument_list|,
operator|&
name|txd_lower
argument_list|)
expr_stmt|;
name|tso_desc
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|csum_flags
operator|&
name|EM_CSUM_OFFLOAD
condition|)
block|{
name|i
operator|=
name|em_transmit_checksum_setup
argument_list|(
name|sc
argument_list|,
name|pi
argument_list|,
operator|&
name|txd_upper
argument_list|,
operator|&
name|txd_lower
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pi
operator|->
name|ipi_mflags
operator|&
name|M_VLANTAG
condition|)
block|{
comment|/* Set the vlan id. */
name|txd_upper
operator||=
name|htole16
argument_list|(
name|pi
operator|->
name|ipi_vtag
argument_list|)
operator|<<
literal|16
expr_stmt|;
comment|/* Tell hardware to add tag */
name|txd_lower
operator||=
name|htole32
argument_list|(
name|E1000_TXD_CMD_VLE
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|iflib_get_dev
argument_list|(
name|sc
operator|->
name|ctx
argument_list|)
argument_list|,
literal|"encap: set up tx: nsegs=%d first=%d i=%d\n"
argument_list|,
name|nsegs
argument_list|,
name|first
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* XXX adapter->pcix_82544 -- lem_fill_descriptors */
comment|/* Set up our transmit descriptors */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsegs
condition|;
name|j
operator|++
control|)
block|{
name|bus_size_t
name|seg_len
decl_stmt|;
name|bus_addr_t
name|seg_addr
decl_stmt|;
name|uint32_t
name|cmd
decl_stmt|;
name|ctxd
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|i
index|]
expr_stmt|;
name|seg_addr
operator|=
name|segs
index|[
name|j
index|]
operator|.
name|ds_addr
expr_stmt|;
name|seg_len
operator|=
name|segs
index|[
name|j
index|]
operator|.
name|ds_len
expr_stmt|;
name|cmd
operator|=
name|E1000_TXD_CMD_IFCS
operator||
name|sc
operator|->
name|txd_cmd
expr_stmt|;
comment|/* 		 * TSO Workaround: 		 * If this is the last descriptor, we want to 		 * split it so we have a small final sentinel 		 */
if|if
condition|(
name|tso_desc
operator|&&
operator|(
name|j
operator|==
operator|(
name|nsegs
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|seg_len
operator|>
literal|8
operator|)
condition|)
block|{
name|seg_len
operator|-=
name|TSO_WORKAROUND
expr_stmt|;
name|ctxd
operator|->
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|seg_addr
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|lower
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|cmd
operator||
name|txd_lower
operator||
name|seg_len
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|upper
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|txd_upper
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Now make the sentinel */
name|ctxd
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|i
index|]
expr_stmt|;
name|ctxd
operator|->
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|seg_addr
operator|+
name|seg_len
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|lower
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|cmd
operator||
name|txd_lower
operator||
name|TSO_WORKAROUND
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|upper
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|txd_upper
argument_list|)
expr_stmt|;
name|pidx_last
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|iflib_get_dev
argument_list|(
name|sc
operator|->
name|ctx
argument_list|)
argument_list|,
literal|"TSO path pidx_last=%d i=%d ntxd[0]=%d\n"
argument_list|,
name|pidx_last
argument_list|,
name|i
argument_list|,
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctxd
operator|->
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|seg_addr
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|lower
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|cmd
operator||
name|txd_lower
operator||
name|seg_len
argument_list|)
expr_stmt|;
name|ctxd
operator|->
name|upper
operator|.
name|data
operator|=
name|htole32
argument_list|(
name|txd_upper
argument_list|)
expr_stmt|;
name|pidx_last
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|iflib_get_dev
argument_list|(
name|sc
operator|->
name|ctx
argument_list|)
argument_list|,
literal|"pidx_last=%d i=%d ntxd[0]=%d\n"
argument_list|,
name|pidx_last
argument_list|,
name|i
argument_list|,
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Last Descriptor of Packet 	 * needs End Of Packet (EOP) 	 * and Report Status (RS) 	 */
if|if
condition|(
name|txd_flags
condition|)
block|{
name|txr
operator|->
name|tx_rsq
index|[
name|txr
operator|->
name|tx_rs_pidx
index|]
operator|=
name|pidx_last
expr_stmt|;
name|DPRINTF
argument_list|(
name|iflib_get_dev
argument_list|(
name|sc
operator|->
name|ctx
argument_list|)
argument_list|,
literal|"setting to RS on %d rs_pidx %d first: %d\n"
argument_list|,
name|pidx_last
argument_list|,
name|txr
operator|->
name|tx_rs_pidx
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tx_rs_pidx
operator|=
operator|(
name|txr
operator|->
name|tx_rs_pidx
operator|+
literal|1
operator|)
operator|&
operator|(
name|ntxd
operator|-
literal|1
operator|)
expr_stmt|;
name|MPASS
argument_list|(
name|txr
operator|->
name|tx_rs_pidx
operator|!=
name|txr
operator|->
name|tx_rs_cidx
argument_list|)
expr_stmt|;
block|}
name|ctxd
operator|->
name|lower
operator|.
name|data
operator||=
name|htole32
argument_list|(
name|E1000_TXD_CMD_EOP
operator||
name|txd_flags
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|iflib_get_dev
argument_list|(
name|sc
operator|->
name|ctx
argument_list|)
argument_list|,
literal|"tx_buffers[%d]->eop = %d ipi_new_pidx=%d\n"
argument_list|,
name|first
argument_list|,
name|pidx_last
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pi
operator|->
name|ipi_new_pidx
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|em_isc_txd_flush
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|txqid
parameter_list|,
name|qidx_t
name|pidx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|que
init|=
operator|&
name|adapter
operator|->
name|tx_queues
index|[
name|txqid
index|]
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|E1000_TDT
argument_list|(
name|txr
operator|->
name|me
argument_list|)
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_isc_txd_credits_update
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|txqid
parameter_list|,
name|bool
name|clear
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|adapter
operator|->
name|shared
decl_stmt|;
name|struct
name|em_tx_queue
modifier|*
name|que
init|=
operator|&
name|adapter
operator|->
name|tx_queues
index|[
name|txqid
index|]
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|qidx_t
name|processed
init|=
literal|0
decl_stmt|;
name|int
name|updated
decl_stmt|;
name|qidx_t
name|cur
decl_stmt|,
name|prev
decl_stmt|,
name|ntxd
decl_stmt|,
name|rs_cidx
decl_stmt|;
name|int32_t
name|delta
decl_stmt|;
name|uint8_t
name|status
decl_stmt|;
name|rs_cidx
operator|=
name|txr
operator|->
name|tx_rs_cidx
expr_stmt|;
if|if
condition|(
name|rs_cidx
operator|==
name|txr
operator|->
name|tx_rs_pidx
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cur
operator|=
name|txr
operator|->
name|tx_rsq
index|[
name|rs_cidx
index|]
expr_stmt|;
name|MPASS
argument_list|(
name|cur
operator|!=
name|QIDX_INVALID
argument_list|)
expr_stmt|;
name|status
operator|=
name|txr
operator|->
name|tx_base
index|[
name|cur
index|]
operator|.
name|upper
operator|.
name|fields
operator|.
name|status
expr_stmt|;
name|updated
operator|=
operator|!
operator|!
operator|(
name|status
operator|&
name|E1000_TXD_STAT_DD
operator|)
expr_stmt|;
if|if
condition|(
name|clear
operator|==
name|false
operator|||
name|updated
operator|==
literal|0
condition|)
return|return
operator|(
name|updated
operator|)
return|;
name|prev
operator|=
name|txr
operator|->
name|tx_cidx_processed
expr_stmt|;
name|ntxd
operator|=
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
expr_stmt|;
do|do
block|{
name|delta
operator|=
operator|(
name|int32_t
operator|)
name|cur
operator|-
operator|(
name|int32_t
operator|)
name|prev
expr_stmt|;
name|MPASS
argument_list|(
name|prev
operator|==
literal|0
operator|||
name|delta
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|+=
name|ntxd
expr_stmt|;
name|DPRINTF
argument_list|(
name|iflib_get_dev
argument_list|(
name|adapter
operator|->
name|ctx
argument_list|)
argument_list|,
literal|"%s: cidx_processed=%u cur=%u clear=%d delta=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|prev
argument_list|,
name|cur
argument_list|,
name|clear
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|processed
operator|+=
name|delta
expr_stmt|;
name|prev
operator|=
name|cur
expr_stmt|;
name|rs_cidx
operator|=
operator|(
name|rs_cidx
operator|+
literal|1
operator|)
operator|&
operator|(
name|ntxd
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rs_cidx
operator|==
name|txr
operator|->
name|tx_rs_pidx
condition|)
break|break;
name|cur
operator|=
name|txr
operator|->
name|tx_rsq
index|[
name|rs_cidx
index|]
expr_stmt|;
name|MPASS
argument_list|(
name|cur
operator|!=
name|QIDX_INVALID
argument_list|)
expr_stmt|;
name|status
operator|=
name|txr
operator|->
name|tx_base
index|[
name|cur
index|]
operator|.
name|upper
operator|.
name|fields
operator|.
name|status
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|status
operator|&
name|E1000_TXD_STAT_DD
operator|)
condition|)
do|;
name|txr
operator|->
name|tx_rs_cidx
operator|=
name|rs_cidx
expr_stmt|;
name|txr
operator|->
name|tx_cidx_processed
operator|=
name|prev
expr_stmt|;
return|return
operator|(
name|processed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lem_isc_rxd_refill
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_rxd_update_t
name|iru
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|sc
operator|->
name|shared
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
init|=
operator|&
name|sc
operator|->
name|rx_queues
index|[
name|iru
operator|->
name|iru_qsidx
index|]
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|e1000_rx_desc
modifier|*
name|rxd
decl_stmt|;
name|uint64_t
modifier|*
name|paddrs
decl_stmt|;
name|uint32_t
name|next_pidx
decl_stmt|,
name|pidx
decl_stmt|;
name|uint16_t
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|paddrs
operator|=
name|iru
operator|->
name|iru_paddrs
expr_stmt|;
name|pidx
operator|=
name|iru
operator|->
name|iru_pidx
expr_stmt|;
name|count
operator|=
name|iru
operator|->
name|iru_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|next_pidx
operator|=
name|pidx
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|(
expr|struct
name|e1000_rx_desc
operator|*
operator|)
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|next_pidx
index|]
expr_stmt|;
name|rxd
operator|->
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|paddrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* status bits must be cleared */
name|rxd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|next_pidx
operator|==
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
condition|)
name|next_pidx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|em_isc_rxd_refill
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_rxd_update_t
name|iru
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|sc
operator|->
name|shared
decl_stmt|;
name|uint16_t
name|rxqid
init|=
name|iru
operator|->
name|iru_qsidx
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
init|=
operator|&
name|sc
operator|->
name|rx_queues
index|[
name|rxqid
index|]
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|union
name|e1000_rx_desc_extended
modifier|*
name|rxd
decl_stmt|;
name|uint64_t
modifier|*
name|paddrs
decl_stmt|;
name|uint32_t
name|next_pidx
decl_stmt|,
name|pidx
decl_stmt|;
name|uint16_t
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|paddrs
operator|=
name|iru
operator|->
name|iru_paddrs
expr_stmt|;
name|pidx
operator|=
name|iru
operator|->
name|iru_pidx
expr_stmt|;
name|count
operator|=
name|iru
operator|->
name|iru_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|next_pidx
operator|=
name|pidx
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|next_pidx
index|]
expr_stmt|;
name|rxd
operator|->
name|read
operator|.
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|paddrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* DD bits must be cleared */
name|rxd
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|next_pidx
operator|==
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
condition|)
name|next_pidx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|em_isc_rxd_flush
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|uint8_t
name|flid
name|__unused
parameter_list|,
name|qidx_t
name|pidx
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
init|=
operator|&
name|sc
operator|->
name|rx_queues
index|[
name|rxqid
index|]
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|E1000_WRITE_REG
argument_list|(
operator|&
name|sc
operator|->
name|hw
argument_list|,
name|E1000_RDT
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lem_isc_rxd_available
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|qidx_t
name|idx
parameter_list|,
name|qidx_t
name|budget
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|sc
operator|->
name|shared
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
init|=
operator|&
name|sc
operator|->
name|rx_queues
index|[
name|rxqid
index|]
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|e1000_rx_desc
modifier|*
name|rxd
decl_stmt|;
name|u32
name|staterr
init|=
literal|0
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|budget
operator|==
literal|1
condition|)
block|{
name|rxd
operator|=
operator|(
expr|struct
name|e1000_rx_desc
operator|*
operator|)
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|idx
index|]
expr_stmt|;
name|staterr
operator|=
name|rxd
operator|->
name|status
expr_stmt|;
return|return
operator|(
name|staterr
operator|&
name|E1000_RXD_STAT_DD
operator|)
return|;
block|}
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|i
operator|=
name|idx
init|;
name|cnt
operator|<
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
operator|&&
name|cnt
operator|<=
name|budget
condition|;
control|)
block|{
name|rxd
operator|=
operator|(
expr|struct
name|e1000_rx_desc
operator|*
operator|)
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
expr_stmt|;
name|staterr
operator|=
name|rxd
operator|->
name|status
expr_stmt|;
if|if
condition|(
operator|(
name|staterr
operator|&
name|E1000_RXD_STAT_DD
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|++
name|i
operator|==
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
condition|)
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|staterr
operator|&
name|E1000_RXD_STAT_EOP
condition|)
name|cnt
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_isc_rxd_available
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint16_t
name|rxqid
parameter_list|,
name|qidx_t
name|idx
parameter_list|,
name|qidx_t
name|budget
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|sc
operator|->
name|shared
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
init|=
operator|&
name|sc
operator|->
name|rx_queues
index|[
name|rxqid
index|]
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|union
name|e1000_rx_desc_extended
modifier|*
name|rxd
decl_stmt|;
name|u32
name|staterr
init|=
literal|0
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|budget
operator|==
literal|1
condition|)
block|{
name|rxd
operator|=
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|idx
index|]
expr_stmt|;
name|staterr
operator|=
name|le32toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
argument_list|)
expr_stmt|;
return|return
operator|(
name|staterr
operator|&
name|E1000_RXD_STAT_DD
operator|)
return|;
block|}
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|i
operator|=
name|idx
init|;
name|cnt
operator|<
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
operator|&&
name|cnt
operator|<=
name|budget
condition|;
control|)
block|{
name|rxd
operator|=
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
expr_stmt|;
name|staterr
operator|=
name|le32toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|staterr
operator|&
name|E1000_RXD_STAT_DD
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|++
name|i
operator|==
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|staterr
operator|&
name|E1000_RXD_STAT_EOP
condition|)
name|cnt
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lem_isc_rxd_pkt_get
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|adapter
operator|->
name|shared
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
init|=
operator|&
name|adapter
operator|->
name|rx_queues
index|[
name|ri
operator|->
name|iri_qsidx
index|]
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|e1000_rx_desc
modifier|*
name|rxd
decl_stmt|;
name|u16
name|len
decl_stmt|;
name|u32
name|status
decl_stmt|,
name|errors
decl_stmt|;
name|bool
name|eop
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cidx
decl_stmt|;
name|status
operator|=
name|errors
operator|=
name|i
operator|=
literal|0
expr_stmt|;
name|cidx
operator|=
name|ri
operator|->
name|iri_cidx
expr_stmt|;
do|do
block|{
name|rxd
operator|=
operator|(
expr|struct
name|e1000_rx_desc
operator|*
operator|)
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|cidx
index|]
expr_stmt|;
name|status
operator|=
name|rxd
operator|->
name|status
expr_stmt|;
name|errors
operator|=
name|rxd
operator|->
name|errors
expr_stmt|;
comment|/* Error Checking then decrement count */
name|MPASS
argument_list|(
operator|(
name|status
operator|&
name|E1000_RXD_STAT_DD
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|rxd
operator|->
name|length
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_len
operator|+=
name|len
expr_stmt|;
name|eop
operator|=
operator|(
name|status
operator|&
name|E1000_RXD_STAT_EOP
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* Make sure bad packets are discarded */
if|if
condition|(
name|errors
operator|&
name|E1000_RXD_ERR_FRAME_ERR_MASK
condition|)
block|{
name|adapter
operator|->
name|dropped_pkts
operator|++
expr_stmt|;
comment|/* XXX fixup if common */
return|return
operator|(
name|EBADMSG
operator|)
return|;
block|}
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_flid
operator|=
literal|0
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_idx
operator|=
name|cidx
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_len
operator|=
name|len
expr_stmt|;
comment|/* Zero out the receive descriptors status. */
name|rxd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|cidx
operator|==
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
condition|)
name|cidx
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|eop
condition|)
do|;
comment|/* XXX add a faster way to look this up */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82543
operator|&&
operator|!
operator|(
name|status
operator|&
name|E1000_RXD_STAT_IXSM
operator|)
condition|)
name|lem_receive_checksum
argument_list|(
name|status
argument_list|,
name|errors
argument_list|,
name|ri
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_RXD_STAT_VP
condition|)
block|{
name|ri
operator|->
name|iri_vtag
operator|=
name|le16toh
argument_list|(
name|rxd
operator|->
name|special
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
name|ri
operator|->
name|iri_nfrags
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|em_isc_rxd_pkt_get
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|arg
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
name|adapter
operator|->
name|shared
decl_stmt|;
name|struct
name|em_rx_queue
modifier|*
name|que
init|=
operator|&
name|adapter
operator|->
name|rx_queues
index|[
name|ri
operator|->
name|iri_qsidx
index|]
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|union
name|e1000_rx_desc_extended
modifier|*
name|rxd
decl_stmt|;
name|u16
name|len
decl_stmt|;
name|u32
name|pkt_info
decl_stmt|;
name|u32
name|staterr
init|=
literal|0
decl_stmt|;
name|bool
name|eop
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cidx
decl_stmt|,
name|vtag
decl_stmt|;
name|i
operator|=
name|vtag
operator|=
literal|0
expr_stmt|;
name|cidx
operator|=
name|ri
operator|->
name|iri_cidx
expr_stmt|;
do|do
block|{
name|rxd
operator|=
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|cidx
index|]
expr_stmt|;
name|staterr
operator|=
name|le32toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
argument_list|)
expr_stmt|;
name|pkt_info
operator|=
name|le32toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|lower
operator|.
name|mrq
argument_list|)
expr_stmt|;
comment|/* Error Checking then decrement count */
name|MPASS
argument_list|(
operator|(
name|staterr
operator|&
name|E1000_RXD_STAT_DD
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|upper
operator|.
name|length
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_len
operator|+=
name|len
expr_stmt|;
name|eop
operator|=
operator|(
name|staterr
operator|&
name|E1000_RXD_STAT_EOP
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* Make sure bad packets are discarded */
if|if
condition|(
name|staterr
operator|&
name|E1000_RXDEXT_ERR_FRAME_ERR_MASK
condition|)
block|{
name|adapter
operator|->
name|dropped_pkts
operator|++
expr_stmt|;
return|return
name|EBADMSG
return|;
block|}
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_flid
operator|=
literal|0
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_idx
operator|=
name|cidx
expr_stmt|;
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_len
operator|=
name|len
expr_stmt|;
comment|/* Zero out the receive descriptors status. */
name|rxd
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
operator|&=
name|htole32
argument_list|(
operator|~
literal|0xFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|cidx
operator|==
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
condition|)
name|cidx
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|eop
condition|)
do|;
comment|/* XXX add a faster way to look this up */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|>=
name|e1000_82543
condition|)
name|em_receive_checksum
argument_list|(
name|staterr
argument_list|,
name|ri
argument_list|)
expr_stmt|;
if|if
condition|(
name|staterr
operator|&
name|E1000_RXD_STAT_VP
condition|)
block|{
name|vtag
operator|=
name|le16toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|upper
operator|.
name|vlan
argument_list|)
expr_stmt|;
block|}
name|ri
operator|->
name|iri_vtag
operator|=
name|vtag
expr_stmt|;
if|if
condition|(
name|vtag
condition|)
name|ri
operator|->
name|iri_flags
operator||=
name|M_VLANTAG
expr_stmt|;
name|ri
operator|->
name|iri_flowid
operator|=
name|le32toh
argument_list|(
name|rxd
operator|->
name|wb
operator|.
name|lower
operator|.
name|hi_dword
operator|.
name|rss
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_rsstype
operator|=
name|em_determine_rsstype
argument_list|(
name|pkt_info
argument_list|)
expr_stmt|;
name|ri
operator|->
name|iri_nfrags
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Verify that the hardware indicated that the checksum is valid.  *  Inform the stack about the status of checksum so that stack  *  doesn't spend time verifying the checksum.  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|lem_receive_checksum
parameter_list|(
name|int
name|status
parameter_list|,
name|int
name|errors
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|)
block|{
comment|/* Did it pass? */
if|if
condition|(
name|status
operator|&
name|E1000_RXD_STAT_IPCS
operator|&&
operator|!
operator|(
name|errors
operator|&
name|E1000_RXD_ERR_IPE
operator|)
condition|)
name|ri
operator|->
name|iri_csum_flags
operator|=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1000_RXD_STAT_TCPCS
condition|)
block|{
comment|/* Did it pass? */
if|if
condition|(
operator|!
operator|(
name|errors
operator|&
name|E1000_RXD_ERR_TCPE
operator|)
condition|)
block|{
name|ri
operator|->
name|iri_csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|ri
operator|->
name|iri_csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/********************************************************************  *  *  Parse the packet type to determine the appropriate hash  *  ******************************************************************/
end_comment

begin_function
specifier|static
name|int
name|em_determine_rsstype
parameter_list|(
name|u32
name|pkt_info
parameter_list|)
block|{
switch|switch
condition|(
name|pkt_info
operator|&
name|E1000_RXDADV_RSSTYPE_MASK
condition|)
block|{
case|case
name|E1000_RXDADV_RSSTYPE_IPV4_TCP
case|:
return|return
name|M_HASHTYPE_RSS_TCP_IPV4
return|;
case|case
name|E1000_RXDADV_RSSTYPE_IPV4
case|:
return|return
name|M_HASHTYPE_RSS_IPV4
return|;
case|case
name|E1000_RXDADV_RSSTYPE_IPV6_TCP
case|:
return|return
name|M_HASHTYPE_RSS_TCP_IPV6
return|;
case|case
name|E1000_RXDADV_RSSTYPE_IPV6_EX
case|:
return|return
name|M_HASHTYPE_RSS_IPV6_EX
return|;
case|case
name|E1000_RXDADV_RSSTYPE_IPV6
case|:
return|return
name|M_HASHTYPE_RSS_IPV6
return|;
case|case
name|E1000_RXDADV_RSSTYPE_IPV6_TCP_EX
case|:
return|return
name|M_HASHTYPE_RSS_TCP_IPV6_EX
return|;
default|default:
return|return
name|M_HASHTYPE_OPAQUE
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|em_receive_checksum
parameter_list|(
name|uint32_t
name|status
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|)
block|{
name|ri
operator|->
name|iri_csum_flags
operator|=
literal|0
expr_stmt|;
comment|/* Ignore Checksum bit is set */
if|if
condition|(
name|status
operator|&
name|E1000_RXD_STAT_IXSM
condition|)
return|return;
comment|/* If the IP checksum exists and there is no IP Checksum error */
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|E1000_RXD_STAT_IPCS
operator||
name|E1000_RXDEXT_STATERR_IPE
operator|)
operator|)
operator|==
name|E1000_RXD_STAT_IPCS
condition|)
block|{
name|ri
operator|->
name|iri_csum_flags
operator|=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator|)
expr_stmt|;
block|}
comment|/* TCP or UDP checksum */
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|E1000_RXD_STAT_TCPCS
operator||
name|E1000_RXDEXT_STATERR_TCPE
operator|)
operator|)
operator|==
name|E1000_RXD_STAT_TCPCS
condition|)
block|{
name|ri
operator|->
name|iri_csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|ri
operator|->
name|iri_csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|E1000_RXD_STAT_UDPCS
condition|)
block|{
name|ri
operator|->
name|iri_csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|ri
operator|->
name|iri_csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

