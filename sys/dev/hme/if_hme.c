begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 The NetBSD Foundation, Inc.  * Copyright (c) 2001-2003 Thomas Moestl<tmm@FreeBSD.org>.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Paul Kranenburg.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  *	from: NetBSD: hme.c,v 1.35 2003/02/27 14:58:22 pk Exp  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * HME Ethernet module driver.  *  * The HME is e.g. part of the PCIO PCI multi function device.  * It supports TX gathering and TX and RX checksum offloading.  * RX buffers must be aligned at a programmable offset modulo 16. We choose 2  * for this offset: mbuf clusters are usually on about 2^11 boundaries, 2 bytes  * are skipped to make sure the header after the ethernet header is aligned on a  * natural boundary, so this ensures minimal wastage in the most common case.  *  * Also, apparently, the buffers must extend to a DMA burst boundary beyond the  * maximum packet size (this is not verified). Buffers starting on odd  * boundaries must be mapped so that the burst can start on a natural boundary.  *  * STP2002QFP-UG says that Ethernet hardware supports TCP checksum offloading.  * In reality, we can do the same technique for UDP datagram too. However,  * the hardware doesn't compensate the checksum for UDP datagram which can yield  * to 0x0. As a safe guard, UDP checksum offload is disabled by default. It  * can be reactivated by setting special link option link0 with ifconfig(8).  */
end_comment

begin_define
define|#
directive|define
name|HME_CSUM_FEATURES
value|(CSUM_TCP)
end_define

begin_define
define|#
directive|define
name|HMEDEBUG
end_define

begin_define
define|#
directive|define
name|KTR_HME
value|KTR_CT2
end_define

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/hme/if_hmereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/hme/if_hmevar.h>
end_include

begin_function_decl
specifier|static
name|void
name|hme_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_stop
parameter_list|(
name|struct
name|hme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hme_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_init_locked
parameter_list|(
name|struct
name|hme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hme_add_rxbuf
parameter_list|(
name|struct
name|hme_softc
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hme_meminit
parameter_list|(
name|struct
name|hme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hme_mac_bitflip
parameter_list|(
name|struct
name|hme_softc
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_mifinit
parameter_list|(
name|struct
name|hme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_setladrf
parameter_list|(
name|struct
name|hme_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hme_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hme_mediachange_locked
parameter_list|(
name|struct
name|hme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hme_load_txmbuf
parameter_list|(
name|struct
name|hme_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_read
parameter_list|(
name|struct
name|hme_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_eint
parameter_list|(
name|struct
name|hme_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_rint
parameter_list|(
name|struct
name|hme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_tint
parameter_list|(
name|struct
name|hme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_txcksum
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_rxcksum
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hme_cdma_callback
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|devclass_t
name|hme_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hme_nerr
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|hme
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|hme
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|HME_SPC_READ_4
parameter_list|(
name|spc
parameter_list|,
name|sc
parameter_list|,
name|offs
parameter_list|)
define|\
value|bus_space_read_4((sc)->sc_ ## spc ## t, (sc)->sc_ ## spc ## h, \ 	    (offs))
end_define

begin_define
define|#
directive|define
name|HME_SPC_WRITE_4
parameter_list|(
name|spc
parameter_list|,
name|sc
parameter_list|,
name|offs
parameter_list|,
name|v
parameter_list|)
define|\
value|bus_space_write_4((sc)->sc_ ## spc ## t, (sc)->sc_ ## spc ## h, \ 	    (offs), (v))
end_define

begin_define
define|#
directive|define
name|HME_SEB_READ_4
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|)
value|HME_SPC_READ_4(seb, (sc), (offs))
end_define

begin_define
define|#
directive|define
name|HME_SEB_WRITE_4
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|,
name|v
parameter_list|)
value|HME_SPC_WRITE_4(seb, (sc), (offs), (v))
end_define

begin_define
define|#
directive|define
name|HME_ERX_READ_4
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|)
value|HME_SPC_READ_4(erx, (sc), (offs))
end_define

begin_define
define|#
directive|define
name|HME_ERX_WRITE_4
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|,
name|v
parameter_list|)
value|HME_SPC_WRITE_4(erx, (sc), (offs), (v))
end_define

begin_define
define|#
directive|define
name|HME_ETX_READ_4
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|)
value|HME_SPC_READ_4(etx, (sc), (offs))
end_define

begin_define
define|#
directive|define
name|HME_ETX_WRITE_4
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|,
name|v
parameter_list|)
value|HME_SPC_WRITE_4(etx, (sc), (offs), (v))
end_define

begin_define
define|#
directive|define
name|HME_MAC_READ_4
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|)
value|HME_SPC_READ_4(mac, (sc), (offs))
end_define

begin_define
define|#
directive|define
name|HME_MAC_WRITE_4
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|,
name|v
parameter_list|)
value|HME_SPC_WRITE_4(mac, (sc), (offs), (v))
end_define

begin_define
define|#
directive|define
name|HME_MIF_READ_4
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|)
value|HME_SPC_READ_4(mif, (sc), (offs))
end_define

begin_define
define|#
directive|define
name|HME_MIF_WRITE_4
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|,
name|v
parameter_list|)
value|HME_SPC_WRITE_4(mif, (sc), (offs), (v))
end_define

begin_define
define|#
directive|define
name|HME_MAXERR
value|5
end_define

begin_define
define|#
directive|define
name|HME_WHINE
parameter_list|(
name|dev
parameter_list|,
modifier|...
parameter_list|)
value|do {					\ 	if (hme_nerr++< HME_MAXERR)					\ 		device_printf(dev, __VA_ARGS__);			\ 	if (hme_nerr == HME_MAXERR) {					\ 		device_printf(dev, "too many errors; not reporting "	\ 		    "any more\n");					\ 	}								\ } while(0)
end_define

begin_comment
comment|/* Support oversized VLAN frames. */
end_comment

begin_define
define|#
directive|define
name|HME_MAX_FRAMESIZE
value|(ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN)
end_define

begin_function
name|int
name|hme_config
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mii_softc
modifier|*
name|child
decl_stmt|;
name|bus_size_t
name|size
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rdesc
decl_stmt|,
name|tdesc
decl_stmt|,
name|i
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 	 * HME common initialization. 	 * 	 * hme_softc fields that must be initialized by the front-end: 	 * 	 * the DMA bus tag: 	 *	sc_dmatag 	 * 	 * the bus handles, tags and offsets (splitted for SBus compatability): 	 *	sc_seb{t,h,o}	(Shared Ethernet Block registers) 	 *	sc_erx{t,h,o}	(Receiver Unit registers) 	 *	sc_etx{t,h,o}	(Transmitter Unit registers) 	 *	sc_mac{t,h,o}	(MAC registers) 	 *	sc_mif{t,h,o}	(Management Interface registers) 	 * 	 * the maximum bus burst size: 	 *	sc_burst 	 * 	 */
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure the chip is stopped. */
name|HME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hme_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate DMA capable memory 	 * Buffer descriptors must be aligned on a 2048 byte boundary; 	 * take this into account when calculating the size. Note that 	 * the maximum number of descriptors (256) occupies 2048 bytes, 	 * so we allocate that much regardless of HME_N*DESC. 	 */
name|size
operator|=
literal|4096
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
name|HME_NTXDESC
operator|+
name|HME_NRXDESC
operator|+
literal|1
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_pdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail_ifnet
goto|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|,
literal|2048
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail_ptag
goto|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|,
name|max
argument_list|(
literal|0x10
argument_list|,
name|sc
operator|->
name|sc_burst
argument_list|)
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
name|HME_NRXDESC
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_rdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail_ctag
goto|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|,
name|max
argument_list|(
literal|0x10
argument_list|,
name|sc
operator|->
name|sc_burst
argument_list|)
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
name|HME_NTXDESC
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_tdmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail_rtag
goto|;
comment|/* Allocate control/TX DMA buffer */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_membase
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_cdmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"DMA buffer alloc error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_ttag
goto|;
block|}
comment|/* Load the buffer */
name|sc
operator|->
name|sc_rb
operator|.
name|rb_dmabase
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cdmamap
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_membase
argument_list|,
name|size
argument_list|,
name|hme_cdma_callback
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|||
name|sc
operator|->
name|sc_rb
operator|.
name|rb_dmabase
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"DMA buffer map load error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_free
goto|;
block|}
name|CTR2
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_config: dma va %p, pa %#lx"
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_membase
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_dmabase
argument_list|)
expr_stmt|;
comment|/* 	 * Prepare the RX descriptors. rdesc serves as marker for the last 	 * processed descriptor and may be used later on. 	 */
for|for
control|(
name|rdesc
operator|=
literal|0
init|;
name|rdesc
operator|<
name|HME_NRXDESC
condition|;
name|rdesc
operator|++
control|)
block|{
name|sc
operator|->
name|sc_rb
operator|.
name|rb_rxdesc
index|[
name|rdesc
index|]
operator|.
name|hrx_m
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_rxdesc
index|[
name|rdesc
index|]
operator|.
name|hrx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail_rxdesc
goto|;
block|}
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_spare_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail_rxdesc
goto|;
comment|/* Same for the TX descs. */
for|for
control|(
name|tdesc
operator|=
literal|0
init|;
name|tdesc
operator|<
name|HME_NTXQ
condition|;
name|tdesc
operator|++
control|)
block|{
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txdesc
index|[
name|tdesc
index|]
operator|.
name|htx_m
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txdesc
index|[
name|tdesc
index|]
operator|.
name|htx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail_txdesc
goto|;
block|}
name|sc
operator|->
name|sc_csum_features
operator|=
name|HME_CSUM_FEATURES
expr_stmt|;
comment|/* Initialize ifnet structure. */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|hme_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|hme_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|hme_init
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|hme_watchdog
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|HME_NTXQ
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|HME_NTXQ
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|hme_mifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_miibus
argument_list|,
name|hme_mediachange
argument_list|,
name|hme_mediastatus
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"phy probe failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail_rxdesc
goto|;
block|}
name|sc
operator|->
name|sc_mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
comment|/* 	 * Walk along the list of attached MII devices and 	 * establish an `MII instance' to `PHY number' 	 * mapping. We'll use this mapping to enable the MII 	 * drivers of the external transceiver according to 	 * the currently selected media. 	 */
name|sc
operator|->
name|sc_phys
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_phys
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|child
argument_list|,
argument|&sc->sc_mii->mii_phys
argument_list|,
argument|mii_list
argument_list|)
block|{
comment|/* 		 * Note: we support just two PHYs: the built-in 		 * internal device and an external on the MII 		 * connector. 		 */
if|if
condition|(
operator|(
name|child
operator|->
name|mii_phy
operator|!=
name|HME_PHYAD_EXTERNAL
operator|&&
name|child
operator|->
name|mii_phy
operator|!=
name|HME_PHYAD_INTERNAL
operator|)
operator|||
name|child
operator|->
name|mii_inst
operator|>
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot accommodate "
literal|"MII device %s at phy %d, instance %d\n"
argument_list|,
name|device_get_name
argument_list|(
name|child
operator|->
name|mii_dev
argument_list|)
argument_list|,
name|child
operator|->
name|mii_phy
argument_list|,
name|child
operator|->
name|mii_inst
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|sc_phys
index|[
name|child
operator|->
name|mii_inst
index|]
operator|=
name|child
operator|->
name|mii_phy
expr_stmt|;
block|}
comment|/* Attach the interface. */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames/checksum offloads. 	 */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
name|sc
operator|->
name|sc_csum_features
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_HWCSUM
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail_txdesc
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tdesc
condition|;
name|i
operator|++
control|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txdesc
index|[
name|i
index|]
operator|.
name|htx_dmamap
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_spare_dmamap
argument_list|)
expr_stmt|;
name|fail_rxdesc
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdesc
condition|;
name|i
operator|++
control|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_rxdesc
index|[
name|i
index|]
operator|.
name|hrx_dmamap
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cdmamap
argument_list|)
expr_stmt|;
name|fail_free
label|:
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_membase
argument_list|,
name|sc
operator|->
name|sc_cdmamap
argument_list|)
expr_stmt|;
name|fail_ttag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|)
expr_stmt|;
name|fail_rtag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|)
expr_stmt|;
name|fail_ctag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|)
expr_stmt|;
name|fail_ptag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|)
expr_stmt|;
name|fail_ifnet
label|:
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|hme_detach
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hme_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_miibus
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HME_NTXQ
condition|;
name|i
operator|++
control|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txdesc
index|[
name|i
index|]
operator|.
name|htx_dmamap
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_spare_dmamap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HME_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_rxdesc
index|[
name|i
index|]
operator|.
name|hrx_dmamap
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cdmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cdmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cdmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_membase
argument_list|,
name|sc
operator|->
name|sc_cdmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_pdmatag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hme_suspend
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|HME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hme_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hme_resume
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|HME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
name|hme_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hme_cdma_callback
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|hme_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|hme_softc
operator|*
operator|)
name|xsc
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"hme_cdma_callback: bad dma segment count"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rb
operator|.
name|rb_dmabase
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hme_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hme_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|HME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
comment|/* 	 * Unload collision counters 	 */
name|ifp
operator|->
name|if_collisions
operator|+=
name|HME_MAC_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_NCCNT
argument_list|)
operator|+
name|HME_MAC_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_FCCNT
argument_list|)
operator|+
name|HME_MAC_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_EXCNT
argument_list|)
operator|+
name|HME_MAC_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_LTCNT
argument_list|)
expr_stmt|;
comment|/* 	 * then clear the hardware counters. 	 */
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_NCCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_FCCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_EXCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_LTCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
name|hz
argument_list|,
name|hme_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hme_stop
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|v
decl_stmt|;
name|int
name|n
decl_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
comment|/* Mask all interrupts */
name|HME_SEB_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_SEBI_IMASK
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Reset transmitter and receiver */
name|HME_SEB_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_SEBI_RESET
argument_list|,
name|HME_SEB_RESET_ETX
operator||
name|HME_SEB_RESET_ERX
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|20
condition|;
name|n
operator|++
control|)
block|{
name|v
operator|=
name|HME_SEB_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_SEBI_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
operator|(
name|HME_SEB_RESET_ETX
operator||
name|HME_SEB_RESET_ERX
operator|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"hme_stop: reset failed\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Discard the contents of an mbuf in the RX ring, freeing the buffer in the  * ring for subsequent use.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|hme_discard_rxbuf
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ix
parameter_list|)
block|{
comment|/* 	 * Dropped a packet, reinitialize the descriptor and turn the 	 * ownership back to the hardware. 	 */
name|HME_XD_SETFLAGS
argument_list|(
name|sc
operator|->
name|sc_pci
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_rxd
argument_list|,
name|ix
argument_list|,
name|HME_XD_OWN
operator||
name|HME_XD_ENCODE_RSIZE
argument_list|(
name|HME_DESC_RXLEN
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_rxdesc
index|[
name|ix
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hme_add_rxbuf
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|ri
parameter_list|,
name|int
name|keepold
parameter_list|)
block|{
name|struct
name|hme_rxdesc
modifier|*
name|rd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|uintptr_t
name|b
decl_stmt|;
name|int
name|a
decl_stmt|,
name|unmap
decl_stmt|,
name|nsegs
decl_stmt|;
name|rd
operator|=
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_rxdesc
index|[
name|ri
index|]
expr_stmt|;
name|unmap
operator|=
name|rd
operator|->
name|hrx_m
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|unmap
operator|&&
name|keepold
condition|)
block|{
comment|/* 		 * Reinitialize the descriptor flags, as they may have been 		 * altered by the hardware. 		 */
name|hme_discard_rxbuf
argument_list|(
name|sc
argument_list|,
name|ri
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
name|b
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uintptr_t
argument_list|)
expr_stmt|;
comment|/* 	 * Required alignment boundary. At least 16 is needed, but since 	 * the mapping must be done in a way that a burst can start on a 	 * natural boundary we might need to extend this. 	 */
name|a
operator|=
name|imax
argument_list|(
name|HME_MINRXALIGN
argument_list|,
name|sc
operator|->
name|sc_burst
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the buffer suitably aligned. The 2 byte offset is removed 	 * when the mbuf is handed up. XXX: this ensures at least 16 byte 	 * alignment of the header adjacent to the ethernet header, which 	 * should be sufficient in all cases. Nevertheless, this second-guesses 	 * ALIGN(). 	 */
name|m_adj
argument_list|(
name|m
argument_list|,
name|roundup2
argument_list|(
name|b
argument_list|,
name|a
argument_list|)
operator|-
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_spare_dmamap
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* If nsegs is wrong then the stack is corrupt */
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"Too many segments returned!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmap
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rd
operator|->
name|hrx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rd
operator|->
name|hrx_dmamap
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
name|rd
operator|->
name|hrx_dmamap
expr_stmt|;
name|rd
operator|->
name|hrx_dmamap
operator|=
name|sc
operator|->
name|sc_rb
operator|.
name|rb_spare_dmamap
expr_stmt|;
name|sc
operator|->
name|sc_rb
operator|.
name|rb_spare_dmamap
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_rdmatag
argument_list|,
name|rd
operator|->
name|hrx_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|HME_XD_SETADDR
argument_list|(
name|sc
operator|->
name|sc_pci
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_rxd
argument_list|,
name|ri
argument_list|,
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|rd
operator|->
name|hrx_m
operator|=
name|m
expr_stmt|;
name|HME_XD_SETFLAGS
argument_list|(
name|sc
operator|->
name|sc_pci
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_rxd
argument_list|,
name|ri
argument_list|,
name|HME_XD_OWN
operator||
name|HME_XD_ENCODE_RSIZE
argument_list|(
name|HME_DESC_RXLEN
argument_list|(
name|sc
argument_list|,
name|rd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hme_meminit
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hme_ring
modifier|*
name|hr
init|=
operator|&
name|sc
operator|->
name|sc_rb
decl_stmt|;
name|struct
name|hme_txdesc
modifier|*
name|td
decl_stmt|;
name|bus_addr_t
name|dma
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|p
operator|=
name|hr
operator|->
name|rb_membase
expr_stmt|;
name|dma
operator|=
name|hr
operator|->
name|rb_dmabase
expr_stmt|;
comment|/* 	 * Allocate transmit descriptors 	 */
name|hr
operator|->
name|rb_txd
operator|=
name|p
expr_stmt|;
name|hr
operator|->
name|rb_txddma
operator|=
name|dma
expr_stmt|;
name|p
operator|+=
name|HME_NTXDESC
operator|*
name|HME_XD_SIZE
expr_stmt|;
name|dma
operator|+=
name|HME_NTXDESC
operator|*
name|HME_XD_SIZE
expr_stmt|;
comment|/* We have reserved descriptor space until the next 2048 byte boundary.*/
name|dma
operator|=
operator|(
name|bus_addr_t
operator|)
name|roundup
argument_list|(
operator|(
name|u_long
operator|)
name|dma
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|roundup
argument_list|(
operator|(
name|u_long
operator|)
name|p
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate receive descriptors 	 */
name|hr
operator|->
name|rb_rxd
operator|=
name|p
expr_stmt|;
name|hr
operator|->
name|rb_rxddma
operator|=
name|dma
expr_stmt|;
name|p
operator|+=
name|HME_NRXDESC
operator|*
name|HME_XD_SIZE
expr_stmt|;
name|dma
operator|+=
name|HME_NRXDESC
operator|*
name|HME_XD_SIZE
expr_stmt|;
comment|/* Again move forward to the next 2048 byte boundary.*/
name|dma
operator|=
operator|(
name|bus_addr_t
operator|)
name|roundup
argument_list|(
operator|(
name|u_long
operator|)
name|dma
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|roundup
argument_list|(
operator|(
name|u_long
operator|)
name|p
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize transmit buffer descriptors 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HME_NTXDESC
condition|;
name|i
operator|++
control|)
block|{
name|HME_XD_SETADDR
argument_list|(
name|sc
operator|->
name|sc_pci
argument_list|,
name|hr
operator|->
name|rb_txd
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HME_XD_SETFLAGS
argument_list|(
name|sc
operator|->
name|sc_pci
argument_list|,
name|hr
operator|->
name|rb_txd
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txfreeq
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txbusyq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HME_NTXQ
condition|;
name|i
operator|++
control|)
block|{
name|td
operator|=
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|htx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|td
operator|->
name|htx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|td
operator|->
name|htx_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|td
operator|->
name|htx_m
argument_list|)
expr_stmt|;
name|td
operator|->
name|htx_m
operator|=
name|NULL
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txfreeq
argument_list|,
name|td
argument_list|,
name|htx_q
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize receive buffer descriptors 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HME_NRXDESC
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|hme_add_rxbuf
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cdmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cdmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|hr
operator|->
name|rb_tdhead
operator|=
name|hr
operator|->
name|rb_tdtail
operator|=
literal|0
expr_stmt|;
name|hr
operator|->
name|rb_td_nbusy
operator|=
literal|0
expr_stmt|;
name|hr
operator|->
name|rb_rdtail
operator|=
literal|0
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_meminit: tx ring va %p, pa %#lx"
argument_list|,
name|hr
operator|->
name|rb_txd
argument_list|,
name|hr
operator|->
name|rb_txddma
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_meminit: rx ring va %p, pa %#lx"
argument_list|,
name|hr
operator|->
name|rb_rxd
argument_list|,
name|hr
operator|->
name|rb_rxddma
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_HME
argument_list|,
literal|"rx entry 1: flags %x, address %x"
argument_list|,
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|hr
operator|->
name|rb_rxd
argument_list|,
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|hr
operator|->
name|rb_rxd
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_HME
argument_list|,
literal|"tx entry 1: flags %x, address %x"
argument_list|,
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|hr
operator|->
name|rb_txd
argument_list|,
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|hr
operator|->
name|rb_txd
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hme_mac_bitflip
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|reg
parameter_list|,
name|u_int32_t
name|val
parameter_list|,
name|u_int32_t
name|clr
parameter_list|,
name|u_int32_t
name|set
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|val
operator|&=
operator|~
name|clr
expr_stmt|;
name|val
operator||=
name|set
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|clr
operator|==
literal|0
operator|&&
name|set
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* just write, no bits to wait for */
do|do
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|val
operator|=
name|HME_MAC_READ_4
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|40
condition|)
block|{
comment|/* After 3.5ms, we should have been done. */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout while writing to "
literal|"MAC configuration register\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|(
name|val
operator|&
name|clr
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|val
operator|&
name|set
operator|)
operator|!=
name|set
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialization of interface; set up initialization block  * and transmit/receive descriptor rings.  */
end_comment

begin_function
specifier|static
name|void
name|hme_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|hme_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|hme_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|HME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hme_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hme_init_locked
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|u_int8_t
modifier|*
name|ea
decl_stmt|;
name|u_int32_t
name|n
decl_stmt|,
name|v
decl_stmt|;
name|HME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Initialization sequence. The numbered steps below correspond 	 * to the sequence outlined in section 6.3.5.1 in the Ethernet 	 * Channel Engine manual (part of the PCIO manual). 	 * See also the STP2002-STQ document from Sun Microsystems. 	 */
comment|/* step 1& 2. Reset the Ethernet Channel */
name|hme_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Re-initialize the MIF */
name|hme_mifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Mask all MIF interrupts, just in case */
block|HME_MIF_WRITE_4(sc, HME_MIFI_IMASK, 0xffff);
endif|#
directive|endif
comment|/* step 3. Setup data structures in host memory */
if|if
condition|(
name|hme_meminit
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"out of buffers; init aborted."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* step 4. TX MAC registers& counters */
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_NCCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_FCCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_EXCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_LTCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_TXSIZE
argument_list|,
name|HME_MAX_FRAMESIZE
argument_list|)
expr_stmt|;
comment|/* Load station MAC address */
name|ea
operator|=
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_MACADDR0
argument_list|,
operator|(
name|ea
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|ea
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_MACADDR1
argument_list|,
operator|(
name|ea
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|ea
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_MACADDR2
argument_list|,
operator|(
name|ea
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|ea
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Init seed for backoff 	 * (source suggested by manual: low 10 bits of MAC address) 	 */
name|v
operator|=
operator|(
operator|(
name|ea
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|ea
index|[
literal|5
index|]
operator|)
operator|&
literal|0x3fff
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_RANDSEED
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Note: Accepting power-on default for other MAC registers here.. */
comment|/* step 5. RX MAC registers& counters */
name|hme_setladrf
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* step 6& 7. Program Descriptor Ring Base Addresses */
name|HME_ETX_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_ETXI_RING
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txddma
argument_list|)
expr_stmt|;
comment|/* Transmit Descriptor ring size: in increments of 16 */
name|HME_ETX_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_ETXI_RSIZE
argument_list|,
name|HME_NTXDESC
operator|/
literal|16
operator|-
literal|1
argument_list|)
expr_stmt|;
name|HME_ERX_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_ERXI_RING
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_rxddma
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_RXSIZE
argument_list|,
name|HME_MAX_FRAMESIZE
argument_list|)
expr_stmt|;
comment|/* step 8. Global Configuration& Interrupt Mask */
name|HME_SEB_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_SEBI_IMASK
argument_list|,
operator|~
operator|(
comment|/*HME_SEB_STAT_GOTFRAME | HME_SEB_STAT_SENTFRAME |*/
name|HME_SEB_STAT_HOSTTOTX
operator||
name|HME_SEB_STAT_RXTOHOST
operator||
name|HME_SEB_STAT_TXALL
operator||
name|HME_SEB_STAT_TXPERR
operator||
name|HME_SEB_STAT_RCNTEXP
operator||
name|HME_SEB_STAT_ALL_ERRORS
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_burst
condition|)
block|{
default|default:
name|v
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|v
operator|=
name|HME_SEB_CFG_BURST16
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|v
operator|=
name|HME_SEB_CFG_BURST32
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|v
operator|=
name|HME_SEB_CFG_BURST64
expr_stmt|;
break|break;
block|}
comment|/* 	 * Blindly setting 64bit transfers may hang PCI cards(Cheerio?). 	 * Allowing 64bit transfers breaks TX checksum offload as well. 	 * Don't know this comes from hardware bug or driver's DMAing 	 * scheme. 	 * 	 * if (sc->sc_pci == 0)  	 *	v |= HME_SEB_CFG_64BIT; 	 */
name|HME_SEB_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_SEBI_CFG
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* step 9. ETX Configuration: use mostly default values */
comment|/* Enable DMA */
name|v
operator|=
name|HME_ETX_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_ETXI_CFG
argument_list|)
expr_stmt|;
name|v
operator||=
name|HME_ETX_CFG_DMAENABLE
expr_stmt|;
name|HME_ETX_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_ETXI_CFG
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* step 10. ERX Configuration */
name|v
operator|=
name|HME_ERX_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_ERXI_CFG
argument_list|)
expr_stmt|;
comment|/* Encode Receive Descriptor ring size: four possible values */
name|v
operator|&=
operator|~
name|HME_ERX_CFG_RINGSIZEMSK
expr_stmt|;
switch|switch
condition|(
name|HME_NRXDESC
condition|)
block|{
case|case
literal|32
case|:
name|v
operator||=
name|HME_ERX_CFG_RINGSIZE32
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|v
operator||=
name|HME_ERX_CFG_RINGSIZE64
expr_stmt|;
break|break;
case|case
literal|128
case|:
name|v
operator||=
name|HME_ERX_CFG_RINGSIZE128
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|v
operator||=
name|HME_ERX_CFG_RINGSIZE256
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"hme: invalid Receive Descriptor ring size\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Enable DMA, fix RX first byte offset. */
name|v
operator|&=
operator|~
name|HME_ERX_CFG_FBO_MASK
expr_stmt|;
name|v
operator||=
name|HME_ERX_CFG_DMAENABLE
operator||
operator|(
name|HME_RXOFFS
operator|<<
name|HME_ERX_CFG_FBO_SHIFT
operator|)
expr_stmt|;
comment|/* RX TCP/UDP checksum offset */
name|n
operator|=
operator|(
name|ETHER_HDR_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
operator|/
literal|2
expr_stmt|;
name|n
operator|=
operator|(
name|n
operator|<<
name|HME_ERX_CFG_CSUMSTART_SHIFT
operator|)
operator|&
name|HME_ERX_CFG_CSUMSTART_MASK
expr_stmt|;
name|v
operator||=
name|n
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_init: programming ERX_CFG to %x"
argument_list|,
operator|(
name|u_int
operator|)
name|v
argument_list|)
expr_stmt|;
name|HME_ERX_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_ERXI_CFG
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* step 11. XIF Configuration */
name|v
operator|=
name|HME_MAC_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_XIF
argument_list|)
expr_stmt|;
name|v
operator||=
name|HME_MAC_XIF_OE
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_init: programming XIF to %x"
argument_list|,
operator|(
name|u_int
operator|)
name|v
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_XIF
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* step 12. RX_MAC Configuration Register */
name|v
operator|=
name|HME_MAC_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_RXCFG
argument_list|)
expr_stmt|;
name|v
operator||=
name|HME_MAC_RXCFG_ENABLE
expr_stmt|;
name|v
operator|&=
operator|~
operator|(
name|HME_MAC_RXCFG_DCRCS
operator|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_init: programming RX_MAC to %x"
argument_list|,
operator|(
name|u_int
operator|)
name|v
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_RXCFG
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* step 13. TX_MAC Configuration Register */
name|v
operator|=
name|HME_MAC_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_TXCFG
argument_list|)
expr_stmt|;
name|v
operator||=
operator|(
name|HME_MAC_TXCFG_ENABLE
operator||
name|HME_MAC_TXCFG_DGIVEUP
operator|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_init: programming TX_MAC to %x"
argument_list|,
operator|(
name|u_int
operator|)
name|v
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_TXCFG
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* step 14. Issue Transmit Pending command */
ifdef|#
directive|ifdef
name|HMEDEBUG
comment|/* Debug: double-check. */
name|CTR4
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_init: tx ring %#x, rsz %#x, rx ring %#x, "
literal|"rxsize %#x"
argument_list|,
name|HME_ETX_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_ETXI_RING
argument_list|)
argument_list|,
name|HME_ETX_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_ETXI_RSIZE
argument_list|)
argument_list|,
name|HME_ERX_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_ERXI_RING
argument_list|)
argument_list|,
name|HME_MAC_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_RXSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_init: intr mask %#x, erx cfg %#x, etx cfg %#x"
argument_list|,
name|HME_SEB_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_SEBI_IMASK
argument_list|)
argument_list|,
name|HME_ERX_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_ERXI_CFG
argument_list|)
argument_list|,
name|HME_ETX_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_ETXI_CFG
argument_list|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_init: mac rxcfg %#x, maci txcfg %#x"
argument_list|,
name|HME_MAC_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_RXCFG
argument_list|)
argument_list|,
name|HME_MAC_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_TXCFG
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the current media. */
name|hme_mediachange_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Start the one second timer. */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tick_ch
argument_list|,
name|hz
argument_list|,
name|hme_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|hme_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TX TCP/UDP checksum */
end_comment

begin_function
specifier|static
name|void
name|hme_txcksum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int32_t
modifier|*
name|cflags
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|,
name|offset2
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
for|for
control|(
init|;
name|m
operator|&&
name|m
operator|->
name|m_len
operator|==
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
empty_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|m_len
operator|<
name|ETHER_HDR_LEN
condition|)
block|{
name|printf
argument_list|(
literal|"hme_txcksum: m_len< ETHER_HDR_LEN\n"
argument_list|)
expr_stmt|;
return|return;
comment|/* checksum will be corrupted */
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ETHER_HDR_LEN
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
name|ETHER_HDR_LEN
condition|)
block|{
name|printf
argument_list|(
literal|"hme_txcksum: m_len != ETHER_HDR_LEN\n"
argument_list|)
expr_stmt|;
return|return;
comment|/* checksum will be corrupted */
block|}
comment|/* XXX */
for|for
control|(
name|m
operator|=
name|m
operator|->
name|m_next
init|;
name|m
operator|&&
name|m
operator|->
name|m_len
operator|==
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
empty_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
comment|/* checksum will be corrupted */
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ETHER_HDR_LEN
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|p
expr_stmt|;
block|}
name|offset2
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
name|offset
operator|=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
name|ETHER_HDR_LEN
expr_stmt|;
operator|*
name|cflags
operator|=
name|offset
operator|<<
name|HME_XD_TXCKSUM_SSHIFT
expr_stmt|;
operator|*
name|cflags
operator||=
operator|(
operator|(
name|offset
operator|+
name|offset2
operator|)
operator|<<
name|HME_XD_TXCKSUM_OSHIFT
operator|)
expr_stmt|;
operator|*
name|cflags
operator||=
name|HME_XD_TXCKSUM
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to dma map an mbuf chain, set up the descriptor rings accordingly and  * start the transmission.  * Returns 0 on success, -1 if there were not enough free descriptors to map  * the packet, or an errno otherwise.  *  * XXX: this relies on the fact that segments returned by bus_dmamap_load_mbuf()  * are readable from the nearest burst boundary on (i.e. potentially before  * ds_addr) to the first boundary beyond the end. This is usually a safe  * assumption to make, but is not documented.  */
end_comment

begin_function
specifier|static
name|int
name|hme_load_txmbuf
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|hme_txdesc
modifier|*
name|htx
decl_stmt|;
name|caddr_t
name|txd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pci
decl_stmt|,
name|si
decl_stmt|,
name|ri
decl_stmt|,
name|nseg
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|,
name|cflags
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|htx
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txfreeq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|htx
operator|->
name|htx_dmamap
argument_list|,
operator|*
name|m0
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txsegs
argument_list|,
operator|&
name|nseg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_defrag
argument_list|(
operator|*
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m0
argument_list|)
expr_stmt|;
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|*
name|m0
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|htx
operator|->
name|htx_dmamap
argument_list|,
operator|*
name|m0
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txsegs
argument_list|,
operator|&
name|nseg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m0
argument_list|)
expr_stmt|;
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nseg
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m0
argument_list|)
expr_stmt|;
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rb
operator|.
name|rb_td_nbusy
operator|+
name|nseg
operator|>=
name|HME_NTXDESC
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|htx
operator|->
name|htx_dmamap
argument_list|)
expr_stmt|;
comment|/* retry with m_defrag(9)? */
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
operator|*
name|m0
operator|)
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|sc
operator|->
name|sc_csum_features
operator|)
operator|!=
literal|0
condition|)
name|hme_txcksum
argument_list|(
operator|*
name|m0
argument_list|,
operator|&
name|cflags
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|htx
operator|->
name|htx_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|si
operator|=
name|ri
operator|=
name|sc
operator|->
name|sc_rb
operator|.
name|rb_tdhead
expr_stmt|;
name|txd
operator|=
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txd
expr_stmt|;
name|pci
operator|=
name|sc
operator|->
name|sc_pci
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_load_mbuf: next desc is %d (%#x)"
argument_list|,
name|ri
argument_list|,
name|HME_XD_GETFLAGS
argument_list|(
name|pci
argument_list|,
name|txd
argument_list|,
name|ri
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
control|)
block|{
comment|/* Fill the ring entry. */
name|flags
operator|=
name|HME_XD_ENCODE_TSIZE
argument_list|(
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txsegs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|flags
operator||=
name|HME_XD_SOP
operator||
name|cflags
expr_stmt|;
else|else
name|flags
operator||=
name|HME_XD_OWN
operator||
name|cflags
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_load_mbuf: activating ri %d, si %d (%#x)"
argument_list|,
name|ri
argument_list|,
name|si
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|HME_XD_SETADDR
argument_list|(
name|pci
argument_list|,
name|txd
argument_list|,
name|ri
argument_list|,
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txsegs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|HME_XD_SETFLAGS
argument_list|(
name|pci
argument_list|,
name|txd
argument_list|,
name|ri
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rb
operator|.
name|rb_td_nbusy
operator|++
expr_stmt|;
name|htx
operator|->
name|htx_lastdesc
operator|=
name|ri
expr_stmt|;
name|ri
operator|=
operator|(
name|ri
operator|+
literal|1
operator|)
operator|%
name|HME_NTXDESC
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rb
operator|.
name|rb_tdhead
operator|=
name|ri
expr_stmt|;
comment|/* set EOP on the last descriptor */
name|ri
operator|=
operator|(
name|ri
operator|+
name|HME_NTXDESC
operator|-
literal|1
operator|)
operator|%
name|HME_NTXDESC
expr_stmt|;
name|flags
operator|=
name|HME_XD_GETFLAGS
argument_list|(
name|pci
argument_list|,
name|txd
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|flags
operator||=
name|HME_XD_EOP
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_load_mbuf: setting EOP ri %d, si %d (%#x)"
argument_list|,
name|ri
argument_list|,
name|si
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|HME_XD_SETFLAGS
argument_list|(
name|pci
argument_list|,
name|txd
argument_list|,
name|ri
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Turn the first descriptor ownership to the hme */
name|flags
operator|=
name|HME_XD_GETFLAGS
argument_list|(
name|pci
argument_list|,
name|txd
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|flags
operator||=
name|HME_XD_OWN
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_load_mbuf: setting OWN for 1st desc ri %d, (%#x)"
argument_list|,
name|ri
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|HME_XD_SETFLAGS
argument_list|(
name|pci
argument_list|,
name|txd
argument_list|,
name|si
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txfreeq
argument_list|,
name|htx_q
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txbusyq
argument_list|,
name|htx
argument_list|,
name|htx_q
argument_list|)
expr_stmt|;
name|htx
operator|->
name|htx_m
operator|=
operator|*
name|m0
expr_stmt|;
comment|/* start the transmission. */
name|HME_ETX_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_ETXI_PENDING
argument_list|,
name|HME_ETX_TP_DMAWAKEUP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pass a packet to the higher levels.  */
end_comment

begin_function
specifier|static
name|void
name|hme_read
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ix
parameter_list|,
name|int
name|len
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|len
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|||
name|len
operator|>
name|HME_MAX_FRAMESIZE
condition|)
block|{
ifdef|#
directive|ifdef
name|HMEDEBUG
name|HME_WHINE
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"invalid packet size %d; dropping\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|hme_discard_rxbuf
argument_list|(
name|sc
argument_list|,
name|ix
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|=
name|sc
operator|->
name|sc_rb
operator|.
name|rb_rxdesc
index|[
name|ix
index|]
operator|.
name|hrx_m
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_read: len %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hme_add_rxbuf
argument_list|(
name|sc
argument_list|,
name|ix
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * hme_add_rxbuf will leave the old buffer in the ring until 		 * it is sure that a new buffer can be mapped. If it can not, 		 * drop the packet, but leave the interface up. 		 */
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
name|hme_discard_rxbuf
argument_list|(
name|sc
argument_list|,
name|ix
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
operator|+
name|HME_RXOFFS
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|HME_RXOFFS
argument_list|)
expr_stmt|;
comment|/* RX TCP/UDP checksum */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
condition|)
name|hme_rxcksum
argument_list|(
name|m
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Pass the packet up. */
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|HME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hme_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|hme_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|HME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hme_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hme_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|hme_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|hme_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|,
name|enq
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
condition|)
return|return;
for|for
control|(
init|;
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
operator|&&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_td_nbusy
operator|<
name|HME_NTXDESC
operator|-
literal|1
condition|;
control|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|error
operator|=
name|hme_load_txmbuf
argument_list|(
name|sc
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
name|enq
operator|++
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Set watchdog timer if a packet was queued */
if|if
condition|(
name|enq
operator|>
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cdmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Transmit interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|hme_tint
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|caddr_t
name|txd
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|hme_txdesc
modifier|*
name|htx
decl_stmt|;
name|unsigned
name|int
name|ri
decl_stmt|,
name|txflags
decl_stmt|;
name|txd
operator|=
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txd
expr_stmt|;
name|htx
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txbusyq
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cdmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* Fetch current position in the transmit ring */
for|for
control|(
name|ri
operator|=
name|sc
operator|->
name|sc_rb
operator|.
name|rb_tdtail
init|;
condition|;
name|ri
operator|=
operator|(
name|ri
operator|+
literal|1
operator|)
operator|%
name|HME_NTXDESC
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rb
operator|.
name|rb_td_nbusy
operator|<=
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_tint: not busy!"
argument_list|)
expr_stmt|;
break|break;
block|}
name|txflags
operator|=
name|HME_XD_GETFLAGS
argument_list|(
name|sc
operator|->
name|sc_pci
argument_list|,
name|txd
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_tint: index %d, flags %#x"
argument_list|,
name|ri
argument_list|,
name|txflags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|txflags
operator|&
name|HME_XD_OWN
operator|)
operator|!=
literal|0
condition|)
break|break;
name|CTR0
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_tint: not owned"
argument_list|)
expr_stmt|;
operator|--
name|sc
operator|->
name|sc_rb
operator|.
name|rb_td_nbusy
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
comment|/* Complete packet transmitted? */
if|if
condition|(
operator|(
name|txflags
operator|&
name|HME_XD_EOP
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|KASSERT
argument_list|(
name|htx
operator|->
name|htx_lastdesc
operator|==
name|ri
argument_list|,
operator|(
literal|"hme_tint: ring indices skewed: %d != %d!"
operator|,
name|htx
operator|->
name|htx_lastdesc
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|htx
operator|->
name|htx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_tdmatag
argument_list|,
name|htx
operator|->
name|htx_dmamap
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|htx
operator|->
name|htx_m
argument_list|)
expr_stmt|;
name|htx
operator|->
name|htx_m
operator|=
name|NULL
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txbusyq
argument_list|,
name|htx_q
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txfreeq
argument_list|,
name|htx
argument_list|,
name|htx_q
argument_list|)
expr_stmt|;
name|htx
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rb
operator|.
name|rb_txbusyq
argument_list|)
expr_stmt|;
block|}
comment|/* Turn off watchdog if hme(4) transmitted queued packet */
name|ifp
operator|->
name|if_timer
operator|=
name|sc
operator|->
name|sc_rb
operator|.
name|rb_td_nbusy
operator|>
literal|0
condition|?
literal|5
else|:
literal|0
expr_stmt|;
comment|/* Update ring */
name|sc
operator|->
name|sc_rb
operator|.
name|rb_tdtail
operator|=
name|ri
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|&&
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|hme_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * RX TCP/UDP checksum   */
end_comment

begin_function
specifier|static
name|void
name|hme_rxcksum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
decl_stmt|;
name|int32_t
name|hlen
decl_stmt|,
name|len
decl_stmt|,
name|pktlen
decl_stmt|;
name|u_int16_t
name|cksum
decl_stmt|,
modifier|*
name|opts
decl_stmt|;
name|u_int32_t
name|temp32
decl_stmt|;
name|pktlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
return|return;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
return|return;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|!=
name|IPVERSION
condition|)
return|return;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|pktlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|<
name|hlen
condition|)
return|return;
if|if
condition|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|!=
name|pktlen
condition|)
return|return;
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
operator||
name|IP_OFFMASK
argument_list|)
condition|)
return|return;
comment|/* can't handle fragmented packet */
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|pktlen
operator|<
operator|(
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|)
condition|)
return|return;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|pktlen
operator|<
operator|(
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|)
condition|)
return|return;
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|hlen
operator|)
expr_stmt|;
if|if
condition|(
name|uh
operator|->
name|uh_sum
operator|==
literal|0
condition|)
return|return;
comment|/* no checksum */
break|break;
default|default:
return|return;
block|}
name|cksum
operator|=
operator|~
operator|(
name|flags
operator|&
name|HME_XD_RXCKSUM
operator|)
expr_stmt|;
comment|/* checksum fixup for IP options */
name|len
operator|=
name|hlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|opts
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|,
name|opts
operator|++
control|)
block|{
name|temp32
operator|=
name|cksum
operator|-
operator|*
name|opts
expr_stmt|;
name|temp32
operator|=
operator|(
name|temp32
operator|>>
literal|16
operator|)
operator|+
operator|(
name|temp32
operator|&
literal|65535
operator|)
expr_stmt|;
name|cksum
operator|=
name|temp32
operator|&
literal|65535
expr_stmt|;
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|cksum
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Receive interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|hme_rint
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|caddr_t
name|xdr
init|=
name|sc
operator|->
name|sc_rb
operator|.
name|rb_rxd
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|unsigned
name|int
name|ri
decl_stmt|,
name|len
decl_stmt|;
name|int
name|progress
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
comment|/* 	 * Process all buffers with valid data. 	 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cdmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
for|for
control|(
name|ri
operator|=
name|sc
operator|->
name|sc_rb
operator|.
name|rb_rdtail
init|;
condition|;
name|ri
operator|=
operator|(
name|ri
operator|+
literal|1
operator|)
operator|%
name|HME_NRXDESC
control|)
block|{
name|flags
operator|=
name|HME_XD_GETFLAGS
argument_list|(
name|sc
operator|->
name|sc_pci
argument_list|,
name|xdr
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_rint: index %d, flags %#x"
argument_list|,
name|ri
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HME_XD_OWN
operator|)
operator|!=
literal|0
condition|)
break|break;
name|progress
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HME_XD_OFL
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"buffer overflow, ri=%d; "
literal|"flags=0x%x\n"
argument_list|,
name|ri
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|hme_discard_rxbuf
argument_list|(
name|sc
argument_list|,
name|ri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|HME_XD_DECODE_RSIZE
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|hme_read
argument_list|(
name|sc
argument_list|,
name|ri
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|progress
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_cdmatag
argument_list|,
name|sc
operator|->
name|sc_cdmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rb
operator|.
name|rb_rdtail
operator|=
name|ri
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hme_eint
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|status
parameter_list|)
block|{
if|if
condition|(
operator|(
name|status
operator|&
name|HME_SEB_STAT_MIFIRQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"XXXlink status changed: "
literal|"cfg=%#x, stat=%#x, sm=%#x\n"
argument_list|,
name|HME_MIF_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MIFI_CFG
argument_list|)
argument_list|,
name|HME_MIF_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MIFI_STAT
argument_list|)
argument_list|,
name|HME_MIF_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MIFI_SM
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* check for fatal errors that needs reset to unfreeze DMA engine */
if|if
condition|(
operator|(
name|status
operator|&
name|HME_SEB_STAT_FATAL_ERRORS
operator|)
operator|!=
literal|0
condition|)
block|{
name|HME_WHINE
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"error signaled, status=%#x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|hme_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|hme_intr
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|hme_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|hme_softc
operator|*
operator|)
name|v
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|HME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|status
operator|=
name|HME_SEB_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_SEBI_STAT
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_intr: status %#x"
argument_list|,
operator|(
name|u_int
operator|)
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|HME_SEB_STAT_ALL_ERRORS
operator|)
operator|!=
literal|0
condition|)
name|hme_eint
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|HME_SEB_STAT_TXALL
operator||
name|HME_SEB_STAT_HOSTTOTX
operator|)
operator|)
operator|!=
literal|0
condition|)
name|hme_tint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|HME_SEB_STAT_RXTOHOST
operator|)
operator|!=
literal|0
condition|)
name|hme_rint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hme_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|hme_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|HMEDEBUG
name|u_int32_t
name|status
decl_stmt|;
endif|#
directive|endif
name|HME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HMEDEBUG
name|status
operator|=
name|HME_SEB_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_SEBI_STAT
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_HME
argument_list|,
literal|"hme_watchdog: status %x"
argument_list|,
operator|(
name|u_int
operator|)
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
operator|++
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
name|hme_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the MII Management Interface  */
end_comment

begin_function
specifier|static
name|void
name|hme_mifinit
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|v
decl_stmt|;
comment|/* 	 * Configure the MIF in frame mode, polling disabled, internal PHY 	 * selected. 	 */
name|HME_MIF_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MIFI_CFG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If the currently selected media uses the external transceiver, 	 * enable its MII drivers (which basically isolates the internal 	 * one and vice versa). In case the current media hasn't been set, 	 * yet, we default to the internal transceiver. 	 */
name|v
operator|=
name|HME_MAC_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_XIF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mii
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media
operator|.
name|ifm_cur
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|sc_phys
index|[
name|IFM_INST
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media
operator|.
name|ifm_cur
operator|->
name|ifm_media
argument_list|)
index|]
operator|==
name|HME_PHYAD_EXTERNAL
condition|)
name|v
operator||=
name|HME_MAC_XIF_MIIENABLE
expr_stmt|;
else|else
name|v
operator|&=
operator|~
name|HME_MAC_XIF_MIIENABLE
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_XIF
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MII interface  */
end_comment

begin_function
name|int
name|hme_mii_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|hme_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
comment|/* We can at most have two PHYs. */
if|if
condition|(
name|phy
operator|!=
name|HME_PHYAD_EXTERNAL
operator|&&
name|phy
operator|!=
name|HME_PHYAD_INTERNAL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Select the desired PHY in the MIF configuration register */
name|v
operator|=
name|HME_MIF_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MIFI_CFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|==
name|HME_PHYAD_EXTERNAL
condition|)
name|v
operator||=
name|HME_MIF_CFG_PHY
expr_stmt|;
else|else
name|v
operator|&=
operator|~
name|HME_MIF_CFG_PHY
expr_stmt|;
name|HME_MIF_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MIFI_CFG
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Construct the frame command */
name|v
operator|=
operator|(
name|MII_COMMAND_START
operator|<<
name|HME_MIF_FO_ST_SHIFT
operator|)
operator||
name|HME_MIF_FO_TAMSB
operator||
operator|(
name|MII_COMMAND_READ
operator|<<
name|HME_MIF_FO_OPC_SHIFT
operator|)
operator||
operator|(
name|phy
operator|<<
name|HME_MIF_FO_PHYAD_SHIFT
operator|)
operator||
operator|(
name|reg
operator|<<
name|HME_MIF_FO_REGAD_SHIFT
operator|)
expr_stmt|;
name|HME_MIF_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MIFI_FO
argument_list|,
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|100
condition|;
name|n
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|HME_MIF_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MIFI_FO
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|HME_MIF_FO_TALSB
condition|)
return|return
operator|(
name|v
operator|&
name|HME_MIF_FO_DATA
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"mii_read timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|hme_mii_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|hme_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
comment|/* We can at most have two PHYs. */
if|if
condition|(
name|phy
operator|!=
name|HME_PHYAD_EXTERNAL
operator|&&
name|phy
operator|!=
name|HME_PHYAD_INTERNAL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Select the desired PHY in the MIF configuration register */
name|v
operator|=
name|HME_MIF_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MIFI_CFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|==
name|HME_PHYAD_EXTERNAL
condition|)
name|v
operator||=
name|HME_MIF_CFG_PHY
expr_stmt|;
else|else
name|v
operator|&=
operator|~
name|HME_MIF_CFG_PHY
expr_stmt|;
name|HME_MIF_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MIFI_CFG
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Construct the frame command */
name|v
operator|=
operator|(
name|MII_COMMAND_START
operator|<<
name|HME_MIF_FO_ST_SHIFT
operator|)
operator||
name|HME_MIF_FO_TAMSB
operator||
operator|(
name|MII_COMMAND_WRITE
operator|<<
name|HME_MIF_FO_OPC_SHIFT
operator|)
operator||
operator|(
name|phy
operator|<<
name|HME_MIF_FO_PHYAD_SHIFT
operator|)
operator||
operator|(
name|reg
operator|<<
name|HME_MIF_FO_REGAD_SHIFT
operator|)
operator||
operator|(
name|val
operator|&
name|HME_MIF_FO_DATA
operator|)
expr_stmt|;
name|HME_MIF_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MIFI_FO
argument_list|,
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|100
condition|;
name|n
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|HME_MIF_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MIFI_FO
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|HME_MIF_FO_TALSB
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"mii_write timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|hme_mii_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hme_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HMEDEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"hme_mii_statchg: status change\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the MAC Full Duplex bit appropriately */
name|v
operator|=
name|HME_MAC_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_TXCFG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hme_mac_bitflip
argument_list|(
name|sc
argument_list|,
name|HME_MACI_TXCFG
argument_list|,
name|v
argument_list|,
name|HME_MAC_TXCFG_ENABLE
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|v
operator||=
name|HME_MAC_TXCFG_FULLDPLX
expr_stmt|;
else|else
name|v
operator|&=
operator|~
name|HME_MAC_TXCFG_FULLDPLX
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_TXCFG
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hme_mac_bitflip
argument_list|(
name|sc
argument_list|,
name|HME_MACI_TXCFG
argument_list|,
name|v
argument_list|,
literal|0
argument_list|,
name|HME_MAC_TXCFG_ENABLE
argument_list|)
condition|)
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|hme_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|hme_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|HME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|hme_mediachange_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hme_mediachange_locked
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mii_softc
modifier|*
name|child
decl_stmt|;
name|HME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HMEDEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"hme_mediachange_locked"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hme_mifinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If both PHYs are present reset them. This is required for 	 * unisolating the previously isolated PHY when switching PHYs. 	 * As the above hme_mifinit() call will set the MII drivers in 	 * the XIF configuration register accoring to the currently 	 * selected media, there should be no window during which the 	 * data paths of both transceivers are open at the same time, 	 * even if the PHY device drivers use MIIF_NOISOLATE. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_phys
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|sc
operator|->
name|sc_phys
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|LIST_FOREACH
argument_list|(
argument|child
argument_list|,
argument|&sc->sc_mii->mii_phys
argument_list|,
argument|mii_list
argument_list|)
name|mii_phy_reset
argument_list|(
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|mii_mediachg
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hme_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|hme_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|HME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|mii_pollstat
argument_list|(
name|sc
operator|->
name|sc_mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media_status
expr_stmt|;
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|hme_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|hme_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|HME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If interface is marked down and it is running, then 			 * stop it. 			 */
name|hme_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If interface is marked up and it is stopped, then 			 * start it. 			 */
name|hme_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Reset the interface to pick up changes in any other 			 * flags that affect hardware registers. 			 */
name|hme_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_csum_features
operator||=
name|CSUM_UDP
expr_stmt|;
else|else
name|sc
operator|->
name|sc_csum_features
operator|&=
operator|~
name|CSUM_UDP
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|sc
operator|->
name|sc_csum_features
expr_stmt|;
ifdef|#
directive|ifdef
name|HMEDEBUG
name|sc
operator|->
name|sc_debug
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
operator|)
operator|!=
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|HME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hme_setladrf
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_mii
operator|->
name|mii_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|HME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifr
operator|->
name|ifr_reqcap
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|sc
operator|->
name|sc_csum_features
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
name|HME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up the logical address filter.  */
end_comment

begin_function
specifier|static
name|void
name|hme_setladrf
parameter_list|(
name|struct
name|hme_softc
modifier|*
name|sc
parameter_list|,
name|int
name|reenable
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|inm
decl_stmt|;
name|u_int32_t
name|crc
decl_stmt|;
name|u_int32_t
name|hash
index|[
literal|4
index|]
decl_stmt|;
name|u_int32_t
name|macc
decl_stmt|;
name|HME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Clear hash table */
name|hash
index|[
literal|3
index|]
operator|=
name|hash
index|[
literal|2
index|]
operator|=
name|hash
index|[
literal|1
index|]
operator|=
name|hash
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Get current RX configuration */
name|macc
operator|=
name|HME_MAC_READ_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_RXCFG
argument_list|)
expr_stmt|;
comment|/* 	 * Disable the receiver while changing it's state as the documentation 	 * mandates. 	 * We then must wait until the bit clears in the register. This should 	 * take at most 3.5ms. 	 */
if|if
condition|(
operator|!
name|hme_mac_bitflip
argument_list|(
name|sc
argument_list|,
name|HME_MACI_RXCFG
argument_list|,
name|macc
argument_list|,
name|HME_MAC_RXCFG_ENABLE
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* Disable the hash filter before writing to the filter registers. */
if|if
condition|(
operator|!
name|hme_mac_bitflip
argument_list|(
name|sc
argument_list|,
name|HME_MACI_RXCFG
argument_list|,
name|macc
argument_list|,
name|HME_MAC_RXCFG_HENABLE
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* make RXMAC really SIMPLEX */
name|macc
operator||=
name|HME_MAC_RXCFG_ME
expr_stmt|;
if|if
condition|(
name|reenable
condition|)
name|macc
operator||=
name|HME_MAC_RXCFG_ENABLE
expr_stmt|;
else|else
name|macc
operator|&=
operator|~
name|HME_MAC_RXCFG_ENABLE
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Turn on promiscuous mode; turn off the hash filter */
name|macc
operator||=
name|HME_MAC_RXCFG_PMISC
expr_stmt|;
name|macc
operator|&=
operator|~
name|HME_MAC_RXCFG_HENABLE
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
goto|goto
name|chipit
goto|;
block|}
comment|/* Turn off promiscuous mode; turn on the hash filter */
name|macc
operator|&=
operator|~
name|HME_MAC_RXCFG_PMISC
expr_stmt|;
name|macc
operator||=
name|HME_MAC_RXCFG_HENABLE
expr_stmt|;
comment|/* 	 * Set up multicast address filter by passing all multicast addresses 	 * through a crc generator, and then using the high order 6 bits as an 	 * index into the 64 bit logical address filter.  The high order bit 	 * selects the word, while the rest of the bits select the bit within 	 * the word. 	 */
name|IF_ADDR_LOCK
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|inm
argument_list|,
argument|&sc->sc_ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|inm
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|crc
operator|=
name|ether_crc32_le
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|inm
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Just want the 6 most significant bits. */
name|crc
operator|>>=
literal|26
expr_stmt|;
comment|/* Set the corresponding bit in the filter. */
name|hash
index|[
name|crc
operator|>>
literal|4
index|]
operator||=
literal|1
operator|<<
operator|(
name|crc
operator|&
literal|0xf
operator|)
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_ALLMULTI
expr_stmt|;
name|chipit
label|:
comment|/* Now load the hash table into the chip */
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_HASHTAB0
argument_list|,
name|hash
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_HASHTAB1
argument_list|,
name|hash
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_HASHTAB2
argument_list|,
name|hash
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|HME_MAC_WRITE_4
argument_list|(
name|sc
argument_list|,
name|HME_MACI_HASHTAB3
argument_list|,
name|hash
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|hme_mac_bitflip
argument_list|(
name|sc
argument_list|,
name|HME_MACI_RXCFG
argument_list|,
name|macc
argument_list|,
literal|0
argument_list|,
name|macc
operator|&
operator|(
name|HME_MAC_RXCFG_ENABLE
operator||
name|HME_MAC_RXCFG_HENABLE
operator||
name|HME_MAC_RXCFG_ME
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

