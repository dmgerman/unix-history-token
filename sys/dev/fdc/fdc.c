begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Poul-Henning Kamp  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Don Ahn.  *  * Libretto PCMCIA floppy support by David Horwitt (dhorwitt@ucsd.edu)  * aided by the Linux floppy driver modifications from David Bateman  * (dbateman@eng.uts.edu.au).  *  * Copyright (c) 1993, 1994 by  *  jc@irbs.UUCP (John Capo)  *  vak@zebub.msk.su (Serge Vakulenko)  *  ache@astral.msk.su (Andrew A. Chernov)  *  * Copyright (c) 1993, 1994, 1995 by  *  joerg_wunsch@uriah.sax.de (Joerg Wunsch)  *  dufault@hda.com (Peter Dufault)  *  * Copyright (c) 2001 Joerg Wunsch,  *  joerg_wunsch@uriah.heep.sax.de (Joerg Wunsch)  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from:	@(#)fd.c	7.4 (Berkeley) 5/25/91  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_fdc.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fdcio.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<isa/isareg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdc/fdcvar.h>
end_include

begin_include
include|#
directive|include
file|<isa/rtc.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/nec765.h>
end_include

begin_comment
comment|/*  * Runtime configuration hints/flags  */
end_comment

begin_comment
comment|/* configuration flags for fd */
end_comment

begin_define
define|#
directive|define
name|FD_TYPEMASK
value|0x0f
end_define

begin_comment
comment|/* drive type, matches enum 				 * fd_drivetype; on i386 machines, if 				 * given as 0, use RTC type for fd0 				 * and fd1 */
end_comment

begin_define
define|#
directive|define
name|FD_NO_PROBE
value|0x20
end_define

begin_comment
comment|/* don't probe drive (seek test), just 				 * assume it is there */
end_comment

begin_comment
comment|/*  * Things that could conceiveably considered parameters or tweakables  */
end_comment

begin_comment
comment|/*  * Maximal number of bytes in a cylinder.  * This is used for ISADMA bouncebuffer allocation and sets the max  * xfersize we support.  *  * 2.88M format has 2 x 36 x 512, allow for hacked up density.  */
end_comment

begin_define
define|#
directive|define
name|MAX_BYTES_PER_CYL
value|(2 * 40 * 512)
end_define

begin_comment
comment|/*  * Timeout value for the PIO loops to wait until the FDC main status  * register matches our expectations (request for master, direction  * bit).  This is supposed to be a number of microseconds, although  * timing might actually not be very accurate.  *  * Timeouts of 100 msec are believed to be required for some broken  * (old) hardware.  */
end_comment

begin_define
define|#
directive|define
name|FDSTS_TIMEOUT
value|100000
end_define

begin_comment
comment|/*  * After this many errors, stop whining.  Close will reset this count.  */
end_comment

begin_define
define|#
directive|define
name|FDC_ERRMAX
value|100
end_define

begin_comment
comment|/*  * AutoDensity search lists for each drive type.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fd_type
name|fd_searchlist_360k
index|[]
init|=
block|{
block|{
name|FDF_5_360
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fd_type
name|fd_searchlist_12m
index|[]
init|=
block|{
block|{
name|FDF_5_1200
operator||
name|FL_AUTO
block|}
block|,
block|{
name|FDF_5_360
operator||
name|FL_2STEP
operator||
name|FL_AUTO
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fd_type
name|fd_searchlist_720k
index|[]
init|=
block|{
block|{
name|FDF_3_720
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fd_type
name|fd_searchlist_144m
index|[]
init|=
block|{
block|{
name|FDF_3_1440
operator||
name|FL_AUTO
block|}
block|,
block|{
name|FDF_3_720
operator||
name|FL_AUTO
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fd_type
name|fd_searchlist_288m
index|[]
init|=
block|{
block|{
name|FDF_3_1440
operator||
name|FL_AUTO
block|}
block|,
if|#
directive|if
literal|0
block|{ FDF_3_2880 | FL_AUTO },
comment|/* XXX: probably doesn't work */
endif|#
directive|endif
block|{
name|FDF_3_720
operator||
name|FL_AUTO
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Order must match enum fd_drivetype in<sys/fdcio.h>.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fd_type
modifier|*
name|fd_native_types
index|[]
init|=
block|{
name|NULL
block|,
comment|/* FDT_NONE */
name|fd_searchlist_360k
block|,
comment|/* FDT_360K */
name|fd_searchlist_12m
block|,
comment|/* FDT_12M */
name|fd_searchlist_720k
block|,
comment|/* FDT_720K */
name|fd_searchlist_144m
block|,
comment|/* FDT_144M */
name|fd_searchlist_288m
block|,
comment|/* FDT_288M_1 (mapped to FDT_288M) */
name|fd_searchlist_288m
block|,
comment|/* FDT_288M */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internals start here  */
end_comment

begin_comment
comment|/* registers */
end_comment

begin_define
define|#
directive|define
name|FDOUT
value|2
end_define

begin_comment
comment|/* Digital Output Register (W) */
end_comment

begin_define
define|#
directive|define
name|FDO_FDSEL
value|0x03
end_define

begin_comment
comment|/*  floppy device select */
end_comment

begin_define
define|#
directive|define
name|FDO_FRST
value|0x04
end_define

begin_comment
comment|/*  floppy controller reset */
end_comment

begin_define
define|#
directive|define
name|FDO_FDMAEN
value|0x08
end_define

begin_comment
comment|/*  enable floppy DMA and Interrupt */
end_comment

begin_define
define|#
directive|define
name|FDO_MOEN0
value|0x10
end_define

begin_comment
comment|/*  motor enable drive 0 */
end_comment

begin_define
define|#
directive|define
name|FDO_MOEN1
value|0x20
end_define

begin_comment
comment|/*  motor enable drive 1 */
end_comment

begin_define
define|#
directive|define
name|FDO_MOEN2
value|0x40
end_define

begin_comment
comment|/*  motor enable drive 2 */
end_comment

begin_define
define|#
directive|define
name|FDO_MOEN3
value|0x80
end_define

begin_comment
comment|/*  motor enable drive 3 */
end_comment

begin_define
define|#
directive|define
name|FDSTS
value|4
end_define

begin_comment
comment|/* NEC 765 Main Status Register (R) */
end_comment

begin_define
define|#
directive|define
name|FDDSR
value|4
end_define

begin_comment
comment|/* Data Rate Select Register (W) */
end_comment

begin_define
define|#
directive|define
name|FDDATA
value|5
end_define

begin_comment
comment|/* NEC 765 Data Register (R/W) */
end_comment

begin_define
define|#
directive|define
name|FDCTL
value|7
end_define

begin_comment
comment|/* Control Register (W) */
end_comment

begin_comment
comment|/*  * The YE-DATA PC Card floppies use PIO to read in the data rather  * than DMA due to the wild variability of DMA for the PC Card  * devices.  DMA was deleted from the PC Card specification in version  * 7.2 of the standard, but that post-dates the YE-DATA devices by many  * years.  *  * In addition, if we cannot setup the DMA resources for the ISA  * attachment, we'll use this same offset for data transfer.  However,  * that almost certainly won't work.  *  * For this mode, offset 0 and 1 must be used to setup the transfer  * for this floppy.  This is OK for PC Card YE Data devices, but for  * ISA this is likely wrong.  These registers are only available on  * those systems that map them to the floppy drive.  Newer systems do  * not do this, and we should likely prohibit access to them (or  * disallow NODMA to be set).  */
end_comment

begin_define
define|#
directive|define
name|FDBCDR
value|0
end_define

begin_comment
comment|/* And 1 */
end_comment

begin_define
define|#
directive|define
name|FD_YE_DATAPORT
value|6
end_define

begin_comment
comment|/* Drive Data port */
end_comment

begin_define
define|#
directive|define
name|FDI_DCHG
value|0x80
end_define

begin_comment
comment|/* diskette has been changed */
end_comment

begin_comment
comment|/* requires drive and motor being selected */
end_comment

begin_comment
comment|/* is cleared by any step pulse to drive */
end_comment

begin_comment
comment|/*  * We have three private BIO commands.  */
end_comment

begin_define
define|#
directive|define
name|BIO_PROBE
value|BIO_CMD0
end_define

begin_define
define|#
directive|define
name|BIO_RDID
value|BIO_CMD1
end_define

begin_define
define|#
directive|define
name|BIO_FMT
value|BIO_CMD2
end_define

begin_comment
comment|/*  * Per drive structure (softc).  */
end_comment

begin_struct
struct|struct
name|fd_data
block|{
name|u_char
modifier|*
name|fd_ioptr
decl_stmt|;
comment|/* IO pointer */
name|u_int
name|fd_iosize
decl_stmt|;
comment|/* Size of IO chunks */
name|u_int
name|fd_iocount
decl_stmt|;
comment|/* Outstanding requests */
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
comment|/* pointer to controller structure */
name|int
name|fdsu
decl_stmt|;
comment|/* this units number on this controller */
name|enum
name|fd_drivetype
name|type
decl_stmt|;
comment|/* drive type */
name|struct
name|fd_type
modifier|*
name|ft
decl_stmt|;
comment|/* pointer to current type descriptor */
name|struct
name|fd_type
name|fts
decl_stmt|;
comment|/* type descriptors */
name|int
name|sectorsize
decl_stmt|;
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|FD_WP
value|(1<<0)
comment|/* Write protected	*/
define|#
directive|define
name|FD_MOTOR
value|(1<<1)
comment|/* motor should be on	*/
define|#
directive|define
name|FD_MOTORWAIT
value|(1<<2)
comment|/* motor should be on	*/
define|#
directive|define
name|FD_EMPTY
value|(1<<3)
comment|/* no media		*/
define|#
directive|define
name|FD_NEWDISK
value|(1<<4)
comment|/* media changed	*/
define|#
directive|define
name|FD_ISADMA
value|(1<<5)
comment|/* isa dma started 	*/
name|int
name|track
decl_stmt|;
comment|/* where we think the head is */
define|#
directive|define
name|FD_NO_TRACK
value|-2
name|int
name|options
decl_stmt|;
comment|/* FDOPT_* */
name|struct
name|callout
name|toffhandle
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|fd_geom
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|fd_provider
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|bio_queue_head
name|fd_bq
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FD_NOT_VALID
value|-2
end_define

begin_decl_stmt
specifier|static
name|driver_intr_t
name|fdc_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_filter_t
name|fdc_intr_fast
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|fdc_reset
parameter_list|(
name|struct
name|fdc_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|fdc
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"fdc driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|fifo_threshold
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_fdc
argument_list|,
name|OID_AUTO
argument_list|,
name|fifo
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fifo_threshold
argument_list|,
literal|0
argument_list|,
literal|"FIFO threshold setting"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|debugflags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_fdc
argument_list|,
name|OID_AUTO
argument_list|,
name|debugflags
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|debugflags
argument_list|,
literal|0
argument_list|,
literal|"Debug flags"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|retries
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_fdc
argument_list|,
name|OID_AUTO
argument_list|,
name|retries
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|retries
argument_list|,
literal|0
argument_list|,
literal|"Number of retries to attempt"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|spec1
init|=
literal|0xaf
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_fdc
argument_list|,
name|OID_AUTO
argument_list|,
name|spec1
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|spec1
argument_list|,
literal|0
argument_list|,
literal|"Specification byte one (step-rate + head unload)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|spec2
init|=
literal|0x10
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_fdc
argument_list|,
name|OID_AUTO
argument_list|,
name|spec2
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|spec2
argument_list|,
literal|0
argument_list|,
literal|"Specification byte two (head load time + no-dma)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|settle
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_fdc
argument_list|,
name|OID_AUTO
argument_list|,
name|settle
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|settle
argument_list|,
literal|0
argument_list|,
literal|"Head settling time in sec/hz"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|fdprinttype
parameter_list|(
name|struct
name|fd_type
modifier|*
name|ft
parameter_list|)
block|{
name|printf
argument_list|(
literal|"(%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,0x%x)"
argument_list|,
name|ft
operator|->
name|sectrac
argument_list|,
name|ft
operator|->
name|secsize
argument_list|,
name|ft
operator|->
name|datalen
argument_list|,
name|ft
operator|->
name|gap
argument_list|,
name|ft
operator|->
name|tracks
argument_list|,
name|ft
operator|->
name|size
argument_list|,
name|ft
operator|->
name|trans
argument_list|,
name|ft
operator|->
name|heads
argument_list|,
name|ft
operator|->
name|f_gap
argument_list|,
name|ft
operator|->
name|f_inter
argument_list|,
name|ft
operator|->
name|offset_side2
argument_list|,
name|ft
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fdsettype
parameter_list|(
name|struct
name|fd_data
modifier|*
name|fd
parameter_list|,
name|struct
name|fd_type
modifier|*
name|ft
parameter_list|)
block|{
name|fd
operator|->
name|ft
operator|=
name|ft
expr_stmt|;
name|ft
operator|->
name|size
operator|=
name|ft
operator|->
name|sectrac
operator|*
name|ft
operator|->
name|heads
operator|*
name|ft
operator|->
name|tracks
expr_stmt|;
name|fd
operator|->
name|sectorsize
operator|=
literal|128
operator|<<
name|fd
operator|->
name|ft
operator|->
name|secsize
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Bus space handling (access to low-level IO).  */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|fdregwr
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint8_t
name|v
parameter_list|)
block|{
name|bus_space_write_1
argument_list|(
name|fdc
operator|->
name|iot
argument_list|,
name|fdc
operator|->
name|ioh
index|[
name|reg
index|]
argument_list|,
name|fdc
operator|->
name|ioff
index|[
name|reg
index|]
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|__inline
specifier|static
name|uint8_t
name|fdregrd
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
return|return
name|bus_space_read_1
argument_list|(
name|fdc
operator|->
name|iot
argument_list|,
name|fdc
operator|->
name|ioh
index|[
name|reg
index|]
argument_list|,
name|fdc
operator|->
name|ioff
index|[
name|reg
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fdctl_wr
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|u_int8_t
name|v
parameter_list|)
block|{
name|fdregwr
argument_list|(
name|fdc
argument_list|,
name|FDCTL
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fdout_wr
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|u_int8_t
name|v
parameter_list|)
block|{
name|fdregwr
argument_list|(
name|fdc
argument_list|,
name|FDOUT
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|fdsts_rd
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|)
block|{
return|return
name|fdregrd
argument_list|(
name|fdc
argument_list|,
name|FDSTS
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fddsr_wr
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|u_int8_t
name|v
parameter_list|)
block|{
name|fdregwr
argument_list|(
name|fdc
argument_list|,
name|FDDSR
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fddata_wr
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|u_int8_t
name|v
parameter_list|)
block|{
name|fdregwr
argument_list|(
name|fdc
argument_list|,
name|FDDATA
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|fddata_rd
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|)
block|{
return|return
name|fdregrd
argument_list|(
name|fdc
argument_list|,
name|FDDATA
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|fdin_rd
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|)
block|{
return|return
name|fdregrd
argument_list|(
name|fdc
argument_list|,
name|FDCTL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Magic pseudo-DMA initialization for YE FDC. Sets count and  * direction.  */
end_comment

begin_function
specifier|static
name|void
name|fdbcdr_wr
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|int
name|iswrite
parameter_list|,
name|uint16_t
name|count
parameter_list|)
block|{
name|fdregwr
argument_list|(
name|fdc
argument_list|,
name|FDBCDR
argument_list|,
operator|(
name|count
operator|-
literal|1
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|fdregwr
argument_list|(
name|fdc
argument_list|,
name|FDBCDR
operator|+
literal|1
argument_list|,
operator|(
name|iswrite
condition|?
literal|0x80
else|:
literal|0
operator|)
operator||
operator|(
operator|(
operator|(
name|count
operator|-
literal|1
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdc_err
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|fdc
operator|->
name|fdc_errs
operator|++
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|fdc
operator|->
name|fdc_errs
operator|<
name|FDC_ERRMAX
condition|)
name|device_printf
argument_list|(
name|fdc
operator|->
name|fdc_dev
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fdc
operator|->
name|fdc_errs
operator|==
name|FDC_ERRMAX
condition|)
name|device_printf
argument_list|(
name|fdc
operator|->
name|fdc_dev
argument_list|,
literal|"too many errors, not "
literal|"logging any more\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * FDC IO functions, take care of the main status register, timeout  * in case the desired status bits are never set.  *  * These PIO loops initially start out with short delays between  * each iteration in the expectation that the required condition  * is usually met quickly, so it can be handled immediately.  */
end_comment

begin_function
specifier|static
name|int
name|fdc_in
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|int
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|step
decl_stmt|;
name|step
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FDSTS_TIMEOUT
condition|;
name|j
operator|+=
name|step
control|)
block|{
name|i
operator|=
name|fdsts_rd
argument_list|(
name|fdc
argument_list|)
operator|&
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
condition|)
block|{
name|i
operator|=
name|fddata_rd
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
operator|*
name|ptr
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|==
name|NE7_RQM
condition|)
return|return
operator|(
name|fdc_err
argument_list|(
name|fdc
argument_list|,
literal|"ready for output in input\n"
argument_list|)
operator|)
return|;
name|step
operator|+=
name|step
expr_stmt|;
name|DELAY
argument_list|(
name|step
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fdc_err
argument_list|(
name|fdc
argument_list|,
name|bootverbose
condition|?
literal|"input ready timeout\n"
else|:
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdc_out
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|step
decl_stmt|;
name|step
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FDSTS_TIMEOUT
condition|;
name|j
operator|+=
name|step
control|)
block|{
name|i
operator|=
name|fdsts_rd
argument_list|(
name|fdc
argument_list|)
operator|&
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NE7_RQM
condition|)
block|{
name|fddata_wr
argument_list|(
name|fdc
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|==
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
condition|)
return|return
operator|(
name|fdc_err
argument_list|(
name|fdc
argument_list|,
literal|"ready for input in output\n"
argument_list|)
operator|)
return|;
name|step
operator|+=
name|step
expr_stmt|;
name|DELAY
argument_list|(
name|step
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fdc_err
argument_list|(
name|fdc
argument_list|,
name|bootverbose
condition|?
literal|"output ready timeout\n"
else|:
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * fdc_cmd: Send a command to the chip.  * Takes a varargs with this structure:  *	# of output bytes  *	output bytes as int [...]  *	# of input bytes  *	input bytes as int* [...]  */
end_comment

begin_function
specifier|static
name|int
name|fdc_cmd
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|int
name|n_out
parameter_list|,
modifier|...
parameter_list|)
block|{
name|u_char
name|cmd
init|=
literal|0
decl_stmt|;
name|int
name|n_in
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|n_out
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_out
condition|;
name|n
operator|++
control|)
block|{
name|i
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|cmd
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|fdc_out
argument_list|(
name|fdc
argument_list|,
name|i
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|msg
index|[
literal|50
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"cmd %x failed at out byte %d of %d\n"
argument_list|,
name|cmd
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|n_out
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|flags
operator||=
name|FDC_NEEDS_RESET
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|fdc_err
argument_list|(
name|fdc
argument_list|,
name|msg
argument_list|)
return|;
block|}
block|}
name|n_in
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_in
condition|;
name|n
operator|++
control|)
block|{
name|int
modifier|*
name|ptr
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|fdc_in
argument_list|(
name|fdc
argument_list|,
name|ptr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|msg
index|[
literal|50
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"cmd %02x failed at in byte %d of %d\n"
argument_list|,
name|cmd
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|n_in
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|flags
operator||=
name|FDC_NEEDS_RESET
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|fdc_err
argument_list|(
name|fdc
argument_list|,
name|msg
argument_list|)
return|;
block|}
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fdc_reset
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|r
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|fdc
operator|->
name|fdct
operator|==
name|FDC_ENHANCED
condition|)
block|{
comment|/* Try a software reset, default precomp, and 500 kb/s */
name|fddsr_wr
argument_list|(
name|fdc
argument_list|,
name|I8207X_DSR_SR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Try a hardware reset, keep motor on */
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
name|fdc
operator|->
name|fdout
operator|&
operator|~
operator|(
name|FDO_FRST
operator||
name|FDO_FDMAEN
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* enable FDC, but defer interrupts a moment */
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
name|fdc
operator|->
name|fdout
operator|&
operator|~
name|FDO_FDMAEN
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
name|fdc
operator|->
name|fdout
argument_list|)
expr_stmt|;
comment|/* XXX after a reset, silently believe the FDC will accept commands */
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SPECIFY
argument_list|,
name|spec1
argument_list|,
name|spec2
argument_list|,
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|fdc
operator|->
name|fdc_dev
argument_list|,
literal|" SPECIFY failed in reset\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|fdct
operator|==
name|FDC_ENHANCED
condition|)
block|{
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|4
argument_list|,
name|I8207X_CONFIG
argument_list|,
literal|0
argument_list|,
literal|0x40
operator||
comment|/* Enable Implied Seek */
literal|0x10
operator||
comment|/* Polling disabled */
operator|(
name|fifo_threshold
operator|-
literal|1
operator|)
argument_list|,
comment|/* Fifo threshold */
literal|0x00
argument_list|,
comment|/* Precomp track */
literal|0
argument_list|)
condition|)
name|device_printf
argument_list|(
name|fdc
operator|->
name|fdc_dev
argument_list|,
literal|" CONFIGURE failed in reset\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugflags
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|1
argument_list|,
name|I8207X_DUMPREG
argument_list|,
literal|10
argument_list|,
operator|&
name|r
index|[
literal|0
index|]
argument_list|,
operator|&
name|r
index|[
literal|1
index|]
argument_list|,
operator|&
name|r
index|[
literal|2
index|]
argument_list|,
operator|&
name|r
index|[
literal|3
index|]
argument_list|,
operator|&
name|r
index|[
literal|4
index|]
argument_list|,
operator|&
name|r
index|[
literal|5
index|]
argument_list|,
operator|&
name|r
index|[
literal|6
index|]
argument_list|,
operator|&
name|r
index|[
literal|7
index|]
argument_list|,
operator|&
name|r
index|[
literal|8
index|]
argument_list|,
operator|&
name|r
index|[
literal|9
index|]
argument_list|)
condition|)
name|device_printf
argument_list|(
name|fdc
operator|->
name|fdc_dev
argument_list|,
literal|" DUMPREG failed in reset\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|r
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fdc_sense_drive
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|int
modifier|*
name|st3p
parameter_list|)
block|{
name|int
name|st3
decl_stmt|;
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|2
argument_list|,
name|NE7CMD_SENSED
argument_list|,
name|fdc
operator|->
name|fd
operator|->
name|fdsu
argument_list|,
literal|1
argument_list|,
operator|&
name|st3
argument_list|)
condition|)
return|return
operator|(
name|fdc_err
argument_list|(
name|fdc
argument_list|,
literal|"Sense Drive Status failed\n"
argument_list|)
operator|)
return|;
if|if
condition|(
name|st3p
condition|)
operator|*
name|st3p
operator|=
name|st3
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdc_sense_int
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|int
modifier|*
name|st0p
parameter_list|,
name|int
modifier|*
name|cylp
parameter_list|)
block|{
name|int
name|cyl
decl_stmt|,
name|st0
decl_stmt|,
name|ret
decl_stmt|;
name|ret
operator|=
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|1
argument_list|,
name|NE7CMD_SENSEI
argument_list|,
literal|1
argument_list|,
operator|&
name|st0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|(
name|void
operator|)
name|fdc_err
argument_list|(
name|fdc
argument_list|,
literal|"sense intr err reading stat reg 0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|st0p
condition|)
operator|*
name|st0p
operator|=
name|st0
expr_stmt|;
if|if
condition|(
operator|(
name|st0
operator|&
name|NE7_ST0_IC
operator|)
operator|==
name|NE7_ST0_IC_IV
condition|)
block|{
comment|/* 		 * There doesn't seem to have been an interrupt. 		 */
return|return
operator|(
name|FD_NOT_VALID
operator|)
return|;
block|}
if|if
condition|(
name|fdc_in
argument_list|(
name|fdc
argument_list|,
operator|&
name|cyl
argument_list|)
operator|<
literal|0
condition|)
return|return
name|fdc_err
argument_list|(
name|fdc
argument_list|,
literal|"can't get cyl num\n"
argument_list|)
return|;
if|if
condition|(
name|cylp
condition|)
operator|*
name|cylp
operator|=
name|cyl
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdc_read_status
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|,
name|status
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ret
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|fdc_in
argument_list|(
name|fdc
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|status
index|[
name|i
index|]
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|fdc
operator|->
name|flags
operator||=
name|FDC_STAT_VALID
expr_stmt|;
else|else
name|fdc
operator|->
name|flags
operator|&=
operator|~
name|FDC_STAT_VALID
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Select this drive  */
end_comment

begin_function
specifier|static
name|void
name|fd_select
parameter_list|(
name|struct
name|fd_data
modifier|*
name|fd
parameter_list|)
block|{
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
comment|/* XXX: lock controller */
name|fdc
operator|=
name|fd
operator|->
name|fdc
expr_stmt|;
name|fdc
operator|->
name|fdout
operator|&=
operator|~
name|FDO_FDSEL
expr_stmt|;
name|fdc
operator|->
name|fdout
operator||=
name|FDO_FDMAEN
operator||
name|FDO_FRST
operator||
name|fd
operator|->
name|fdsu
expr_stmt|;
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
name|fdc
operator|->
name|fdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fd_turnon
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|int
name|once
decl_stmt|;
name|fd
operator|=
name|arg
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|fd
operator|->
name|fdc
operator|->
name|fdc_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|fd
operator|->
name|flags
operator|&=
operator|~
name|FD_MOTORWAIT
expr_stmt|;
name|fd
operator|->
name|flags
operator||=
name|FD_MOTOR
expr_stmt|;
name|once
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|fd
operator|->
name|fd_bq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
break|break;
name|bioq_disksort
argument_list|(
operator|&
name|fd
operator|->
name|fdc
operator|->
name|head
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|once
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|once
condition|)
name|wakeup
argument_list|(
operator|&
name|fd
operator|->
name|fdc
operator|->
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fd_motor
parameter_list|(
name|struct
name|fd_data
modifier|*
name|fd
parameter_list|,
name|int
name|turnon
parameter_list|)
block|{
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
name|fdc
operator|=
name|fd
operator|->
name|fdc
expr_stmt|;
comment|/* 	mtx_assert(&fdc->fdc_mtx, MA_OWNED); */
if|if
condition|(
name|turnon
condition|)
block|{
name|fd
operator|->
name|flags
operator||=
name|FD_MOTORWAIT
expr_stmt|;
name|fdc
operator|->
name|fdout
operator||=
operator|(
name|FDO_MOEN0
operator|<<
name|fd
operator|->
name|fdsu
operator|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|fd
operator|->
name|toffhandle
argument_list|,
name|hz
argument_list|,
name|fd_turnon
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callout_stop
argument_list|(
operator|&
name|fd
operator|->
name|toffhandle
argument_list|)
expr_stmt|;
name|fd
operator|->
name|flags
operator|&=
operator|~
operator|(
name|FD_MOTOR
operator||
name|FD_MOTORWAIT
operator|)
expr_stmt|;
name|fdc
operator|->
name|fdout
operator|&=
operator|~
operator|(
name|FDO_MOEN0
operator|<<
name|fd
operator|->
name|fdsu
operator|)
expr_stmt|;
block|}
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
name|fdc
operator|->
name|fdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fd_turnoff
parameter_list|(
name|void
modifier|*
name|xfd
parameter_list|)
block|{
name|struct
name|fd_data
modifier|*
name|fd
init|=
name|xfd
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|fd
operator|->
name|fdc
operator|->
name|fdc_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|fd_motor
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * fdc_intr - wake up the worker thread.  */
end_comment

begin_function
specifier|static
name|void
name|fdc_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|wakeup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdc_intr_fast
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|wakeup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * fdc_pio(): perform programmed IO read/write for YE PCMCIA floppy.  */
end_comment

begin_function
specifier|static
name|void
name|fdc_pio
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|)
block|{
name|u_char
modifier|*
name|cptr
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|bp
operator|=
name|fdc
operator|->
name|bp
expr_stmt|;
name|cptr
operator|=
name|fdc
operator|->
name|fd
operator|->
name|fd_ioptr
expr_stmt|;
name|count
operator|=
name|fdc
operator|->
name|fd
operator|->
name|fd_iosize
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|fdbcdr_wr
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|bus_space_read_multi_1
argument_list|(
name|fdc
operator|->
name|iot
argument_list|,
name|fdc
operator|->
name|ioh
index|[
name|FD_YE_DATAPORT
index|]
argument_list|,
name|fdc
operator|->
name|ioff
index|[
name|FD_YE_DATAPORT
index|]
argument_list|,
name|cptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_space_write_multi_1
argument_list|(
name|fdc
operator|->
name|iot
argument_list|,
name|fdc
operator|->
name|ioh
index|[
name|FD_YE_DATAPORT
index|]
argument_list|,
name|fdc
operator|->
name|ioff
index|[
name|FD_YE_DATAPORT
index|]
argument_list|,
name|cptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|fdbcdr_wr
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* needed? */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fdc_biodone
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|fd
operator|=
name|fdc
operator|->
name|fd
expr_stmt|;
name|bp
operator|=
name|fdc
operator|->
name|bp
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|fd
operator|->
name|fd_iocount
operator|==
literal|0
condition|)
name|callout_reset
argument_list|(
operator|&
name|fd
operator|->
name|toffhandle
argument_list|,
literal|4
operator|*
name|hz
argument_list|,
name|fd_turnoff
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
name|fdc
operator|->
name|fd
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_to
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|debugflags
operator|&
literal|2
operator|)
operator|&&
name|fd
operator|->
name|fdc
operator|->
name|retry
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"retries: %d\n"
argument_list|,
name|fd
operator|->
name|fdc
operator|->
name|retry
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bp
operator|->
name|bio_error
operator|=
name|error
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_DONE
expr_stmt|;
name|wakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|retry_line
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|fdc_worker
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|)
block|{
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nsect
decl_stmt|;
name|int
name|st0
decl_stmt|,
name|st3
decl_stmt|,
name|cyl
decl_stmt|,
name|mfm
decl_stmt|,
name|steptrac
decl_stmt|,
name|cylinder
decl_stmt|,
name|descyl
decl_stmt|,
name|sec
decl_stmt|;
name|int
name|head
decl_stmt|;
specifier|static
name|int
name|need_recal
decl_stmt|;
name|struct
name|fdc_readid
modifier|*
name|idp
decl_stmt|;
name|struct
name|fd_formb
modifier|*
name|finfo
decl_stmt|;
comment|/* Have we exhausted our retries ? */
name|bp
operator|=
name|fdc
operator|->
name|bp
expr_stmt|;
name|fd
operator|=
name|fdc
operator|->
name|fd
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
operator|&&
operator|(
name|fdc
operator|->
name|retry
operator|>=
name|retries
operator|||
operator|(
name|fd
operator|->
name|options
operator|&
name|FDOPT_NORETRY
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|debugflags
operator|&
literal|4
operator|)
condition|)
name|printf
argument_list|(
literal|"Too many retries (EIO)\n"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|fd
operator|->
name|flags
operator||=
name|FD_EMPTY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|fdc_biodone
argument_list|(
name|fdc
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
block|}
comment|/* Disable ISADMA if we bailed while it was active */
if|if
condition|(
name|fd
operator|!=
name|NULL
operator|&&
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_ISADMA
operator|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|isa_dmadone
argument_list|(
name|bp
operator|->
name|bio_cmd
operator|&
name|BIO_READ
condition|?
name|ISADMA_READ
else|:
name|ISADMA_WRITE
argument_list|,
name|fd
operator|->
name|fd_ioptr
argument_list|,
name|fd
operator|->
name|fd_iosize
argument_list|,
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|fd
operator|->
name|flags
operator|&=
operator|~
name|FD_ISADMA
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* Unwedge the controller ? */
if|if
condition|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NEEDS_RESET
condition|)
block|{
name|fdc
operator|->
name|flags
operator|&=
operator|~
name|FDC_NEEDS_RESET
expr_stmt|;
name|fdc_reset
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|fdc
argument_list|,
name|PRIBIO
argument_list|,
literal|"fdcrst"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* Discard results */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|fdc_sense_int
argument_list|(
name|fdc
argument_list|,
operator|&
name|st0
argument_list|,
operator|&
name|cyl
argument_list|)
expr_stmt|;
comment|/* All drives must recal */
name|need_recal
operator|=
literal|0xf
expr_stmt|;
block|}
comment|/* Pick up a request, if need be wait for it */
if|if
condition|(
name|fdc
operator|->
name|bp
operator|==
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
do|do
block|{
name|fdc
operator|->
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|fdc
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|bp
operator|==
name|NULL
condition|)
name|msleep
argument_list|(
operator|&
name|fdc
operator|->
name|head
argument_list|,
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"-"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fdc
operator|->
name|bp
operator|==
name|NULL
operator|&&
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_KTHREAD_EXIT
operator|)
operator|==
literal|0
condition|)
do|;
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|bp
operator|==
name|NULL
condition|)
comment|/* 			 * Nothing to do, worker thread has been 			 * requested to stop. 			 */
return|return
operator|(
literal|0
operator|)
return|;
name|bp
operator|=
name|fdc
operator|->
name|bp
expr_stmt|;
name|fd
operator|=
name|fdc
operator|->
name|fd
operator|=
name|bp
operator|->
name|bio_driver1
expr_stmt|;
name|fdc
operator|->
name|retry
operator|=
literal|0
expr_stmt|;
name|fd
operator|->
name|fd_ioptr
operator|=
name|bp
operator|->
name|bio_data
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|&
name|BIO_FMT
condition|)
block|{
name|i
operator|=
name|offsetof
argument_list|(
expr|struct
name|fd_formb
argument_list|,
name|fd_formb_cylno
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|->
name|fd_ioptr
operator|+=
name|i
expr_stmt|;
name|fd
operator|->
name|fd_iosize
operator|=
name|bp
operator|->
name|bio_length
operator|-
name|i
expr_stmt|;
block|}
block|}
comment|/* Select drive, setup params */
name|fd_select
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|fdct
operator|==
name|FDC_ENHANCED
condition|)
name|fddsr_wr
argument_list|(
name|fdc
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|trans
argument_list|)
expr_stmt|;
else|else
name|fdctl_wr
argument_list|(
name|fdc
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|trans
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|&
name|BIO_PROBE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fdin_rd
argument_list|(
name|fdc
argument_list|)
operator|&
name|FDI_DCHG
operator|)
operator|&&
operator|!
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_EMPTY
operator|)
condition|)
return|return
operator|(
name|fdc_biodone
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* 		 * Try to find out if we have a disk in the drive 		 * 		 * First recal, then seek to cyl#1, this clears the 		 * old condition on the disk change line so we can 		 * examine it for current status 		 */
if|if
condition|(
name|debugflags
operator|&
literal|0x40
condition|)
name|printf
argument_list|(
literal|"New disk in probe\n"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|fd
operator|->
name|flags
operator||=
name|FD_NEWDISK
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|2
argument_list|,
name|NE7CMD_RECAL
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tsleep
argument_list|(
name|fdc
argument_list|,
name|PRIBIO
argument_list|,
literal|"fdrecal"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_sense_int
argument_list|(
name|fdc
argument_list|,
operator|&
name|st0
argument_list|,
operator|&
name|cyl
argument_list|)
operator|==
name|FD_NOT_VALID
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* XXX */
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
operator|(
name|st0
operator|&
literal|0xc0
operator|)
operator|||
name|cyl
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Seek to track 1 */
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SEEK
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tsleep
argument_list|(
name|fdc
argument_list|,
name|PRIBIO
argument_list|,
literal|"fdseek"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_sense_int
argument_list|(
name|fdc
argument_list|,
operator|&
name|st0
argument_list|,
operator|&
name|cyl
argument_list|)
operator|==
name|FD_NOT_VALID
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* XXX */
name|need_recal
operator||=
operator|(
literal|1
operator|<<
name|fd
operator|->
name|fdsu
operator|)
expr_stmt|;
if|if
condition|(
name|fdin_rd
argument_list|(
name|fdc
argument_list|)
operator|&
name|FDI_DCHG
condition|)
block|{
if|if
condition|(
name|debugflags
operator|&
literal|0x40
condition|)
name|printf
argument_list|(
literal|"Empty in probe\n"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|fd
operator|->
name|flags
operator||=
name|FD_EMPTY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|debugflags
operator|&
literal|0x40
condition|)
name|printf
argument_list|(
literal|"Got disk in probe\n"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|fd
operator|->
name|flags
operator|&=
operator|~
name|FD_EMPTY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_sense_drive
argument_list|(
name|fdc
argument_list|,
operator|&
name|st3
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|st3
operator|&
name|NE7_ST3_WP
condition|)
name|fd
operator|->
name|flags
operator||=
name|FD_WP
expr_stmt|;
else|else
name|fd
operator|->
name|flags
operator|&=
operator|~
name|FD_WP
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fdc_biodone
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If we are dead just flush the requests 	 */
if|if
condition|(
name|fd
operator|->
name|flags
operator|&
name|FD_EMPTY
condition|)
return|return
operator|(
name|fdc_biodone
argument_list|(
name|fdc
argument_list|,
name|ENXIO
argument_list|)
operator|)
return|;
comment|/* Check if we lost our media */
if|if
condition|(
name|fdin_rd
argument_list|(
name|fdc
argument_list|)
operator|&
name|FDI_DCHG
condition|)
block|{
if|if
condition|(
name|debugflags
operator|&
literal|0x40
condition|)
name|printf
argument_list|(
literal|"Lost disk\n"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|fd
operator|->
name|flags
operator||=
name|FD_EMPTY
expr_stmt|;
name|fd
operator|->
name|flags
operator||=
name|FD_NEWDISK
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_orphan_provider
argument_list|(
name|fd
operator|->
name|fd_provider
argument_list|,
name|EXDEV
argument_list|)
expr_stmt|;
name|fd
operator|->
name|fd_provider
operator|->
name|flags
operator||=
name|G_PF_WITHER
expr_stmt|;
name|fd
operator|->
name|fd_provider
operator|=
name|g_new_providerf
argument_list|(
name|fd
operator|->
name|fd_geom
argument_list|,
name|fd
operator|->
name|fd_geom
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_error_provider
argument_list|(
name|fd
operator|->
name|fd_provider
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|fdc_biodone
argument_list|(
name|fdc
argument_list|,
name|ENXIO
argument_list|)
operator|)
return|;
block|}
comment|/* Check if the floppy is write-protected */
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|&
operator|(
name|BIO_FMT
operator||
name|BIO_WRITE
operator|)
condition|)
block|{
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_sense_drive
argument_list|(
name|fdc
argument_list|,
operator|&
name|st3
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|st3
operator|&
name|NE7_ST3_WP
condition|)
return|return
operator|(
name|fdc_biodone
argument_list|(
name|fdc
argument_list|,
name|EROFS
argument_list|)
operator|)
return|;
block|}
name|mfm
operator|=
operator|(
name|fd
operator|->
name|ft
operator|->
name|flags
operator|&
name|FL_MFM
operator|)
condition|?
name|NE7CMD_MFM
else|:
literal|0
expr_stmt|;
name|steptrac
operator|=
operator|(
name|fd
operator|->
name|ft
operator|->
name|flags
operator|&
name|FL_2STEP
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|i
operator|=
name|fd
operator|->
name|ft
operator|->
name|sectrac
operator|*
name|fd
operator|->
name|ft
operator|->
name|heads
expr_stmt|;
name|cylinder
operator|=
name|bp
operator|->
name|bio_pblkno
operator|/
name|i
expr_stmt|;
name|descyl
operator|=
name|cylinder
operator|*
name|steptrac
expr_stmt|;
name|sec
operator|=
name|bp
operator|->
name|bio_pblkno
operator|%
name|i
expr_stmt|;
name|nsect
operator|=
name|i
operator|-
name|sec
expr_stmt|;
name|head
operator|=
name|sec
operator|/
name|fd
operator|->
name|ft
operator|->
name|sectrac
expr_stmt|;
name|sec
operator|=
name|sec
operator|%
name|fd
operator|->
name|ft
operator|->
name|sectrac
operator|+
literal|1
expr_stmt|;
comment|/* If everything is going swimmingly, use multisector xfer */
if|if
condition|(
name|fdc
operator|->
name|retry
operator|==
literal|0
operator|&&
name|bp
operator|->
name|bio_cmd
operator|&
operator|(
name|BIO_READ
operator||
name|BIO_WRITE
operator|)
condition|)
block|{
name|fd
operator|->
name|fd_iosize
operator|=
name|imin
argument_list|(
name|nsect
operator|*
name|fd
operator|->
name|sectorsize
argument_list|,
name|bp
operator|->
name|bio_resid
argument_list|)
expr_stmt|;
name|nsect
operator|=
name|fd
operator|->
name|fd_iosize
operator|/
name|fd
operator|->
name|sectorsize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|&
operator|(
name|BIO_READ
operator||
name|BIO_WRITE
operator|)
condition|)
block|{
name|fd
operator|->
name|fd_iosize
operator|=
name|fd
operator|->
name|sectorsize
expr_stmt|;
name|nsect
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Do RECAL if we need to or are going to track zero anyway */
if|if
condition|(
operator|(
name|need_recal
operator|&
operator|(
literal|1
operator|<<
name|fd
operator|->
name|fdsu
operator|)
operator|)
operator|||
operator|(
name|cylinder
operator|==
literal|0
operator|&&
name|fd
operator|->
name|track
operator|!=
literal|0
operator|)
operator|||
name|fdc
operator|->
name|retry
operator|>
literal|2
condition|)
block|{
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|2
argument_list|,
name|NE7CMD_RECAL
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tsleep
argument_list|(
name|fdc
argument_list|,
name|PRIBIO
argument_list|,
literal|"fdrecal"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_sense_int
argument_list|(
name|fdc
argument_list|,
operator|&
name|st0
argument_list|,
operator|&
name|cyl
argument_list|)
operator|==
name|FD_NOT_VALID
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* XXX */
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
operator|(
name|st0
operator|&
literal|0xc0
operator|)
operator|||
name|cyl
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|need_recal
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|fd
operator|->
name|fdsu
operator|)
expr_stmt|;
name|fd
operator|->
name|track
operator|=
literal|0
expr_stmt|;
comment|/* let the heads settle */
if|if
condition|(
name|settle
condition|)
name|tsleep
argument_list|(
name|fdc
operator|->
name|fd
argument_list|,
name|PRIBIO
argument_list|,
literal|"fdhdstl"
argument_list|,
name|settle
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * SEEK to where we want to be 	 * 	 * Enhanced controllers do implied seeks for read&write as long as 	 * we do not need multiple steps per track. 	 */
if|if
condition|(
name|cylinder
operator|!=
name|fd
operator|->
name|track
operator|&&
operator|(
name|fdc
operator|->
name|fdct
operator|!=
name|FDC_ENHANCED
operator|||
name|descyl
operator|!=
name|cylinder
operator|||
operator|(
name|bp
operator|->
name|bio_cmd
operator|&
operator|(
name|BIO_RDID
operator||
name|BIO_FMT
operator|)
operator|)
operator|)
condition|)
block|{
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SEEK
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
name|descyl
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tsleep
argument_list|(
name|fdc
argument_list|,
name|PRIBIO
argument_list|,
literal|"fdseek"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_sense_int
argument_list|(
name|fdc
argument_list|,
operator|&
name|st0
argument_list|,
operator|&
name|cyl
argument_list|)
operator|==
name|FD_NOT_VALID
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* XXX */
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
operator|(
name|st0
operator|&
literal|0xc0
operator|)
operator|||
name|cyl
operator|!=
name|descyl
condition|)
block|{
name|need_recal
operator||=
operator|(
literal|1
operator|<<
name|fd
operator|->
name|fdsu
operator|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* let the heads settle */
if|if
condition|(
name|settle
condition|)
name|tsleep
argument_list|(
name|fdc
operator|->
name|fd
argument_list|,
name|PRIBIO
argument_list|,
literal|"fdhdstl"
argument_list|,
name|settle
argument_list|)
expr_stmt|;
block|}
name|fd
operator|->
name|track
operator|=
name|cylinder
expr_stmt|;
if|if
condition|(
name|debugflags
operator|&
literal|8
condition|)
name|printf
argument_list|(
literal|"op %x bn %ju siz %u ptr %p retry %d\n"
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|,
name|bp
operator|->
name|bio_pblkno
argument_list|,
name|fd
operator|->
name|fd_iosize
argument_list|,
name|fd
operator|->
name|fd_ioptr
argument_list|,
name|fdc
operator|->
name|retry
argument_list|)
expr_stmt|;
comment|/* Setup ISADMA if we need it and have it */
if|if
condition|(
operator|(
name|bp
operator|->
name|bio_cmd
operator|&
operator|(
name|BIO_READ
operator||
name|BIO_WRITE
operator||
name|BIO_FMT
operator|)
operator|)
operator|&&
operator|!
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
operator|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|isa_dmastart
argument_list|(
name|bp
operator|->
name|bio_cmd
operator|&
name|BIO_READ
condition|?
name|ISADMA_READ
else|:
name|ISADMA_WRITE
argument_list|,
name|fd
operator|->
name|fd_ioptr
argument_list|,
name|fd
operator|->
name|fd_iosize
argument_list|,
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|fd
operator|->
name|flags
operator||=
name|FD_ISADMA
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* Do PIO if we have to */
if|if
condition|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|&
operator|(
name|BIO_READ
operator||
name|BIO_WRITE
operator||
name|BIO_FMT
operator|)
condition|)
name|fdbcdr_wr
argument_list|(
name|fdc
argument_list|,
literal|1
argument_list|,
name|fd
operator|->
name|fd_iosize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|&
operator|(
name|BIO_WRITE
operator||
name|BIO_FMT
operator|)
condition|)
name|fdc_pio
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_FMT
case|:
comment|/* formatting */
name|finfo
operator|=
operator|(
expr|struct
name|fd_formb
operator|*
operator|)
name|bp
operator|->
name|bio_data
expr_stmt|;
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|6
argument_list|,
name|NE7CMD_FORMAT
operator||
name|mfm
argument_list|,
name|head
operator|<<
literal|2
operator||
name|fd
operator|->
name|fdsu
argument_list|,
name|finfo
operator|->
name|fd_formb_secshift
argument_list|,
name|finfo
operator|->
name|fd_formb_nsecs
argument_list|,
name|finfo
operator|->
name|fd_formb_gaplen
argument_list|,
name|finfo
operator|->
name|fd_formb_fillbyte
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|BIO_RDID
case|:
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|2
argument_list|,
name|NE7CMD_READID
operator||
name|mfm
argument_list|,
name|head
operator|<<
literal|2
operator||
name|fd
operator|->
name|fdsu
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|BIO_READ
case|:
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|9
argument_list|,
name|NE7CMD_READ
operator||
name|NE7CMD_SK
operator||
name|mfm
operator||
name|NE7CMD_MT
argument_list|,
name|head
operator|<<
literal|2
operator||
name|fd
operator|->
name|fdsu
argument_list|,
comment|/* head& unit */
name|fd
operator|->
name|track
argument_list|,
comment|/* track */
name|head
argument_list|,
comment|/* head */
name|sec
argument_list|,
comment|/* sector + 1 */
name|fd
operator|->
name|ft
operator|->
name|secsize
argument_list|,
comment|/* sector size */
name|fd
operator|->
name|ft
operator|->
name|sectrac
argument_list|,
comment|/* sectors/track */
name|fd
operator|->
name|ft
operator|->
name|gap
argument_list|,
comment|/* gap size */
name|fd
operator|->
name|ft
operator|->
name|datalen
argument_list|,
comment|/* data length */
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|BIO_WRITE
case|:
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|9
argument_list|,
name|NE7CMD_WRITE
operator||
name|mfm
operator||
name|NE7CMD_MT
argument_list|,
name|head
operator|<<
literal|2
operator||
name|fd
operator|->
name|fdsu
argument_list|,
comment|/* head& unit */
name|fd
operator|->
name|track
argument_list|,
comment|/* track */
name|head
argument_list|,
comment|/* head */
name|sec
argument_list|,
comment|/* sector + 1 */
name|fd
operator|->
name|ft
operator|->
name|secsize
argument_list|,
comment|/* sector size */
name|fd
operator|->
name|ft
operator|->
name|sectrac
argument_list|,
comment|/* sectors/track */
name|fd
operator|->
name|ft
operator|->
name|gap
argument_list|,
comment|/* gap size */
name|fd
operator|->
name|ft
operator|->
name|datalen
argument_list|,
comment|/* data length */
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
operator|==
literal|1
argument_list|,
operator|(
literal|"Wrong bio_cmd %x\n"
operator|,
name|bp
operator|->
name|bio_cmd
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Wait for interrupt */
name|i
operator|=
name|tsleep
argument_list|(
name|fdc
argument_list|,
name|PRIBIO
argument_list|,
literal|"fddata"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* PIO if the read looks good */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
operator|)
operator|&&
operator|(
name|bp
operator|->
name|bio_cmd
operator|&
name|BIO_READ
operator|)
condition|)
name|fdc_pio
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
comment|/* Finish DMA */
if|if
condition|(
name|fd
operator|->
name|flags
operator|&
name|FD_ISADMA
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|isa_dmadone
argument_list|(
name|bp
operator|->
name|bio_cmd
operator|&
name|BIO_READ
condition|?
name|ISADMA_READ
else|:
name|ISADMA_WRITE
argument_list|,
name|fd
operator|->
name|fd_ioptr
argument_list|,
name|fd
operator|->
name|fd_iosize
argument_list|,
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|fd
operator|->
name|flags
operator|&=
operator|~
name|FD_ISADMA
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Timeout. 		 * 		 * Due to IBM's brain-dead design, the FDC has a faked ready 		 * signal, hardwired to ready == true. Thus, any command 		 * issued if there's no diskette in the drive will _never_ 		 * complete, and must be aborted by resetting the FDC. 		 * Many thanks, Big Blue! 		 */
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
name|fdc
operator|->
name|flags
operator||=
name|FDC_NEEDS_RESET
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|fdc_read_status
argument_list|(
name|fdc
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|debugflags
operator|&
literal|0x10
condition|)
name|printf
argument_list|(
literal|"  -> %x %x %x %x\n"
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|0
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|1
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|2
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|st0
operator|=
name|fdc
operator|->
name|status
index|[
literal|0
index|]
operator|&
name|NE7_ST0_IC
expr_stmt|;
if|if
condition|(
name|st0
operator|!=
literal|0
condition|)
block|{
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|st0
operator|==
name|NE7_ST0_IC_AT
operator|&&
name|fdc
operator|->
name|status
index|[
literal|1
index|]
operator|&
name|NE7_ST1_OR
condition|)
block|{
comment|/* 			 * DMA overrun. Someone hogged the bus and 			 * didn't release it in time for the next 			 * FDC transfer. 			 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|st0
operator|==
name|NE7_ST0_IC_IV
condition|)
block|{
name|fdc
operator|->
name|flags
operator||=
name|FDC_NEEDS_RESET
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
if|if
condition|(
name|st0
operator|==
name|NE7_ST0_IC_AT
operator|&&
name|fdc
operator|->
name|status
index|[
literal|2
index|]
operator|&
name|NE7_ST2_WC
condition|)
block|{
name|need_recal
operator||=
operator|(
literal|1
operator|<<
name|fd
operator|->
name|fdsu
operator|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|debugflags
operator|&
literal|0x20
condition|)
block|{
name|printf
argument_list|(
literal|"status %02x %02x %02x %02x %02x %02x\n"
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|0
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|1
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|2
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|3
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|4
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|retry_line
operator|=
name|__LINE__
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* All OK */
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_RDID
case|:
comment|/* copy out ID field contents */
name|idp
operator|=
operator|(
expr|struct
name|fdc_readid
operator|*
operator|)
name|bp
operator|->
name|bio_data
expr_stmt|;
name|idp
operator|->
name|cyl
operator|=
name|fdc
operator|->
name|status
index|[
literal|3
index|]
expr_stmt|;
name|idp
operator|->
name|head
operator|=
name|fdc
operator|->
name|status
index|[
literal|4
index|]
expr_stmt|;
name|idp
operator|->
name|sec
operator|=
name|fdc
operator|->
name|status
index|[
literal|5
index|]
expr_stmt|;
name|idp
operator|->
name|secshift
operator|=
name|fdc
operator|->
name|status
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|debugflags
operator|&
literal|0x40
condition|)
name|printf
argument_list|(
literal|"c %d h %d s %d z %d\n"
argument_list|,
name|idp
operator|->
name|cyl
argument_list|,
name|idp
operator|->
name|head
argument_list|,
name|idp
operator|->
name|sec
argument_list|,
name|idp
operator|->
name|secshift
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_READ
case|:
case|case
name|BIO_WRITE
case|:
name|bp
operator|->
name|bio_pblkno
operator|+=
name|nsect
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|-=
name|fd
operator|->
name|fd_iosize
expr_stmt|;
name|bp
operator|->
name|bio_completed
operator|+=
name|fd
operator|->
name|fd_iosize
expr_stmt|;
name|fd
operator|->
name|fd_ioptr
operator|+=
name|fd
operator|->
name|fd_iosize
expr_stmt|;
comment|/* Since we managed to get something done, reset the retry */
name|fdc
operator|->
name|retry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_resid
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|BIO_FMT
case|:
break|break;
block|}
return|return
operator|(
name|fdc_biodone
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fdc_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
name|fdc
operator|=
name|arg
expr_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|flags
operator||=
name|FDC_KTHREAD_ALIVE
expr_stmt|;
while|while
condition|(
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_KTHREAD_EXIT
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|i
operator|=
name|fdc_worker
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
name|debugflags
operator|&
literal|0x20
condition|)
block|{
if|if
condition|(
name|fdc
operator|->
name|bp
operator|!=
name|NULL
condition|)
block|{
name|g_print_bio
argument_list|(
name|fdc
operator|->
name|bp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Retry line %d\n"
argument_list|,
name|retry_line
argument_list|)
expr_stmt|;
block|}
name|fdc
operator|->
name|retry
operator|+=
name|i
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
block|}
name|fdc
operator|->
name|flags
operator|&=
operator|~
operator|(
name|FDC_KTHREAD_EXIT
operator||
name|FDC_KTHREAD_ALIVE
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enqueue a request.  */
end_comment

begin_function
specifier|static
name|void
name|fd_enqueue
parameter_list|(
name|struct
name|fd_data
modifier|*
name|fd
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
name|int
name|call
decl_stmt|;
name|call
operator|=
literal|0
expr_stmt|;
name|fdc
operator|=
name|fd
operator|->
name|fdc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
comment|/* If we go from idle, cancel motor turnoff */
if|if
condition|(
name|fd
operator|->
name|fd_iocount
operator|++
operator|==
literal|0
condition|)
name|callout_stop
argument_list|(
operator|&
name|fd
operator|->
name|toffhandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|->
name|flags
operator|&
name|FD_MOTOR
condition|)
block|{
comment|/* The motor is on, send it directly to the controller */
name|bioq_disksort
argument_list|(
operator|&
name|fdc
operator|->
name|head
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|fdc
operator|->
name|head
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Queue it on the drive until the motor has started */
name|bioq_insert_tail
argument_list|(
operator|&
name|fd
operator|->
name|fd_bq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_MOTORWAIT
operator|)
condition|)
name|fd_motor
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdmisccmd
parameter_list|(
name|struct
name|fd_data
modifier|*
name|fd
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|fd_formb
modifier|*
name|finfo
decl_stmt|;
name|struct
name|fdc_readid
modifier|*
name|idfield
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bio
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* 	 * Set up a bio request for fdstrategy().  bio_offset is faked 	 * so that fdstrategy() will seek to the the requested 	 * cylinder, and use the desired head. 	 */
name|bp
operator|->
name|bio_cmd
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|BIO_FMT
condition|)
block|{
name|finfo
operator|=
operator|(
expr|struct
name|fd_formb
operator|*
operator|)
name|data
expr_stmt|;
name|bp
operator|->
name|bio_pblkno
operator|=
operator|(
name|finfo
operator|->
name|cyl
operator|*
name|fd
operator|->
name|ft
operator|->
name|heads
operator|+
name|finfo
operator|->
name|head
operator|)
operator|*
name|fd
operator|->
name|ft
operator|->
name|sectrac
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|=
sizeof|sizeof
expr|*
name|finfo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|BIO_RDID
condition|)
block|{
name|idfield
operator|=
operator|(
expr|struct
name|fdc_readid
operator|*
operator|)
name|data
expr_stmt|;
name|bp
operator|->
name|bio_pblkno
operator|=
operator|(
name|idfield
operator|->
name|cyl
operator|*
name|fd
operator|->
name|ft
operator|->
name|heads
operator|+
name|idfield
operator|->
name|head
operator|)
operator|*
name|fd
operator|->
name|ft
operator|->
name|sectrac
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|fdc_readid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|BIO_PROBE
condition|)
block|{
comment|/* nothing */
block|}
else|else
name|panic
argument_list|(
literal|"wrong cmd in fdmisccmd()"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|=
name|bp
operator|->
name|bio_pblkno
operator|*
name|fd
operator|->
name|sectorsize
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|data
expr_stmt|;
name|bp
operator|->
name|bio_driver1
operator|=
name|fd
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator|=
literal|0
expr_stmt|;
name|fd_enqueue
argument_list|(
name|fd
argument_list|,
name|bp
argument_list|)
expr_stmt|;
do|do
block|{
name|tsleep
argument_list|(
name|bp
argument_list|,
name|PRIBIO
argument_list|,
literal|"fdwait"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|bp
operator|->
name|bio_flags
operator|&
name|BIO_DONE
operator|)
condition|)
do|;
name|error
operator|=
name|bp
operator|->
name|bio_error
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try figuring out the density of the media present in our device.  */
end_comment

begin_function
specifier|static
name|int
name|fdautoselect
parameter_list|(
name|struct
name|fd_data
modifier|*
name|fd
parameter_list|)
block|{
name|struct
name|fd_type
modifier|*
name|fdtp
decl_stmt|;
name|struct
name|fdc_readid
name|id
decl_stmt|;
name|int
name|oopts
decl_stmt|,
name|rv
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|->
name|ft
operator|->
name|flags
operator|&
name|FL_AUTO
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fdtp
operator|=
name|fd_native_types
index|[
name|fd
operator|->
name|type
index|]
expr_stmt|;
name|fdsettype
argument_list|(
name|fd
argument_list|,
name|fdtp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|->
name|ft
operator|->
name|flags
operator|&
name|FL_AUTO
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Try reading sector ID fields, first at cylinder 0, head 0, 	 * then at cylinder 2, head N.  We don't probe cylinder 1, 	 * since for 5.25in DD media in a HD drive, there are no data 	 * to read (2 step pulses per media cylinder required).  For 	 * two-sided media, the second probe always goes to head 1, so 	 * we can tell them apart from single-sided media.  As a 	 * side-effect this means that single-sided media should be 	 * mentioned in the search list after two-sided media of an 	 * otherwise identical density.  Media with a different number 	 * of sectors per track but otherwise identical parameters 	 * cannot be distinguished at all. 	 * 	 * If we successfully read an ID field on both cylinders where 	 * the recorded values match our expectation, we are done. 	 * Otherwise, we try the next density entry from the table. 	 * 	 * Stepping to cylinder 2 has the side-effect of clearing the 	 * unit attention bit. 	 */
name|oopts
operator|=
name|fd
operator|->
name|options
expr_stmt|;
name|fd
operator|->
name|options
operator||=
name|FDOPT_NOERRLOG
operator||
name|FDOPT_NORETRY
expr_stmt|;
for|for
control|(
init|;
name|fdtp
operator|->
name|heads
condition|;
name|fdtp
operator|++
control|)
block|{
name|fdsettype
argument_list|(
name|fd
argument_list|,
name|fdtp
argument_list|)
expr_stmt|;
name|id
operator|.
name|cyl
operator|=
name|id
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|fdmisccmd
argument_list|(
name|fd
argument_list|,
name|BIO_RDID
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|id
operator|.
name|cyl
operator|!=
literal|0
operator|||
name|id
operator|.
name|head
operator|!=
literal|0
operator|||
name|id
operator|.
name|secshift
operator|!=
name|fdtp
operator|->
name|secsize
condition|)
continue|continue;
name|id
operator|.
name|cyl
operator|=
literal|2
expr_stmt|;
name|id
operator|.
name|head
operator|=
name|fd
operator|->
name|ft
operator|->
name|heads
operator|-
literal|1
expr_stmt|;
name|rv
operator|=
name|fdmisccmd
argument_list|(
name|fd
argument_list|,
name|BIO_RDID
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|.
name|cyl
operator|!=
literal|2
operator|||
name|id
operator|.
name|head
operator|!=
name|fdtp
operator|->
name|heads
operator|-
literal|1
operator|||
name|id
operator|.
name|secshift
operator|!=
name|fdtp
operator|->
name|secsize
condition|)
continue|continue;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
break|break;
block|}
name|fd
operator|->
name|options
operator|=
name|oopts
expr_stmt|;
if|if
condition|(
name|fdtp
operator|->
name|heads
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debugflags
operator|&
literal|0x40
condition|)
name|device_printf
argument_list|(
name|fd
operator|->
name|dev
argument_list|,
literal|"autoselection failed\n"
argument_list|)
expr_stmt|;
name|fdsettype
argument_list|(
name|fd
argument_list|,
name|fd_native_types
index|[
name|fd
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|debugflags
operator|&
literal|0x40
condition|)
block|{
name|device_printf
argument_list|(
name|fd
operator|->
name|dev
argument_list|,
literal|"autoselected %d KB medium\n"
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|size
operator|/
literal|2
argument_list|)
expr_stmt|;
name|fdprinttype
argument_list|(
name|fd
operator|->
name|ft
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * GEOM class implementation  */
end_comment

begin_decl_stmt
specifier|static
name|g_access_t
name|fd_access
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_start_t
name|fd_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_ioctl_t
name|fd_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|g_class
name|g_fd_class
init|=
block|{
operator|.
name|name
operator|=
literal|"FD"
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|,
operator|.
name|start
operator|=
name|fd_start
block|,
operator|.
name|access
operator|=
name|fd_access
block|,
operator|.
name|ioctl
operator|=
name|fd_ioctl
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|fd_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|r
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|e
parameter_list|)
block|{
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
name|int
name|ar
decl_stmt|,
name|aw
decl_stmt|,
name|ae
decl_stmt|;
name|fd
operator|=
name|pp
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|fdc
operator|=
name|fd
operator|->
name|fdc
expr_stmt|;
comment|/* 	 * If our provider is withering, we can only get negative requests 	 * and we don't want to even see them 	 */
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|G_PF_WITHER
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ar
operator|=
name|r
operator|+
name|pp
operator|->
name|acr
expr_stmt|;
name|aw
operator|=
name|w
operator|+
name|pp
operator|->
name|acw
expr_stmt|;
name|ae
operator|=
name|e
operator|+
name|pp
operator|->
name|ace
expr_stmt|;
if|if
condition|(
name|ar
operator|==
literal|0
operator|&&
name|aw
operator|==
literal|0
operator|&&
name|ae
operator|==
literal|0
condition|)
block|{
name|device_unbusy
argument_list|(
name|fd
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pp
operator|->
name|acr
operator|==
literal|0
operator|&&
name|pp
operator|->
name|acw
operator|==
literal|0
operator|&&
name|pp
operator|->
name|ace
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fdmisccmd
argument_list|(
name|fd
argument_list|,
name|BIO_PROBE
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|fd
operator|->
name|flags
operator|&
name|FD_EMPTY
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|fd
operator|->
name|flags
operator|&
name|FD_NEWDISK
condition|)
block|{
name|fdautoselect
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|fd
operator|->
name|flags
operator|&=
operator|~
name|FD_NEWDISK
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
block|}
name|device_busy
argument_list|(
name|fd
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|>
literal|0
operator|&&
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_WP
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
name|pp
operator|->
name|sectorsize
operator|=
name|fd
operator|->
name|sectorsize
expr_stmt|;
name|pp
operator|->
name|stripesize
operator|=
name|fd
operator|->
name|ft
operator|->
name|heads
operator|*
name|fd
operator|->
name|ft
operator|->
name|sectrac
operator|*
name|fd
operator|->
name|sectorsize
expr_stmt|;
name|pp
operator|->
name|mediasize
operator|=
name|pp
operator|->
name|stripesize
operator|*
name|fd
operator|->
name|ft
operator|->
name|tracks
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fd_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|fd
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|fdc
operator|=
name|fd
operator|->
name|fdc
expr_stmt|;
name|bp
operator|->
name|bio_driver1
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|&
name|BIO_GETATTR
condition|)
block|{
if|if
condition|(
name|g_handleattr_int
argument_list|(
name|bp
argument_list|,
literal|"GEOM::fwsectors"
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|sectrac
argument_list|)
condition|)
return|return;
if|if
condition|(
name|g_handleattr_int
argument_list|(
name|bp
argument_list|,
literal|"GEOM::fwheads"
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|heads
argument_list|)
condition|)
return|return;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|ENOIOCTL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|bio_cmd
operator|&
operator|(
name|BIO_READ
operator||
name|BIO_WRITE
operator|)
operator|)
condition|)
block|{
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|bio_pblkno
operator|=
name|bp
operator|->
name|bio_offset
operator|/
name|fd
operator|->
name|sectorsize
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|fd_enqueue
argument_list|(
name|fd
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|fd_ioctl
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|struct
name|fdc_status
modifier|*
name|fsp
decl_stmt|;
name|struct
name|fdc_readid
modifier|*
name|rid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fd
operator|=
name|pp
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FD_GTYPE
case|:
comment|/* get drive type */
operator|*
operator|(
expr|struct
name|fd_type
operator|*
operator|)
name|data
operator|=
operator|*
name|fd
operator|->
name|ft
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FD_STYPE
case|:
comment|/* set drive type */
if|if
condition|(
operator|!
operator|(
name|fflag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 		 * Allow setting drive type temporarily iff 		 * currently unset.  Used for fdformat so any 		 * user can set it, and then start formatting. 		 */
name|fd
operator|->
name|fts
operator|=
operator|*
operator|(
expr|struct
name|fd_type
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|fd
operator|->
name|fts
operator|.
name|sectrac
condition|)
block|{
comment|/* XXX: check for rubbish */
name|fdsettype
argument_list|(
name|fd
argument_list|,
operator|&
name|fd
operator|->
name|fts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fdsettype
argument_list|(
name|fd
argument_list|,
name|fd_native_types
index|[
name|fd
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debugflags
operator|&
literal|0x40
condition|)
name|fdprinttype
argument_list|(
name|fd
operator|->
name|ft
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FD_GOPTS
case|:
comment|/* get drive options */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|fd
operator|->
name|options
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FD_SOPTS
case|:
comment|/* set drive options */
if|if
condition|(
operator|!
operator|(
name|fflag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|fd
operator|->
name|options
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FD_CLRERR
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|fd
operator|->
name|fdc
operator|->
name|fdc_errs
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FD_GSTAT
case|:
name|fsp
operator|=
operator|(
expr|struct
name|fdc_status
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|->
name|fdc
operator|->
name|flags
operator|&
name|FDC_STAT_VALID
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|fsp
operator|->
name|status
argument_list|,
name|fd
operator|->
name|fdc
operator|->
name|status
argument_list|,
literal|7
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FD_GDTYPE
case|:
operator|*
operator|(
expr|enum
name|fd_drivetype
operator|*
operator|)
name|data
operator|=
name|fd
operator|->
name|type
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FD_FORM
case|:
if|if
condition|(
operator|!
operator|(
name|fflag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|fd_formb
operator|*
operator|)
name|data
operator|)
operator|->
name|format_version
operator|!=
name|FD_FORMAT_VERSION
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* wrong version of formatting prog */
name|error
operator|=
name|fdmisccmd
argument_list|(
name|fd
argument_list|,
name|BIO_FMT
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fd
operator|->
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|fd
operator|->
name|flags
operator||=
name|FD_NEWDISK
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fd
operator|->
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|FD_READID
case|:
name|rid
operator|=
operator|(
expr|struct
name|fdc_readid
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|rid
operator|->
name|cyl
operator|>
literal|85
operator|||
name|rid
operator|->
name|head
operator|>
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|fdmisccmd
argument_list|(
name|fd
argument_list|,
name|BIO_RDID
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIONBIO
case|:
case|case
name|FIOASYNC
case|:
comment|/* For backwards compat with old fd*(8) tools */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|debugflags
operator|&
literal|0x80
condition|)
name|printf
argument_list|(
literal|"Unknown ioctl %lx\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOIOCTL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * Configuration/initialization stuff, per controller.  */
end_comment

begin_decl_stmt
name|devclass_t
name|fdc_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|fd_devclass
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|fdc_ivars
block|{
name|int
name|fdunit
decl_stmt|;
name|int
name|fdtype
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|fdc_release_resources
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|last
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dev
operator|=
name|fdc
operator|->
name|fdc_dev
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|fdc_intr
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|fdc
operator|->
name|res_irq
argument_list|,
name|fdc
operator|->
name|fdc_intr
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fdc_intr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|res_irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|fdc
operator|->
name|rid_irq
argument_list|,
name|fdc
operator|->
name|res_irq
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|res_irq
operator|=
name|NULL
expr_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FDC_MAXREG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fdc
operator|->
name|resio
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|fdc
operator|->
name|resio
index|[
name|i
index|]
operator|!=
name|last
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|fdc
operator|->
name|ridio
index|[
name|i
index|]
argument_list|,
name|fdc
operator|->
name|resio
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|last
operator|=
name|fdc
operator|->
name|resio
index|[
name|i
index|]
expr_stmt|;
name|fdc
operator|->
name|resio
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fdc
operator|->
name|res_drq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|fdc
operator|->
name|rid_drq
argument_list|,
name|fdc
operator|->
name|res_drq
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|res_drq
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fdc_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|fdc_ivars
modifier|*
name|ivars
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|FDC_IVAR_FDUNIT
case|:
operator|*
name|result
operator|=
name|ivars
operator|->
name|fdunit
expr_stmt|;
break|break;
case|case
name|FDC_IVAR_FDTYPE
case|:
operator|*
name|result
operator|=
name|ivars
operator|->
name|fdtype
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fdc_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|fdc_ivars
modifier|*
name|ivars
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|FDC_IVAR_FDUNIT
case|:
name|ivars
operator|->
name|fdunit
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|FDC_IVAR_FDTYPE
case|:
name|ivars
operator|->
name|fdtype
operator|=
name|value
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fdc_initial_reset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|)
block|{
name|int
name|ic_type
decl_stmt|,
name|part_id
decl_stmt|;
comment|/* 	 * A status value of 0xff is very unlikely, but not theoretically 	 * impossible, but it is far more likely to indicate an empty bus. 	 */
if|if
condition|(
name|fdsts_rd
argument_list|(
name|fdc
argument_list|)
operator|==
literal|0xff
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Assert a reset to the floppy controller and check that the status 	 * register goes to zero. 	 */
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdsts_rd
argument_list|(
name|fdc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Clear the reset and see it come ready. 	 */
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
name|FDO_FRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdsts_rd
argument_list|(
name|fdc
argument_list|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Then, see if it can handle a command. */
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SPECIFY
argument_list|,
literal|0xaf
argument_list|,
literal|0x1e
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Try to identify the chip. 	 * 	 * The i8272 datasheet documents that unknown commands 	 * will return ST0 as 0x80.  The i8272 is supposedly identical 	 * to the NEC765. 	 * The i82077SL datasheet says 0x90 for the VERSION command, 	 * and several "superio" chips emulate this. 	 */
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|1
argument_list|,
name|NE7CMD_VERSION
argument_list|,
literal|1
argument_list|,
operator|&
name|ic_type
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|1
argument_list|,
literal|0x18
argument_list|,
literal|1
argument_list|,
operator|&
name|part_id
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ic_type %02x part_id %02x\n"
argument_list|,
name|ic_type
argument_list|,
name|part_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ic_type
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0x80
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"NEC 765 or clone"
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fdct
operator|=
name|FDC_NE765
expr_stmt|;
break|break;
case|case
literal|0x81
case|:
case|case
literal|0x90
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Enhanced floppy controller"
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fdct
operator|=
name|FDC_ENHANCED
expr_stmt|;
break|break;
default|default:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Generic floppy controller"
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fdct
operator|=
name|FDC_UNKNOWN
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fdc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fdc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* have our children detached first */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* kill worker thread */
name|mtx_lock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|flags
operator||=
name|FDC_KTHREAD_EXIT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|fdc
operator|->
name|head
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_KTHREAD_ALIVE
operator|)
operator|!=
literal|0
condition|)
name|msleep
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_thread
argument_list|,
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"fdcdet"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
comment|/* reset controller, turn motor off */
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
operator|)
condition|)
name|isa_dma_release
argument_list|(
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
name|fdc_release_resources
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a child device to the fdc controller.  It will then be probed etc.  */
end_comment

begin_function
name|device_t
name|fdc_add_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|fdc_ivars
modifier|*
name|ivar
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|ivar
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ivar
argument_list|,
name|M_DEVBUF
comment|/* XXX */
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivar
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ivar
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
name|ivar
operator|->
name|fdunit
operator|=
name|unit
expr_stmt|;
name|ivar
operator|->
name|fdtype
operator|=
name|FDT_NONE
expr_stmt|;
if|if
condition|(
name|resource_disabled
argument_list|(
name|name
argument_list|,
name|unit
argument_list|)
condition|)
name|device_disable
argument_list|(
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fdc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fdc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fdc_dev
operator|=
name|dev
expr_stmt|;
name|error
operator|=
name|fdc_initial_reset
argument_list|(
name|dev
argument_list|,
name|fdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"does not respond\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|fdc
operator|->
name|res_irq
argument_list|,
name|INTR_TYPE_BIO
operator||
name|INTR_ENTROPY
operator||
operator|(
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NOFAST
operator|)
condition|?
name|INTR_MPSAFE
else|:
literal|0
operator|)
argument_list|,
operator|(
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NOFAST
operator|)
condition|?
name|NULL
else|:
name|fdc_intr_fast
operator|)
argument_list|,
operator|(
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NOFAST
operator|)
condition|?
name|fdc_intr
else|:
name|NULL
operator|)
argument_list|,
name|fdc
argument_list|,
operator|&
name|fdc
operator|->
name|fdc_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot setup interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
operator|)
condition|)
block|{
name|error
operator|=
name|isa_dma_acquire
argument_list|(
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|isa_dma_init
argument_list|(
name|fdc
operator|->
name|dmachan
argument_list|,
name|MAX_BYTES_PER_CYL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|isa_dma_release
argument_list|(
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|fdc
operator|->
name|fdcu
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|flags
operator||=
name|FDC_NEEDS_RESET
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|fdc
operator|->
name|fdc_mtx
argument_list|,
literal|"fdc lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* reset controller, turn motor off, clear fdout mirror reg */
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
name|fdc
operator|->
name|fdout
operator|=
literal|0
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|fdc
operator|->
name|head
argument_list|)
expr_stmt|;
name|kthread_create
argument_list|(
name|fdc_thread
argument_list|,
name|fdc
argument_list|,
operator|&
name|fdc
operator|->
name|fdc_thread
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"fdc%d"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|settle
operator|=
name|hz
operator|/
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fdc_hints_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|dname
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|dunit
decl_stmt|;
comment|/* 	 * Probe and attach any children.  We should probably detect 	 * devices from the BIOS unless overridden. 	 */
name|name
operator|=
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|resource_find_match
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|dname
argument_list|,
operator|&
name|dunit
argument_list|,
literal|"at"
argument_list|,
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|resource_int_value
argument_list|(
name|dname
argument_list|,
name|dunit
argument_list|,
literal|"drive"
argument_list|,
operator|&
name|dunit
argument_list|)
expr_stmt|;
name|fdc_add_child
argument_list|(
name|dev
argument_list|,
name|dname
argument_list|,
name|dunit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fdc_print_child
parameter_list|(
name|device_t
name|me
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|me
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" on %s drive %d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|me
argument_list|)
argument_list|,
name|fdc_get_fdunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|device_get_flags
argument_list|(
name|me
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|retval
operator|+=
name|printf
argument_list|(
literal|" flags %#x"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Configuration/initialization, per drive.  */
end_comment

begin_function
specifier|static
name|int
name|fd_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|unit
decl_stmt|;
name|u_int
name|st0
decl_stmt|,
name|st3
decl_stmt|;
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
name|int
name|fdsu
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|type
decl_stmt|;
name|fdsu
operator|=
name|fdc_get_fdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fd
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fdc
operator|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|device_get_flags
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fd
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|fd
operator|->
name|fdc
operator|=
name|fdc
expr_stmt|;
name|fd
operator|->
name|fdsu
operator|=
name|fdsu
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Auto-probe if fdinfo is present, but always allow override. */
name|type
operator|=
name|flags
operator|&
name|FD_TYPEMASK
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|FDT_NONE
operator|&&
operator|(
name|type
operator|=
name|fdc_get_fdtype
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
name|FDT_NONE
condition|)
block|{
name|fd
operator|->
name|type
operator|=
name|type
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
comment|/* make sure fdautoselect() will be called */
name|fd
operator|->
name|flags
operator|=
name|FD_EMPTY
expr_stmt|;
name|fd
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PC98
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
if|if
condition|(
name|fd
operator|->
name|type
operator|==
name|FDT_NONE
operator|&&
operator|(
name|unit
operator|==
literal|0
operator|||
name|unit
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* Look up what the BIOS thinks we have. */
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
name|fd
operator|->
name|type
operator|=
operator|(
name|rtcin
argument_list|(
name|RTC_FDISKETTE
argument_list|)
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
expr_stmt|;
else|else
name|fd
operator|->
name|type
operator|=
name|rtcin
argument_list|(
name|RTC_FDISKETTE
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|fd
operator|->
name|type
operator|==
name|FDT_288M_1
condition|)
name|fd
operator|->
name|type
operator|=
name|FDT_288M
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __i386__ || __amd64__ */
comment|/* is there a unit? */
if|if
condition|(
name|fd
operator|->
name|type
operator|==
name|FDT_NONE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	mtx_lock(&fdc->fdc_mtx); */
comment|/* select it */
name|fd_select
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd_motor
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|fdc_reset
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
comment|/* XXX reset, then unreset, etc. */
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
comment|/* 1 sec */
if|if
condition|(
operator|(
name|flags
operator|&
name|FD_NO_PROBE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* If we're at track 0 first seek inwards. */
if|if
condition|(
operator|(
name|fdc_sense_drive
argument_list|(
name|fdc
argument_list|,
operator|&
name|st3
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|st3
operator|&
name|NE7_ST3_T0
operator|)
condition|)
block|{
comment|/* Seek some steps... */
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SEEK
argument_list|,
name|fdsu
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* ...wait a moment... */
name|DELAY
argument_list|(
literal|300000
argument_list|)
expr_stmt|;
comment|/* make ctrlr happy: */
name|fdc_sense_int
argument_list|(
name|fdc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * we must recalibrate twice, just in case the 			 * heads have been beyond cylinder 76, since 			 * most FDCs still barf when attempting to 			 * recalibrate more than 77 steps 			 */
comment|/* go back to 0: */
if|if
condition|(
name|fdc_cmd
argument_list|(
name|fdc
argument_list|,
literal|2
argument_list|,
name|NE7CMD_RECAL
argument_list|,
name|fdsu
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* a second being enough for full stroke seek*/
name|DELAY
argument_list|(
name|i
operator|==
literal|0
condition|?
literal|1000000
else|:
literal|300000
argument_list|)
expr_stmt|;
comment|/* anything responding? */
if|if
condition|(
name|fdc_sense_int
argument_list|(
name|fdc
argument_list|,
operator|&
name|st0
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|st0
operator|&
name|NE7_ST0_EC
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* already probed succesfully */
block|}
block|}
block|}
name|fd_motor
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fd
operator|=
name|NULL
expr_stmt|;
comment|/* 	mtx_unlock(&fdc->fdc_mtx); */
if|if
condition|(
operator|(
name|flags
operator|&
name|FD_NO_PROBE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|st0
operator|&
name|NE7_ST0_EC
operator|)
operator|!=
literal|0
condition|)
comment|/* no track 0 -> no drive present */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|done
label|:
switch|switch
condition|(
name|fd
operator|->
name|type
condition|)
block|{
case|case
name|FDT_12M
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"1200-KB 5.25\" drive"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDT_144M
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"1440-KB 3.5\" drive"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDT_288M
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"2880-KB 3.5\" drive (in 1440-KB mode)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDT_360K
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"360-KB 5.25\" drive"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDT_720K
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"720-KB 3.5\" drive"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|fd
operator|->
name|track
operator|=
name|FD_NO_TRACK
expr_stmt|;
name|fd
operator|->
name|fdc
operator|=
name|fdc
expr_stmt|;
name|fd
operator|->
name|fdsu
operator|=
name|fdsu
expr_stmt|;
name|fd
operator|->
name|options
operator|=
literal|0
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|fd
operator|->
name|toffhandle
argument_list|,
operator|&
name|fd
operator|->
name|fdc
operator|->
name|fdc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* initialize densities for subdevices */
name|fdsettype
argument_list|(
name|fd
argument_list|,
name|fd_native_types
index|[
name|fd
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We have to do this in a geom event because GEOM is not running  * when fd_attach() is.  * XXX: move fd_attach after geom like ata/scsi disks  */
end_comment

begin_function
specifier|static
name|void
name|fd_attach2
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|fd
operator|=
name|arg
expr_stmt|;
name|fd
operator|->
name|fd_geom
operator|=
name|g_new_geomf
argument_list|(
operator|&
name|g_fd_class
argument_list|,
literal|"fd%d"
argument_list|,
name|device_get_unit
argument_list|(
name|fd
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|->
name|fd_provider
operator|=
name|g_new_providerf
argument_list|(
name|fd
operator|->
name|fd_geom
argument_list|,
name|fd
operator|->
name|fd_geom
operator|->
name|name
argument_list|)
expr_stmt|;
name|fd
operator|->
name|fd_geom
operator|->
name|softc
operator|=
name|fd
expr_stmt|;
name|g_error_provider
argument_list|(
name|fd
operator|->
name|fd_provider
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fd_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|fd
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|g_post_event
argument_list|(
name|fd_attach2
argument_list|,
name|fd
argument_list|,
name|M_WAITOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fd
operator|->
name|flags
operator||=
name|FD_EMPTY
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|fd
operator|->
name|fd_bq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fd_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|fd
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_wither_geom
argument_list|(
name|fd
operator|->
name|fd_geom
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
while|while
condition|(
name|device_get_state
argument_list|(
name|dev
argument_list|)
operator|==
name|DS_BUSY
condition|)
name|tsleep
argument_list|(
name|fd
argument_list|,
name|PZERO
argument_list|,
literal|"fdd"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|fd
operator|->
name|toffhandle
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|fd_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fd_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fd_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fd_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
comment|/* XXX */
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
comment|/* XXX */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fd_driver
init|=
block|{
literal|"fd"
block|,
name|fd_methods
block|,
expr|sizeof
operator|(
expr|struct
name|fd_data
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|fdc_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|g_modevent
argument_list|(
name|NULL
argument_list|,
name|type
argument_list|,
operator|&
name|g_fd_class
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|fd
argument_list|,
name|fdc
argument_list|,
name|fd_driver
argument_list|,
name|fd_devclass
argument_list|,
name|fdc_modevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

