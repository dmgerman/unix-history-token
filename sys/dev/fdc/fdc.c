begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Don Ahn.  *  * Libretto PCMCIA floppy support by David Horwitt (dhorwitt@ucsd.edu)  * aided by the Linux floppy driver modifications from David Bateman  * (dbateman@eng.uts.edu.au).  *  * Copyright (c) 1993, 1994 by  *  jc@irbs.UUCP (John Capo)  *  vak@zebub.msk.su (Serge Vakulenko)  *  ache@astral.msk.su (Andrew A. Chernov)  *  * Copyright (c) 1993, 1994, 1995 by  *  joerg_wunsch@uriah.sax.de (Joerg Wunsch)  *  dufault@hda.com (Peter Dufault)  *  * Copyright (c) 2001 Joerg Wunsch,  *  joerg_wunsch@uriah.heep.sax.de (Joerg Wunsch)  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from:	@(#)fd.c	7.4 (Berkeley) 5/25/91  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_fdc.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fdcio.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<isa/isareg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdc/fdcreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdc/fdcvar.h>
end_include

begin_include
include|#
directive|include
file|<isa/rtc.h>
end_include

begin_define
define|#
directive|define
name|FDBIO_FORMAT
value|BIO_CMD2
end_define

begin_comment
comment|/* configuration flags for fdc */
end_comment

begin_define
define|#
directive|define
name|FDC_NO_FIFO
value|(1<< 2)
end_define

begin_comment
comment|/* do not enable FIFO  */
end_comment

begin_comment
comment|/*  * Stop retrying after this many DMA overruns.  Since each retry takes  * one revolution, with 300 rpm., 25 retries take approximately 5  * seconds which the read attempt will block in case the DMA overrun  * is persistent.  */
end_comment

begin_define
define|#
directive|define
name|FDC_DMAOV_MAX
value|25
end_define

begin_comment
comment|/*  * Timeout value for the PIO loops to wait until the FDC main status  * register matches our expectations (request for master, direction  * bit).  This is supposed to be a number of microseconds, although  * timing might actually not be very accurate.  *  * Timeouts of 100 msec are believed to be required for some broken  * (old) hardware.  */
end_comment

begin_define
define|#
directive|define
name|FDSTS_TIMEOUT
value|100000
end_define

begin_comment
comment|/*  * Number of subdevices that can be used for different density types.  */
end_comment

begin_define
define|#
directive|define
name|NUMDENS
value|16
end_define

begin_define
define|#
directive|define
name|FDBIO_RDSECTID
value|BIO_CMD1
end_define

begin_comment
comment|/*  * List of native drive densities.  Order must match enum fd_drivetype  * in<sys/fdcio.h>.  Upon attaching the drive, each of the  * programmable subdevices is initialized with the native density  * definition.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fd_type
name|fd_native_types
index|[]
init|=
block|{
block|{
literal|0
block|}
block|,
comment|/* FDT_NONE */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x2A
block|,
literal|40
block|,
literal|720
block|,
name|FDC_250KBPS
block|,
literal|2
block|,
literal|0x50
block|,
literal|1
block|,
literal|0
block|,
name|FL_MFM
block|}
block|,
comment|/* FDT_360K */
block|{
literal|15
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2400
block|,
name|FDC_500KBPS
block|,
literal|2
block|,
literal|0x54
block|,
literal|1
block|,
literal|0
block|,
name|FL_MFM
block|}
block|,
comment|/* FDT_12M  */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x20
block|,
literal|80
block|,
literal|1440
block|,
name|FDC_250KBPS
block|,
literal|2
block|,
literal|0x50
block|,
literal|1
block|,
literal|0
block|,
name|FL_MFM
block|}
block|,
comment|/* FDT_720K */
block|{
literal|18
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2880
block|,
name|FDC_500KBPS
block|,
literal|2
block|,
literal|0x6C
block|,
literal|1
block|,
literal|0
block|,
name|FL_MFM
block|}
block|,
comment|/* FDT_144M */
if|#
directive|if
literal|0
comment|/* we currently don't handle 2.88 MB */
block|{ 36,2,0xFF,0x1B,80,5760,FDC_1MBPS,  2,0x4C,1,1,FL_MFM|FL_PERPND }
comment|/*FDT_288M*/
else|#
directive|else
block|{
literal|18
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2880
block|,
name|FDC_500KBPS
block|,
literal|2
block|,
literal|0x6C
block|,
literal|1
block|,
literal|0
block|,
name|FL_MFM
block|}
block|,
comment|/* FDT_144M */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * 360 KB 5.25" and 720 KB 3.5" drives don't have automatic density  * selection, they just start out with their native density (or lose).  * So 1.2 MB 5.25", 1.44 MB 3.5", and 2.88 MB 3.5" drives have their  * respective lists of densities to search for.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fd_type
name|fd_searchlist_12m
index|[]
init|=
block|{
block|{
literal|15
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2400
block|,
name|FDC_500KBPS
block|,
literal|2
block|,
literal|0x54
block|,
literal|1
block|,
literal|0
block|,
name|FL_MFM
block|}
block|,
comment|/* 1.2M */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x23
block|,
literal|40
block|,
literal|720
block|,
name|FDC_300KBPS
block|,
literal|2
block|,
literal|0x50
block|,
literal|1
block|,
literal|0
block|,
name|FL_MFM
operator||
name|FL_2STEP
block|}
block|,
comment|/* 360K */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x20
block|,
literal|80
block|,
literal|1440
block|,
name|FDC_300KBPS
block|,
literal|2
block|,
literal|0x50
block|,
literal|1
block|,
literal|0
block|,
name|FL_MFM
block|}
block|,
comment|/* 720K */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fd_type
name|fd_searchlist_144m
index|[]
init|=
block|{
block|{
literal|18
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2880
block|,
name|FDC_500KBPS
block|,
literal|2
block|,
literal|0x6C
block|,
literal|1
block|,
literal|0
block|,
name|FL_MFM
block|}
block|,
comment|/* 1.44M */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x20
block|,
literal|80
block|,
literal|1440
block|,
name|FDC_250KBPS
block|,
literal|2
block|,
literal|0x50
block|,
literal|1
block|,
literal|0
block|,
name|FL_MFM
block|}
block|,
comment|/* 720K */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We search for 1.44M first since this is the most common case. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fd_type
name|fd_searchlist_288m
index|[]
init|=
block|{
block|{
literal|18
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2880
block|,
name|FDC_500KBPS
block|,
literal|2
block|,
literal|0x6C
block|,
literal|1
block|,
literal|0
block|,
name|FL_MFM
block|}
block|,
comment|/* 1.44M */
if|#
directive|if
literal|0
block|{ 36,2,0xFF,0x1B,80,5760,FDC_1MBPS,  2,0x4C,1,1,FL_MFM|FL_PERPND }
comment|/* 2.88M */
endif|#
directive|endif
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x20
block|,
literal|80
block|,
literal|1440
block|,
name|FDC_250KBPS
block|,
literal|2
block|,
literal|0x50
block|,
literal|1
block|,
literal|0
block|,
name|FL_MFM
block|}
block|,
comment|/* 720K */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_SEC_SIZE
value|(128<< 3)
end_define

begin_define
define|#
directive|define
name|MAX_CYLINDER
value|85
end_define

begin_comment
comment|/* some people really stress their drives 				 * up to cyl 82 */
end_comment

begin_define
define|#
directive|define
name|MAX_HEAD
value|1
end_define

begin_decl_stmt
name|devclass_t
name|fdc_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Per drive structure (softc).  */
end_comment

begin_struct
struct|struct
name|fd_data
block|{
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
comment|/* pointer to controller structure */
name|int
name|fdsu
decl_stmt|;
comment|/* this units number on this controller */
name|enum
name|fd_drivetype
name|type
decl_stmt|;
comment|/* drive type */
name|struct
name|fd_type
modifier|*
name|ft
decl_stmt|;
comment|/* pointer to current type descriptor */
name|struct
name|fd_type
name|fts
index|[
name|NUMDENS
index|]
decl_stmt|;
comment|/* type descriptors */
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|FD_OPEN
value|0x01
comment|/* it's open		*/
define|#
directive|define
name|FD_NONBLOCK
value|0x02
comment|/* O_NONBLOCK set	*/
define|#
directive|define
name|FD_ACTIVE
value|0x04
comment|/* it's active		*/
define|#
directive|define
name|FD_MOTOR
value|0x08
comment|/* motor should be on	*/
define|#
directive|define
name|FD_MOTOR_WAIT
value|0x10
comment|/* motor coming up	*/
define|#
directive|define
name|FD_UA
value|0x20
comment|/* force unit attention */
name|int
name|skip
decl_stmt|;
name|int
name|hddrv
decl_stmt|;
define|#
directive|define
name|FD_NO_TRACK
value|-2
name|int
name|track
decl_stmt|;
comment|/* where we think the head is */
name|int
name|options
decl_stmt|;
comment|/* user configurable options, see fdcio.h */
name|struct
name|callout_handle
name|toffhandle
decl_stmt|;
name|struct
name|callout_handle
name|tohandle
decl_stmt|;
name|struct
name|devstat
modifier|*
name|device_stats
decl_stmt|;
name|struct
name|cdev
modifier|*
name|masterdev
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|fdu_t
name|fdu
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fdc_ivars
block|{
name|int
name|fdunit
decl_stmt|;
name|int
name|fdtype
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|devclass_t
name|fd_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* configuration flags for fd */
end_comment

begin_define
define|#
directive|define
name|FD_TYPEMASK
value|0x0f
end_define

begin_comment
comment|/* drive type, matches enum 				 * fd_drivetype; on i386 machines, if 				 * given as 0, use RTC type for fd0 				 * and fd1 */
end_comment

begin_define
define|#
directive|define
name|FD_DTYPE
parameter_list|(
name|flags
parameter_list|)
value|((flags)& FD_TYPEMASK)
end_define

begin_define
define|#
directive|define
name|FD_NO_CHLINE
value|0x10
end_define

begin_comment
comment|/* drive does not support changeline 				 * aka. unit attention */
end_comment

begin_define
define|#
directive|define
name|FD_NO_PROBE
value|0x20
end_define

begin_comment
comment|/* don't probe drive (seek test), just 				 * assume it is there */
end_comment

begin_comment
comment|/*  * Throughout this file the following conventions will be used:  *  * fd is a pointer to the fd_data struct for the drive in question  * fdc is a pointer to the fdc_data struct for the controller  * fdu is the floppy drive unit number  * fdcu is the floppy controller unit number  * fdsu is the floppy drive unit number on that controller. (sub-unit)  */
end_comment

begin_comment
comment|/*  * Function declarations, same (chaotic) order as they appear in the  * file.  Re-ordering is too late now, it would only obfuscate the  * diffs against old and offspring versions (like the PC98 one).  *  * Anyone adding functions here, please keep this sequence the same  * as below -- makes locating a particular function in the body much  * easier.  */
end_comment

begin_function_decl
specifier|static
name|u_int8_t
name|fdsts_rd
parameter_list|(
name|fdc_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fddata_wr
parameter_list|(
name|fdc_p
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|fddata_rd
parameter_list|(
name|fdc_p
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static u_int8_t fdin_rd(fdc_p);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|fdc_err
parameter_list|(
name|struct
name|fdc_data
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|enable_fifo
parameter_list|(
name|fdc_p
name|fdc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fd_sense_drive_status
parameter_list|(
name|fdc_p
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fd_sense_int
parameter_list|(
name|fdc_p
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fd_read_status
parameter_list|(
name|fdc_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fdc_add_child
parameter_list|(
name|device_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fd_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fd_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fd_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_motor
parameter_list|(
name|struct
name|fdc_data
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|TURNON
value|1
end_define

begin_define
define|#
directive|define
name|TURNOFF
value|0
end_define

begin_decl_stmt
specifier|static
name|timeout_t
name|fd_turnoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|fd_motor_on
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|fd_turnon
parameter_list|(
name|struct
name|fd_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fdc_reset
parameter_list|(
name|fdc_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fd_in
parameter_list|(
name|struct
name|fdc_data
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|out_fdc
parameter_list|(
name|struct
name|fdc_data
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * The open function is named fdopen() to avoid confusion with fdopen()  * in fd(4).  The difference is now only meaningful for debuggers.  */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|fdopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|fdclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|fdstrategy
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|fdstart
parameter_list|(
name|struct
name|fdc_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|fd_iotimeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|fd_pseudointr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_intr_t
name|fdc_intr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|fdcpio
parameter_list|(
name|fdc_p
parameter_list|,
name|long
parameter_list|,
name|caddr_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdautoselect
parameter_list|(
name|struct
name|cdev
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdstate
parameter_list|(
name|struct
name|fdc_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|retrier
parameter_list|(
name|struct
name|fdc_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fdbiodone
parameter_list|(
name|struct
name|bio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdmisccmd
parameter_list|(
name|struct
name|cdev
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|fdioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fifo_threshold
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX: should be accessible via sysctl */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FDC_DEBUG
end_ifdef

begin_comment
comment|/* CAUTION: fd_debug causes huge amounts of logging output */
end_comment

begin_decl_stmt
specifier|static
name|int
specifier|volatile
name|fd_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRACE0
parameter_list|(
name|arg
parameter_list|)
value|do { if (fd_debug) printf(arg); } while (0)
end_define

begin_define
define|#
directive|define
name|TRACE1
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
value|do { if (fd_debug) printf(arg1, arg2); } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* FDC_DEBUG */
end_comment

begin_define
define|#
directive|define
name|TRACE0
parameter_list|(
name|arg
parameter_list|)
value|do { } while (0)
end_define

begin_define
define|#
directive|define
name|TRACE1
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FDC_DEBUG */
end_comment

begin_comment
comment|/*  * Bus space handling (access to low-level IO).  */
end_comment

begin_function
name|void
name|fdout_wr
parameter_list|(
name|fdc_p
name|fdc
parameter_list|,
name|u_int8_t
name|v
parameter_list|)
block|{
name|bus_space_write_1
argument_list|(
name|fdc
operator|->
name|portt
argument_list|,
name|fdc
operator|->
name|porth
argument_list|,
name|FDOUT
operator|+
name|fdc
operator|->
name|port_off
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|fdsts_rd
parameter_list|(
name|fdc_p
name|fdc
parameter_list|)
block|{
return|return
name|bus_space_read_1
argument_list|(
name|fdc
operator|->
name|portt
argument_list|,
name|fdc
operator|->
name|porth
argument_list|,
name|FDSTS
operator|+
name|fdc
operator|->
name|port_off
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fddata_wr
parameter_list|(
name|fdc_p
name|fdc
parameter_list|,
name|u_int8_t
name|v
parameter_list|)
block|{
name|bus_space_write_1
argument_list|(
name|fdc
operator|->
name|portt
argument_list|,
name|fdc
operator|->
name|porth
argument_list|,
name|FDDATA
operator|+
name|fdc
operator|->
name|port_off
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|fddata_rd
parameter_list|(
name|fdc_p
name|fdc
parameter_list|)
block|{
return|return
name|bus_space_read_1
argument_list|(
name|fdc
operator|->
name|portt
argument_list|,
name|fdc
operator|->
name|porth
argument_list|,
name|FDDATA
operator|+
name|fdc
operator|->
name|port_off
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|fdin_rd
parameter_list|(
name|fdc_p
name|fdc
parameter_list|)
block|{
return|return
name|bus_space_read_1
argument_list|(
name|fdc
operator|->
name|portt
argument_list|,
name|fdc
operator|->
name|porth
argument_list|,
name|FDIN
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|fd_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|fdopen
block|,
operator|.
name|d_close
operator|=
name|fdclose
block|,
operator|.
name|d_read
operator|=
name|physread
block|,
operator|.
name|d_write
operator|=
name|physwrite
block|,
operator|.
name|d_ioctl
operator|=
name|fdioctl
block|,
operator|.
name|d_strategy
operator|=
name|fdstrategy
block|,
operator|.
name|d_name
operator|=
literal|"fd"
block|,
operator|.
name|d_flags
operator|=
name|D_DISK
operator||
name|D_NEEDGIANT
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Auxiliary functions.  Well, some only.  Others are scattered  * throughout the entire file.  */
end_comment

begin_function
specifier|static
name|int
name|fdc_err
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|fdc
operator|->
name|fdc_errs
operator|++
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|fdc
operator|->
name|fdc_errs
operator|<
name|FDC_ERRMAX
condition|)
name|device_printf
argument_list|(
name|fdc
operator|->
name|fdc_dev
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fdc
operator|->
name|fdc_errs
operator|==
name|FDC_ERRMAX
condition|)
name|device_printf
argument_list|(
name|fdc
operator|->
name|fdc_dev
argument_list|,
literal|"too many errors, not "
literal|"logging any more\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|FD_FAILED
return|;
block|}
end_function

begin_comment
comment|/*  * fd_cmd: Send a command to the chip.  Takes a varargs with this structure:  * Unit number,  * # of output bytes, output bytes as ints ...,  * # of input bytes, input bytes as ints ...  */
end_comment

begin_function
name|int
name|fd_cmd
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|int
name|n_out
parameter_list|,
modifier|...
parameter_list|)
block|{
name|u_char
name|cmd
decl_stmt|;
name|int
name|n_in
decl_stmt|;
name|int
name|n
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|n_out
argument_list|)
expr_stmt|;
name|cmd
operator|=
call|(
name|u_char
call|)
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|n_out
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_out
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|out_fdc
argument_list|(
name|fdc
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|msg
index|[
literal|50
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"cmd %x failed at out byte %d of %d\n"
argument_list|,
name|cmd
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|n_out
argument_list|)
expr_stmt|;
return|return
name|fdc_err
argument_list|(
name|fdc
argument_list|,
name|msg
argument_list|)
return|;
block|}
block|}
name|n_in
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_in
condition|;
name|n
operator|++
control|)
block|{
name|int
modifier|*
name|ptr
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd_in
argument_list|(
name|fdc
argument_list|,
name|ptr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|msg
index|[
literal|50
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"cmd %02x failed at in byte %d of %d\n"
argument_list|,
name|cmd
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|n_in
argument_list|)
expr_stmt|;
return|return
name|fdc_err
argument_list|(
name|fdc
argument_list|,
name|msg
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|enable_fifo
parameter_list|(
name|fdc_p
name|fdc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_HAS_FIFO
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Cannot use fd_cmd the normal way here, since 		 * this might be an invalid command. Thus we send the 		 * first byte, and check for an early turn of data directon. 		 */
if|if
condition|(
name|out_fdc
argument_list|(
name|fdc
argument_list|,
name|I8207X_CONFIGURE
argument_list|)
operator|<
literal|0
condition|)
return|return
name|fdc_err
argument_list|(
name|fdc
argument_list|,
literal|"Enable FIFO failed\n"
argument_list|)
return|;
comment|/* If command is invalid, return */
name|j
operator|=
name|FDSTS_TIMEOUT
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|fdsts_rd
argument_list|(
name|fdc
argument_list|)
operator|&
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
operator|)
operator|!=
name|NE7_RQM
operator|&&
name|j
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
condition|)
block|{
name|fdc_reset
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
return|return
name|FD_FAILED
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<
literal|0
operator|||
name|fd_cmd
argument_list|(
name|fdc
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
operator|(
name|fifo_threshold
operator|-
literal|1
operator|)
operator|&
literal|0xf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fdc_reset
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
return|return
name|fdc_err
argument_list|(
name|fdc
argument_list|,
literal|"Enable FIFO failed\n"
argument_list|)
return|;
block|}
name|fdc
operator|->
name|flags
operator||=
name|FDC_HAS_FIFO
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdc
argument_list|,
literal|4
argument_list|,
name|I8207X_CONFIGURE
argument_list|,
literal|0
argument_list|,
operator|(
name|fifo_threshold
operator|-
literal|1
operator|)
operator|&
literal|0xf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
name|fdc_err
argument_list|(
name|fdc
argument_list|,
literal|"Re-enable FIFO failed\n"
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fd_sense_drive_status
parameter_list|(
name|fdc_p
name|fdc
parameter_list|,
name|int
modifier|*
name|st3p
parameter_list|)
block|{
name|int
name|st3
decl_stmt|;
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdc
argument_list|,
literal|2
argument_list|,
name|NE7CMD_SENSED
argument_list|,
name|fdc
operator|->
name|fdu
argument_list|,
literal|1
argument_list|,
operator|&
name|st3
argument_list|)
condition|)
block|{
return|return
name|fdc_err
argument_list|(
name|fdc
argument_list|,
literal|"Sense Drive Status failed\n"
argument_list|)
return|;
block|}
if|if
condition|(
name|st3p
condition|)
operator|*
name|st3p
operator|=
name|st3
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fd_sense_int
parameter_list|(
name|fdc_p
name|fdc
parameter_list|,
name|int
modifier|*
name|st0p
parameter_list|,
name|int
modifier|*
name|cylp
parameter_list|)
block|{
name|int
name|cyl
decl_stmt|,
name|st0
decl_stmt|,
name|ret
decl_stmt|;
name|ret
operator|=
name|fd_cmd
argument_list|(
name|fdc
argument_list|,
literal|1
argument_list|,
name|NE7CMD_SENSEI
argument_list|,
literal|1
argument_list|,
operator|&
name|st0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|(
name|void
operator|)
name|fdc_err
argument_list|(
name|fdc
argument_list|,
literal|"sense intr err reading stat reg 0\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|st0p
condition|)
operator|*
name|st0p
operator|=
name|st0
expr_stmt|;
if|if
condition|(
operator|(
name|st0
operator|&
name|NE7_ST0_IC
operator|)
operator|==
name|NE7_ST0_IC_IV
condition|)
block|{
comment|/* 		 * There doesn't seem to have been an interrupt. 		 */
return|return
name|FD_NOT_VALID
return|;
block|}
if|if
condition|(
name|fd_in
argument_list|(
name|fdc
argument_list|,
operator|&
name|cyl
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|fdc_err
argument_list|(
name|fdc
argument_list|,
literal|"can't get cyl num\n"
argument_list|)
return|;
block|}
if|if
condition|(
name|cylp
condition|)
operator|*
name|cylp
operator|=
name|cyl
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fd_read_status
parameter_list|(
name|fdc_p
name|fdc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ret
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * XXX types are poorly chosen.  Only bytes can be read 		 * from the hardware, but fdc->status[] wants u_ints and 		 * fd_in() gives ints. 		 */
name|int
name|status
decl_stmt|;
name|ret
operator|=
name|fd_in
argument_list|(
name|fdc
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|status
index|[
name|i
index|]
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|fdc
operator|->
name|flags
operator||=
name|FDC_STAT_VALID
expr_stmt|;
else|else
name|fdc
operator|->
name|flags
operator|&=
operator|~
name|FDC_STAT_VALID
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|fdc_alloc_resources
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|ispnp
decl_stmt|,
name|ispcmcia
decl_stmt|,
name|nports
decl_stmt|;
name|dev
operator|=
name|fdc
operator|->
name|fdc_dev
expr_stmt|;
name|ispnp
operator|=
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_ISPNP
operator|)
operator|!=
literal|0
expr_stmt|;
name|ispcmcia
operator|=
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_ISPCMCIA
operator|)
operator|!=
literal|0
expr_stmt|;
name|fdc
operator|->
name|rid_ioport
operator|=
name|fdc
operator|->
name|rid_irq
operator|=
name|fdc
operator|->
name|rid_drq
operator|=
literal|0
expr_stmt|;
name|fdc
operator|->
name|res_ioport
operator|=
name|fdc
operator|->
name|res_irq
operator|=
name|fdc
operator|->
name|res_drq
operator|=
literal|0
expr_stmt|;
name|fdc
operator|->
name|rid_ctl
operator|=
literal|1
expr_stmt|;
comment|/* 	 * On standard ISA, we don't just use an 8 port range 	 * (e.g. 0x3f0-0x3f7) since that covers an IDE control 	 * register at 0x3f6. 	 * 	 * Isn't PC hardware wonderful. 	 * 	 * The Y-E Data PCMCIA FDC doesn't have this problem, it 	 * uses the register with offset 6 for pseudo-DMA, and the 	 * one with offset 7 as control register. 	 */
name|nports
operator|=
name|ispcmcia
condition|?
literal|8
else|:
operator|(
name|ispnp
condition|?
literal|1
else|:
literal|6
operator|)
expr_stmt|;
comment|/* 	 * Some ACPI BIOSen have _CRS objects for the floppy device that 	 * split the I/O port resource into several resources.  We detect 	 * this case by checking if there are more than 2 IOPORT resources. 	 * If so, we use the resource with the smallest start address as 	 * the port RID and the largest start address as the control RID. 	 */
if|if
condition|(
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|u_long
name|min_start
decl_stmt|,
name|max_start
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find the min/max start addresses and their RIDs. */
name|max_start
operator|=
literal|0ul
expr_stmt|;
name|min_start
operator|=
operator|~
literal|0ul
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|i
argument_list|)
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tmp
operator|!=
literal|0
argument_list|,
operator|(
literal|"bogus resource"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
name|min_start
condition|)
block|{
name|min_start
operator|=
name|tmp
expr_stmt|;
name|fdc
operator|->
name|rid_ioport
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|>
name|max_start
condition|)
block|{
name|max_start
operator|=
name|tmp
expr_stmt|;
name|fdc
operator|->
name|rid_ctl
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min_start
operator|+
literal|7
operator|!=
name|max_start
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"I/O to control range incorrect\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
name|fdc
operator|->
name|res_ioport
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|fdc
operator|->
name|rid_ioport
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
name|nports
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|res_ioport
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot reserve I/O port range (%d ports)\n"
argument_list|,
name|nports
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|fdc
operator|->
name|portt
operator|=
name|rman_get_bustag
argument_list|(
name|fdc
operator|->
name|res_ioport
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|porth
operator|=
name|rman_get_bushandle
argument_list|(
name|fdc
operator|->
name|res_ioport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ispcmcia
condition|)
block|{
comment|/* 		 * Some BIOSen report the device at 0x3f2-0x3f5,0x3f7 		 * and some at 0x3f0-0x3f5,0x3f7. We detect the former 		 * by checking the size and adjust the port address 		 * accordingly. 		 */
if|if
condition|(
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|)
operator|==
literal|4
condition|)
name|fdc
operator|->
name|port_off
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* 		 * Register the control port range as rid 1 if it 		 * isn't there already. Most PnP BIOSen will have 		 * already done this but non-PnP configurations don't. 		 * 		 * And some (!!) report 0x3f2-0x3f5 and completely 		 * leave out the control register!  It seems that some 		 * non-antique controller chips have a different 		 * method of programming the transfer speed which 		 * doesn't require the control register, but it's 		 * mighty bogus as the chip still responds to the 		 * address for the control register. 		 */
if|if
condition|(
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u_long
name|ctlstart
decl_stmt|;
comment|/* Find the control port, usually 0x3f7 */
name|ctlstart
operator|=
name|rman_get_start
argument_list|(
name|fdc
operator|->
name|res_ioport
argument_list|)
operator|+
name|fdc
operator|->
name|port_off
operator|+
literal|7
expr_stmt|;
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|1
argument_list|,
name|ctlstart
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now (finally!) allocate the control port. 		 */
name|fdc
operator|->
name|res_ctl
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|fdc
operator|->
name|rid_ctl
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|res_ctl
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot reserve control I/O port range (control port)\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|fdc
operator|->
name|ctlt
operator|=
name|rman_get_bustag
argument_list|(
name|fdc
operator|->
name|res_ctl
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|ctlh
operator|=
name|rman_get_bushandle
argument_list|(
name|fdc
operator|->
name|res_ctl
argument_list|)
expr_stmt|;
block|}
name|fdc
operator|->
name|res_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|fdc
operator|->
name|rid_irq
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|res_irq
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot reserve interrupt line\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
operator|)
operator|==
literal|0
condition|)
block|{
name|fdc
operator|->
name|res_drq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
operator|&
name|fdc
operator|->
name|rid_drq
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|res_drq
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot reserve DMA request line\n"
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|flags
operator||=
name|FDC_NODMA
expr_stmt|;
block|}
else|else
name|fdc
operator|->
name|dmachan
operator|=
name|rman_get_start
argument_list|(
name|fdc
operator|->
name|res_drq
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|fdc_release_resources
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|fdc
operator|->
name|fdc_dev
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|res_irq
operator|!=
literal|0
condition|)
block|{
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|fdc
operator|->
name|rid_irq
argument_list|,
name|fdc
operator|->
name|res_irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|fdc
operator|->
name|rid_irq
argument_list|,
name|fdc
operator|->
name|res_irq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fdc
operator|->
name|res_ctl
operator|!=
literal|0
condition|)
block|{
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|fdc
operator|->
name|rid_ctl
argument_list|,
name|fdc
operator|->
name|res_ctl
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|fdc
operator|->
name|rid_ctl
argument_list|,
name|fdc
operator|->
name|res_ctl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fdc
operator|->
name|res_ioport
operator|!=
literal|0
condition|)
block|{
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|fdc
operator|->
name|rid_ioport
argument_list|,
name|fdc
operator|->
name|res_ioport
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|fdc
operator|->
name|rid_ioport
argument_list|,
name|fdc
operator|->
name|res_ioport
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fdc
operator|->
name|res_drq
operator|!=
literal|0
condition|)
block|{
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|fdc
operator|->
name|rid_drq
argument_list|,
name|fdc
operator|->
name|res_drq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|fdc
operator|->
name|rid_drq
argument_list|,
name|fdc
operator|->
name|res_drq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Configuration/initialization stuff, per controller.  */
end_comment

begin_function
name|int
name|fdc_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|fdc_ivars
modifier|*
name|ivars
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|FDC_IVAR_FDUNIT
case|:
operator|*
name|result
operator|=
name|ivars
operator|->
name|fdunit
expr_stmt|;
break|break;
case|case
name|FDC_IVAR_FDTYPE
case|:
operator|*
name|result
operator|=
name|ivars
operator|->
name|fdtype
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fdc_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|fdc_ivars
modifier|*
name|ivars
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|FDC_IVAR_FDUNIT
case|:
name|ivars
operator|->
name|fdunit
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|FDC_IVAR_FDTYPE
case|:
name|ivars
operator|->
name|fdtype
operator|=
name|value
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fdc_initial_reset
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|)
block|{
comment|/* First, reset the floppy controller. */
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
name|FDO_FRST
argument_list|)
expr_stmt|;
comment|/* Then, see if it can handle a command. */
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdc
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SPECIFY
argument_list|,
name|NE7_SPEC_1
argument_list|(
literal|3
argument_list|,
literal|240
argument_list|)
argument_list|,
name|NE7_SPEC_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fdc_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fdc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* have our children detached first */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* reset controller, turn motor off */
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_ATTACHED
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"already unloaded\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fdc
operator|->
name|flags
operator|&=
operator|~
name|FDC_ATTACHED
expr_stmt|;
name|BUS_TEARDOWN_INTR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|fdc
operator|->
name|res_irq
argument_list|,
name|fdc
operator|->
name|fdc_intr
argument_list|)
expr_stmt|;
name|fdc_release_resources
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a child device to the fdc controller.  It will then be probed etc.  */
end_comment

begin_function
specifier|static
name|void
name|fdc_add_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|int
name|fdu
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|fdc_ivars
modifier|*
name|ivar
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|ivar
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ivar
argument_list|,
name|M_DEVBUF
comment|/* XXX */
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivar
operator|==
name|NULL
condition|)
return|return;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ivar
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|ivar
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|name
argument_list|,
name|unit
argument_list|,
literal|"drive"
argument_list|,
operator|&
name|fdu
argument_list|)
operator|!=
literal|0
condition|)
name|fdu
operator|=
literal|0
expr_stmt|;
name|fdc_set_fdunit
argument_list|(
name|child
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
name|fdc_set_fdtype
argument_list|(
name|child
argument_list|,
name|FDT_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|name
argument_list|,
name|unit
argument_list|,
literal|"flags"
argument_list|,
operator|&
name|flags
argument_list|)
operator|==
literal|0
condition|)
name|device_set_flags
argument_list|(
name|child
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_disabled
argument_list|(
name|name
argument_list|,
name|unit
argument_list|)
condition|)
name|device_disable
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fdc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|dname
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|dunit
decl_stmt|;
name|fdc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|fdc_alloc_resources
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot re-acquire resources\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|BUS_SETUP_INTR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|fdc
operator|->
name|res_irq
argument_list|,
name|INTR_TYPE_BIO
operator||
name|INTR_ENTROPY
argument_list|,
name|fdc_intr
argument_list|,
name|fdc
argument_list|,
operator|&
name|fdc
operator|->
name|fdc_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot setup interrupt\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|fdc
operator|->
name|fdcu
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|flags
operator||=
name|FDC_ATTACHED
operator||
name|FDC_NEEDS_RESET
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|DEVIDLE
expr_stmt|;
comment|/* reset controller, turn motor off, clear fdout mirror reg */
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
name|fdc
operator|->
name|fdout
operator|=
literal|0
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|fdc
operator|->
name|head
argument_list|)
expr_stmt|;
comment|/* 	 * Probe and attach any children.  We should probably detect 	 * devices from the BIOS unless overridden. 	 */
name|name
operator|=
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|resource_find_match
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|dname
argument_list|,
operator|&
name|dunit
argument_list|,
literal|"at"
argument_list|,
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|fdc_add_child
argument_list|(
name|dev
argument_list|,
name|dname
argument_list|,
name|dunit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fdc_print_child
parameter_list|(
name|device_t
name|me
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|me
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" on %s drive %d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|me
argument_list|)
argument_list|,
name|fdc_get_fdunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|device_get_flags
argument_list|(
name|me
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|retval
operator|+=
name|printf
argument_list|(
literal|" flags %#x"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Configuration/initialization, per drive.  */
end_comment

begin_function
specifier|static
name|int
name|fd_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|st0
decl_stmt|,
name|st3
decl_stmt|;
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
name|fdsu_t
name|fdsu
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|type
decl_stmt|;
name|fdsu
operator|=
name|fdc_get_fdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fd
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fdc
operator|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|device_get_flags
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fd
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|fd
operator|->
name|fdc
operator|=
name|fdc
expr_stmt|;
name|fd
operator|->
name|fdsu
operator|=
name|fdsu
expr_stmt|;
name|fd
operator|->
name|fdu
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|type
operator|=
name|FD_DTYPE
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* Auto-probe if fdinfo is present, but always allow override. */
if|if
condition|(
name|type
operator|==
name|FDT_NONE
operator|&&
operator|(
name|type
operator|=
name|fdc_get_fdtype
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
name|FDT_NONE
condition|)
block|{
name|fd
operator|->
name|type
operator|=
name|type
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
comment|/* make sure fdautoselect() will be called */
name|fd
operator|->
name|flags
operator|=
name|FD_UA
expr_stmt|;
name|fd
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
comment|/*  * XXX I think using __i386__ is wrong here since we actually want to probe  * for the machine type, not the CPU type (so non-PC arch's like the PC98 will  * fail the probe).  However, for whatever reason, testing for _MACHINE_ARCH  * == i386 breaks the test on FreeBSD/Alpha.  */
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
if|if
condition|(
name|fd
operator|->
name|type
operator|==
name|FDT_NONE
operator|&&
operator|(
name|fd
operator|->
name|fdu
operator|==
literal|0
operator|||
name|fd
operator|->
name|fdu
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* Look up what the BIOS thinks we have. */
if|if
condition|(
name|fd
operator|->
name|fdu
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_ISPCMCIA
operator|)
condition|)
comment|/* 				 * Somewhat special.  No need to force the 				 * user to set device flags, since the Y-E 				 * Data PCMCIA floppy is always a 1.44 MB 				 * device. 				 */
name|fd
operator|->
name|type
operator|=
name|FDT_144M
expr_stmt|;
else|else
name|fd
operator|->
name|type
operator|=
operator|(
name|rtcin
argument_list|(
name|RTC_FDISKETTE
argument_list|)
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
expr_stmt|;
block|}
else|else
block|{
name|fd
operator|->
name|type
operator|=
name|rtcin
argument_list|(
name|RTC_FDISKETTE
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|->
name|type
operator|==
name|FDT_288M_1
condition|)
name|fd
operator|->
name|type
operator|=
name|FDT_288M
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __i386__ || __amd64__ */
comment|/* is there a unit? */
if|if
condition|(
name|fd
operator|->
name|type
operator|==
name|FDT_NONE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* select it */
name|set_motor
argument_list|(
name|fdc
argument_list|,
name|fdsu
argument_list|,
name|TURNON
argument_list|)
expr_stmt|;
name|fdc_reset
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
comment|/* XXX reset, then unreset, etc. */
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
comment|/* 1 sec */
if|if
condition|(
operator|(
name|flags
operator|&
name|FD_NO_PROBE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* If we're at track 0 first seek inwards. */
if|if
condition|(
operator|(
name|fd_sense_drive_status
argument_list|(
name|fdc
argument_list|,
operator|&
name|st3
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|st3
operator|&
name|NE7_ST3_T0
operator|)
condition|)
block|{
comment|/* Seek some steps... */
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdc
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SEEK
argument_list|,
name|fdsu
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* ...wait a moment... */
name|DELAY
argument_list|(
literal|300000
argument_list|)
expr_stmt|;
comment|/* make ctrlr happy: */
name|fd_sense_int
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * we must recalibrate twice, just in case the 			 * heads have been beyond cylinder 76, since 			 * most FDCs still barf when attempting to 			 * recalibrate more than 77 steps 			 */
comment|/* go back to 0: */
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdc
argument_list|,
literal|2
argument_list|,
name|NE7CMD_RECAL
argument_list|,
name|fdsu
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* a second being enough for full stroke seek*/
name|DELAY
argument_list|(
name|i
operator|==
literal|0
condition|?
literal|1000000
else|:
literal|300000
argument_list|)
expr_stmt|;
comment|/* anything responding? */
if|if
condition|(
name|fd_sense_int
argument_list|(
name|fdc
argument_list|,
operator|&
name|st0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|st0
operator|&
name|NE7_ST0_EC
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* already probed succesfully */
block|}
block|}
block|}
name|set_motor
argument_list|(
name|fdc
argument_list|,
name|fdsu
argument_list|,
name|TURNOFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FD_NO_PROBE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|st0
operator|&
name|NE7_ST0_EC
operator|)
operator|!=
literal|0
condition|)
comment|/* no track 0 -> no drive present */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|done
label|:
comment|/* This doesn't work before the first reset.  Or set_motor?? */
if|if
condition|(
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_HAS_FIFO
operator|)
operator|==
literal|0
operator|&&
name|fdc
operator|->
name|fdct
operator|==
name|FDC_ENHANCED
operator|&&
operator|(
name|device_get_flags
argument_list|(
name|fdc
operator|->
name|fdc_dev
argument_list|)
operator|&
name|FDC_NO_FIFO
operator|)
operator|==
literal|0
operator|&&
name|enable_fifo
argument_list|(
name|fdc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"FIFO enabled, %d bytes threshold\n"
argument_list|,
name|fifo_threshold
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|fd
operator|->
name|type
condition|)
block|{
case|case
name|FDT_12M
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"1200-KB 5.25\" drive"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDT_144M
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"1440-KB 3.5\" drive"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDT_288M
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"2880-KB 3.5\" drive (in 1440-KB mode)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDT_360K
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"360-KB 5.25\" drive"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDT_720K
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"720-KB 3.5\" drive"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|fd
operator|->
name|track
operator|=
name|FD_NO_TRACK
expr_stmt|;
name|fd
operator|->
name|fdc
operator|=
name|fdc
expr_stmt|;
name|fd
operator|->
name|fdsu
operator|=
name|fdsu
expr_stmt|;
name|fd
operator|->
name|options
operator|=
literal|0
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|fd
operator|->
name|toffhandle
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|fd
operator|->
name|tohandle
argument_list|)
expr_stmt|;
comment|/* initialize densities for subdevices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMDENS
condition|;
name|i
operator|++
control|)
name|memcpy
argument_list|(
name|fd
operator|->
name|fts
operator|+
name|i
argument_list|,
name|fd_native_types
operator|+
name|fd
operator|->
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fd_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fd_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|fd
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fd
operator|->
name|masterdev
operator|=
name|make_dev
argument_list|(
operator|&
name|fd_cdevsw
argument_list|,
name|fd
operator|->
name|fdu
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"fd%d"
argument_list|,
name|fd
operator|->
name|fdu
argument_list|)
expr_stmt|;
name|fd
operator|->
name|masterdev
operator|->
name|si_drv1
operator|=
name|fd
expr_stmt|;
name|fd
operator|->
name|device_stats
operator|=
name|devstat_new_entry
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DEVSTAT_NO_ORDERED_TAGS
argument_list|,
name|DEVSTAT_TYPE_FLOPPY
operator||
name|DEVSTAT_TYPE_IF_OTHER
argument_list|,
name|DEVSTAT_PRIORITY_FD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fd_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|fd
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|fd_turnoff
argument_list|,
name|fd
argument_list|,
name|fd
operator|->
name|toffhandle
argument_list|)
expr_stmt|;
name|devstat_remove_entry
argument_list|(
name|fd
operator|->
name|device_stats
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|fd
operator|->
name|masterdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|fd_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fd_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fd_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fd_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
comment|/* XXX */
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
comment|/* XXX */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fd_driver
init|=
block|{
literal|"fd"
block|,
name|fd_methods
block|,
expr|sizeof
operator|(
expr|struct
name|fd_data
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|fd
argument_list|,
name|fdc
argument_list|,
name|fd_driver
argument_list|,
name|fd_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * More auxiliary functions.  */
end_comment

begin_comment
comment|/*  * Motor control stuff.  * Remember to not deselect the drive we're working on.  */
end_comment

begin_function
specifier|static
name|void
name|set_motor
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|int
name|fdsu
parameter_list|,
name|int
name|turnon
parameter_list|)
block|{
name|int
name|fdout
decl_stmt|;
name|fdout
operator|=
name|fdc
operator|->
name|fdout
expr_stmt|;
if|if
condition|(
name|turnon
condition|)
block|{
name|fdout
operator|&=
operator|~
name|FDO_FDSEL
expr_stmt|;
name|fdout
operator||=
operator|(
name|FDO_MOEN0
operator|<<
name|fdsu
operator|)
operator||
name|FDO_FDMAEN
operator||
name|FDO_FRST
operator||
name|fdsu
expr_stmt|;
block|}
else|else
name|fdout
operator|&=
operator|~
operator|(
name|FDO_MOEN0
operator|<<
name|fdsu
operator|)
expr_stmt|;
name|fdc
operator|->
name|fdout
operator|=
name|fdout
expr_stmt|;
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
name|fdout
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[0x%x->FDOUT]"
argument_list|,
name|fdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fd_turnoff
parameter_list|(
name|void
modifier|*
name|xfd
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|fd_p
name|fd
init|=
name|xfd
decl_stmt|;
name|TRACE1
argument_list|(
literal|"[fd%d: turnoff]"
argument_list|,
name|fd
operator|->
name|fdu
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * Don't turn off the motor yet if the drive is active. 	 * 	 * If we got here, this could only mean we missed an interrupt. 	 * This can e. g. happen on the Y-E Date PCMCIA floppy controller 	 * after a controller reset.  Just schedule a pseudo-interrupt 	 * so the state machine gets re-entered. 	 */
if|if
condition|(
name|fd
operator|->
name|fdc
operator|->
name|state
operator|!=
name|DEVIDLE
operator|&&
name|fd
operator|->
name|fdc
operator|->
name|fdu
operator|==
name|fd
operator|->
name|fdu
condition|)
block|{
name|fdc_intr
argument_list|(
name|fd
operator|->
name|fdc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|fd
operator|->
name|flags
operator|&=
operator|~
name|FD_MOTOR
expr_stmt|;
name|set_motor
argument_list|(
name|fd
operator|->
name|fdc
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
name|TURNOFF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fd_motor_on
parameter_list|(
name|void
modifier|*
name|xfd
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|fd_p
name|fd
init|=
name|xfd
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|fd
operator|->
name|flags
operator|&=
operator|~
name|FD_MOTOR_WAIT
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|->
name|fdc
operator|->
name|fd
operator|==
name|fd
operator|)
operator|&&
operator|(
name|fd
operator|->
name|fdc
operator|->
name|state
operator|==
name|MOTORWAIT
operator|)
condition|)
block|{
name|fdc_intr
argument_list|(
name|fd
operator|->
name|fdc
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fd_turnon
parameter_list|(
name|fd_p
name|fd
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_MOTOR
operator|)
condition|)
block|{
name|fd
operator|->
name|flags
operator||=
operator|(
name|FD_MOTOR
operator|+
name|FD_MOTOR_WAIT
operator|)
expr_stmt|;
name|set_motor
argument_list|(
name|fd
operator|->
name|fdc
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
name|TURNON
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|fd_motor_on
argument_list|,
name|fd
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* in 1 sec its ok */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fdc_reset
parameter_list|(
name|fdc_p
name|fdc
parameter_list|)
block|{
comment|/* Try a reset, keep motor on */
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
name|fdc
operator|->
name|fdout
operator|&
operator|~
operator|(
name|FDO_FRST
operator||
name|FDO_FDMAEN
operator|)
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[0x%x->FDOUT]"
argument_list|,
name|fdc
operator|->
name|fdout
operator|&
operator|~
operator|(
name|FDO_FRST
operator||
name|FDO_FDMAEN
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* enable FDC, but defer interrupts a moment */
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
name|fdc
operator|->
name|fdout
operator|&
operator|~
name|FDO_FDMAEN
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[0x%x->FDOUT]"
argument_list|,
name|fdc
operator|->
name|fdout
operator|&
operator|~
name|FDO_FDMAEN
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|fdout_wr
argument_list|(
name|fdc
argument_list|,
name|fdc
operator|->
name|fdout
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[0x%x->FDOUT]"
argument_list|,
name|fdc
operator|->
name|fdout
argument_list|)
expr_stmt|;
comment|/* XXX after a reset, silently believe the FDC will accept commands */
operator|(
name|void
operator|)
name|fd_cmd
argument_list|(
name|fdc
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SPECIFY
argument_list|,
name|NE7_SPEC_1
argument_list|(
literal|3
argument_list|,
literal|240
argument_list|)
argument_list|,
name|NE7_SPEC_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_HAS_FIFO
condition|)
operator|(
name|void
operator|)
name|enable_fifo
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * FDC IO functions, take care of the main status register, timeout  * in case the desired status bits are never set.  *  * These PIO loops initially start out with short delays between  * each iteration in the expectation that the required condition  * is usually met quickly, so it can be handled immediately.  After  * about 1 ms, stepping is increased to achieve a better timing  * accuracy in the calls to DELAY().  */
end_comment

begin_function
specifier|static
name|int
name|fd_in
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|int
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|step
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|step
operator|=
literal|1
init|;
operator|(
name|i
operator|=
name|fdsts_rd
argument_list|(
name|fdc
argument_list|)
operator|&
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
operator|)
operator|!=
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
operator|&&
name|j
operator|<
name|FDSTS_TIMEOUT
condition|;
name|j
operator|+=
name|step
control|)
block|{
if|if
condition|(
name|i
operator|==
name|NE7_RQM
condition|)
return|return
operator|(
name|fdc_err
argument_list|(
name|fdc
argument_list|,
literal|"ready for output in input\n"
argument_list|)
operator|)
return|;
if|if
condition|(
name|j
operator|==
literal|1000
condition|)
name|step
operator|=
literal|1000
expr_stmt|;
name|DELAY
argument_list|(
name|step
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>=
name|FDSTS_TIMEOUT
condition|)
return|return
operator|(
name|fdc_err
argument_list|(
name|fdc
argument_list|,
name|bootverbose
condition|?
literal|"input ready timeout\n"
else|:
literal|0
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|FDC_DEBUG
name|i
operator|=
name|fddata_rd
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[FDDATA->0x%x]"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|i
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* !FDC_DEBUG */
name|i
operator|=
name|fddata_rd
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
operator|*
name|ptr
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* FDC_DEBUG */
block|}
end_function

begin_function
specifier|static
name|int
name|out_fdc
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|step
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|step
operator|=
literal|1
init|;
operator|(
name|i
operator|=
name|fdsts_rd
argument_list|(
name|fdc
argument_list|)
operator|&
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
operator|)
operator|!=
name|NE7_RQM
operator|&&
name|j
operator|<
name|FDSTS_TIMEOUT
condition|;
name|j
operator|+=
name|step
control|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
condition|)
return|return
operator|(
name|fdc_err
argument_list|(
name|fdc
argument_list|,
literal|"ready for input in output\n"
argument_list|)
operator|)
return|;
if|if
condition|(
name|j
operator|==
literal|1000
condition|)
name|step
operator|=
literal|1000
expr_stmt|;
name|DELAY
argument_list|(
name|step
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>=
name|FDSTS_TIMEOUT
condition|)
return|return
operator|(
name|fdc_err
argument_list|(
name|fdc
argument_list|,
name|bootverbose
condition|?
literal|"output ready timeout\n"
else|:
literal|0
argument_list|)
operator|)
return|;
comment|/* Send the command and return */
name|fddata_wr
argument_list|(
name|fdc
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[0x%x->FDDATA]"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Block device driver interface functions (interspersed with even more  * auxiliary functions).  */
end_comment

begin_function
specifier|static
name|int
name|fdopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|fd_p
name|fd
decl_stmt|;
name|fdc_p
name|fdc
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|unitattn
decl_stmt|,
name|dflags
decl_stmt|;
name|fd
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|fdc
operator|=
name|fd
operator|->
name|fdc
expr_stmt|;
if|if
condition|(
operator|(
name|fdc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fd
operator|->
name|type
operator|==
name|FDT_NONE
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dflags
operator|=
name|device_get_flags
argument_list|(
name|fd
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * This is a bit bogus.  It's still possible that e. g. a 	 * descriptor gets inherited to a child, but then it's at 	 * least for the same subdevice.  By checking FD_OPEN here, we 	 * can ensure that a device isn't attempted to be opened with 	 * different densities at the same time where the second open 	 * could clobber the settings from the first one. 	 */
if|if
condition|(
name|fd
operator|->
name|flags
operator|&
name|FD_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|FNONBLOCK
condition|)
block|{
comment|/* 		 * Unfortunately, physio(9) discards its ioflag 		 * argument, thus preventing us from seeing the 		 * IO_NDELAY bit.  So we need to keep track 		 * ourselves. 		 */
name|fd
operator|->
name|flags
operator||=
name|FD_NONBLOCK
expr_stmt|;
name|fd
operator|->
name|ft
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Figure out a unit attention condition. 		 * 		 * If UA has been forced, proceed. 		 * 		 * If the drive has no changeline support, 		 * or if the drive parameters have been lost 		 * due to previous non-blocking access, 		 * assume a forced UA condition. 		 * 		 * If motor is off, turn it on for a moment 		 * and select our drive, in order to read the 		 * UA hardware signal. 		 * 		 * If motor is on, and our drive is currently 		 * selected, just read the hardware bit. 		 * 		 * If motor is on, but active for another 		 * drive on that controller, we are lost.  We 		 * cannot risk to deselect the other drive, so 		 * we just assume a forced UA condition to be 		 * on the safe side. 		 */
name|unitattn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|dflags
operator|&
name|FD_NO_CHLINE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_UA
operator|)
operator|!=
literal|0
operator|||
name|fd
operator|->
name|ft
operator|==
literal|0
condition|)
block|{
name|unitattn
operator|=
literal|1
expr_stmt|;
name|fd
operator|->
name|flags
operator|&=
operator|~
name|FD_UA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fdc
operator|->
name|fdout
operator|&
operator|(
name|FDO_MOEN0
operator||
name|FDO_MOEN1
operator||
name|FDO_MOEN2
operator||
name|FDO_MOEN3
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|fdc
operator|->
name|fdout
operator|&
name|FDO_FDSEL
operator|)
operator|==
name|fd
operator|->
name|fdsu
condition|)
name|unitattn
operator|=
name|fdin_rd
argument_list|(
name|fdc
argument_list|)
operator|&
name|FDI_DCHG
expr_stmt|;
else|else
name|unitattn
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|set_motor
argument_list|(
name|fdc
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
name|TURNON
argument_list|)
expr_stmt|;
name|unitattn
operator|=
name|fdin_rd
argument_list|(
name|fdc
argument_list|)
operator|&
name|FDI_DCHG
expr_stmt|;
name|set_motor
argument_list|(
name|fdc
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
name|TURNOFF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unitattn
operator|&&
operator|(
name|rv
operator|=
name|fdautoselect
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|fd
operator|->
name|flags
operator||=
name|FD_OPEN
expr_stmt|;
if|if
condition|(
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fdc
operator|->
name|dmacnt
operator|++
operator|==
literal|0
condition|)
block|{
name|isa_dma_acquire
argument_list|(
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
name|isa_dmainit
argument_list|(
name|fdc
operator|->
name|dmachan
argument_list|,
name|MAX_SEC_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Clearing the DMA overrun counter at open time is a bit messy. 	 * Since we're only managing one counter per controller, opening 	 * the second drive could mess it up.  Anyway, if the DMA overrun 	 * condition is really persistent, it will eventually time out 	 * still.  OTOH, clearing it here will ensure we'll at least start 	 * trying again after a previous (maybe even long ago) failure. 	 * Also, this is merely a stop-gap measure only that should not 	 * happen during normal operation, so we can tolerate it to be a 	 * bit sloppy about this. 	 */
name|fdc
operator|->
name|dma_overruns
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|fdc_p
name|fdc
decl_stmt|;
name|fd
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|fdc
operator|=
name|fd
operator|->
name|fdc
expr_stmt|;
name|fd
operator|->
name|flags
operator|&=
operator|~
operator|(
name|FD_OPEN
operator||
name|FD_NONBLOCK
operator|)
expr_stmt|;
name|fd
operator|->
name|options
operator|&=
operator|~
operator|(
name|FDOPT_NORETRY
operator||
name|FDOPT_NOERRLOG
operator||
name|FDOPT_NOERROR
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|--
name|fdc
operator|->
name|dmacnt
operator|==
literal|0
condition|)
name|isa_dma_release
argument_list|(
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fdstrategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|long
name|blknum
decl_stmt|,
name|nblocks
decl_stmt|;
name|int
name|s
decl_stmt|;
name|fdu_t
name|fdu
decl_stmt|;
name|fdc_p
name|fdc
decl_stmt|;
name|fd_p
name|fd
decl_stmt|;
name|size_t
name|fdblk
decl_stmt|;
name|fd
operator|=
name|bp
operator|->
name|bio_dev
operator|->
name|si_drv1
expr_stmt|;
name|fdu
operator|=
name|fd
operator|->
name|fdu
expr_stmt|;
name|fdc
operator|=
name|fd
operator|->
name|fdc
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
if|if
condition|(
name|fd
operator|->
name|type
operator|==
name|FDT_NONE
operator|||
name|fd
operator|->
name|ft
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fd
operator|->
name|type
operator|!=
name|FDT_NONE
operator|&&
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_NONBLOCK
operator|)
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|EAGAIN
expr_stmt|;
else|else
name|bp
operator|->
name|bio_error
operator|=
name|ENXIO
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|fdblk
operator|=
literal|128
operator|<<
operator|(
name|fd
operator|->
name|ft
operator|->
name|secsize
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|!=
name|FDBIO_FORMAT
operator|&&
name|bp
operator|->
name|bio_cmd
operator|!=
name|FDBIO_RDSECTID
condition|)
block|{
if|if
condition|(
name|fd
operator|->
name|flags
operator|&
name|FD_NONBLOCK
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EAGAIN
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_offset
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"fd%d: fdstrat: bad request offset = %ju, bcount = %ld\n"
argument_list|,
name|fdu
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|bio_offset
argument_list|,
name|bp
operator|->
name|bio_bcount
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|bio_bcount
operator|%
name|fdblk
operator|)
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* 	 * Set up block calculations. 	 */
if|if
condition|(
name|bp
operator|->
name|bio_offset
operator|>=
operator|(
operator|(
name|off_t
operator|)
literal|128
operator|<<
name|fd
operator|->
name|ft
operator|->
name|secsize
operator|)
operator|*
name|fd
operator|->
name|ft
operator|->
name|size
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|blknum
operator|=
name|bp
operator|->
name|bio_offset
operator|/
name|fdblk
expr_stmt|;
name|nblocks
operator|=
name|fd
operator|->
name|ft
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|blknum
operator|+
name|bp
operator|->
name|bio_bcount
operator|/
name|fdblk
operator|>
name|nblocks
condition|)
block|{
if|if
condition|(
name|blknum
operator|>=
name|nblocks
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|!=
name|BIO_READ
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|ENOSPC
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
block|}
goto|goto
name|bad
goto|;
comment|/* not always bad, but EOF */
block|}
name|bp
operator|->
name|bio_bcount
operator|=
operator|(
name|nblocks
operator|-
name|blknum
operator|)
operator|*
name|fdblk
expr_stmt|;
block|}
name|bp
operator|->
name|bio_pblkno
operator|=
name|blknum
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|bioq_disksort
argument_list|(
operator|&
name|fdc
operator|->
name|head
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|fd_turnoff
argument_list|,
name|fd
argument_list|,
name|fd
operator|->
name|toffhandle
argument_list|)
expr_stmt|;
comment|/* a good idea */
name|devstat_start_transaction_bio
argument_list|(
name|fd
operator|->
name|device_stats
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|device_busy
argument_list|(
name|fd
operator|->
name|dev
argument_list|)
expr_stmt|;
name|fdstart
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * fdstart  *  * We have just queued something.  If the controller is not busy  * then simulate the case where it has just finished a command  * So that it (the interrupt routine) looks on the queue for more  * work to do and picks up what we just added.  *  * If the controller is already busy, we need do nothing, as it  * will pick up our work when the present work completes.  */
end_comment

begin_function
specifier|static
name|void
name|fdstart
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|state
operator|==
name|DEVIDLE
condition|)
block|{
name|fdc_intr
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fd_iotimeout
parameter_list|(
name|void
modifier|*
name|xfdc
parameter_list|)
block|{
name|fdc_p
name|fdc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|fdc
operator|=
name|xfdc
expr_stmt|;
name|TRACE1
argument_list|(
literal|"fd%d[fd_iotimeout()]"
argument_list|,
name|fdc
operator|->
name|fdu
argument_list|)
expr_stmt|;
comment|/* 	 * Due to IBM's brain-dead design, the FDC has a faked ready 	 * signal, hardwired to ready == true. Thus, any command 	 * issued if there's no diskette in the drive will _never_ 	 * complete, and must be aborted by resetting the FDC. 	 * Many thanks, Big Blue! 	 * The FDC must not be reset directly, since that would 	 * interfere with the state machine.  Instead, pretend that 	 * the command completed but was invalid.  The state machine 	 * will reset the FDC and retry once. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|fdc
operator|->
name|status
index|[
literal|0
index|]
operator|=
name|NE7_ST0_IC_IV
expr_stmt|;
name|fdc
operator|->
name|flags
operator|&=
operator|~
name|FDC_STAT_VALID
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|IOTIMEDOUT
expr_stmt|;
name|fdc_intr
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just ensure it has the right spl. */
end_comment

begin_function
specifier|static
name|void
name|fd_pseudointr
parameter_list|(
name|void
modifier|*
name|xfdc
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|fdc_intr
argument_list|(
name|xfdc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * fdc_intr  *  * Keep calling the state machine until it returns a 0.  * Always called at splbio.  */
end_comment

begin_function
specifier|static
name|void
name|fdc_intr
parameter_list|(
name|void
modifier|*
name|xfdc
parameter_list|)
block|{
name|fdc_p
name|fdc
init|=
name|xfdc
decl_stmt|;
while|while
condition|(
name|fdstate
argument_list|(
name|fdc
argument_list|)
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Magic pseudo-DMA initialization for YE FDC. Sets count and  * direction.  */
end_comment

begin_define
define|#
directive|define
name|SET_BCDR
parameter_list|(
name|fdc
parameter_list|,
name|wr
parameter_list|,
name|cnt
parameter_list|,
name|port
parameter_list|)
define|\
value|bus_space_write_1(fdc->portt, fdc->porth, fdc->port_off + port,	 \ 	    ((cnt)-1)& 0xff);						 \ 	bus_space_write_1(fdc->portt, fdc->porth, fdc->port_off + port + 1, \ 	    ((wr ? 0x80 : 0) | ((((cnt)-1)>> 8)& 0x7f)));
end_define

begin_comment
comment|/*  * fdcpio(): perform programmed IO read/write for YE PCMCIA floppy.  */
end_comment

begin_function
specifier|static
name|int
name|fdcpio
parameter_list|(
name|fdc_p
name|fdc
parameter_list|,
name|long
name|flags
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|u_char
modifier|*
name|cptr
init|=
operator|(
name|u_char
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|flags
operator|==
name|BIO_READ
condition|)
block|{
if|if
condition|(
name|fdc
operator|->
name|state
operator|!=
name|PIOREAD
condition|)
block|{
name|fdc
operator|->
name|state
operator|=
name|PIOREAD
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SET_BCDR
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_read_multi_1
argument_list|(
name|fdc
operator|->
name|portt
argument_list|,
name|fdc
operator|->
name|porth
argument_list|,
name|fdc
operator|->
name|port_off
operator|+
name|FDC_YE_DATAPORT
argument_list|,
name|cptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_space_write_multi_1
argument_list|(
name|fdc
operator|->
name|portt
argument_list|,
name|fdc
operator|->
name|porth
argument_list|,
name|fdc
operator|->
name|port_off
operator|+
name|FDC_YE_DATAPORT
argument_list|,
name|cptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|SET_BCDR
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try figuring out the density of the media present in our device.  */
end_comment

begin_function
specifier|static
name|int
name|fdautoselect
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|fd_p
name|fd
decl_stmt|;
name|struct
name|fd_type
modifier|*
name|fdtp
decl_stmt|;
name|struct
name|fdc_readid
name|id
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|oopts
decl_stmt|,
name|rv
decl_stmt|;
name|fd
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
switch|switch
condition|(
name|fd
operator|->
name|type
condition|)
block|{
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
case|case
name|FDT_360K
case|:
case|case
name|FDT_720K
case|:
comment|/* no autoselection on those drives */
name|fd
operator|->
name|ft
operator|=
name|fd_native_types
operator|+
name|fd
operator|->
name|type
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FDT_12M
case|:
name|fdtp
operator|=
name|fd_searchlist_12m
expr_stmt|;
name|n
operator|=
sizeof|sizeof
name|fd_searchlist_12m
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|fd_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDT_144M
case|:
name|fdtp
operator|=
name|fd_searchlist_144m
expr_stmt|;
name|n
operator|=
sizeof|sizeof
name|fd_searchlist_144m
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|fd_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDT_288M
case|:
name|fdtp
operator|=
name|fd_searchlist_288m
expr_stmt|;
name|n
operator|=
sizeof|sizeof
name|fd_searchlist_288m
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|fd_type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Try reading sector ID fields, first at cylinder 0, head 0, 	 * then at cylinder 2, head N.  We don't probe cylinder 1, 	 * since for 5.25in DD media in a HD drive, there are no data 	 * to read (2 step pulses per media cylinder required).  For 	 * two-sided media, the second probe always goes to head 1, so 	 * we can tell them apart from single-sided media.  As a 	 * side-effect this means that single-sided media should be 	 * mentioned in the search list after two-sided media of an 	 * otherwise identical density.  Media with a different number 	 * of sectors per track but otherwise identical parameters 	 * cannot be distinguished at all. 	 * 	 * If we successfully read an ID field on both cylinders where 	 * the recorded values match our expectation, we are done. 	 * Otherwise, we try the next density entry from the table. 	 * 	 * Stepping to cylinder 2 has the side-effect of clearing the 	 * unit attention bit. 	 */
name|oopts
operator|=
name|fd
operator|->
name|options
expr_stmt|;
name|fd
operator|->
name|options
operator||=
name|FDOPT_NOERRLOG
operator||
name|FDOPT_NORETRY
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|fdtp
operator|++
control|)
block|{
name|fd
operator|->
name|ft
operator|=
name|fdtp
expr_stmt|;
name|id
operator|.
name|cyl
operator|=
name|id
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|fdmisccmd
argument_list|(
name|dev
argument_list|,
name|FDBIO_RDSECTID
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|id
operator|.
name|cyl
operator|!=
literal|0
operator|||
name|id
operator|.
name|head
operator|!=
literal|0
operator|||
name|id
operator|.
name|secshift
operator|!=
name|fdtp
operator|->
name|secsize
condition|)
continue|continue;
name|id
operator|.
name|cyl
operator|=
literal|2
expr_stmt|;
name|id
operator|.
name|head
operator|=
name|fd
operator|->
name|ft
operator|->
name|heads
operator|-
literal|1
expr_stmt|;
name|rv
operator|=
name|fdmisccmd
argument_list|(
name|dev
argument_list|,
name|FDBIO_RDSECTID
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|.
name|cyl
operator|!=
literal|2
operator|||
name|id
operator|.
name|head
operator|!=
name|fdtp
operator|->
name|heads
operator|-
literal|1
operator|||
name|id
operator|.
name|secshift
operator|!=
name|fdtp
operator|->
name|secsize
condition|)
continue|continue;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
break|break;
block|}
name|fd
operator|->
name|options
operator|=
name|oopts
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|n
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|fd
operator|->
name|dev
argument_list|,
literal|"autoselection failed\n"
argument_list|)
expr_stmt|;
name|fd
operator|->
name|ft
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|fd
operator|->
name|dev
argument_list|,
literal|"autoselected %d KB medium\n"
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|size
operator|/
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * The controller state machine.  *  * If it returns a non zero value, it should be called again immediately.  */
end_comment

begin_function
specifier|static
name|int
name|fdstate
parameter_list|(
name|fdc_p
name|fdc
parameter_list|)
block|{
name|struct
name|fdc_readid
modifier|*
name|idp
decl_stmt|;
name|int
name|read
decl_stmt|,
name|format
decl_stmt|,
name|rdsectid
decl_stmt|,
name|cylinder
decl_stmt|,
name|head
decl_stmt|,
name|i
decl_stmt|,
name|sec
init|=
literal|0
decl_stmt|,
name|sectrac
decl_stmt|;
name|int
name|st0
decl_stmt|,
name|cyl
decl_stmt|,
name|st3
decl_stmt|,
name|idf
decl_stmt|,
name|ne7cmd
decl_stmt|,
name|mfm
decl_stmt|,
name|steptrac
decl_stmt|;
name|unsigned
name|long
name|blknum
decl_stmt|;
name|fdu_t
name|fdu
init|=
name|fdc
operator|->
name|fdu
decl_stmt|;
name|fd_p
name|fd
decl_stmt|;
specifier|register
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|fd_formb
modifier|*
name|finfo
init|=
name|NULL
decl_stmt|;
name|size_t
name|fdblk
decl_stmt|;
name|bp
operator|=
name|fdc
operator|->
name|bp
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|fdc
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bioq_remove
argument_list|(
operator|&
name|fdc
operator|->
name|head
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Nothing left for this controller to do, 		 * force into the IDLE state. 		 */
name|fdc
operator|->
name|state
operator|=
name|DEVIDLE
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|fd
condition|)
block|{
name|device_printf
argument_list|(
name|fdc
operator|->
name|fdc_dev
argument_list|,
literal|"unexpected valid fd pointer\n"
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fd
operator|=
operator|(
name|fd_p
operator|)
literal|0
expr_stmt|;
name|fdc
operator|->
name|fdu
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|TRACE1
argument_list|(
literal|"[fdc%d IDLE]"
argument_list|,
name|fdc
operator|->
name|fdcu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fd
operator|=
name|bp
operator|->
name|bio_dev
operator|->
name|si_drv1
expr_stmt|;
name|fdu
operator|=
name|fd
operator|->
name|fdu
expr_stmt|;
name|fdblk
operator|=
literal|128
operator|<<
name|fd
operator|->
name|ft
operator|->
name|secsize
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|fd
operator|&&
operator|(
name|fd
operator|!=
name|fdc
operator|->
name|fd
operator|)
condition|)
name|device_printf
argument_list|(
name|fd
operator|->
name|dev
argument_list|,
literal|"confused fd pointers\n"
argument_list|)
expr_stmt|;
name|read
operator|=
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
expr_stmt|;
name|mfm
operator|=
operator|(
name|fd
operator|->
name|ft
operator|->
name|flags
operator|&
name|FL_MFM
operator|)
condition|?
name|NE7CMD_MFM
else|:
literal|0
expr_stmt|;
name|steptrac
operator|=
operator|(
name|fd
operator|->
name|ft
operator|->
name|flags
operator|&
name|FL_2STEP
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|read
condition|)
name|idf
operator|=
name|ISADMA_READ
expr_stmt|;
else|else
name|idf
operator|=
name|ISADMA_WRITE
expr_stmt|;
name|format
operator|=
name|bp
operator|->
name|bio_cmd
operator|==
name|FDBIO_FORMAT
expr_stmt|;
name|rdsectid
operator|=
name|bp
operator|->
name|bio_cmd
operator|==
name|FDBIO_RDSECTID
expr_stmt|;
if|if
condition|(
name|format
condition|)
name|finfo
operator|=
operator|(
expr|struct
name|fd_formb
operator|*
operator|)
name|bp
operator|->
name|bio_data
expr_stmt|;
name|TRACE1
argument_list|(
literal|"fd%d"
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[%s]"
argument_list|,
name|fdstates
index|[
name|fdc
operator|->
name|state
index|]
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"(0x%x)"
argument_list|,
name|fd
operator|->
name|flags
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|fd_turnoff
argument_list|,
name|fd
argument_list|,
name|fd
operator|->
name|toffhandle
argument_list|)
expr_stmt|;
name|fd
operator|->
name|toffhandle
operator|=
name|timeout
argument_list|(
name|fd_turnoff
argument_list|,
name|fd
argument_list|,
literal|4
operator|*
name|hz
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fdc
operator|->
name|state
condition|)
block|{
case|case
name|DEVIDLE
case|:
case|case
name|FINDWORK
case|:
comment|/* we have found new work */
name|fdc
operator|->
name|retry
operator|=
literal|0
expr_stmt|;
name|fd
operator|->
name|skip
operator|=
literal|0
expr_stmt|;
name|fdc
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|fdc
operator|->
name|fdu
operator|=
name|fdu
expr_stmt|;
name|fdc
operator|->
name|fdctl_wr
argument_list|(
name|fdc
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|trans
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[0x%x->FDCTL]"
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|trans
argument_list|)
expr_stmt|;
comment|/* 		 * If the next drive has a motor startup pending, then 		 * it will start up in its own good time. 		 */
if|if
condition|(
name|fd
operator|->
name|flags
operator|&
name|FD_MOTOR_WAIT
condition|)
block|{
name|fdc
operator|->
name|state
operator|=
name|MOTORWAIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
block|}
comment|/* 		 * Maybe if it's not starting, it SHOULD be starting. 		 */
if|if
condition|(
operator|!
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_MOTOR
operator|)
condition|)
block|{
name|fdc
operator|->
name|state
operator|=
name|MOTORWAIT
expr_stmt|;
name|fd_turnon
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
block|}
else|else
comment|/* at least make sure we are selected */
block|{
name|set_motor
argument_list|(
name|fdc
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
name|TURNON
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NEEDS_RESET
condition|)
block|{
name|fdc
operator|->
name|state
operator|=
name|RESETCTLR
expr_stmt|;
name|fdc
operator|->
name|flags
operator|&=
operator|~
name|FDC_NEEDS_RESET
expr_stmt|;
block|}
else|else
name|fdc
operator|->
name|state
operator|=
name|DOSEEK
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* will return immediately */
case|case
name|DOSEEK
case|:
name|blknum
operator|=
name|bp
operator|->
name|bio_pblkno
operator|+
name|fd
operator|->
name|skip
operator|/
name|fdblk
expr_stmt|;
name|cylinder
operator|=
name|blknum
operator|/
operator|(
name|fd
operator|->
name|ft
operator|->
name|sectrac
operator|*
name|fd
operator|->
name|ft
operator|->
name|heads
operator|)
expr_stmt|;
if|if
condition|(
name|cylinder
operator|==
name|fd
operator|->
name|track
condition|)
block|{
name|fdc
operator|->
name|state
operator|=
name|SEEKCOMPLETE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* will return immediately */
block|}
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdc
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SEEK
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
name|cylinder
operator|*
name|steptrac
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* 			 * Seek command not accepted, looks like 			 * the FDC went off to the Saints... 			 */
name|fdc
operator|->
name|retry
operator|=
literal|6
expr_stmt|;
comment|/* try a reset */
return|return
operator|(
name|retrier
argument_list|(
name|fdc
argument_list|)
operator|)
return|;
block|}
name|fd
operator|->
name|track
operator|=
name|FD_NO_TRACK
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|SEEKWAIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
case|case
name|SEEKWAIT
case|:
comment|/* allow heads to settle */
name|timeout
argument_list|(
name|fd_pseudointr
argument_list|,
name|fdc
argument_list|,
name|hz
operator|/
literal|16
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|SEEKCOMPLETE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
case|case
name|SEEKCOMPLETE
case|:
comment|/* seek done, start DMA */
name|blknum
operator|=
name|bp
operator|->
name|bio_pblkno
operator|+
name|fd
operator|->
name|skip
operator|/
name|fdblk
expr_stmt|;
name|cylinder
operator|=
name|blknum
operator|/
operator|(
name|fd
operator|->
name|ft
operator|->
name|sectrac
operator|*
name|fd
operator|->
name|ft
operator|->
name|heads
operator|)
expr_stmt|;
comment|/* Make sure seek really happened. */
if|if
condition|(
name|fd
operator|->
name|track
operator|==
name|FD_NO_TRACK
condition|)
block|{
name|int
name|descyl
init|=
name|cylinder
operator|*
name|steptrac
decl_stmt|;
do|do
block|{
comment|/* 				 * This might be a "ready changed" interrupt, 				 * which cannot really happen since the 				 * RDY pin is hardwired to + 5 volts.  This 				 * generally indicates a "bouncing" intr 				 * line, so do one of the following: 				 * 				 * When running on an enhanced FDC that is 				 * known to not go stuck after responding 				 * with INVALID, fetch all interrupt states 				 * until seeing either an INVALID or a 				 * real interrupt condition. 				 * 				 * When running on a dumb old NE765, give 				 * up immediately.  The controller will 				 * provide up to four dummy RC interrupt 				 * conditions right after reset (for the 				 * corresponding four drives), so this is 				 * our only chance to get notice that it 				 * was not the FDC that caused the interrupt. 				 */
if|if
condition|(
name|fd_sense_int
argument_list|(
name|fdc
argument_list|,
operator|&
name|st0
argument_list|,
operator|&
name|cyl
argument_list|)
operator|==
name|FD_NOT_VALID
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
if|if
condition|(
name|fdc
operator|->
name|fdct
operator|==
name|FDC_NE765
operator|&&
operator|(
name|st0
operator|&
name|NE7_ST0_IC
operator|)
operator|==
name|NE7_ST0_IC_RC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hope for a real intr */
block|}
do|while
condition|(
operator|(
name|st0
operator|&
name|NE7_ST0_IC
operator|)
operator|==
name|NE7_ST0_IC_RC
condition|)
do|;
if|if
condition|(
literal|0
operator|==
name|descyl
condition|)
block|{
name|int
name|failed
init|=
literal|0
decl_stmt|;
comment|/* 				 * seek to cyl 0 requested; make sure we are 				 * really there 				 */
if|if
condition|(
name|fd_sense_drive_status
argument_list|(
name|fdc
argument_list|,
operator|&
name|st3
argument_list|)
condition|)
name|failed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|st3
operator|&
name|NE7_ST3_T0
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"fd%d: Seek to cyl 0, but not really there (ST3 = %b)\n"
argument_list|,
name|fdu
argument_list|,
name|st3
argument_list|,
name|NE7_ST3BITS
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|failed
condition|)
block|{
if|if
condition|(
name|fdc
operator|->
name|retry
operator|<
literal|3
condition|)
name|fdc
operator|->
name|retry
operator|=
literal|3
expr_stmt|;
return|return
operator|(
name|retrier
argument_list|(
name|fdc
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|cyl
operator|!=
name|descyl
condition|)
block|{
name|printf
argument_list|(
literal|"fd%d: Seek to cyl %d failed; am at cyl %d (ST0 = 0x%x)\n"
argument_list|,
name|fdu
argument_list|,
name|descyl
argument_list|,
name|cyl
argument_list|,
name|st0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|retry
operator|<
literal|3
condition|)
name|fdc
operator|->
name|retry
operator|=
literal|3
expr_stmt|;
return|return
operator|(
name|retrier
argument_list|(
name|fdc
argument_list|)
operator|)
return|;
block|}
block|}
name|fd
operator|->
name|track
operator|=
name|cylinder
expr_stmt|;
if|if
condition|(
name|format
condition|)
name|fd
operator|->
name|skip
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|finfo
operator|->
name|fd_formb_cylno
argument_list|(
literal|0
argument_list|)
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
name|finfo
expr_stmt|;
if|if
condition|(
operator|!
name|rdsectid
operator|&&
operator|!
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
operator|)
condition|)
name|isa_dmastart
argument_list|(
name|idf
argument_list|,
name|bp
operator|->
name|bio_data
operator|+
name|fd
operator|->
name|skip
argument_list|,
name|format
condition|?
name|bp
operator|->
name|bio_bcount
else|:
name|fdblk
argument_list|,
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
name|blknum
operator|=
name|bp
operator|->
name|bio_pblkno
operator|+
name|fd
operator|->
name|skip
operator|/
name|fdblk
expr_stmt|;
name|sectrac
operator|=
name|fd
operator|->
name|ft
operator|->
name|sectrac
expr_stmt|;
name|sec
operator|=
name|blknum
operator|%
operator|(
name|sectrac
operator|*
name|fd
operator|->
name|ft
operator|->
name|heads
operator|)
expr_stmt|;
name|head
operator|=
name|sec
operator|/
name|sectrac
expr_stmt|;
name|sec
operator|=
name|sec
operator|%
name|sectrac
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|head
operator|!=
literal|0
operator|&&
name|fd
operator|->
name|ft
operator|->
name|offset_side2
operator|!=
literal|0
condition|)
name|sec
operator|+=
name|fd
operator|->
name|ft
operator|->
name|offset_side2
expr_stmt|;
name|fd
operator|->
name|hddrv
operator|=
operator|(
operator|(
name|head
operator|&
literal|1
operator|)
operator|<<
literal|2
operator|)
operator|+
name|fdu
expr_stmt|;
if|if
condition|(
name|format
operator|||
operator|!
operator|(
name|read
operator|||
name|rdsectid
operator|)
condition|)
block|{
comment|/* make sure the drive is writable */
if|if
condition|(
name|fd_sense_drive_status
argument_list|(
name|fdc
argument_list|,
operator|&
name|st3
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* stuck controller? */
if|if
condition|(
operator|!
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
operator|)
condition|)
name|isa_dmadone
argument_list|(
name|idf
argument_list|,
name|bp
operator|->
name|bio_data
operator|+
name|fd
operator|->
name|skip
argument_list|,
name|format
condition|?
name|bp
operator|->
name|bio_bcount
else|:
name|fdblk
argument_list|,
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|retry
operator|=
literal|6
expr_stmt|;
comment|/* reset the beast */
return|return
operator|(
name|retrier
argument_list|(
name|fdc
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|st3
operator|&
name|NE7_ST3_WP
condition|)
block|{
comment|/* 				 * XXX YES! this is ugly. 				 * in order to force the current operation 				 * to fail, we will have to fake an FDC 				 * error - all error handling is done 				 * by the retrier() 				 */
name|fdc
operator|->
name|status
index|[
literal|0
index|]
operator|=
name|NE7_ST0_IC_AT
expr_stmt|;
name|fdc
operator|->
name|status
index|[
literal|1
index|]
operator|=
name|NE7_ST1_NW
expr_stmt|;
name|fdc
operator|->
name|status
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|fdc
operator|->
name|status
index|[
literal|3
index|]
operator|=
name|fd
operator|->
name|track
expr_stmt|;
name|fdc
operator|->
name|status
index|[
literal|4
index|]
operator|=
name|head
expr_stmt|;
name|fdc
operator|->
name|status
index|[
literal|5
index|]
operator|=
name|sec
expr_stmt|;
name|fdc
operator|->
name|retry
operator|=
literal|8
expr_stmt|;
comment|/* break out immediately */
name|fdc
operator|->
name|state
operator|=
name|IOTIMEDOUT
expr_stmt|;
comment|/* not really... */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* will return immediately */
block|}
block|}
if|if
condition|(
name|format
condition|)
block|{
name|ne7cmd
operator|=
name|NE7CMD_FORMAT
operator||
name|mfm
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
condition|)
block|{
comment|/* 				 * This seems to be necessary for 				 * whatever obscure reason; if we omit 				 * it, we end up filling the sector ID 				 * fields of the newly formatted track 				 * entirely with garbage, causing 				 * `wrong cylinder' errors all over 				 * the place when trying to read them 				 * back. 				 * 				 * Umpf. 				 */
name|SET_BCDR
argument_list|(
name|fdc
argument_list|,
literal|1
argument_list|,
name|bp
operator|->
name|bio_bcount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fdcpio
argument_list|(
name|fdc
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|,
name|bp
operator|->
name|bio_data
operator|+
name|fd
operator|->
name|skip
argument_list|,
name|bp
operator|->
name|bio_bcount
argument_list|)
expr_stmt|;
block|}
comment|/* formatting */
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdc
argument_list|,
literal|6
argument_list|,
name|ne7cmd
argument_list|,
name|head
operator|<<
literal|2
operator||
name|fdu
argument_list|,
name|finfo
operator|->
name|fd_formb_secshift
argument_list|,
name|finfo
operator|->
name|fd_formb_nsecs
argument_list|,
name|finfo
operator|->
name|fd_formb_gaplen
argument_list|,
name|finfo
operator|->
name|fd_formb_fillbyte
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* controller fell over */
if|if
condition|(
operator|!
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
operator|)
condition|)
name|isa_dmadone
argument_list|(
name|idf
argument_list|,
name|bp
operator|->
name|bio_data
operator|+
name|fd
operator|->
name|skip
argument_list|,
name|format
condition|?
name|bp
operator|->
name|bio_bcount
else|:
name|fdblk
argument_list|,
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|retry
operator|=
literal|6
expr_stmt|;
return|return
operator|(
name|retrier
argument_list|(
name|fdc
argument_list|)
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|rdsectid
condition|)
block|{
name|ne7cmd
operator|=
name|NE7CMD_READID
operator||
name|mfm
expr_stmt|;
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdc
argument_list|,
literal|2
argument_list|,
name|ne7cmd
argument_list|,
name|head
operator|<<
literal|2
operator||
name|fdu
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* controller jamming */
name|fdc
operator|->
name|retry
operator|=
literal|6
expr_stmt|;
return|return
operator|(
name|retrier
argument_list|(
name|fdc
argument_list|)
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* read or write operation */
name|ne7cmd
operator|=
operator|(
name|read
condition|?
name|NE7CMD_READ
operator||
name|NE7CMD_SK
else|:
name|NE7CMD_WRITE
operator|)
operator||
name|mfm
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
condition|)
block|{
comment|/* 				 * This seems to be necessary even when 				 * reading data. 				 */
name|SET_BCDR
argument_list|(
name|fdc
argument_list|,
literal|1
argument_list|,
name|fdblk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * Perform the write pseudo-DMA before 				 * the WRITE command is sent. 				 */
if|if
condition|(
operator|!
name|read
condition|)
operator|(
name|void
operator|)
name|fdcpio
argument_list|(
name|fdc
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|,
name|bp
operator|->
name|bio_data
operator|+
name|fd
operator|->
name|skip
argument_list|,
name|fdblk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdc
argument_list|,
literal|9
argument_list|,
name|ne7cmd
argument_list|,
name|head
operator|<<
literal|2
operator||
name|fdu
argument_list|,
comment|/* head& unit */
name|fd
operator|->
name|track
argument_list|,
comment|/* track */
name|head
argument_list|,
name|sec
argument_list|,
comment|/* sector + 1 */
name|fd
operator|->
name|ft
operator|->
name|secsize
argument_list|,
comment|/* sector size */
name|sectrac
argument_list|,
comment|/* sectors/track */
name|fd
operator|->
name|ft
operator|->
name|gap
argument_list|,
comment|/* gap size */
name|fd
operator|->
name|ft
operator|->
name|datalen
argument_list|,
comment|/* data length */
literal|0
argument_list|)
condition|)
block|{
comment|/* the beast is sleeping again */
if|if
condition|(
operator|!
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
operator|)
condition|)
name|isa_dmadone
argument_list|(
name|idf
argument_list|,
name|bp
operator|->
name|bio_data
operator|+
name|fd
operator|->
name|skip
argument_list|,
name|format
condition|?
name|bp
operator|->
name|bio_bcount
else|:
name|fdblk
argument_list|,
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|retry
operator|=
literal|6
expr_stmt|;
return|return
operator|(
name|retrier
argument_list|(
name|fdc
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|rdsectid
operator|&&
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
operator|)
condition|)
comment|/* 			 * If this is a read, then simply await interrupt 			 * before performing PIO. 			 */
if|if
condition|(
name|read
operator|&&
operator|!
name|fdcpio
argument_list|(
name|fdc
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|,
name|bp
operator|->
name|bio_data
operator|+
name|fd
operator|->
name|skip
argument_list|,
name|fdblk
argument_list|)
condition|)
block|{
name|fd
operator|->
name|tohandle
operator|=
name|timeout
argument_list|(
name|fd_iotimeout
argument_list|,
name|fdc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
block|}
comment|/* 		 * Write (or format) operation will fall through and 		 * await completion interrupt. 		 */
name|fdc
operator|->
name|state
operator|=
name|IOCOMPLETE
expr_stmt|;
name|fd
operator|->
name|tohandle
operator|=
name|timeout
argument_list|(
name|fd_iotimeout
argument_list|,
name|fdc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
case|case
name|PIOREAD
case|:
comment|/*  		 * Actually perform the PIO read.  The IOCOMPLETE case 		 * removes the timeout for us. 		 */
operator|(
name|void
operator|)
name|fdcpio
argument_list|(
name|fdc
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|,
name|bp
operator|->
name|bio_data
operator|+
name|fd
operator|->
name|skip
argument_list|,
name|fdblk
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|IOCOMPLETE
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|IOCOMPLETE
case|:
comment|/* IO done, post-analyze */
name|untimeout
argument_list|(
name|fd_iotimeout
argument_list|,
name|fdc
argument_list|,
name|fd
operator|->
name|tohandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd_read_status
argument_list|(
name|fdc
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rdsectid
operator|&&
operator|!
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
operator|)
condition|)
name|isa_dmadone
argument_list|(
name|idf
argument_list|,
name|bp
operator|->
name|bio_data
operator|+
name|fd
operator|->
name|skip
argument_list|,
name|format
condition|?
name|bp
operator|->
name|bio_bcount
else|:
name|fdblk
argument_list|,
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|retry
operator|<
literal|6
condition|)
name|fdc
operator|->
name|retry
operator|=
literal|6
expr_stmt|;
comment|/* force a reset */
return|return
operator|(
name|retrier
argument_list|(
name|fdc
argument_list|)
operator|)
return|;
block|}
name|fdc
operator|->
name|state
operator|=
name|IOTIMEDOUT
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|IOTIMEDOUT
case|:
if|if
condition|(
operator|!
name|rdsectid
operator|&&
operator|!
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NODMA
operator|)
condition|)
name|isa_dmadone
argument_list|(
name|idf
argument_list|,
name|bp
operator|->
name|bio_data
operator|+
name|fd
operator|->
name|skip
argument_list|,
name|format
condition|?
name|bp
operator|->
name|bio_bcount
else|:
name|fdblk
argument_list|,
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|status
index|[
literal|0
index|]
operator|&
name|NE7_ST0_IC
condition|)
block|{
if|if
condition|(
operator|(
name|fdc
operator|->
name|status
index|[
literal|0
index|]
operator|&
name|NE7_ST0_IC
operator|)
operator|==
name|NE7_ST0_IC_AT
operator|&&
name|fdc
operator|->
name|status
index|[
literal|1
index|]
operator|&
name|NE7_ST1_OR
condition|)
block|{
comment|/* 				 * DMA overrun. Someone hogged the bus and 				 * didn't release it in time for the next 				 * FDC transfer. 				 * 				 * We normally restart this without bumping 				 * the retry counter.  However, in case 				 * something is seriously messed up (like 				 * broken hardware), we rather limit the 				 * number of retries so the IO operation 				 * doesn't block indefinately. 				 */
if|if
condition|(
name|fdc
operator|->
name|dma_overruns
operator|++
operator|<
name|FDC_DMAOV_MAX
condition|)
block|{
name|fdc
operator|->
name|state
operator|=
name|SEEKCOMPLETE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* will return immediately */
block|}
comment|/* else fall through */
block|}
if|if
condition|(
operator|(
name|fdc
operator|->
name|status
index|[
literal|0
index|]
operator|&
name|NE7_ST0_IC
operator|)
operator|==
name|NE7_ST0_IC_IV
operator|&&
name|fdc
operator|->
name|retry
operator|<
literal|6
condition|)
name|fdc
operator|->
name|retry
operator|=
literal|6
expr_stmt|;
comment|/* force a reset */
elseif|else
if|if
condition|(
operator|(
name|fdc
operator|->
name|status
index|[
literal|0
index|]
operator|&
name|NE7_ST0_IC
operator|)
operator|==
name|NE7_ST0_IC_AT
operator|&&
name|fdc
operator|->
name|status
index|[
literal|2
index|]
operator|&
name|NE7_ST2_WC
operator|&&
name|fdc
operator|->
name|retry
operator|<
literal|3
condition|)
name|fdc
operator|->
name|retry
operator|=
literal|3
expr_stmt|;
comment|/* force recalibrate */
return|return
operator|(
name|retrier
argument_list|(
name|fdc
argument_list|)
operator|)
return|;
block|}
comment|/* All OK */
if|if
condition|(
name|rdsectid
condition|)
block|{
comment|/* copy out ID field contents */
name|idp
operator|=
operator|(
expr|struct
name|fdc_readid
operator|*
operator|)
name|bp
operator|->
name|bio_data
expr_stmt|;
name|idp
operator|->
name|cyl
operator|=
name|fdc
operator|->
name|status
index|[
literal|3
index|]
expr_stmt|;
name|idp
operator|->
name|head
operator|=
name|fdc
operator|->
name|status
index|[
literal|4
index|]
expr_stmt|;
name|idp
operator|->
name|sec
operator|=
name|fdc
operator|->
name|status
index|[
literal|5
index|]
expr_stmt|;
name|idp
operator|->
name|secshift
operator|=
name|fdc
operator|->
name|status
index|[
literal|6
index|]
expr_stmt|;
block|}
comment|/* Operation successful, retry DMA overruns again next time. */
name|fdc
operator|->
name|dma_overruns
operator|=
literal|0
expr_stmt|;
name|fd
operator|->
name|skip
operator|+=
name|fdblk
expr_stmt|;
if|if
condition|(
operator|!
name|rdsectid
operator|&&
operator|!
name|format
operator|&&
name|fd
operator|->
name|skip
operator|<
name|bp
operator|->
name|bio_bcount
condition|)
block|{
comment|/* set up next transfer */
name|fdc
operator|->
name|state
operator|=
name|DOSEEK
expr_stmt|;
block|}
else|else
block|{
comment|/* ALL DONE */
name|fd
operator|->
name|skip
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
literal|0
expr_stmt|;
name|fdc
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
name|device_unbusy
argument_list|(
name|fd
operator|->
name|dev
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|fd
operator|->
name|device_stats
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fd
operator|=
operator|(
name|fd_p
operator|)
literal|0
expr_stmt|;
name|fdc
operator|->
name|fdu
operator|=
operator|-
literal|1
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|FINDWORK
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* will return immediately */
case|case
name|RESETCTLR
case|:
name|fdc_reset
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|retry
operator|++
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|RESETCOMPLETE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
case|case
name|RESETCOMPLETE
case|:
comment|/* 		 * Discard all the results from the reset so that they 		 * can't cause an unexpected interrupt later. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fd_sense_int
argument_list|(
name|fdc
argument_list|,
operator|&
name|st0
argument_list|,
operator|&
name|cyl
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|STARTRECAL
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|STARTRECAL
case|:
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdc
argument_list|,
literal|2
argument_list|,
name|NE7CMD_RECAL
argument_list|,
name|fdu
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* arrgl */
name|fdc
operator|->
name|retry
operator|=
literal|6
expr_stmt|;
return|return
operator|(
name|retrier
argument_list|(
name|fdc
argument_list|)
operator|)
return|;
block|}
name|fdc
operator|->
name|state
operator|=
name|RECALWAIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
case|case
name|RECALWAIT
case|:
comment|/* allow heads to settle */
name|timeout
argument_list|(
name|fd_pseudointr
argument_list|,
name|fdc
argument_list|,
name|hz
operator|/
literal|8
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|RECALCOMPLETE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
case|case
name|RECALCOMPLETE
case|:
do|do
block|{
comment|/* 			 * See SEEKCOMPLETE for a comment on this: 			 */
if|if
condition|(
name|fd_sense_int
argument_list|(
name|fdc
argument_list|,
operator|&
name|st0
argument_list|,
operator|&
name|cyl
argument_list|)
operator|==
name|FD_NOT_VALID
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
if|if
condition|(
name|fdc
operator|->
name|fdct
operator|==
name|FDC_NE765
operator|&&
operator|(
name|st0
operator|&
name|NE7_ST0_IC
operator|)
operator|==
name|NE7_ST0_IC_RC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hope for a real intr */
block|}
do|while
condition|(
operator|(
name|st0
operator|&
name|NE7_ST0_IC
operator|)
operator|==
name|NE7_ST0_IC_RC
condition|)
do|;
if|if
condition|(
operator|(
name|st0
operator|&
name|NE7_ST0_IC
operator|)
operator|!=
name|NE7_ST0_IC_NT
operator|||
name|cyl
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fdc
operator|->
name|retry
operator|>
literal|3
condition|)
comment|/* 				 * A recalibrate from beyond cylinder 77 				 * will "fail" due to the FDC limitations; 				 * since people used to complain much about 				 * the failure message, try not logging 				 * this one if it seems to be the first 				 * time in a line. 				 */
name|printf
argument_list|(
literal|"fd%d: recal failed ST0 %b cyl %d\n"
argument_list|,
name|fdu
argument_list|,
name|st0
argument_list|,
name|NE7_ST0BITS
argument_list|,
name|cyl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|retry
operator|<
literal|3
condition|)
name|fdc
operator|->
name|retry
operator|=
literal|3
expr_stmt|;
return|return
operator|(
name|retrier
argument_list|(
name|fdc
argument_list|)
operator|)
return|;
block|}
name|fd
operator|->
name|track
operator|=
literal|0
expr_stmt|;
comment|/* Seek (probably) necessary */
name|fdc
operator|->
name|state
operator|=
name|DOSEEK
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* will return immediately */
case|case
name|MOTORWAIT
case|:
if|if
condition|(
name|fd
operator|->
name|flags
operator|&
name|FD_MOTOR_WAIT
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* time's not up yet */
block|}
if|if
condition|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_NEEDS_RESET
condition|)
block|{
name|fdc
operator|->
name|state
operator|=
name|RESETCTLR
expr_stmt|;
name|fdc
operator|->
name|flags
operator|&=
operator|~
name|FDC_NEEDS_RESET
expr_stmt|;
block|}
else|else
name|fdc
operator|->
name|state
operator|=
name|DOSEEK
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* will return immediately */
default|default:
name|device_printf
argument_list|(
name|fdc
operator|->
name|fdc_dev
argument_list|,
literal|"unexpected FD int->"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd_read_status
argument_list|(
name|fdc
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"FDC status :%x %x %x %x %x %x %x   "
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|0
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|1
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|2
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|3
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|4
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|5
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"No status available   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd_sense_int
argument_list|(
name|fdc
argument_list|,
operator|&
name|st0
argument_list|,
operator|&
name|cyl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"[controller is dead now]\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
block|}
name|printf
argument_list|(
literal|"ST0 = %x, PCN = %x\n"
argument_list|,
name|st0
argument_list|,
name|cyl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
block|}
comment|/* noone should ever get here */
block|}
end_function

begin_function
specifier|static
name|int
name|retrier
parameter_list|(
name|struct
name|fdc_data
modifier|*
name|fdc
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|fd_data
modifier|*
name|fd
decl_stmt|;
name|int
name|fdu
decl_stmt|;
name|bp
operator|=
name|fdc
operator|->
name|bp
expr_stmt|;
comment|/* XXX shouldn't this be cached somewhere?  */
name|fd
operator|=
name|bp
operator|->
name|bio_dev
operator|->
name|si_drv1
expr_stmt|;
name|fdu
operator|=
name|fd
operator|->
name|fdu
expr_stmt|;
if|if
condition|(
name|fd
operator|->
name|options
operator|&
name|FDOPT_NORETRY
condition|)
goto|goto
name|fail
goto|;
switch|switch
condition|(
name|fdc
operator|->
name|retry
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
name|fdc
operator|->
name|state
operator|=
name|SEEKCOMPLETE
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
name|fdc
operator|->
name|state
operator|=
name|STARTRECAL
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|fdc
operator|->
name|state
operator|=
name|RESETCTLR
expr_stmt|;
break|break;
case|case
literal|7
case|:
break|break;
default|default:
name|fail
label|:
if|if
condition|(
operator|(
name|fd
operator|->
name|options
operator|&
name|FDOPT_NOERRLOG
operator|)
operator|==
literal|0
condition|)
block|{
name|disk_err
argument_list|(
name|bp
argument_list|,
literal|"hard error"
argument_list|,
name|fdc
operator|->
name|fd
operator|->
name|skip
operator|/
name|DEV_BSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_STAT_VALID
condition|)
block|{
name|printf
argument_list|(
literal|" (ST0 %b ST1 %b ST2 %b cyl %u hd %u sec %u)\n"
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|0
index|]
argument_list|,
name|NE7_ST0BITS
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|1
index|]
argument_list|,
name|NE7_ST1BITS
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|2
index|]
argument_list|,
name|NE7_ST2BITS
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|3
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|4
index|]
argument_list|,
name|fdc
operator|->
name|status
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|" (No status)\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fd
operator|->
name|options
operator|&
name|FDOPT_NOERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
operator|-
name|fdc
operator|->
name|fd
operator|->
name|skip
expr_stmt|;
block|}
else|else
name|bp
operator|->
name|bio_resid
operator|=
literal|0
expr_stmt|;
name|fdc
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
name|fdc
operator|->
name|fd
operator|->
name|skip
operator|=
literal|0
expr_stmt|;
name|device_unbusy
argument_list|(
name|fd
operator|->
name|dev
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|fdc
operator|->
name|fd
operator|->
name|device_stats
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|FINDWORK
expr_stmt|;
name|fdc
operator|->
name|flags
operator||=
name|FDC_NEEDS_RESET
expr_stmt|;
name|fdc
operator|->
name|fd
operator|=
operator|(
name|fd_p
operator|)
literal|0
expr_stmt|;
name|fdc
operator|->
name|fdu
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fdc
operator|->
name|retry
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fdbiodone
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|wakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdmisccmd
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|fdu_t
name|fdu
decl_stmt|;
name|fd_p
name|fd
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|fd_formb
modifier|*
name|finfo
decl_stmt|;
name|struct
name|fdc_readid
modifier|*
name|idfield
decl_stmt|;
name|size_t
name|fdblk
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fd
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|fdu
operator|=
name|fd
operator|->
name|fdu
expr_stmt|;
name|fdblk
operator|=
literal|128
operator|<<
name|fd
operator|->
name|ft
operator|->
name|secsize
expr_stmt|;
name|finfo
operator|=
operator|(
expr|struct
name|fd_formb
operator|*
operator|)
name|data
expr_stmt|;
name|idfield
operator|=
operator|(
expr|struct
name|fdc_readid
operator|*
operator|)
name|data
expr_stmt|;
name|bp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bio
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* 	 * Set up a bio request for fdstrategy().  bio_offset is faked 	 * so that fdstrategy() will seek to the the requested 	 * cylinder, and use the desired head. 	 */
name|bp
operator|->
name|bio_cmd
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|FDBIO_FORMAT
condition|)
block|{
name|bp
operator|->
name|bio_offset
operator|=
operator|(
name|finfo
operator|->
name|cyl
operator|*
operator|(
name|fd
operator|->
name|ft
operator|->
name|sectrac
operator|*
name|fd
operator|->
name|ft
operator|->
name|heads
operator|)
operator|+
name|finfo
operator|->
name|head
operator|*
name|fd
operator|->
name|ft
operator|->
name|sectrac
operator|)
operator|*
name|fdblk
expr_stmt|;
name|bp
operator|->
name|bio_bcount
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|fd_idfield_data
argument_list|)
operator|*
name|finfo
operator|->
name|fd_formb_nsecs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|FDBIO_RDSECTID
condition|)
block|{
name|bp
operator|->
name|bio_offset
operator|=
operator|(
name|idfield
operator|->
name|cyl
operator|*
operator|(
name|fd
operator|->
name|ft
operator|->
name|sectrac
operator|*
name|fd
operator|->
name|ft
operator|->
name|heads
operator|)
operator|+
name|idfield
operator|->
name|head
operator|*
name|fd
operator|->
name|ft
operator|->
name|sectrac
operator|)
operator|*
name|fdblk
expr_stmt|;
name|bp
operator|->
name|bio_bcount
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|fdc_readid
argument_list|)
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"wrong cmd in fdmisccmd()"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|data
expr_stmt|;
name|bp
operator|->
name|bio_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|bio_done
operator|=
name|fdbiodone
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator|=
literal|0
expr_stmt|;
comment|/* Now run the command. */
name|fdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|biowait
argument_list|(
name|bp
argument_list|,
literal|"fdcmd"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|fdu_t
name|fdu
decl_stmt|;
name|fd_p
name|fd
decl_stmt|;
name|struct
name|fdc_status
modifier|*
name|fsp
decl_stmt|;
name|struct
name|fdc_readid
modifier|*
name|rid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fd
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|fdu
operator|=
name|fd
operator|->
name|fdu
expr_stmt|;
comment|/* 	 * First, handle everything that could be done with 	 * FD_NONBLOCK still being set. 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGMEDIASIZE
case|:
if|if
condition|(
name|fd
operator|->
name|ft
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_NONBLOCK
operator|)
condition|?
name|EAGAIN
else|:
name|ENXIO
operator|)
return|;
operator|*
operator|(
name|off_t
operator|*
operator|)
name|addr
operator|=
operator|(
literal|128
operator|<<
operator|(
name|fd
operator|->
name|ft
operator|->
name|secsize
operator|)
operator|)
operator|*
name|fd
operator|->
name|ft
operator|->
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|DIOCGSECTORSIZE
case|:
if|if
condition|(
name|fd
operator|->
name|ft
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_NONBLOCK
operator|)
condition|?
name|EAGAIN
else|:
name|ENXIO
operator|)
return|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
literal|128
operator|<<
operator|(
name|fd
operator|->
name|ft
operator|->
name|secsize
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIONBIO
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|!=
literal|0
condition|)
name|fd
operator|->
name|flags
operator||=
name|FD_NONBLOCK
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fd
operator|->
name|ft
operator|==
literal|0
condition|)
block|{
comment|/* 				 * No drive type has been selected yet, 				 * cannot turn FNONBLOCK off. 				 */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|fd
operator|->
name|flags
operator|&=
operator|~
name|FD_NONBLOCK
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIOASYNC
case|:
comment|/* keep the generic fcntl() code happy */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FD_GTYPE
case|:
comment|/* get drive type */
if|if
condition|(
name|fd
operator|->
name|ft
operator|==
literal|0
condition|)
comment|/* no type known yet, return the native type */
operator|*
operator|(
expr|struct
name|fd_type
operator|*
operator|)
name|addr
operator|=
name|fd_native_types
index|[
name|fd
operator|->
name|type
index|]
expr_stmt|;
else|else
operator|*
operator|(
expr|struct
name|fd_type
operator|*
operator|)
name|addr
operator|=
operator|*
name|fd
operator|->
name|ft
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FD_STYPE
case|:
comment|/* set drive type */
comment|/* 		 * Allow setting drive type temporarily iff 		 * currently unset.  Used for fdformat so any 		 * user can set it, and then start formatting. 		 */
if|if
condition|(
name|fd
operator|->
name|ft
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* already set */
name|fd
operator|->
name|fts
index|[
literal|0
index|]
operator|=
operator|*
operator|(
expr|struct
name|fd_type
operator|*
operator|)
name|addr
expr_stmt|;
name|fd
operator|->
name|ft
operator|=
operator|&
name|fd
operator|->
name|fts
index|[
literal|0
index|]
expr_stmt|;
name|fd
operator|->
name|flags
operator||=
name|FD_UA
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FD_GOPTS
case|:
comment|/* get drive options */
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|fd
operator|->
name|options
operator|+
name|FDOPT_AUTOSEL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FD_SOPTS
case|:
comment|/* set drive options */
name|fd
operator|->
name|options
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|&
operator|~
name|FDOPT_AUTOSEL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|FDC_DEBUG
case|case
name|FD_DEBUG
case|:
if|if
condition|(
operator|(
name|fd_debug
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|!=
literal|0
operator|)
condition|)
block|{
name|fd_debug
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|!=
literal|0
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"fd%d: debugging turned %s\n"
argument_list|,
name|fd
operator|->
name|fdu
argument_list|,
name|fd_debug
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
case|case
name|FD_CLRERR
case|:
if|if
condition|(
name|suser
argument_list|(
name|td
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|fd
operator|->
name|fdc
operator|->
name|fdc_errs
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FD_GSTAT
case|:
name|fsp
operator|=
operator|(
expr|struct
name|fdc_status
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|->
name|fdc
operator|->
name|flags
operator|&
name|FDC_STAT_VALID
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|fsp
operator|->
name|status
argument_list|,
name|fd
operator|->
name|fdc
operator|->
name|status
argument_list|,
literal|7
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FD_GDTYPE
case|:
operator|*
operator|(
expr|enum
name|fd_drivetype
operator|*
operator|)
name|addr
operator|=
name|fd
operator|->
name|type
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now handle everything else.  Make sure we have a valid 	 * drive type. 	 */
if|if
condition|(
name|fd
operator|->
name|flags
operator|&
name|FD_NONBLOCK
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
if|if
condition|(
name|fd
operator|->
name|ft
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FD_FORM
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
comment|/* must be opened for writing */
if|if
condition|(
operator|(
operator|(
expr|struct
name|fd_formb
operator|*
operator|)
name|addr
operator|)
operator|->
name|format_version
operator|!=
name|FD_FORMAT_VERSION
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* wrong version of formatting prog */
name|error
operator|=
name|fdmisccmd
argument_list|(
name|dev
argument_list|,
name|FDBIO_FORMAT
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|FD_GTYPE
case|:
comment|/* get drive type */
operator|*
operator|(
expr|struct
name|fd_type
operator|*
operator|)
name|addr
operator|=
operator|*
name|fd
operator|->
name|ft
expr_stmt|;
break|break;
case|case
name|FD_STYPE
case|:
comment|/* set drive type */
comment|/* this is considered harmful; only allow for superuser */
if|if
condition|(
name|suser
argument_list|(
name|td
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
operator|*
name|fd
operator|->
name|ft
operator|=
operator|*
operator|(
expr|struct
name|fd_type
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|FD_GOPTS
case|:
comment|/* get drive options */
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|fd
operator|->
name|options
expr_stmt|;
break|break;
case|case
name|FD_SOPTS
case|:
comment|/* set drive options */
name|fd
operator|->
name|options
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FDC_DEBUG
case|case
name|FD_DEBUG
case|:
if|if
condition|(
operator|(
name|fd_debug
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|!=
literal|0
operator|)
condition|)
block|{
name|fd_debug
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|!=
literal|0
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"fd%d: debugging turned %s\n"
argument_list|,
name|fd
operator|->
name|fdu
argument_list|,
name|fd_debug
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|FD_CLRERR
case|:
if|if
condition|(
name|suser
argument_list|(
name|td
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|fd
operator|->
name|fdc
operator|->
name|fdc_errs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FD_GSTAT
case|:
name|fsp
operator|=
operator|(
expr|struct
name|fdc_status
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|->
name|fdc
operator|->
name|flags
operator|&
name|FDC_STAT_VALID
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|fsp
operator|->
name|status
argument_list|,
name|fd
operator|->
name|fdc
operator|->
name|status
argument_list|,
literal|7
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FD_READID
case|:
name|rid
operator|=
operator|(
expr|struct
name|fdc_readid
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|rid
operator|->
name|cyl
operator|>
name|MAX_CYLINDER
operator|||
name|rid
operator|->
name|head
operator|>
name|MAX_HEAD
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|fdmisccmd
argument_list|(
name|dev
argument_list|,
name|FDBIO_RDSECTID
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

