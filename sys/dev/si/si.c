begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Device driver for Specialix range (SI/XIO) of serial line multiplexors.  *  * Copyright (C) 1990, 1992, 1998 Specialix International,  * Copyright (C) 1993, Andy Rutter<andy@acronym.co.uk>  * Copyright (C) 2000, Peter Wemm<peter@netplex.com.au>  *  * Originally derived from:	SunOS 4.x version  * Ported from BSDI version to FreeBSD by Peter Wemm.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notices, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notices, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Andy Rutter of  *	Advanced Methods and Tools Ltd. based on original information  *	from Specialix International.  * 4. Neither the name of Advanced Methods and Tools, nor Specialix  *    International may be used to endorse or promote products derived from  *    this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN  * NO EVENT SHALL THE AUTHORS BE LIABLE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|si_copyright1
index|[]
init|=
literal|"@(#) Copyright (C) Specialix International, 1990,1992,1998"
decl_stmt|,
name|si_copyright2
index|[]
init|=
literal|"@(#) Copyright (C) Andy Rutter 1993"
decl_stmt|,
name|si_copyright3
index|[]
init|=
literal|"@(#) Copyright (C) Peter Wemm 2000"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_debug_si.h"
end_include

begin_include
include|#
directive|include
file|"opt_eisa.h"
end_include

begin_include
include|#
directive|include
file|"opt_tty.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/serial.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<dev/si/sireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/si/sivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/si/si.h>
end_include

begin_comment
comment|/*  * This device driver is designed to interface the Specialix International  * SI, XIO and SX range of serial multiplexor cards to FreeBSD on an ISA,  * EISA or PCI bus machine.  *  * The controller is interfaced to the host via dual port RAM  * and an interrupt.  *  * The code for the Host 1 (very old ISA cards) has not been tested.  */
end_comment

begin_define
define|#
directive|define
name|POLL
end_define

begin_comment
comment|/* turn on poller to scan for lost interrupts */
end_comment

begin_define
define|#
directive|define
name|REALPOLL
end_define

begin_comment
comment|/* on each poll, scan for work regardless */
end_comment

begin_define
define|#
directive|define
name|POLLHZ
value|(hz/10)
end_define

begin_comment
comment|/* 10 times per second */
end_comment

begin_define
define|#
directive|define
name|SI_I_HIGH_WATER
value|(TTYHOG - 2 * SI_BUFFERSIZE)
end_define

begin_define
define|#
directive|define
name|INT_COUNT
value|25000
end_define

begin_comment
comment|/* max of 125 ints per second */
end_comment

begin_define
define|#
directive|define
name|JET_INT_COUNT
value|100
end_define

begin_comment
comment|/* max of 100 ints per second */
end_comment

begin_define
define|#
directive|define
name|RXINT_COUNT
value|1
end_define

begin_comment
comment|/* one rxint per 10 milliseconds */
end_comment

begin_function_decl
specifier|static
name|void
name|si_command
parameter_list|(
name|struct
name|si_port
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|si_Sioctl
parameter_list|(
name|struct
name|cdev
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|si_start
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|si_stop
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|si_lstart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_break_t
name|sibreak
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_close_t
name|siclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_modem_t
name|simodem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_open_t
name|siopen
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|siparam
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|struct
name|termios
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|si_modem_state
parameter_list|(
name|struct
name|si_port
modifier|*
name|pp
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|hi_ip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|si_modulename
parameter_list|(
name|int
name|host_type
parameter_list|,
name|int
name|uart_type
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|si_Scdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_ioctl
operator|=
name|si_Sioctl
block|,
operator|.
name|d_name
operator|=
literal|"si"
block|,
operator|.
name|d_flags
operator|=
name|D_TTY
operator||
name|D_NEEDGIANT
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|si_Nports
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|si_Nmodules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|si_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data, not bss, so it's patchable */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|si_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|si_debug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"machdep.si_debug"
argument_list|,
operator|&
name|si_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|si_numunits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|si_devclass
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|B2000
end_ifndef

begin_comment
comment|/* not standard, but the hardware knows it. */
end_comment

begin_define
define|#
directive|define
name|B2000
value|2000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|speedtab
name|bdrates
index|[]
init|=
block|{
block|{
name|B75
block|,
name|CLK75
block|, }
block|,
comment|/* 0x0 */
block|{
name|B110
block|,
name|CLK110
block|, }
block|,
comment|/* 0x1 */
block|{
name|B150
block|,
name|CLK150
block|, }
block|,
comment|/* 0x3 */
block|{
name|B300
block|,
name|CLK300
block|, }
block|,
comment|/* 0x4 */
block|{
name|B600
block|,
name|CLK600
block|, }
block|,
comment|/* 0x5 */
block|{
name|B1200
block|,
name|CLK1200
block|, }
block|,
comment|/* 0x6 */
block|{
name|B2000
block|,
name|CLK2000
block|, }
block|,
comment|/* 0x7 */
block|{
name|B2400
block|,
name|CLK2400
block|, }
block|,
comment|/* 0x8 */
block|{
name|B4800
block|,
name|CLK4800
block|, }
block|,
comment|/* 0x9 */
block|{
name|B9600
block|,
name|CLK9600
block|, }
block|,
comment|/* 0xb */
block|{
name|B19200
block|,
name|CLK19200
block|, }
block|,
comment|/* 0xc */
block|{
name|B38400
block|,
name|CLK38400
block|, }
block|,
comment|/* 0x2 (out of order!) */
block|{
name|B57600
block|,
name|CLK57600
block|, }
block|,
comment|/* 0xd */
block|{
name|B115200
block|,
name|CLK110
block|, }
block|,
comment|/* 0x1 (dupe!, 110 baud on "si") */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* populated with approx character/sec rates - translated at card  * initialisation time to chars per tick of the clock */
end_comment

begin_decl_stmt
specifier|static
name|int
name|done_chartimes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|speedtab
name|chartimes
index|[]
init|=
block|{
block|{
name|B75
block|,
literal|8
block|, }
block|,
block|{
name|B110
block|,
literal|11
block|, }
block|,
block|{
name|B150
block|,
literal|15
block|, }
block|,
block|{
name|B300
block|,
literal|30
block|, }
block|,
block|{
name|B600
block|,
literal|60
block|, }
block|,
block|{
name|B1200
block|,
literal|120
block|, }
block|,
block|{
name|B2000
block|,
literal|200
block|, }
block|,
block|{
name|B2400
block|,
literal|240
block|, }
block|,
block|{
name|B4800
block|,
literal|480
block|, }
block|,
block|{
name|B9600
block|,
literal|960
block|, }
block|,
block|{
name|B19200
block|,
literal|1920
block|, }
block|,
block|{
name|B38400
block|,
literal|3840
block|, }
block|,
block|{
name|B57600
block|,
literal|5760
block|, }
block|,
block|{
name|B115200
block|,
literal|11520
block|, }
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|in_intr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Inside interrupt handler? */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|POLL
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|si_pollrate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in addition to irq */
end_comment

begin_decl_stmt
specifier|static
name|int
name|si_realpoll
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* poll HW on timer */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|si_pollrate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|si_pollrate
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|si_realpoll
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|si_realpoll
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|init_finished
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|si_poll
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Array of adapter types and the corresponding RAM size. The order of  * entries here MUST match the ordinal of the adapter type.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|si_type
index|[]
init|=
block|{
literal|"EMPTY"
block|,
literal|"SIHOST"
block|,
literal|"SIMCA"
block|,
comment|/* FreeBSD does not support Microchannel */
literal|"SIHOST2"
block|,
literal|"SIEISA"
block|,
literal|"SIPCI"
block|,
literal|"SXPCI"
block|,
literal|"SXISA"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We have to make an 8 bit version of bcopy, since some cards can't  * deal with 32 bit I/O  */
end_comment

begin_function
specifier|static
name|void
name|__inline
name|si_bcopy
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|u_char
modifier|*
name|d
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|s
decl_stmt|;
name|d
operator|=
name|dst
expr_stmt|;
name|s
operator|=
name|src
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__inline
name|si_vbcopy
parameter_list|(
specifier|const
specifier|volatile
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|u_char
modifier|*
name|d
decl_stmt|;
specifier|const
specifier|volatile
name|u_char
modifier|*
name|s
decl_stmt|;
name|d
operator|=
name|dst
expr_stmt|;
name|s
operator|=
name|src
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__inline
name|si_bcopyv
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
specifier|volatile
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|volatile
name|u_char
modifier|*
name|d
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|s
decl_stmt|;
name|d
operator|=
name|dst
expr_stmt|;
name|s
operator|=
name|src
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach the device.  Initialize the card.  */
end_comment

begin_function
name|int
name|siattach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|struct
name|si_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
decl_stmt|;
specifier|volatile
name|struct
name|si_reg
modifier|*
name|regp
decl_stmt|;
specifier|volatile
name|caddr_t
name|maddr
decl_stmt|;
name|struct
name|si_module
modifier|*
name|modp
decl_stmt|;
name|struct
name|speedtab
modifier|*
name|spt
decl_stmt|;
name|int
name|nmodule
decl_stmt|,
name|nport
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|uart_type
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_typename
operator|=
name|si_type
index|[
name|sc
operator|->
name|sc_type
index|]
expr_stmt|;
if|if
condition|(
name|si_numunits
operator|<
name|unit
operator|+
literal|1
condition|)
name|si_numunits
operator|=
name|unit
operator|+
literal|1
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator|,
literal|"si%d: siattach\n"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POLL
if|if
condition|(
name|si_pollrate
operator|==
literal|0
condition|)
block|{
name|si_pollrate
operator|=
name|POLLHZ
expr_stmt|;
comment|/* in addition to irq */
ifdef|#
directive|ifdef
name|REALPOLL
name|si_realpoll
operator|=
literal|1
expr_stmt|;
comment|/* scan always */
endif|#
directive|endif
block|}
endif|#
directive|endif
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator|,
literal|"si%d: type: %s paddr: %x maddr: %x\n"
operator|,
name|unit
operator|,
name|sc
operator|->
name|sc_typename
operator|,
name|sc
operator|->
name|sc_paddr
operator|,
name|sc
operator|->
name|sc_maddr
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ports
operator|=
name|NULL
expr_stmt|;
comment|/* mark as uninitialised */
name|maddr
operator|=
name|sc
operator|->
name|sc_maddr
expr_stmt|;
comment|/* Stop the CPU first so it won't stomp around while we load */
switch|switch
condition|(
name|sc
operator|->
name|sc_type
condition|)
block|{
ifdef|#
directive|ifdef
name|DEV_EISA
case|case
name|SIEISA
case|:
name|outb
argument_list|(
name|sc
operator|->
name|sc_iobase
operator|+
literal|2
argument_list|,
name|sc
operator|->
name|sc_irq
operator|<<
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SIPCI
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIPCIRESET
operator|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIJETPCI
case|:
comment|/* fall through to JET ISA */
case|case
name|SIJETISA
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIJETCONFIG
operator|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIHOST2
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIPLRESET
operator|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIHOST
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIRESET
operator|)
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* this should never happen */
name|printf
argument_list|(
literal|"si%d: unsupported configuration\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
break|break;
block|}
comment|/* OK, now lets download the download code */
if|if
condition|(
name|SI_ISJET
argument_list|(
name|sc
operator|->
name|sc_type
argument_list|)
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_DOWNLOAD
operator|,
literal|"si%d: jet_download: nbytes %d\n"
operator|,
name|unit
operator|,
name|si3_t225_dsize
operator|)
argument_list|)
expr_stmt|;
name|si_bcopy
argument_list|(
name|si3_t225_download
argument_list|,
name|maddr
operator|+
name|si3_t225_downloadaddr
argument_list|,
name|si3_t225_dsize
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_DOWNLOAD
operator|,
literal|"si%d: jet_bootstrap: nbytes %d -> %x\n"
operator|,
name|unit
operator|,
name|si3_t225_bsize
operator|,
name|si3_t225_bootloadaddr
operator|)
argument_list|)
expr_stmt|;
name|si_bcopy
argument_list|(
name|si3_t225_bootstrap
argument_list|,
name|maddr
operator|+
name|si3_t225_bootloadaddr
argument_list|,
name|si3_t225_bsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_DOWNLOAD
operator|,
literal|"si%d: si_download: nbytes %d\n"
operator|,
name|unit
operator|,
name|si2_z280_dsize
operator|)
argument_list|)
expr_stmt|;
name|si_bcopy
argument_list|(
name|si2_z280_download
argument_list|,
name|maddr
operator|+
name|si2_z280_downloadaddr
argument_list|,
name|si2_z280_dsize
argument_list|)
expr_stmt|;
block|}
comment|/* Now start the CPU */
switch|switch
condition|(
name|sc
operator|->
name|sc_type
condition|)
block|{
ifdef|#
directive|ifdef
name|DEV_EISA
case|case
name|SIEISA
case|:
comment|/* modify the download code to tell it that it's on an EISA */
operator|*
operator|(
name|maddr
operator|+
literal|0x42
operator|)
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|sc_iobase
operator|+
literal|2
argument_list|,
operator|(
name|sc
operator|->
name|sc_irq
operator|<<
literal|4
operator|)
operator||
literal|4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|sc_iobase
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* reset interrupt */
break|break;
endif|#
directive|endif
case|case
name|SIPCI
case|:
comment|/* modify the download code to tell it that it's on a PCI */
operator|*
operator|(
name|maddr
operator|+
literal|0x42
operator|)
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|maddr
operator|+
name|SIPCIRESET
operator|)
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|maddr
operator|+
name|SIPCIINTCL
operator|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIJETPCI
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIJETRESET
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|maddr
operator|+
name|SIJETCONFIG
operator|)
operator|=
name|SIJETBUSEN
operator||
name|SIJETIRQEN
expr_stmt|;
break|break;
case|case
name|SIJETISA
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIJETRESET
operator|)
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_irq
condition|)
block|{
case|case
literal|9
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIJETCONFIG
operator|)
operator|=
name|SIJETBUSEN
operator||
name|SIJETIRQEN
operator||
literal|0x90
expr_stmt|;
break|break;
case|case
literal|10
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIJETCONFIG
operator|)
operator|=
name|SIJETBUSEN
operator||
name|SIJETIRQEN
operator||
literal|0xa0
expr_stmt|;
break|break;
case|case
literal|11
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIJETCONFIG
operator|)
operator|=
name|SIJETBUSEN
operator||
name|SIJETIRQEN
operator||
literal|0xb0
expr_stmt|;
break|break;
case|case
literal|12
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIJETCONFIG
operator|)
operator|=
name|SIJETBUSEN
operator||
name|SIJETIRQEN
operator||
literal|0xc0
expr_stmt|;
break|break;
case|case
literal|15
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIJETCONFIG
operator|)
operator|=
name|SIJETBUSEN
operator||
name|SIJETIRQEN
operator||
literal|0xf0
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIHOST
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIRESET_CL
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|maddr
operator|+
name|SIINTCL_CL
operator|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIHOST2
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIPLRESET
operator|)
operator|=
literal|0x10
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_irq
condition|)
block|{
case|case
literal|11
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIPLIRQ11
operator|)
operator|=
literal|0x10
expr_stmt|;
break|break;
case|case
literal|12
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIPLIRQ12
operator|)
operator|=
literal|0x10
expr_stmt|;
break|break;
case|case
literal|15
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIPLIRQ15
operator|)
operator|=
literal|0x10
expr_stmt|;
break|break;
block|}
operator|*
operator|(
name|maddr
operator|+
name|SIPLIRQCLR
operator|)
operator|=
literal|0x10
expr_stmt|;
break|break;
default|default:
comment|/* this should _REALLY_ never happen */
name|printf
argument_list|(
literal|"si%d: Uh, it was supported a second ago...\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
comment|/* wait around for a second */
name|regp
operator|=
operator|(
expr|struct
name|si_reg
operator|*
operator|)
name|maddr
expr_stmt|;
name|y
operator|=
literal|0
expr_stmt|;
comment|/* wait max of 5 sec for init OK */
while|while
condition|(
name|regp
operator|->
name|initstat
operator|==
literal|0
operator|&&
name|y
operator|++
operator|<
literal|10
condition|)
block|{
name|DELAY
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|regp
operator|->
name|initstat
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"si%d: startup timeout - aborting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_type
operator|=
name|SIEMPTY
expr_stmt|;
return|return
name|EINVAL
return|;
case|case
literal|1
case|:
if|if
condition|(
name|SI_ISJET
argument_list|(
name|sc
operator|->
name|sc_type
argument_list|)
condition|)
block|{
comment|/* set throttle to 100 times per second */
name|regp
operator|->
name|int_count
operator|=
name|JET_INT_COUNT
expr_stmt|;
comment|/* rx_intr_count is a NOP in Jet */
block|}
else|else
block|{
comment|/* set throttle to 125 times per second */
name|regp
operator|->
name|int_count
operator|=
name|INT_COUNT
expr_stmt|;
comment|/* rx intr max of 25 times per second */
name|regp
operator|->
name|rx_int_count
operator|=
name|RXINT_COUNT
expr_stmt|;
block|}
name|regp
operator|->
name|int_pending
operator|=
literal|0
expr_stmt|;
comment|/* no intr pending */
name|regp
operator|->
name|int_scounter
operator|=
literal|0
expr_stmt|;
comment|/* reset counter */
break|break;
case|case
literal|0xff
case|:
comment|/* 		 * No modules found, so give up on this one. 		 */
name|printf
argument_list|(
literal|"si%d: %s - no ports found\n"
argument_list|,
name|unit
argument_list|,
name|si_type
index|[
name|sc
operator|->
name|sc_type
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|printf
argument_list|(
literal|"si%d: download code version error - initstat %x\n"
argument_list|,
name|unit
argument_list|,
name|regp
operator|->
name|initstat
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* 	 * First time around the ports just count them in order 	 * to allocate some memory. 	 */
name|nport
operator|=
literal|0
expr_stmt|;
name|modp
operator|=
operator|(
expr|struct
name|si_module
operator|*
operator|)
operator|(
name|maddr
operator|+
literal|0x80
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_DOWNLOAD
operator|,
literal|"si%d: ccb addr 0x%x\n"
operator|,
name|unit
operator|,
name|modp
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|modp
operator|->
name|sm_type
condition|)
block|{
case|case
name|TA4
case|:
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_DOWNLOAD
operator|,
literal|"si%d: Found old TA4 module, 4 ports\n"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|TA8
case|:
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_DOWNLOAD
operator|,
literal|"si%d: Found old TA8 module, 8 ports\n"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|TA4_ASIC
case|:
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_DOWNLOAD
operator|,
literal|"si%d: Found ASIC TA4 module, 4 ports\n"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|TA8_ASIC
case|:
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_DOWNLOAD
operator|,
literal|"si%d: Found ASIC TA8 module, 8 ports\n"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|MTA
case|:
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_DOWNLOAD
operator|,
literal|"si%d: Found CD1400 module, 8 ports\n"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|SXDC
case|:
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_DOWNLOAD
operator|,
literal|"si%d: Found SXDC module, 8 ports\n"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"si%d: unknown module type %d\n"
argument_list|,
name|unit
argument_list|,
name|modp
operator|->
name|sm_type
argument_list|)
expr_stmt|;
goto|goto
name|try_next
goto|;
block|}
comment|/* this was limited in firmware and is also a driver issue */
if|if
condition|(
operator|(
name|nport
operator|+
name|x
operator|)
operator|>
name|SI_MAXPORTPERCARD
condition|)
block|{
name|printf
argument_list|(
literal|"si%d: extra ports ignored\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|try_next
goto|;
block|}
name|nport
operator|+=
name|x
expr_stmt|;
name|si_Nports
operator|+=
name|x
expr_stmt|;
name|si_Nmodules
operator|++
expr_stmt|;
name|try_next
label|:
if|if
condition|(
name|modp
operator|->
name|sm_next
operator|==
literal|0
condition|)
break|break;
name|modp
operator|=
operator|(
expr|struct
name|si_module
operator|*
operator|)
operator|(
name|maddr
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|modp
operator|->
name|sm_next
operator|&
literal|0x7fff
argument_list|)
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ports
operator|=
operator|(
expr|struct
name|si_port
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|si_port
argument_list|)
operator|*
name|nport
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ports
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"si%d: fail to malloc memory for port structs\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|sc
operator|->
name|sc_nport
operator|=
name|nport
expr_stmt|;
comment|/* 	 * Scan round the ports again, this time initialising. 	 */
name|pp
operator|=
name|sc
operator|->
name|sc_ports
expr_stmt|;
name|nmodule
operator|=
literal|0
expr_stmt|;
name|modp
operator|=
operator|(
expr|struct
name|si_module
operator|*
operator|)
operator|(
name|maddr
operator|+
literal|0x80
operator|)
expr_stmt|;
name|uart_type
operator|=
literal|1000
expr_stmt|;
comment|/* arbitary,> uchar_max */
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|modp
operator|->
name|sm_type
condition|)
block|{
case|case
name|TA4
case|:
name|nport
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|TA8
case|:
name|nport
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|TA4_ASIC
case|:
name|nport
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|TA8_ASIC
case|:
name|nport
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|MTA
case|:
name|nport
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|SXDC
case|:
name|nport
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
goto|goto
name|try_next2
goto|;
block|}
name|nmodule
operator|++
expr_stmt|;
name|ccbp
operator|=
operator|(
expr|struct
name|si_channel
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|modp
operator|+
literal|0x100
operator|)
expr_stmt|;
if|if
condition|(
name|uart_type
operator|==
literal|1000
condition|)
name|uart_type
operator|=
name|ccbp
operator|->
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|uart_type
operator|!=
name|ccbp
operator|->
name|type
condition|)
name|printf
argument_list|(
literal|"si%d: Warning: module %d mismatch! (%d%s != %d%s)\n"
argument_list|,
name|unit
argument_list|,
name|nmodule
argument_list|,
name|ccbp
operator|->
name|type
argument_list|,
name|si_modulename
argument_list|(
name|sc
operator|->
name|sc_type
argument_list|,
name|ccbp
operator|->
name|type
argument_list|)
argument_list|,
name|uart_type
argument_list|,
name|si_modulename
argument_list|(
name|sc
operator|->
name|sc_type
argument_list|,
name|uart_type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nport
condition|;
name|x
operator|++
operator|,
name|pp
operator|++
operator|,
name|ccbp
operator|++
control|)
block|{
name|pp
operator|->
name|sp_ccb
operator|=
name|ccbp
expr_stmt|;
comment|/* save the address */
name|pp
operator|->
name|sp_pend
operator|=
name|IDLE_CLOSE
expr_stmt|;
name|pp
operator|->
name|sp_state
operator|=
literal|0
expr_stmt|;
comment|/* internal flag */
ifdef|#
directive|ifdef
name|SI_DEBUG
name|sprintf
argument_list|(
name|pp
operator|->
name|sp_name
argument_list|,
literal|"si%r%r"
argument_list|,
name|unit
argument_list|,
call|(
name|int
call|)
argument_list|(
name|pp
operator|-
name|sc
operator|->
name|sc_ports
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp
operator|=
name|pp
operator|->
name|sp_tty
operator|=
name|ttyalloc
argument_list|()
expr_stmt|;
name|tp
operator|->
name|t_sc
operator|=
name|pp
expr_stmt|;
name|tp
operator|->
name|t_break
operator|=
name|sibreak
expr_stmt|;
name|tp
operator|->
name|t_close
operator|=
name|siclose
expr_stmt|;
name|tp
operator|->
name|t_modem
operator|=
name|simodem
expr_stmt|;
name|tp
operator|->
name|t_open
operator|=
name|siopen
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|si_start
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|siparam
expr_stmt|;
name|tp
operator|->
name|t_stop
operator|=
name|si_stop
expr_stmt|;
name|ttycreate
argument_list|(
name|tp
argument_list|,
name|TS_CALLOUT
argument_list|,
literal|"A%r%r"
argument_list|,
name|unit
argument_list|,
call|(
name|int
call|)
argument_list|(
name|pp
operator|-
name|sc
operator|->
name|sc_ports
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|try_next2
label|:
if|if
condition|(
name|modp
operator|->
name|sm_next
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"si%d: card: %s, ports: %d, modules: %d, type: %d%s\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_typename
argument_list|,
name|sc
operator|->
name|sc_nport
argument_list|,
name|nmodule
argument_list|,
name|uart_type
argument_list|,
name|si_modulename
argument_list|(
name|sc
operator|->
name|sc_type
argument_list|,
name|uart_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|modp
operator|=
operator|(
expr|struct
name|si_module
operator|*
operator|)
operator|(
name|maddr
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|modp
operator|->
name|sm_next
operator|&
literal|0x7fff
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|done_chartimes
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|spt
operator|=
name|chartimes
init|;
name|spt
operator|->
name|sp_speed
operator|!=
operator|-
literal|1
condition|;
name|spt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|spt
operator|->
name|sp_code
operator|/=
name|hz
operator|)
operator|==
literal|0
condition|)
name|spt
operator|->
name|sp_code
operator|=
literal|1
expr_stmt|;
block|}
name|done_chartimes
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
name|make_dev
argument_list|(
operator|&
name|si_Scdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"si_control"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|siopen
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|POLL
comment|/* 	 * We've now got a device, so start the poller. 	 */
if|if
condition|(
name|init_finished
operator|==
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|si_poll
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0L
argument_list|,
name|si_pollrate
argument_list|)
expr_stmt|;
name|init_finished
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|siclose
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
operator|(
name|void
operator|)
name|si_command
argument_list|(
name|pp
argument_list|,
name|FCLOSE
argument_list|,
name|SI_NOWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sibreak
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sig
condition|)
name|si_command
argument_list|(
name|pp
argument_list|,
name|SBREAK
argument_list|,
name|SI_WAIT
argument_list|)
expr_stmt|;
else|else
name|si_command
argument_list|(
name|pp
argument_list|,
name|EBREAK
argument_list|,
name|SI_WAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle the Specialix ioctls on the control dev.  */
end_comment

begin_function
specifier|static
name|int
name|si_Sioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|si_softc
modifier|*
name|xsc
decl_stmt|;
name|struct
name|si_port
modifier|*
name|xpp
decl_stmt|;
specifier|volatile
name|struct
name|si_reg
modifier|*
name|regp
decl_stmt|;
name|struct
name|si_tcsi
modifier|*
name|dp
decl_stmt|;
name|struct
name|si_pstat
modifier|*
name|sps
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|oldspl
decl_stmt|;
name|int
name|card
decl_stmt|,
name|port
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_ENTRY
operator||
name|DBG_IOCTL
operator|,
literal|"si_Sioctl(%s,%lx,%x,%x)\n"
operator|,
name|devtoname
argument_list|(
name|dev
argument_list|)
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_IOCTL
operator|,
literal|"TCSI_PORT=%x\n"
operator|,
name|TCSI_PORT
operator|)
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_IOCTL
operator|,
literal|"TCSI_CCB=%x\n"
operator|,
name|TCSI_CCB
operator|)
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_IOCTL
operator|,
literal|"TCSI_TTY=%x\n"
operator|,
name|TCSI_TTY
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* better safe than sorry */
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
define|#
directive|define
name|SUCHECK
value|if ((error = priv_check(td, PRIV_DRIVER))) goto out
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TCSIPORTS
case|:
operator|*
name|ip
operator|=
name|si_Nports
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|TCSIMODULES
case|:
operator|*
name|ip
operator|=
name|si_Nmodules
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|TCSISDBG_ALL
case|:
name|SUCHECK
expr_stmt|;
name|si_debug
operator|=
operator|*
name|ip
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|TCSIGDBG_ALL
case|:
operator|*
name|ip
operator|=
name|si_debug
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
comment|/* 		 * Check that a controller for this port exists 		 */
comment|/* may also be a struct si_pstat, a superset of si_tcsi */
name|dp
operator|=
operator|(
expr|struct
name|si_tcsi
operator|*
operator|)
name|data
expr_stmt|;
name|sps
operator|=
operator|(
expr|struct
name|si_pstat
operator|*
operator|)
name|data
expr_stmt|;
name|card
operator|=
name|dp
operator|->
name|tc_card
expr_stmt|;
name|xsc
operator|=
name|devclass_get_softc
argument_list|(
name|si_devclass
argument_list|,
name|card
argument_list|)
expr_stmt|;
comment|/* check.. */
if|if
condition|(
name|xsc
operator|==
name|NULL
operator|||
name|xsc
operator|->
name|sc_type
operator|==
name|SIEMPTY
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * And check that a port exists 		 */
name|port
operator|=
name|dp
operator|->
name|tc_port
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|0
operator|||
name|port
operator|>=
name|xsc
operator|->
name|sc_nport
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|xpp
operator|=
name|xsc
operator|->
name|sc_ports
operator|+
name|port
expr_stmt|;
name|regp
operator|=
operator|(
expr|struct
name|si_reg
operator|*
operator|)
name|xsc
operator|->
name|sc_maddr
expr_stmt|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TCSIDEBUG
case|:
ifdef|#
directive|ifdef
name|SI_DEBUG
name|SUCHECK
expr_stmt|;
if|if
condition|(
name|xpp
operator|->
name|sp_debug
condition|)
name|xpp
operator|->
name|sp_debug
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|xpp
operator|->
name|sp_debug
operator|=
name|DBG_ALL
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|xpp
operator|,
name|DBG_IOCTL
operator|,
literal|"debug toggled %s\n"
operator|,
operator|(
name|xpp
operator|->
name|sp_debug
operator|&
name|DBG_ALL
operator|)
condition|?
literal|"ON"
else|:
literal|"OFF"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
else|#
directive|else
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
endif|#
directive|endif
case|case
name|TCSISDBG_LEVEL
case|:
case|case
name|TCSIGDBG_LEVEL
case|:
ifdef|#
directive|ifdef
name|SI_DEBUG
if|if
condition|(
name|cmd
operator|==
name|TCSIGDBG_LEVEL
condition|)
block|{
name|dp
operator|->
name|tc_dbglvl
operator|=
name|xpp
operator|->
name|sp_debug
expr_stmt|;
block|}
else|else
block|{
name|SUCHECK
expr_stmt|;
name|xpp
operator|->
name|sp_debug
operator|=
name|dp
operator|->
name|tc_dbglvl
expr_stmt|;
block|}
break|break;
else|#
directive|else
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
endif|#
directive|endif
case|case
name|TCSIGRXIT
case|:
name|dp
operator|->
name|tc_int
operator|=
name|regp
operator|->
name|rx_int_count
expr_stmt|;
break|break;
case|case
name|TCSIRXIT
case|:
name|SUCHECK
expr_stmt|;
name|regp
operator|->
name|rx_int_count
operator|=
name|dp
operator|->
name|tc_int
expr_stmt|;
break|break;
case|case
name|TCSIGIT
case|:
name|dp
operator|->
name|tc_int
operator|=
name|regp
operator|->
name|int_count
expr_stmt|;
break|break;
case|case
name|TCSIIT
case|:
name|SUCHECK
expr_stmt|;
name|regp
operator|->
name|int_count
operator|=
name|dp
operator|->
name|tc_int
expr_stmt|;
break|break;
case|case
name|TCSISTATE
case|:
name|dp
operator|->
name|tc_int
operator|=
name|xpp
operator|->
name|sp_ccb
operator|->
name|hi_ip
expr_stmt|;
break|break;
comment|/* these next three use a different structure */
case|case
name|TCSI_PORT
case|:
name|SUCHECK
expr_stmt|;
name|si_bcopy
argument_list|(
name|xpp
argument_list|,
operator|&
name|sps
operator|->
name|tc_siport
argument_list|,
sizeof|sizeof
argument_list|(
name|sps
operator|->
name|tc_siport
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCSI_CCB
case|:
name|SUCHECK
expr_stmt|;
name|si_vbcopy
argument_list|(
name|xpp
operator|->
name|sp_ccb
argument_list|,
operator|&
name|sps
operator|->
name|tc_ccb
argument_list|,
sizeof|sizeof
argument_list|(
name|sps
operator|->
name|tc_ccb
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCSI_TTY
case|:
name|SUCHECK
expr_stmt|;
name|si_bcopy
argument_list|(
name|xpp
operator|->
name|sp_tty
argument_list|,
operator|&
name|sps
operator|->
name|tc_tty
argument_list|,
sizeof|sizeof
argument_list|(
name|sps
operator|->
name|tc_tty
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/*  *	siparam()	: Configure line params  *	called at spltty();  *	this may sleep, does not flush, nor wait for drain, nor block writes  *	caller must arrange this if it's important..  */
end_comment

begin_function
specifier|static
name|int
name|siparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|si_port
modifier|*
name|pp
init|=
name|tp
operator|->
name|t_sc
decl_stmt|;
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
decl_stmt|;
name|int
name|oldspl
decl_stmt|,
name|cflag
decl_stmt|,
name|iflag
decl_stmt|,
name|oflag
decl_stmt|,
name|lflag
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* shutup gcc */
name|int
name|ispeed
init|=
literal|0
decl_stmt|;
comment|/* shutup gcc */
name|int
name|ospeed
init|=
literal|0
decl_stmt|;
comment|/* shutup gcc */
name|BYTE
name|val
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_PARAM
operator|,
literal|"siparam(%x,%x)\n"
operator|,
name|tp
operator|,
name|t
operator|)
argument_list|)
expr_stmt|;
name|cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
name|iflag
operator|=
name|t
operator|->
name|c_iflag
expr_stmt|;
name|oflag
operator|=
name|t
operator|->
name|c_oflag
expr_stmt|;
name|lflag
operator|=
name|t
operator|->
name|c_lflag
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_PARAM
operator|,
literal|"OFLAG 0x%x CFLAG 0x%x IFLAG 0x%x LFLAG 0x%x\n"
operator|,
name|oflag
operator|,
name|cflag
operator|,
name|iflag
operator|,
name|lflag
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX - if Jet host and SXDC module, use extended baud rates */
comment|/* if not hung up.. */
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
block|{
comment|/* translate baud rate to firmware values */
name|ospeed
operator|=
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ospeed
argument_list|,
name|bdrates
argument_list|)
expr_stmt|;
name|ispeed
operator|=
name|t
operator|->
name|c_ispeed
condition|?
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ispeed
argument_list|,
name|bdrates
argument_list|)
else|:
name|ospeed
expr_stmt|;
comment|/* enforce legit baud rate */
if|if
condition|(
name|ospeed
operator|<
literal|0
operator|||
name|ispeed
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|ccbp
operator|=
name|pp
operator|->
name|sp_ccb
expr_stmt|;
comment|/* ========== set hi_break ========== */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IGNBRK
condition|)
comment|/* Breaks */
name|val
operator||=
name|BR_IGN
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|BRKINT
condition|)
comment|/* Interrupt on break? */
name|val
operator||=
name|BR_INT
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|PARMRK
condition|)
comment|/* Parity mark? */
name|val
operator||=
name|BR_PARMRK
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IGNPAR
condition|)
comment|/* Ignore chars with parity errors? */
name|val
operator||=
name|BR_PARIGN
expr_stmt|;
name|ccbp
operator|->
name|hi_break
operator|=
name|val
expr_stmt|;
comment|/* ========== set hi_csr ========== */
comment|/* if not hung up.. */
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
block|{
comment|/* Set I/O speeds */
name|val
operator|=
operator|(
name|ispeed
operator|<<
literal|4
operator|)
operator||
name|ospeed
expr_stmt|;
block|}
name|ccbp
operator|->
name|hi_csr
operator|=
name|val
expr_stmt|;
comment|/* ========== set hi_mr2 ========== */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CSTOPB
condition|)
comment|/* Stop bits */
name|val
operator||=
name|MR2_2_STOP
expr_stmt|;
else|else
name|val
operator||=
name|MR2_1_STOP
expr_stmt|;
comment|/* 	 * Enable H/W RTS/CTS handshaking. The default TA/MTA is 	 * a DCE, hence the reverse sense of RTS and CTS 	 */
comment|/* Output Flow - RTS must be raised before data can be sent */
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
name|val
operator||=
name|MR2_RTSCONT
expr_stmt|;
name|ccbp
operator|->
name|hi_mr2
operator|=
name|val
expr_stmt|;
comment|/* ========== set hi_mr1 ========== */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cflag
operator|&
name|PARENB
operator|)
condition|)
comment|/* Parity */
name|val
operator||=
name|MR1_NONE
expr_stmt|;
else|else
name|val
operator||=
name|MR1_WITH
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|PARODD
condition|)
name|val
operator||=
name|MR1_ODD
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS8
operator|)
operator|==
name|CS8
condition|)
block|{
comment|/* 8 data bits? */
name|val
operator||=
name|MR1_8_BITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS7
operator|)
operator|==
name|CS7
condition|)
block|{
comment|/* 7 data bits? */
name|val
operator||=
name|MR1_7_BITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS6
operator|)
operator|==
name|CS6
condition|)
block|{
comment|/* 6 data bits? */
name|val
operator||=
name|MR1_6_BITS
expr_stmt|;
block|}
else|else
block|{
comment|/* Must be 5 */
name|val
operator||=
name|MR1_5_BITS
expr_stmt|;
block|}
comment|/* 	 * Enable H/W RTS/CTS handshaking. The default TA/MTA is 	 * a DCE, hence the reverse sense of RTS and CTS 	 */
comment|/* Input Flow - CTS is raised when port is ready to receive data */
if|if
condition|(
name|cflag
operator|&
name|CRTS_IFLOW
condition|)
name|val
operator||=
name|MR1_CTSCONT
expr_stmt|;
name|ccbp
operator|->
name|hi_mr1
operator|=
name|val
expr_stmt|;
comment|/* ========== set hi_mask ========== */
name|val
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS8
operator|)
operator|==
name|CS8
condition|)
block|{
comment|/* 8 data bits? */
name|val
operator|&=
literal|0xFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS7
operator|)
operator|==
name|CS7
condition|)
block|{
comment|/* 7 data bits? */
name|val
operator|&=
literal|0x7F
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS6
operator|)
operator|==
name|CS6
condition|)
block|{
comment|/* 6 data bits? */
name|val
operator|&=
literal|0x3F
expr_stmt|;
block|}
else|else
block|{
comment|/* Must be 5 */
name|val
operator|&=
literal|0x1F
expr_stmt|;
block|}
if|if
condition|(
name|iflag
operator|&
name|ISTRIP
condition|)
name|val
operator|&=
literal|0x7F
expr_stmt|;
name|ccbp
operator|->
name|hi_mask
operator|=
name|val
expr_stmt|;
comment|/* ========== set hi_prtcl ========== */
name|val
operator|=
name|SP_DCEN
expr_stmt|;
comment|/* Monitor DCD always, or TIOCMGET misses it */
if|if
condition|(
name|iflag
operator|&
name|IXANY
condition|)
name|val
operator||=
name|SP_TANY
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IXON
condition|)
name|val
operator||=
name|SP_TXEN
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IXOFF
condition|)
name|val
operator||=
name|SP_RXEN
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|INPCK
condition|)
name|val
operator||=
name|SP_PAEN
expr_stmt|;
name|ccbp
operator|->
name|hi_prtcl
operator|=
name|val
expr_stmt|;
comment|/* ========== set hi_{rx|tx}{on|off} ========== */
comment|/* XXX: the card TOTALLY shields us from the flow control... */
name|ccbp
operator|->
name|hi_txon
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
expr_stmt|;
name|ccbp
operator|->
name|hi_txoff
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
expr_stmt|;
name|ccbp
operator|->
name|hi_rxon
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
expr_stmt|;
name|ccbp
operator|->
name|hi_rxoff
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
expr_stmt|;
comment|/* ========== send settings to the card ========== */
comment|/* potential sleep here */
if|if
condition|(
name|ccbp
operator|->
name|hi_stat
operator|==
name|IDLE_CLOSE
condition|)
comment|/* Not yet open */
name|si_command
argument_list|(
name|pp
argument_list|,
name|LOPEN
argument_list|,
name|SI_WAIT
argument_list|)
expr_stmt|;
comment|/* open it */
else|else
name|si_command
argument_list|(
name|pp
argument_list|,
name|CONFIG
argument_list|,
name|SI_WAIT
argument_list|)
expr_stmt|;
comment|/* change params */
comment|/* ========== set DTR etc ========== */
comment|/* Hangup if ospeed == 0 */
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|simodem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|SER_DTR
operator||
name|SER_RTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If the previous speed was 0, may need to re-enable 		 * the modem signals 		 */
operator|(
name|void
operator|)
name|simodem
argument_list|(
name|tp
argument_list|,
name|SER_DTR
operator||
name|SER_RTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_PARAM
operator|,
literal|"siparam, complete: MR1 %x MR2 %x HI_MASK %x PRTCL %x HI_BREAK %x\n"
operator|,
name|ccbp
operator|->
name|hi_mr1
operator|,
name|ccbp
operator|->
name|hi_mr2
operator|,
name|ccbp
operator|->
name|hi_mask
operator|,
name|ccbp
operator|->
name|hi_prtcl
operator|,
name|ccbp
operator|->
name|hi_break
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set/Get state of modem control lines.  * Due to DCE-like behaviour of the adapter, some signals need translation:  *	TIOCM_DTR	DSR  *	TIOCM_RTS	CTS  */
end_comment

begin_function
specifier|static
name|int
name|simodem
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|sigon
parameter_list|,
name|int
name|sigoff
parameter_list|)
block|{
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
decl_stmt|;
name|int
name|x
decl_stmt|;
name|pp
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_MODEM
operator|,
literal|"simodem(%x,%x)\n"
operator|,
name|sigon
operator|,
name|sigoff
operator|)
argument_list|)
expr_stmt|;
name|ccbp
operator|=
name|pp
operator|->
name|sp_ccb
expr_stmt|;
comment|/* Find channel address */
if|if
condition|(
name|sigon
operator|==
literal|0
operator|&&
name|sigoff
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|ccbp
operator|->
name|hi_ip
expr_stmt|;
comment|/* 		 * XXX: not sure this is correct, should it be CTS&DSR ? 		 * XXX: or do we (just) miss CTS& DSR ? 		 */
if|if
condition|(
name|x
operator|&
name|IP_DCD
condition|)
name|sigon
operator||=
name|SER_DCD
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|IP_DTR
condition|)
name|sigon
operator||=
name|SER_DTR
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|IP_RTS
condition|)
name|sigon
operator||=
name|SER_RTS
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|IP_RI
condition|)
name|sigon
operator||=
name|SER_RI
expr_stmt|;
return|return
operator|(
name|sigon
operator|)
return|;
block|}
name|x
operator|=
name|ccbp
operator|->
name|hi_op
expr_stmt|;
if|if
condition|(
name|sigon
operator|&
name|SER_DTR
condition|)
name|x
operator||=
name|OP_DSR
expr_stmt|;
if|if
condition|(
name|sigoff
operator|&
name|SER_DTR
condition|)
name|x
operator|&=
operator|~
name|OP_DSR
expr_stmt|;
if|if
condition|(
name|sigon
operator|&
name|SER_RTS
condition|)
name|x
operator||=
name|OP_CTS
expr_stmt|;
if|if
condition|(
name|sigoff
operator|&
name|SER_RTS
condition|)
name|x
operator|&=
operator|~
name|OP_CTS
expr_stmt|;
name|ccbp
operator|->
name|hi_op
operator|=
name|x
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Handle change of modem state  */
end_comment

begin_function
specifier|static
name|void
name|si_modem_state
parameter_list|(
name|struct
name|si_port
modifier|*
name|pp
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|hi_ip
parameter_list|)
block|{
comment|/* if a modem dev */
if|if
condition|(
name|hi_ip
operator|&
name|IP_DCD
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pp
operator|->
name|sp_last_hi_ip
operator|&
name|IP_DCD
operator|)
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"modem carr on t_line %d\n"
operator|,
name|tp
operator|->
name|t_line
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ttyld_modem
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pp
operator|->
name|sp_last_hi_ip
operator|&
name|IP_DCD
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"modem carr off\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyld_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
condition|)
operator|(
name|void
operator|)
name|simodem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|SER_DTR
operator||
name|SER_RTS
argument_list|)
expr_stmt|;
block|}
block|}
name|pp
operator|->
name|sp_last_hi_ip
operator|=
name|hi_ip
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Poller to catch missed interrupts.  *  * Note that the SYSV Specialix drivers poll at 100 times per second to get  * better response.  We could really use a "periodic" version timeout(). :-)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|POLL
end_ifdef

begin_function
specifier|static
name|void
name|si_poll
parameter_list|(
name|void
modifier|*
name|nothing
parameter_list|)
block|{
name|struct
name|si_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|volatile
name|struct
name|si_reg
modifier|*
name|regp
decl_stmt|;
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
name|int
name|lost
decl_stmt|,
name|oldspl
decl_stmt|,
name|port
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_POLL
operator|,
literal|"si_poll()\n"
operator|)
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_intr
condition|)
goto|goto
name|out
goto|;
name|lost
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|si_numunits
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|si_devclass
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|sc_type
operator|==
name|SIEMPTY
condition|)
continue|continue;
name|regp
operator|=
operator|(
expr|struct
name|si_reg
operator|*
operator|)
name|sc
operator|->
name|sc_maddr
expr_stmt|;
comment|/* 		 * See if there has been a pending interrupt for 2 seconds 		 * or so. The test (int_scounter>= 200) won't correspond 		 * to 2 seconds if int_count gets changed. 		 */
if|if
condition|(
name|regp
operator|->
name|int_pending
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|regp
operator|->
name|int_scounter
operator|>=
literal|200
operator|&&
name|regp
operator|->
name|initstat
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"si%d: lost intr\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lost
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|regp
operator|->
name|int_scounter
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * gripe about no input flow control.. 		 */
name|pp
operator|=
name|sc
operator|->
name|sc_ports
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|sc
operator|->
name|sc_nport
condition|;
name|pp
operator|++
operator|,
name|port
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|sp_delta_overflows
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"si%d: %d tty level buffer overflows\n"
argument_list|,
name|i
argument_list|,
name|pp
operator|->
name|sp_delta_overflows
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_delta_overflows
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lost
operator|||
name|si_realpoll
condition|)
name|si_intr
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* call intr with fake vector */
name|out
label|:
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|si_poll
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0L
argument_list|,
name|si_pollrate
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ifdef POLL */
end_comment

begin_comment
comment|/*  * The interrupt handler polls ALL ports on ALL adapters each time  * it is called.  */
end_comment

begin_decl_stmt
specifier|static
name|BYTE
name|si_rxbuf
index|[
name|SI_BUFFERSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input staging area */
end_comment

begin_decl_stmt
specifier|static
name|BYTE
name|si_txbuf
index|[
name|SI_BUFFERSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output staging area */
end_comment

begin_function
name|void
name|si_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|si_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|volatile
name|caddr_t
name|maddr
decl_stmt|;
name|BYTE
name|op
decl_stmt|,
name|ip
decl_stmt|;
name|int
name|x
decl_stmt|,
name|card
decl_stmt|,
name|port
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|isopen
decl_stmt|;
specifier|volatile
name|BYTE
modifier|*
name|z
decl_stmt|;
name|BYTE
name|c
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|arg
operator|==
name|NULL
condition|?
name|DBG_POLL
else|:
name|DBG_INTR
operator|,
literal|"si_intr\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_intr
condition|)
return|return;
name|in_intr
operator|=
literal|1
expr_stmt|;
comment|/* 	 * When we get an int we poll all the channels and do ALL pending 	 * work, not just the first one we find. This allows all cards to 	 * share the same vector. 	 * 	 * XXX - But if we're sharing the vector with something that's NOT 	 * a SI/XIO/SX card, we may be making more work for ourselves. 	 */
for|for
control|(
name|card
operator|=
literal|0
init|;
name|card
operator|<
name|si_numunits
condition|;
name|card
operator|++
control|)
block|{
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|si_devclass
argument_list|,
name|card
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|sc_type
operator|==
name|SIEMPTY
condition|)
continue|continue;
comment|/* 		 * First, clear the interrupt 		 */
switch|switch
condition|(
name|sc
operator|->
name|sc_type
condition|)
block|{
case|case
name|SIHOST
case|:
name|maddr
operator|=
name|sc
operator|->
name|sc_maddr
expr_stmt|;
operator|(
operator|(
specifier|volatile
expr|struct
name|si_reg
operator|*
operator|)
name|maddr
operator|)
operator|->
name|int_pending
operator|=
literal|0
expr_stmt|;
comment|/* flag nothing pending */
operator|*
operator|(
name|maddr
operator|+
name|SIINTCL
operator|)
operator|=
literal|0x00
expr_stmt|;
comment|/* Set IRQ clear */
operator|*
operator|(
name|maddr
operator|+
name|SIINTCL_CL
operator|)
operator|=
literal|0x00
expr_stmt|;
comment|/* Clear IRQ clear */
break|break;
case|case
name|SIHOST2
case|:
name|maddr
operator|=
name|sc
operator|->
name|sc_maddr
expr_stmt|;
operator|(
operator|(
specifier|volatile
expr|struct
name|si_reg
operator|*
operator|)
name|maddr
operator|)
operator|->
name|int_pending
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|maddr
operator|+
name|SIPLIRQCLR
operator|)
operator|=
literal|0x00
expr_stmt|;
operator|*
operator|(
name|maddr
operator|+
name|SIPLIRQCLR
operator|)
operator|=
literal|0x10
expr_stmt|;
break|break;
case|case
name|SIPCI
case|:
name|maddr
operator|=
name|sc
operator|->
name|sc_maddr
expr_stmt|;
operator|(
operator|(
specifier|volatile
expr|struct
name|si_reg
operator|*
operator|)
name|maddr
operator|)
operator|->
name|int_pending
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|maddr
operator|+
name|SIPCIINTCL
operator|)
operator|=
literal|0x0
expr_stmt|;
break|break;
case|case
name|SIJETPCI
case|:
comment|/* fall through to JETISA case */
case|case
name|SIJETISA
case|:
name|maddr
operator|=
name|sc
operator|->
name|sc_maddr
expr_stmt|;
operator|(
operator|(
specifier|volatile
expr|struct
name|si_reg
operator|*
operator|)
name|maddr
operator|)
operator|->
name|int_pending
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|maddr
operator|+
name|SIJETINTCL
operator|)
operator|=
literal|0x0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEV_EISA
case|case
name|SIEISA
case|:
name|maddr
operator|=
name|sc
operator|->
name|sc_maddr
expr_stmt|;
operator|(
operator|(
specifier|volatile
expr|struct
name|si_reg
operator|*
operator|)
name|maddr
operator|)
operator|->
name|int_pending
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|sc_iobase
operator|+
literal|3
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIEMPTY
case|:
default|default:
continue|continue;
block|}
operator|(
operator|(
specifier|volatile
expr|struct
name|si_reg
operator|*
operator|)
name|maddr
operator|)
operator|->
name|int_scounter
operator|=
literal|0
expr_stmt|;
comment|/* 		 * check each port 		 */
for|for
control|(
name|pp
operator|=
name|sc
operator|->
name|sc_ports
operator|,
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|sc
operator|->
name|sc_nport
condition|;
name|pp
operator|++
operator|,
name|port
operator|++
control|)
block|{
name|ccbp
operator|=
name|pp
operator|->
name|sp_ccb
expr_stmt|;
name|tp
operator|=
name|pp
operator|->
name|sp_tty
expr_stmt|;
comment|/* 			 * See if a command has completed ? 			 */
if|if
condition|(
name|ccbp
operator|->
name|hi_stat
operator|!=
name|pp
operator|->
name|sp_pend
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"si_intr hi_stat = 0x%x, pend = %d\n"
operator|,
name|ccbp
operator|->
name|hi_stat
operator|,
name|pp
operator|->
name|sp_pend
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pp
operator|->
name|sp_pend
condition|)
block|{
case|case
name|LOPEN
case|:
case|case
name|MPEND
case|:
case|case
name|MOPEN
case|:
case|case
name|CONFIG
case|:
case|case
name|SBREAK
case|:
case|case
name|EBREAK
case|:
name|pp
operator|->
name|sp_pend
operator|=
name|ccbp
operator|->
name|hi_stat
expr_stmt|;
comment|/* sleeping in si_command */
name|wakeup
argument_list|(
operator|&
name|pp
operator|->
name|sp_state
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp
operator|->
name|sp_pend
operator|=
name|ccbp
operator|->
name|hi_stat
expr_stmt|;
block|}
block|}
comment|/* 			 * Continue on if it's closed 			 */
if|if
condition|(
name|ccbp
operator|->
name|hi_stat
operator|==
name|IDLE_CLOSE
condition|)
block|{
continue|continue;
block|}
comment|/* 			 * Do modem state change if not a local device 			 */
name|si_modem_state
argument_list|(
name|pp
argument_list|,
name|tp
argument_list|,
name|ccbp
operator|->
name|hi_ip
argument_list|)
expr_stmt|;
comment|/* 			 * Check to see if we should 'receive' characters. 			 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CONNECTED
operator|&&
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
name|isopen
operator|=
literal|1
expr_stmt|;
else|else
name|isopen
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Do input break processing 			 */
if|if
condition|(
name|ccbp
operator|->
name|hi_state
operator|&
name|ST_BREAK
condition|)
block|{
if|if
condition|(
name|isopen
condition|)
block|{
name|ttyld_rint
argument_list|(
name|tp
argument_list|,
name|TTY_BI
argument_list|)
expr_stmt|;
block|}
name|ccbp
operator|->
name|hi_state
operator|&=
operator|~
name|ST_BREAK
expr_stmt|;
comment|/* A Bit iffy this */
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"si_intr break\n"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Do RX stuff - if not open then dump any characters. 			 * XXX: This is VERY messy and needs to be cleaned up. 			 * 			 * XXX: can we leave data in the host adapter buffer 			 * when the clists are full?  That may be dangerous 			 * if the user cannot get an interrupt signal through. 			 */
name|more_rx
label|:
comment|/* XXX Sorry. the nesting was driving me bats! :-( */
if|if
condition|(
operator|!
name|isopen
condition|)
block|{
name|ccbp
operator|->
name|hi_rxopos
operator|=
name|ccbp
operator|->
name|hi_rxipos
expr_stmt|;
goto|goto
name|end_rx
goto|;
block|}
comment|/* 			 * If the tty input buffers are blocked, stop emptying 			 * the incoming buffers and let the auto flow control 			 * assert.. 			 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
condition|)
block|{
goto|goto
name|end_rx
goto|;
block|}
comment|/* 			 * Process read characters if not skipped above 			 */
name|op
operator|=
name|ccbp
operator|->
name|hi_rxopos
expr_stmt|;
name|ip
operator|=
name|ccbp
operator|->
name|hi_rxipos
expr_stmt|;
name|c
operator|=
name|ip
operator|-
name|op
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
goto|goto
name|end_rx
goto|;
block|}
name|n
operator|=
name|c
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|250
condition|)
name|n
operator|=
literal|250
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"n = %d, op = %d, ip = %d\n"
operator|,
name|n
operator|,
name|op
operator|,
name|ip
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Suck characters out of host card buffer into the 			 * "input staging buffer" - so that we dont leave the 			 * host card in limbo while we're possibly echoing 			 * characters and possibly flushing input inside the 			 * ldisc l_rint() routine. 			 */
if|if
condition|(
name|n
operator|<=
name|SI_BUFFERSIZE
operator|-
name|op
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"\tsingle copy\n"
operator|)
argument_list|)
expr_stmt|;
name|z
operator|=
name|ccbp
operator|->
name|hi_rxbuf
operator|+
name|op
expr_stmt|;
name|si_vbcopy
argument_list|(
name|z
argument_list|,
name|si_rxbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|op
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|SI_BUFFERSIZE
operator|-
name|op
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"\tdouble part 1 %d\n"
operator|,
name|x
operator|)
argument_list|)
expr_stmt|;
name|z
operator|=
name|ccbp
operator|->
name|hi_rxbuf
operator|+
name|op
expr_stmt|;
name|si_vbcopy
argument_list|(
name|z
argument_list|,
name|si_rxbuf
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"\tdouble part 2 %d\n"
operator|,
name|n
operator|-
name|x
operator|)
argument_list|)
expr_stmt|;
name|z
operator|=
name|ccbp
operator|->
name|hi_rxbuf
expr_stmt|;
name|si_vbcopy
argument_list|(
name|z
argument_list|,
name|si_rxbuf
operator|+
name|x
argument_list|,
name|n
operator|-
name|x
argument_list|)
expr_stmt|;
name|op
operator|+=
name|n
expr_stmt|;
block|}
comment|/* clear collected characters from buffer */
name|ccbp
operator|->
name|hi_rxopos
operator|=
name|op
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"n = %d, op = %d, ip = %d\n"
operator|,
name|n
operator|,
name|op
operator|,
name|ip
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * at this point... 			 * n = number of chars placed in si_rxbuf 			 */
comment|/* 			 * Avoid the grotesquely inefficient lineswitch 			 * routine (ttyinput) in "raw" mode. It usually 			 * takes about 450 instructions (that's without 			 * canonical processing or echo!). slinput is 			 * reasonably fast (usually 40 instructions 			 * plus call overhead). 			 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
condition|)
block|{
comment|/* block if the driver supports it */
if|if
condition|(
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|n
operator|>=
name|SI_I_HIGH_WATER
operator|&&
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CRTS_IFLOW
operator|||
name|tp
operator|->
name|t_iflag
operator|&
name|IXOFF
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
condition|)
name|ttyblock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tk_nin
operator|+=
name|n
expr_stmt|;
name|tk_rawcc
operator|+=
name|n
expr_stmt|;
name|tp
operator|->
name|t_rawcc
operator|+=
name|n
expr_stmt|;
name|pp
operator|->
name|sp_delta_overflows
operator|+=
name|b_to_q
argument_list|(
operator|(
name|char
operator|*
operator|)
name|si_rxbuf
argument_list|,
name|n
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|&&
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|IXANY
operator|||
name|tp
operator|->
name|t_cc
index|[
name|VSTART
index|]
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VSTOP
index|]
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_TTSTOP
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|&=
operator|~
name|FLUSHO
expr_stmt|;
name|si_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * It'd be nice to not have to go through the 				 * function call overhead for each char here. 				 * It'd be nice to block input it, saving a 				 * loop here and the call/return overhead. 				 */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|n
condition|;
name|x
operator|++
control|)
block|{
name|i
operator|=
name|si_rxbuf
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|ttyld_rint
argument_list|(
name|tp
argument_list|,
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pp
operator|->
name|sp_delta_overflows
operator|++
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|more_rx
goto|;
comment|/* try for more until RXbuf is empty */
name|end_rx
label|:
comment|/* XXX: Again, sorry about the gotos.. :-) */
comment|/* 			 * Do TX stuff 			 */
name|ttyld_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/* end of for (all ports on this controller) */
block|}
comment|/* end of for (all controllers) */
name|in_intr
operator|=
literal|0
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|arg
operator|==
name|NULL
condition|?
name|DBG_POLL
else|:
name|DBG_INTR
operator|,
literal|"end si_intr\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Nudge the transmitter...  *  * XXX: I inherited some funny code here.  It implies the host card only  * interrupts when the transmit buffer reaches the low-water-mark, and does  * not interrupt when it's actually hits empty.  In some cases, we have  * processes waiting for complete drain, and we need to simulate an interrupt  * about when we think the buffer is going to be empty (and retry if not).  * I really am not certain about this...  I *need* the hardware manuals.  */
end_comment

begin_function
specifier|static
name|void
name|si_start
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
decl_stmt|;
name|struct
name|clist
modifier|*
name|qp
decl_stmt|;
name|BYTE
name|ipos
decl_stmt|;
name|int
name|nchar
decl_stmt|;
name|int
name|oldspl
decl_stmt|,
name|count
decl_stmt|,
name|n
decl_stmt|,
name|amount
decl_stmt|,
name|buffer_full
decl_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|qp
operator|=
operator|&
name|tp
operator|->
name|t_outq
expr_stmt|;
name|pp
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_START
operator|,
literal|"si_start(%x) t_state %x sp_state %x t_outq.c_cc %d\n"
operator|,
name|tp
operator|,
name|tp
operator|->
name|t_state
operator|,
name|pp
operator|->
name|sp_state
operator|,
name|qp
operator|->
name|c_cc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
name|buffer_full
operator|=
literal|0
expr_stmt|;
name|ccbp
operator|=
name|pp
operator|->
name|sp_ccb
expr_stmt|;
name|count
operator|=
operator|(
name|int
operator|)
name|ccbp
operator|->
name|hi_txipos
operator|-
operator|(
name|int
operator|)
name|ccbp
operator|->
name|hi_txopos
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_START
operator|,
literal|"count %d\n"
operator|,
operator|(
name|BYTE
operator|)
name|count
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nchar
operator|=
name|qp
operator|->
name|c_cc
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|BYTE
operator|)
name|count
operator|>=
literal|255
condition|)
block|{
name|buffer_full
operator|++
expr_stmt|;
break|break;
block|}
name|amount
operator|=
name|min
argument_list|(
name|nchar
argument_list|,
operator|(
literal|255
operator|-
operator|(
name|BYTE
operator|)
name|count
operator|)
argument_list|)
expr_stmt|;
name|ipos
operator|=
operator|(
name|unsigned
name|int
operator|)
name|ccbp
operator|->
name|hi_txipos
expr_stmt|;
name|n
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|si_txbuf
argument_list|,
name|amount
argument_list|)
expr_stmt|;
comment|/* will it fit in one lump? */
if|if
condition|(
operator|(
name|SI_BUFFERSIZE
operator|-
name|ipos
operator|)
operator|>=
name|n
condition|)
block|{
name|si_bcopyv
argument_list|(
name|si_txbuf
argument_list|,
operator|&
name|ccbp
operator|->
name|hi_txbuf
index|[
name|ipos
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|si_bcopyv
argument_list|(
name|si_txbuf
argument_list|,
operator|&
name|ccbp
operator|->
name|hi_txbuf
index|[
name|ipos
index|]
argument_list|,
name|SI_BUFFERSIZE
operator|-
name|ipos
argument_list|)
expr_stmt|;
name|si_bcopyv
argument_list|(
name|si_txbuf
operator|+
operator|(
name|SI_BUFFERSIZE
operator|-
name|ipos
operator|)
argument_list|,
operator|&
name|ccbp
operator|->
name|hi_txbuf
index|[
literal|0
index|]
argument_list|,
name|n
operator|-
operator|(
name|SI_BUFFERSIZE
operator|-
name|ipos
operator|)
argument_list|)
expr_stmt|;
block|}
name|ccbp
operator|->
name|hi_txipos
operator|+=
name|n
expr_stmt|;
name|count
operator|=
operator|(
name|int
operator|)
name|ccbp
operator|->
name|hi_txipos
operator|-
operator|(
name|int
operator|)
name|ccbp
operator|->
name|hi_txopos
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
name|nchar
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
block|}
comment|/* wakeup time? */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_START
operator|,
literal|"count %d, nchar %d, tp->t_state 0x%x\n"
operator|,
operator|(
name|BYTE
operator|)
name|count
operator|,
name|nchar
operator|,
name|tp
operator|->
name|t_state
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
name|int
name|time
decl_stmt|;
name|time
operator|=
name|ttspeedtab
argument_list|(
name|tp
operator|->
name|t_ospeed
argument_list|,
name|chartimes
argument_list|)
expr_stmt|;
if|if
condition|(
name|time
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|time
operator|<
name|nchar
condition|)
name|time
operator|=
name|nchar
operator|/
name|time
expr_stmt|;
else|else
name|time
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_START
operator|,
literal|"bad char time value! %d\n"
operator|,
name|time
operator|)
argument_list|)
expr_stmt|;
name|time
operator|=
name|hz
operator|/
literal|10
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pp
operator|->
name|sp_state
operator|&
operator|(
name|SS_LSTART
operator||
name|SS_INLSTART
operator|)
operator|)
operator|==
name|SS_LSTART
condition|)
block|{
name|untimeout
argument_list|(
name|si_lstart
argument_list|,
operator|(
name|caddr_t
operator|)
name|pp
argument_list|,
name|pp
operator|->
name|lstart_ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|sp_state
operator||=
name|SS_LSTART
expr_stmt|;
block|}
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_START
operator|,
literal|"arming lstart, time=%d\n"
operator|,
name|time
operator|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lstart_ch
operator|=
name|timeout
argument_list|(
name|si_lstart
argument_list|,
operator|(
name|caddr_t
operator|)
name|pp
argument_list|,
name|time
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_EXIT
operator||
name|DBG_START
operator|,
literal|"leave si_start()\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note: called at splsoftclock from the timeout code  * This has to deal with two things...  cause wakeups while waiting for  * tty drains on last process exit, and call l_start at about the right  * time for protocols like ppp.  */
end_comment

begin_function
specifier|static
name|void
name|si_lstart
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|si_port
modifier|*
name|pp
init|=
name|arg
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|oldspl
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_LSTART
operator|,
literal|"si_lstart(%x) sp_state %x\n"
operator|,
name|pp
operator|,
name|pp
operator|->
name|sp_state
operator|)
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|tp
operator|=
name|pp
operator|->
name|sp_tty
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
operator|||
operator|(
name|pp
operator|->
name|sp_state
operator|&
name|SS_LSTART
operator|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SS_LSTART
expr_stmt|;
name|pp
operator|->
name|sp_state
operator||=
name|SS_INLSTART
expr_stmt|;
comment|/* deal with the process exit case */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* nudge protocols - eg: ppp */
name|ttyld_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SS_INLSTART
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop output on a line. called at spltty();  */
end_comment

begin_function
specifier|static
name|void
name|si_stop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
decl_stmt|;
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|ccbp
operator|=
name|pp
operator|->
name|sp_ccb
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_STOP
operator|,
literal|"si_stop(%x,%x)\n"
operator|,
name|tp
operator|,
name|rw
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX: must check (rw& FWRITE | FREAD) etc flushing... */
if|if
condition|(
name|rw
operator|&
name|FWRITE
condition|)
block|{
comment|/* what level are we meant to be flushing anyway? */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
name|si_command
argument_list|(
name|pp
argument_list|,
name|WFLUSH
argument_list|,
name|SI_NOWAIT
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Bruce???? */
block|}
block|}
if|#
directive|if
literal|1
comment|/* XXX: this doesn't work right yet.. */
comment|/* XXX: this may have been failing because we used to call l_rint() 	 * while we were looping based on these two counters. Now, we collect 	 * the data and then loop stuffing it into l_rint(), making this 	 * useless.  Should we cause this to blow away the staging buffer? 	 */
if|if
condition|(
name|rw
operator|&
name|FREAD
condition|)
block|{
name|ccbp
operator|->
name|hi_rxopos
operator|=
name|ccbp
operator|->
name|hi_rxipos
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Issue a command to the host card CPU.  */
end_comment

begin_function
specifier|static
name|void
name|si_command
parameter_list|(
name|struct
name|si_port
modifier|*
name|pp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|waitflag
parameter_list|)
block|{
name|int
name|oldspl
decl_stmt|;
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
init|=
name|pp
operator|->
name|sp_ccb
decl_stmt|;
name|int
name|x
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_PARAM
operator|,
literal|"si_command(%x,%x,%d): hi_stat 0x%x\n"
operator|,
name|pp
operator|,
name|cmd
operator|,
name|waitflag
operator|,
name|ccbp
operator|->
name|hi_stat
operator|)
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* Keep others out */
comment|/* wait until it's finished what it was doing.. */
comment|/* XXX: sits in IDLE_BREAK until something disturbs it or break 	 * is turned off. */
while|while
condition|(
operator|(
name|x
operator|=
name|ccbp
operator|->
name|hi_stat
operator|)
operator|!=
name|IDLE_OPEN
operator|&&
name|x
operator|!=
name|IDLE_CLOSE
operator|&&
name|x
operator|!=
name|IDLE_BREAK
operator|&&
name|x
operator|!=
name|cmd
condition|)
block|{
if|if
condition|(
name|in_intr
condition|)
block|{
comment|/* Prevent sleep in intr */
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_PARAM
operator|,
literal|"cmd intr collision - completing %d\trequested %d\n"
operator|,
name|x
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|ttysleep
argument_list|(
name|pp
operator|->
name|sp_tty
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|pp
operator|->
name|sp_state
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"sicmd1"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* it should now be in IDLE_{OPEN|CLOSE|BREAK}, or "cmd" */
comment|/* if there was a pending command, cause a state-change wakeup */
switch|switch
condition|(
name|pp
operator|->
name|sp_pend
condition|)
block|{
case|case
name|LOPEN
case|:
case|case
name|MPEND
case|:
case|case
name|MOPEN
case|:
case|case
name|CONFIG
case|:
case|case
name|SBREAK
case|:
case|case
name|EBREAK
case|:
name|wakeup
argument_list|(
operator|&
name|pp
operator|->
name|sp_state
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|pp
operator|->
name|sp_pend
operator|=
name|cmd
expr_stmt|;
comment|/* New command pending */
name|ccbp
operator|->
name|hi_stat
operator|=
name|cmd
expr_stmt|;
comment|/* Post it */
if|if
condition|(
name|waitflag
condition|)
block|{
if|if
condition|(
name|in_intr
condition|)
block|{
comment|/* If in interrupt handler */
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_PARAM
operator|,
literal|"attempt to sleep in si_intr - cmd req %d\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
while|while
condition|(
name|ccbp
operator|->
name|hi_stat
operator|!=
name|IDLE_OPEN
operator|&&
name|ccbp
operator|->
name|hi_stat
operator|!=
name|IDLE_BREAK
condition|)
block|{
if|if
condition|(
name|ttysleep
argument_list|(
name|pp
operator|->
name|sp_tty
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|pp
operator|->
name|sp_state
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"sicmd2"
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
block|}
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SI_DEBUG
end_ifdef

begin_function
name|void
name|si_dprintf
parameter_list|(
name|struct
name|si_port
modifier|*
name|pp
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|(
name|pp
operator|==
name|NULL
operator|&&
operator|(
name|si_debug
operator|&
name|flags
operator|)
operator|)
operator|||
operator|(
name|pp
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|pp
operator|->
name|sp_debug
operator|&
name|flags
operator|)
operator|||
operator|(
name|si_debug
operator|&
name|flags
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|pp
operator|->
name|sp_name
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|si_modulename
parameter_list|(
name|int
name|host_type
parameter_list|,
name|int
name|uart_type
parameter_list|)
block|{
switch|switch
condition|(
name|host_type
condition|)
block|{
comment|/* Z280 based cards */
ifdef|#
directive|ifdef
name|DEV_EISA
case|case
name|SIEISA
case|:
endif|#
directive|endif
case|case
name|SIHOST2
case|:
case|case
name|SIHOST
case|:
case|case
name|SIPCI
case|:
switch|switch
condition|(
name|uart_type
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
literal|" (XIO)"
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
literal|" (SI)"
operator|)
return|;
block|}
break|break;
comment|/* T225 based hosts */
case|case
name|SIJETPCI
case|:
case|case
name|SIJETISA
case|:
switch|switch
condition|(
name|uart_type
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
literal|" (SI)"
operator|)
return|;
case|case
literal|40
case|:
return|return
operator|(
literal|" (XIO)"
operator|)
return|;
case|case
literal|72
case|:
return|return
operator|(
literal|" (SXDC)"
operator|)
return|;
block|}
break|break;
block|}
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

end_unit

