begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998, 1999 Nicolas Souchu  * Copyright (c) 2001 Alcove - Nicolas Souchu  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Iomega ZIP+ Matchmaker Parallel Port Interface driver  *  * Thanks to David Campbell work on the Linux driver and the Iomega specs  * Thanks to Thiebault Moeglin for the drive  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|"opt_vpo.h"
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppbio.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppbconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppb_msq.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/vpoio.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppb_1284.h>
end_include

begin_include
include|#
directive|include
file|"ppbus_if.h"
end_include

begin_define
define|#
directive|define
name|VP0_SELTMO
value|5000
end_define

begin_comment
comment|/* select timeout */
end_comment

begin_define
define|#
directive|define
name|VP0_FAST_SPINTMO
value|500000
end_define

begin_comment
comment|/* wait status timeout */
end_comment

begin_define
define|#
directive|define
name|VP0_LOW_SPINTMO
value|5000000
end_define

begin_comment
comment|/* wait status timeout */
end_comment

begin_define
define|#
directive|define
name|VP0_SECTOR_SIZE
value|512
end_define

begin_comment
comment|/*  * Microcode to execute very fast I/O sequences at the lowest bus level.  */
end_comment

begin_define
define|#
directive|define
name|WAIT_RET
value|MS_PARAM(7, 2, MS_TYP_PTR)
end_define

begin_define
define|#
directive|define
name|WAIT_TMO
value|MS_PARAM(1, 0, MS_TYP_INT)
end_define

begin_define
define|#
directive|define
name|DECLARE_WAIT_MICROSEQUENCE
define|\
value|struct ppb_microseq wait_microseq[] = {					\ 	MS_CASS(0x0c),							\ 	MS_SET(MS_UNKNOWN),						\
comment|/* loop */
value|\ 	MS_BRSET(nBUSY, 4
comment|/* ready */
value|),					\ 	MS_DBRA(-2
comment|/* loop */
value|),						\ 	MS_CASS(0x04),							\ 	MS_RET(1),
comment|/* timed out */
value|\
comment|/* ready */
value|\ 	MS_CASS(0x04),							\ 	MS_RFETCH(MS_REG_STR, 0xb8, MS_UNKNOWN ),			\ 	MS_RET(0)
comment|/* no error */
value|\ }
end_define

begin_define
define|#
directive|define
name|SELECT_TARGET
value|MS_PARAM(6, 1, MS_TYP_CHA)
end_define

begin_define
define|#
directive|define
name|DECLARE_SELECT_MICROSEQUENCE
define|\
value|struct ppb_microseq select_microseq[] = {				\ 	MS_CASS(0xc),							\
comment|/* first, check there is nothing holding onto the bus */
value|\ 	MS_SET(VP0_SELTMO),						\
comment|/* _loop: */
value|\ 	MS_BRCLEAR(0x8, 2
comment|/* _ready */
value|),				\ 	MS_DBRA(-2
comment|/* _loop */
value|),					\ 	MS_RET(2),
comment|/* bus busy */
value|\
comment|/* _ready: */
value|\ 	MS_CASS(0x4),							\ 	MS_DASS(MS_UNKNOWN
comment|/* 0x80 | 1<< target */
value|),			\ 	MS_DELAY(1),							\ 	MS_CASS(0xc),							\ 	MS_CASS(0xd),							\
comment|/* now, wait until the drive is ready */
value|\ 	MS_SET(VP0_SELTMO),						\
comment|/* loop: */
value|\ 	MS_BRSET(0x8, 3
comment|/* ready */
value|),					\ 	MS_DBRA(-2
comment|/* loop */
value|),						\
comment|/* error: */
value|\ 	MS_CASS(0xc),							\ 	MS_RET(VP0_ESELECT_TIMEOUT),					\
comment|/* ready: */
value|\ 	MS_CASS(0xc),							\ 	MS_RET(0)							\ }
end_define

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|transfer_epilog
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
literal|0x4
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0xc
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0xe
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x4
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CPP_S1
value|MS_PARAM(10, 2, MS_TYP_PTR)
end_define

begin_define
define|#
directive|define
name|CPP_S2
value|MS_PARAM(13, 2, MS_TYP_PTR)
end_define

begin_define
define|#
directive|define
name|CPP_S3
value|MS_PARAM(16, 2, MS_TYP_PTR)
end_define

begin_define
define|#
directive|define
name|CPP_PARAM
value|MS_PARAM(17, 1, MS_TYP_CHA)
end_define

begin_define
define|#
directive|define
name|DECLARE_CPP_MICROSEQ
define|\
value|struct ppb_microseq cpp_microseq[] = {					\ 	MS_CASS(0x0c), MS_DELAY(2),					\ 	MS_DASS(0xaa), MS_DELAY(10),					\ 	MS_DASS(0x55), MS_DELAY(10),					\ 	MS_DASS(0x00), MS_DELAY(10),					\ 	MS_DASS(0xff), MS_DELAY(10),					\ 	MS_RFETCH(MS_REG_STR, 0xb8, MS_UNKNOWN
comment|/*&s1 */
value|),		\ 	MS_DASS(0x87), MS_DELAY(10),					\ 	MS_RFETCH(MS_REG_STR, 0xb8, MS_UNKNOWN
comment|/*&s2 */
value|),		\ 	MS_DASS(0x78), MS_DELAY(10),					\ 	MS_RFETCH(MS_REG_STR, 0x38, MS_UNKNOWN
comment|/*&s3 */
value|),		\ 	MS_DASS(MS_UNKNOWN
comment|/* param */
value|),				\ 	MS_DELAY(2),							\ 	MS_CASS(0x0c), MS_DELAY(10),					\ 	MS_CASS(0x0d), MS_DELAY(2),					\ 	MS_CASS(0x0c), MS_DELAY(10),					\ 	MS_DASS(0xff), MS_DELAY(10),					\ 	MS_RET(0)							\ }
end_define

begin_define
define|#
directive|define
name|NEGOCIATED_MODE
value|MS_PARAM(2, 1, MS_TYP_CHA)
end_define

begin_define
define|#
directive|define
name|DECLARE_NEGOCIATE_MICROSEQ
define|\
value|struct ppb_microseq negociate_microseq[] = {				\ 	MS_CASS(0x4),							\ 	MS_DELAY(5),							\ 	MS_DASS(MS_UNKNOWN
comment|/* mode */
value|),					\ 	MS_DELAY(100),							\ 	MS_CASS(0x6),							\ 	MS_DELAY(5),							\ 	MS_BRSET(0x20, 5
comment|/* continue */
value|),				\ 	MS_DELAY(5),							\ 	MS_CASS(0x7),							\ 	MS_DELAY(5),							\ 	MS_CASS(0x6),							\ 	MS_RET(VP0_ENEGOCIATE),						\
comment|/* continue: */
value|\ 	MS_DELAY(5),							\ 	MS_CASS(0x7),							\ 	MS_DELAY(5),							\ 	MS_CASS(0x6),							\ 	MS_RET(0)							\ }
end_define

begin_define
define|#
directive|define
name|INB_NIBBLE_L
value|MS_PARAM(3, 2, MS_TYP_PTR)
end_define

begin_define
define|#
directive|define
name|INB_NIBBLE_H
value|MS_PARAM(6, 2, MS_TYP_PTR)
end_define

begin_define
define|#
directive|define
name|INB_NIBBLE_F
value|MS_PARAM(9, 0, MS_TYP_FUN)
end_define

begin_define
define|#
directive|define
name|INB_NIBBLE_P
value|MS_PARAM(9, 1, MS_TYP_PTR)
end_define

begin_comment
comment|/*  * This is the sub-microseqence for MS_GET in NIBBLE mode  * Retrieve the two nibbles and call the C function to generate the character  * and store it in the buffer (see nibble_inbyte_hook())  */
end_comment

begin_define
define|#
directive|define
name|DECLARE_NIBBLE_INBYTE_SUBMICROSEQ
define|\
value|struct ppb_microseq nibble_inbyte_submicroseq[] = {			\ 	MS_CASS(0x4),							\
comment|/* loop: */
value|\ 	MS_CASS(0x6),							\ 	MS_DELAY(1),							\ 	MS_RFETCH(MS_REG_STR, MS_FETCH_ALL, MS_UNKNOWN
comment|/* low nibble */
value|),\ 	MS_CASS(0x5),							\ 	MS_DELAY(1),							\ 	MS_RFETCH(MS_REG_STR, MS_FETCH_ALL, MS_UNKNOWN
comment|/* high nibble */
value|),\ 	MS_CASS(0x4),							\ 	MS_DELAY(1),							\
comment|/* do a C call to format the received nibbles */
value|\ 	MS_C_CALL(MS_UNKNOWN
comment|/* C hook */
value|, MS_UNKNOWN
comment|/* param */
value|),	\ 	MS_DBRA(-7
comment|/* loop */
value|),						\ 	MS_RET(0)							\ }
end_define

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|reset_microseq
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
literal|0x04
argument_list|)
block|,
name|MS_DASS
argument_list|(
literal|0x40
argument_list|)
block|,
name|MS_DELAY
argument_list|(
literal|1
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x0c
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x0d
argument_list|)
block|,
name|MS_DELAY
argument_list|(
literal|50
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x0c
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x04
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * nibble_inbyte_hook()  *  * Formats high and low nibble into a character  */
end_comment

begin_function
specifier|static
name|int
name|nibble_inbyte_hook
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|vpo_nibble
modifier|*
name|s
init|=
operator|(
expr|struct
name|vpo_nibble
operator|*
operator|)
name|p
decl_stmt|;
comment|/* increment the buffer pointer */
operator|*
name|ptr
operator|=
operator|(
operator|(
name|s
operator|->
name|l
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
operator|)
operator|+
operator|(
name|s
operator|->
name|h
operator|&
literal|0xf0
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the sub-microseqence for MS_GET in PS2 mode  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|ps2_inbyte_submicroseq
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
literal|0x4
argument_list|)
block|,
comment|/* loop: */
name|MS_CASS
argument_list|(
name|PCD
operator||
literal|0x6
argument_list|)
block|,
name|MS_RFETCH_P
argument_list|(
literal|1
argument_list|,
name|MS_REG_DTR
argument_list|,
name|MS_FETCH_ALL
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|PCD
operator||
literal|0x5
argument_list|)
block|,
name|MS_DBRA
argument_list|(
operator|-
literal|4
comment|/* loop */
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the sub-microsequence for MS_PUT in both NIBBLE and PS2 modes  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|spp_outbyte_submicroseq
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
literal|0x4
argument_list|)
block|,
comment|/* loop: */
name|MS_RASSERT_P
argument_list|(
literal|1
argument_list|,
name|MS_REG_DTR
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x5
argument_list|)
block|,
name|MS_DBRA
argument_list|(
literal|0
argument_list|)
block|,
comment|/* decrement counter */
name|MS_RASSERT_P
argument_list|(
literal|1
argument_list|,
name|MS_REG_DTR
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x0
argument_list|)
block|,
name|MS_DBRA
argument_list|(
operator|-
literal|6
comment|/* loop */
argument_list|)
block|,
comment|/* return from the put call */
name|MS_CASS
argument_list|(
literal|0x4
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EPP 1.7 microsequences, ptr and len set at runtime */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|epp17_outstr
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
literal|0x4
argument_list|)
block|,
name|MS_RASSERT_P
argument_list|(
name|MS_ACCUM
argument_list|,
name|MS_REG_EPP_D
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0xc
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|epp17_instr
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
name|PCD
operator||
literal|0x4
argument_list|)
block|,
name|MS_RFETCH_P
argument_list|(
name|MS_ACCUM
argument_list|,
name|MS_REG_EPP_D
argument_list|,
name|MS_FETCH_ALL
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|PCD
operator||
literal|0xc
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|imm_disconnect
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|int
modifier|*
name|connected
parameter_list|,
name|int
name|release_bus
parameter_list|)
block|{
name|DECLARE_CPP_MICROSEQ
expr_stmt|;
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|char
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* all should be ok */
if|if
condition|(
name|connected
condition|)
operator|*
name|connected
operator|=
literal|0
expr_stmt|;
name|ppb_MS_init_msq
argument_list|(
name|cpp_microseq
argument_list|,
literal|4
argument_list|,
name|CPP_S1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s1
argument_list|,
name|CPP_S2
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s2
argument_list|,
name|CPP_S3
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s3
argument_list|,
name|CPP_PARAM
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|cpp_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s1
operator|!=
operator|(
name|char
operator|)
literal|0xb8
operator|||
name|s2
operator|!=
operator|(
name|char
operator|)
literal|0x18
operator|||
name|s3
operator|!=
operator|(
name|char
operator|)
literal|0x38
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"imm%d: (disconnect) s1=0x%x s2=0x%x, s3=0x%x\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|,
name|s1
operator|&
literal|0xff
argument_list|,
name|s2
operator|&
literal|0xff
argument_list|,
name|s3
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|connected
condition|)
operator|*
name|connected
operator|=
name|VP0_ECONNECT
expr_stmt|;
block|}
if|if
condition|(
name|release_bus
condition|)
return|return
operator|(
name|ppb_release_bus
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * how	: PPB_WAIT or PPB_DONTWAIT  */
end_comment

begin_function
specifier|static
name|int
name|imm_connect
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|int
name|how
parameter_list|,
name|int
modifier|*
name|disconnected
parameter_list|,
name|int
name|request_bus
parameter_list|)
block|{
name|DECLARE_CPP_MICROSEQ
expr_stmt|;
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|char
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* all should be ok */
if|if
condition|(
name|disconnected
condition|)
operator|*
name|disconnected
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|request_bus
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|ppb_request_bus
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|how
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ppb_MS_init_msq
argument_list|(
name|cpp_microseq
argument_list|,
literal|3
argument_list|,
name|CPP_S1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s1
argument_list|,
name|CPP_S2
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s2
argument_list|,
name|CPP_S3
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s3
argument_list|)
expr_stmt|;
comment|/* select device 0 in compatible mode */
name|ppb_MS_init_msq
argument_list|(
name|cpp_microseq
argument_list|,
literal|1
argument_list|,
name|CPP_PARAM
argument_list|,
literal|0xe0
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|cpp_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
comment|/* disconnect all devices */
name|ppb_MS_init_msq
argument_list|(
name|cpp_microseq
argument_list|,
literal|1
argument_list|,
name|CPP_PARAM
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|cpp_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|PPB_IN_EPP_MODE
argument_list|(
name|ppbus
argument_list|)
condition|)
name|ppb_MS_init_msq
argument_list|(
name|cpp_microseq
argument_list|,
literal|1
argument_list|,
name|CPP_PARAM
argument_list|,
literal|0x28
argument_list|)
expr_stmt|;
else|else
name|ppb_MS_init_msq
argument_list|(
name|cpp_microseq
argument_list|,
literal|1
argument_list|,
name|CPP_PARAM
argument_list|,
literal|0xe0
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|cpp_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s1
operator|!=
operator|(
name|char
operator|)
literal|0xb8
operator|||
name|s2
operator|!=
operator|(
name|char
operator|)
literal|0x18
operator|||
name|s3
operator|!=
operator|(
name|char
operator|)
literal|0x30
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"imm%d: (connect) s1=0x%x s2=0x%x, s3=0x%x\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|,
name|s1
operator|&
literal|0xff
argument_list|,
name|s2
operator|&
literal|0xff
argument_list|,
name|s3
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|disconnected
condition|)
operator|*
name|disconnected
operator|=
name|VP0_ECONNECT
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_detect()  *  * Detect and initialise the VP0 adapter.  */
end_comment

begin_function
specifier|static
name|int
name|imm_detect
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ppb_request_bus
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PPB_DONTWAIT
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* disconnect the drive, keep the bus */
name|imm_disconnect
argument_list|(
name|vpo
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vpo
operator|->
name|vpo_mode_found
operator|=
name|VP0_MODE_UNDEFINED
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
comment|/* try to enter EPP mode since vpoio failure put the bus in NIBBLE */
if|if
condition|(
name|ppb_set_mode
argument_list|(
name|ppbus
argument_list|,
name|PPB_EPP
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|imm_connect
argument_list|(
name|vpo
argument_list|,
name|PPB_DONTWAIT
argument_list|,
operator|&
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* if connection failed try PS/2 then NIBBLE modes */
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|ppb_set_mode
argument_list|(
name|ppbus
argument_list|,
name|PPB_PS2
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|imm_connect
argument_list|(
name|vpo
argument_list|,
name|PPB_DONTWAIT
argument_list|,
operator|&
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|ppb_set_mode
argument_list|(
name|ppbus
argument_list|,
name|PPB_NIBBLE
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|imm_connect
argument_list|(
name|vpo
argument_list|,
name|PPB_DONTWAIT
argument_list|,
operator|&
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
name|vpo
operator|->
name|vpo_mode_found
operator|=
name|VP0_MODE_NIBBLE
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"imm%d: NIBBLE mode unavailable!\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
else|else
block|{
name|vpo
operator|->
name|vpo_mode_found
operator|=
name|VP0_MODE_PS2
expr_stmt|;
block|}
block|}
else|else
block|{
name|vpo
operator|->
name|vpo_mode_found
operator|=
name|VP0_MODE_EPP
expr_stmt|;
block|}
comment|/* send SCSI reset signal */
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|reset_microseq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* release the bus now */
name|imm_disconnect
argument_list|(
name|vpo
argument_list|,
operator|&
name|error
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ensure we are disconnected or daisy chained peripheral  	 * may cause serious problem to the disk */
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"imm%d: can't disconnect from the drive\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|ppb_release_bus
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|VP0_EINITFAILED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_outstr()  */
end_comment

begin_function
specifier|static
name|int
name|imm_outstr
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|PPB_IN_EPP_MODE
argument_list|(
name|ppbus
argument_list|)
condition|)
name|ppb_reset_epp_timeout
argument_list|(
name|ppbus
argument_list|)
expr_stmt|;
name|ppb_MS_exec
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|MS_OP_PUT
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|buffer
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|size
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|MS_UNKNOWN
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_instr()  */
end_comment

begin_function
specifier|static
name|int
name|imm_instr
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|PPB_IN_EPP_MODE
argument_list|(
name|ppbus
argument_list|)
condition|)
name|ppb_reset_epp_timeout
argument_list|(
name|ppbus
argument_list|)
expr_stmt|;
name|ppb_MS_exec
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|MS_OP_GET
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|buffer
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|size
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|MS_UNKNOWN
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|imm_select
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|int
name|initiator
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|DECLARE_SELECT_MICROSEQUENCE
expr_stmt|;
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* initialize the select microsequence */
name|ppb_MS_init_msq
argument_list|(
name|select_microseq
argument_list|,
literal|1
argument_list|,
name|SELECT_TARGET
argument_list|,
literal|1
operator|<<
name|initiator
operator||
literal|1
operator|<<
name|target
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|select_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_wait()  *  * H_SELIN must be low.  *  */
end_comment

begin_function
specifier|static
name|char
name|imm_wait
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|int
name|tmo
parameter_list|)
block|{
name|DECLARE_WAIT_MICROSEQUENCE
expr_stmt|;
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|err
decl_stmt|;
comment|/* 	 * Return some status information. 	 * Semantics :	0x88 = ZIP+ wants more data 	 *		0x98 = ZIP+ wants to send more data 	 *		0xa8 = ZIP+ wants command 	 *		0xb8 = end of transfer, ZIP+ is sending status 	 */
name|ppb_MS_init_msq
argument_list|(
name|wait_microseq
argument_list|,
literal|2
argument_list|,
name|WAIT_RET
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ret
argument_list|,
name|WAIT_TMO
argument_list|,
name|tmo
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|wait_microseq
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* command timed out */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imm_negociate
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|DECLARE_NEGOCIATE_MICROSEQ
expr_stmt|;
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|negociate_mode
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|PPB_IN_NIBBLE_MODE
argument_list|(
name|ppbus
argument_list|)
condition|)
name|negociate_mode
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|PPB_IN_PS2_MODE
argument_list|(
name|ppbus
argument_list|)
condition|)
name|negociate_mode
operator|=
literal|1
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
literal|0
comment|/* XXX use standalone code not to depend on ppb_1284 code yet */
block|ret = ppb_1284_negociate(ppbus, negociate_mode);  	if (ret) 		return (VP0_ENEGOCIATE);
endif|#
directive|endif
name|ppb_MS_init_msq
argument_list|(
name|negociate_microseq
argument_list|,
literal|1
argument_list|,
name|NEGOCIATED_MODE
argument_list|,
name|negociate_mode
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|negociate_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_probe()  *  * Low level probe of vpo device  *  */
end_comment

begin_function
name|int
name|imm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* ppbus dependent initialisation */
name|vpo
operator|->
name|vpo_dev
operator|=
name|dev
expr_stmt|;
comment|/* now, try to initialise the drive */
if|if
condition|(
operator|(
name|error
operator|=
name|imm_detect
argument_list|(
name|vpo
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_attach()  *  * Low level attachment of vpo device  *  */
end_comment

begin_function
name|int
name|imm_attach
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|DECLARE_NIBBLE_INBYTE_SUBMICROSEQ
expr_stmt|;
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Initialize microsequence code 	 */
name|vpo
operator|->
name|vpo_nibble_inbyte_msq
operator|=
operator|(
expr|struct
name|ppb_microseq
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|nibble_inbyte_submicroseq
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vpo
operator|->
name|vpo_nibble_inbyte_msq
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|nibble_inbyte_submicroseq
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vpo
operator|->
name|vpo_nibble_inbyte_msq
argument_list|,
sizeof|sizeof
argument_list|(
name|nibble_inbyte_submicroseq
argument_list|)
argument_list|)
expr_stmt|;
name|ppb_MS_init_msq
argument_list|(
name|vpo
operator|->
name|vpo_nibble_inbyte_msq
argument_list|,
literal|4
argument_list|,
name|INB_NIBBLE_H
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|vpo
operator|)
operator|->
name|vpo_nibble
operator|.
name|h
argument_list|,
name|INB_NIBBLE_L
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|vpo
operator|)
operator|->
name|vpo_nibble
operator|.
name|l
argument_list|,
name|INB_NIBBLE_F
argument_list|,
name|nibble_inbyte_hook
argument_list|,
name|INB_NIBBLE_P
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|vpo
operator|)
operator|->
name|vpo_nibble
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize mode dependent in/out microsequences 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|ppb_request_bus
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PPB_WAIT
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
comment|/* ppbus automatically restore the last mode entered during detection */
switch|switch
condition|(
name|vpo
operator|->
name|vpo_mode_found
condition|)
block|{
case|case
name|VP0_MODE_EPP
case|:
name|ppb_MS_GET_init
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|epp17_instr
argument_list|)
expr_stmt|;
name|ppb_MS_PUT_init
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|epp17_outstr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"imm%d: EPP mode\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|VP0_MODE_PS2
case|:
name|ppb_MS_GET_init
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|ps2_inbyte_submicroseq
argument_list|)
expr_stmt|;
name|ppb_MS_PUT_init
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|spp_outbyte_submicroseq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"imm%d: PS2 mode\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|VP0_MODE_NIBBLE
case|:
name|ppb_MS_GET_init
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|vpo
operator|->
name|vpo_nibble_inbyte_msq
argument_list|)
expr_stmt|;
name|ppb_MS_PUT_init
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|spp_outbyte_submicroseq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"imm%d: NIBBLE mode\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"imm: unknown mode %d"
argument_list|,
name|vpo
operator|->
name|vpo_mode_found
argument_list|)
expr_stmt|;
block|}
name|ppb_release_bus
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
name|error
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_reset_bus()  *  */
end_comment

begin_function
name|int
name|imm_reset_bus
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|disconnected
decl_stmt|;
comment|/* first, connect to the drive and request the bus */
name|imm_connect
argument_list|(
name|vpo
argument_list|,
name|PPB_WAIT
operator||
name|PPB_INTR
argument_list|,
operator|&
name|disconnected
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disconnected
condition|)
block|{
comment|/* reset the SCSI bus */
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|reset_microseq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* then disconnect */
name|imm_disconnect
argument_list|(
name|vpo
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_do_scsi()  *  * Send an SCSI command  *  */
end_comment

begin_function
name|int
name|imm_do_scsi
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|int
name|host
parameter_list|,
name|int
name|target
parameter_list|,
name|char
modifier|*
name|command
parameter_list|,
name|int
name|clen
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|blen
parameter_list|,
name|int
modifier|*
name|result
parameter_list|,
name|int
modifier|*
name|count
parameter_list|,
name|int
modifier|*
name|ret
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
specifier|register
name|char
name|r
decl_stmt|;
name|char
name|l
decl_stmt|,
name|h
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|not_connected
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|int
name|negociated
init|=
literal|0
decl_stmt|;
comment|/* 	 * enter disk state, allocate the ppbus 	 * 	 * XXX 	 * Should we allow this call to be interruptible? 	 * The only way to report the interruption is to return 	 * EIO to upper SCSI code :^( 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|imm_connect
argument_list|(
name|vpo
argument_list|,
name|PPB_WAIT
operator||
name|PPB_INTR
argument_list|,
operator|&
name|not_connected
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|not_connected
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ECONNECT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Select the drive ... 	 */
if|if
condition|(
operator|(
operator|*
name|ret
operator|=
name|imm_select
argument_list|(
name|vpo
argument_list|,
name|host
argument_list|,
name|target
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
comment|/* 	 * Send the command ... 	 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|clen
condition|;
name|k
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|imm_wait
argument_list|(
name|vpo
argument_list|,
name|VP0_FAST_SPINTMO
argument_list|)
operator|!=
operator|(
name|char
operator|)
literal|0xa8
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ECMD_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|imm_outstr
argument_list|(
name|vpo
argument_list|,
operator|&
name|command
index|[
name|k
index|]
argument_list|,
literal|2
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_EPPDATA_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|r
operator|=
name|imm_wait
argument_list|(
name|vpo
argument_list|,
name|VP0_LOW_SPINTMO
argument_list|)
operator|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ESTATUS_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|&
literal|0x30
operator|)
operator|==
literal|0x10
condition|)
block|{
if|if
condition|(
name|imm_negociate
argument_list|(
name|vpo
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ENEGOCIATE
expr_stmt|;
goto|goto
name|error
goto|;
block|}
else|else
name|negociated
operator|=
literal|1
expr_stmt|;
block|}
comment|/*  	 * Complete transfer ...  	 */
operator|*
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|r
operator|=
name|imm_wait
argument_list|(
name|vpo
argument_list|,
name|VP0_LOW_SPINTMO
argument_list|)
operator|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ESTATUS_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* stop when the ZIP+ wants to send status */
if|if
condition|(
name|r
operator|==
operator|(
name|char
operator|)
literal|0xb8
condition|)
break|break;
if|if
condition|(
operator|*
name|count
operator|>=
name|blen
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_EDATA_OVERFLOW
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* ZIP+ wants to send data? */
if|if
condition|(
name|r
operator|==
operator|(
name|char
operator|)
literal|0x88
condition|)
block|{
name|len
operator|=
operator|(
operator|(
operator|(
name|blen
operator|-
operator|*
name|count
operator|)
operator|>=
name|VP0_SECTOR_SIZE
operator|)
operator|)
condition|?
name|VP0_SECTOR_SIZE
else|:
literal|2
expr_stmt|;
name|error
operator|=
name|imm_outstr
argument_list|(
name|vpo
argument_list|,
operator|&
name|buffer
index|[
operator|*
name|count
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|PPB_IN_EPP_MODE
argument_list|(
name|ppbus
argument_list|)
condition|)
name|len
operator|=
literal|1
expr_stmt|;
else|else
name|len
operator|=
operator|(
operator|(
operator|(
name|blen
operator|-
operator|*
name|count
operator|)
operator|>=
name|VP0_SECTOR_SIZE
operator|)
operator|)
condition|?
name|VP0_SECTOR_SIZE
else|:
literal|1
expr_stmt|;
name|error
operator|=
name|imm_instr
argument_list|(
name|vpo
argument_list|,
operator|&
name|buffer
index|[
operator|*
name|count
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|ret
operator|=
name|error
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|count
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|PPB_IN_NIBBLE_MODE
argument_list|(
name|ppbus
argument_list|)
operator|||
name|PPB_IN_PS2_MODE
argument_list|(
name|ppbus
argument_list|)
operator|)
operator|&&
name|negociated
condition|)
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|transfer_epilog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Retrieve status ... 	 */
if|if
condition|(
name|imm_negociate
argument_list|(
name|vpo
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ENEGOCIATE
expr_stmt|;
goto|goto
name|error
goto|;
block|}
else|else
name|negociated
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm_instr
argument_list|(
name|vpo
argument_list|,
operator|&
name|l
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_EOTHER
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* check if the ZIP+ wants to send more status */
if|if
condition|(
name|imm_wait
argument_list|(
name|vpo
argument_list|,
name|VP0_FAST_SPINTMO
argument_list|)
operator|==
operator|(
name|char
operator|)
literal|0xb8
condition|)
if|if
condition|(
name|imm_instr
argument_list|(
name|vpo
argument_list|,
operator|&
name|h
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_EOTHER
operator|+
literal|2
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Experience showed that we should discard this */
if|if
condition|(
name|h
operator|==
operator|-
literal|1
condition|)
name|h
operator|=
literal|0
expr_stmt|;
operator|*
name|result
operator|=
operator|(
operator|(
name|int
operator|)
name|h
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|int
operator|)
name|l
operator|&
literal|0xff
operator|)
expr_stmt|;
name|error
label|:
if|if
condition|(
operator|(
name|PPB_IN_NIBBLE_MODE
argument_list|(
name|ppbus
argument_list|)
operator|||
name|PPB_IN_PS2_MODE
argument_list|(
name|ppbus
argument_list|)
operator|)
operator|&&
name|negociated
condition|)
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|transfer_epilog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* return to printer state, release the ppbus */
name|imm_disconnect
argument_list|(
name|vpo
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

