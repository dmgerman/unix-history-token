begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Nicolas Souchu  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Iomega ZIP+ Matchmaker Parallel Port Interface driver  *  * Thanks to David Campbell work on the Linux driver and the Iomega specs  * Thanks to Thiebault Moeglin for the drive  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*KERNEL */
end_comment

begin_include
include|#
directive|include
file|"opt_vpo.h"
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppbconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppb_msq.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/vpoio.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppb_1284.h>
end_include

begin_define
define|#
directive|define
name|VP0_SELTMO
value|5000
end_define

begin_comment
comment|/* select timeout */
end_comment

begin_define
define|#
directive|define
name|VP0_FAST_SPINTMO
value|500000
end_define

begin_comment
comment|/* wait status timeout */
end_comment

begin_define
define|#
directive|define
name|VP0_LOW_SPINTMO
value|5000000
end_define

begin_comment
comment|/* wait status timeout */
end_comment

begin_define
define|#
directive|define
name|VP0_SECTOR_SIZE
value|512
end_define

begin_comment
comment|/*  * Microcode to execute very fast I/O sequences at the lowest bus level.  */
end_comment

begin_define
define|#
directive|define
name|SELECT_TARGET
value|MS_PARAM(6, 1, MS_TYP_CHA)
end_define

begin_define
define|#
directive|define
name|DECLARE_SELECT_MICROSEQUENCE
define|\
value|struct ppb_microseq select_microseq[] = {				\ 	MS_CASS(0xc),							\
comment|/* first, check there is nothing holding onto the bus */
value|\ 	MS_SET(VP0_SELTMO),						\
comment|/* _loop: */
value|\ 	MS_BRCLEAR(0x8, 2
comment|/* _ready */
value|),				\ 	MS_DBRA(-2
comment|/* _loop */
value|),					\ 	MS_RET(2),
comment|/* bus busy */
value|\
comment|/* _ready: */
value|\ 	MS_CASS(0x4),							\ 	MS_DASS(MS_UNKNOWN
comment|/* 0x80 | 1<< target */
value|),			\ 	MS_DELAY(1),							\ 	MS_CASS(0xc),							\ 	MS_CASS(0xd),							\
comment|/* now, wait until the drive is ready */
value|\ 	MS_SET(VP0_SELTMO),						\
comment|/* loop: */
value|\ 	MS_BRSET(0x8, 3
comment|/* ready */
value|),					\ 	MS_DBRA(-2
comment|/* loop */
value|),						\
comment|/* error: */
value|\ 	MS_CASS(0xc),							\ 	MS_RET(VP0_ESELECT_TIMEOUT),					\
comment|/* ready: */
value|\ 	MS_CASS(0xc),							\ 	MS_RET(0)							\ }
end_define

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|transfer_epilog
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
literal|0x4
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0xc
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0xe
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x4
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CPP_S1
value|MS_PARAM(10, 2, MS_TYP_PTR)
end_define

begin_define
define|#
directive|define
name|CPP_S2
value|MS_PARAM(13, 2, MS_TYP_PTR)
end_define

begin_define
define|#
directive|define
name|CPP_S3
value|MS_PARAM(16, 2, MS_TYP_PTR)
end_define

begin_define
define|#
directive|define
name|CPP_PARAM
value|MS_PARAM(17, 1, MS_TYP_CHA)
end_define

begin_define
define|#
directive|define
name|DECLARE_CPP_MICROSEQ
define|\
value|struct ppb_microseq cpp_microseq[] = {					\ 	MS_CASS(0x0c), MS_DELAY(2),					\ 	MS_DASS(0xaa), MS_DELAY(10),					\ 	MS_DASS(0x55), MS_DELAY(10),					\ 	MS_DASS(0x00), MS_DELAY(10),					\ 	MS_DASS(0xff), MS_DELAY(10),					\ 	MS_RFETCH(MS_REG_STR, 0xb8, MS_UNKNOWN
comment|/*&s1 */
value|),		\ 	MS_DASS(0x87), MS_DELAY(10),					\ 	MS_RFETCH(MS_REG_STR, 0xb8, MS_UNKNOWN
comment|/*&s2 */
value|),		\ 	MS_DASS(0x78), MS_DELAY(10),					\ 	MS_RFETCH(MS_REG_STR, 0x38, MS_UNKNOWN
comment|/*&s3 */
value|),		\ 	MS_DASS(MS_UNKNOWN
comment|/* param */
value|),				\ 	MS_DELAY(2),							\ 	MS_CASS(0x0c), MS_DELAY(10),					\ 	MS_CASS(0x0d), MS_DELAY(2),					\ 	MS_CASS(0x0c), MS_DELAY(10),					\ 	MS_DASS(0xff), MS_DELAY(10),					\ 	MS_RET(0)							\ }
end_define

begin_define
define|#
directive|define
name|NEGOCIATED_MODE
value|MS_PARAM(2, 1, MS_TYP_CHA)
end_define

begin_define
define|#
directive|define
name|DECLARE_NEGOCIATE_MICROSEQ
define|\
value|static struct ppb_microseq negociate_microseq[] = { 			\ 	MS_CASS(0x4),							\ 	MS_DELAY(5),							\ 	MS_DASS(MS_UNKNOWN
comment|/* mode */
value|),					\ 	MS_DELAY(100),							\ 	MS_CASS(0x6),							\ 	MS_DELAY(5),							\ 	MS_BRSET(0x20, 5
comment|/* continue */
value|),				\ 	MS_DELAY(5),							\ 	MS_CASS(0x7),							\ 	MS_DELAY(5),							\ 	MS_CASS(0x6),							\ 	MS_RET(VP0_ENEGOCIATE),						\
comment|/* continue: */
value|\ 	MS_DELAY(5),							\ 	MS_CASS(0x7),							\ 	MS_DELAY(5),							\ 	MS_CASS(0x6),							\ 	MS_RET(0)							\ }
end_define

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|reset_microseq
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
literal|0x04
argument_list|)
block|,
name|MS_DASS
argument_list|(
literal|0x40
argument_list|)
block|,
name|MS_DELAY
argument_list|(
literal|1
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x0c
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x0d
argument_list|)
block|,
name|MS_DELAY
argument_list|(
literal|50
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x0c
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x04
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * nibble_inbyte_hook()  *  * Formats high and low nibble into a character  */
end_comment

begin_function
specifier|static
name|int
name|nibble_inbyte_hook
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|vpo_nibble
modifier|*
name|s
init|=
operator|(
expr|struct
name|vpo_nibble
operator|*
operator|)
name|p
decl_stmt|;
comment|/* increment the buffer pointer */
operator|*
name|ptr
operator|=
operator|(
operator|(
name|s
operator|->
name|l
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
operator|)
operator|+
operator|(
name|s
operator|->
name|h
operator|&
literal|0xf0
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Macro used to initialize each vpoio_data structure during  * low level attachment  *  * XXX should be converted to ppb_MS_init_msq()  */
end_comment

begin_define
define|#
directive|define
name|INIT_NIBBLE_INBYTE_SUBMICROSEQ
parameter_list|(
name|vpo
parameter_list|)
value|{		    	\ 	(vpo)->vpo_nibble_inbyte_msq[6].arg[2].p =		\ 			(void *)&(vpo)->vpo_nibble.h;		\ 	(vpo)->vpo_nibble_inbyte_msq[3].arg[2].p =		\ 			(void *)&(vpo)->vpo_nibble.l;		\ 	(vpo)->vpo_nibble_inbyte_msq[9].arg[0].f =		\ 			nibble_inbyte_hook;			\ 	(vpo)->vpo_nibble_inbyte_msq[9].arg[1].p =		\ 			(void *)&(vpo)->vpo_nibble;		\ }
end_define

begin_comment
comment|/*  * This is the sub-microseqence for MS_GET in NIBBLE mode  * Retrieve the two nibbles and call the C function to generate the character  * and store it in the buffer (see nibble_inbyte_hook())  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|nibble_inbyte_submicroseq
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
literal|0x4
argument_list|)
block|,
comment|/* loop: */
name|MS_CASS
argument_list|(
literal|0x6
argument_list|)
block|,
name|MS_DELAY
argument_list|(
literal|1
argument_list|)
block|,
name|MS_RFETCH
argument_list|(
name|MS_REG_STR
argument_list|,
name|MS_FETCH_ALL
argument_list|,
name|MS_UNKNOWN
comment|/* low nibble */
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x5
argument_list|)
block|,
name|MS_DELAY
argument_list|(
literal|1
argument_list|)
block|,
name|MS_RFETCH
argument_list|(
name|MS_REG_STR
argument_list|,
name|MS_FETCH_ALL
argument_list|,
name|MS_UNKNOWN
comment|/* high nibble */
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x4
argument_list|)
block|,
name|MS_DELAY
argument_list|(
literal|1
argument_list|)
block|,
comment|/* do a C call to format the received nibbles */
name|MS_C_CALL
argument_list|(
name|MS_UNKNOWN
comment|/* C hook */
argument_list|,
name|MS_UNKNOWN
comment|/* param */
argument_list|)
block|,
name|MS_DBRA
argument_list|(
operator|-
literal|7
comment|/* loop */
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the sub-microseqence for MS_GET in PS2 mode  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|ps2_inbyte_submicroseq
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
literal|0x4
argument_list|)
block|,
comment|/* loop: */
name|MS_CASS
argument_list|(
name|PCD
operator||
literal|0x6
argument_list|)
block|,
name|MS_RFETCH_P
argument_list|(
literal|1
argument_list|,
name|MS_REG_DTR
argument_list|,
name|MS_FETCH_ALL
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|PCD
operator||
literal|0x5
argument_list|)
block|,
name|MS_DBRA
argument_list|(
operator|-
literal|4
comment|/* loop */
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the sub-microsequence for MS_PUT in both NIBBLE and PS2 modes  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|spp_outbyte_submicroseq
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
literal|0x4
argument_list|)
block|,
comment|/* loop: */
name|MS_RASSERT_P
argument_list|(
literal|1
argument_list|,
name|MS_REG_DTR
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x5
argument_list|)
block|,
name|MS_DBRA
argument_list|(
literal|0
argument_list|)
block|,
comment|/* decrement counter */
name|MS_RASSERT_P
argument_list|(
literal|1
argument_list|,
name|MS_REG_DTR
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0x0
argument_list|)
block|,
name|MS_DBRA
argument_list|(
operator|-
literal|6
comment|/* loop */
argument_list|)
block|,
comment|/* return from the put call */
name|MS_CASS
argument_list|(
literal|0x4
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EPP 1.7 microsequences, ptr and len set at runtime */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|epp17_outstr
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
literal|0x4
argument_list|)
block|,
name|MS_RASSERT_P
argument_list|(
name|MS_ACCUM
argument_list|,
name|MS_REG_EPP_D
argument_list|)
block|,
name|MS_CASS
argument_list|(
literal|0xc
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|epp17_instr
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
name|PCD
operator||
literal|0x4
argument_list|)
block|,
name|MS_RFETCH_P
argument_list|(
name|MS_ACCUM
argument_list|,
name|MS_REG_EPP_D
argument_list|,
name|MS_FETCH_ALL
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|PCD
operator||
literal|0xc
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|imm_disconnect
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|int
modifier|*
name|connected
parameter_list|,
name|int
name|release_bus
parameter_list|)
block|{
name|DECLARE_CPP_MICROSEQ
expr_stmt|;
name|char
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* all should be ok */
if|if
condition|(
name|connected
condition|)
operator|*
name|connected
operator|=
literal|0
expr_stmt|;
name|ppb_MS_init_msq
argument_list|(
name|cpp_microseq
argument_list|,
literal|4
argument_list|,
name|CPP_S1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s1
argument_list|,
name|CPP_S2
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s2
argument_list|,
name|CPP_S3
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s3
argument_list|,
name|CPP_PARAM
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|cpp_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s1
operator|!=
operator|(
name|char
operator|)
literal|0xb8
operator|||
name|s2
operator|!=
operator|(
name|char
operator|)
literal|0x18
operator|||
name|s3
operator|!=
operator|(
name|char
operator|)
literal|0x38
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"imm%d: (disconnect) s1=0x%x s2=0x%x, s3=0x%x\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|,
name|s1
operator|&
literal|0xff
argument_list|,
name|s2
operator|&
literal|0xff
argument_list|,
name|s3
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|connected
condition|)
operator|*
name|connected
operator|=
name|VP0_ECONNECT
expr_stmt|;
block|}
if|if
condition|(
name|release_bus
condition|)
return|return
operator|(
name|ppb_release_bus
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * how	: PPB_WAIT or PPB_DONTWAIT  */
end_comment

begin_function
specifier|static
name|int
name|imm_connect
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|int
name|how
parameter_list|,
name|int
modifier|*
name|disconnected
parameter_list|,
name|int
name|request_bus
parameter_list|)
block|{
name|DECLARE_CPP_MICROSEQ
expr_stmt|;
name|char
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* all should be ok */
if|if
condition|(
name|disconnected
condition|)
operator|*
name|disconnected
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|request_bus
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|ppb_request_bus
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|how
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ppb_MS_init_msq
argument_list|(
name|cpp_microseq
argument_list|,
literal|3
argument_list|,
name|CPP_S1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s1
argument_list|,
name|CPP_S2
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s2
argument_list|,
name|CPP_S3
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s3
argument_list|)
expr_stmt|;
comment|/* select device 0 in compatible mode */
name|ppb_MS_init_msq
argument_list|(
name|cpp_microseq
argument_list|,
literal|1
argument_list|,
name|CPP_PARAM
argument_list|,
literal|0xe0
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|cpp_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
comment|/* disconnect all devices */
name|ppb_MS_init_msq
argument_list|(
name|cpp_microseq
argument_list|,
literal|1
argument_list|,
name|CPP_PARAM
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|cpp_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|PPB_IN_EPP_MODE
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
condition|)
name|ppb_MS_init_msq
argument_list|(
name|cpp_microseq
argument_list|,
literal|1
argument_list|,
name|CPP_PARAM
argument_list|,
literal|0x28
argument_list|)
expr_stmt|;
else|else
name|ppb_MS_init_msq
argument_list|(
name|cpp_microseq
argument_list|,
literal|1
argument_list|,
name|CPP_PARAM
argument_list|,
literal|0xe0
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|cpp_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s1
operator|!=
operator|(
name|char
operator|)
literal|0xb8
operator|||
name|s2
operator|!=
operator|(
name|char
operator|)
literal|0x18
operator|||
name|s3
operator|!=
operator|(
name|char
operator|)
literal|0x30
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"imm%d: (connect) s1=0x%x s2=0x%x, s3=0x%x\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|,
name|s1
operator|&
literal|0xff
argument_list|,
name|s2
operator|&
literal|0xff
argument_list|,
name|s3
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|disconnected
condition|)
operator|*
name|disconnected
operator|=
name|VP0_ECONNECT
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_detect()  *  * Detect and initialise the VP0 adapter.  */
end_comment

begin_function
specifier|static
name|int
name|imm_detect
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ppb_request_bus
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PPB_DONTWAIT
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* disconnect the drive, keep the bus */
name|imm_disconnect
argument_list|(
name|vpo
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* we already have the bus, just connect */
name|imm_connect
argument_list|(
name|vpo
argument_list|,
name|PPB_DONTWAIT
argument_list|,
operator|&
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"imm%d: can't connect to the drive\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* send SCSI reset signal */
name|ppb_MS_microseq
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|reset_microseq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* release the bus now */
name|imm_disconnect
argument_list|(
name|vpo
argument_list|,
operator|&
name|error
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ensure we are disconnected or daisy chained peripheral  	 * may cause serious problem to the disk */
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"imm%d: can't disconnect from the drive\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|ppb_release_bus
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|VP0_EINITFAILED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_outstr()  */
end_comment

begin_function
specifier|static
name|int
name|imm_outstr
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|PPB_IN_EPP_MODE
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
condition|)
name|ppb_reset_epp_timeout
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
name|ppb_MS_exec
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|MS_OP_PUT
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|buffer
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|size
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|MS_UNKNOWN
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_instr()  */
end_comment

begin_function
specifier|static
name|int
name|imm_instr
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|PPB_IN_EPP_MODE
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
condition|)
name|ppb_reset_epp_timeout
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
name|ppb_MS_exec
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|MS_OP_GET
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|buffer
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|size
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|MS_UNKNOWN
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|imm_select
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|int
name|initiator
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|DECLARE_SELECT_MICROSEQUENCE
expr_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* initialize the select microsequence */
name|ppb_MS_init_msq
argument_list|(
name|select_microseq
argument_list|,
literal|1
argument_list|,
name|SELECT_TARGET
argument_list|,
literal|1
operator|<<
name|initiator
operator||
literal|1
operator|<<
name|target
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|select_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_wait()  *  * H_SELIN must be low.  *  * XXX should be ported to microseq  */
end_comment

begin_function
specifier|static
name|char
name|imm_wait
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|int
name|tmo
parameter_list|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
name|r
decl_stmt|;
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
comment|/* XXX should be ported to microseq */
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|r
operator|=
name|ppb_rstr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|)
operator|&
literal|0x80
operator|)
operator|&&
operator|(
name|k
operator|++
operator|<
name|tmo
operator|)
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Return some status information. 	 * Semantics :	0x88 = ZIP+ wants more data 	 *		0x98 = ZIP+ wants to send more data 	 *		0xa8 = ZIP+ wants command 	 *		0xb8 = end of transfer, ZIP+ is sending status 	 */
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|tmo
condition|)
return|return
operator|(
name|r
operator|&
literal|0xb8
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* command timed out */
block|}
end_function

begin_function
specifier|static
name|int
name|imm_negociate
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|DECLARE_NEGOCIATE_MICROSEQ
expr_stmt|;
name|int
name|negociate_mode
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|PPB_IN_NIBBLE_MODE
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
condition|)
name|negociate_mode
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|PPB_IN_PS2_MODE
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
condition|)
name|negociate_mode
operator|=
literal|1
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
literal|0
comment|/* XXX use standalone code not to depend on ppb_1284 code yet */
block|ret = ppb_1284_negociate(&vpo->vpo_dev, negociate_mode);  	if (ret) 		return (VP0_ENEGOCIATE);
endif|#
directive|endif
name|ppb_MS_init_msq
argument_list|(
name|negociate_microseq
argument_list|,
literal|1
argument_list|,
name|NEGOCIATED_MODE
argument_list|,
name|negociate_mode
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|negociate_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_probe()  *  * Low level probe of vpo device  *  */
end_comment

begin_function
name|struct
name|ppb_device
modifier|*
name|imm_probe
parameter_list|(
name|struct
name|ppb_data
modifier|*
name|ppb
parameter_list|,
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
comment|/* ppbus dependent initialisation */
name|vpo
operator|->
name|vpo_dev
operator|.
name|id_unit
operator|=
name|vpo
operator|->
name|vpo_unit
expr_stmt|;
name|vpo
operator|->
name|vpo_dev
operator|.
name|name
operator|=
literal|"vpo"
expr_stmt|;
name|vpo
operator|->
name|vpo_dev
operator|.
name|ppb
operator|=
name|ppb
expr_stmt|;
comment|/* now, try to initialise the drive */
if|if
condition|(
name|imm_detect
argument_list|(
name|vpo
argument_list|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
operator|&
name|vpo
operator|->
name|vpo_dev
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_attach()  *  * Low level attachment of vpo device  *  */
end_comment

begin_function
name|int
name|imm_attach
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|int
name|epp
decl_stmt|;
comment|/* 	 * Report ourselves 	 */
name|printf
argument_list|(
literal|"imm%d:<Iomega Matchmaker Parallel to SCSI interface> on ppbus %d\n"
argument_list|,
name|vpo
operator|->
name|vpo_dev
operator|.
name|id_unit
argument_list|,
name|vpo
operator|->
name|vpo_dev
operator|.
name|ppb
operator|->
name|ppb_link
operator|->
name|adapter_unit
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize microsequence code 	 */
name|vpo
operator|->
name|vpo_nibble_inbyte_msq
operator|=
operator|(
expr|struct
name|ppb_microseq
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|nibble_inbyte_submicroseq
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vpo
operator|->
name|vpo_nibble_inbyte_msq
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|nibble_inbyte_submicroseq
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vpo
operator|->
name|vpo_nibble_inbyte_msq
argument_list|,
sizeof|sizeof
argument_list|(
name|nibble_inbyte_submicroseq
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_NIBBLE_INBYTE_SUBMICROSEQ
argument_list|(
name|vpo
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize mode dependent in/out microsequences 	 */
name|ppb_request_bus
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PPB_WAIT
argument_list|)
expr_stmt|;
comment|/* enter NIBBLE mode to configure submsq */
if|if
condition|(
name|ppb_set_mode
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PPB_NIBBLE
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ppb_MS_GET_init
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|vpo
operator|->
name|vpo_nibble_inbyte_msq
argument_list|)
expr_stmt|;
name|ppb_MS_PUT_init
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|spp_outbyte_submicroseq
argument_list|)
expr_stmt|;
block|}
comment|/* enter PS2 mode to configure submsq */
if|if
condition|(
name|ppb_set_mode
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PPB_PS2
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ppb_MS_GET_init
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|ps2_inbyte_submicroseq
argument_list|)
expr_stmt|;
name|ppb_MS_PUT_init
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|spp_outbyte_submicroseq
argument_list|)
expr_stmt|;
block|}
name|epp
operator|=
name|ppb_get_epp_protocol
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
comment|/* enter EPP mode to configure submsq */
if|if
condition|(
name|ppb_set_mode
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PPB_EPP
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|epp
condition|)
block|{
case|case
name|EPP_1_9
case|:
case|case
name|EPP_1_7
case|:
name|ppb_MS_GET_init
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|epp17_instr
argument_list|)
expr_stmt|;
name|ppb_MS_PUT_init
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|epp17_outstr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unknown EPP protocol (0x%x)"
argument_list|,
name|__FUNCTION__
argument_list|,
name|epp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* try to enter EPP or PS/2 mode, NIBBLE otherwise */
if|if
condition|(
name|ppb_set_mode
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PPB_EPP
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|epp
condition|)
block|{
case|case
name|EPP_1_9
case|:
name|printf
argument_list|(
literal|"imm%d: EPP 1.9 mode\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPP_1_7
case|:
name|printf
argument_list|(
literal|"imm%d: EPP 1.7 mode\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unknown EPP protocol (0x%x)"
argument_list|,
name|__FUNCTION__
argument_list|,
name|epp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ppb_set_mode
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PPB_PS2
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"imm%d: PS2 mode\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ppb_set_mode
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PPB_NIBBLE
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"imm%d: NIBBLE mode\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"imm%d: can't enter NIBBLE, PS2 or EPP mode\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
name|ppb_release_bus
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vpo
operator|->
name|vpo_nibble_inbyte_msq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ppb_release_bus
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_reset_bus()  *  */
end_comment

begin_function
name|int
name|imm_reset_bus
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|int
name|disconnected
decl_stmt|;
comment|/* first, connect to the drive and request the bus */
name|imm_connect
argument_list|(
name|vpo
argument_list|,
name|PPB_WAIT
operator||
name|PPB_INTR
argument_list|,
operator|&
name|disconnected
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disconnected
condition|)
block|{
comment|/* reset the SCSI bus */
name|ppb_MS_microseq
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|reset_microseq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* then disconnect */
name|imm_disconnect
argument_list|(
name|vpo
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * imm_do_scsi()  *  * Send an SCSI command  *  */
end_comment

begin_function
name|int
name|imm_do_scsi
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|int
name|host
parameter_list|,
name|int
name|target
parameter_list|,
name|char
modifier|*
name|command
parameter_list|,
name|int
name|clen
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|blen
parameter_list|,
name|int
modifier|*
name|result
parameter_list|,
name|int
modifier|*
name|count
parameter_list|,
name|int
modifier|*
name|ret
parameter_list|)
block|{
specifier|register
name|char
name|r
decl_stmt|;
name|char
name|l
decl_stmt|,
name|h
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|not_connected
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|int
name|negociated
init|=
literal|0
decl_stmt|;
comment|/* 	 * enter disk state, allocate the ppbus 	 * 	 * XXX 	 * Should we allow this call to be interruptible? 	 * The only way to report the interruption is to return 	 * EIO do upper SCSI code :^( 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|imm_connect
argument_list|(
name|vpo
argument_list|,
name|PPB_WAIT
operator||
name|PPB_INTR
argument_list|,
operator|&
name|not_connected
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|not_connected
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ECONNECT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Select the drive ... 	 */
if|if
condition|(
operator|(
operator|*
name|ret
operator|=
name|imm_select
argument_list|(
name|vpo
argument_list|,
name|host
argument_list|,
name|target
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
comment|/* 	 * Send the command ... 	 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|clen
condition|;
name|k
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|imm_wait
argument_list|(
name|vpo
argument_list|,
name|VP0_FAST_SPINTMO
argument_list|)
operator|!=
operator|(
name|char
operator|)
literal|0xa8
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ECMD_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|imm_outstr
argument_list|(
name|vpo
argument_list|,
operator|&
name|command
index|[
name|k
index|]
argument_list|,
literal|2
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_EPPDATA_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|r
operator|=
name|imm_wait
argument_list|(
name|vpo
argument_list|,
name|VP0_LOW_SPINTMO
argument_list|)
operator|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ESTATUS_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|r
operator|&
literal|0x30
operator|)
operator|==
literal|0x10
condition|)
block|{
if|if
condition|(
name|imm_negociate
argument_list|(
name|vpo
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ENEGOCIATE
expr_stmt|;
goto|goto
name|error
goto|;
block|}
else|else
name|negociated
operator|=
literal|1
expr_stmt|;
block|}
comment|/*  	 * Complete transfer ...  	 */
operator|*
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|r
operator|=
name|imm_wait
argument_list|(
name|vpo
argument_list|,
name|VP0_LOW_SPINTMO
argument_list|)
operator|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ESTATUS_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* stop when the ZIP+ wants to send status */
if|if
condition|(
name|r
operator|==
operator|(
name|char
operator|)
literal|0xb8
condition|)
break|break;
if|if
condition|(
operator|*
name|count
operator|>=
name|blen
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_EDATA_OVERFLOW
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* ZIP+ wants to send data? */
if|if
condition|(
name|r
operator|==
operator|(
name|char
operator|)
literal|0x88
condition|)
block|{
name|len
operator|=
operator|(
operator|(
operator|(
name|blen
operator|-
operator|*
name|count
operator|)
operator|>=
name|VP0_SECTOR_SIZE
operator|)
operator|)
condition|?
name|VP0_SECTOR_SIZE
else|:
literal|2
expr_stmt|;
name|error
operator|=
name|imm_outstr
argument_list|(
name|vpo
argument_list|,
operator|&
name|buffer
index|[
operator|*
name|count
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|PPB_IN_EPP_MODE
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
condition|)
name|len
operator|=
literal|1
expr_stmt|;
else|else
name|len
operator|=
operator|(
operator|(
operator|(
name|blen
operator|-
operator|*
name|count
operator|)
operator|>=
name|VP0_SECTOR_SIZE
operator|)
operator|)
condition|?
name|VP0_SECTOR_SIZE
else|:
literal|1
expr_stmt|;
name|error
operator|=
name|imm_instr
argument_list|(
name|vpo
argument_list|,
operator|&
name|buffer
index|[
operator|*
name|count
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|ret
operator|=
name|error
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|count
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|PPB_IN_NIBBLE_MODE
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|||
name|PPB_IN_PS2_MODE
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|)
operator|&&
name|negociated
condition|)
name|ppb_MS_microseq
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|transfer_epilog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Retrieve status ... 	 */
if|if
condition|(
name|imm_negociate
argument_list|(
name|vpo
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ENEGOCIATE
expr_stmt|;
goto|goto
name|error
goto|;
block|}
else|else
name|negociated
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm_instr
argument_list|(
name|vpo
argument_list|,
operator|&
name|l
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_EOTHER
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* check if the ZIP+ wants to send more status */
if|if
condition|(
name|imm_wait
argument_list|(
name|vpo
argument_list|,
name|VP0_FAST_SPINTMO
argument_list|)
operator|==
operator|(
name|char
operator|)
literal|0xb8
condition|)
if|if
condition|(
name|imm_instr
argument_list|(
name|vpo
argument_list|,
operator|&
name|h
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_EOTHER
operator|+
literal|2
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|result
operator|=
operator|(
operator|(
name|int
operator|)
name|h
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|int
operator|)
name|l
operator|&
literal|0xff
operator|)
expr_stmt|;
name|error
label|:
if|if
condition|(
operator|(
name|PPB_IN_NIBBLE_MODE
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|||
name|PPB_IN_PS2_MODE
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|)
operator|&&
name|negociated
condition|)
name|ppb_MS_microseq
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|transfer_epilog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* return to printer state, release the ppbus */
name|imm_disconnect
argument_list|(
name|vpo
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

