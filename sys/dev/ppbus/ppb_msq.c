begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998, 1999 Nicolas Souchu  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppbconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppb_msq.h>
end_include

begin_include
include|#
directive|include
file|"ppbus_if.h"
end_include

begin_comment
comment|/* msq index (see PPB_MAX_XFER)  * These are device modes  */
end_comment

begin_define
define|#
directive|define
name|COMPAT_MSQ
value|0x0
end_define

begin_define
define|#
directive|define
name|NIBBLE_MSQ
value|0x1
end_define

begin_define
define|#
directive|define
name|PS2_MSQ
value|0x2
end_define

begin_define
define|#
directive|define
name|EPP17_MSQ
value|0x3
end_define

begin_define
define|#
directive|define
name|EPP19_MSQ
value|0x4
end_define

begin_define
define|#
directive|define
name|ECP_MSQ
value|0x5
end_define

begin_comment
comment|/*  * Device mode to submsq conversion  */
end_comment

begin_function
specifier|static
name|struct
name|ppb_xfer
modifier|*
name|mode2xfer
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|struct
name|ppb_device
modifier|*
name|ppbdev
parameter_list|,
name|int
name|opcode
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|epp
decl_stmt|;
name|struct
name|ppb_xfer
modifier|*
name|table
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|MS_OP_GET
case|:
name|table
operator|=
name|ppbdev
operator|->
name|get_xfer
expr_stmt|;
break|break;
case|case
name|MS_OP_PUT
case|:
name|table
operator|=
name|ppbdev
operator|->
name|put_xfer
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unknown opcode (%d)"
argument_list|,
name|__func__
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
comment|/* retrieve the device operating mode */
switch|switch
condition|(
name|ppb_get_mode
argument_list|(
name|bus
argument_list|)
condition|)
block|{
case|case
name|PPB_COMPATIBLE
case|:
name|index
operator|=
name|COMPAT_MSQ
expr_stmt|;
break|break;
case|case
name|PPB_NIBBLE
case|:
name|index
operator|=
name|NIBBLE_MSQ
expr_stmt|;
break|break;
case|case
name|PPB_PS2
case|:
name|index
operator|=
name|PS2_MSQ
expr_stmt|;
break|break;
case|case
name|PPB_EPP
case|:
switch|switch
condition|(
operator|(
name|epp
operator|=
name|ppb_get_epp_protocol
argument_list|(
name|bus
argument_list|)
operator|)
condition|)
block|{
case|case
name|EPP_1_7
case|:
name|index
operator|=
name|EPP17_MSQ
expr_stmt|;
break|break;
case|case
name|EPP_1_9
case|:
name|index
operator|=
name|EPP19_MSQ
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unknown EPP protocol (0x%x)!"
argument_list|,
name|__func__
argument_list|,
name|epp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PPB_ECP
case|:
name|index
operator|=
name|ECP_MSQ
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unknown mode (%d)"
argument_list|,
name|__func__
argument_list|,
name|ppbdev
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|table
index|[
name|index
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppb_MS_init()  *  * Initialize device dependent submicrosequence of the current mode  *  */
end_comment

begin_function
name|int
name|ppb_MS_init
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|struct
name|ppb_microseq
modifier|*
name|loop
parameter_list|,
name|int
name|opcode
parameter_list|)
block|{
name|struct
name|ppb_device
modifier|*
name|ppbdev
init|=
operator|(
expr|struct
name|ppb_device
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ppb_xfer
modifier|*
name|xfer
init|=
name|mode2xfer
argument_list|(
name|bus
argument_list|,
name|ppbdev
argument_list|,
name|opcode
argument_list|)
decl_stmt|;
name|xfer
operator|->
name|loop
operator|=
name|loop
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppb_MS_exec()  *  * Execute any microsequence opcode - expensive  *  */
end_comment

begin_function
name|int
name|ppb_MS_exec
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|opcode
parameter_list|,
name|union
name|ppb_insarg
name|param1
parameter_list|,
name|union
name|ppb_insarg
name|param2
parameter_list|,
name|union
name|ppb_insarg
name|param3
parameter_list|,
name|int
modifier|*
name|ret
parameter_list|)
block|{
name|struct
name|ppb_microseq
name|msq
index|[]
init|=
block|{
block|{
name|MS_UNKNOWN
block|,
block|{
block|{
name|MS_UNKNOWN
block|}
block|,
block|{
name|MS_UNKNOWN
block|}
block|,
block|{
name|MS_UNKNOWN
block|}
block|}
block|}
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
comment|/* initialize the corresponding microseq */
name|msq
index|[
literal|0
index|]
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
name|msq
index|[
literal|0
index|]
operator|.
name|arg
index|[
literal|0
index|]
operator|=
name|param1
expr_stmt|;
name|msq
index|[
literal|0
index|]
operator|.
name|arg
index|[
literal|1
index|]
operator|=
name|param2
expr_stmt|;
name|msq
index|[
literal|0
index|]
operator|.
name|arg
index|[
literal|2
index|]
operator|=
name|param3
expr_stmt|;
comment|/* execute the microseq */
return|return
operator|(
name|ppb_MS_microseq
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|msq
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppb_MS_loop()  *  * Execute a microseq loop  *  */
end_comment

begin_function
name|int
name|ppb_MS_loop
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|struct
name|ppb_microseq
modifier|*
name|prolog
parameter_list|,
name|struct
name|ppb_microseq
modifier|*
name|body
parameter_list|,
name|struct
name|ppb_microseq
modifier|*
name|epilog
parameter_list|,
name|int
name|iter
parameter_list|,
name|int
modifier|*
name|ret
parameter_list|)
block|{
name|struct
name|ppb_microseq
name|loop_microseq
index|[]
init|=
block|{
name|MS_CALL
argument_list|(
literal|0
argument_list|)
block|,
comment|/* execute prolog */
name|MS_SET
argument_list|(
name|MS_UNKNOWN
argument_list|)
block|,
comment|/* set size of transfer */
comment|/* loop: */
name|MS_CALL
argument_list|(
literal|0
argument_list|)
block|,
comment|/* execute body */
name|MS_DBRA
argument_list|(
operator|-
literal|1
comment|/* loop: */
argument_list|)
block|,
name|MS_CALL
argument_list|(
literal|0
argument_list|)
block|,
comment|/* execute epilog */
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
comment|/* initialize the structure */
name|loop_microseq
index|[
literal|0
index|]
operator|.
name|arg
index|[
literal|0
index|]
operator|.
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|prolog
expr_stmt|;
name|loop_microseq
index|[
literal|1
index|]
operator|.
name|arg
index|[
literal|0
index|]
operator|.
name|i
operator|=
name|iter
expr_stmt|;
name|loop_microseq
index|[
literal|2
index|]
operator|.
name|arg
index|[
literal|0
index|]
operator|.
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|body
expr_stmt|;
name|loop_microseq
index|[
literal|4
index|]
operator|.
name|arg
index|[
literal|0
index|]
operator|.
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|epilog
expr_stmt|;
comment|/* execute the loop */
return|return
operator|(
name|ppb_MS_microseq
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|loop_microseq
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppb_MS_init_msq()  *  * Initialize a microsequence - see macros in ppb_msq.h  *  */
end_comment

begin_function
name|int
name|ppb_MS_init_msq
parameter_list|(
name|struct
name|ppb_microseq
modifier|*
name|msq
parameter_list|,
name|int
name|nbparam
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|param
decl_stmt|,
name|ins
decl_stmt|,
name|arg
decl_stmt|,
name|type
decl_stmt|;
name|va_list
name|p_list
decl_stmt|;
name|va_start
argument_list|(
name|p_list
argument_list|,
name|nbparam
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbparam
condition|;
name|i
operator|++
control|)
block|{
comment|/* retrieve the parameter descriptor */
name|param
operator|=
name|va_arg
argument_list|(
name|p_list
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ins
operator|=
name|MS_INS
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|arg
operator|=
name|MS_ARG
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|type
operator|=
name|MS_TYP
argument_list|(
name|param
argument_list|)
expr_stmt|;
comment|/* check the instruction position */
if|if
condition|(
name|arg
operator|>=
name|PPB_MS_MAXARGS
condition|)
name|panic
argument_list|(
literal|"%s: parameter out of range (0x%x)!"
argument_list|,
name|__func__
argument_list|,
name|param
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s: param = %d, ins = %d, arg = %d, type = %d\n",  			__func__, param, ins, arg, type);
endif|#
directive|endif
comment|/* properly cast the parameter */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MS_TYP_INT
case|:
name|msq
index|[
name|ins
index|]
operator|.
name|arg
index|[
name|arg
index|]
operator|.
name|i
operator|=
name|va_arg
argument_list|(
name|p_list
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|MS_TYP_CHA
case|:
name|msq
index|[
name|ins
index|]
operator|.
name|arg
index|[
name|arg
index|]
operator|.
name|i
operator|=
operator|(
name|int
operator|)
name|va_arg
argument_list|(
name|p_list
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|MS_TYP_PTR
case|:
name|msq
index|[
name|ins
index|]
operator|.
name|arg
index|[
name|arg
index|]
operator|.
name|p
operator|=
name|va_arg
argument_list|(
name|p_list
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|MS_TYP_FUN
case|:
name|msq
index|[
name|ins
index|]
operator|.
name|arg
index|[
name|arg
index|]
operator|.
name|f
operator|=
name|va_arg
argument_list|(
name|p_list
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unknown parameter (0x%x)!"
argument_list|,
name|__func__
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppb_MS_microseq()  *  * Interprete a microsequence. Some microinstructions are executed at adapter  * level to avoid function call overhead between ppbus and the adapter  */
end_comment

begin_function
name|int
name|ppb_MS_microseq
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|struct
name|ppb_microseq
modifier|*
name|msq
parameter_list|,
name|int
modifier|*
name|ret
parameter_list|)
block|{
name|struct
name|ppb_data
modifier|*
name|ppb
init|=
operator|(
expr|struct
name|ppb_data
operator|*
operator|)
name|device_get_softc
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|struct
name|ppb_device
modifier|*
name|ppbdev
init|=
operator|(
expr|struct
name|ppb_device
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ppb_microseq
modifier|*
name|mi
decl_stmt|;
comment|/* current microinstruction */
name|int
name|error
decl_stmt|;
name|struct
name|ppb_xfer
modifier|*
name|xfer
decl_stmt|;
comment|/* microsequence executed to initialize the transfer */
name|struct
name|ppb_microseq
name|initxfer
index|[]
init|=
block|{
name|MS_PTR
argument_list|(
name|MS_UNKNOWN
argument_list|)
block|,
comment|/* set ptr to buffer */
name|MS_SET
argument_list|(
name|MS_UNKNOWN
argument_list|)
block|,
comment|/* set transfer size */
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|ppb
operator|->
name|ppb_owner
operator|!=
name|dev
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
define|#
directive|define
name|INCR_PC
value|(mi ++)
name|mi
operator|=
name|msq
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|mi
operator|->
name|opcode
condition|)
block|{
case|case
name|MS_OP_PUT
case|:
case|case
name|MS_OP_GET
case|:
comment|/* attempt to choose the best mode for the device */
name|xfer
operator|=
name|mode2xfer
argument_list|(
name|bus
argument_list|,
name|ppbdev
argument_list|,
name|mi
operator|->
name|opcode
argument_list|)
expr_stmt|;
comment|/* figure out if we should use ieee1284 code */
if|if
condition|(
operator|!
name|xfer
operator|->
name|loop
condition|)
block|{
if|if
condition|(
name|mi
operator|->
name|opcode
operator|==
name|MS_OP_PUT
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|PPBUS_WRITE
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
name|INCR_PC
expr_stmt|;
goto|goto
name|next
goto|;
block|}
else|else
name|panic
argument_list|(
literal|"%s: IEEE1284 read not supported"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* XXX should use ppb_MS_init_msq() */
name|initxfer
index|[
literal|0
index|]
operator|.
name|arg
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|p
expr_stmt|;
name|initxfer
index|[
literal|1
index|]
operator|.
name|arg
index|[
literal|0
index|]
operator|.
name|i
operator|=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
comment|/* initialize transfer */
name|ppb_MS_microseq
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|initxfer
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
comment|/* the xfer microsequence should not contain any 			 * MS_OP_PUT or MS_OP_GET! 			 */
name|ppb_MS_microseq
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|xfer
operator|->
name|loop
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_RET
case|:
if|if
condition|(
name|ret
condition|)
operator|*
name|ret
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
expr_stmt|;
comment|/* return code */
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
comment|/* executing microinstructions at ppc level is 			 * faster. This is the default if the microinstr 			 * is unknown here 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|PPBUS_EXEC_MICROSEQ
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
operator|&
name|mi
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
break|break;
block|}
name|next
label|:
continue|continue;
block|}
name|error
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

