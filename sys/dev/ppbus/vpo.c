begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997 Nicolas Souchu  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: vpo.c,v 1.3 1997/08/28 10:15:20 msmith Exp $  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

begin_include
include|#
directive|include
file|<scsi/scsi_disk.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*KERNEL */
end_comment

begin_include
include|#
directive|include
file|<dev/ppbus/ppbconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/vpo.h>
end_include

begin_comment
comment|/* --------------------------------------------------------------------  * HERE ARE THINGS YOU MAY HAVE/WANT TO CHANGE  */
end_comment

begin_comment
comment|/*  * XXX  * We may add a timeout queue to avoid active polling on nACK.  */
end_comment

begin_define
define|#
directive|define
name|VP0_SELTMO
value|5000
end_define

begin_comment
comment|/* select timeout */
end_comment

begin_define
define|#
directive|define
name|VP0_FAST_SPINTMO
value|500000
end_define

begin_comment
comment|/* wait status timeout */
end_comment

begin_define
define|#
directive|define
name|VP0_LOW_SPINTMO
value|5000000
end_define

begin_comment
comment|/* wait status timeout */
end_comment

begin_comment
comment|/*  * DO NOT MODIFY ANYTHING UNDER THIS LINE  * --------------------------------------------------------------------  */
end_comment

begin_function_decl
specifier|static
specifier|inline
name|int
name|vpoio_do_scsi
parameter_list|(
name|struct
name|vpo_data
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|vpo_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vpominphys
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|vpo_adapter_info
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vpo_detect
parameter_list|(
name|struct
name|vpo_data
modifier|*
name|vpo
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|nvpo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXVP0
value|8
end_define

begin_comment
comment|/* XXX not much better! */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vpo_data
modifier|*
name|vpodata
index|[
name|MAXVP0
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|vpo_switch
init|=
block|{
name|vpo_scsi_cmd
block|,
name|vpominphys
block|,
literal|0
block|,
literal|0
block|,
name|vpo_adapter_info
block|,
literal|"vpo"
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * The below structure is so we have a default dev struct  * for out link struct.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|vpo_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"vpo"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Make ourselves visible as a ppbus driver  */
end_comment

begin_function_decl
specifier|static
name|struct
name|ppb_device
modifier|*
name|vpoprobe
parameter_list|(
name|struct
name|ppb_data
modifier|*
name|ppb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vpoattach
parameter_list|(
name|struct
name|ppb_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ppb_driver
name|vpodriver
init|=
block|{
name|vpoprobe
block|,
name|vpoattach
block|,
literal|"vpo"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|ppbdriver_set
argument_list|,
name|vpodriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

begin_function
specifier|static
name|u_int32_t
name|vpo_adapter_info
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * vpoprobe()  *  * Called by ppb_attachdevs().  */
end_comment

begin_function
specifier|static
name|struct
name|ppb_device
modifier|*
name|vpoprobe
parameter_list|(
name|struct
name|ppb_data
modifier|*
name|ppb
parameter_list|)
block|{
name|struct
name|vpo_data
modifier|*
name|vpo
decl_stmt|;
if|if
condition|(
name|nvpo
operator|>=
name|MAXVP0
condition|)
block|{
name|printf
argument_list|(
literal|"vpo: Too many devices (max %d)\n"
argument_list|,
name|MAXVP0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|vpo
operator|=
operator|(
expr|struct
name|vpo_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vpo_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vpo
condition|)
block|{
name|printf
argument_list|(
literal|"vpo: cannot malloc!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|vpo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vpo_data
argument_list|)
argument_list|)
expr_stmt|;
name|vpodata
index|[
name|nvpo
index|]
operator|=
name|vpo
expr_stmt|;
comment|/* vpo dependent initialisation */
name|vpo
operator|->
name|vpo_unit
operator|=
name|nvpo
expr_stmt|;
comment|/* ppbus dependent initialisation */
name|vpo
operator|->
name|vpo_dev
operator|.
name|id_unit
operator|=
name|vpo
operator|->
name|vpo_unit
expr_stmt|;
name|vpo
operator|->
name|vpo_dev
operator|.
name|ppb
operator|=
name|ppb
expr_stmt|;
comment|/* now, try to initialise the drive */
if|if
condition|(
name|vpo_detect
argument_list|(
name|vpo
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|vpo
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* ok, go to next device on next probe */
name|nvpo
operator|++
expr_stmt|;
return|return
operator|(
operator|&
name|vpo
operator|->
name|vpo_dev
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vpoattach()  *  * Called by ppb_attachdevs().  */
end_comment

begin_function
specifier|static
name|int
name|vpoattach
parameter_list|(
name|struct
name|ppb_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
name|struct
name|vpo_data
modifier|*
name|vpo
init|=
name|vpodata
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|vpo
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|vpo
operator|->
name|vpo_unit
expr_stmt|;
name|vpo
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|VP0_INITIATOR
expr_stmt|;
name|vpo
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|vpo_switch
expr_stmt|;
name|vpo
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|vpo_dev
expr_stmt|;
name|vpo
operator|->
name|sc_link
operator|.
name|opennings
operator|=
name|VP0_OPENNINGS
expr_stmt|;
comment|/* 	 * Report ourselves 	 */
name|printf
argument_list|(
literal|"vpo%d:<Adaptec aic7110 scsi> on ppbus %d\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|dev
operator|->
name|ppb
operator|->
name|ppb_link
operator|->
name|adapter_unit
argument_list|)
expr_stmt|;
comment|/* 	 * Prepare the scsibus_data area for the upperlevel 	 * scsi code. 	 */
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|vpo
operator|->
name|sc_link
expr_stmt|;
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vpominphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|VP0_BUFFER_SIZE
condition|)
name|bp
operator|->
name|b_bcount
operator|=
name|VP0_BUFFER_SIZE
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VP0_WARNING
end_ifdef

begin_function
specifier|static
specifier|inline
name|void
name|vpo_warning
parameter_list|(
name|struct
name|vpo_data
modifier|*
name|vpo
parameter_list|,
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
switch|switch
condition|(
name|timeout
condition|)
block|{
case|case
literal|0
case|:
case|case
name|VP0_ESELECT_TIMEOUT
case|:
comment|/* log(LOG_WARNING, 			"vpo%d: select timeout\n", vpo->vpo_unit); */
break|break;
case|case
name|VP0_EDISCONNECT
case|:
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vpo%d: can't get printer state\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|VP0_ECONNECT
case|:
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vpo%d: can't get disk state\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|VP0_ECMD_TIMEOUT
case|:
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vpo%d: command timeout\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|VP0_EPPDATA_TIMEOUT
case|:
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vpo%d: EPP data timeout\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|VP0_ESTATUS_TIMEOUT
case|:
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vpo%d: status timeout\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|VP0_EDATA_OVERFLOW
case|:
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vpo%d: data overflow\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|VP0_EINTR
case|:
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vpo%d: ppb request interrupted\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vpo%d: timeout = %d\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VP0_WARNING */
end_comment

begin_comment
comment|/*  * vpointr()  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|vpointr
parameter_list|(
name|struct
name|vpo_data
modifier|*
name|vpo
parameter_list|,
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|int
name|errno
decl_stmt|;
comment|/* error in errno.h */
if|if
condition|(
name|xs
operator|->
name|datalen
operator|&&
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_DATA_IN
operator|)
condition|)
name|bcopy
argument_list|(
name|xs
operator|->
name|data
argument_list|,
name|vpo
operator|->
name|vpo_buffer
argument_list|,
name|xs
operator|->
name|datalen
argument_list|)
expr_stmt|;
name|errno
operator|=
name|vpoio_do_scsi
argument_list|(
name|vpo
argument_list|,
name|VP0_INITIATOR
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
operator|(
name|char
operator|*
operator|)
name|xs
operator|->
name|cmd
argument_list|,
name|xs
operator|->
name|cmdlen
argument_list|,
name|vpo
operator|->
name|vpo_buffer
argument_list|,
name|xs
operator|->
name|datalen
argument_list|,
operator|&
name|vpo
operator|->
name|vpo_stat
argument_list|,
operator|&
name|vpo
operator|->
name|vpo_count
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VP0_DEBUG
name|printf
argument_list|(
literal|"vpo_do_scsi = %d, status = 0x%x, count = %d, vpo_error = %d\n"
argument_list|,
name|errno
argument_list|,
name|vpo
operator|->
name|vpo_stat
argument_list|,
name|vpo
operator|->
name|vpo_count
argument_list|,
name|vpo
operator|->
name|vpo_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|errno
condition|)
block|{
ifdef|#
directive|ifdef
name|VP0_WARNING
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"vpo%d: errno = %d\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* connection to ppbus interrupted */
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* if a timeout occured, no sense */
if|if
condition|(
name|vpo
operator|->
name|vpo_error
condition|)
block|{
ifdef|#
directive|ifdef
name|VP0_WARNING
name|vpo_warning
argument_list|(
name|vpo
argument_list|,
name|xs
argument_list|,
name|vpo
operator|->
name|vpo_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
define|#
directive|define
name|RESERVED_BITS_MASK
value|0x3e
comment|/* 00111110b */
define|#
directive|define
name|NO_SENSE
value|0x0
define|#
directive|define
name|CHECK_CONDITION
value|0x02
switch|switch
condition|(
name|vpo
operator|->
name|vpo_stat
operator|&
name|RESERVED_BITS_MASK
condition|)
block|{
case|case
name|NO_SENSE
case|:
break|break;
case|case
name|CHECK_CONDITION
case|:
name|vpo
operator|->
name|vpo_sense
operator|.
name|cmd
operator|.
name|op_code
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|vpo
operator|->
name|vpo_sense
operator|.
name|cmd
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|xs
operator|->
name|sense
argument_list|)
expr_stmt|;
name|vpo
operator|->
name|vpo_sense
operator|.
name|cmd
operator|.
name|control
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
name|vpoio_do_scsi
argument_list|(
name|vpo
argument_list|,
name|VP0_INITIATOR
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|vpo
operator|->
name|vpo_sense
operator|.
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|vpo
operator|->
name|vpo_sense
operator|.
name|cmd
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|xs
operator|->
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
name|xs
operator|->
name|sense
argument_list|)
argument_list|,
operator|&
name|vpo
operator|->
name|vpo_sense
operator|.
name|stat
argument_list|,
operator|&
name|vpo
operator|->
name|vpo_sense
operator|.
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
comment|/* connection to ppbus interrupted */
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
else|else
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
goto|goto
name|error
goto|;
default|default:
comment|/* BUSY or RESERVATION_CONFLICT */
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|xs
operator|->
name|datalen
operator|&&
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_DATA_IN
operator|)
condition|)
name|bcopy
argument_list|(
name|vpo
operator|->
name|vpo_buffer
argument_list|,
name|xs
operator|->
name|data
argument_list|,
name|xs
operator|->
name|datalen
argument_list|)
expr_stmt|;
name|done
label|:
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
name|error
label|:
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|vpo_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|>
literal|0
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
name|TRY_AGAIN_LATER
return|;
block|}
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_DATA_UIO
condition|)
block|{
name|printf
argument_list|(
literal|"UIO not supported by vpo_driver !\n"
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
name|TRY_AGAIN_LATER
return|;
block|}
ifdef|#
directive|ifdef
name|VP0_DEBUG
name|printf
argument_list|(
literal|"vpo_scsi_cmd(): xs->flags = 0x%x, "
expr|\
literal|"xs->data = 0x%x, xs->datalen = %d\ncommand : %*D\n"
argument_list|,
name|xs
operator|->
name|flags
argument_list|,
name|xs
operator|->
name|data
argument_list|,
name|xs
operator|->
name|datalen
argument_list|,
name|xs
operator|->
name|cmdlen
argument_list|,
name|xs
operator|->
name|cmd
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_NOMASK
condition|)
block|{
name|vpointr
argument_list|(
name|vpodata
index|[
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
index|]
argument_list|,
name|xs
argument_list|)
expr_stmt|;
return|return
name|COMPLETE
return|;
block|}
name|s
operator|=
name|VP0_SPL
argument_list|()
expr_stmt|;
name|vpointr
argument_list|(
name|vpodata
index|[
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
index|]
argument_list|,
name|xs
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|SUCCESSFULLY_QUEUED
return|;
block|}
end_function

begin_define
define|#
directive|define
name|vpoio_d_pulse
parameter_list|(
name|vpo
parameter_list|,
name|b
parameter_list|)
value|{ \ 	ppb_wdtr(&(vpo)->vpo_dev, b); \ 	ppb_wctr(&(vpo)->vpo_dev,  H_AUTO | H_nSELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev, H_nAUTO | H_nSELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev, H_nAUTO | H_nSELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev, H_nAUTO | H_nSELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev,  H_AUTO | H_nSELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev,  H_AUTO |  H_SELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev,  H_AUTO |  H_SELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev,  H_AUTO |  H_SELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev,  H_AUTO | H_nSELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev,  H_AUTO | H_nSELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev,  H_AUTO | H_nSELIN | H_INIT | H_STROBE); \ }
end_define

begin_define
define|#
directive|define
name|vpoio_c_pulse
parameter_list|(
name|vpo
parameter_list|,
name|b
parameter_list|)
value|{ \ 	ppb_wdtr(&(vpo)->vpo_dev, b); \ 	ppb_wctr(&(vpo)->vpo_dev,  H_AUTO | H_nSELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev,  H_AUTO |  H_SELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev, H_nAUTO |  H_SELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev, H_nAUTO |  H_SELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev, H_nAUTO |  H_SELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev,  H_AUTO |  H_SELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev,  H_AUTO | H_nSELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev,  H_AUTO | H_nSELIN | H_INIT | H_STROBE); \ 	ppb_wctr(&(vpo)->vpo_dev,  H_AUTO | H_nSELIN | H_INIT | H_STROBE); \ }
end_define

begin_function
specifier|static
name|int
name|vpoio_disconnect
parameter_list|(
name|struct
name|vpo_data
modifier|*
name|vpo
parameter_list|)
block|{
name|vpoio_d_pulse
argument_list|(
name|vpo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vpoio_d_pulse
argument_list|(
name|vpo
argument_list|,
literal|0x3c
argument_list|)
expr_stmt|;
name|vpoio_d_pulse
argument_list|(
name|vpo
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|vpoio_d_pulse
argument_list|(
name|vpo
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ppb_release_bus
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * how	: PPB_WAIT or PPB_DONTWAIT  */
end_comment

begin_function
specifier|static
name|int
name|vpoio_connect
parameter_list|(
name|struct
name|vpo_data
modifier|*
name|vpo
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ppb_request_bus
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|how
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|vpoio_c_pulse
argument_list|(
name|vpo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vpoio_c_pulse
argument_list|(
name|vpo
argument_list|,
literal|0x3c
argument_list|)
expr_stmt|;
name|vpoio_c_pulse
argument_list|(
name|vpo
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
if|if
condition|(
name|PPB_IN_EPP_MODE
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
condition|)
block|{
name|vpoio_c_pulse
argument_list|(
name|vpo
argument_list|,
literal|0xcf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vpoio_c_pulse
argument_list|(
name|vpo
argument_list|,
literal|0x8f
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vpoio_in_disk_mode()  *  * Check if we are in disk mode  */
end_comment

begin_function
specifier|static
name|int
name|vpoio_in_disk_mode
parameter_list|(
name|struct
name|vpo_data
modifier|*
name|vpo
parameter_list|)
block|{
comment|/* first, set H_AUTO high */
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
comment|/* when H_AUTO is set low, H_FLT should be high */
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|H_nAUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ppb_rstr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|&
name|H_FLT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* when H_AUTO is set high, H_FLT should be low */
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ppb_rstr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|&
name|H_FLT
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vpoio_reset()  *  * SCSI reset signal, the drive must be in disk mode  */
end_comment

begin_function
specifier|static
name|void
name|vpoio_reset
parameter_list|(
name|struct
name|vpo_data
modifier|*
name|vpo
parameter_list|)
block|{
comment|/* 	 * SCSI reset signal. 	 */
name|ppb_wdtr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
operator|(
literal|1
operator|<<
literal|7
operator|)
argument_list|)
expr_stmt|;
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_nINIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * vpo_detect()  *  * Detect and initialise the VP0 adapter.  */
end_comment

begin_function
specifier|static
name|int
name|vpo_detect
parameter_list|(
name|struct
name|vpo_data
modifier|*
name|vpo
parameter_list|)
block|{
name|vpoio_disconnect
argument_list|(
name|vpo
argument_list|)
expr_stmt|;
name|vpoio_connect
argument_list|(
name|vpo
argument_list|,
name|PPB_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vpoio_in_disk_mode
argument_list|(
name|vpo
argument_list|)
condition|)
block|{
name|vpoio_disconnect
argument_list|(
name|vpo
argument_list|)
expr_stmt|;
return|return
operator|(
name|VP0_EINITFAILED
operator|)
return|;
block|}
comment|/* send SCSI reset signal */
name|vpoio_reset
argument_list|(
name|vpo
argument_list|)
expr_stmt|;
name|vpoio_disconnect
argument_list|(
name|vpo
argument_list|)
expr_stmt|;
if|if
condition|(
name|vpoio_in_disk_mode
argument_list|(
name|vpo
argument_list|)
condition|)
return|return
operator|(
name|VP0_EINITFAILED
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|vpo_wctr
parameter_list|(
name|dev
parameter_list|,
name|byte
parameter_list|,
name|delay
parameter_list|)
value|{			 \ 	int i; int iter = delay / MHZ_16_IO_DURATION;	 \ 	for (i = 0; i< iter; i++) {			 \ 		ppb_wctr(dev, byte);			 \ 	}						 \ }
end_define

begin_define
define|#
directive|define
name|vpoio_spp_outbyte
parameter_list|(
name|vpo
parameter_list|,
name|byte
parameter_list|)
value|{					 \ 	ppb_wdtr(&vpo->vpo_dev, byte);					 \ 	ppb_wctr(&vpo->vpo_dev, H_nAUTO | H_nSELIN | H_INIT | H_STROBE); \ 	vpo_wctr(&vpo->vpo_dev,  H_AUTO | H_nSELIN | H_INIT | H_STROBE,	 \ 		VP0_SPP_WRITE_PULSE);					 \ }
end_define

begin_define
define|#
directive|define
name|vpoio_nibble_inbyte
parameter_list|(
name|vpo
parameter_list|,
name|buffer
parameter_list|)
value|{				\ 	register char h, l;						\ 	vpo_wctr(&vpo->vpo_dev,  H_AUTO | H_SELIN | H_INIT | H_STROBE,	\ 		VP0_NIBBLE_READ_PULSE);					\ 	h = ppb_rstr(&vpo->vpo_dev);					\ 	ppb_wctr(&vpo->vpo_dev, H_nAUTO | H_SELIN | H_INIT | H_STROBE);	\ 	l = ppb_rstr(&vpo->vpo_dev);					\ 	*buffer = ((l>> 4)& 0x0f) + (h& 0xf0);			\ }
end_define

begin_define
define|#
directive|define
name|vpoio_ps2_inbyte
parameter_list|(
name|vpo
parameter_list|,
name|buffer
parameter_list|)
value|{					\ 	*buffer = ppb_rdtr(&vpo->vpo_dev);				\ 	ppb_wctr(&vpo->vpo_dev, PCD | H_nAUTO | H_SELIN | H_INIT | H_nSTROBE); \ 	ppb_wctr(&vpo->vpo_dev, PCD |  H_AUTO | H_SELIN | H_INIT | H_nSTROBE); \ }
end_define

begin_comment
comment|/*  * vpoio_outstr()  */
end_comment

begin_function
specifier|static
name|int
name|vpoio_outstr
parameter_list|(
name|struct
name|vpo_data
modifier|*
name|vpo
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|,
name|mode
decl_stmt|,
name|epp
decl_stmt|;
name|mode
operator|=
name|ppb_get_mode
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|PPB_NIBBLE
case|:
case|case
name|PPB_PS2
case|:
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|size
condition|;
name|k
operator|++
control|)
block|{
name|vpoio_spp_outbyte
argument_list|(
name|vpo
argument_list|,
operator|*
name|buffer
operator|++
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PPB_EPP
case|:
case|case
name|PPB_ECP_EPP
case|:
name|epp
operator|=
name|ppb_get_epp_protocol
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
name|ppb_reset_epp_timeout
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|H_AUTO
operator||
name|H_SELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
if|if
condition|(
name|epp
operator|==
name|EPP_1_7
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|size
condition|;
name|k
operator|++
control|)
block|{
name|ppb_wepp
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
operator|*
name|buffer
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ppb_rstr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|&
name|TIMEOUT
operator|)
condition|)
block|{
name|error
operator|=
name|VP0_EPPDATA_TIMEOUT
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|long
operator|)
name|buffer
operator||
name|size
operator|)
operator|&
literal|0x03
condition|)
name|ppb_outsb_epp
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ppb_outsl_epp
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|buffer
argument_list|,
name|size
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ppb_rstr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|&
name|TIMEOUT
operator|)
condition|)
block|{
name|error
operator|=
name|VP0_EPPDATA_TIMEOUT
expr_stmt|;
break|break;
block|}
block|}
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
comment|/* ppb_ecp_sync(&vpo->vpo_dev); */
break|break;
default|default:
name|printf
argument_list|(
literal|"vpoio_outstr(): unknown transfer mode (%d)!\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* XXX */
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vpoio_instr()  */
end_comment

begin_function
specifier|static
name|int
name|vpoio_instr
parameter_list|(
name|struct
name|vpo_data
modifier|*
name|vpo
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|,
name|mode
decl_stmt|,
name|epp
decl_stmt|;
name|mode
operator|=
name|ppb_get_mode
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|PPB_NIBBLE
case|:
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|size
condition|;
name|k
operator|++
control|)
block|{
name|vpoio_nibble_inbyte
argument_list|(
name|vpo
argument_list|,
name|buffer
operator|++
argument_list|)
expr_stmt|;
block|}
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_PS2
case|:
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PCD
operator||
name|H_AUTO
operator||
name|H_SELIN
operator||
name|H_INIT
operator||
name|H_nSTROBE
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|size
condition|;
name|k
operator|++
control|)
block|{
name|vpoio_ps2_inbyte
argument_list|(
name|vpo
argument_list|,
name|buffer
operator|++
argument_list|)
expr_stmt|;
block|}
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPB_EPP
case|:
case|case
name|PPB_ECP_EPP
case|:
name|epp
operator|=
name|ppb_get_epp_protocol
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
name|ppb_reset_epp_timeout
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PCD
operator||
name|H_AUTO
operator||
name|H_SELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
if|if
condition|(
name|epp
operator|==
name|EPP_1_7
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|size
condition|;
name|k
operator|++
control|)
block|{
operator|*
name|buffer
operator|++
operator|=
name|ppb_repp
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ppb_rstr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|&
name|TIMEOUT
operator|)
condition|)
block|{
name|error
operator|=
name|VP0_EPPDATA_TIMEOUT
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|long
operator|)
name|buffer
operator||
name|size
operator|)
operator|&
literal|0x03
condition|)
name|ppb_insb_epp
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ppb_insl_epp
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|buffer
argument_list|,
name|size
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ppb_rstr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|&
name|TIMEOUT
operator|)
condition|)
block|{
name|error
operator|=
name|VP0_EPPDATA_TIMEOUT
expr_stmt|;
break|break;
block|}
block|}
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PCD
operator||
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
comment|/* ppb_ecp_sync(&vpo->vpo_dev); */
break|break;
default|default:
name|printf
argument_list|(
literal|"vpoio_instr(): unknown transfer mode (%d)!\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* XXX */
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|char
name|vpoio_select
parameter_list|(
name|struct
name|vpo_data
modifier|*
name|vpo
parameter_list|,
name|int
name|initiator
parameter_list|,
name|int
name|target
parameter_list|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
name|ppb_wdtr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
operator|(
literal|1
operator|<<
name|target
operator|)
argument_list|)
expr_stmt|;
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|H_nAUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
name|ppb_wdtr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
operator|(
literal|1
operator|<<
name|initiator
operator|)
argument_list|)
expr_stmt|;
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_nINIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|ppb_rstr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|&
literal|0x40
operator|)
operator|&&
operator|(
name|k
operator|++
operator|<
name|VP0_SELTMO
operator|)
condition|)
name|barrier
argument_list|()
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|VP0_SELTMO
condition|)
return|return
operator|(
name|VP0_ESELECT_TIMEOUT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vpoio_wait()  *  * H_SELIN must be low.  */
end_comment

begin_function
specifier|static
specifier|inline
name|char
name|vpoio_wait
parameter_list|(
name|struct
name|vpo_data
modifier|*
name|vpo
parameter_list|,
name|int
name|tmo
parameter_list|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
name|r
decl_stmt|;
if|#
directive|if
literal|0
comment|/* broken */
block|if (ppb_poll_device(&vpo->vpo_dev, 150, nBUSY, nBUSY, PPB_INTR)) 		return (0);  	return (ppb_rstr(&vpo->vpo_dev)& 0xf0);
endif|#
directive|endif
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|r
operator|=
name|ppb_rstr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|)
operator|&
name|nBUSY
operator|)
operator|&&
operator|(
name|k
operator|++
operator|<
name|tmo
operator|)
condition|)
name|barrier
argument_list|()
expr_stmt|;
comment|/* 	 * Return some status information. 	 * Semantics :	0xc0 = ZIP wants more data 	 *		0xd0 = ZIP wants to send more data 	 *		0xe0 = ZIP wants command 	 *		0xf0 = end of transfer, ZIP is sending status 	 */
if|if
condition|(
name|k
operator|<
name|tmo
condition|)
return|return
operator|(
name|r
operator|&
literal|0xf0
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* command timed out */
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|vpoio_do_scsi
parameter_list|(
name|struct
name|vpo_data
modifier|*
name|vpo
parameter_list|,
name|int
name|host
parameter_list|,
name|int
name|target
parameter_list|,
name|char
modifier|*
name|command
parameter_list|,
name|int
name|clen
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|blen
parameter_list|,
name|int
modifier|*
name|result
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
specifier|register
name|char
name|r
decl_stmt|;
name|char
name|l
decl_stmt|,
name|h
init|=
literal|0
decl_stmt|;
name|int
name|rw
decl_stmt|,
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
comment|/* 	 * enter disk state, allocate the ppbus 	 * 	 * XXX 	 * Should we allow this call to be interruptible? 	 * The only way to report the interruption is to return 	 * EIO do upper SCSI code :^( 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|vpoio_connect
argument_list|(
name|vpo
argument_list|,
name|PPB_WAIT
operator||
name|PPB_INTR
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|vpoio_in_disk_mode
argument_list|(
name|vpo
argument_list|)
condition|)
block|{
name|vpo
operator|->
name|vpo_error
operator|=
name|VP0_ECONNECT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|vpo
operator|->
name|vpo_error
operator|=
name|vpoio_select
argument_list|(
name|vpo
argument_list|,
name|host
argument_list|,
name|target
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
comment|/* 	 * Send the command ... 	 * 	 * set H_SELIN low for vpoio_wait(). 	 */
name|ppb_wctr
argument_list|(
operator|&
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VP0_DEBUG
name|printf
argument_list|(
literal|"vpo%d: drive selected, now sending the command...\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|clen
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|vpoio_wait
argument_list|(
name|vpo
argument_list|,
name|VP0_FAST_SPINTMO
argument_list|)
operator|!=
operator|(
name|char
operator|)
literal|0xe0
condition|)
block|{
name|vpo
operator|->
name|vpo_error
operator|=
name|VP0_ECMD_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|vpoio_outstr
argument_list|(
name|vpo
argument_list|,
operator|&
name|command
index|[
name|k
index|]
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|vpo
operator|->
name|vpo_error
operator|=
name|VP0_EPPDATA_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|VP0_DEBUG
name|printf
argument_list|(
literal|"vpo%d: command sent, now completing the request...\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  	 * Completion ...  	 */
name|rw
operator|=
operator|(
operator|(
name|command
index|[
literal|0
index|]
operator|==
name|READ_COMMAND
operator|)
operator|||
operator|(
name|command
index|[
literal|0
index|]
operator|==
name|READ_BIG
operator|)
operator|||
operator|(
name|command
index|[
literal|0
index|]
operator|==
name|WRITE_COMMAND
operator|)
operator|||
operator|(
name|command
index|[
literal|0
index|]
operator|==
name|WRITE_BIG
operator|)
operator|)
expr_stmt|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|r
operator|=
name|vpoio_wait
argument_list|(
name|vpo
argument_list|,
name|VP0_LOW_SPINTMO
argument_list|)
operator|)
condition|)
block|{
name|vpo
operator|->
name|vpo_error
operator|=
name|VP0_ESTATUS_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* stop when the ZIP wants to send status */
if|if
condition|(
name|r
operator|==
operator|(
name|char
operator|)
literal|0xf0
condition|)
break|break;
if|if
condition|(
operator|*
name|count
operator|>=
name|blen
condition|)
block|{
name|vpo
operator|->
name|vpo_error
operator|=
name|VP0_EDATA_OVERFLOW
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|len
operator|=
operator|(
name|rw
operator|&&
operator|(
operator|(
name|blen
operator|-
operator|*
name|count
operator|)
operator|>=
name|VP0_SECTOR_SIZE
operator|)
operator|)
condition|?
name|VP0_SECTOR_SIZE
else|:
literal|1
expr_stmt|;
comment|/* ZIP wants to send data? */
if|if
condition|(
name|r
operator|==
operator|(
name|char
operator|)
literal|0xc0
condition|)
name|error
operator|=
name|vpoio_outstr
argument_list|(
name|vpo
argument_list|,
operator|&
name|buffer
index|[
operator|*
name|count
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|vpoio_instr
argument_list|(
name|vpo
argument_list|,
operator|&
name|buffer
index|[
operator|*
name|count
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vpo
operator|->
name|vpo_error
operator|=
name|error
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|count
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|vpoio_instr
argument_list|(
name|vpo
argument_list|,
operator|&
name|l
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|vpo
operator|->
name|vpo_error
operator|=
name|VP0_EOTHER
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* check if the ZIP wants to send more status */
if|if
condition|(
name|vpoio_wait
argument_list|(
name|vpo
argument_list|,
name|VP0_FAST_SPINTMO
argument_list|)
operator|==
operator|(
name|char
operator|)
literal|0xf0
condition|)
if|if
condition|(
name|vpoio_instr
argument_list|(
name|vpo
argument_list|,
operator|&
name|h
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|vpo
operator|->
name|vpo_error
operator|=
name|VP0_EOTHER
operator|+
literal|2
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|result
operator|=
operator|(
operator|(
name|int
operator|)
name|h
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|int
operator|)
name|l
operator|&
literal|0xff
operator|)
expr_stmt|;
name|error
label|:
comment|/* return to printer state, release the ppbus */
name|vpoio_disconnect
argument_list|(
name|vpo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

