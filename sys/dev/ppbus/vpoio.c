begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998, 1999 Nicolas Souchu  * Copyright (c) 2000 Alcove - Nicolas Souchu  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"opt_vpo.h"
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppbio.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppbconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppb_msq.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/vpoio.h>
end_include

begin_include
include|#
directive|include
file|"ppbus_if.h"
end_include

begin_comment
comment|/*  * The driver pools the drive. We may add a timeout queue to avoid  * active polling on nACK. I've tried this but it leads to unreliable  * transfers  */
end_comment

begin_define
define|#
directive|define
name|VP0_SELTMO
value|5000
end_define

begin_comment
comment|/* select timeout */
end_comment

begin_define
define|#
directive|define
name|VP0_FAST_SPINTMO
value|500000
end_define

begin_comment
comment|/* wait status timeout */
end_comment

begin_define
define|#
directive|define
name|VP0_LOW_SPINTMO
value|5000000
end_define

begin_comment
comment|/* wait status timeout */
end_comment

begin_comment
comment|/*  * Actually, VP0 timings are more accurate (about few 16MHZ cycles),  * but succeeding in respecting such timings leads to architecture  * dependent considerations.  */
end_comment

begin_define
define|#
directive|define
name|VP0_PULSE
value|1
end_define

begin_define
define|#
directive|define
name|VP0_SECTOR_SIZE
value|512
end_define

begin_define
define|#
directive|define
name|VP0_BUFFER_SIZE
value|0x12000
end_define

begin_define
define|#
directive|define
name|n
parameter_list|(
name|flags
parameter_list|)
value|(~(flags)& (flags))
end_define

begin_comment
comment|/*  * VP0 connections.  */
end_comment

begin_define
define|#
directive|define
name|H_AUTO
value|n(AUTOFEED)
end_define

begin_define
define|#
directive|define
name|H_nAUTO
value|AUTOFEED
end_define

begin_define
define|#
directive|define
name|H_STROBE
value|n(STROBE)
end_define

begin_define
define|#
directive|define
name|H_nSTROBE
value|STROBE
end_define

begin_define
define|#
directive|define
name|H_BSY
value|n(nBUSY)
end_define

begin_define
define|#
directive|define
name|H_nBSY
value|nBUSY
end_define

begin_define
define|#
directive|define
name|H_SEL
value|SELECT
end_define

begin_define
define|#
directive|define
name|H_nSEL
value|n(SELECT)
end_define

begin_define
define|#
directive|define
name|H_ERR
value|PERROR
end_define

begin_define
define|#
directive|define
name|H_nERR
value|n(PERROR)
end_define

begin_define
define|#
directive|define
name|H_ACK
value|nACK
end_define

begin_define
define|#
directive|define
name|H_nACK
value|n(nACK)
end_define

begin_define
define|#
directive|define
name|H_FLT
value|nFAULT
end_define

begin_define
define|#
directive|define
name|H_nFLT
value|n(nFAULT)
end_define

begin_define
define|#
directive|define
name|H_SELIN
value|n(SELECTIN)
end_define

begin_define
define|#
directive|define
name|H_nSELIN
value|SELECTIN
end_define

begin_define
define|#
directive|define
name|H_INIT
value|nINIT
end_define

begin_define
define|#
directive|define
name|H_nINIT
value|n(nINIT)
end_define

begin_comment
comment|/*  * Microcode to execute very fast I/O sequences at the lowest bus level.  */
end_comment

begin_comment
comment|/* call this macro to initialize connect/disconnect microsequences */
end_comment

begin_define
define|#
directive|define
name|INIT_TRIG_MICROSEQ
value|{						\ 	int i;								\ 	for (i=1; i<= 7; i+=2) {					\ 		disconnect_microseq[i].arg[2] = (union ppb_insarg)d_pulse; \ 		connect_epp_microseq[i].arg[2] = 			\ 		connect_spp_microseq[i].arg[2] = (union ppb_insarg)c_pulse; \ 	}								\ }
end_define

begin_define
define|#
directive|define
name|trig_d_pulse
value|MS_TRIG(MS_REG_CTR,5,MS_UNKNOWN
comment|/* d_pulse */
value|)
end_define

begin_decl_stmt
specifier|static
name|char
name|d_pulse
index|[]
init|=
block|{
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
block|,
literal|0
block|,
name|H_nAUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
block|,
name|VP0_PULSE
block|,
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
block|,
literal|0
block|,
name|H_AUTO
operator||
name|H_SELIN
operator||
name|H_INIT
operator||
name|H_STROBE
block|,
name|VP0_PULSE
block|,
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
block|,
name|VP0_PULSE
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|trig_c_pulse
value|MS_TRIG(MS_REG_CTR,5,MS_UNKNOWN
comment|/* c_pulse */
value|)
end_define

begin_decl_stmt
specifier|static
name|char
name|c_pulse
index|[]
init|=
block|{
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
block|,
literal|0
block|,
name|H_AUTO
operator||
name|H_SELIN
operator||
name|H_INIT
operator||
name|H_STROBE
block|,
literal|0
block|,
name|H_nAUTO
operator||
name|H_SELIN
operator||
name|H_INIT
operator||
name|H_STROBE
block|,
name|VP0_PULSE
block|,
name|H_AUTO
operator||
name|H_SELIN
operator||
name|H_INIT
operator||
name|H_STROBE
block|,
literal|0
block|,
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
block|,
name|VP0_PULSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|disconnect_microseq
index|[]
init|=
block|{
name|MS_DASS
argument_list|(
literal|0x0
argument_list|)
block|,
name|trig_d_pulse
block|,
name|MS_DASS
argument_list|(
literal|0x3c
argument_list|)
block|,
name|trig_d_pulse
block|,
name|MS_DASS
argument_list|(
literal|0x20
argument_list|)
block|,
name|trig_d_pulse
block|,
name|MS_DASS
argument_list|(
literal|0xf
argument_list|)
block|,
name|trig_d_pulse
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|connect_epp_microseq
index|[]
init|=
block|{
name|MS_DASS
argument_list|(
literal|0x0
argument_list|)
block|,
name|trig_c_pulse
block|,
name|MS_DASS
argument_list|(
literal|0x3c
argument_list|)
block|,
name|trig_c_pulse
block|,
name|MS_DASS
argument_list|(
literal|0x20
argument_list|)
block|,
name|trig_c_pulse
block|,
name|MS_DASS
argument_list|(
literal|0xcf
argument_list|)
block|,
name|trig_c_pulse
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|connect_spp_microseq
index|[]
init|=
block|{
name|MS_DASS
argument_list|(
literal|0x0
argument_list|)
block|,
name|trig_c_pulse
block|,
name|MS_DASS
argument_list|(
literal|0x3c
argument_list|)
block|,
name|trig_c_pulse
block|,
name|MS_DASS
argument_list|(
literal|0x20
argument_list|)
block|,
name|trig_c_pulse
block|,
name|MS_DASS
argument_list|(
literal|0x8f
argument_list|)
block|,
name|trig_c_pulse
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * nibble_inbyte_hook()  *  * Formats high and low nibble into a character  */
end_comment

begin_function
specifier|static
name|int
name|nibble_inbyte_hook
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|vpo_nibble
modifier|*
name|s
init|=
operator|(
expr|struct
name|vpo_nibble
operator|*
operator|)
name|p
decl_stmt|;
comment|/* increment the buffer pointer */
operator|*
name|ptr
operator|++
operator|=
operator|(
operator|(
name|s
operator|->
name|l
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
operator|)
operator|+
operator|(
name|s
operator|->
name|h
operator|&
literal|0xf0
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Macro used to initialize each vpoio_data structure during  * low level attachment  *  * XXX should be converted to ppb_MS_init_msq()  */
end_comment

begin_define
define|#
directive|define
name|INIT_NIBBLE_INBYTE_SUBMICROSEQ
parameter_list|(
name|vpo
parameter_list|)
value|{		    	\ 	(vpo)->vpo_nibble_inbyte_msq[2].arg[2].p =		\ 			(void *)&(vpo)->vpo_nibble.h;		\ 	(vpo)->vpo_nibble_inbyte_msq[4].arg[2].p =		\ 			(void *)&(vpo)->vpo_nibble.l;		\ 	(vpo)->vpo_nibble_inbyte_msq[5].arg[0].f =		\ 			nibble_inbyte_hook;			\ 	(vpo)->vpo_nibble_inbyte_msq[5].arg[1].p =		\ 			(void *)&(vpo)->vpo_nibble;		\ }
end_define

begin_comment
comment|/*  * This is the sub-microseqence for MS_GET in NIBBLE mode  * Retrieve the two nibbles and call the C function to generate the character  * and store it in the buffer (see nibble_inbyte_hook())  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|nibble_inbyte_submicroseq
index|[]
init|=
block|{
comment|/* loop: */
name|MS_CASS
argument_list|(
name|H_AUTO
operator||
name|H_SELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_DELAY
argument_list|(
name|VP0_PULSE
argument_list|)
block|,
name|MS_RFETCH
argument_list|(
name|MS_REG_STR
argument_list|,
name|MS_FETCH_ALL
argument_list|,
name|MS_UNKNOWN
comment|/* high nibble */
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|H_nAUTO
operator||
name|H_SELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_RFETCH
argument_list|(
name|MS_REG_STR
argument_list|,
name|MS_FETCH_ALL
argument_list|,
name|MS_UNKNOWN
comment|/* low nibble */
argument_list|)
block|,
comment|/* do a C call to format the received nibbles */
name|MS_C_CALL
argument_list|(
name|MS_UNKNOWN
comment|/* C hook */
argument_list|,
name|MS_UNKNOWN
comment|/* param */
argument_list|)
block|,
name|MS_DBRA
argument_list|(
operator|-
literal|7
comment|/* loop */
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the sub-microseqence for MS_GET in PS2 mode  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|ps2_inbyte_submicroseq
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
name|PCD
operator||
name|H_AUTO
operator||
name|H_SELIN
operator||
name|H_INIT
operator||
name|H_nSTROBE
argument_list|)
block|,
comment|/* loop: */
name|MS_RFETCH_P
argument_list|(
literal|1
argument_list|,
name|MS_REG_DTR
argument_list|,
name|MS_FETCH_ALL
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|PCD
operator||
name|H_nAUTO
operator||
name|H_SELIN
operator||
name|H_INIT
operator||
name|H_nSTROBE
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|PCD
operator||
name|H_AUTO
operator||
name|H_SELIN
operator||
name|H_INIT
operator||
name|H_nSTROBE
argument_list|)
block|,
name|MS_DBRA
argument_list|(
operator|-
literal|4
comment|/* loop */
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the sub-microsequence for MS_PUT in both NIBBLE and PS2 modes  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|spp_outbyte_submicroseq
index|[]
init|=
block|{
comment|/* loop: */
name|MS_RASSERT_P
argument_list|(
literal|1
argument_list|,
name|MS_REG_DTR
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|H_nAUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_DELAY
argument_list|(
name|VP0_PULSE
argument_list|)
block|,
name|MS_DBRA
argument_list|(
operator|-
literal|5
comment|/* loop */
argument_list|)
block|,
comment|/* return from the put call */
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EPP 1.7 microsequences, ptr and len set at runtime */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|epp17_outstr_body
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
name|H_AUTO
operator||
name|H_SELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
comment|/* loop: */
name|MS_RASSERT_P
argument_list|(
literal|1
argument_list|,
name|MS_REG_EPP_D
argument_list|)
block|,
name|MS_BRSET
argument_list|(
name|TIMEOUT
argument_list|,
literal|3
comment|/* error */
argument_list|)
block|,
comment|/* EPP timeout? */
name|MS_DBRA
argument_list|(
operator|-
literal|3
comment|/* loop */
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|,
comment|/* error: */
name|MS_CASS
argument_list|(
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|1
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|epp17_instr_body
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
name|PCD
operator||
name|H_AUTO
operator||
name|H_SELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
comment|/* loop: */
name|MS_RFETCH_P
argument_list|(
literal|1
argument_list|,
name|MS_REG_EPP_D
argument_list|,
name|MS_FETCH_ALL
argument_list|)
block|,
name|MS_BRSET
argument_list|(
name|TIMEOUT
argument_list|,
literal|3
comment|/* error */
argument_list|)
block|,
comment|/* EPP timeout? */
name|MS_DBRA
argument_list|(
operator|-
literal|3
comment|/* loop */
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|PCD
operator||
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|,
comment|/* error: */
name|MS_CASS
argument_list|(
name|PCD
operator||
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|1
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ppb_microseq
name|in_disk_mode
index|[]
init|=
block|{
name|MS_CASS
argument_list|(
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|H_nAUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_BRCLEAR
argument_list|(
name|H_FLT
argument_list|,
literal|3
comment|/* error */
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_BRSET
argument_list|(
name|H_FLT
argument_list|,
literal|1
comment|/* error */
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|1
argument_list|)
block|,
comment|/* error: */
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|vpoio_disconnect
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|disconnect_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ppb_release_bus
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * how	: PPB_WAIT or PPB_DONTWAIT  */
end_comment

begin_function
specifier|static
name|int
name|vpoio_connect
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ppb_request_bus
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|how
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|VP0_DEBUG
name|printf
argument_list|(
literal|"%s: can't request bus!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
if|if
condition|(
name|PPB_IN_EPP_MODE
argument_list|(
name|ppbus
argument_list|)
condition|)
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|connect_epp_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
else|else
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|connect_spp_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vpoio_reset()  *  * SCSI reset signal, the drive must be in disk mode  */
end_comment

begin_function
specifier|static
name|void
name|vpoio_reset
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|ppb_microseq
name|reset_microseq
index|[]
init|=
block|{
define|#
directive|define
name|INITIATOR
value|MS_PARAM(0, 1, MS_TYP_INT)
name|MS_DASS
argument_list|(
name|MS_UNKNOWN
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_nINIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_DELAY
argument_list|(
literal|25
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
name|ppb_MS_init_msq
argument_list|(
name|reset_microseq
argument_list|,
literal|1
argument_list|,
name|INITIATOR
argument_list|,
literal|1
operator|<<
name|VP0_INITIATOR
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|reset_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * vpoio_in_disk_mode()  */
end_comment

begin_function
specifier|static
name|int
name|vpoio_in_disk_mode
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|in_disk_mode
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vpoio_detect()  *  * Detect and initialise the VP0 adapter.  */
end_comment

begin_function
specifier|static
name|int
name|vpoio_detect
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ret
decl_stmt|;
comment|/* allocate the bus, then apply microsequences */
if|if
condition|(
operator|(
name|error
operator|=
name|ppb_request_bus
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PPB_DONTWAIT
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Force disconnection */
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|disconnect_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
comment|/* Try to enter EPP mode, then connect to the drive in EPP mode */
if|if
condition|(
name|ppb_set_mode
argument_list|(
name|ppbus
argument_list|,
name|PPB_EPP
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* call manually the microseq instead of using the appropriate function 		 * since we already requested the ppbus */
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|connect_epp_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
block|}
comment|/* If EPP mode switch failed or ZIP connection in EPP mode failed, 	 * try to connect in NIBBLE mode */
if|if
condition|(
operator|!
name|vpoio_in_disk_mode
argument_list|(
name|vpo
argument_list|)
condition|)
block|{
comment|/* The interface must be at least PS/2 or NIBBLE capable. 		 * There is no way to know if the ZIP will work with 		 * PS/2 mode since PS/2 and SPP both use the same connect 		 * sequence. One must supress PS/2 with boot flags if 		 * PS/2 mode fails (see ppc(4)). 		 */
if|if
condition|(
name|ppb_set_mode
argument_list|(
name|ppbus
argument_list|,
name|PPB_PS2
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|vpo
operator|->
name|vpo_mode_found
operator|=
name|VP0_MODE_PS2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ppb_set_mode
argument_list|(
name|ppbus
argument_list|,
name|PPB_NIBBLE
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
name|vpo
operator|->
name|vpo_mode_found
operator|=
name|VP0_MODE_NIBBLE
expr_stmt|;
block|}
comment|/* Can't know if the interface is capable of PS/2 yet */
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|connect_spp_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vpoio_in_disk_mode
argument_list|(
name|vpo
argument_list|)
condition|)
block|{
name|vpo
operator|->
name|vpo_mode_found
operator|=
name|VP0_MODE_UNDEFINED
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"vpo%d: can't connect to the drive\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
comment|/* disconnect and release the bus */
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|disconnect_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
else|else
block|{
name|vpo
operator|->
name|vpo_mode_found
operator|=
name|VP0_MODE_EPP
expr_stmt|;
block|}
comment|/* send SCSI reset signal */
name|vpoio_reset
argument_list|(
name|vpo
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|disconnect_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
comment|/* ensure we are disconnected or daisy chained peripheral  	 * may cause serious problem to the disk */
if|if
condition|(
name|vpoio_in_disk_mode
argument_list|(
name|vpo
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"vpo%d: can't disconnect from the drive\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ppb_release_bus
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|ppb_release_bus
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|VP0_EINITFAILED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vpoio_outstr()  */
end_comment

begin_function
specifier|static
name|int
name|vpoio_outstr
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ppb_MS_exec
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|MS_OP_PUT
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|buffer
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|size
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|MS_UNKNOWN
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|ppb_ecp_sync
argument_list|(
name|ppbus
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vpoio_instr()  */
end_comment

begin_function
specifier|static
name|int
name|vpoio_instr
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ppb_MS_exec
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|MS_OP_GET
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|buffer
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|size
argument_list|,
operator|(
expr|union
name|ppb_insarg
operator|)
name|MS_UNKNOWN
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|ppb_ecp_sync
argument_list|(
name|ppbus
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|vpoio_select
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|int
name|initiator
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|ppb_microseq
name|select_microseq
index|[]
init|=
block|{
comment|/* parameter list 		 */
define|#
directive|define
name|SELECT_TARGET
value|MS_PARAM(0, 1, MS_TYP_INT)
define|#
directive|define
name|SELECT_INITIATOR
value|MS_PARAM(3, 1, MS_TYP_INT)
comment|/* send the select command to the drive */
name|MS_DASS
argument_list|(
name|MS_UNKNOWN
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|H_nAUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
block|,
name|MS_DASS
argument_list|(
name|MS_UNKNOWN
argument_list|)
block|,
name|MS_CASS
argument_list|(
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_nINIT
operator||
name|H_STROBE
argument_list|)
block|,
comment|/* now, wait until the drive is ready */
name|MS_SET
argument_list|(
name|VP0_SELTMO
argument_list|)
block|,
comment|/* loop: */
name|MS_BRSET
argument_list|(
name|H_ACK
argument_list|,
literal|2
comment|/* ready */
argument_list|)
block|,
name|MS_DBRA
argument_list|(
operator|-
literal|2
comment|/* loop */
argument_list|)
block|,
comment|/* error: */
name|MS_RET
argument_list|(
literal|1
argument_list|)
block|,
comment|/* ready: */
name|MS_RET
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
comment|/* initialize the select microsequence */
name|ppb_MS_init_msq
argument_list|(
name|select_microseq
argument_list|,
literal|2
argument_list|,
name|SELECT_TARGET
argument_list|,
literal|1
operator|<<
name|target
argument_list|,
name|SELECT_INITIATOR
argument_list|,
literal|1
operator|<<
name|initiator
argument_list|)
expr_stmt|;
name|ppb_MS_microseq
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|select_microseq
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|VP0_ESELECT_TIMEOUT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vpoio_wait()  *  * H_SELIN must be low.  *  * XXX should be ported to microseq  */
end_comment

begin_function
specifier|static
name|char
name|vpoio_wait
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|int
name|tmo
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
name|r
decl_stmt|;
if|#
directive|if
literal|0
comment|/* broken */
block|if (ppb_poll_device(ppbus, 150, nBUSY, nBUSY, PPB_INTR)) 		return (0);  	return (ppb_rstr(ppbus)& 0xf0);
endif|#
directive|endif
comment|/* XXX should be ported to microseq */
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|r
operator|=
name|ppb_rstr
argument_list|(
name|ppbus
argument_list|)
operator|)
operator|&
name|nBUSY
operator|)
operator|&&
operator|(
name|k
operator|++
operator|<
name|tmo
operator|)
condition|)
empty_stmt|;
comment|/* 	 * Return some status information. 	 * Semantics :	0xc0 = ZIP wants more data 	 *		0xd0 = ZIP wants to send more data 	 *		0xe0 = ZIP wants command 	 *		0xf0 = end of transfer, ZIP is sending status 	 */
if|if
condition|(
name|k
operator|<
name|tmo
condition|)
return|return
operator|(
name|r
operator|&
literal|0xf0
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* command timed out */
block|}
end_function

begin_comment
comment|/*  * vpoio_probe()  *  * Low level probe of vpo device  *  */
end_comment

begin_function
name|int
name|vpoio_probe
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* ppbus dependent initialisation */
name|vpo
operator|->
name|vpo_dev
operator|=
name|dev
expr_stmt|;
comment|/* 	 * Initialize microsequence code 	 */
name|INIT_TRIG_MICROSEQ
expr_stmt|;
comment|/* now, try to initialise the drive */
if|if
condition|(
operator|(
name|error
operator|=
name|vpoio_detect
argument_list|(
name|vpo
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vpoio_attach()  *  * Low level attachment of vpo device  *  */
end_comment

begin_function
name|int
name|vpoio_attach
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|vpo
operator|->
name|vpo_nibble_inbyte_msq
operator|=
operator|(
expr|struct
name|ppb_microseq
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|nibble_inbyte_submicroseq
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vpo
operator|->
name|vpo_nibble_inbyte_msq
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|nibble_inbyte_submicroseq
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vpo
operator|->
name|vpo_nibble_inbyte_msq
argument_list|,
sizeof|sizeof
argument_list|(
name|nibble_inbyte_submicroseq
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_NIBBLE_INBYTE_SUBMICROSEQ
argument_list|(
name|vpo
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize mode dependent in/out microsequences 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|ppb_request_bus
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|PPB_WAIT
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
comment|/* ppbus sets automatically the last mode entered during detection */
switch|switch
condition|(
name|vpo
operator|->
name|vpo_mode_found
condition|)
block|{
case|case
name|VP0_MODE_EPP
case|:
name|ppb_MS_GET_init
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|epp17_instr_body
argument_list|)
expr_stmt|;
name|ppb_MS_PUT_init
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|epp17_outstr_body
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vpo%d: EPP mode\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|VP0_MODE_PS2
case|:
name|ppb_MS_GET_init
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|ps2_inbyte_submicroseq
argument_list|)
expr_stmt|;
name|ppb_MS_PUT_init
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|spp_outbyte_submicroseq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vpo%d: PS2 mode\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|VP0_MODE_NIBBLE
case|:
name|ppb_MS_GET_init
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|vpo
operator|->
name|vpo_nibble_inbyte_msq
argument_list|)
expr_stmt|;
name|ppb_MS_PUT_init
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|,
name|spp_outbyte_submicroseq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vpo%d: NIBBLE mode\n"
argument_list|,
name|vpo
operator|->
name|vpo_unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"vpo: unknown mode %d"
argument_list|,
name|vpo
operator|->
name|vpo_mode_found
argument_list|)
expr_stmt|;
block|}
name|ppb_release_bus
argument_list|(
name|ppbus
argument_list|,
name|vpo
operator|->
name|vpo_dev
argument_list|)
expr_stmt|;
name|error
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vpoio_reset_bus()  *  */
end_comment

begin_function
name|int
name|vpoio_reset_bus
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|)
block|{
comment|/* first, connect to the drive */
if|if
condition|(
name|vpoio_connect
argument_list|(
name|vpo
argument_list|,
name|PPB_WAIT
operator||
name|PPB_INTR
argument_list|)
operator|||
operator|!
name|vpoio_in_disk_mode
argument_list|(
name|vpo
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|VP0_DEBUG
name|printf
argument_list|(
literal|"%s: not in disk mode!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* release ppbus */
name|vpoio_disconnect
argument_list|(
name|vpo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* reset the SCSI bus */
name|vpoio_reset
argument_list|(
name|vpo
argument_list|)
expr_stmt|;
comment|/* then disconnect */
name|vpoio_disconnect
argument_list|(
name|vpo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vpoio_do_scsi()  *  * Send an SCSI command  *  */
end_comment

begin_function
name|int
name|vpoio_do_scsi
parameter_list|(
name|struct
name|vpoio_data
modifier|*
name|vpo
parameter_list|,
name|int
name|host
parameter_list|,
name|int
name|target
parameter_list|,
name|char
modifier|*
name|command
parameter_list|,
name|int
name|clen
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|blen
parameter_list|,
name|int
modifier|*
name|result
parameter_list|,
name|int
modifier|*
name|count
parameter_list|,
name|int
modifier|*
name|ret
parameter_list|)
block|{
name|device_t
name|ppbus
init|=
name|device_get_parent
argument_list|(
name|vpo
operator|->
name|vpo_dev
argument_list|)
decl_stmt|;
specifier|register
name|char
name|r
decl_stmt|;
name|char
name|l
decl_stmt|,
name|h
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
comment|/* 	 * enter disk state, allocate the ppbus 	 * 	 * XXX 	 * Should we allow this call to be interruptible? 	 * The only way to report the interruption is to return 	 * EIO do upper SCSI code :^( 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|vpoio_connect
argument_list|(
name|vpo
argument_list|,
name|PPB_WAIT
operator||
name|PPB_INTR
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|vpoio_in_disk_mode
argument_list|(
name|vpo
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ECONNECT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
operator|*
name|ret
operator|=
name|vpoio_select
argument_list|(
name|vpo
argument_list|,
name|host
argument_list|,
name|target
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
comment|/* 	 * Send the command ... 	 * 	 * set H_SELIN low for vpoio_wait(). 	 */
name|ppb_wctr
argument_list|(
name|ppbus
argument_list|,
name|H_AUTO
operator||
name|H_nSELIN
operator||
name|H_INIT
operator||
name|H_STROBE
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|clen
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|vpoio_wait
argument_list|(
name|vpo
argument_list|,
name|VP0_FAST_SPINTMO
argument_list|)
operator|!=
operator|(
name|char
operator|)
literal|0xe0
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ECMD_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|vpoio_outstr
argument_list|(
name|vpo
argument_list|,
operator|&
name|command
index|[
name|k
index|]
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_EPPDATA_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|/*  	 * Completion ...  	 */
operator|*
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|r
operator|=
name|vpoio_wait
argument_list|(
name|vpo
argument_list|,
name|VP0_LOW_SPINTMO
argument_list|)
operator|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_ESTATUS_TIMEOUT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* stop when the ZIP wants to send status */
if|if
condition|(
name|r
operator|==
operator|(
name|char
operator|)
literal|0xf0
condition|)
break|break;
if|if
condition|(
operator|*
name|count
operator|>=
name|blen
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_EDATA_OVERFLOW
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* if in EPP mode or writing bytes, try to transfer a sector 		 * otherwise, just send one byte 		 */
if|if
condition|(
name|PPB_IN_EPP_MODE
argument_list|(
name|ppbus
argument_list|)
operator|||
name|r
operator|==
operator|(
name|char
operator|)
literal|0xc0
condition|)
name|len
operator|=
operator|(
operator|(
operator|(
name|blen
operator|-
operator|*
name|count
operator|)
operator|>=
name|VP0_SECTOR_SIZE
operator|)
operator|)
condition|?
name|VP0_SECTOR_SIZE
else|:
literal|1
expr_stmt|;
else|else
name|len
operator|=
literal|1
expr_stmt|;
comment|/* ZIP wants to send data? */
if|if
condition|(
name|r
operator|==
operator|(
name|char
operator|)
literal|0xc0
condition|)
name|error
operator|=
name|vpoio_outstr
argument_list|(
name|vpo
argument_list|,
operator|&
name|buffer
index|[
operator|*
name|count
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|vpoio_instr
argument_list|(
name|vpo
argument_list|,
operator|&
name|buffer
index|[
operator|*
name|count
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|ret
operator|=
name|error
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|count
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|vpoio_instr
argument_list|(
name|vpo
argument_list|,
operator|&
name|l
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_EOTHER
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* check if the ZIP wants to send more status */
if|if
condition|(
name|vpoio_wait
argument_list|(
name|vpo
argument_list|,
name|VP0_FAST_SPINTMO
argument_list|)
operator|==
operator|(
name|char
operator|)
literal|0xf0
condition|)
if|if
condition|(
name|vpoio_instr
argument_list|(
name|vpo
argument_list|,
operator|&
name|h
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|*
name|ret
operator|=
name|VP0_EOTHER
operator|+
literal|2
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|*
name|result
operator|=
operator|(
operator|(
name|int
operator|)
name|h
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|int
operator|)
name|l
operator|&
literal|0xff
operator|)
expr_stmt|;
name|error
label|:
comment|/* return to printer state, release the ppbus */
name|vpoio_disconnect
argument_list|(
name|vpo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

