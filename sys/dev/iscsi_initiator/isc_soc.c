begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2010 Daniel Braniss<danny@cs.huji.ac.il>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*  | $Id: isc_soc.c 998 2009-12-20 10:32:45Z danny $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_iscsi_initiator.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<dev/iscsi_initiator/iscsi.h>
end_include

begin_include
include|#
directive|include
file|<dev/iscsi_initiator/iscsivar.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_USE_MBUF
end_ifndef

begin_define
define|#
directive|define
name|USE_MBUF
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MBUF
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ou_refcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  | function for freeing external storage for mbuf  */
end_comment

begin_function
specifier|static
name|void
name|ext_free
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|pduq_t
modifier|*
name|pq
init|=
name|b
decl_stmt|;
if|if
condition|(
name|pq
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"ou_refcnt=%d a=%p b=%p"
argument_list|,
name|ou_refcnt
argument_list|,
name|a
argument_list|,
name|pq
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pq
operator|->
name|buf
argument_list|,
name|M_ISCSIBUF
argument_list|)
expr_stmt|;
name|pq
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|isc_sendPDU
parameter_list|(
name|isc_session_t
modifier|*
name|sp
parameter_list|,
name|pduq_t
modifier|*
name|pq
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mh
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
name|pdu_t
modifier|*
name|pp
init|=
operator|&
name|pq
operator|->
name|pdu
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/*        | mbuf for the iSCSI header       */
name|MGETHDR
argument_list|(
name|mh
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|mh
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|mh
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|ipdu_u
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISOK2DIG
argument_list|(
name|sp
operator|->
name|hdrDigest
argument_list|,
name|pp
argument_list|)
condition|)
block|{
name|pp
operator|->
name|hdr_dig
operator|=
name|sp
operator|->
name|hdrDigest
argument_list|(
operator|&
name|pp
operator|->
name|ipdu
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ipdu_u
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|hdr_dig
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|ahs_len
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"ahs_len=%d"
argument_list|,
name|pp
operator|->
name|ahs_len
argument_list|)
expr_stmt|;
name|pp
operator|->
name|hdr_dig
operator|=
name|sp
operator|->
name|hdrDigest
argument_list|(
operator|&
name|pp
operator|->
name|ahs_addr
argument_list|,
name|pp
operator|->
name|ahs_len
argument_list|,
name|pp
operator|->
name|hdr_dig
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|3
argument_list|,
literal|"pp->hdr_dig=%04x"
argument_list|,
name|htonl
argument_list|(
name|pp
operator|->
name|hdr_dig
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|ahs_len
condition|)
block|{
comment|/*  	   | Add any AHS to the iSCSI hdr mbuf 	   */
if|if
condition|(
operator|(
name|mh
operator|->
name|m_len
operator|+
name|pp
operator|->
name|ahs_len
operator|)
operator|<
name|MHLEN
condition|)
block|{
name|MH_ALIGN
argument_list|(
name|mh
argument_list|,
name|mh
operator|->
name|m_len
operator|+
name|pp
operator|->
name|ahs_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pp
operator|->
name|ipdu
argument_list|,
name|mh
operator|->
name|m_data
argument_list|,
name|mh
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|pp
operator|->
name|ahs_addr
argument_list|,
name|mh
operator|->
name|m_data
operator|+
name|mh
operator|->
name|m_len
argument_list|,
name|pp
operator|->
name|ahs_len
argument_list|)
expr_stmt|;
name|mh
operator|->
name|m_len
operator|+=
name|pp
operator|->
name|ahs_len
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"len AHS=%d too big, not impleneted yet"
argument_list|,
name|pp
operator|->
name|ahs_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MH_ALIGN
argument_list|(
name|mh
argument_list|,
name|mh
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pp
operator|->
name|ipdu
argument_list|,
name|mh
operator|->
name|m_data
argument_list|,
name|mh
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mh
operator|->
name|m_len
expr_stmt|;
name|mp
operator|=
operator|&
name|mh
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|ds_len
operator|&&
name|pq
operator|->
name|pdu
operator|.
name|ds_addr
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
name|len
operator|=
name|pp
operator|->
name|ds_len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|l
decl_stmt|;
name|MGET
argument_list|(
name|md
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|md
operator|->
name|m_ext
operator|.
name|ref_cnt
operator|=
operator|&
name|ou_refcnt
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|MCLBYTES
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|4
argument_list|,
literal|"setting ext_free(arg=%p len/l=%d/%d)"
argument_list|,
name|pq
operator|->
name|buf
argument_list|,
name|len
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|MEXTADD
argument_list|(
name|md
argument_list|,
name|pp
operator|->
name|ds_addr
operator|+
name|off
argument_list|,
name|l
argument_list|,
name|ext_free
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|pp
operator|->
name|ds_addr
operator|+
name|off
argument_list|,
endif|#
directive|endif
name|pq
argument_list|,
literal|0
argument_list|,
name|EXT_EXTREF
argument_list|)
expr_stmt|;
name|md
operator|->
name|m_len
operator|=
name|l
expr_stmt|;
name|md
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|l
expr_stmt|;
operator|*
name|mp
operator|=
name|md
expr_stmt|;
name|mp
operator|=
operator|&
name|md
operator|->
name|m_next
expr_stmt|;
name|len
operator|-=
name|l
expr_stmt|;
name|off
operator|+=
name|l
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|pp
operator|->
name|ds_len
operator|&
literal|03
operator|)
operator|!=
literal|0
operator|)
operator|||
name|ISOK2DIG
argument_list|(
name|sp
operator|->
name|dataDigest
argument_list|,
name|pp
argument_list|)
condition|)
block|{
name|MGET
argument_list|(
name|md
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|ds_len
operator|&
literal|03
condition|)
name|len
operator|=
literal|4
operator|-
operator|(
name|pp
operator|->
name|ds_len
operator|&
literal|03
operator|)
expr_stmt|;
else|else
name|len
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|ISOK2DIG
argument_list|(
name|sp
operator|->
name|dataDigest
argument_list|,
name|pp
argument_list|)
condition|)
name|md
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|ds_dig
argument_list|)
expr_stmt|;
name|M_ALIGN
argument_list|(
name|md
argument_list|,
name|md
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISOK2DIG
argument_list|(
name|sp
operator|->
name|dataDigest
argument_list|,
name|pp
argument_list|)
condition|)
block|{
name|pp
operator|->
name|ds_dig
operator|=
name|sp
operator|->
name|dataDigest
argument_list|(
name|pp
operator|->
name|ds_addr
argument_list|,
name|pp
operator|->
name|ds_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|bzero
argument_list|(
name|md
operator|->
name|m_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|// RFC says SHOULD be 0
name|pp
operator|->
name|ds_dig
operator|=
name|sp
operator|->
name|dataDigest
argument_list|(
name|md
operator|->
name|m_data
argument_list|,
name|len
argument_list|,
name|pp
operator|->
name|ds_dig
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|&
name|pp
operator|->
name|ds_dig
argument_list|,
name|md
operator|->
name|m_data
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|ds_dig
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|md
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|md
operator|->
name|m_len
expr_stmt|;
operator|*
name|mp
operator|=
name|md
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|sosend
argument_list|(
name|sp
operator|->
name|soc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|mh
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sp
operator|->
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sdebug
argument_list|(
literal|2
argument_list|,
literal|"error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|sp
operator|->
name|stats
operator|.
name|nsent
operator|++
expr_stmt|;
name|getbintime
argument_list|(
operator|&
name|sp
operator|->
name|stats
operator|.
name|t_sent
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* NO_USE_MBUF */
end_comment

begin_function
name|int
name|isc_sendPDU
parameter_list|(
name|isc_session_t
modifier|*
name|sp
parameter_list|,
name|pduq_t
modifier|*
name|pq
parameter_list|)
block|{
name|struct
name|uio
modifier|*
name|uio
init|=
operator|&
name|pq
operator|->
name|uio
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iv
decl_stmt|;
name|pdu_t
modifier|*
name|pp
init|=
operator|&
name|pq
operator|->
name|pdu
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|uio
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uio
argument_list|)
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uio
operator|->
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|->
name|uio_td
operator|=
name|sp
operator|->
name|td
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|=
name|iv
operator|=
name|pq
operator|->
name|iov
expr_stmt|;
name|iv
operator|->
name|iov_base
operator|=
operator|&
name|pp
operator|->
name|ipdu
expr_stmt|;
name|iv
operator|->
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|ipdu_u
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
name|iv
operator|->
name|iov_len
expr_stmt|;
name|iv
operator|++
expr_stmt|;
if|if
condition|(
name|ISOK2DIG
argument_list|(
name|sp
operator|->
name|hdrDigest
argument_list|,
name|pp
argument_list|)
condition|)
name|pq
operator|->
name|pdu
operator|.
name|hdr_dig
operator|=
name|sp
operator|->
name|hdrDigest
argument_list|(
operator|&
name|pp
operator|->
name|ipdu
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ipdu_u
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|ahs_len
condition|)
block|{
name|iv
operator|->
name|iov_base
operator|=
name|pp
operator|->
name|ahs_addr
expr_stmt|;
name|iv
operator|->
name|iov_len
operator|=
name|pp
operator|->
name|ahs_len
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|+=
name|iv
operator|->
name|iov_len
expr_stmt|;
name|iv
operator|++
expr_stmt|;
if|if
condition|(
name|ISOK2DIG
argument_list|(
name|sp
operator|->
name|hdrDigest
argument_list|,
name|pp
argument_list|)
condition|)
name|pp
operator|->
name|hdr_dig
operator|=
name|sp
operator|->
name|hdrDigest
argument_list|(
operator|&
name|pp
operator|->
name|ahs_addr
argument_list|,
name|pp
operator|->
name|ahs_len
argument_list|,
name|pp
operator|->
name|hdr_dig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISOK2DIG
argument_list|(
name|sp
operator|->
name|hdrDigest
argument_list|,
name|pp
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"hdr_dig=%04x"
argument_list|,
name|htonl
argument_list|(
name|pp
operator|->
name|hdr_dig
argument_list|)
argument_list|)
expr_stmt|;
name|iv
operator|->
name|iov_base
operator|=
operator|&
name|pp
operator|->
name|hdr_dig
expr_stmt|;
name|iv
operator|->
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|+=
name|iv
operator|->
name|iov_len
expr_stmt|;
name|iv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pq
operator|->
name|pdu
operator|.
name|ds_addr
operator|&&
name|pp
operator|->
name|ds_len
condition|)
block|{
name|iv
operator|->
name|iov_base
operator|=
name|pp
operator|->
name|ds_addr
expr_stmt|;
name|iv
operator|->
name|iov_len
operator|=
name|pp
operator|->
name|ds_len
expr_stmt|;
while|while
condition|(
name|iv
operator|->
name|iov_len
operator|&
literal|03
condition|)
comment|// the specs say it must be int alligned
name|iv
operator|->
name|iov_len
operator|++
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|+=
name|iv
operator|->
name|iov_len
expr_stmt|;
name|iv
operator|++
expr_stmt|;
if|if
condition|(
name|ISOK2DIG
argument_list|(
name|sp
operator|->
name|dataDigest
argument_list|,
name|pp
argument_list|)
condition|)
block|{
name|pp
operator|->
name|ds_dig
operator|=
name|sp
operator|->
name|dataDigest
argument_list|(
name|pp
operator|->
name|ds
argument_list|,
name|pp
operator|->
name|ds_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iv
operator|->
name|iov_base
operator|=
operator|&
name|pp
operator|->
name|ds_dig
expr_stmt|;
name|iv
operator|->
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|ds_dig
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|+=
name|iv
operator|->
name|iov_len
expr_stmt|;
name|iv
operator|++
expr_stmt|;
block|}
block|}
name|uio
operator|->
name|uio_iovcnt
operator|=
name|iv
operator|-
name|pq
operator|->
name|iov
expr_stmt|;
name|sdebug
argument_list|(
literal|4
argument_list|,
literal|"pq->len=%d uio->uio_resid=%d  uio->uio_iovcnt=%d"
argument_list|,
name|pq
operator|->
name|len
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|uio
operator|->
name|uio_iovcnt
argument_list|)
expr_stmt|;
name|sdebug
argument_list|(
literal|4
argument_list|,
literal|"opcode=%x iovcnt=%d uio_resid=%d itt=%x"
argument_list|,
name|pp
operator|->
name|ipdu
operator|.
name|bhs
operator|.
name|opcode
argument_list|,
name|uio
operator|->
name|uio_iovcnt
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|ntohl
argument_list|(
name|pp
operator|->
name|ipdu
operator|.
name|bhs
operator|.
name|itt
argument_list|)
argument_list|)
expr_stmt|;
name|sdebug
argument_list|(
literal|5
argument_list|,
literal|"sp=%p sp->soc=%p uio=%p sp->td=%p"
argument_list|,
name|sp
argument_list|,
name|sp
operator|->
name|soc
argument_list|,
name|uio
argument_list|,
name|sp
operator|->
name|td
argument_list|)
expr_stmt|;
do|do
block|{
name|len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|error
operator|=
name|sosend
argument_list|(
name|sp
operator|->
name|soc
argument_list|,
name|NULL
argument_list|,
name|uio
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sp
operator|->
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|||
name|error
operator|||
name|len
operator|==
name|uio
operator|->
name|uio_resid
condition|)
block|{
if|if
condition|(
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|sdebug
argument_list|(
literal|2
argument_list|,
literal|"uio->uio_resid=%d uio->uio_iovcnt=%d error=%d len=%d"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|uio
operator|->
name|uio_iovcnt
argument_list|,
name|error
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|EAGAIN
expr_stmt|;
comment|// 35
block|}
break|break;
block|}
comment|/* 	   | XXX: untested code 	   */
name|sdebug
argument_list|(
literal|1
argument_list|,
literal|"uio->uio_resid=%d uio->uio_iovcnt=%d"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|uio
operator|->
name|uio_iovcnt
argument_list|)
expr_stmt|;
name|iv
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
name|len
operator|-=
name|uio
operator|->
name|uio_resid
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_iovcnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|iv
operator|->
name|iov_len
operator|>
name|len
condition|)
block|{
name|caddr_t
name|bp
init|=
operator|(
name|caddr_t
operator|)
name|iv
operator|->
name|iov_base
decl_stmt|;
name|iv
operator|->
name|iov_len
operator|-=
name|len
expr_stmt|;
name|iv
operator|->
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|bp
index|[
name|len
index|]
expr_stmt|;
break|break;
block|}
name|len
operator|-=
name|iv
operator|->
name|iov_len
expr_stmt|;
name|uio
operator|->
name|uio_iovcnt
operator|--
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|++
expr_stmt|;
name|iv
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|uio
operator|->
name|uio_resid
condition|)
do|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|stats
operator|.
name|nsent
operator|++
expr_stmt|;
name|getbintime
argument_list|(
operator|&
name|sp
operator|->
name|stats
operator|.
name|t_sent
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_MBUF */
end_comment

begin_comment
comment|/*  | wait till a PDU header is received  | from the socket.  */
end_comment

begin_comment
comment|/*    The format of the BHS is:     Byte/     0       |       1       |       2       |       3       |       /              |               |               |               |      |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|      +---------------+---------------+---------------+---------------+     0|.|I| Opcode    |F|  Opcode-specific fields                     |      +---------------+---------------+---------------+---------------+     4|TotalAHSLength | DataSegmentLength                             |      +---------------+---------------+---------------+---------------+     8| LUN or Opcode-specific fields                                 |      +                                                               +    12|                                                               |      +---------------+---------------+---------------+---------------+    16| Initiator Task Tag                                            |      +---------------+---------------+---------------+---------------+    20/ Opcode-specific fields                                        /     +/                                                               /      +---------------+---------------+---------------+---------------+    48  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|so_getbhs
parameter_list|(
name|isc_session_t
modifier|*
name|sp
parameter_list|)
block|{
name|bhs_t
modifier|*
name|bhs
init|=
operator|&
name|sp
operator|->
name|bhs
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
operator|&
name|sp
operator|->
name|uio
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iov
init|=
operator|&
name|sp
operator|->
name|iov
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|iov
operator|->
name|iov_base
operator|=
name|bhs
expr_stmt|;
name|iov
operator|->
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|bhs_t
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|=
name|iov
expr_stmt|;
name|uio
operator|->
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uio
operator|->
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|->
name|uio_td
operator|=
name|curthread
expr_stmt|;
comment|// why ...
name|uio
operator|->
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|bhs_t
argument_list|)
expr_stmt|;
name|flags
operator|=
name|MSG_WAITALL
expr_stmt|;
name|error
operator|=
name|soreceive
argument_list|(
name|sp
operator|->
name|soc
argument_list|,
name|NULL
argument_list|,
name|uio
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|debug
argument_list|(
literal|2
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|800000
literal|"error=%d so_error=%d uio->uio_resid=%zd iov.iov_len=%zd"
argument_list|,
else|#
directive|else
literal|"error=%d so_error=%d uio->uio_resid=%d iov.iov_len=%zd"
argument_list|,
endif|#
directive|endif
name|error
argument_list|,
name|sp
operator|->
name|soc
operator|->
name|so_error
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|iov
operator|->
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|EPIPE
expr_stmt|;
comment|// was EAGAIN
name|debug
argument_list|(
literal|2
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|800000
literal|"error=%d so_error=%d uio->uio_resid=%zd iov.iov_len=%zd so_state=%x"
argument_list|,
else|#
directive|else
literal|"error=%d so_error=%d uio->uio_resid=%d iov.iov_len=%zd so_state=%x"
argument_list|,
endif|#
directive|endif
name|error
argument_list|,
name|sp
operator|->
name|soc
operator|->
name|so_error
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|iov
operator|->
name|iov_len
argument_list|,
name|sp
operator|->
name|soc
operator|->
name|so_state
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  | so_recv gets called when   | an iSCSI header has been received.  | Note: the designers had no intentions   |       in making programmer's life easy.  */
end_comment

begin_function
specifier|static
name|int
name|so_recv
parameter_list|(
name|isc_session_t
modifier|*
name|sp
parameter_list|,
name|pduq_t
modifier|*
name|pq
parameter_list|)
block|{
name|sn_t
modifier|*
name|sn
init|=
operator|&
name|sp
operator|->
name|sn
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
operator|&
name|pq
operator|->
name|uio
decl_stmt|;
name|pdu_t
modifier|*
name|pp
init|=
operator|&
name|pq
operator|->
name|pdu
decl_stmt|;
name|bhs_t
modifier|*
name|bhs
init|=
operator|&
name|pp
operator|->
name|ipdu
operator|.
name|bhs
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iov
init|=
name|pq
operator|->
name|iov
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|u_int
name|max
decl_stmt|,
name|exp
decl_stmt|;
name|int
name|flags
init|=
name|MSG_WAITALL
decl_stmt|;
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/*       | now calculate how much data should be in the buffer       */
name|uio
operator|->
name|uio_iov
operator|=
name|iov
expr_stmt|;
name|uio
operator|->
name|uio_iovcnt
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bhs
operator|->
name|AHSLength
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"bhs->AHSLength=%d"
argument_list|,
name|bhs
operator|->
name|AHSLength
argument_list|)
expr_stmt|;
name|pp
operator|->
name|ahs_len
operator|=
name|bhs
operator|->
name|AHSLength
operator|*
literal|4
expr_stmt|;
name|len
operator|+=
name|pp
operator|->
name|ahs_len
expr_stmt|;
name|pp
operator|->
name|ahs_addr
operator|=
name|malloc
argument_list|(
name|pp
operator|->
name|ahs_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|// XXX: could get stuck here
name|iov
operator|->
name|iov_base
operator|=
name|pp
operator|->
name|ahs_addr
expr_stmt|;
name|iov
operator|->
name|iov_len
operator|=
name|pp
operator|->
name|ahs_len
expr_stmt|;
name|uio
operator|->
name|uio_iovcnt
operator|++
expr_stmt|;
name|iov
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ISOK2DIG
argument_list|(
name|sp
operator|->
name|hdrDigest
argument_list|,
name|pp
argument_list|)
condition|)
block|{
name|len
operator|+=
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|hdr_dig
argument_list|)
expr_stmt|;
name|iov
operator|->
name|iov_base
operator|=
operator|&
name|pp
operator|->
name|hdr_dig
expr_stmt|;
name|iov
operator|->
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|hdr_dig
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_iovcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|uio
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uio
operator|->
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
name|len
expr_stmt|;
name|uio
operator|->
name|uio_td
operator|=
name|sp
operator|->
name|td
expr_stmt|;
comment|// why ...
name|error
operator|=
name|soreceive
argument_list|(
name|sp
operator|->
name|soc
argument_list|,
name|NULL
argument_list|,
name|uio
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
comment|//if(error == EAGAIN)
comment|// XXX: this needs work! it hangs iscontrol
if|if
condition|(
name|error
operator|||
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|800000
literal|"len=%d error=%d uio->uio_resid=%zd"
argument_list|,
else|#
directive|else
literal|"len=%d error=%d uio->uio_resid=%d"
argument_list|,
endif|#
directive|endif
name|len
argument_list|,
name|error
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ISOK2DIG
argument_list|(
name|sp
operator|->
name|hdrDigest
argument_list|,
name|pp
argument_list|)
condition|)
block|{
name|bhs_t
modifier|*
name|bhs
decl_stmt|;
name|u_int
name|digest
decl_stmt|;
name|bhs
operator|=
operator|(
name|bhs_t
operator|*
operator|)
operator|&
name|pp
operator|->
name|ipdu
expr_stmt|;
name|digest
operator|=
name|sp
operator|->
name|hdrDigest
argument_list|(
name|bhs
argument_list|,
sizeof|sizeof
argument_list|(
name|bhs_t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|ahs_len
condition|)
name|digest
operator|=
name|sp
operator|->
name|hdrDigest
argument_list|(
name|pp
operator|->
name|ahs_addr
argument_list|,
name|pp
operator|->
name|ahs_len
argument_list|,
name|digest
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|hdr_dig
operator|!=
name|digest
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"bad header digest: received=%x calculated=%x"
argument_list|,
name|pp
operator|->
name|hdr_dig
argument_list|,
name|digest
argument_list|)
expr_stmt|;
comment|// XXX: now what?
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|pp
operator|->
name|ahs_len
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"ahs len=%x type=%x spec=%x"
argument_list|,
name|pp
operator|->
name|ahs_addr
operator|->
name|len
argument_list|,
name|pp
operator|->
name|ahs_addr
operator|->
name|type
argument_list|,
name|pp
operator|->
name|ahs_addr
operator|->
name|spec
argument_list|)
expr_stmt|;
comment|// XXX: till I figure out what to do with this
name|free
argument_list|(
name|pp
operator|->
name|ahs_addr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|pq
operator|->
name|len
operator|+=
name|len
expr_stmt|;
comment|// XXX: who needs this?
name|bzero
argument_list|(
name|uio
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uio
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bhs
operator|->
name|DSLength
condition|)
block|{
name|len
operator|=
name|bhs
operator|->
name|DSLength
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|len
operator|=
operator|(
operator|(
name|len
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|16
operator|)
operator||
operator|(
name|len
operator|&
literal|0x0000ff00
operator|)
operator||
operator|(
operator|(
name|len
operator|&
literal|0x000000ff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
endif|#
directive|endif
name|pp
operator|->
name|ds_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|opt
operator|.
name|maxRecvDataSegmentLength
operator|>
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
name|sp
operator|->
name|opt
operator|.
name|maxRecvDataSegmentLength
operator|)
condition|)
block|{
name|xdebug
argument_list|(
literal|"impossible PDU length(%d) opt.maxRecvDataSegmentLength=%d"
argument_list|,
name|len
argument_list|,
name|sp
operator|->
name|opt
operator|.
name|maxRecvDataSegmentLength
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"so_recv: impossible PDU length(%d) from iSCSI %s/%s\n"
argument_list|,
name|len
argument_list|,
name|sp
operator|->
name|opt
operator|.
name|targetAddress
argument_list|,
name|sp
operator|->
name|opt
operator|.
name|targetName
argument_list|)
expr_stmt|;
comment|/* 		| XXX: this will really screwup the stream. 		| should clear up the buffer till a valid header 		| is found, or just close connection ... 		| should read the RFC. 	        */
name|error
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
while|while
condition|(
name|len
operator|&
literal|03
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|ISOK2DIG
argument_list|(
name|sp
operator|->
name|dataDigest
argument_list|,
name|pp
argument_list|)
condition|)
name|len
operator|+=
literal|4
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
name|len
expr_stmt|;
name|uio
operator|->
name|uio_td
operator|=
name|sp
operator|->
name|td
expr_stmt|;
comment|// why ...
name|pq
operator|->
name|len
operator|+=
name|len
expr_stmt|;
comment|// XXX: do we need this?
name|error
operator|=
name|soreceive
argument_list|(
name|sp
operator|->
name|soc
argument_list|,
name|NULL
argument_list|,
name|uio
argument_list|,
operator|&
name|pq
operator|->
name|mp
argument_list|,
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
comment|//if(error == EAGAIN)
comment|// XXX: this needs work! it hangs iscontrol
if|if
condition|(
name|error
operator|||
name|uio
operator|->
name|uio_resid
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ISOK2DIG
argument_list|(
name|sp
operator|->
name|dataDigest
argument_list|,
name|pp
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|digest
decl_stmt|,
name|ds_len
decl_stmt|,
name|cnt
decl_stmt|;
comment|// get the received digest
name|m_copydata
argument_list|(
name|pq
operator|->
name|mp
argument_list|,
name|len
operator|-
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|ds_dig
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|ds_dig
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|pp
operator|->
name|ds_dig
argument_list|)
expr_stmt|;
comment|// calculate all mbufs
name|digest
operator|=
literal|0
expr_stmt|;
name|ds_len
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|ds_dig
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|pq
operator|->
name|mp
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|cnt
operator|=
name|MIN
argument_list|(
name|ds_len
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|digest
operator|=
name|sp
operator|->
name|dataDigest
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|cnt
argument_list|,
name|digest
argument_list|)
expr_stmt|;
name|ds_len
operator|-=
name|cnt
expr_stmt|;
if|if
condition|(
name|ds_len
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|digest
operator|!=
name|pp
operator|->
name|ds_dig
condition|)
block|{
name|sdebug
argument_list|(
literal|1
argument_list|,
literal|"bad data digest: received=%x calculated=%x"
argument_list|,
name|pp
operator|->
name|ds_dig
argument_list|,
name|digest
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
comment|// XXX: find a better error
goto|goto
name|out
goto|;
block|}
name|KASSERT
argument_list|(
name|ds_len
operator|==
literal|0
argument_list|,
operator|(
literal|"ds_len not zero"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|sdebug
argument_list|(
literal|6
argument_list|,
literal|"len=%d] opcode=0x%x ahs_len=0x%x ds_len=0x%x"
argument_list|,
name|pq
operator|->
name|len
argument_list|,
name|bhs
operator|->
name|opcode
argument_list|,
name|pp
operator|->
name|ahs_len
argument_list|,
name|pp
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|max
operator|=
name|ntohl
argument_list|(
name|bhs
operator|->
name|MaxCmdSN
argument_list|)
expr_stmt|;
name|exp
operator|=
name|ntohl
argument_list|(
name|bhs
operator|->
name|ExpStSN
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|exp
operator|-
literal|1
operator|&&
name|max
operator|>
name|exp
operator|-
name|_MAXINCR
condition|)
block|{
name|sdebug
argument_list|(
literal|2
argument_list|,
literal|"bad cmd window size"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
comment|// XXX: for now;
goto|goto
name|out
goto|;
comment|// error
block|}
if|if
condition|(
name|SNA_GT
argument_list|(
name|max
argument_list|,
name|sn
operator|->
name|maxCmd
argument_list|)
condition|)
name|sn
operator|->
name|maxCmd
operator|=
name|max
expr_stmt|;
if|if
condition|(
name|SNA_GT
argument_list|(
name|exp
argument_list|,
name|sn
operator|->
name|expCmd
argument_list|)
condition|)
name|sn
operator|->
name|expCmd
operator|=
name|exp
expr_stmt|;
comment|/*       | remove from the holding queue packets       | that have been acked and don't need       | further processing.       */
name|i_acked_hld
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sp
operator|->
name|cws
operator|=
name|sn
operator|->
name|maxCmd
operator|-
name|sn
operator|->
name|expCmd
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
name|out
label|:
comment|// XXX: need some work here
if|if
condition|(
name|pp
operator|->
name|ahs_len
condition|)
block|{
comment|// XXX: till I figure out what to do with this
name|free
argument_list|(
name|pp
operator|->
name|ahs_addr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|xdebug
argument_list|(
literal|"have a problem, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|pdu_free
argument_list|(
name|sp
operator|->
name|isc
argument_list|,
name|pq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
name|error
operator|=
name|EPIPE
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  | wait for something to arrive.  | and if the pdu is without errors, process it.  */
end_comment

begin_function
specifier|static
name|int
name|so_input
parameter_list|(
name|isc_session_t
modifier|*
name|sp
parameter_list|)
block|{
name|pduq_t
modifier|*
name|pq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/*       | first read in the iSCSI header       */
name|error
operator|=
name|so_getbhs
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 	   | now read the rest. 	   */
name|pq
operator|=
name|pdu_alloc
argument_list|(
name|sp
operator|->
name|isc
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pq
operator|==
name|NULL
condition|)
block|{
comment|// XXX: might cause a deadlock ...
name|debug
argument_list|(
literal|2
argument_list|,
literal|"out of pdus, wait"
argument_list|)
expr_stmt|;
name|pq
operator|=
name|pdu_alloc
argument_list|(
name|sp
operator|->
name|isc
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|// OK to WAIT
block|}
name|pq
operator|->
name|pdu
operator|.
name|ipdu
operator|.
name|bhs
operator|=
name|sp
operator|->
name|bhs
expr_stmt|;
name|pq
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
name|bhs_t
argument_list|)
expr_stmt|;
comment|// so far only the header was read
name|error
operator|=
name|so_recv
argument_list|(
name|sp
argument_list|,
name|pq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|+=
literal|0x800
expr_stmt|;
comment|// XXX: just to see the error.
comment|// terminal error
comment|// XXX: close connection and exit
block|}
else|else
block|{
name|sp
operator|->
name|stats
operator|.
name|nrecv
operator|++
expr_stmt|;
name|getbintime
argument_list|(
operator|&
name|sp
operator|->
name|stats
operator|.
name|t_recv
argument_list|)
expr_stmt|;
name|ism_recv
argument_list|(
name|sp
argument_list|,
name|pq
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  | one per active (connected) session.  | this thread is responsible for reading  | in packets from the target.  */
end_comment

begin_function
specifier|static
name|void
name|isc_in
parameter_list|(
name|void
modifier|*
name|vp
parameter_list|)
block|{
name|isc_session_t
modifier|*
name|sp
init|=
operator|(
name|isc_session_t
operator|*
operator|)
name|vp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|sp
operator|->
name|soc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|ISC_CON_RUNNING
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|sp
operator|->
name|flags
operator|&
operator|(
name|ISC_CON_RUN
operator||
name|ISC_LINK_UP
operator|)
operator|)
operator|==
operator|(
name|ISC_CON_RUN
operator||
name|ISC_LINK_UP
operator|)
condition|)
block|{
comment|// XXX: hunting ...
if|if
condition|(
name|sp
operator|->
name|soc
operator|==
name|NULL
operator|||
operator|!
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"sp->soc=%p"
argument_list|,
name|sp
operator|->
name|soc
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|so_input
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sp
operator|->
name|io_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|ISC_OWAITING
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|sp
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sp
operator|->
name|io_mtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EPIPE
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
condition|)
comment|// there seems to be a problem in 6.0 ...
name|tsleep
argument_list|(
name|sp
argument_list|,
name|PRIBIO
argument_list|,
literal|"isc_soc"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
name|sdebug
argument_list|(
literal|2
argument_list|,
literal|"terminated, flags=%x so_count=%d so_state=%x error=%d proc=%p"
argument_list|,
name|sp
operator|->
name|flags
argument_list|,
name|so
operator|->
name|so_count
argument_list|,
name|so
operator|->
name|so_state
argument_list|,
name|error
argument_list|,
name|sp
operator|->
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|proc
operator|!=
name|NULL
operator|)
operator|&&
name|sp
operator|->
name|signal
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|sp
operator|->
name|proc
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|sp
operator|->
name|proc
argument_list|,
name|sp
operator|->
name|signal
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|sp
operator|->
name|proc
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|ISC_SIGNALED
expr_stmt|;
name|sdebug
argument_list|(
literal|2
argument_list|,
literal|"pid=%d signaled(%d)"
argument_list|,
name|sp
operator|->
name|proc
operator|->
name|p_pid
argument_list|,
name|sp
operator|->
name|signal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we have to do something ourselves
comment|// like closing this session ...
block|}
comment|/*       | we've been terminated       */
comment|// do we need this mutex ...?
name|mtx_lock
argument_list|(
operator|&
name|sp
operator|->
name|io_mtx
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ISC_CON_RUNNING
operator||
name|ISC_LINK_UP
operator|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sp
operator|->
name|soc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sp
operator|->
name|io_mtx
argument_list|)
expr_stmt|;
name|sdebug
argument_list|(
literal|2
argument_list|,
literal|"dropped ISC_CON_RUNNING"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|isc_stop_receiver
parameter_list|(
name|isc_session_t
modifier|*
name|sp
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|sdebug
argument_list|(
literal|3
argument_list|,
literal|"sp=%p sp->soc=%p"
argument_list|,
name|sp
argument_list|,
name|sp
condition|?
name|sp
operator|->
name|soc
else|:
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sp
operator|->
name|io_mtx
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
name|ISC_LINK_UP
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|sp
operator|->
name|soc
argument_list|,
operator|&
name|sp
operator|->
name|io_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"isc_stpc"
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
name|soshutdown
argument_list|(
name|sp
operator|->
name|soc
argument_list|,
name|SHUT_RD
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sp
operator|->
name|io_mtx
argument_list|)
expr_stmt|;
name|sdebug
argument_list|(
literal|3
argument_list|,
literal|"soshutdown"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
name|ISC_CON_RUN
expr_stmt|;
name|n
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|&&
operator|(
name|sp
operator|->
name|flags
operator|&
name|ISC_CON_RUNNING
operator|)
condition|)
block|{
name|sdebug
argument_list|(
literal|3
argument_list|,
literal|"waiting n=%d... flags=%x"
argument_list|,
name|n
argument_list|,
name|sp
operator|->
name|flags
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|sp
operator|->
name|soc
argument_list|,
operator|&
name|sp
operator|->
name|io_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"isc_stpc"
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sp
operator|->
name|io_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|fp
operator|!=
name|NULL
condition|)
name|fdrop
argument_list|(
name|sp
operator|->
name|fp
argument_list|,
name|sp
operator|->
name|td
argument_list|)
expr_stmt|;
name|fputsock
argument_list|(
name|sp
operator|->
name|soc
argument_list|)
expr_stmt|;
name|sp
operator|->
name|soc
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|fp
operator|=
name|NULL
expr_stmt|;
name|sdebug
argument_list|(
literal|3
argument_list|,
literal|"done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc_start_receiver
parameter_list|(
name|isc_session_t
modifier|*
name|sp
parameter_list|)
block|{
name|debug_called
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|ISC_CON_RUN
operator||
name|ISC_LINK_UP
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|kproc_create
else|#
directive|else
name|kthread_create
endif|#
directive|endif
argument_list|(
name|isc_in
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|soc_proc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"isc_in %d"
argument_list|,
name|sp
operator|->
name|sid
argument_list|)
decl_stmt|;
block|}
end_function

end_unit

