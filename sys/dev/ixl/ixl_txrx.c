begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2013-2014, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_comment
comment|/* **	IXL driver TX/RX Routines: **	    This was seperated to allow usage by ** 	    both the BASE and the VF drivers. */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"ixl.h"
end_include

begin_comment
comment|/* Local Prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|ixl_rx_checksum
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u32
parameter_list|,
name|u8
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_refresh_mbufs
parameter_list|(
name|struct
name|ixl_queue
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_xmit
parameter_list|(
name|struct
name|ixl_queue
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_tx_setup_offload
parameter_list|(
name|struct
name|ixl_queue
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ixl_tso_setup
parameter_list|(
name|struct
name|ixl_queue
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ixl_rx_discard
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ixl_rx_input
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u8
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ** Multiqueue Transmit driver ** */
end_comment

begin_function
name|int
name|ixl_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|;
comment|/* Which queue to use */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
operator|)
operator|!=
literal|0
condition|)
name|i
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|vsi
operator|->
name|num_queues
expr_stmt|;
else|else
name|i
operator|=
name|curcpu
operator|%
name|vsi
operator|->
name|num_queues
expr_stmt|;
comment|/* Check for a hung queue and pick alternative */
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
name|vsi
operator|->
name|active_queues
operator|)
operator|==
literal|0
condition|)
name|i
operator|=
name|ffsl
argument_list|(
name|vsi
operator|->
name|active_queues
argument_list|)
expr_stmt|;
name|que
operator|=
operator|&
name|vsi
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
name|err
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|IXL_TX_TRYLOCK
argument_list|(
name|txr
argument_list|)
condition|)
block|{
name|ixl_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
else|else
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|tx_task
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixl_mq_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|txr
operator|->
name|que
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|)
operator|||
name|vsi
operator|->
name|link_active
operator|==
literal|0
condition|)
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* Process the transmit queue */
while|while
condition|(
operator|(
name|next
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|ixl_xmit
argument_list|(
name|que
argument_list|,
operator|&
name|next
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
expr_stmt|;
else|else
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
expr_stmt|;
comment|/* Send a copy of the frame to the BPF listener */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|txr
operator|->
name|avail
operator|<
name|IXL_TX_CLEANUP_THRESHOLD
condition|)
name|ixl_txeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called from a taskqueue to drain queued transmit packets.  */
end_comment

begin_function
name|void
name|ixl_deferred_mq_start
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|arg
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixl_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Flush all queue ring buffers */
end_comment

begin_function
name|void
name|ixl_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
operator|&
name|vsi
operator|->
name|queues
index|[
name|i
index|]
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txr
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Find mbuf chains passed to the driver  ** that are 'sparse', using more than 8 ** mbufs to deliver an mss-size chunk of data */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|ixl_tso_detect_sparse
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|,
name|mss
decl_stmt|;
name|bool
name|ret
init|=
name|FALSE
decl_stmt|;
name|mss
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
for|for
control|(
name|m
operator|=
name|mp
operator|->
name|m_next
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|num
operator|++
expr_stmt|;
name|mss
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|mss
operator|<
literal|1
condition|)
break|break;
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|num
operator|>
name|IXL_SPARSE_CHAIN
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine maps the mbufs to tx descriptors, allowing the  *  TX engine to transmit the packets.   *  	- return 0 on success, positive on failure  *  **********************************************************************/
end_comment

begin_define
define|#
directive|define
name|IXL_TXD_CMD
value|(I40E_TX_DESC_CMD_EOP | I40E_TX_DESC_CMD_RS)
end_define

begin_function
specifier|static
name|int
name|ixl_xmit
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_headp
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|ixl_tx_buf
modifier|*
name|buf
decl_stmt|;
name|struct
name|i40e_tx_desc
modifier|*
name|txd
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|,
name|nsegs
decl_stmt|,
name|maxsegs
decl_stmt|;
name|int
name|first
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|;
name|u16
name|vtag
init|=
literal|0
decl_stmt|;
name|u32
name|cmd
decl_stmt|,
name|off
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|bus_dma_tag_t
name|tag
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|IXL_MAX_TSO_SEGS
index|]
decl_stmt|;
name|cmd
operator|=
name|off
operator|=
literal|0
expr_stmt|;
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
comment|/*          * Important to capture the first descriptor          * used because it will contain the index of          * the one we tell the hardware to report back          */
name|first
operator|=
name|txr
operator|->
name|next_avail
expr_stmt|;
name|buf
operator|=
operator|&
name|txr
operator|->
name|buffers
index|[
name|first
index|]
expr_stmt|;
name|map
operator|=
name|buf
operator|->
name|map
expr_stmt|;
name|tag
operator|=
name|txr
operator|->
name|tx_tag
expr_stmt|;
name|maxsegs
operator|=
name|IXL_MAX_TX_SEGS
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
comment|/* Use larger mapping for TSO */
name|tag
operator|=
name|txr
operator|->
name|tso_tag
expr_stmt|;
name|maxsegs
operator|=
name|IXL_MAX_TSO_SEGS
expr_stmt|;
if|if
condition|(
name|ixl_tso_detect_sparse
argument_list|(
name|m_head
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_defrag
argument_list|(
name|m_head
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|m
expr_stmt|;
block|}
block|}
comment|/* 	 * Map the packet for DMA. 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|tag
argument_list|,
name|map
argument_list|,
operator|*
name|m_headp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_collapse
argument_list|(
operator|*
name|m_headp
argument_list|,
name|M_NOWAIT
argument_list|,
name|maxsegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|que
operator|->
name|mbuf_defrag_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m_headp
operator|=
name|m
expr_stmt|;
comment|/* Try it again */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|tag
argument_list|,
name|map
argument_list|,
operator|*
name|m_headp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
name|que
operator|->
name|tx_dma_setup
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|que
operator|->
name|tx_dma_setup
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
name|que
operator|->
name|tx_dma_setup
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|que
operator|->
name|tx_dma_setup
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Make certain there are enough descriptors */
if|if
condition|(
name|nsegs
operator|>
name|txr
operator|->
name|avail
operator|-
literal|2
condition|)
block|{
name|txr
operator|->
name|no_desc
operator|++
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|xmit_fail
goto|;
block|}
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
comment|/* Set up the TSO/CSUM offload */
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_OFFLOAD
condition|)
block|{
name|error
operator|=
name|ixl_tx_setup_offload
argument_list|(
name|que
argument_list|,
name|m_head
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|xmit_fail
goto|;
block|}
name|cmd
operator||=
name|I40E_TX_DESC_CMD_ICRC
expr_stmt|;
comment|/* Grab the VLAN tag */
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|cmd
operator||=
name|I40E_TX_DESC_CMD_IL2TAG1
expr_stmt|;
name|vtag
operator|=
name|htole16
argument_list|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|txr
operator|->
name|next_avail
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsegs
condition|;
name|j
operator|++
control|)
block|{
name|bus_size_t
name|seglen
decl_stmt|;
name|buf
operator|=
operator|&
name|txr
operator|->
name|buffers
index|[
name|i
index|]
expr_stmt|;
name|buf
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
comment|/* Keep track of the type tag */
name|txd
operator|=
operator|&
name|txr
operator|->
name|base
index|[
name|i
index|]
expr_stmt|;
name|seglen
operator|=
name|segs
index|[
name|j
index|]
operator|.
name|ds_len
expr_stmt|;
name|txd
operator|->
name|buffer_addr
operator|=
name|htole64
argument_list|(
name|segs
index|[
name|j
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|txd
operator|->
name|cmd_type_offset_bsz
operator|=
name|htole64
argument_list|(
name|I40E_TX_DESC_DTYPE_DATA
operator||
operator|(
operator|(
name|u64
operator|)
name|cmd
operator|<<
name|I40E_TXD_QW1_CMD_SHIFT
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
name|off
operator|<<
name|I40E_TXD_QW1_OFFSET_SHIFT
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
name|seglen
operator|<<
name|I40E_TXD_QW1_TX_BUF_SZ_SHIFT
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
name|vtag
operator|<<
name|I40E_TXD_QW1_L2TAG1_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|i
expr_stmt|;
comment|/* descriptor that will get completion IRQ */
if|if
condition|(
operator|++
name|i
operator|==
name|que
operator|->
name|num_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|eop_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Set the last descriptor for report */
name|txd
operator|->
name|cmd_type_offset_bsz
operator||=
name|htole64
argument_list|(
operator|(
operator|(
name|u64
operator|)
name|IXL_TXD_CMD
operator|<<
name|I40E_TXD_QW1_CMD_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|txr
operator|->
name|avail
operator|-=
name|nsegs
expr_stmt|;
name|txr
operator|->
name|next_avail
operator|=
name|i
expr_stmt|;
name|buf
operator|->
name|m_head
operator|=
name|m_head
expr_stmt|;
comment|/* Swap the dma map between the first and last descriptor */
name|txr
operator|->
name|buffers
index|[
name|first
index|]
operator|.
name|map
operator|=
name|buf
operator|->
name|map
expr_stmt|;
name|buf
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|tag
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Set the index of the descriptor that will be marked done */
name|buf
operator|=
operator|&
name|txr
operator|->
name|buffers
index|[
name|first
index|]
expr_stmt|;
name|buf
operator|->
name|eop_index
operator|=
name|last
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|dma
operator|.
name|tag
argument_list|,
name|txr
operator|->
name|dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Advance the Transmit Descriptor Tail (Tdt), this tells the 	 * hardware that this frame is available to transmit. 	 */
operator|++
name|txr
operator|->
name|total_packets
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|txr
operator|->
name|tail
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Mark outstanding work */
if|if
condition|(
name|que
operator|->
name|busy
operator|==
literal|0
condition|)
name|que
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|xmit_fail
label|:
name|bus_dmamap_unload
argument_list|(
name|tag
argument_list|,
name|buf
operator|->
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for tx_buffer structures. The tx_buffer stores all  *  the information needed to transmit a packet on the wire. This is  *  called only once at attach, setup is done every reset.  *  **********************************************************************/
end_comment

begin_function
name|int
name|ixl_allocate_tx_data
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_tx_buf
modifier|*
name|buf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Setup DMA descriptor areas. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|IXL_TSO_SIZE
argument_list|,
comment|/* maxsize */
name|IXL_MAX_TX_SEGS
argument_list|,
comment|/* nsegments */
name|PAGE_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|txr
operator|->
name|tx_tag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Make a special tag for TSO */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|IXL_TSO_SIZE
argument_list|,
comment|/* maxsize */
name|IXL_MAX_TSO_SEGS
argument_list|,
comment|/* nsegments */
name|PAGE_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|txr
operator|->
name|tso_tag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX TSO DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|txr
operator|->
name|buffers
operator|=
operator|(
expr|struct
name|ixl_tx_buf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_tx_buf
argument_list|)
operator|*
name|que
operator|->
name|num_desc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate tx_buffer memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create the descriptor buffer default dma maps */
name|buf
operator|=
name|txr
operator|->
name|buffers
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|que
operator|->
name|num_desc
condition|;
name|i
operator|++
operator|,
name|buf
operator|++
control|)
block|{
name|buf
operator|->
name|tag
operator|=
name|txr
operator|->
name|tx_tag
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|buf
operator|->
name|tag
argument_list|,
literal|0
argument_list|,
operator|&
name|buf
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create TX DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  (Re)Initialize a queue transmit ring.  *	- called by init, it clears the descriptor ring,  *	  and frees any stale mbufs   *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_init_tx_ring
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|ixl_tx_buf
modifier|*
name|buf
decl_stmt|;
comment|/* Clear the old ring contents */
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|base
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_tx_desc
argument_list|)
operator|)
operator|*
name|que
operator|->
name|num_desc
argument_list|)
expr_stmt|;
comment|/* Reset indices */
name|txr
operator|->
name|next_avail
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|next_to_clean
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_FDIR
comment|/* Initialize flow director */
name|txr
operator|->
name|atr_rate
operator|=
name|ixl_atr_rate
expr_stmt|;
name|txr
operator|->
name|atr_count
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Free any existing tx mbufs. */
name|buf
operator|=
name|txr
operator|->
name|buffers
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|que
operator|->
name|num_desc
condition|;
name|i
operator|++
operator|,
name|buf
operator|++
control|)
block|{
if|if
condition|(
name|buf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|buf
operator|->
name|tag
argument_list|,
name|buf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|buf
operator|->
name|tag
argument_list|,
name|buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Clear the EOP index */
name|buf
operator|->
name|eop_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Set number of descriptors available */
name|txr
operator|->
name|avail
operator|=
name|que
operator|->
name|num_desc
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|dma
operator|.
name|tag
argument_list|,
name|txr
operator|->
name|dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free transmit ring related data structures.  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_free_que_tx
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|ixl_tx_buf
modifier|*
name|buf
decl_stmt|;
name|INIT_DBG_IF
argument_list|(
name|que
operator|->
name|vsi
operator|->
name|ifp
argument_list|,
literal|"queue %d: begin"
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|que
operator|->
name|num_desc
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|=
operator|&
name|txr
operator|->
name|buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|buf
operator|->
name|tag
argument_list|,
name|buf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|buf
operator|->
name|tag
argument_list|,
name|buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|buf
operator|->
name|tag
argument_list|,
name|buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|buf
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|buf
operator|->
name|tag
argument_list|,
name|buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|buf
operator|->
name|tag
argument_list|,
name|buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|buf
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|txr
operator|->
name|br
operator|!=
name|NULL
condition|)
name|buf_ring_free
argument_list|(
name|txr
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|buffers
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|txr
operator|->
name|buffers
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|txr
operator|->
name|buffers
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txr
operator|->
name|tx_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|txr
operator|->
name|tx_tag
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tx_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txr
operator|->
name|tso_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|txr
operator|->
name|tso_tag
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tso_tag
operator|=
name|NULL
expr_stmt|;
block|}
name|INIT_DBG_IF
argument_list|(
name|que
operator|->
name|vsi
operator|->
name|ifp
argument_list|,
literal|"queue %d: end"
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup descriptor for hw offloads   *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_tx_setup_offload
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|u32
modifier|*
name|cmd
parameter_list|,
name|u32
modifier|*
name|off
parameter_list|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
name|int
name|elen
decl_stmt|,
name|ip_hlen
init|=
literal|0
decl_stmt|,
name|tcp_hlen
decl_stmt|;
name|u16
name|etype
decl_stmt|;
name|u8
name|ipproto
init|=
literal|0
decl_stmt|;
name|bool
name|tso
init|=
name|FALSE
decl_stmt|;
comment|/* Set up the TSO context descriptor if required */
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|tso
operator|=
name|ixl_tso_setup
argument_list|(
name|que
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tso
condition|)
operator|++
name|que
operator|->
name|tso
expr_stmt|;
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Determine where frame payload starts. 	 * Jump over vlan headers if already present, 	 * helpful for QinQ too. 	 */
name|eh
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|elen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
else|else
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
name|elen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
block|}
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|elen
operator|)
expr_stmt|;
name|ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|ipproto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|ip_hlen
operator|)
expr_stmt|;
comment|/* The IP checksum must be recalculated with TSO */
if|if
condition|(
name|tso
condition|)
operator|*
name|cmd
operator||=
name|I40E_TX_DESC_CMD_IIPT_IPV4_CSUM
expr_stmt|;
else|else
operator|*
name|cmd
operator||=
name|I40E_TX_DESC_CMD_IIPT_IPV4
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|elen
operator|)
expr_stmt|;
name|ip_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|ipproto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6
operator|+
name|ip_hlen
operator|)
expr_stmt|;
operator|*
name|cmd
operator||=
name|I40E_TX_DESC_CMD_IIPT_IPV6
expr_stmt|;
comment|/* Falls thru */
default|default:
break|break;
block|}
operator|*
name|off
operator||=
operator|(
name|elen
operator|>>
literal|1
operator|)
operator|<<
name|I40E_TX_DESC_LENGTH_MACLEN_SHIFT
expr_stmt|;
operator|*
name|off
operator||=
operator|(
name|ip_hlen
operator|>>
literal|2
operator|)
operator|<<
name|I40E_TX_DESC_LENGTH_IPLEN_SHIFT
expr_stmt|;
switch|switch
condition|(
name|ipproto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|tcp_hlen
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_TCP_IPV6
operator|)
condition|)
block|{
operator|*
name|cmd
operator||=
name|I40E_TX_DESC_CMD_L4T_EOFT_TCP
expr_stmt|;
operator|*
name|off
operator||=
operator|(
name|tcp_hlen
operator|>>
literal|2
operator|)
operator|<<
name|I40E_TX_DESC_LENGTH_L4_FC_LEN_SHIFT
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IXL_FDIR
name|ixl_atr
argument_list|(
name|que
argument_list|,
name|th
argument_list|,
name|etype
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_UDP
operator||
name|CSUM_UDP_IPV6
operator|)
condition|)
block|{
operator|*
name|cmd
operator||=
name|I40E_TX_DESC_CMD_L4T_EOFT_UDP
expr_stmt|;
operator|*
name|off
operator||=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|>>
literal|2
operator|)
operator|<<
name|I40E_TX_DESC_LENGTH_L4_FC_LEN_SHIFT
expr_stmt|;
block|}
break|break;
case|case
name|IPPROTO_SCTP
case|:
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_SCTP
operator||
name|CSUM_SCTP_IPV6
operator|)
condition|)
block|{
operator|*
name|cmd
operator||=
name|I40E_TX_DESC_CMD_L4T_EOFT_SCTP
expr_stmt|;
operator|*
name|off
operator||=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|>>
literal|2
operator|)
operator|<<
name|I40E_TX_DESC_LENGTH_L4_FC_LEN_SHIFT
expr_stmt|;
block|}
comment|/* Fall Thru */
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Setup context for hardware segmentation offload (TSO)  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|bool
name|ixl_tso_setup
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|i40e_tx_context_desc
modifier|*
name|TXD
decl_stmt|;
name|struct
name|ixl_tx_buf
modifier|*
name|buf
decl_stmt|;
name|u32
name|cmd
decl_stmt|,
name|mss
decl_stmt|,
name|type
decl_stmt|,
name|tsolen
decl_stmt|;
name|u16
name|etype
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|elen
decl_stmt|,
name|ip_hlen
decl_stmt|,
name|tcp_hlen
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|u64
name|type_cmd_tso_mss
decl_stmt|;
comment|/* 	 * Determine where frame payload starts. 	 * Jump over vlan headers if already present 	 */
name|eh
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|elen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|etype
operator|=
name|eh
operator|->
name|evl_proto
expr_stmt|;
block|}
else|else
block|{
name|elen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|etype
operator|=
name|eh
operator|->
name|evl_encap_proto
expr_stmt|;
block|}
switch|switch
condition|(
name|ntohs
argument_list|(
name|etype
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|elen
operator|)
expr_stmt|;
if|if
condition|(
name|ip6
operator|->
name|ip6_nxt
operator|!=
name|IPPROTO_TCP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ip_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6
operator|+
name|ip_hlen
operator|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in6_cksum_pseudo
argument_list|(
name|ip6
argument_list|,
literal|0
argument_list|,
name|IPPROTO_TCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tcp_hlen
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|elen
operator|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|!=
name|IPPROTO_TCP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|ip_hlen
operator|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
name|tcp_hlen
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"%s: CSUM_TSO but no supported IP version (0x%04x)"
argument_list|,
name|__func__
argument_list|,
name|ntohs
argument_list|(
name|etype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Ensure we have at least the IP+TCP header in the first mbuf. */
if|if
condition|(
name|mp
operator|->
name|m_len
operator|<
name|elen
operator|+
name|ip_hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|idx
operator|=
name|txr
operator|->
name|next_avail
expr_stmt|;
name|buf
operator|=
operator|&
name|txr
operator|->
name|buffers
index|[
name|idx
index|]
expr_stmt|;
name|TXD
operator|=
operator|(
expr|struct
name|i40e_tx_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|base
index|[
name|idx
index|]
expr_stmt|;
name|tsolen
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|elen
operator|+
name|ip_hlen
operator|+
name|tcp_hlen
operator|)
expr_stmt|;
name|type
operator|=
name|I40E_TX_DESC_DTYPE_CONTEXT
expr_stmt|;
name|cmd
operator|=
name|I40E_TX_CTX_DESC_TSO
expr_stmt|;
name|mss
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
name|type_cmd_tso_mss
operator|=
operator|(
operator|(
name|u64
operator|)
name|type
operator|<<
name|I40E_TXD_CTX_QW1_DTYPE_SHIFT
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
name|cmd
operator|<<
name|I40E_TXD_CTX_QW1_CMD_SHIFT
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
name|tsolen
operator|<<
name|I40E_TXD_CTX_QW1_TSO_LEN_SHIFT
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
name|mss
operator|<<
name|I40E_TXD_CTX_QW1_MSS_SHIFT
operator|)
expr_stmt|;
name|TXD
operator|->
name|type_cmd_tso_mss
operator|=
name|htole64
argument_list|(
name|type_cmd_tso_mss
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|tunneling_params
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|eop_index
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|idx
operator|==
name|que
operator|->
name|num_desc
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|avail
operator|--
expr_stmt|;
name|txr
operator|->
name|next_avail
operator|=
name|idx
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*              ** ixl_get_tx_head - Retrieve the value from the  **    location the HW records its HEAD index */
end_comment

begin_function
specifier|static
specifier|inline
name|u32
name|ixl_get_tx_head
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|void
modifier|*
name|head
init|=
operator|&
name|txr
operator|->
name|base
index|[
name|que
operator|->
name|num_desc
index|]
decl_stmt|;
return|return
name|LE32_TO_CPU
argument_list|(
operator|*
operator|(
specifier|volatile
name|__le32
operator|*
operator|)
name|head
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  *  Examine each tx_buffer in the used queue. If the hardware is done  *  processing the packet then free associated resources. The  *  tx_buffer is put back on the free queue.  *  **********************************************************************/
end_comment

begin_function
name|bool
name|ixl_txeof
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|u32
name|first
decl_stmt|,
name|last
decl_stmt|,
name|head
decl_stmt|,
name|done
decl_stmt|,
name|processed
decl_stmt|;
name|struct
name|ixl_tx_buf
modifier|*
name|buf
decl_stmt|;
name|struct
name|i40e_tx_desc
modifier|*
name|tx_desc
decl_stmt|,
modifier|*
name|eop_desc
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* These are not the descriptors you seek, move along :) */
if|if
condition|(
name|txr
operator|->
name|avail
operator|==
name|que
operator|->
name|num_desc
condition|)
block|{
name|que
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|processed
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|txr
operator|->
name|next_to_clean
expr_stmt|;
name|buf
operator|=
operator|&
name|txr
operator|->
name|buffers
index|[
name|first
index|]
expr_stmt|;
name|tx_desc
operator|=
operator|(
expr|struct
name|i40e_tx_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|base
index|[
name|first
index|]
expr_stmt|;
name|last
operator|=
name|buf
operator|->
name|eop_index
expr_stmt|;
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|eop_desc
operator|=
operator|(
expr|struct
name|i40e_tx_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|base
index|[
name|last
index|]
expr_stmt|;
comment|/* Get the Head WB value */
name|head
operator|=
name|ixl_get_tx_head
argument_list|(
name|que
argument_list|)
expr_stmt|;
comment|/* 	** Get the index of the first descriptor 	** BEYOND the EOP and call that 'done'. 	** I do this so the comparison in the 	** inner while loop below can be simple 	*/
if|if
condition|(
operator|++
name|last
operator|==
name|que
operator|->
name|num_desc
condition|)
name|last
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|last
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|dma
operator|.
name|tag
argument_list|,
name|txr
operator|->
name|dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* 	** The HEAD index of the ring is written in a  	** defined location, this rather than a done bit 	** is what is used to keep track of what must be 	** 'cleaned'. 	*/
while|while
condition|(
name|first
operator|!=
name|head
condition|)
block|{
comment|/* We clean the range of the packet */
while|while
condition|(
name|first
operator|!=
name|done
condition|)
block|{
operator|++
name|txr
operator|->
name|avail
expr_stmt|;
operator|++
name|processed
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|m_head
condition|)
block|{
name|txr
operator|->
name|bytes
operator|+=
comment|/* for ITR adjustment */
name|buf
operator|->
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|txr
operator|->
name|tx_bytes
operator|+=
comment|/* for TX stats */
name|buf
operator|->
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|buf
operator|->
name|tag
argument_list|,
name|buf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|buf
operator|->
name|tag
argument_list|,
name|buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
name|buf
operator|->
name|eop_index
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|first
operator|==
name|que
operator|->
name|num_desc
condition|)
name|first
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
operator|&
name|txr
operator|->
name|buffers
index|[
name|first
index|]
expr_stmt|;
name|tx_desc
operator|=
operator|&
name|txr
operator|->
name|base
index|[
name|first
index|]
expr_stmt|;
block|}
operator|++
name|txr
operator|->
name|packets
expr_stmt|;
operator|++
name|ifp
operator|->
name|if_opackets
expr_stmt|;
comment|/* See if there is more work now */
name|last
operator|=
name|buf
operator|->
name|eop_index
expr_stmt|;
if|if
condition|(
name|last
operator|!=
operator|-
literal|1
condition|)
block|{
name|eop_desc
operator|=
operator|&
name|txr
operator|->
name|base
index|[
name|last
index|]
expr_stmt|;
comment|/* Get next done point */
if|if
condition|(
operator|++
name|last
operator|==
name|que
operator|->
name|num_desc
condition|)
name|last
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|last
expr_stmt|;
block|}
else|else
break|break;
block|}
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|dma
operator|.
name|tag
argument_list|,
name|txr
operator|->
name|dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|txr
operator|->
name|next_to_clean
operator|=
name|first
expr_stmt|;
comment|/* 	** Hang detection, we know there's 	** work outstanding or the first return 	** would have been taken, so indicate an 	** unsuccessful pass, in local_timer if 	** the value is too great the queue will 	** be considered hung. If anything has been 	** cleaned then reset the state. 	*/
if|if
condition|(
operator|(
name|processed
operator|==
literal|0
operator|)
operator|&&
operator|(
name|que
operator|->
name|busy
operator|!=
name|IXL_QUEUE_HUNG
operator|)
condition|)
operator|++
name|que
operator|->
name|busy
expr_stmt|;
if|if
condition|(
name|processed
condition|)
name|que
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
comment|/* Note this turns off HUNG */
comment|/* 	 * If there are no pending descriptors, clear the timeout. 	 */
if|if
condition|(
name|txr
operator|->
name|avail
operator|==
name|que
operator|->
name|num_desc
condition|)
block|{
name|que
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Refresh mbuf buffers for RX descriptor rings  *   - now keeps its own state so discards due to resource  *     exhaustion are unnecessary, if an mbuf cannot be obtained  *     it just returns, keeping its placeholder, thus it can simply  *     be recalled to try again.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixl_refresh_mbufs
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|bus_dma_segment_t
name|hseg
index|[
literal|1
index|]
decl_stmt|;
name|bus_dma_segment_t
name|pseg
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|ixl_rx_buf
modifier|*
name|buf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mh
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nsegs
decl_stmt|,
name|error
decl_stmt|;
name|bool
name|refreshed
init|=
name|FALSE
decl_stmt|;
name|i
operator|=
name|j
operator|=
name|rxr
operator|->
name|next_refresh
expr_stmt|;
comment|/* Control the loop with one beyond */
if|if
condition|(
operator|++
name|j
operator|==
name|que
operator|->
name|num_desc
condition|)
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|!=
name|limit
condition|)
block|{
name|buf
operator|=
operator|&
name|rxr
operator|->
name|buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|hdr_split
operator|==
name|FALSE
condition|)
goto|goto
name|no_split
goto|;
if|if
condition|(
name|buf
operator|->
name|m_head
operator|==
name|NULL
condition|)
block|{
name|mh
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
goto|goto
name|update
goto|;
block|}
else|else
name|mh
operator|=
name|buf
operator|->
name|m_head
expr_stmt|;
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mh
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
name|mh
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
name|mh
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
comment|/* Get the memory mapping */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|buf
operator|->
name|hmap
argument_list|,
name|mh
argument_list|,
name|hseg
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Refresh mbufs: hdr dmamap load"
literal|" failure - %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
goto|goto
name|update
goto|;
block|}
name|buf
operator|->
name|m_head
operator|=
name|mh
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|buf
operator|->
name|hmap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|base
index|[
name|i
index|]
operator|.
name|read
operator|.
name|hdr_addr
operator|=
name|htole64
argument_list|(
name|hseg
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|no_split
label|:
if|if
condition|(
name|buf
operator|->
name|m_pack
operator|==
name|NULL
condition|)
block|{
name|mp
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|rxr
operator|->
name|mbuf_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
goto|goto
name|update
goto|;
block|}
else|else
name|mp
operator|=
name|buf
operator|->
name|m_pack
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mp
operator|->
name|m_len
operator|=
name|rxr
operator|->
name|mbuf_sz
expr_stmt|;
comment|/* Get the memory mapping */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|buf
operator|->
name|pmap
argument_list|,
name|mp
argument_list|,
name|pseg
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Refresh mbufs: payload dmamap load"
literal|" failure - %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_pack
operator|=
name|NULL
expr_stmt|;
goto|goto
name|update
goto|;
block|}
name|buf
operator|->
name|m_pack
operator|=
name|mp
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|buf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|base
index|[
name|i
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
name|htole64
argument_list|(
name|pseg
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
comment|/* Used only when doing header split */
name|rxr
operator|->
name|base
index|[
name|i
index|]
operator|.
name|read
operator|.
name|hdr_addr
operator|=
literal|0
expr_stmt|;
name|refreshed
operator|=
name|TRUE
expr_stmt|;
comment|/* Next is precalculated */
name|i
operator|=
name|j
expr_stmt|;
name|rxr
operator|->
name|next_refresh
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|++
name|j
operator|==
name|que
operator|->
name|num_desc
condition|)
name|j
operator|=
literal|0
expr_stmt|;
block|}
name|update
label|:
if|if
condition|(
name|refreshed
condition|)
comment|/* Update hardware tail index */
name|wr32
argument_list|(
name|vsi
operator|->
name|hw
argument_list|,
name|rxr
operator|->
name|tail
argument_list|,
name|rxr
operator|->
name|next_refresh
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for rx_buffer structures. Since we use one  *  rx_buffer per descriptor, the maximum number of rx_buffer's  *  that we'll need is equal to the number of receive descriptors  *  that we've defined.  *  **********************************************************************/
end_comment

begin_function
name|int
name|ixl_allocate_rx_data
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_rx_buf
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bsize
decl_stmt|,
name|error
decl_stmt|;
name|bsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_rx_buf
argument_list|)
operator|*
name|que
operator|->
name|num_desc
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rxr
operator|->
name|buffers
operator|=
operator|(
expr|struct
name|ixl_rx_buf
operator|*
operator|)
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate rx_buffer memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MSIZE
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MSIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|rxr
operator|->
name|htag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX DMA htag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MJUM16BYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MJUM16BYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|rxr
operator|->
name|ptag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX DMA ptag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|que
operator|->
name|num_desc
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|=
operator|&
name|rxr
operator|->
name|buffers
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|buf
operator|->
name|hmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX head map\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|buf
operator|->
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX pkt map\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  (Re)Initialize the queue receive ring and its buffers.  *  **********************************************************************/
end_comment

begin_function
name|int
name|ixl_init_rx_ring
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|lro
decl_stmt|;
name|struct
name|ixl_rx_buf
modifier|*
name|buf
decl_stmt|;
name|bus_dma_segment_t
name|pseg
index|[
literal|1
index|]
decl_stmt|,
name|hseg
index|[
literal|1
index|]
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|nsegs
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|IXL_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
comment|/* Clear the ring contents */
name|rsize
operator|=
name|roundup2
argument_list|(
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|i40e_rx_desc
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* Cleanup any existing buffers */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|que
operator|->
name|num_desc
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|=
operator|&
name|rxr
operator|->
name|buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|buf
operator|->
name|hmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|buf
operator|->
name|hmap
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_head
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m_head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|m_pack
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|buf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|buf
operator|->
name|pmap
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_pack
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m_pack
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|m_pack
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* header split is off */
name|rxr
operator|->
name|hdr_split
operator|=
name|FALSE
expr_stmt|;
comment|/* Now replenish the mbufs */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|!=
name|que
operator|->
name|num_desc
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|mbuf
modifier|*
name|mh
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|buf
operator|=
operator|&
name|rxr
operator|->
name|buffers
index|[
name|j
index|]
expr_stmt|;
comment|/* 		** Don't allocate mbufs if not 		** doing header split, its wasteful 		*/
if|if
condition|(
name|rxr
operator|->
name|hdr_split
operator|==
name|FALSE
condition|)
goto|goto
name|skip_head
goto|;
comment|/* First the header */
name|buf
operator|->
name|m_head
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|m_head
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_adj
argument_list|(
name|buf
operator|->
name|m_head
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
name|mh
operator|=
name|buf
operator|->
name|m_head
expr_stmt|;
name|mh
operator|->
name|m_len
operator|=
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MHLEN
expr_stmt|;
name|mh
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
comment|/* Get the memory mapping */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|buf
operator|->
name|hmap
argument_list|,
name|buf
operator|->
name|m_head
argument_list|,
name|hseg
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
comment|/* Nothing elegant to do here */
goto|goto
name|fail
goto|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|buf
operator|->
name|hmap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Update descriptor */
name|rxr
operator|->
name|base
index|[
name|j
index|]
operator|.
name|read
operator|.
name|hdr_addr
operator|=
name|htole64
argument_list|(
name|hseg
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|skip_head
label|:
comment|/* Now the payload cluster */
name|buf
operator|->
name|m_pack
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|rxr
operator|->
name|mbuf_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|m_pack
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|mp
operator|=
name|buf
operator|->
name|m_pack
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mp
operator|->
name|m_len
operator|=
name|rxr
operator|->
name|mbuf_sz
expr_stmt|;
comment|/* Get the memory mapping */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|buf
operator|->
name|pmap
argument_list|,
name|mp
argument_list|,
name|pseg
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|buf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Update descriptor */
name|rxr
operator|->
name|base
index|[
name|j
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
name|htole64
argument_list|(
name|pseg
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|base
index|[
name|j
index|]
operator|.
name|read
operator|.
name|hdr_addr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Setup our descriptor indices */
name|rxr
operator|->
name|next_check
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|next_refresh
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|lro_enabled
operator|=
name|FALSE
expr_stmt|;
name|rxr
operator|->
name|split
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|discard
operator|=
name|FALSE
expr_stmt|;
comment|/* 	** Now set up the LRO interface: 	*/
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
condition|)
block|{
name|int
name|err
init|=
name|tcp_lro_init
argument_list|(
name|lro
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"queue %d: LRO Initialization failed!\n"
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|INIT_DBG_IF
argument_list|(
name|ifp
argument_list|,
literal|"queue %d: RX Soft LRO Initialized"
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|lro_enabled
operator|=
name|TRUE
expr_stmt|;
name|lro
operator|->
name|ifp
operator|=
name|vsi
operator|->
name|ifp
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|dma
operator|.
name|tag
argument_list|,
name|rxr
operator|->
name|dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|fail
label|:
name|IXL_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free station receive ring data structures  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_free_que_rx
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|ixl_rx_buf
modifier|*
name|buf
decl_stmt|;
name|INIT_DBG_IF
argument_list|(
name|que
operator|->
name|vsi
operator|->
name|ifp
argument_list|,
literal|"queue %d: begin"
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
comment|/* Cleanup any existing buffers */
if|if
condition|(
name|rxr
operator|->
name|buffers
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|que
operator|->
name|num_desc
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|=
operator|&
name|rxr
operator|->
name|buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|buf
operator|->
name|hmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|buf
operator|->
name|hmap
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_head
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m_head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|m_pack
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|buf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|buf
operator|->
name|pmap
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_pack
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m_pack
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|m_pack
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|hmap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|rxr
operator|->
name|htag
argument_list|,
name|buf
operator|->
name|hmap
argument_list|)
expr_stmt|;
name|buf
operator|->
name|hmap
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|pmap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|buf
operator|->
name|pmap
argument_list|)
expr_stmt|;
name|buf
operator|->
name|pmap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rxr
operator|->
name|buffers
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rxr
operator|->
name|buffers
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|buffers
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rxr
operator|->
name|htag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|rxr
operator|->
name|htag
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|htag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rxr
operator|->
name|ptag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|ptag
operator|=
name|NULL
expr_stmt|;
block|}
name|INIT_DBG_IF
argument_list|(
name|que
operator|->
name|vsi
operator|->
name|ifp
argument_list|,
literal|"queue %d: end"
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ixl_rx_input
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u8
name|ptype
parameter_list|)
block|{
comment|/*          * ATM LRO is only for IPv4/TCP packets and TCP checksum of the packet          * should be computed by hardware. Also it should not have VLAN tag in          * ethernet header.          */
if|if
condition|(
name|rxr
operator|->
name|lro_enabled
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
operator|)
operator|==
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
condition|)
block|{
comment|/*                  * Send to the stack if:                  **  - LRO not enabled, or                  **  - no LRO resources, or                  **  - lro enqueue fails                  */
if|if
condition|(
name|rxr
operator|->
name|lro
operator|.
name|lro_cnt
operator|!=
literal|0
condition|)
if|if
condition|(
name|tcp_lro_rx
argument_list|(
operator|&
name|rxr
operator|->
name|lro
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
block|}
name|IXL_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IXL_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ixl_rx_discard
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|ixl_rx_buf
modifier|*
name|rbuf
decl_stmt|;
name|rbuf
operator|=
operator|&
name|rxr
operator|->
name|buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rbuf
operator|->
name|fmp
operator|!=
name|NULL
condition|)
block|{
comment|/* Partial chain ? */
name|rbuf
operator|->
name|fmp
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|rbuf
operator|->
name|fmp
argument_list|)
expr_stmt|;
name|rbuf
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	** With advanced descriptors the writeback 	** clobbers the buffer addrs, so its easier 	** to just free the existing mbufs and take 	** the normal refresh path to get new buffers 	** and mapping. 	*/
if|if
condition|(
name|rbuf
operator|->
name|m_head
condition|)
block|{
name|m_free
argument_list|(
name|rbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|rbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rbuf
operator|->
name|m_pack
condition|)
block|{
name|m_free
argument_list|(
name|rbuf
operator|->
name|m_pack
argument_list|)
expr_stmt|;
name|rbuf
operator|->
name|m_pack
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine executes in interrupt context. It replenishes  *  the mbufs in the descriptor and sends data which has been  *  dma'ed into host memory to upper layer.  *  *  We loop at most count times if count is> 0, or until done if  *  count< 0.  *  *  Return TRUE for more work, FALSE for all clean.  *********************************************************************/
end_comment

begin_function
name|bool
name|ixl_rxeof
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|lro
decl_stmt|;
name|struct
name|lro_entry
modifier|*
name|queued
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nextp
decl_stmt|,
name|processed
init|=
literal|0
decl_stmt|;
name|union
name|i40e_rx_desc
modifier|*
name|cur
decl_stmt|;
name|struct
name|ixl_rx_buf
modifier|*
name|rbuf
decl_stmt|,
modifier|*
name|nbuf
decl_stmt|;
name|IXL_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rxr
operator|->
name|next_check
init|;
name|count
operator|!=
literal|0
condition|;
control|)
block|{
name|struct
name|mbuf
modifier|*
name|sendmp
decl_stmt|,
modifier|*
name|mh
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|u32
name|rsc
decl_stmt|,
name|status
decl_stmt|,
name|error
decl_stmt|;
name|u16
name|hlen
decl_stmt|,
name|plen
decl_stmt|,
name|vtag
decl_stmt|;
name|u64
name|qword
decl_stmt|;
name|u8
name|ptype
decl_stmt|;
name|bool
name|eop
decl_stmt|;
comment|/* Sync the ring. */
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|dma
operator|.
name|tag
argument_list|,
name|rxr
operator|->
name|dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|rxr
operator|->
name|base
index|[
name|i
index|]
expr_stmt|;
name|qword
operator|=
name|le64toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|qword1
operator|.
name|status_error_len
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|qword
operator|&
name|I40E_RXD_QW1_STATUS_MASK
operator|)
operator|>>
name|I40E_RXD_QW1_STATUS_SHIFT
expr_stmt|;
name|error
operator|=
operator|(
name|qword
operator|&
name|I40E_RXD_QW1_ERROR_MASK
operator|)
operator|>>
name|I40E_RXD_QW1_ERROR_SHIFT
expr_stmt|;
name|plen
operator|=
operator|(
name|qword
operator|&
name|I40E_RXD_QW1_LENGTH_PBUF_MASK
operator|)
operator|>>
name|I40E_RXD_QW1_LENGTH_PBUF_SHIFT
expr_stmt|;
name|hlen
operator|=
operator|(
name|qword
operator|&
name|I40E_RXD_QW1_LENGTH_HBUF_MASK
operator|)
operator|>>
name|I40E_RXD_QW1_LENGTH_HBUF_SHIFT
expr_stmt|;
name|ptype
operator|=
operator|(
name|qword
operator|&
name|I40E_RXD_QW1_PTYPE_MASK
operator|)
operator|>>
name|I40E_RXD_QW1_PTYPE_SHIFT
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
literal|1
operator|<<
name|I40E_RX_DESC_STATUS_DD_SHIFT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|++
name|rxr
operator|->
name|not_done
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
name|count
operator|--
expr_stmt|;
name|sendmp
operator|=
name|NULL
expr_stmt|;
name|nbuf
operator|=
name|NULL
expr_stmt|;
name|rsc
operator|=
literal|0
expr_stmt|;
name|cur
operator|->
name|wb
operator|.
name|qword1
operator|.
name|status_error_len
operator|=
literal|0
expr_stmt|;
name|rbuf
operator|=
operator|&
name|rxr
operator|->
name|buffers
index|[
name|i
index|]
expr_stmt|;
name|mh
operator|=
name|rbuf
operator|->
name|m_head
expr_stmt|;
name|mp
operator|=
name|rbuf
operator|->
name|m_pack
expr_stmt|;
name|eop
operator|=
operator|(
name|status
operator|&
operator|(
literal|1
operator|<<
name|I40E_RX_DESC_STATUS_EOF_SHIFT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
literal|1
operator|<<
name|I40E_RX_DESC_STATUS_L2TAG1P_SHIFT
operator|)
condition|)
name|vtag
operator|=
name|le16toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|qword0
operator|.
name|lo_dword
operator|.
name|l2tag1
argument_list|)
expr_stmt|;
else|else
name|vtag
operator|=
literal|0
expr_stmt|;
comment|/* 		** Make sure bad packets are discarded, 		** note that only EOP descriptor has valid 		** error results. 		*/
if|if
condition|(
name|eop
operator|&&
operator|(
name|error
operator|&
operator|(
literal|1
operator|<<
name|I40E_RX_DESC_ERROR_RXE_SHIFT
operator|)
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|rxr
operator|->
name|discarded
operator|++
expr_stmt|;
name|ixl_rx_discard
argument_list|(
name|rxr
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|next_desc
goto|;
block|}
comment|/* Prefetch the next buffer */
if|if
condition|(
operator|!
name|eop
condition|)
block|{
name|nextp
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nextp
operator|==
name|que
operator|->
name|num_desc
condition|)
name|nextp
operator|=
literal|0
expr_stmt|;
name|nbuf
operator|=
operator|&
name|rxr
operator|->
name|buffers
index|[
name|nextp
index|]
expr_stmt|;
name|prefetch
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 		** The header mbuf is ONLY used when header  		** split is enabled, otherwise we get normal  		** behavior, ie, both header and payload 		** are DMA'd into the payload buffer. 		** 		** Rather than using the fmp/lmp global pointers 		** we now keep the head of a packet chain in the 		** buffer struct and pass this along from one 		** descriptor to the next, until we get EOP. 		*/
if|if
condition|(
name|rxr
operator|->
name|hdr_split
operator|&&
operator|(
name|rbuf
operator|->
name|fmp
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|hlen
operator|>
name|IXL_RX_HDR
condition|)
name|hlen
operator|=
name|IXL_RX_HDR
expr_stmt|;
name|mh
operator|->
name|m_len
operator|=
name|hlen
expr_stmt|;
name|mh
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|mh
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mh
operator|->
name|m_len
expr_stmt|;
comment|/* Null buf pointer so it is refreshed */
name|rbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
comment|/* 			** Check the payload length, this 			** could be zero if its a small 			** packet. 			*/
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
block|{
name|mp
operator|->
name|m_len
operator|=
name|plen
expr_stmt|;
name|mp
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|mh
operator|->
name|m_next
operator|=
name|mp
expr_stmt|;
name|mh
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
comment|/* Null buf pointer so it is refreshed */
name|rbuf
operator|->
name|m_pack
operator|=
name|NULL
expr_stmt|;
name|rxr
operator|->
name|split
operator|++
expr_stmt|;
block|}
comment|/* 			** Now create the forward 			** chain so when complete  			** we wont have to. 			*/
if|if
condition|(
name|eop
operator|==
literal|0
condition|)
block|{
comment|/* stash the chain head */
name|nbuf
operator|->
name|fmp
operator|=
name|mh
expr_stmt|;
comment|/* Make forward chain */
if|if
condition|(
name|plen
condition|)
name|mp
operator|->
name|m_next
operator|=
name|nbuf
operator|->
name|m_pack
expr_stmt|;
else|else
name|mh
operator|->
name|m_next
operator|=
name|nbuf
operator|->
name|m_pack
expr_stmt|;
block|}
else|else
block|{
comment|/* Singlet, prepare to send */
name|sendmp
operator|=
name|mh
expr_stmt|;
if|if
condition|(
name|vtag
condition|)
block|{
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|vtag
expr_stmt|;
name|sendmp
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 			** Either no header split, or a 			** secondary piece of a fragmented 			** split packet. 			*/
name|mp
operator|->
name|m_len
operator|=
name|plen
expr_stmt|;
comment|/* 			** See if there is a stored head 			** that determines what we are 			*/
name|sendmp
operator|=
name|rbuf
operator|->
name|fmp
expr_stmt|;
name|rbuf
operator|->
name|m_pack
operator|=
name|rbuf
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sendmp
operator|!=
name|NULL
condition|)
comment|/* secondary frag */
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
else|else
block|{
comment|/* first desc of a non-ps chain */
name|sendmp
operator|=
name|mp
expr_stmt|;
name|sendmp
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|vtag
condition|)
block|{
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|vtag
expr_stmt|;
name|sendmp
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
block|}
comment|/* Pass the head pointer on */
if|if
condition|(
name|eop
operator|==
literal|0
condition|)
block|{
name|nbuf
operator|->
name|fmp
operator|=
name|sendmp
expr_stmt|;
name|sendmp
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|m_next
operator|=
name|nbuf
operator|->
name|m_pack
expr_stmt|;
block|}
block|}
operator|++
name|processed
expr_stmt|;
comment|/* Sending this frame? */
if|if
condition|(
name|eop
condition|)
block|{
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
comment|/* gather stats */
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|rxr
operator|->
name|rx_packets
operator|++
expr_stmt|;
name|rxr
operator|->
name|rx_bytes
operator|+=
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* capture data for dynamic ITR adjustment */
name|rxr
operator|->
name|packets
operator|++
expr_stmt|;
name|rxr
operator|->
name|bytes
operator|+=
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|ixl_rx_checksum
argument_list|(
name|sendmp
argument_list|,
name|status
argument_list|,
name|error
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|que
operator|->
name|msix
expr_stmt|;
name|sendmp
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
block|}
name|next_desc
label|:
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|dma
operator|.
name|tag
argument_list|,
name|rxr
operator|->
name|dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Advance our pointers to the next descriptor. */
if|if
condition|(
operator|++
name|i
operator|==
name|que
operator|->
name|num_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Now send to the stack or do LRO */
if|if
condition|(
name|sendmp
operator|!=
name|NULL
condition|)
block|{
name|rxr
operator|->
name|next_check
operator|=
name|i
expr_stmt|;
name|ixl_rx_input
argument_list|(
name|rxr
argument_list|,
name|ifp
argument_list|,
name|sendmp
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|i
operator|=
name|rxr
operator|->
name|next_check
expr_stmt|;
block|}
comment|/* Every 8 descriptors we go to refresh mbufs */
if|if
condition|(
name|processed
operator|==
literal|8
condition|)
block|{
name|ixl_refresh_mbufs
argument_list|(
name|que
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|processed
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Refresh any remaining buf structs */
if|if
condition|(
name|ixl_rx_unrefreshed
argument_list|(
name|que
argument_list|)
condition|)
name|ixl_refresh_mbufs
argument_list|(
name|que
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|next_check
operator|=
name|i
expr_stmt|;
comment|/* 	 * Flush any outstanding LRO work 	 */
while|while
condition|(
operator|(
name|queued
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|tcp_lro_flush
argument_list|(
name|lro
argument_list|,
name|queued
argument_list|)
expr_stmt|;
block|}
name|IXL_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Verify that the hardware indicated that the checksum is valid.  *  Inform the stack about the status of checksum so that stack  *  doesn't spend time verifying the checksum.  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixl_rx_checksum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|u32
name|status
parameter_list|,
name|u32
name|error
parameter_list|,
name|u8
name|ptype
parameter_list|)
block|{
name|struct
name|i40e_rx_ptype_decoded
name|decoded
decl_stmt|;
name|decoded
operator|=
name|decode_rx_desc_ptype
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
comment|/* Errors? */
if|if
condition|(
name|error
operator|&
operator|(
operator|(
literal|1
operator|<<
name|I40E_RX_DESC_ERROR_IPE_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|I40E_RX_DESC_ERROR_L4E_SHIFT
operator|)
operator|)
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* IPv6 with extension headers likely have bad csum */
if|if
condition|(
name|decoded
operator|.
name|outer_ip
operator|==
name|I40E_RX_PTYPE_OUTER_IP
operator|&&
name|decoded
operator|.
name|outer_ip_ver
operator|==
name|I40E_RX_PTYPE_OUTER_IPV6
condition|)
if|if
condition|(
name|status
operator|&
operator|(
literal|1
operator|<<
name|I40E_RX_DESC_STATUS_IPV6EXADD_SHIFT
operator|)
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* IP Checksum Good */
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
literal|1
operator|<<
name|I40E_RX_DESC_STATUS_L3L4P_SHIFT
operator|)
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator||=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

