begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2013-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IXL_STANDALONE_BUILD
end_ifndef

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_rss.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ixl.h"
end_include

begin_include
include|#
directive|include
file|"ixl_pf.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RSS
end_ifdef

begin_include
include|#
directive|include
file|<net/rss_config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*********************************************************************  *  Driver version  *********************************************************************/
end_comment

begin_decl_stmt
name|char
name|ixl_driver_version
index|[]
init|=
literal|"1.4.20-k"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  PCI Device ID Table  *  *  Used by probe to select devices to load on  *  Last field stores an index into ixl_strings  *  Last entry must be all 0s  *  *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|ixl_vendor_info_t
name|ixl_vendor_info_array
index|[]
init|=
block|{
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_SFP_XL710
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_KX_B
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_KX_C
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_QSFP_A
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_QSFP_B
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_QSFP_C
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_10G_BASE_T
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_10G_BASE_T4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* required last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Table of branding strings  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ixl_strings
index|[]
init|=
block|{
literal|"Intel(R) Ethernet Connection XL710 Driver"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|ixl_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_get_hw_capabilities
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_cap_txcsum_tso
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_init_locked
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_stop
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_stop_locked
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_update_link_status
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_allocate_pci_resources
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u16
name|ixl_get_bus_info
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|,
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_setup_stations
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_switch_config
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_initialize_vsi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_setup_adminq_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_setup_adminq_tq
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_setup_queue_msix
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_setup_queue_tqs
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_teardown_adminq_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_teardown_queue_msix
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_configure_intr0_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_configure_queue_intr_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_free_queue_tqs
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_free_adminq_tq
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_assign_vsi_legacy
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_init_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_configure_itr
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_configure_legacy
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_free_pci_resources
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_local_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_setup_interface
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_link_event
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|,
name|struct
name|i40e_arq_event_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_config_rss
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_set_queue_rx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_set_queue_tx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_set_advertised_speeds
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_get_initial_advertised_speeds
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_enable_rings
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_disable_rings
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_enable_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_disable_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_disable_rings_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_enable_adminq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_disable_adminq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_enable_queue
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_disable_queue
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_enable_legacy
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_disable_legacy
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_set_promisc
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_add_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_del_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_register_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_unregister_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_setup_vlan_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_init_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_reconfigure_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_add_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|s16
name|vlan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_del_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|s16
name|vlan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_add_hw_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_del_hw_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ixl_mac_filter
modifier|*
name|ixl_find_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|s16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_add_mc_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|u8
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_free_mac_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Sysctls*/
end_comment

begin_function_decl
specifier|static
name|void
name|ixl_add_device_sysctls
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_set_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_set_advertise
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_current_speed
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_show_fw
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_DEBUG_SYSCTL
end_ifdef

begin_function_decl
specifier|static
name|int
name|ixl_debug_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_print_debug_info
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_link_status
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_phy_abilities
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_sw_filter_list
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_hw_res_alloc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_switch_config
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The MSI/X Interrupt handlers */
end_comment

begin_function_decl
specifier|static
name|void
name|ixl_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_msix_que
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_msix_adminq
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_handle_mdd_event
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Deferred interrupt tasklets */
end_comment

begin_function_decl
specifier|static
name|void
name|ixl_do_adminq
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Statistics */
end_comment

begin_function_decl
specifier|static
name|void
name|ixl_add_hw_stats
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_add_sysctls_mac_stats
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
parameter_list|,
name|struct
name|i40e_hw_port_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_add_sysctls_eth_stats
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
parameter_list|,
name|struct
name|i40e_eth_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_update_stats_counters
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_update_eth_stats
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_update_vsi_stats
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_pf_reset_stats
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_vsi_reset_stats
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_stat_update48
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u32
parameter_list|,
name|bool
parameter_list|,
name|u64
modifier|*
parameter_list|,
name|u64
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_stat_update32
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|bool
parameter_list|,
name|u64
modifier|*
parameter_list|,
name|u64
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* NVM update */
end_comment

begin_function_decl
specifier|static
name|int
name|ixl_handle_nvmupd_cmd
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|,
name|struct
name|ifdrv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_handle_empr_reset
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_rebuild_hw_structs_after_reset
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_IOV
end_ifdef

begin_function_decl
specifier|static
name|int
name|ixl_adminq_err_to_errno
parameter_list|(
name|enum
name|i40e_admin_queue_err
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_iov_init
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint16_t
name|num_vfs
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_iov_uninit
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_add_vf
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint16_t
name|vfnum
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_handle_vf_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|,
name|struct
name|i40e_arq_event_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_handle_vflr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_reset_vf
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_reinit_vf
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|ixl_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ixl_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ixl_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ixl_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ixl_shutdown
argument_list|)
block|,
ifdef|#
directive|ifdef
name|PCI_IOV
name|DEVMETHOD
argument_list|(
name|pci_iov_init
argument_list|,
name|ixl_iov_init
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_iov_uninit
argument_list|,
name|ixl_iov_uninit
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_iov_add_vf
argument_list|,
name|ixl_add_vf
argument_list|)
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ixl_driver
init|=
block|{
literal|"ixl"
block|,
name|ixl_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_pf
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|ixl_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ixl
argument_list|,
name|pci
argument_list|,
name|ixl_driver
argument_list|,
name|ixl_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixl
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixl
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixl
argument_list|,
name|netmap
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_comment
comment|/* ** Global reset mutex */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ixl_reset_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** TUNEABLE PARAMETERS: */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ixl
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"IXL driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * MSIX should be the default for best performance,  * but this allows it to be forced off for testing.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixl_enable_msix
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.enable_msix"
argument_list|,
operator|&
name|ixl_enable_msix
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_msix
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_enable_msix
argument_list|,
literal|0
argument_list|,
literal|"Enable MSI-X interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Number of descriptors per ring: **   - TX and RX are the same size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixl_ringsz
init|=
name|DEFAULT_RING
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.ringsz"
argument_list|,
operator|&
name|ixl_ringsz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|ring_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_ringsz
argument_list|,
literal|0
argument_list|,
literal|"Descriptor Ring Size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  ** This can be set manually, if left as 0 the ** number of queues will be calculated based ** on cpus and msix vectors available. */
end_comment

begin_decl_stmt
name|int
name|ixl_max_queues
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.max_queues"
argument_list|,
operator|&
name|ixl_max_queues
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|max_queues
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_max_queues
argument_list|,
literal|0
argument_list|,
literal|"Number of Queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Controls for Interrupt Throttling  **	- true/false for dynamic adjustment ** 	- default values for static ITR */
end_comment

begin_decl_stmt
name|int
name|ixl_dynamic_rx_itr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.dynamic_rx_itr"
argument_list|,
operator|&
name|ixl_dynamic_rx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|dynamic_rx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_dynamic_rx_itr
argument_list|,
literal|0
argument_list|,
literal|"Dynamic RX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ixl_dynamic_tx_itr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.dynamic_tx_itr"
argument_list|,
operator|&
name|ixl_dynamic_tx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|dynamic_tx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_dynamic_tx_itr
argument_list|,
literal|0
argument_list|,
literal|"Dynamic TX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ixl_rx_itr
init|=
name|IXL_ITR_8K
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.rx_itr"
argument_list|,
operator|&
name|ixl_rx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_rx_itr
argument_list|,
literal|0
argument_list|,
literal|"RX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ixl_tx_itr
init|=
name|IXL_ITR_4K
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.tx_itr"
argument_list|,
operator|&
name|ixl_tx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_tx_itr
argument_list|,
literal|0
argument_list|,
literal|"TX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_FDIR
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ixl_enable_fdir
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.enable_fdir"
argument_list|,
operator|&
name|ixl_enable_fdir
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Rate at which we sample */
end_comment

begin_decl_stmt
name|int
name|ixl_atr_rate
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.atr_rate"
argument_list|,
operator|&
name|ixl_atr_rate
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_define
define|#
directive|define
name|NETMAP_IXL_MAIN
end_define

begin_comment
comment|/* only bring in one part of the netmap code */
end_comment

begin_include
include|#
directive|include
file|<dev/netmap/if_ixl_netmap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ixl_fc_string
index|[
literal|6
index|]
init|=
block|{
literal|"None"
block|,
literal|"Rx"
block|,
literal|"Tx"
block|,
literal|"Full"
block|,
literal|"Priority"
block|,
literal|"Default"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IXL
argument_list|,
literal|"ixl"
argument_list|,
literal|"ixl driver allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|ixl_bcast_addr
index|[
name|ETHER_ADDR_LEN
index|]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Device identification routine  *  *  ixl_probe determines if the driver should be loaded on  *  the hardware based on PCI vendor/device id of the device.  *  *  return BUS_PROBE_DEFAULT on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ixl_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|u16
name|pci_vendor_id
decl_stmt|,
name|pci_device_id
decl_stmt|;
name|u16
name|pci_subvendor_id
decl_stmt|,
name|pci_subdevice_id
decl_stmt|;
name|char
name|device_name
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|bool
name|lock_init
init|=
name|FALSE
decl_stmt|;
if|#
directive|if
literal|0
block|INIT_DEBUGOUT("ixl_probe: begin");
endif|#
directive|endif
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_vendor_id
operator|!=
name|I40E_INTEL_VENDOR_ID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|ixl_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subvendor_id
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subdevice_id
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|device_name
argument_list|,
literal|"%s, Version - %s"
argument_list|,
name|ixl_strings
index|[
name|ent
operator|->
name|index
index|]
argument_list|,
name|ixl_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|device_name
argument_list|)
expr_stmt|;
comment|/* One shot mutex init */
if|if
condition|(
name|lock_init
operator|==
name|FALSE
condition|)
block|{
name|lock_init
operator|=
name|TRUE
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ixl_reset_mtx
argument_list|,
literal|"ixl_reset"
argument_list|,
literal|"IXL RESET Lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device initialization routine  *  *  The attach entry point is called when the driver is being loaded.  *  This routine identifies the type of hardware, allocates all resources  *  and initializes the hardware.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
decl_stmt|;
name|u16
name|bus
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
name|nvlist_t
modifier|*
name|pf_schema
decl_stmt|,
modifier|*
name|vf_schema
decl_stmt|;
name|int
name|iov_error
decl_stmt|;
endif|#
directive|endif
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_attach: begin"
argument_list|)
expr_stmt|;
comment|/* Allocate, clear, and link in our primary soft structure */
name|pf
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pf
operator|->
name|dev
operator|=
name|pf
operator|->
name|osdep
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
comment|/* 	** Note this assumes we have a single embedded VSI, 	** this could be enhanced later to allocate multiple 	*/
name|vsi
operator|=
operator|&
name|pf
operator|->
name|vsi
expr_stmt|;
name|vsi
operator|->
name|dev
operator|=
name|pf
operator|->
name|dev
expr_stmt|;
comment|/* Core Lock Init*/
name|IXL_PF_LOCK_INIT
argument_list|(
name|pf
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the timer callout */
name|callout_init_mtx
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|,
operator|&
name|pf
operator|->
name|pf_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Save off the PCI information */
name|hw
operator|->
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|revision_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_vendor_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_device_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|device
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|func
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pf
operator|->
name|vc_debug_lvl
operator|=
literal|1
expr_stmt|;
comment|/* Do PCI setup - map BAR0, etc */
if|if
condition|(
name|ixl_allocate_pci_resources
argument_list|(
name|pf
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Allocation of PCI resources failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Establish a clean starting point */
name|i40e_clear_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_pf_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PF reset failure %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Set admin queue parameters */
name|hw
operator|->
name|aq
operator|.
name|num_arq_entries
operator|=
name|IXL_AQ_LEN
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|num_asq_entries
operator|=
name|IXL_AQ_LEN
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|arq_buf_size
operator|=
name|IXL_AQ_BUFSZ
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|asq_buf_size
operator|=
name|IXL_AQ_BUFSZ
expr_stmt|;
comment|/* Initialize mac filter list for VSI */
name|SLIST_INIT
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|)
expr_stmt|;
comment|/* Initialize the shared code */
name|error
operator|=
name|i40e_init_shared_code
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize shared code, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Set up the admin queue */
name|error
operator|=
name|i40e_init_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|I40E_ERR_FIRMWARE_API_VERSION
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize Admin Queue, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|ixl_print_nvm_version
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|I40E_ERR_FIRMWARE_API_VERSION
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The driver for the device stopped "
literal|"because the NVM image is newer than expected.\n"
literal|"You must install the most recent version of "
literal|"the network driver.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
if|if
condition|(
name|hw
operator|->
name|aq
operator|.
name|api_maj_ver
operator|==
name|I40E_FW_API_VERSION_MAJOR
operator|&&
name|hw
operator|->
name|aq
operator|.
name|api_min_ver
operator|>
name|I40E_FW_API_VERSION_MINOR
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The driver for the device detected "
literal|"a newer version of the NVM image than expected.\n"
literal|"Please install the most recent version of the network driver.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hw
operator|->
name|aq
operator|.
name|api_maj_ver
operator|<
name|I40E_FW_API_VERSION_MAJOR
operator|||
name|hw
operator|->
name|aq
operator|.
name|api_min_ver
operator|<
operator|(
name|I40E_FW_API_VERSION_MINOR
operator|-
literal|1
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The driver for the device detected "
literal|"an older version of the NVM image than expected.\n"
literal|"Please update the NVM image.\n"
argument_list|)
expr_stmt|;
comment|/* Clear PXE mode */
name|i40e_clear_pxe_mode
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Get capabilities from the device */
name|error
operator|=
name|ixl_get_hw_capabilities
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"HW capabilities failure!\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_get_cap
goto|;
block|}
comment|/* Set up host memory cache */
name|error
operator|=
name|i40e_init_lan_hmc
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_tx_qp
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_rx_qp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init_lan_hmc failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_get_cap
goto|;
block|}
name|error
operator|=
name|i40e_configure_lan_hmc
argument_list|(
name|hw
argument_list|,
name|I40E_HMC_MODEL_DIRECT_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"configure_lan_hmc failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_mac_hmc
goto|;
block|}
comment|/* Disable LLDP from the firmware */
name|i40e_aq_stop_lldp
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|i40e_get_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_validate_mac_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"validate_mac_addr failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_mac_hmc
goto|;
block|}
name|bcopy
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|perm_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|i40e_get_port_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|port_addr
argument_list|)
expr_stmt|;
comment|/* Set up VSI and queues */
if|if
condition|(
name|ixl_setup_stations
argument_list|(
name|pf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"setup stations failed!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_mac_hmc
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|aq
operator|.
name|fw_maj_ver
operator|==
literal|4
operator|)
operator|&&
operator|(
name|hw
operator|->
name|aq
operator|.
name|fw_min_ver
operator|<
literal|33
operator|)
operator|)
operator|||
operator|(
name|hw
operator|->
name|aq
operator|.
name|fw_maj_ver
operator|<
literal|4
operator|)
condition|)
block|{
name|i40e_msec_delay
argument_list|(
literal|75
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_aq_set_link_restart_an
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"link restart failed, aq_err=%d\n"
argument_list|,
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
block|}
comment|/* Determine link state */
name|hw
operator|->
name|phy
operator|.
name|get_link_info
operator|=
name|TRUE
expr_stmt|;
name|i40e_get_link_status
argument_list|(
name|hw
argument_list|,
operator|&
name|pf
operator|->
name|link_up
argument_list|)
expr_stmt|;
comment|/* Setup OS network interface / ifnet */
if|if
condition|(
name|ixl_setup_interface
argument_list|(
name|dev
argument_list|,
name|vsi
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"interface setup failed!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
name|error
operator|=
name|ixl_switch_config
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Initial ixl_switch_config() failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Limit PHY interrupts to link, autoneg, and modules failure */
name|error
operator|=
name|i40e_aq_set_phy_int_mask
argument_list|(
name|hw
argument_list|,
name|IXL_DEFAULT_PHY_INT_MASK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_aq_set_phy_mask() failed: err %d,"
literal|" aq_err %d\n"
argument_list|,
name|error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Get the bus configuration and set the shared code's config */
name|bus
operator|=
name|ixl_get_bus_info
argument_list|(
name|hw
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|i40e_set_pci_config_data
argument_list|(
name|hw
argument_list|,
name|bus
argument_list|)
expr_stmt|;
comment|/* 	 * In MSI-X mode, initialize the Admin Queue interrupt, 	 * so userland tools can communicate with the adapter regardless of 	 * the ifnet interface's status. 	 */
if|if
condition|(
name|pf
operator|->
name|msix
operator|>
literal|1
condition|)
block|{
name|error
operator|=
name|ixl_setup_adminq_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixl_setup_adminq_msix error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
name|error
operator|=
name|ixl_setup_adminq_tq
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixl_setup_adminq_tq error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
name|ixl_configure_intr0_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_enable_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize statistics& add sysctls */
name|ixl_add_device_sysctls
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_pf_reset_stats
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_update_stats_counters
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_add_hw_stats
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Register for VLAN events */
name|vsi
operator|->
name|vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|ixl_register_vlan
argument_list|,
name|vsi
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|ixl_unregister_vlan
argument_list|,
name|vsi
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
comment|/* SR-IOV is only supported when MSI-X is in use. */
if|if
condition|(
name|pf
operator|->
name|msix
operator|>
literal|1
condition|)
block|{
name|pf_schema
operator|=
name|pci_iov_schema_alloc_node
argument_list|()
expr_stmt|;
name|vf_schema
operator|=
name|pci_iov_schema_alloc_node
argument_list|()
expr_stmt|;
name|pci_iov_schema_add_unicast_mac
argument_list|(
name|vf_schema
argument_list|,
literal|"mac-addr"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pci_iov_schema_add_bool
argument_list|(
name|vf_schema
argument_list|,
literal|"mac-anti-spoof"
argument_list|,
name|IOV_SCHEMA_HASDEFAULT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pci_iov_schema_add_bool
argument_list|(
name|vf_schema
argument_list|,
literal|"allow-set-mac"
argument_list|,
name|IOV_SCHEMA_HASDEFAULT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pci_iov_schema_add_bool
argument_list|(
name|vf_schema
argument_list|,
literal|"allow-promisc"
argument_list|,
name|IOV_SCHEMA_HASDEFAULT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|iov_error
operator|=
name|pci_iov_attach
argument_list|(
name|dev
argument_list|,
name|pf_schema
argument_list|,
name|vf_schema
argument_list|)
expr_stmt|;
if|if
condition|(
name|iov_error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize SR-IOV (error=%d)\n"
argument_list|,
name|iov_error
argument_list|)
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SR-IOV ready\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|ixl_netmap_attach
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_attach: end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_late
label|:
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|err_mac_hmc
label|:
name|i40e_shutdown_lan_hmc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|err_get_cap
label|:
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|err_out
label|:
name|ixl_free_pci_resources
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_free_vsi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK_DESTROY
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device removal routine  *  *  The detach entry point is called when the driver is being removed.  *  This routine stops the adapter and deallocates all the resources  *  that were allocated for driver operation.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
name|int
name|error
decl_stmt|;
endif|#
directive|endif
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_detach: begin"
argument_list|)
expr_stmt|;
comment|/* Make sure VLANS are not using driver */
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Vlan in use, detach first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|PCI_IOV
name|error
operator|=
name|pci_iov_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SR-IOV in use; detach first.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
name|ether_ifdetach
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixl_stop
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_free_queue_tqs
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Shutdown LAN HMC */
name|status
operator|=
name|i40e_shutdown_lan_hmc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Shutdown LAN HMC failed with code %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Shutdown admin queue */
name|ixl_disable_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixl_free_adminq_tq
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_teardown_adminq_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|status
operator|=
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Shutdown Admin queue failed with code %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Unregister VLAN events */
if|if
condition|(
name|vsi
operator|->
name|vlan_attach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|vsi
operator|->
name|vlan_attach
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|vlan_detach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|vsi
operator|->
name|vlan_detach
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|netmap_detach
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|ixl_free_pci_resources
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ixl_free_vsi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK_DESTROY
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Shutdown entry point  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ixl_stop
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Get the hardware capabilities  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_get_hw_capabilities
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_aqc_list_capabilities_element_resp
modifier|*
name|buf
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
name|u16
name|needed
decl_stmt|;
name|bool
name|again
init|=
name|TRUE
decl_stmt|;
name|len
operator|=
literal|40
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aqc_list_capabilities_element_resp
argument_list|)
expr_stmt|;
name|retry
label|:
if|if
condition|(
operator|!
operator|(
name|buf
operator|=
operator|(
expr|struct
name|i40e_aqc_list_capabilities_element_resp
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate cap memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* This populates the hw struct */
name|error
operator|=
name|i40e_aq_discover_capabilities
argument_list|(
name|hw
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|needed
argument_list|,
name|i40e_aqc_opc_list_func_capabilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|asq_last_status
operator|==
name|I40E_AQ_RC_ENOMEM
operator|)
operator|&&
operator|(
name|again
operator|==
name|TRUE
operator|)
condition|)
block|{
comment|/* retry once with a larger buffer */
name|again
operator|=
name|FALSE
expr_stmt|;
name|len
operator|=
name|needed
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|asq_last_status
operator|!=
name|I40E_AQ_RC_OK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"capability discovery failed: %d\n"
argument_list|,
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Capture this PF's starting queue pair */
name|pf
operator|->
name|qbase
operator|=
name|hw
operator|->
name|func_caps
operator|.
name|base_queue
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"pf_id=%d, num_vfs=%d, msix_pf=%d, "
literal|"msix_vf=%d, fd_g=%d, fd_b=%d, tx_qp=%d rx_qp=%d qbase=%d\n"
argument_list|,
name|hw
operator|->
name|pf_id
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_vfs
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_msix_vectors
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_msix_vectors_vf
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|fd_filters_guaranteed
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|fd_filters_best_effort
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_tx_qp
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_rx_qp
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|base_queue
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_cap_txcsum_tso
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
comment|/* Enable/disable TXCSUM/TSO4 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
comment|/* enable TXCSUM, restore TSO if previously enabled */
if|if
condition|(
name|vsi
operator|->
name|flags
operator|&
name|IXL_FLAGS_KEEP_TSO4
condition|)
block|{
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TSO4 requires txcsum, enabling both...\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TXCSUM
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|vsi
operator|->
name|flags
operator||=
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TSO4 requires txcsum, disabling both...\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
block|}
comment|/* Enable/disable TXCSUM_IPV6/TSO6 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|flags
operator|&
name|IXL_FLAGS_KEEP_TSO6
condition|)
block|{
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO6
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
operator|(
name|IFCAP_TXCSUM_IPV6
operator||
name|IFCAP_TSO6
operator|)
expr_stmt|;
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TSO6 requires txcsum6, enabling both...\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|vsi
operator|->
name|flags
operator||=
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM_IPV6
operator||
name|IFCAP_TSO6
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TSO6 requires txcsum6, disabling both...\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO6
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Ioctl entry point  *  *  ixl_ioctl is called when the user wants to configure the  *  interface.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifdrv
modifier|*
name|ifd
init|=
operator|(
expr|struct
name|ifdrv
operator|*
operator|)
name|data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|bool
name|avoid_reset
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
comment|/* 		** Calling init results in link renegotiation, 		** so we avoid doing it when possible. 		*/
if|if
condition|(
name|avoid_reset
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|ixl_init
argument_list|(
name|pf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
operator|)
condition|)
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCSIFMTU
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|IXL_MAX_FRAME
operator|-
name|ETHER_HDR_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|ETHER_VLAN_ENCAP_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|vsi
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFFLAGS (Set Interface Flags)"
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|pf
operator|->
name|if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
name|ixl_set_promisc
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_init
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_stop
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
block|}
name|pf
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSDRVSPEC
case|:
case|case
name|SIOCGDRVSPEC
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCxDRVSPEC (Get/Set Driver-specific "
literal|"Info)\n"
argument_list|)
expr_stmt|;
comment|/* NVM update command */
if|if
condition|(
name|ifd
operator|->
name|ifd_cmd
operator|==
name|I40E_NVM_ACCESS
condition|)
name|error
operator|=
name|ixl_handle_nvmupd_cmd
argument_list|(
name|pf
argument_list|,
name|ifd
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCADDMULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_disable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_add_multi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_enable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCDELMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCDELMULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_disable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_del_multi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_enable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
ifdef|#
directive|ifdef
name|IFM_ETH_XTYPE
case|case
name|SIOCGIFXMEDIA
case|:
endif|#
directive|endif
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCxIFMEDIA (Get/Set Interface Media)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|mask
init|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFCAP (Set Capabilities)"
argument_list|)
expr_stmt|;
name|ixl_cap_txcsum_tso
argument_list|(
name|vsi
argument_list|,
name|ifp
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: UNKNOWN (0x%X)\n"
argument_list|,
operator|(
name|int
operator|)
name|command
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Init entry point  *  *  This routine is used in two ways. It is used by the stack as  *  init entry point in network interface structure. It is also used  *  by the driver as a hw/sw initialization routine to get to a  *  consistent state.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixl_init_locked
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_filter_control_settings
name|filter
decl_stmt|;
name|u8
name|tmpaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pf
operator|->
name|pf_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_init: begin"
argument_list|)
expr_stmt|;
name|ixl_stop_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Get the latest mac address... User might use a LAA */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
argument_list|,
name|tmpaddr
argument_list|,
name|I40E_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmp_etheraddr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|tmpaddr
argument_list|)
operator|&&
operator|(
name|i40e_validate_mac_addr
argument_list|(
name|tmpaddr
argument_list|)
operator|==
name|I40E_SUCCESS
operator|)
condition|)
block|{
name|ixl_del_filter
argument_list|(
name|vsi
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tmpaddr
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|I40E_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i40e_aq_mac_address_write
argument_list|(
name|hw
argument_list|,
name|I40E_AQC_WRITE_TYPE_LAA_ONLY
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"LLA address"
literal|"change failed!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
comment|/* Set the various hardware offload abilities */
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP_IPV6
operator||
name|CSUM_UDP_IPV6
operator|)
expr_stmt|;
comment|/* Set up the device filtering */
name|bzero
argument_list|(
operator|&
name|filter
argument_list|,
sizeof|sizeof
argument_list|(
name|filter
argument_list|)
argument_list|)
expr_stmt|;
name|filter
operator|.
name|enable_ethtype
operator|=
name|TRUE
expr_stmt|;
name|filter
operator|.
name|enable_macvlan
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_FDIR
name|filter
operator|.
name|enable_fdir
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|filter
operator|.
name|hash_lut_size
operator|=
name|I40E_HASH_LUT_SIZE_512
expr_stmt|;
if|if
condition|(
name|i40e_set_filter_control
argument_list|(
name|hw
argument_list|,
operator|&
name|filter
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_set_filter_control() failed\n"
argument_list|)
expr_stmt|;
comment|/* Set up RSS */
name|ixl_config_rss
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Prepare the VSI: rings, hmc contexts, etc... */
if|if
condition|(
name|ixl_initialize_vsi
argument_list|(
name|vsi
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"initialize vsi failed!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Add protocol filters to list */
name|ixl_init_filters
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Setup vlan's if needed */
name|ixl_setup_vlan_filters
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Set up MSI/X routing and the ITR settings */
if|if
condition|(
name|ixl_enable_msix
condition|)
block|{
name|ixl_configure_queue_intr_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_configure_itr
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
else|else
name|ixl_configure_legacy
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_enable_rings
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|i40e_aq_set_default_vsi
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ixl_reconfigure_filters
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* And now turn on interrupts */
name|ixl_enable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Get link info */
name|hw
operator|->
name|phy
operator|.
name|get_link_info
operator|=
name|TRUE
expr_stmt|;
name|i40e_get_link_status
argument_list|(
name|hw
argument_list|,
operator|&
name|pf
operator|->
name|link_up
argument_list|)
expr_stmt|;
name|ixl_update_link_status
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Set initial advertised speed sysctl value */
name|ixl_get_initial_advertised_speeds
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Start the local timer */
name|callout_reset
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixl_local_timer
argument_list|,
name|pf
argument_list|)
expr_stmt|;
comment|/* Now inform the stack we're ready */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* For the set_advertise sysctl */
end_comment

begin_function
specifier|static
name|void
name|ixl_get_initial_advertised_speeds
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities
decl_stmt|;
comment|/* Set initial sysctl values */
name|status
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|,
name|false
argument_list|,
operator|&
name|abilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
comment|/* Non-fatal error */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: i40e_aq_get_phy_capabilities() error %d\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|abilities
operator|.
name|link_speed
operator|&
name|I40E_LINK_SPEED_40GB
condition|)
name|pf
operator|->
name|advertised_speed
operator||=
literal|0x10
expr_stmt|;
if|if
condition|(
name|abilities
operator|.
name|link_speed
operator|&
name|I40E_LINK_SPEED_20GB
condition|)
name|pf
operator|->
name|advertised_speed
operator||=
literal|0x8
expr_stmt|;
if|if
condition|(
name|abilities
operator|.
name|link_speed
operator|&
name|I40E_LINK_SPEED_10GB
condition|)
name|pf
operator|->
name|advertised_speed
operator||=
literal|0x4
expr_stmt|;
if|if
condition|(
name|abilities
operator|.
name|link_speed
operator|&
name|I40E_LINK_SPEED_1GB
condition|)
name|pf
operator|->
name|advertised_speed
operator||=
literal|0x2
expr_stmt|;
if|if
condition|(
name|abilities
operator|.
name|link_speed
operator|&
name|I40E_LINK_SPEED_100MB
condition|)
name|pf
operator|->
name|advertised_speed
operator||=
literal|0x1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_teardown_hw_structs
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|status
init|=
literal|0
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
comment|/* Shutdown LAN HMC */
if|if
condition|(
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
condition|)
block|{
name|status
operator|=
name|i40e_shutdown_lan_hmc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: LAN HMC shutdown failure; status %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
block|}
comment|// XXX: This gets called when we know the adminq is inactive;
comment|// so we already know it's setup when we get here.
comment|/* Shutdown admin queue */
name|status
operator|=
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: Admin Queue shutdown failure; status %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err_out
label|:
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_reset
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|// XXX: clear_hw() actually writes to hw registers -- maybe this isn't necessary
name|i40e_clear_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_pf_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: PF reset failure"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|error
operator|=
name|i40e_init_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: Admin queue init failure; status code %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|i40e_clear_pxe_mode
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixl_get_hw_capabilities
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: Error retrieving HW capabilities; status code %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|error
operator|=
name|i40e_init_lan_hmc
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_tx_qp
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_rx_qp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: LAN HMC init failed; status code %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|error
operator|=
name|i40e_configure_lan_hmc
argument_list|(
name|hw
argument_list|,
name|I40E_HMC_MODEL_DIRECT_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: LAN HMC config failed; status code %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|// XXX: need to do switch config here?
name|error
operator|=
name|i40e_aq_set_phy_int_mask
argument_list|(
name|hw
argument_list|,
name|IXL_DEFAULT_PHY_INT_MASK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: i40e_aq_set_phy_mask() failed: err %d,"
literal|" aq_err %d\n"
argument_list|,
name|error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|u8
name|set_fc_err_mask
decl_stmt|;
name|error
operator|=
name|i40e_set_fc
argument_list|(
name|hw
argument_list|,
operator|&
name|set_fc_err_mask
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: setting link flow control failed; retcode %d,"
literal|" fc_err_mask 0x%02x\n"
argument_list|,
name|error
argument_list|,
name|set_fc_err_mask
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|// XXX: (Rebuild VSIs?)
comment|/* Firmware delay workaround */
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|aq
operator|.
name|fw_maj_ver
operator|==
literal|4
operator|)
operator|&&
operator|(
name|hw
operator|->
name|aq
operator|.
name|fw_min_ver
operator|<
literal|33
operator|)
operator|)
operator|||
operator|(
name|hw
operator|->
name|aq
operator|.
name|fw_maj_ver
operator|<
literal|4
operator|)
condition|)
block|{
name|i40e_msec_delay
argument_list|(
literal|75
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_aq_set_link_restart_an
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init: link restart failed, aq_err %d\n"
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
block|}
name|err_out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|arg
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * If the aq is dead here, it probably means something outside of the driver 	 * did something to the adapter, like a PF reset. 	 * So rebuild the driver's state here if that occurs. 	 */
if|if
condition|(
operator|!
name|i40e_check_asq_alive
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Admin Queue is down; resetting...\n"
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_teardown_hw_structs
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_reset
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up LAN queue interrupts here. 	 * Kernel interrupt setup functions cannot be called while holding a lock, 	 * so this is done outside of init_locked(). 	 */
if|if
condition|(
name|pf
operator|->
name|msix
operator|>
literal|1
condition|)
block|{
name|error
operator|=
name|ixl_setup_queue_msix
argument_list|(
operator|&
name|pf
operator|->
name|vsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixl_setup_queue_msix() error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixl_setup_queue_tqs
argument_list|(
operator|&
name|pf
operator|->
name|vsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixl_setup_queue_tqs() error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
comment|// possibly broken
name|error
operator|=
name|ixl_assign_vsi_legacy
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"assign_vsi_msix/legacy error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** MSIX Interrupt Handlers and Tasklets */
end_comment

begin_function
specifier|static
name|void
name|ixl_handle_que
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|context
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|bool
name|more
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|more
operator|=
name|ixl_rxeof
argument_list|(
name|que
argument_list|,
name|IXL_RX_LIMIT
argument_list|)
expr_stmt|;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixl_txeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixl_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|task
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Reenable this interrupt - hmmm */
name|ixl_enable_queue
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Legacy Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|arg
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|icr0
decl_stmt|,
name|mask
decl_stmt|;
name|bool
name|more_tx
decl_stmt|,
name|more_rx
decl_stmt|;
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
comment|/* Protect against spurious interrupts */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|icr0
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|reg
operator||
name|I40E_PFINT_DYN_CTL0_CLEARPBA_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|mask
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
if|if
condition|(
name|icr0
operator|&
name|I40E_PFINT_ICR0_VFLR_MASK
condition|)
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|vflr_task
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|icr0
operator|&
name|I40E_PFINT_ICR0_ADMINQ_MASK
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|adminq
argument_list|)
expr_stmt|;
return|return;
block|}
name|more_rx
operator|=
name|ixl_rxeof
argument_list|(
name|que
argument_list|,
name|IXL_RX_LIMIT
argument_list|)
expr_stmt|;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|more_tx
operator|=
name|ixl_txeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|more_tx
operator|=
literal|1
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
comment|/* re-enable other interrupt causes */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* And now the queues */
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_RQCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_QINT_RQCTL_CAUSE_ENA_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_RQCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_TQCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_QINT_TQCTL_CAUSE_ENA_MASK
expr_stmt|;
name|reg
operator|&=
operator|~
name|I40E_PFINT_ICR0_INTEVENT_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_TQCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ixl_enable_legacy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX VSI Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_msix_que
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|arg
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|bool
name|more_tx
decl_stmt|,
name|more_rx
decl_stmt|;
comment|/* Protect against spurious interrupts */
if|if
condition|(
operator|!
operator|(
name|vsi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
name|more_rx
operator|=
name|ixl_rxeof
argument_list|(
name|que
argument_list|,
name|IXL_RX_LIMIT
argument_list|)
expr_stmt|;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|more_tx
operator|=
name|ixl_txeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
comment|/* 	** Make certain that if the stack  	** has anything queued the task gets 	** scheduled to handle it. 	*/
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|more_tx
operator|=
literal|1
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixl_set_queue_rx_itr
argument_list|(
name|que
argument_list|)
expr_stmt|;
name|ixl_set_queue_tx_itr
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|more_tx
operator|||
name|more_rx
condition|)
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|task
argument_list|)
expr_stmt|;
else|else
name|ixl_enable_queue
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX Admin Queue Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixl_msix_adminq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|arg
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|mask
decl_stmt|,
name|rstat_reg
decl_stmt|;
name|bool
name|do_task
init|=
name|FALSE
decl_stmt|;
operator|++
name|pf
operator|->
name|admin_irq
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|)
expr_stmt|;
comment|/* Check on the cause */
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_ADMINQ_MASK
condition|)
block|{
name|mask
operator|&=
operator|~
name|I40E_PFINT_ICR0_ADMINQ_MASK
expr_stmt|;
name|do_task
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_MAL_DETECT_MASK
condition|)
block|{
name|ixl_handle_mdd_event
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|mask
operator|&=
operator|~
name|I40E_PFINT_ICR0_MAL_DETECT_MASK
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_GRST_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Reset Requested!\n"
argument_list|)
expr_stmt|;
name|rstat_reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLGEN_RSTAT
argument_list|)
expr_stmt|;
name|rstat_reg
operator|=
operator|(
name|rstat_reg
operator|&
name|I40E_GLGEN_RSTAT_RESET_TYPE_MASK
operator|)
operator|>>
name|I40E_GLGEN_RSTAT_RESET_TYPE_SHIFT
expr_stmt|;
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Reset type: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rstat_reg
condition|)
block|{
comment|/* These others might be handled similarly to an EMPR reset */
case|case
name|I40E_RESET_CORER
case|:
name|printf
argument_list|(
literal|"CORER\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_RESET_GLOBR
case|:
name|printf
argument_list|(
literal|"GLOBR\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_RESET_EMPR
case|:
name|printf
argument_list|(
literal|"EMPR\n"
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|pf
operator|->
name|state
argument_list|,
name|IXL_PF_STATE_EMPR_RESETTING
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// overload admin queue task to check reset progress?
name|do_task
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_ECC_ERR_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"ECC Error detected!\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_HMC_ERR_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"HMC Error detected!\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_PCI_EXCEPTION_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"PCI Exception detected!\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PCI_IOV
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_VFLR_MASK
condition|)
block|{
name|mask
operator|&=
operator|~
name|I40E_PFINT_ICR0_ENA_VFLR_MASK
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|vflr_task
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|reg
operator||
name|I40E_PFINT_DYN_CTL0_CLEARPBA_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_task
condition|)
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|adminq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called whenever the user queries the status of  *  the interface using ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixl_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_media_status: begin"
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|get_link_info
operator|=
name|TRUE
expr_stmt|;
name|i40e_get_link_status
argument_list|(
name|hw
argument_list|,
operator|&
name|pf
operator|->
name|link_up
argument_list|)
expr_stmt|;
name|ixl_update_link_status
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|pf
operator|->
name|link_up
condition|)
block|{
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
comment|/* Hardware always does full-duplex */
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|phy_type
condition|)
block|{
comment|/* 100 M */
case|case
name|I40E_PHY_TYPE_100BASE_TX
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
break|break;
comment|/* 1 G */
case|case
name|I40E_PHY_TYPE_1000BASE_T
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_1000BASE_SX
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_SX
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_1000BASE_LX
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_LX
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_1000BASE_T_OPTICAL
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_OTHER
expr_stmt|;
break|break;
comment|/* 10 G */
case|case
name|I40E_PHY_TYPE_10GBASE_SFPP_CU
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_TWINAX
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_SR
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_SR
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_LR
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_LR
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_T
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_T
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_XAUI
case|:
case|case
name|I40E_PHY_TYPE_XFI
case|:
case|case
name|I40E_PHY_TYPE_10GBASE_AOC
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_OTHER
expr_stmt|;
break|break;
comment|/* 40 G */
case|case
name|I40E_PHY_TYPE_40GBASE_CR4
case|:
case|case
name|I40E_PHY_TYPE_40GBASE_CR4_CU
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_CR4
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_40GBASE_SR4
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_SR4
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_40GBASE_LR4
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_LR4
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_XLAUI
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_OTHER
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|IFM_ETH_XTYPE
case|case
name|I40E_PHY_TYPE_1000BASE_KX
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_CX
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_SGMII
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_OTHER
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_CR1_CU
case|:
case|case
name|I40E_PHY_TYPE_10GBASE_CR1
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_TWINAX
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_KX4
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_CX4
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_KR
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_SR
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_SFI
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_OTHER
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_40GBASE_KR4
case|:
case|case
name|I40E_PHY_TYPE_XLPPI
case|:
case|case
name|I40E_PHY_TYPE_40GBASE_AOC
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_SR4
expr_stmt|;
break|break;
else|#
directive|else
case|case
name|I40E_PHY_TYPE_1000BASE_KX
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_KX
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_SGMII
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_SGMII
expr_stmt|;
break|break;
comment|/* ERJ: What's the difference between these? */
case|case
name|I40E_PHY_TYPE_10GBASE_CR1_CU
case|:
case|case
name|I40E_PHY_TYPE_10GBASE_CR1
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_CR1
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_KX4
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_KX4
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_KR
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_KR
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_SFI
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_SFI
expr_stmt|;
break|break;
comment|/* Our single 20G media type */
case|case
name|I40E_PHY_TYPE_20GBASE_KR2
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_20G_KR2
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_40GBASE_KR4
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_KR4
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_XLPPI
case|:
case|case
name|I40E_PHY_TYPE_40GBASE_AOC
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_XLPPI
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* Unknown to driver */
default|default:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_UNKNOWN
expr_stmt|;
break|break;
block|}
comment|/* Report flow control status as well */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|an_info
operator|&
name|I40E_AQ_LINK_PAUSE_TX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_ETH_TXPAUSE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|an_info
operator|&
name|I40E_AQ_LINK_PAUSE_RX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_ETH_RXPAUSE
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * NOTE: Fortville does not support forcing media speeds. Instead,  * use the set_advertise sysctl to set the speeds Fortville  * will advertise or be allowed to operate at.  */
end_comment

begin_function
specifier|static
name|int
name|ixl_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|vsi
operator|->
name|media
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_media_change: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Media change is not supported.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_FDIR
end_ifdef

begin_comment
comment|/* ** ATR: Application Targetted Receive - creates a filter **	based on TX flow info that will keep the receive **	portion of the flow on the same queue. Based on the **	implementation this is only available for TCP connections */
end_comment

begin_function
name|void
name|ixl_atr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|int
name|etype
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|i40e_filter_program_desc
modifier|*
name|FDIR
decl_stmt|;
name|u32
name|ptype
decl_stmt|,
name|dtype
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* check if ATR is enabled and sample rate */
if|if
condition|(
operator|(
operator|!
name|ixl_enable_fdir
operator|)
operator|||
operator|(
operator|!
name|txr
operator|->
name|atr_rate
operator|)
condition|)
return|return;
comment|/* 	** We sample all TCP SYN/FIN packets, 	** or at the selected sample rate  	*/
name|txr
operator|->
name|atr_count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_FIN
operator||
name|TH_SYN
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|txr
operator|->
name|atr_count
operator|<
name|txr
operator|->
name|atr_rate
operator|)
condition|)
return|return;
name|txr
operator|->
name|atr_count
operator|=
literal|0
expr_stmt|;
comment|/* Get a descriptor to use */
name|idx
operator|=
name|txr
operator|->
name|next_avail
expr_stmt|;
name|FDIR
operator|=
operator|(
expr|struct
name|i40e_filter_program_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|base
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|idx
operator|==
name|que
operator|->
name|num_desc
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|avail
operator|--
expr_stmt|;
name|txr
operator|->
name|next_avail
operator|=
name|idx
expr_stmt|;
name|ptype
operator|=
operator|(
name|que
operator|->
name|me
operator|<<
name|I40E_TXD_FLTR_QW0_QINDEX_SHIFT
operator|)
operator|&
name|I40E_TXD_FLTR_QW0_QINDEX_MASK
expr_stmt|;
name|ptype
operator||=
operator|(
name|etype
operator|==
name|ETHERTYPE_IP
operator|)
condition|?
operator|(
name|I40E_FILTER_PCTYPE_NONF_IPV4_TCP
operator|<<
name|I40E_TXD_FLTR_QW0_PCTYPE_SHIFT
operator|)
else|:
operator|(
name|I40E_FILTER_PCTYPE_NONF_IPV6_TCP
operator|<<
name|I40E_TXD_FLTR_QW0_PCTYPE_SHIFT
operator|)
expr_stmt|;
name|ptype
operator||=
name|vsi
operator|->
name|id
operator|<<
name|I40E_TXD_FLTR_QW0_DEST_VSI_SHIFT
expr_stmt|;
name|dtype
operator|=
name|I40E_TX_DESC_DTYPE_FILTER_PROG
expr_stmt|;
comment|/* 	** We use the TCP TH_FIN as a trigger to remove 	** the filter, otherwise its an update. 	*/
name|dtype
operator||=
operator|(
name|th
operator|->
name|th_flags
operator|&
name|TH_FIN
operator|)
condition|?
operator|(
name|I40E_FILTER_PROGRAM_DESC_PCMD_REMOVE
operator|<<
name|I40E_TXD_FLTR_QW1_PCMD_SHIFT
operator|)
else|:
operator|(
name|I40E_FILTER_PROGRAM_DESC_PCMD_ADD_UPDATE
operator|<<
name|I40E_TXD_FLTR_QW1_PCMD_SHIFT
operator|)
expr_stmt|;
name|dtype
operator||=
name|I40E_FILTER_PROGRAM_DESC_DEST_DIRECT_PACKET_QINDEX
operator|<<
name|I40E_TXD_FLTR_QW1_DEST_SHIFT
expr_stmt|;
name|dtype
operator||=
name|I40E_FILTER_PROGRAM_DESC_FD_STATUS_FD_ID
operator|<<
name|I40E_TXD_FLTR_QW1_FD_STATUS_SHIFT
expr_stmt|;
name|FDIR
operator|->
name|qindex_flex_ptype_vsi
operator|=
name|htole32
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
name|FDIR
operator|->
name|dtype_cmd_cntindex
operator|=
name|htole32
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ixl_set_promisc
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|int
name|err
decl_stmt|,
name|mcnt
init|=
literal|0
decl_stmt|;
name|bool
name|uni
init|=
name|FALSE
decl_stmt|,
name|multi
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|multi
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
comment|/* Need to count the multicast addresses */
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|mcnt
operator|==
name|MAX_MULTICAST_ADDR
condition|)
break|break;
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mcnt
operator|>=
name|MAX_MULTICAST_ADDR
condition|)
name|multi
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|uni
operator|=
name|TRUE
expr_stmt|;
name|err
operator|=
name|i40e_aq_set_vsi_unicast_promiscuous
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|uni
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|i40e_aq_set_vsi_multicast_promiscuous
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|multi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  * 	Filter Routines  *  *	Routines for multicast and vlan filter management.  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixl_add_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ixl_add_multi: begin"
argument_list|)
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	** First just get a count, to decide if we 	** we simply use multicast promiscuous. 	*/
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|mcnt
operator|>=
name|MAX_MULTICAST_ADDR
argument_list|)
condition|)
block|{
comment|/* delete existing MC filters */
name|ixl_del_hw_filters
argument_list|(
name|vsi
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
name|i40e_aq_set_vsi_multicast_promiscuous
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|mcnt
operator|=
literal|0
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|ixl_add_mc_filter
argument_list|(
name|vsi
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>
literal|0
condition|)
block|{
name|flags
operator|=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator||
name|IXL_FILTER_MC
operator|)
expr_stmt|;
name|ixl_add_hw_filters
argument_list|(
name|vsi
argument_list|,
name|flags
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
block|}
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ixl_add_multi: end"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_del_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|bool
name|match
init|=
name|FALSE
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ixl_del_multi: begin"
argument_list|)
expr_stmt|;
comment|/* Search for removed multicast addresses */
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_USED
operator|)
operator|&&
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_MC
operator|)
condition|)
block|{
name|match
operator|=
name|FALSE
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|u8
modifier|*
name|mc_addr
init|=
operator|(
name|u8
operator|*
operator|)
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp_etheraddr
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|mc_addr
argument_list|)
condition|)
block|{
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|match
operator|==
name|FALSE
condition|)
block|{
name|f
operator|->
name|flags
operator||=
name|IXL_FILTER_DEL
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
block|}
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>
literal|0
condition|)
name|ixl_del_hw_filters
argument_list|(
name|vsi
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Timer routine  *  *  This routine checks for link status,updates statistics,  *  and runs the watchdog check.  *  *  Only runs when the driver is configured UP and RUNNING.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixl_local_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|arg
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|hung
init|=
literal|0
decl_stmt|;
name|u32
name|mask
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pf
operator|->
name|pf_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Fire off the adminq task */
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|adminq
argument_list|)
expr_stmt|;
comment|/* Update stats */
name|ixl_update_stats_counters
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* 	** Check status of the queues 	*/
name|mask
operator|=
operator|(
name|I40E_PFINT_DYN_CTLN_INTENA_MASK
operator||
name|I40E_PFINT_DYN_CTLN_SWINT_TRIG_MASK
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
comment|/* Any queues with outstanding work get a sw irq */
if|if
condition|(
name|que
operator|->
name|busy
condition|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTLN
argument_list|(
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* 		** Each time txeof runs without cleaning, but there 		** are uncleaned descriptors it increments busy. If 		** we get to 5 we declare it hung. 		*/
if|if
condition|(
name|que
operator|->
name|busy
operator|==
name|IXL_QUEUE_HUNG
condition|)
block|{
operator|++
name|hung
expr_stmt|;
comment|/* Mark the queue as inactive */
name|vsi
operator|->
name|active_queues
operator|&=
operator|~
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Check if we've come back from hung */
if|if
condition|(
operator|(
name|vsi
operator|->
name|active_queues
operator|&
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
operator|)
operator|==
literal|0
condition|)
name|vsi
operator|->
name|active_queues
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|que
operator|->
name|busy
operator|>=
name|IXL_MAX_TX_BUSY
condition|)
block|{
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Warning queue %d "
literal|"appears to be hung!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|que
operator|->
name|busy
operator|=
name|IXL_QUEUE_HUNG
expr_stmt|;
operator|++
name|hung
expr_stmt|;
block|}
block|}
comment|/* Only reinit if all queues show hung */
if|if
condition|(
name|hung
operator|==
name|vsi
operator|->
name|num_queues
condition|)
goto|goto
name|hung
goto|;
name|callout_reset
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixl_local_timer
argument_list|,
name|pf
argument_list|)
expr_stmt|;
return|return;
name|hung
label|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Local Timer: HANG DETECT - Resetting!!\n"
argument_list|)
expr_stmt|;
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Note: this routine updates the OS on the link state **	the real check of the hardware only happens with **	a link interrupt. */
end_comment

begin_function
specifier|static
name|void
name|ixl_update_link_status
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|pf
operator|->
name|link_up
condition|)
block|{
if|if
condition|(
name|vsi
operator|->
name|link_active
operator|==
name|FALSE
condition|)
block|{
name|pf
operator|->
name|fc
operator|=
name|hw
operator|->
name|fc
operator|.
name|current_mode
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is up %d Gbps %s,"
literal|" Flow Control: %s\n"
argument_list|,
operator|(
operator|(
name|pf
operator|->
name|link_speed
operator|==
name|I40E_LINK_SPEED_40GB
operator|)
condition|?
literal|40
else|:
literal|10
operator|)
argument_list|,
literal|"Full Duplex"
argument_list|,
name|ixl_fc_string
index|[
name|pf
operator|->
name|fc
index|]
argument_list|)
expr_stmt|;
block|}
name|vsi
operator|->
name|link_active
operator|=
name|TRUE
expr_stmt|;
comment|/* 			** Warn user if link speed on NPAR enabled 			** partition is not at least 10GB 			*/
if|if
condition|(
name|hw
operator|->
name|func_caps
operator|.
name|npar_enable
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|link_speed
operator|==
name|I40E_LINK_SPEED_1GB
operator|||
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|link_speed
operator|==
name|I40E_LINK_SPEED_100MB
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The partition detected"
literal|"link speed that is less than 10Gbps\n"
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Link down */
if|if
condition|(
name|vsi
operator|->
name|link_active
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is Down\n"
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|link_active
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_stop
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_stop_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_teardown_queue_msix
argument_list|(
operator|&
name|pf
operator|->
name|vsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine disables all traffic on the adapter by issuing a  *  global reset on the MAC and deallocates TX/RX buffers.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixl_stop_locked
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_stop: begin\n"
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK_ASSERT
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Stop the local timer */
name|callout_stop
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|)
expr_stmt|;
name|ixl_disable_rings_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_disable_rings
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is no longer active */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup MSIX Interrupt resources and handlers for the VSI  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_assign_vsi_legacy
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pf
operator|->
name|msix
operator|==
literal|1
condition|)
name|rid
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: vsi legacy/msi interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixl_intr
argument_list|,
name|pf
argument_list|,
operator|&
name|pf
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pf
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register legacy/msi handler\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|pf
operator|->
name|tag
argument_list|,
literal|"irq0"
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|tx_task
argument_list|,
literal|0
argument_list|,
name|ixl_deferred_mq_start
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|ixl_handle_que
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixl_que"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s que"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|pf
operator|->
name|adminq
argument_list|,
literal|0
argument_list|,
name|ixl_do_adminq
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|pf
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixl_adm"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|pf
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|pf
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s adminq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_setup_adminq_tq
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Tasklet for Admin Queue interrupts */
name|TASK_INIT
argument_list|(
operator|&
name|pf
operator|->
name|adminq
argument_list|,
literal|0
argument_list|,
name|ixl_do_adminq
argument_list|,
name|pf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
comment|/* VFLR Tasklet */
name|TASK_INIT
argument_list|(
operator|&
name|pf
operator|->
name|vflr_task
argument_list|,
literal|0
argument_list|,
name|ixl_handle_vflr
argument_list|,
name|pf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create and start Admin Queue taskqueue */
name|pf
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixl_aq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|pf
operator|->
name|tq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf
operator|->
name|tq
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"taskqueue_create_fast (for AQ) returned NULL!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|taskqueue_start_threads
argument_list|(
operator|&
name|pf
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s aq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"taskqueue_start_threads (for AQ) error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|pf
operator|->
name|tq
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_setup_queue_tqs
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
comment|/* Create queue tasks and start queue taskqueues */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|tx_task
argument_list|,
literal|0
argument_list|,
name|ixl_deferred_mq_start
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|ixl_handle_que
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixl_que"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|CPU_SETOF
argument_list|(
name|cpu_id
argument_list|,
operator|&
name|cpu_mask
argument_list|)
expr_stmt|;
name|taskqueue_start_threads_cpuset
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
operator|&
name|cpu_mask
argument_list|,
literal|"%s (bucket %d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
else|#
directive|else
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s (que %d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_free_adminq_tq
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
if|if
condition|(
name|pf
operator|->
name|tq
condition|)
name|taskqueue_free
argument_list|(
name|pf
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_free_queue_tqs
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
if|if
condition|(
name|que
operator|->
name|tq
condition|)
name|taskqueue_free
argument_list|(
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_setup_adminq_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
comment|/* Admin IRQ rid is 1, vector is 0 */
name|rid
operator|=
literal|1
expr_stmt|;
comment|/* Get interrupt resource from bus */
name|pf
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf
operator|->
name|res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_alloc_resource_any() for Admin Queue"
literal|" interrupt failed [rid=%d]\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Then associate interrupt with handler */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixl_msix_adminq
argument_list|,
name|pf
argument_list|,
operator|&
name|pf
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pf
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_setup_intr() for Admin Queue"
literal|" interrupt handler failed, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|pf
operator|->
name|tag
argument_list|,
literal|"aq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Probably non-fatal? */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_describe_intr() for Admin Queue"
literal|" interrupt name failed, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|pf
operator|->
name|admvec
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate interrupt resources from bus and associate an interrupt handler  * to those for the VSI's queues.  */
end_comment

begin_function
specifier|static
name|int
name|ixl_setup_queue_msix
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|vector
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|cpuset_t
name|cpu_mask
decl_stmt|;
endif|#
directive|endif
comment|/* Queue interrupt vector numbers start at 1 (adminq intr is 0) */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|int
name|cpu_id
init|=
name|i
decl_stmt|;
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
name|que
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|que
operator|->
name|res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_alloc_resource_any() for"
literal|" Queue %d interrupt failed [rid=%d]\n"
argument_list|,
name|que
operator|->
name|me
argument_list|,
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixl_msix_que
argument_list|,
name|que
argument_list|,
operator|&
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_setup_intr() for Queue %d"
literal|" interrupt handler failed, error %d\n"
argument_list|,
name|que
operator|->
name|me
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|// TODO: Check for error from this?
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|que
operator|->
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|,
literal|"que%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_describe_intr() for Queue %d"
literal|" interrupt name failed, error %d\n"
argument_list|,
name|que
operator|->
name|me
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Bind the vector to a CPU */
ifdef|#
directive|ifdef
name|RSS
name|cpu_id
operator|=
name|rss_getcpu
argument_list|(
name|i
operator|%
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|bus_bind_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_bind_intr() for Queue %d"
literal|" to CPU %d failed, error %d\n"
argument_list|,
name|que
operator|->
name|me
argument_list|,
name|cpu_id
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|que
operator|->
name|msix
operator|=
name|vector
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate MSI/X vectors  */
end_comment

begin_function
specifier|static
name|int
name|ixl_init_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|want
decl_stmt|,
name|vectors
decl_stmt|,
name|queues
decl_stmt|,
name|available
decl_stmt|;
comment|/* Override by tuneable */
if|if
condition|(
name|ixl_enable_msix
operator|==
literal|0
condition|)
goto|goto
name|no_msix
goto|;
comment|/* 	** When used in a virtualized environment  	** PCI BUSMASTER capability may not be set 	** so explicity set it here and rewrite 	** the ENABLE in the MSIX control register 	** at this point to cause the host to 	** successfully initialize us. 	*/
block|{
name|u16
name|pci_cmd_word
decl_stmt|;
name|int
name|msix_ctrl
decl_stmt|;
name|pci_cmd_word
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_cmd_word
operator||=
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|pci_cmd_word
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_MSIX
argument_list|,
operator|&
name|rid
argument_list|)
expr_stmt|;
name|rid
operator|+=
name|PCIR_MSIX_CTRL
expr_stmt|;
name|msix_ctrl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|msix_ctrl
operator||=
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* First try MSI/X */
name|rid
operator|=
name|PCIR_BAR
argument_list|(
name|IXL_BAR
argument_list|)
expr_stmt|;
name|pf
operator|->
name|msix_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf
operator|->
name|msix_mem
condition|)
block|{
comment|/* May not be enabled */
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Unable to map MSIX table\n"
argument_list|)
expr_stmt|;
goto|goto
name|no_msix
goto|;
block|}
name|available
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|available
operator|==
literal|0
condition|)
block|{
comment|/* system has msix disabled */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|pf
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
name|pf
operator|->
name|msix_mem
operator|=
name|NULL
expr_stmt|;
goto|goto
name|no_msix
goto|;
block|}
comment|/* Figure out a reasonable auto config value */
name|queues
operator|=
operator|(
name|mp_ncpus
operator|>
operator|(
name|available
operator|-
literal|1
operator|)
operator|)
condition|?
operator|(
name|available
operator|-
literal|1
operator|)
else|:
name|mp_ncpus
expr_stmt|;
comment|/* Override with tunable value if tunable is less than autoconfig count */
if|if
condition|(
operator|(
name|ixl_max_queues
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ixl_max_queues
operator|<=
name|queues
operator|)
condition|)
name|queues
operator|=
name|ixl_max_queues
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ixl_max_queues
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ixl_max_queues
operator|>
name|queues
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixl_max_queues> # of cpus, using "
literal|"autoconfig amount...\n"
argument_list|)
expr_stmt|;
comment|/* Or limit maximum auto-configured queues to 8 */
elseif|else
if|if
condition|(
operator|(
name|ixl_max_queues
operator|==
literal|0
operator|)
operator|&&
operator|(
name|queues
operator|>
literal|8
operator|)
condition|)
name|queues
operator|=
literal|8
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* If we're doing RSS, clamp at the number of RSS buckets */
if|if
condition|(
name|queues
operator|>
name|rss_getnumbuckets
argument_list|()
condition|)
name|queues
operator|=
name|rss_getnumbuckets
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Want one vector (RX/TX pair) per queue 	** plus an additional for the admin queue. 	*/
name|want
operator|=
name|queues
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|want
operator|<=
name|available
condition|)
comment|/* Have enough */
name|vectors
operator|=
name|want
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"MSIX Configuration Problem, "
literal|"%d vectors available but %d wanted!\n"
argument_list|,
name|available
argument_list|,
name|want
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Will go to Legacy setup */
block|}
if|if
condition|(
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|vectors
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Using MSIX interrupts with %d vectors\n"
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
name|pf
operator|->
name|msix
operator|=
name|vectors
expr_stmt|;
name|pf
operator|->
name|vsi
operator|.
name|num_queues
operator|=
name|queues
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* 		 * If we're doing RSS, the number of queues needs to 		 * match the number of RSS buckets that are configured. 		 * 		 * + If there's more queues than RSS buckets, we'll end 		 *   up with queues that get no traffic. 		 * 		 * + If there's more RSS buckets than queues, we'll end 		 *   up having multiple RSS buckets map to the same queue, 		 *   so there'll be some contention. 		 */
if|if
condition|(
name|queues
operator|!=
name|rss_getnumbuckets
argument_list|()
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: queues (%d) != RSS buckets (%d)"
literal|"; performance will be impacted.\n"
argument_list|,
name|__func__
argument_list|,
name|queues
argument_list|,
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|vectors
operator|)
return|;
block|}
name|no_msix
label|:
name|vectors
operator|=
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pf
operator|->
name|vsi
operator|.
name|num_queues
operator|=
literal|1
expr_stmt|;
name|ixl_max_queues
operator|=
literal|1
expr_stmt|;
name|ixl_enable_msix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vectors
operator|==
literal|1
operator|&&
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|vectors
argument_list|)
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Using an MSI interrupt\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|vectors
operator|=
literal|0
expr_stmt|;
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Using a Legacy interrupt\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|vectors
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Configure admin queue/misc interrupt cause registers in hardware.  */
end_comment

begin_function
specifier|static
name|void
name|ixl_configure_intr0_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|;
comment|/* First set up the adminq - vector 0 */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable all */
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0
argument_list|)
expr_stmt|;
comment|/* read to clear */
name|reg
operator|=
name|I40E_PFINT_ICR0_ENA_ECC_ERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_GRST_MASK
operator||
name|I40E_PFINT_ICR0_ENA_HMC_ERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_ADMINQ_MASK
operator||
name|I40E_PFINT_ICR0_ENA_MAL_DETECT_MASK
operator||
name|I40E_PFINT_ICR0_ENA_VFLR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_PCI_EXCEPTION_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* 	 * 0x7FF is the end of the queue list. 	 * This means we won't use MSI-X vector 0 for a queue interrupt 	 * in MSIX mode. 	 */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_LNKLST0
argument_list|,
literal|0x7FF
argument_list|)
expr_stmt|;
comment|/* Value is in 2 usec units, so 0x3E is 62*2 = 124 usecs. */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITR0
argument_list|(
name|IXL_RX_ITR
argument_list|)
argument_list|,
literal|0x3E
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|I40E_PFINT_DYN_CTL0_SW_ITR_INDX_MASK
operator||
name|I40E_PFINT_DYN_CTL0_INTENA_MSK_MASK
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_STAT_CTL0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Configure queue interrupt cause registers in hardware.  */
end_comment

begin_function
specifier|static
name|void
name|ixl_configure_queue_intr_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|u16
name|vector
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
control|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTLN
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_LNKLSTN
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I40E_QINT_RQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|IXL_RX_ITR
operator|<<
name|I40E_QINT_RQCTL_ITR_INDX_SHIFT
operator|)
operator||
operator|(
name|vector
operator|<<
name|I40E_QINT_RQCTL_MSIX_INDX_SHIFT
operator|)
operator||
operator|(
name|i
operator|<<
name|I40E_QINT_RQCTL_NEXTQ_INDX_SHIFT
operator|)
operator||
operator|(
name|I40E_QUEUE_TYPE_TX
operator|<<
name|I40E_QINT_RQCTL_NEXTQ_TYPE_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_RQCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I40E_QINT_TQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|IXL_TX_ITR
operator|<<
name|I40E_QINT_TQCTL_ITR_INDX_SHIFT
operator|)
operator||
operator|(
name|vector
operator|<<
name|I40E_QINT_TQCTL_MSIX_INDX_SHIFT
operator|)
operator||
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|I40E_QINT_TQCTL_NEXTQ_INDX_SHIFT
operator|)
operator||
operator|(
name|I40E_QUEUE_TYPE_RX
operator|<<
name|I40E_QINT_TQCTL_NEXTQ_TYPE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|vsi
operator|->
name|num_queues
operator|-
literal|1
operator|)
condition|)
name|reg
operator||=
operator|(
name|IXL_QUEUE_EOL
operator|<<
name|I40E_QINT_TQCTL_NEXTQ_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_TQCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Configure for MSI single vector operation   */
end_comment

begin_function
specifier|static
name|void
name|ixl_configure_legacy
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITR0
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITR0
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup "other" causes */
name|reg
operator|=
name|I40E_PFINT_ICR0_ENA_ECC_ERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_MAL_DETECT_MASK
operator||
name|I40E_PFINT_ICR0_ENA_GRST_MASK
operator||
name|I40E_PFINT_ICR0_ENA_PCI_EXCEPTION_MASK
operator||
name|I40E_PFINT_ICR0_ENA_GPIO_MASK
operator||
name|I40E_PFINT_ICR0_ENA_LINK_STAT_CHANGE_MASK
operator||
name|I40E_PFINT_ICR0_ENA_HMC_ERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_PE_CRITERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_VFLR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_ADMINQ_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* SW_ITR_IDX = 0, but don't change INTENA */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|I40E_PFINT_DYN_CTLN_SW_ITR_INDX_MASK
operator||
name|I40E_PFINT_DYN_CTLN_INTENA_MSK_MASK
argument_list|)
expr_stmt|;
comment|/* SW_ITR_IDX = 0, OTHER_ITR_IDX = 0 */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_STAT_CTL0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIRSTQ_INDX = 0, FIRSTQ_TYPE = 0 (rx) */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_LNKLST0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Associate the queue pair to the vector and enable the q int */
name|reg
operator|=
name|I40E_QINT_RQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|IXL_RX_ITR
operator|<<
name|I40E_QINT_RQCTL_ITR_INDX_SHIFT
operator|)
operator||
operator|(
name|I40E_QUEUE_TYPE_TX
operator|<<
name|I40E_QINT_TQCTL_NEXTQ_TYPE_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_RQCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I40E_QINT_TQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|IXL_TX_ITR
operator|<<
name|I40E_QINT_TQCTL_ITR_INDX_SHIFT
operator|)
operator||
operator|(
name|IXL_QUEUE_EOL
operator|<<
name|I40E_QINT_TQCTL_NEXTQ_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_TQCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the Initial ITR state  */
end_comment

begin_function
specifier|static
name|void
name|ixl_configure_itr
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|vsi
operator|->
name|rx_itr_setting
operator|=
name|ixl_rx_itr
expr_stmt|;
if|if
condition|(
name|ixl_dynamic_rx_itr
condition|)
name|vsi
operator|->
name|rx_itr_setting
operator||=
name|IXL_ITR_DYNAMIC
expr_stmt|;
name|vsi
operator|->
name|tx_itr_setting
operator|=
name|ixl_tx_itr
expr_stmt|;
if|if
condition|(
name|ixl_dynamic_tx_itr
condition|)
name|vsi
operator|->
name|tx_itr_setting
operator||=
name|IXL_ITR_DYNAMIC
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_RX_ITR
argument_list|,
name|i
argument_list|)
argument_list|,
name|vsi
operator|->
name|rx_itr_setting
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|rx_itr_setting
expr_stmt|;
name|rxr
operator|->
name|latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_TX_ITR
argument_list|,
name|i
argument_list|)
argument_list|,
name|vsi
operator|->
name|tx_itr_setting
argument_list|)
expr_stmt|;
name|txr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|tx_itr_setting
expr_stmt|;
name|txr
operator|->
name|latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_allocate_pci_resources
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pf
operator|->
name|pci_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pf
operator|->
name|pci_mem
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: PCI memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|pf
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|pf
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|pf
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|pf
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|pf
operator|->
name|osdep
operator|.
name|mem_bus_space_size
operator|=
name|rman_get_size
argument_list|(
name|pf
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|pf
operator|->
name|osdep
operator|.
name|flush_reg
operator|=
name|I40E_GLGEN_STAT
expr_stmt|;
name|pf
operator|->
name|hw
operator|.
name|hw_addr
operator|=
operator|(
name|u8
operator|*
operator|)
operator|&
name|pf
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
expr_stmt|;
name|pf
operator|->
name|hw
operator|.
name|back
operator|=
operator|&
name|pf
operator|->
name|osdep
expr_stmt|;
comment|/* 	** Now setup MSI or MSI/X, should 	** return us the number of supported 	** vectors. (Will be 1 for MSI) 	*/
name|pf
operator|->
name|msix
operator|=
name|ixl_init_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Teardown and release the admin queue/misc vector  * interrupt.  */
end_comment

begin_function
specifier|static
name|int
name|ixl_teardown_adminq_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
if|if
condition|(
name|pf
operator|->
name|admvec
condition|)
comment|/* we are doing MSIX */
name|rid
operator|=
name|pf
operator|->
name|admvec
operator|+
literal|1
expr_stmt|;
else|else
operator|(
name|pf
operator|->
name|msix
operator|!=
literal|0
operator|)
condition|?
operator|(
name|rid
operator|=
literal|1
operator|)
else|:
operator|(
name|rid
operator|=
literal|0
operator|)
expr_stmt|;
comment|// TODO: Check for errors from bus_teardown_intr
comment|// TODO: Check for errors from bus_release_resource
if|if
condition|(
name|pf
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|pf
operator|->
name|tag
argument_list|)
expr_stmt|;
name|pf
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|pf
operator|->
name|res
argument_list|)
expr_stmt|;
name|pf
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_teardown_queue_msix
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
comment|/* We may get here before stations are setup */
if|if
condition|(
operator|(
operator|!
name|ixl_enable_msix
operator|)
operator|||
operator|(
name|que
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Release all MSIX queue resources */
comment|// TODO: Check for errors from bus_teardown_intr
comment|// TODO: Check for errors from bus_release_resource
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|rid
operator|=
name|que
operator|->
name|msix
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|que
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
name|que
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|que
operator|->
name|res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|que
operator|->
name|res
argument_list|)
expr_stmt|;
name|que
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_free_pci_resources
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|memrid
decl_stmt|;
name|ixl_teardown_queue_msix
argument_list|(
operator|&
name|pf
operator|->
name|vsi
argument_list|)
expr_stmt|;
name|ixl_teardown_adminq_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|msix
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|memrid
operator|=
name|PCIR_BAR
argument_list|(
name|IXL_BAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|memrid
argument_list|,
name|pf
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|pci_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|pf
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_add_ifmedia
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|u32
name|phy_type
parameter_list|)
block|{
comment|/* Display supported media types */
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_100BASE_TX
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_1000BASE_T
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_1000BASE_SX
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_1000BASE_LX
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_LX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_XAUI
operator|)
operator|||
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_XFI
operator|)
operator|||
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_SFPP_CU
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_TWINAX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_SR
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_SR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_LR
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_LR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_T
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_40GBASE_CR4
operator|)
operator|||
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_40GBASE_CR4_CU
operator|)
operator|||
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_40GBASE_AOC
operator|)
operator|||
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_XLAUI
operator|)
operator|||
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_40GBASE_KR4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_CR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_40GBASE_SR4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_SR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_40GBASE_LR4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_LR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IFM_ETH_XTYPE
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_1000BASE_KX
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_CX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_CR1_CU
operator|)
operator|||
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_CR1
operator|)
operator|||
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_AOC
operator|)
operator|||
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_SFI
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_TWINAX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_KX4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_CX4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_KR
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_SR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_40GBASE_KR4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_SR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_XLPPI
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_CR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_1000BASE_KX
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_KX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_CR1_CU
operator|)
operator|||
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_CR1
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_CR1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_AOC
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_TWINAX_LONG
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_SFI
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_SFI
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_KX4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_KX4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_KR
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_KR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_20GBASE_KR2
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_20G_KR2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_40GBASE_KR4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_KR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_XLPPI
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_XLPPI
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup networking device structure and register an interface.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_setup_interface
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities
decl_stmt|;
name|enum
name|i40e_status_code
name|aq_error
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_setup_interface: begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|vsi
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Gbps
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ixl_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|vsi
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ixl_ioctl
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100036
name|if_setgetcounterfn
argument_list|(
name|ifp
argument_list|,
name|ixl_get_counter
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_transmit
operator|=
name|ixl_mq_start
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|ixl_qflush
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|que
operator|->
name|num_desc
operator|-
literal|2
expr_stmt|;
name|vsi
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM_IPV6
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_JUMBO_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_LRO
expr_stmt|;
comment|/* VLAN capabilties */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	** Don't turn this on by default, if vlans are 	** created on another pseudo device (eg. lagg) 	** then vlan events are not passed thru, breaking 	** operation, but with HW FILTER off it works. If 	** using vlans directly on the ixl driver you can 	** enable this and get full hardware tag filtering. 	*/
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
name|ifmedia_init
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|ixl_media_change
argument_list|,
name|ixl_media_status
argument_list|)
expr_stmt|;
name|aq_error
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|&
name|abilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* May need delay to detect fiber correctly */
if|if
condition|(
name|aq_error
operator|==
name|I40E_ERR_UNKNOWN_PHY
condition|)
block|{
name|i40e_msec_delay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|aq_error
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|&
name|abilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aq_error
condition|)
block|{
if|if
condition|(
name|aq_error
operator|==
name|I40E_ERR_UNKNOWN_PHY
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unknown PHY type detected!\n"
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error getting supported media types, err %d,"
literal|" AQ error %d\n"
argument_list|,
name|aq_error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ixl_add_ifmedia
argument_list|(
name|vsi
argument_list|,
name|abilities
operator|.
name|phy_type
argument_list|)
expr_stmt|;
comment|/* Use autoselect media by default */
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Run when the Admin Queue gets a link state change interrupt. */
end_comment

begin_function
specifier|static
name|void
name|ixl_link_event
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|i40e_arq_event_info
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_aqc_get_link_status
modifier|*
name|status
init|=
operator|(
expr|struct
name|i40e_aqc_get_link_status
operator|*
operator|)
operator|&
name|e
operator|->
name|desc
operator|.
name|params
operator|.
name|raw
decl_stmt|;
comment|/* Request link status from adapter */
name|hw
operator|->
name|phy
operator|.
name|get_link_info
operator|=
name|TRUE
expr_stmt|;
name|i40e_get_link_status
argument_list|(
name|hw
argument_list|,
operator|&
name|pf
operator|->
name|link_up
argument_list|)
expr_stmt|;
comment|/* Print out message if an unqualified module is found */
if|if
condition|(
operator|(
name|status
operator|->
name|link_info
operator|&
name|I40E_AQ_MEDIA_AVAILABLE
operator|)
operator|&&
operator|(
operator|!
operator|(
name|status
operator|->
name|an_info
operator|&
name|I40E_AQ_QUALIFIED_MODULE
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|status
operator|->
name|link_info
operator|&
name|I40E_AQ_LINK_UP
operator|)
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link failed because "
literal|"an unqualified module was detected!\n"
argument_list|)
expr_stmt|;
comment|/* Update OS link info */
name|ixl_update_link_status
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Get Firmware Switch configuration  *	- this will need to be more robust when more complex  *	  switch configurations are enabled.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_switch_config
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_aqc_get_switch_config_resp
modifier|*
name|sw_config
decl_stmt|;
name|u8
name|aq_buf
index|[
name|I40E_AQ_LARGE_BUF
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|u16
name|next
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|aq_buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|aq_buf
argument_list|)
argument_list|)
expr_stmt|;
name|sw_config
operator|=
operator|(
expr|struct
name|i40e_aqc_get_switch_config_resp
operator|*
operator|)
name|aq_buf
expr_stmt|;
name|ret
operator|=
name|i40e_aq_get_switch_config
argument_list|(
name|hw
argument_list|,
name|sw_config
argument_list|,
sizeof|sizeof
argument_list|(
name|aq_buf
argument_list|)
argument_list|,
operator|&
name|next
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"aq_get_switch_config failed (ret=%d)!!\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Switch config: header reported: %d in structure, %d total\n"
argument_list|,
name|sw_config
operator|->
name|header
operator|.
name|num_reported
argument_list|,
name|sw_config
operator|->
name|header
operator|.
name|num_total
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sw_config
operator|->
name|header
operator|.
name|num_reported
condition|;
name|i
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%d: type=%d seid=%d uplink=%d downlink=%d\n"
argument_list|,
name|i
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|element_type
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|seid
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|uplink_seid
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|downlink_seid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Simplified due to a single VSI at the moment */
name|vsi
operator|->
name|uplink_seid
operator|=
name|sw_config
operator|->
name|element
index|[
literal|0
index|]
operator|.
name|uplink_seid
expr_stmt|;
name|vsi
operator|->
name|downlink_seid
operator|=
name|sw_config
operator|->
name|element
index|[
literal|0
index|]
operator|.
name|downlink_seid
expr_stmt|;
name|vsi
operator|->
name|seid
operator|=
name|sw_config
operator|->
name|element
index|[
literal|0
index|]
operator|.
name|seid
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize the VSI:  this handles contexts, which means things  *  			 like the number of descriptors, buffer size,  *			 plus we init the rings thru this function.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_initialize_vsi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_vsi_context
name|ctxt
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ctxt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctxt
argument_list|)
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|seid
operator|=
name|vsi
operator|->
name|seid
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|veb_seid
operator|!=
literal|0
condition|)
name|ctxt
operator|.
name|uplink_seid
operator|=
name|pf
operator|->
name|veb_seid
expr_stmt|;
name|ctxt
operator|.
name|pf_num
operator|=
name|hw
operator|->
name|pf_id
expr_stmt|;
name|err
operator|=
name|i40e_aq_get_vsi_params
argument_list|(
name|hw
argument_list|,
operator|&
name|ctxt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_aq_get_vsi_params() failed, error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"get_vsi_params: seid: %d, uplinkseid: %d, vsi_number: %d, "
literal|"vsis_allocated: %d, vsis_unallocated: %d, flags: 0x%x, "
literal|"pfnum: %d, vfnum: %d, stat idx: %d, enabled: %d\n"
argument_list|,
name|ctxt
operator|.
name|seid
argument_list|,
name|ctxt
operator|.
name|uplink_seid
argument_list|,
name|ctxt
operator|.
name|vsi_number
argument_list|,
name|ctxt
operator|.
name|vsis_allocated
argument_list|,
name|ctxt
operator|.
name|vsis_unallocated
argument_list|,
name|ctxt
operator|.
name|flags
argument_list|,
name|ctxt
operator|.
name|pf_num
argument_list|,
name|ctxt
operator|.
name|vf_num
argument_list|,
name|ctxt
operator|.
name|info
operator|.
name|stat_counter_idx
argument_list|,
name|ctxt
operator|.
name|info
operator|.
name|up_enable_bits
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Set the queue and traffic class bits 	**  - when multiple traffic classes are supported 	**    this will need to be more robust. 	*/
name|ctxt
operator|.
name|info
operator|.
name|valid_sections
operator|=
name|I40E_AQ_VSI_PROP_QUEUE_MAP_VALID
expr_stmt|;
name|ctxt
operator|.
name|info
operator|.
name|mapping_flags
operator||=
name|I40E_AQ_VSI_QUE_MAP_CONTIG
expr_stmt|;
name|ctxt
operator|.
name|info
operator|.
name|queue_mapping
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* This VSI is assigned 64 queues (we may not use all of them) */
name|ctxt
operator|.
name|info
operator|.
name|tc_mapping
index|[
literal|0
index|]
operator|=
literal|0x0c00
expr_stmt|;
comment|/* Set VLAN receive stripping mode */
name|ctxt
operator|.
name|info
operator|.
name|valid_sections
operator||=
name|I40E_AQ_VSI_PROP_VLAN_VALID
expr_stmt|;
name|ctxt
operator|.
name|info
operator|.
name|port_vlan_flags
operator|=
name|I40E_AQ_VSI_PVLAN_MODE_ALL
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ctxt
operator|.
name|info
operator|.
name|port_vlan_flags
operator||=
name|I40E_AQ_VSI_PVLAN_EMOD_STR_BOTH
expr_stmt|;
else|else
name|ctxt
operator|.
name|info
operator|.
name|port_vlan_flags
operator||=
name|I40E_AQ_VSI_PVLAN_EMOD_NOTHING
expr_stmt|;
comment|/* Keep copy of VSI info in VSI for statistic counters */
name|memcpy
argument_list|(
operator|&
name|vsi
operator|->
name|info
argument_list|,
operator|&
name|ctxt
operator|.
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|ctxt
operator|.
name|info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reset VSI statistics */
name|ixl_vsi_reset_stats
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|hw_filters_add
operator|=
literal|0
expr_stmt|;
name|vsi
operator|->
name|hw_filters_del
operator|=
literal|0
expr_stmt|;
name|ctxt
operator|.
name|flags
operator|=
name|htole16
argument_list|(
name|I40E_AQ_VSI_TYPE_PF
argument_list|)
expr_stmt|;
name|err
operator|=
name|i40e_aq_update_vsi_params
argument_list|(
name|hw
argument_list|,
operator|&
name|ctxt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_aq_update_vsi_params() failed, error %d, aq_error %d\n"
argument_list|,
name|err
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|i40e_hmc_obj_txq
name|tctx
decl_stmt|;
name|struct
name|i40e_hmc_obj_rxq
name|rctx
decl_stmt|;
name|u32
name|txctl
decl_stmt|;
name|u16
name|size
decl_stmt|;
comment|/* Setup the HMC TX Context  */
name|size
operator|=
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_tx_desc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hmc_obj_txq
argument_list|)
argument_list|)
expr_stmt|;
name|tctx
operator|.
name|new_context
operator|=
literal|1
expr_stmt|;
name|tctx
operator|.
name|base
operator|=
operator|(
name|txr
operator|->
name|dma
operator|.
name|pa
operator|/
name|IXL_TX_CTX_BASE_UNITS
operator|)
expr_stmt|;
name|tctx
operator|.
name|qlen
operator|=
name|que
operator|->
name|num_desc
expr_stmt|;
name|tctx
operator|.
name|fc_ena
operator|=
literal|0
expr_stmt|;
name|tctx
operator|.
name|rdylist
operator|=
name|vsi
operator|->
name|info
operator|.
name|qs_handle
index|[
literal|0
index|]
expr_stmt|;
comment|/* index is TC */
comment|/* Enable HEAD writeback */
name|tctx
operator|.
name|head_wb_ena
operator|=
literal|1
expr_stmt|;
name|tctx
operator|.
name|head_wb_addr
operator|=
name|txr
operator|->
name|dma
operator|.
name|pa
operator|+
operator|(
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_tx_desc
argument_list|)
operator|)
expr_stmt|;
name|tctx
operator|.
name|rdylist_act
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|i40e_clear_lan_tx_queue_context
argument_list|(
name|hw
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to clear TX context\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|i40e_set_lan_tx_queue_context
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|tctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to set TX context\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Associate the ring with this PF */
name|txctl
operator|=
name|I40E_QTX_CTL_PF_QUEUE
expr_stmt|;
name|txctl
operator||=
operator|(
operator|(
name|hw
operator|->
name|pf_id
operator|<<
name|I40E_QTX_CTL_PF_INDX_SHIFT
operator|)
operator|&
name|I40E_QTX_CTL_PF_INDX_MASK
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_CTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|txctl
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Do ring (re)init */
name|ixl_init_tx_ring
argument_list|(
name|que
argument_list|)
expr_stmt|;
comment|/* Next setup the HMC RX Context  */
if|if
condition|(
name|vsi
operator|->
name|max_frame_size
operator|<=
name|MCLBYTES
condition|)
name|rxr
operator|->
name|mbuf_sz
operator|=
name|MCLBYTES
expr_stmt|;
else|else
name|rxr
operator|->
name|mbuf_sz
operator|=
name|MJUMPAGESIZE
expr_stmt|;
name|u16
name|max_rxmax
init|=
name|rxr
operator|->
name|mbuf_sz
operator|*
name|hw
operator|->
name|func_caps
operator|.
name|rx_buf_chain_len
decl_stmt|;
comment|/* Set up an RX context for the HMC */
name|memset
argument_list|(
operator|&
name|rctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hmc_obj_rxq
argument_list|)
argument_list|)
expr_stmt|;
name|rctx
operator|.
name|dbuff
operator|=
name|rxr
operator|->
name|mbuf_sz
operator|>>
name|I40E_RXQ_CTX_DBUFF_SHIFT
expr_stmt|;
comment|/* ignore header split for now */
name|rctx
operator|.
name|hbuff
operator|=
literal|0
operator|>>
name|I40E_RXQ_CTX_HBUFF_SHIFT
expr_stmt|;
name|rctx
operator|.
name|rxmax
operator|=
operator|(
name|vsi
operator|->
name|max_frame_size
operator|<
name|max_rxmax
operator|)
condition|?
name|vsi
operator|->
name|max_frame_size
else|:
name|max_rxmax
expr_stmt|;
name|rctx
operator|.
name|dtype
operator|=
literal|0
expr_stmt|;
name|rctx
operator|.
name|dsize
operator|=
literal|1
expr_stmt|;
comment|/* do 32byte descriptors */
name|rctx
operator|.
name|hsplit_0
operator|=
literal|0
expr_stmt|;
comment|/* no HDR split initially */
name|rctx
operator|.
name|base
operator|=
operator|(
name|rxr
operator|->
name|dma
operator|.
name|pa
operator|/
name|IXL_RX_CTX_BASE_UNITS
operator|)
expr_stmt|;
name|rctx
operator|.
name|qlen
operator|=
name|que
operator|->
name|num_desc
expr_stmt|;
name|rctx
operator|.
name|tphrdesc_ena
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|tphwdesc_ena
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|tphdata_ena
operator|=
literal|0
expr_stmt|;
name|rctx
operator|.
name|tphhead_ena
operator|=
literal|0
expr_stmt|;
name|rctx
operator|.
name|lrxqthresh
operator|=
literal|2
expr_stmt|;
name|rctx
operator|.
name|crcstrip
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|l2tsel
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|showiv
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|fc_ena
operator|=
literal|0
expr_stmt|;
name|rctx
operator|.
name|prefena
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|i40e_clear_lan_rx_queue_context
argument_list|(
name|hw
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to clear RX context %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|i40e_set_lan_rx_queue_context
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|rctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to set RX context %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|ixl_init_rx_ring
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Fail in init_rx_ring %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|wr32
argument_list|(
name|vsi
operator|->
name|hw
argument_list|,
name|I40E_QRX_TAIL
argument_list|(
name|que
operator|->
name|me
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* preserve queue */
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
decl_stmt|;
name|int
name|t
init|=
name|na
operator|->
name|num_rx_desc
operator|-
literal|1
operator|-
name|nm_kr_rxspace
argument_list|(
name|kring
argument_list|)
decl_stmt|;
name|wr32
argument_list|(
name|vsi
operator|->
name|hw
argument_list|,
name|I40E_QRX_TAIL
argument_list|(
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|wr32
argument_list|(
name|vsi
operator|->
name|hw
argument_list|,
name|I40E_QRX_TAIL
argument_list|(
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|que
operator|->
name|num_desc
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free all VSI structs.  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_free_vsi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
comment|/* Free station queues */
if|if
condition|(
operator|!
name|vsi
operator|->
name|queues
condition|)
goto|goto
name|free_filters
goto|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
condition|)
comment|/* uninitialized */
continue|continue;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixl_free_que_tx
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|)
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|IXL_TX_LOCK_DESTROY
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|rxr
operator|->
name|mtx
argument_list|)
condition|)
comment|/* uninitialized */
continue|continue;
name|IXL_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|ixl_free_que_rx
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|)
expr_stmt|;
name|IXL_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|IXL_RX_LOCK_DESTROY
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|vsi
operator|->
name|queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free_filters
label|:
comment|/* Free VSI filter list */
name|ixl_free_mac_filters
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_free_mac_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|)
condition|)
block|{
name|f
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for the VSI (virtual station interface) and their  *  associated queues, rings and the descriptors associated with each,  *  called only once at attach.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_setup_stations
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|tsize
decl_stmt|;
name|int
name|error
init|=
name|I40E_SUCCESS
decl_stmt|;
name|vsi
operator|=
operator|&
name|pf
operator|->
name|vsi
expr_stmt|;
name|vsi
operator|->
name|back
operator|=
operator|(
name|void
operator|*
operator|)
name|pf
expr_stmt|;
name|vsi
operator|->
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|vsi
operator|->
name|id
operator|=
literal|0
expr_stmt|;
name|vsi
operator|->
name|num_vlans
operator|=
literal|0
expr_stmt|;
name|vsi
operator|->
name|back
operator|=
name|pf
expr_stmt|;
comment|/* Get memory for the station queues */
if|if
condition|(
operator|!
operator|(
name|vsi
operator|->
name|queues
operator|=
operator|(
expr|struct
name|ixl_queue
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_queue
argument_list|)
operator|*
name|vsi
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate queue memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|early
goto|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|vsi
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|que
operator|->
name|num_desc
operator|=
name|ixl_ringsz
expr_stmt|;
name|que
operator|->
name|me
operator|=
name|i
expr_stmt|;
name|que
operator|->
name|vsi
operator|=
name|vsi
expr_stmt|;
comment|/* mark the queue as active */
name|vsi
operator|->
name|active_queues
operator||=
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
name|txr
operator|->
name|que
operator|=
name|que
expr_stmt|;
name|txr
operator|->
name|tail
operator|=
name|I40E_QTX_TAIL
argument_list|(
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
comment|/* Initialize the TX lock */
name|snprintf
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:tx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|,
name|txr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Create the TX descriptor ring */
name|tsize
operator|=
name|roundup2
argument_list|(
operator|(
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_tx_desc
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|i40e_allocate_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|,
name|i40e_mem_reserved
argument_list|,
name|tsize
argument_list|,
name|DBA_ALIGN
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|txr
operator|->
name|base
operator|=
operator|(
expr|struct
name|i40e_tx_desc
operator|*
operator|)
name|txr
operator|->
name|dma
operator|.
name|va
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|base
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
comment|/* Now allocate transmit soft structs for the ring */
if|if
condition|(
name|ixl_allocate_tx_data
argument_list|(
name|que
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up TX structures\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate a buf ring */
name|txr
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
literal|4096
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
operator|&
name|txr
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|br
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up TX buf ring\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 		 * Next the RX queues... 		 */
name|rsize
operator|=
name|roundup2
argument_list|(
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|i40e_rx_desc
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
name|rxr
operator|=
operator|&
name|que
operator|->
name|rxr
expr_stmt|;
name|rxr
operator|->
name|que
operator|=
name|que
expr_stmt|;
name|rxr
operator|->
name|tail
operator|=
name|I40E_QRX_TAIL
argument_list|(
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
comment|/* Initialize the RX side lock */
name|snprintf
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:rx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rxr
operator|->
name|mtx
argument_list|,
name|rxr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|i40e_allocate_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|,
name|i40e_mem_reserved
argument_list|,
name|rsize
argument_list|,
literal|4096
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rxr
operator|->
name|base
operator|=
operator|(
expr|union
name|i40e_rx_desc
operator|*
operator|)
name|rxr
operator|->
name|dma
operator|.
name|va
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* Allocate receive soft structs for the ring*/
if|if
condition|(
name|ixl_allocate_rx_data
argument_list|(
name|que
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up receive structs\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|vsi
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|rxr
operator|=
operator|&
name|que
operator|->
name|rxr
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|)
expr_stmt|;
block|}
name|early
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Provide a update to the queue RX ** interrupt moderation value. */
end_comment

begin_function
specifier|static
name|void
name|ixl_set_queue_rx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|u16
name|rx_itr
decl_stmt|;
name|u16
name|rx_latency
init|=
literal|0
decl_stmt|;
name|int
name|rx_bytes
decl_stmt|;
comment|/* Idle, do nothing */
if|if
condition|(
name|rxr
operator|->
name|bytes
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ixl_dynamic_rx_itr
condition|)
block|{
name|rx_bytes
operator|=
name|rxr
operator|->
name|bytes
operator|/
name|rxr
operator|->
name|itr
expr_stmt|;
name|rx_itr
operator|=
name|rxr
operator|->
name|itr
expr_stmt|;
comment|/* Adjust latency range */
switch|switch
condition|(
name|rxr
operator|->
name|latency
condition|)
block|{
case|case
name|IXL_LOW_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|>
literal|10
condition|)
block|{
name|rx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_AVE_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|>
literal|20
condition|)
block|{
name|rx_latency
operator|=
name|IXL_BULK_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_8K
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rx_bytes
operator|<=
literal|10
condition|)
block|{
name|rx_latency
operator|=
name|IXL_LOW_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_100K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_BULK_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|<=
literal|20
condition|)
block|{
name|rx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
block|}
name|rxr
operator|->
name|latency
operator|=
name|rx_latency
expr_stmt|;
if|if
condition|(
name|rx_itr
operator|!=
name|rxr
operator|->
name|itr
condition|)
block|{
comment|/* do an exponential smoothing */
name|rx_itr
operator|=
operator|(
literal|10
operator|*
name|rx_itr
operator|*
name|rxr
operator|->
name|itr
operator|)
operator|/
operator|(
operator|(
literal|9
operator|*
name|rx_itr
operator|)
operator|+
name|rxr
operator|->
name|itr
operator|)
expr_stmt|;
name|rxr
operator|->
name|itr
operator|=
name|rx_itr
operator|&
name|IXL_MAX_ITR
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_RX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|rxr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have have toggled to non-dynamic */
if|if
condition|(
name|vsi
operator|->
name|rx_itr_setting
operator|&
name|IXL_ITR_DYNAMIC
condition|)
name|vsi
operator|->
name|rx_itr_setting
operator|=
name|ixl_rx_itr
expr_stmt|;
comment|/* Update the hardware if needed */
if|if
condition|(
name|rxr
operator|->
name|itr
operator|!=
name|vsi
operator|->
name|rx_itr_setting
condition|)
block|{
name|rxr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|rx_itr_setting
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_RX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|rxr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
name|rxr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Provide a update to the queue TX ** interrupt moderation value. */
end_comment

begin_function
specifier|static
name|void
name|ixl_set_queue_tx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|u16
name|tx_itr
decl_stmt|;
name|u16
name|tx_latency
init|=
literal|0
decl_stmt|;
name|int
name|tx_bytes
decl_stmt|;
comment|/* Idle, do nothing */
if|if
condition|(
name|txr
operator|->
name|bytes
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ixl_dynamic_tx_itr
condition|)
block|{
name|tx_bytes
operator|=
name|txr
operator|->
name|bytes
operator|/
name|txr
operator|->
name|itr
expr_stmt|;
name|tx_itr
operator|=
name|txr
operator|->
name|itr
expr_stmt|;
switch|switch
condition|(
name|txr
operator|->
name|latency
condition|)
block|{
case|case
name|IXL_LOW_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|>
literal|10
condition|)
block|{
name|tx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_AVE_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|>
literal|20
condition|)
block|{
name|tx_latency
operator|=
name|IXL_BULK_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_8K
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tx_bytes
operator|<=
literal|10
condition|)
block|{
name|tx_latency
operator|=
name|IXL_LOW_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_100K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_BULK_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|<=
literal|20
condition|)
block|{
name|tx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
block|}
name|txr
operator|->
name|latency
operator|=
name|tx_latency
expr_stmt|;
if|if
condition|(
name|tx_itr
operator|!=
name|txr
operator|->
name|itr
condition|)
block|{
comment|/* do an exponential smoothing */
name|tx_itr
operator|=
operator|(
literal|10
operator|*
name|tx_itr
operator|*
name|txr
operator|->
name|itr
operator|)
operator|/
operator|(
operator|(
literal|9
operator|*
name|tx_itr
operator|)
operator|+
name|txr
operator|->
name|itr
operator|)
expr_stmt|;
name|txr
operator|->
name|itr
operator|=
name|tx_itr
operator|&
name|IXL_MAX_ITR
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_TX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|txr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have have toggled to non-dynamic */
if|if
condition|(
name|vsi
operator|->
name|tx_itr_setting
operator|&
name|IXL_ITR_DYNAMIC
condition|)
name|vsi
operator|->
name|tx_itr_setting
operator|=
name|ixl_tx_itr
expr_stmt|;
comment|/* Update the hardware if needed */
if|if
condition|(
name|txr
operator|->
name|itr
operator|!=
name|vsi
operator|->
name|tx_itr_setting
condition|)
block|{
name|txr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|tx_itr_setting
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_TX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|txr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
name|txr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_define
define|#
directive|define
name|QUEUE_NAME_LEN
value|32
end_define

begin_function
specifier|static
name|void
name|ixl_add_vsi_sysctls
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|sysctl_name
parameter_list|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|vsi_list
decl_stmt|;
name|tree
operator|=
name|device_get_sysctl_tree
argument_list|(
name|pf
operator|->
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|vsi_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|sysctl_name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"VSI Number"
argument_list|)
expr_stmt|;
name|vsi_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|vsi
operator|->
name|vsi_node
argument_list|)
expr_stmt|;
name|ixl_add_sysctls_eth_stats
argument_list|(
name|ctx
argument_list|,
name|vsi_list
argument_list|,
operator|&
name|vsi
operator|->
name|eth_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_add_hw_stats
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|queues
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|i40e_hw_port_stats
modifier|*
name|pf_stats
init|=
operator|&
name|pf
operator|->
name|stats
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|vsi_list
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|queue_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|queue_list
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|char
name|queue_namebuf
index|[
name|QUEUE_NAME_LEN
index|]
decl_stmt|;
comment|/* Driver statistics */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"watchdog_events"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pf
operator|->
name|watchdog_events
argument_list|,
literal|"Watchdog timeouts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"admin_irq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pf
operator|->
name|admin_irq
argument_list|,
literal|"Admin Queue IRQ Handled"
argument_list|)
expr_stmt|;
name|ixl_add_vsi_sysctls
argument_list|(
name|pf
argument_list|,
operator|&
name|pf
operator|->
name|vsi
argument_list|,
name|ctx
argument_list|,
literal|"pf"
argument_list|)
expr_stmt|;
name|vsi_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|pf
operator|->
name|vsi
operator|.
name|vsi_node
argument_list|)
expr_stmt|;
comment|/* Queue statistics */
for|for
control|(
name|int
name|q
init|=
literal|0
init|;
name|q
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|q
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|queue_namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"que%d"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|vsi_list
argument_list|,
name|OID_AUTO
argument_list|,
name|queue_namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue #"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|txr
operator|=
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|txr
operator|)
expr_stmt|;
name|rxr
operator|=
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|rxr
operator|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_defrag_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|mbuf_defrag_failed
operator|)
argument_list|,
literal|"m_defrag() failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|dropped_pkts
operator|)
argument_list|,
literal|"Driver dropped packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"irqs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|irqs
operator|)
argument_list|,
literal|"irqs on this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_tx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|tso
operator|)
argument_list|,
literal|"TSO"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_dma_setup"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|tx_dma_setup
operator|)
argument_list|,
literal|"Driver tx dma failure in xmit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_desc_avail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|no_desc
operator|)
argument_list|,
literal|"Queue No Descriptor Available"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|total_packets
operator|)
argument_list|,
literal|"Queue Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|tx_bytes
operator|)
argument_list|,
literal|"Queue Bytes Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|rx_packets
operator|)
argument_list|,
literal|"Queue Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|rx_bytes
operator|)
argument_list|,
literal|"Queue Bytes Received"
argument_list|)
expr_stmt|;
block|}
comment|/* MAC stats */
name|ixl_add_sysctls_mac_stats
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|pf_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_add_sysctls_eth_stats
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
name|child
parameter_list|,
name|struct
name|i40e_eth_stats
modifier|*
name|eth_stats
parameter_list|)
block|{
name|struct
name|ixl_sysctl_info
name|ctls
index|[]
init|=
block|{
block|{
operator|&
name|eth_stats
operator|->
name|rx_bytes
block|,
literal|"good_octets_rcvd"
block|,
literal|"Good Octets Received"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|rx_unicast
block|,
literal|"ucast_pkts_rcvd"
block|,
literal|"Unicast Packets Received"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|rx_multicast
block|,
literal|"mcast_pkts_rcvd"
block|,
literal|"Multicast Packets Received"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|rx_broadcast
block|,
literal|"bcast_pkts_rcvd"
block|,
literal|"Broadcast Packets Received"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|rx_discards
block|,
literal|"rx_discards"
block|,
literal|"Discarded RX packets"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|tx_bytes
block|,
literal|"good_octets_txd"
block|,
literal|"Good Octets Transmitted"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|tx_unicast
block|,
literal|"ucast_pkts_txd"
block|,
literal|"Unicast Packets Transmitted"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|tx_multicast
block|,
literal|"mcast_pkts_txd"
block|,
literal|"Multicast Packets Transmitted"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|tx_broadcast
block|,
literal|"bcast_pkts_txd"
block|,
literal|"Broadcast Packets Transmitted"
block|}
block|,
comment|// end
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|struct
name|ixl_sysctl_info
modifier|*
name|entry
init|=
name|ctls
decl_stmt|;
while|while
condition|(
name|entry
operator|->
name|stat
operator|!=
name|NULL
condition|)
block|{
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|entry
operator|->
name|stat
argument_list|,
name|entry
operator|->
name|description
argument_list|)
expr_stmt|;
name|entry
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_add_sysctls_mac_stats
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
name|child
parameter_list|,
name|struct
name|i40e_hw_port_stats
modifier|*
name|stats
parameter_list|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|stat_node
init|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mac"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Mac Statistics"
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|stat_list
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|stat_node
argument_list|)
decl_stmt|;
name|struct
name|i40e_eth_stats
modifier|*
name|eth_stats
init|=
operator|&
name|stats
operator|->
name|eth
decl_stmt|;
name|ixl_add_sysctls_eth_stats
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|eth_stats
argument_list|)
expr_stmt|;
name|struct
name|ixl_sysctl_info
name|ctls
index|[]
init|=
block|{
block|{
operator|&
name|stats
operator|->
name|crc_errors
block|,
literal|"crc_errors"
block|,
literal|"CRC Errors"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|illegal_bytes
block|,
literal|"illegal_bytes"
block|,
literal|"Illegal Byte Errors"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|mac_local_faults
block|,
literal|"local_faults"
block|,
literal|"MAC Local Faults"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|mac_remote_faults
block|,
literal|"remote_faults"
block|,
literal|"MAC Remote Faults"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_length_errors
block|,
literal|"rx_length_errors"
block|,
literal|"Receive Length Errors"
block|}
block|,
comment|/* Packet Reception Stats */
block|{
operator|&
name|stats
operator|->
name|rx_size_64
block|,
literal|"rx_frames_64"
block|,
literal|"64 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_127
block|,
literal|"rx_frames_65_127"
block|,
literal|"65-127 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_255
block|,
literal|"rx_frames_128_255"
block|,
literal|"128-255 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_511
block|,
literal|"rx_frames_256_511"
block|,
literal|"256-511 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_1023
block|,
literal|"rx_frames_512_1023"
block|,
literal|"512-1023 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_1522
block|,
literal|"rx_frames_1024_1522"
block|,
literal|"1024-1522 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_big
block|,
literal|"rx_frames_big"
block|,
literal|"1523-9522 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_undersize
block|,
literal|"rx_undersize"
block|,
literal|"Undersized packets received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_fragments
block|,
literal|"rx_fragmented"
block|,
literal|"Fragmented packets received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_oversize
block|,
literal|"rx_oversized"
block|,
literal|"Oversized packets received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_jabber
block|,
literal|"rx_jabber"
block|,
literal|"Received Jabber"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|checksum_error
block|,
literal|"checksum_errors"
block|,
literal|"Checksum Errors"
block|}
block|,
comment|/* Packet Transmission Stats */
block|{
operator|&
name|stats
operator|->
name|tx_size_64
block|,
literal|"tx_frames_64"
block|,
literal|"64 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_127
block|,
literal|"tx_frames_65_127"
block|,
literal|"65-127 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_255
block|,
literal|"tx_frames_128_255"
block|,
literal|"128-255 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_511
block|,
literal|"tx_frames_256_511"
block|,
literal|"256-511 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_1023
block|,
literal|"tx_frames_512_1023"
block|,
literal|"512-1023 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_1522
block|,
literal|"tx_frames_1024_1522"
block|,
literal|"1024-1522 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_big
block|,
literal|"tx_frames_big"
block|,
literal|"1523-9522 byte frames transmitted"
block|}
block|,
comment|/* Flow control */
block|{
operator|&
name|stats
operator|->
name|link_xon_tx
block|,
literal|"xon_txd"
block|,
literal|"Link XON transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|link_xon_rx
block|,
literal|"xon_recvd"
block|,
literal|"Link XON received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|link_xoff_tx
block|,
literal|"xoff_txd"
block|,
literal|"Link XOFF transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|link_xoff_rx
block|,
literal|"xoff_recvd"
block|,
literal|"Link XOFF received"
block|}
block|,
comment|/* End */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|struct
name|ixl_sysctl_info
modifier|*
name|entry
init|=
name|ctls
decl_stmt|;
while|while
condition|(
name|entry
operator|->
name|stat
operator|!=
name|NULL
condition|)
block|{
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|entry
operator|->
name|stat
argument_list|,
name|entry
operator|->
name|description
argument_list|)
expr_stmt|;
name|entry
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** ixl_config_rss - setup RSS  **  - note this is done for the single vsi */
end_comment

begin_function
specifier|static
name|void
name|ixl_config_rss
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|u32
name|lut
init|=
literal|0
decl_stmt|;
name|u64
name|set_hena
init|=
literal|0
decl_stmt|,
name|hena
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|que_id
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|u32
name|rss_hash_config
decl_stmt|;
name|u32
name|rss_seed
index|[
name|IXL_KEYSZ
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|rss_seed
index|[
name|IXL_KEYSZ
index|]
init|=
block|{
literal|0x41b01687
block|,
literal|0x183cfd8c
block|,
literal|0xce880440
block|,
literal|0x580cbc3c
block|,
literal|0x35897377
block|,
literal|0x328b25e1
block|,
literal|0x4fa98922
block|,
literal|0xb7d90c14
block|,
literal|0xd5bad70d
block|,
literal|0xcd15a2c1
block|}
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RSS
comment|/* Fetch the configured RSS key */
name|rss_getkey
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|rss_seed
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fill out hash function seed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXL_KEYSZ
condition|;
name|i
operator|++
control|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HKEY
argument_list|(
name|i
argument_list|)
argument_list|,
name|rss_seed
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Enable PCTYPES for RSS: */
ifdef|#
directive|ifdef
name|RSS
name|rss_hash_config
operator|=
name|rss_gethashconfig
argument_list|()
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV4
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_OTHER
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV4
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_TCP
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV4
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_UDP
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV6
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_OTHER
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV6_EX
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_FRAG_IPV6
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV6
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_TCP
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV6
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_UDP
operator|)
expr_stmt|;
else|#
directive|else
name|set_hena
operator|=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_UDP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_TCP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_SCTP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_OTHER
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_FRAG_IPV4
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_UDP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_TCP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_SCTP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_OTHER
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_FRAG_IPV6
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_L2_PAYLOAD
operator|)
expr_stmt|;
endif|#
directive|endif
name|hena
operator|=
operator|(
name|u64
operator|)
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HENA
argument_list|(
literal|0
argument_list|)
argument_list|)
operator||
operator|(
operator|(
name|u64
operator|)
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HENA
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|hena
operator||=
name|set_hena
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HENA
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|u32
operator|)
name|hena
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HENA
argument_list|(
literal|1
argument_list|)
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|hena
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Populate the LUT with max no. of queues in round robin fashion */
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|pf
operator|->
name|hw
operator|.
name|func_caps
operator|.
name|rss_table_size
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|vsi
operator|->
name|num_queues
condition|)
name|j
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* 		 * Fetch the RSS bucket id for the given indirection entry. 		 * Cap it at the number of configured buckets (which is 		 * num_queues.) 		 */
name|que_id
operator|=
name|rss_get_indirection_to_bucket
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|que_id
operator|=
name|que_id
operator|%
name|vsi
operator|->
name|num_queues
expr_stmt|;
else|#
directive|else
name|que_id
operator|=
name|j
expr_stmt|;
endif|#
directive|endif
comment|/* lut = 4-byte sliding window of 4 lut entries */
name|lut
operator|=
operator|(
name|lut
operator|<<
literal|8
operator|)
operator||
operator|(
name|que_id
operator|&
operator|(
operator|(
literal|0x1
operator|<<
name|pf
operator|->
name|hw
operator|.
name|func_caps
operator|.
name|rss_table_entry_width
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* On i = 3, we have 4 entries in lut; write to the register */
if|if
condition|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HLUT
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
argument_list|,
name|lut
argument_list|)
expr_stmt|;
block|}
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine is run via an vlan config EVENT, ** it enables us to use the HW Filter table since ** we can get the vlan id. This just creates the ** entry in the soft version of the VFTA, init will ** repopulate the real table. */
end_comment

begin_function
specifier|static
name|void
name|ixl_register_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
operator|++
name|vsi
operator|->
name|num_vlans
expr_stmt|;
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|vtag
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine is run via an vlan ** unconfig EVENT, remove our entry ** in the soft vfta. */
end_comment

begin_function
specifier|static
name|void
name|ixl_unregister_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
operator|--
name|vsi
operator|->
name|num_vlans
expr_stmt|;
name|ixl_del_filter
argument_list|(
name|vsi
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|vtag
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine updates vlan filters, called by init ** it scans the filter table and then updates the hw ** after a soft reset. */
end_comment

begin_function
specifier|static
name|void
name|ixl_setup_vlan_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|;
if|if
condition|(
name|vsi
operator|->
name|num_vlans
operator|==
literal|0
condition|)
return|return;
comment|/* 	** Scan the filter list for vlan entries, 	** mark them for addition and then call 	** for the AQ update. 	*/
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_VLAN
condition|)
block|{
name|f
operator|->
name|flags
operator||=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"setup vlan: no filters found!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|flags
operator|=
name|IXL_FILTER_VLAN
expr_stmt|;
name|flags
operator||=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator|)
expr_stmt|;
name|ixl_add_hw_filters
argument_list|(
name|vsi
argument_list|,
name|flags
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Initialize filter list and add filters that the hardware ** needs to know about. ** ** Requires VSI's filter list& seid to be set before calling. */
end_comment

begin_function
specifier|static
name|void
name|ixl_init_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
comment|/* Add broadcast address */
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|ixl_bcast_addr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
comment|/* 	 * Prevent Tx flow control frames from being sent out by 	 * non-firmware transmitters. 	 */
name|i40e_add_filter_to_drop_tx_flow_control_frames
argument_list|(
name|vsi
operator|->
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine adds mulicast filters */
end_comment

begin_function
specifier|static
name|void
name|ixl_add_mc_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
comment|/* Does one already exist */
name|f
operator|=
name|ixl_find_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
return|return;
name|f
operator|=
name|ixl_get_filter
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: no filter available!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|macaddr
argument_list|,
name|f
operator|->
name|macaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|f
operator|->
name|vlan
operator|=
name|IXL_VLAN_ANY
expr_stmt|;
name|f
operator|->
name|flags
operator||=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator||
name|IXL_FILTER_MC
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_reconfigure_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|ixl_add_hw_filters
argument_list|(
name|vsi
argument_list|,
name|IXL_FILTER_USED
argument_list|,
name|vsi
operator|->
name|num_macs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine adds macvlan filters */
end_comment

begin_function
specifier|static
name|void
name|ixl_add_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|,
name|s16
name|vlan
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ixl_add_filter: begin"
argument_list|)
expr_stmt|;
name|pf
operator|=
name|vsi
operator|->
name|back
expr_stmt|;
name|dev
operator|=
name|pf
operator|->
name|dev
expr_stmt|;
comment|/* Does one already exist */
name|f
operator|=
name|ixl_find_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|vlan
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
return|return;
comment|/* 	** Is this the first vlan being registered, if so we 	** need to remove the ANY filter that indicates we are 	** not in a vlan, and replace that with a 0 filter. 	*/
if|if
condition|(
operator|(
name|vlan
operator|!=
name|IXL_VLAN_ANY
operator|)
operator|&&
operator|(
name|vsi
operator|->
name|num_vlans
operator|==
literal|1
operator|)
condition|)
block|{
name|tmp
operator|=
name|ixl_find_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|ixl_del_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|f
operator|=
name|ixl_get_filter
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING: no filter available!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|macaddr
argument_list|,
name|f
operator|->
name|macaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|f
operator|->
name|vlan
operator|=
name|vlan
expr_stmt|;
name|f
operator|->
name|flags
operator||=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|vlan
operator|!=
name|IXL_VLAN_ANY
condition|)
name|f
operator|->
name|flags
operator||=
name|IXL_FILTER_VLAN
expr_stmt|;
else|else
name|vsi
operator|->
name|num_macs
operator|++
expr_stmt|;
name|ixl_add_hw_filters
argument_list|(
name|vsi
argument_list|,
name|f
operator|->
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_del_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|,
name|s16
name|vlan
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|ixl_find_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|vlan
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return;
name|f
operator|->
name|flags
operator||=
name|IXL_FILTER_DEL
expr_stmt|;
name|ixl_del_hw_filters
argument_list|(
name|vsi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|num_macs
operator|--
expr_stmt|;
comment|/* Check if this is the last vlan removal */
if|if
condition|(
name|vlan
operator|!=
name|IXL_VLAN_ANY
operator|&&
name|vsi
operator|->
name|num_vlans
operator|==
literal|0
condition|)
block|{
comment|/* Switch back to a non-vlan filter */
name|ixl_del_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ** Find the filter with both matching mac addr and vlan id */
end_comment

begin_function
specifier|static
name|struct
name|ixl_mac_filter
modifier|*
name|ixl_find_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|,
name|s16
name|vlan
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|bool
name|match
init|=
name|FALSE
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
operator|!
name|cmp_etheraddr
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|macaddr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|f
operator|->
name|vlan
operator|==
name|vlan
condition|)
block|{
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
name|f
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** This routine takes additions to the vsi filter ** table and creates an Admin Queue call to create ** the filters in the hardware. */
end_comment

begin_function
specifier|static
name|void
name|ixl_add_hw_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|struct
name|i40e_aqc_add_macvlan_element_data
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|pf
operator|=
name|vsi
operator|->
name|back
expr_stmt|;
name|dev
operator|=
name|pf
operator|->
name|dev
expr_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|IXL_PF_LOCK_ASSERT
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|a
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aqc_add_macvlan_element_data
argument_list|)
operator|*
name|cnt
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"add_hw_filters failed to get memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	** Scan the filter list, each time we find one 	** we add it to the admin queue array and turn off 	** the add bit. 	*/
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|f
operator|->
name|flags
operator|==
name|flags
condition|)
block|{
name|b
operator|=
operator|&
name|a
index|[
name|j
index|]
expr_stmt|;
comment|// a pox on fvl long names :)
name|bcopy
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|b
operator|->
name|mac_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|vlan
operator|==
name|IXL_VLAN_ANY
condition|)
block|{
name|b
operator|->
name|vlan_tag
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|flags
operator|=
name|I40E_AQC_MACVLAN_ADD_IGNORE_VLAN
expr_stmt|;
block|}
else|else
block|{
name|b
operator|->
name|vlan_tag
operator|=
name|f
operator|->
name|vlan
expr_stmt|;
name|b
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|b
operator|->
name|flags
operator||=
name|I40E_AQC_MACVLAN_ADD_PERFECT_MATCH
expr_stmt|;
name|f
operator|->
name|flags
operator|&=
operator|~
name|IXL_FILTER_ADD
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
name|cnt
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|err
operator|=
name|i40e_aq_add_macvlan
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|a
argument_list|,
name|j
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"aq_add_macvlan err %d, "
literal|"aq_error %d\n"
argument_list|,
name|err
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
else|else
name|vsi
operator|->
name|hw_filters_add
operator|+=
name|j
expr_stmt|;
block|}
name|free
argument_list|(
name|a
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** This routine takes removals in the vsi filter ** table and creates an Admin Queue call to delete ** the filters in the hardware. */
end_comment

begin_function
specifier|static
name|void
name|ixl_del_hw_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|struct
name|i40e_aqc_remove_macvlan_element_data
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|,
modifier|*
name|f_temp
decl_stmt|;
name|int
name|err
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ixl_del_hw_filters: begin\n"
argument_list|)
expr_stmt|;
name|pf
operator|=
name|vsi
operator|->
name|back
expr_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|dev
operator|=
name|pf
operator|->
name|dev
expr_stmt|;
name|d
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aqc_remove_macvlan_element_data
argument_list|)
operator|*
name|cnt
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"del hw filter failed to get memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|SLIST_FOREACH_SAFE
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|,
argument|f_temp
argument_list|)
block|{
if|if
condition|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_DEL
condition|)
block|{
name|e
operator|=
operator|&
name|d
index|[
name|j
index|]
expr_stmt|;
comment|// a pox on fvl long names :)
name|bcopy
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|e
operator|->
name|mac_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|e
operator|->
name|vlan_tag
operator|=
operator|(
name|f
operator|->
name|vlan
operator|==
name|IXL_VLAN_ANY
condition|?
literal|0
else|:
name|f
operator|->
name|vlan
operator|)
expr_stmt|;
name|e
operator|->
name|flags
operator|=
name|I40E_AQC_MACVLAN_DEL_PERFECT_MATCH
expr_stmt|;
comment|/* delete entry from vsi list */
name|SLIST_REMOVE
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|,
name|f
argument_list|,
name|ixl_mac_filter
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
name|cnt
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|err
operator|=
name|i40e_aq_remove_macvlan
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|d
argument_list|,
name|j
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* NOTE: returns ENOENT every time but seems to work fine, 		   so we'll ignore that specific error. */
comment|// TODO: Does this still occur on current firmwares?
if|if
condition|(
name|err
operator|&&
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
operator|!=
name|I40E_AQ_RC_ENOENT
condition|)
block|{
name|int
name|sc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
name|sc
operator|+=
operator|(
operator|!
name|d
index|[
name|i
index|]
operator|.
name|error_code
operator|)
expr_stmt|;
name|vsi
operator|->
name|hw_filters_del
operator|+=
name|sc
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to remove %d/%d filters, aq error %d\n"
argument_list|,
name|j
operator|-
name|sc
argument_list|,
name|j
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
else|else
name|vsi
operator|->
name|hw_filters_del
operator|+=
name|j
expr_stmt|;
block|}
name|free
argument_list|(
name|d
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ixl_del_hw_filters: end\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_enable_rings
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|int
name|index
decl_stmt|,
name|error
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|index
operator|=
name|vsi
operator|->
name|first_queue
operator|+
name|i
expr_stmt|;
name|i40e_pre_tx_queue_cfg
argument_list|(
name|hw
argument_list|,
name|index
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_QTX_ENA_QENA_REQ_MASK
operator||
name|I40E_QTX_ENA_QENA_STAT_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|index
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Verify the enable took */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_QTX_ENA_QENA_STAT_MASK
condition|)
break|break;
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reg
operator|&
name|I40E_QTX_ENA_QENA_STAT_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"TX queue %d disabled!\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_QRX_ENA_QENA_REQ_MASK
operator||
name|I40E_QRX_ENA_QENA_STAT_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|index
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Verify the enable took */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_QRX_ENA_QENA_STAT_MASK
condition|)
break|break;
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reg
operator|&
name|I40E_QRX_ENA_QENA_STAT_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"RX queue %d disabled!\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_disable_rings
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|int
name|index
decl_stmt|,
name|error
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|index
operator|=
name|vsi
operator|->
name|first_queue
operator|+
name|i
expr_stmt|;
name|i40e_pre_tx_queue_cfg
argument_list|(
name|hw
argument_list|,
name|index
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|i40e_usec_delay
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|I40E_QTX_ENA_QENA_REQ_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|index
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Verify the disable took */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg
operator|&
name|I40E_QTX_ENA_QENA_STAT_MASK
operator|)
condition|)
break|break;
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_QTX_ENA_QENA_STAT_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"TX queue %d still enabled!\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|I40E_QRX_ENA_QENA_REQ_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|index
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Verify the disable took */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg
operator|&
name|I40E_QRX_ENA_QENA_STAT_MASK
operator|)
condition|)
break|break;
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_QRX_ENA_QENA_STAT_MASK
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"RX queue %d still enabled!\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ixl_handle_mdd_event  *  * Called from interrupt handler to identify possibly malicious vfs  * (But also detects events from the PF, as well)  **/
end_comment

begin_function
specifier|static
name|void
name|ixl_handle_mdd_event
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|bool
name|mdd_detected
init|=
name|false
decl_stmt|;
name|bool
name|pf_mdd_detected
init|=
name|false
decl_stmt|;
name|u32
name|reg
decl_stmt|;
comment|/* find what triggered the MDD event */
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GL_MDET_TX
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_GL_MDET_TX_VALID_MASK
condition|)
block|{
name|u8
name|pf_num
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_TX_PF_NUM_MASK
operator|)
operator|>>
name|I40E_GL_MDET_TX_PF_NUM_SHIFT
decl_stmt|;
name|u8
name|event
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_TX_EVENT_MASK
operator|)
operator|>>
name|I40E_GL_MDET_TX_EVENT_SHIFT
decl_stmt|;
name|u8
name|queue
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_TX_QUEUE_MASK
operator|)
operator|>>
name|I40E_GL_MDET_TX_QUEUE_SHIFT
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Malicious Driver Detection event 0x%02x"
literal|" on TX queue %d pf number 0x%02x\n"
argument_list|,
name|event
argument_list|,
name|queue
argument_list|,
name|pf_num
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GL_MDET_TX
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|mdd_detected
operator|=
name|true
expr_stmt|;
block|}
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GL_MDET_RX
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_GL_MDET_RX_VALID_MASK
condition|)
block|{
name|u8
name|func
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_RX_FUNCTION_MASK
operator|)
operator|>>
name|I40E_GL_MDET_RX_FUNCTION_SHIFT
decl_stmt|;
name|u8
name|event
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_RX_EVENT_MASK
operator|)
operator|>>
name|I40E_GL_MDET_RX_EVENT_SHIFT
decl_stmt|;
name|u8
name|queue
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_RX_QUEUE_MASK
operator|)
operator|>>
name|I40E_GL_MDET_RX_QUEUE_SHIFT
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Malicious Driver Detection event 0x%02x"
literal|" on RX queue %d of function 0x%02x\n"
argument_list|,
name|event
argument_list|,
name|queue
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GL_MDET_RX
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|mdd_detected
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|mdd_detected
condition|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_MDET_TX
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_PF_MDET_TX_VALID_MASK
condition|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_MDET_TX
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MDD TX event is for this function 0x%08x"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|pf_mdd_detected
operator|=
name|true
expr_stmt|;
block|}
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_MDET_RX
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_PF_MDET_RX_VALID_MASK
condition|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_MDET_RX
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MDD RX event is for this function 0x%08x"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|pf_mdd_detected
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* re-enable mdd interrupt cause */
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_PFINT_ICR0_ENA_MAL_DETECT_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_enable_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
if|if
condition|(
name|ixl_enable_msix
condition|)
block|{
name|ixl_enable_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
name|ixl_enable_queue
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
block|}
else|else
name|ixl_enable_legacy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_disable_rings_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
name|ixl_disable_queue
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_disable_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
if|if
condition|(
name|ixl_enable_msix
condition|)
name|ixl_disable_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
else|else
name|ixl_disable_legacy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_enable_adminq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|I40E_PFINT_DYN_CTL0_INTENA_MASK
operator||
name|I40E_PFINT_DYN_CTL0_CLEARPBA_MASK
operator||
operator|(
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTL0_ITR_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_disable_adminq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTL0_ITR_INDX_SHIFT
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_enable_queue
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|I40E_PFINT_DYN_CTLN_INTENA_MASK
operator||
name|I40E_PFINT_DYN_CTLN_CLEARPBA_MASK
operator||
operator|(
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTLN_ITR_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTLN
argument_list|(
name|id
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_disable_queue
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTLN_ITR_INDX_SHIFT
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTLN
argument_list|(
name|id
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_enable_legacy
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|I40E_PFINT_DYN_CTL0_INTENA_MASK
operator||
name|I40E_PFINT_DYN_CTL0_CLEARPBA_MASK
operator||
operator|(
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTL0_ITR_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_disable_legacy
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTL0_ITR_INDX_SHIFT
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_update_stats_counters
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_vf
modifier|*
name|vf
decl_stmt|;
name|struct
name|i40e_hw_port_stats
modifier|*
name|nsd
init|=
operator|&
name|pf
operator|->
name|stats
decl_stmt|;
name|struct
name|i40e_hw_port_stats
modifier|*
name|osd
init|=
operator|&
name|pf
operator|->
name|stats_offsets
decl_stmt|;
comment|/* Update hw stats */
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_CRCERRS
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|crc_errors
argument_list|,
operator|&
name|nsd
operator|->
name|crc_errors
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_ILLERRC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|illegal_bytes
argument_list|,
operator|&
name|nsd
operator|->
name|illegal_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_GORCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_GORCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_bytes
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_GOTCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_GOTCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|tx_bytes
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|tx_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RDPC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_discards
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_discards
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_UPRCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_UPRCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_unicast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_unicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_UPTCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_UPTCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|tx_unicast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|tx_unicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MPRCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_MPRCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_multicast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_multicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MPTCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_MPTCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|tx_multicast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|tx_multicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_BPRCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_BPRCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_broadcast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_broadcast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_BPTCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_BPTCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|tx_broadcast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|tx_broadcast
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_TDOLD
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_dropped_link_down
argument_list|,
operator|&
name|nsd
operator|->
name|tx_dropped_link_down
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MLFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|mac_local_faults
argument_list|,
operator|&
name|nsd
operator|->
name|mac_local_faults
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MRFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|mac_remote_faults
argument_list|,
operator|&
name|nsd
operator|->
name|mac_remote_faults
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RLEC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_length_errors
argument_list|,
operator|&
name|nsd
operator|->
name|rx_length_errors
argument_list|)
expr_stmt|;
comment|/* Flow control (LFC) stats */
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_LXONRXC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|link_xon_rx
argument_list|,
operator|&
name|nsd
operator|->
name|link_xon_rx
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_LXONTXC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|link_xon_tx
argument_list|,
operator|&
name|nsd
operator|->
name|link_xon_tx
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_LXOFFRXC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|link_xoff_rx
argument_list|,
operator|&
name|nsd
operator|->
name|link_xoff_rx
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_LXOFFTXC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|link_xoff_tx
argument_list|,
operator|&
name|nsd
operator|->
name|link_xoff_tx
argument_list|)
expr_stmt|;
comment|/* Packet size stats rx */
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC64H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC64L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_64
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_64
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC127H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC127L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_127
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_127
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC255H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC255L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_255
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_255
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC511H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC511L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_511
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_511
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC1023H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC1023L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_1023
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_1023
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC1522H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC1522L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_1522
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_1522
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC9522H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC9522L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_big
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_big
argument_list|)
expr_stmt|;
comment|/* Packet size stats tx */
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC64H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC64L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_64
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_64
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC127H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC127L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_127
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_127
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC255H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC255L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_255
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_255
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC511H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC511L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_511
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_511
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC1023H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC1023L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_1023
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_1023
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC1522H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC1522L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_1522
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_1522
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC9522H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC9522L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_big
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_big
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RUC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_undersize
argument_list|,
operator|&
name|nsd
operator|->
name|rx_undersize
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_fragments
argument_list|,
operator|&
name|nsd
operator|->
name|rx_fragments
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_ROC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_oversize
argument_list|,
operator|&
name|nsd
operator|->
name|rx_oversize
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RJC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_jabber
argument_list|,
operator|&
name|nsd
operator|->
name|rx_jabber
argument_list|)
expr_stmt|;
name|pf
operator|->
name|stat_offsets_loaded
operator|=
name|true
expr_stmt|;
comment|/* End hw stats */
comment|/* Update vsi stats */
name|ixl_update_vsi_stats
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pf
operator|->
name|num_vfs
condition|;
name|i
operator|++
control|)
block|{
name|vf
operator|=
operator|&
name|pf
operator|->
name|vfs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vf
operator|->
name|vf_flags
operator|&
name|VF_FLAG_ENABLED
condition|)
name|ixl_update_eth_stats
argument_list|(
operator|&
name|pf
operator|->
name|vfs
index|[
name|i
index|]
operator|.
name|vsi
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_rebuild_hw_structs_after_reset
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|bool
name|is_up
init|=
name|false
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|is_up
operator|=
operator|!
operator|!
operator|(
name|vsi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
expr_stmt|;
comment|/* Teardown */
if|if
condition|(
name|is_up
condition|)
name|ixl_stop
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_shutdown_lan_hmc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Shutdown LAN HMC failed with code %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ixl_disable_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixl_teardown_adminq_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Shutdown Admin queue failed with code %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Setup */
name|error
operator|=
name|i40e_init_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|I40E_ERR_FIRMWARE_API_VERSION
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize Admin Queue, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ixl_setup_adminq_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixl_setup_adminq_msix error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|ixl_configure_intr0_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_enable_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* setup hmc */
name|error
operator|=
name|i40e_init_lan_hmc
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_tx_qp
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_rx_qp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init_lan_hmc failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|i40e_configure_lan_hmc
argument_list|(
name|hw
argument_list|,
name|I40E_HMC_MODEL_DIRECT_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"configure_lan_hmc failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_up
condition|)
name|ixl_init
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_handle_empr_reset
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|u32
name|reg
decl_stmt|;
comment|/* Typically finishes within 3-4 seconds */
while|while
condition|(
name|count
operator|++
operator|<
literal|100
condition|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLGEN_RSTAT
argument_list|)
operator|&
name|I40E_GLGEN_RSTAT_DEVSTATE_MASK
expr_stmt|;
if|if
condition|(
name|reg
condition|)
name|i40e_msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
ifdef|#
directive|ifdef
name|IXL_DEBUG
comment|// Reset-related
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"EMPR reset wait count: %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Rebuilding driver state...\n"
argument_list|)
expr_stmt|;
name|ixl_rebuild_hw_structs_after_reset
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Rebuilding driver state done.\n"
argument_list|)
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|pf
operator|->
name|state
argument_list|,
name|IXL_PF_STATE_EMPR_RESETTING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Tasklet handler for MSIX Adminq interrupts **  - do outside interrupt since it might sleep */
end_comment

begin_function
specifier|static
name|void
name|ixl_do_adminq
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|context
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_arq_event_info
name|event
decl_stmt|;
name|i40e_status
name|ret
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|u32
name|loop
init|=
literal|0
decl_stmt|;
name|u16
name|opcode
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|pf
operator|->
name|state
operator|&
name|IXL_PF_STATE_EMPR_RESETTING
condition|)
block|{
comment|/* Flag cleared at end of this function */
name|ixl_handle_empr_reset
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Admin Queue handling */
name|event
operator|.
name|buf_len
operator|=
name|IXL_AQ_BUF_SZ
expr_stmt|;
name|event
operator|.
name|msg_buf
operator|=
name|malloc
argument_list|(
name|event
operator|.
name|buf_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event
operator|.
name|msg_buf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Unable to allocate memory for Admin"
literal|" Queue event!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* clean and process any events */
do|do
block|{
name|ret
operator|=
name|i40e_clean_arq_element
argument_list|(
name|hw
argument_list|,
operator|&
name|event
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
name|opcode
operator|=
name|LE16_TO_CPU
argument_list|(
name|event
operator|.
name|desc
operator|.
name|opcode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Admin Queue event: %#06x\n"
argument_list|,
name|__func__
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|i40e_aqc_opc_get_link_status
case|:
name|ixl_link_event
argument_list|(
name|pf
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|i40e_aqc_opc_send_msg_to_pf
case|:
ifdef|#
directive|ifdef
name|PCI_IOV
name|ixl_handle_vf_msg
argument_list|(
name|pf
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|i40e_aqc_opc_event_lan_overflow
case|:
default|default:
break|break;
block|}
block|}
do|while
condition|(
name|result
operator|&&
operator|(
name|loop
operator|++
operator|<
name|IXL_ADM_LIMIT
operator|)
condition|)
do|;
name|free
argument_list|(
name|event
operator|.
name|msg_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* 	 * If there are still messages to process, reschedule ourselves. 	 * Otherwise, re-enable our interrupt and go to sleep. 	 */
if|if
condition|(
name|result
operator|>
literal|0
condition|)
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|adminq
argument_list|)
expr_stmt|;
else|else
name|ixl_enable_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Update VSI-specific ethernet statistics counters.  **/
end_comment

begin_function
name|void
name|ixl_update_eth_stats
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_eth_stats
modifier|*
name|es
decl_stmt|;
name|struct
name|i40e_eth_stats
modifier|*
name|oes
decl_stmt|;
name|struct
name|i40e_hw_port_stats
modifier|*
name|nsd
decl_stmt|;
name|u16
name|stat_idx
init|=
name|vsi
operator|->
name|info
operator|.
name|stat_counter_idx
decl_stmt|;
name|es
operator|=
operator|&
name|vsi
operator|->
name|eth_stats
expr_stmt|;
name|oes
operator|=
operator|&
name|vsi
operator|->
name|eth_stats_offsets
expr_stmt|;
name|nsd
operator|=
operator|&
name|pf
operator|->
name|stats
expr_stmt|;
comment|/* Gather up the stats that the hw collects */
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_TEPC
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_errors
argument_list|,
operator|&
name|es
operator|->
name|tx_errors
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_RDPC
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_discards
argument_list|,
operator|&
name|es
operator|->
name|rx_discards
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_GORCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_GORCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_bytes
argument_list|,
operator|&
name|es
operator|->
name|rx_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_UPRCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_UPRCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_unicast
argument_list|,
operator|&
name|es
operator|->
name|rx_unicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_MPRCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_MPRCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_multicast
argument_list|,
operator|&
name|es
operator|->
name|rx_multicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_BPRCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_BPRCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_broadcast
argument_list|,
operator|&
name|es
operator|->
name|rx_broadcast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_GOTCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_GOTCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_bytes
argument_list|,
operator|&
name|es
operator|->
name|tx_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_UPTCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_UPTCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_unicast
argument_list|,
operator|&
name|es
operator|->
name|tx_unicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_MPTCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_MPTCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_multicast
argument_list|,
operator|&
name|es
operator|->
name|tx_multicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_BPTCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_BPTCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_broadcast
argument_list|,
operator|&
name|es
operator|->
name|tx_broadcast
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|stat_offsets_loaded
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_update_vsi_stats
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|i40e_eth_stats
modifier|*
name|es
decl_stmt|;
name|u64
name|tx_discards
decl_stmt|;
name|struct
name|i40e_hw_port_stats
modifier|*
name|nsd
decl_stmt|;
name|pf
operator|=
name|vsi
operator|->
name|back
expr_stmt|;
name|ifp
operator|=
name|vsi
operator|->
name|ifp
expr_stmt|;
name|es
operator|=
operator|&
name|vsi
operator|->
name|eth_stats
expr_stmt|;
name|nsd
operator|=
operator|&
name|pf
operator|->
name|stats
expr_stmt|;
name|ixl_update_eth_stats
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|tx_discards
operator|=
name|es
operator|->
name|tx_discards
operator|+
name|nsd
operator|->
name|tx_dropped_link_down
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|tx_discards
operator|+=
name|vsi
operator|->
name|queues
index|[
name|i
index|]
operator|.
name|txr
operator|.
name|br
operator|->
name|br_drops
expr_stmt|;
comment|/* Update ifnet stats */
name|IXL_SET_IPACKETS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_unicast
operator|+
name|es
operator|->
name|rx_multicast
operator|+
name|es
operator|->
name|rx_broadcast
argument_list|)
expr_stmt|;
name|IXL_SET_OPACKETS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|tx_unicast
operator|+
name|es
operator|->
name|tx_multicast
operator|+
name|es
operator|->
name|tx_broadcast
argument_list|)
expr_stmt|;
name|IXL_SET_IBYTES
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_bytes
argument_list|)
expr_stmt|;
name|IXL_SET_OBYTES
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|tx_bytes
argument_list|)
expr_stmt|;
name|IXL_SET_IMCASTS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_multicast
argument_list|)
expr_stmt|;
name|IXL_SET_OMCASTS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|tx_multicast
argument_list|)
expr_stmt|;
name|IXL_SET_IERRORS
argument_list|(
name|vsi
argument_list|,
name|nsd
operator|->
name|crc_errors
operator|+
name|nsd
operator|->
name|illegal_bytes
operator|+
name|nsd
operator|->
name|rx_undersize
operator|+
name|nsd
operator|->
name|rx_oversize
operator|+
name|nsd
operator|->
name|rx_fragments
operator|+
name|nsd
operator|->
name|rx_jabber
argument_list|)
expr_stmt|;
name|IXL_SET_OERRORS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|tx_errors
argument_list|)
expr_stmt|;
name|IXL_SET_IQDROPS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_discards
operator|+
name|nsd
operator|->
name|eth
operator|.
name|rx_discards
argument_list|)
expr_stmt|;
name|IXL_SET_OQDROPS
argument_list|(
name|vsi
argument_list|,
name|tx_discards
argument_list|)
expr_stmt|;
name|IXL_SET_NOPROTO
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_unknown_protocol
argument_list|)
expr_stmt|;
name|IXL_SET_COLLISIONS
argument_list|(
name|vsi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Reset all of the stats for the given pf  **/
end_comment

begin_function
name|void
name|ixl_pf_reset_stats
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|pf
operator|->
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hw_port_stats
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pf
operator|->
name|stats_offsets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hw_port_stats
argument_list|)
argument_list|)
expr_stmt|;
name|pf
operator|->
name|stat_offsets_loaded
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Resets all stats of the given vsi  **/
end_comment

begin_function
name|void
name|ixl_vsi_reset_stats
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|vsi
operator|->
name|eth_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_eth_stats
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|vsi
operator|->
name|eth_stats_offsets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_eth_stats
argument_list|)
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|stat_offsets_loaded
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read and update a 48 bit stat from the hw  *  * Since the device stats are not reset at PFReset, they likely will not  * be zeroed when the driver starts.  We'll save the first values read  * and use them as offsets to be subtracted from the raw values in order  * to report stats that count from zero.  **/
end_comment

begin_function
specifier|static
name|void
name|ixl_stat_update48
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|hireg
parameter_list|,
name|u32
name|loreg
parameter_list|,
name|bool
name|offset_loaded
parameter_list|,
name|u64
modifier|*
name|offset
parameter_list|,
name|u64
modifier|*
name|stat
parameter_list|)
block|{
name|u64
name|new_data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|>=
literal|1000000
operator|)
operator|&&
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|new_data
operator|=
name|rd64
argument_list|(
name|hw
argument_list|,
name|loreg
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Use two rd32's instead of one rd64; FreeBSD versions before 	 * 10 don't support 8 byte bus reads/writes. 	 */
name|new_data
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|loreg
argument_list|)
expr_stmt|;
name|new_data
operator||=
operator|(
call|(
name|u64
call|)
argument_list|(
name|rd32
argument_list|(
name|hw
argument_list|,
name|hireg
argument_list|)
operator|&
literal|0xFFFF
argument_list|)
operator|)
operator|<<
literal|32
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|offset_loaded
condition|)
operator|*
name|offset
operator|=
name|new_data
expr_stmt|;
if|if
condition|(
name|new_data
operator|>=
operator|*
name|offset
condition|)
operator|*
name|stat
operator|=
name|new_data
operator|-
operator|*
name|offset
expr_stmt|;
else|else
operator|*
name|stat
operator|=
operator|(
name|new_data
operator|+
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
literal|48
operator|)
operator|)
operator|-
operator|*
name|offset
expr_stmt|;
operator|*
name|stat
operator|&=
literal|0xFFFFFFFFFFFFULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read and update a 32 bit stat from the hw  **/
end_comment

begin_function
specifier|static
name|void
name|ixl_stat_update32
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|bool
name|offset_loaded
parameter_list|,
name|u64
modifier|*
name|offset
parameter_list|,
name|u64
modifier|*
name|stat
parameter_list|)
block|{
name|u32
name|new_data
decl_stmt|;
name|new_data
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|offset_loaded
condition|)
operator|*
name|offset
operator|=
name|new_data
expr_stmt|;
if|if
condition|(
name|new_data
operator|>=
operator|*
name|offset
condition|)
operator|*
name|stat
operator|=
call|(
name|u32
call|)
argument_list|(
name|new_data
operator|-
operator|*
name|offset
argument_list|)
expr_stmt|;
else|else
operator|*
name|stat
operator|=
call|(
name|u32
call|)
argument_list|(
operator|(
name|new_data
operator|+
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
literal|32
operator|)
operator|)
operator|-
operator|*
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_add_device_sysctls
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
comment|/* Set up sysctls */
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_set_flowcntl
argument_list|,
literal|"I"
argument_list|,
name|IXL_SYSCTL_HELP_FC
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"advertise_speed"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_set_advertise
argument_list|,
literal|"I"
argument_list|,
name|IXL_SYSCTL_HELP_SET_ADVERTISE
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"current_speed"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_current_speed
argument_list|,
literal|"A"
argument_list|,
literal|"Current Port Speed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fw_version"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_show_fw
argument_list|,
literal|"A"
argument_list|,
literal|"Firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_itr"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixl_rx_itr
argument_list|,
name|IXL_ITR_8K
argument_list|,
literal|"RX ITR"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dynamic_rx_itr"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixl_dynamic_rx_itr
argument_list|,
literal|0
argument_list|,
literal|"Dynamic RX ITR"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_itr"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixl_tx_itr
argument_list|,
name|IXL_ITR_4K
argument_list|,
literal|"TX ITR"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dynamic_tx_itr"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixl_dynamic_tx_itr
argument_list|,
literal|0
argument_list|,
literal|"Dynamic TX ITR"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_DEBUG_SYSCTL
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_debug_info
argument_list|,
literal|"I"
argument_list|,
literal|"Debug Information"
argument_list|)
expr_stmt|;
comment|/* Shared-code debug message level */
name|SYSCTL_ADD_UINT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug_mask"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pf
operator|->
name|hw
operator|.
name|debug_mask
argument_list|,
literal|0
argument_list|,
literal|"Debug Message Level"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"link_status"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_link_status
argument_list|,
literal|"A"
argument_list|,
name|IXL_SYSCTL_HELP_LINK_STATUS
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"phy_abilities"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_phy_abilities
argument_list|,
literal|"A"
argument_list|,
literal|"PHY Abilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"filter_list"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_sw_filter_list
argument_list|,
literal|"A"
argument_list|,
literal|"SW Filter List"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_res_alloc"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_hw_res_alloc
argument_list|,
literal|"A"
argument_list|,
literal|"HW Resource Allocation"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"switch_config"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_switch_config
argument_list|,
literal|"A"
argument_list|,
literal|"HW Switch Configuration"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
name|SYSCTL_ADD_UINT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vc_debug_level"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pf
operator|->
name|vc_debug_lvl
argument_list|,
literal|0
argument_list|,
literal|"PF/VF Virtual Channel debug level"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ** Set flow control using sysctl: ** 	0 - off **	1 - rx pause **	2 - tx pause **	3 - full */
end_comment

begin_function
specifier|static
name|int
name|ixl_set_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
comment|/* 	 * TODO: ensure tx CRC by hardware should be enabled 	 * if tx flow control is enabled. 	 * ^ N/A for 40G ports 	 */
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|requested_fc
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|enum
name|i40e_status_code
name|aq_error
init|=
literal|0
decl_stmt|;
name|u8
name|fc_aq_err
init|=
literal|0
decl_stmt|;
comment|/* Get request */
name|requested_fc
operator|=
name|pf
operator|->
name|fc
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|requested_fc
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|requested_fc
operator|<
literal|0
operator|||
name|requested_fc
operator|>
literal|3
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid fc mode; valid modes are 0 through 3\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	** Changing flow control mode currently does not work on 	** 40GBASE-CR4 PHYs 	*/
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|phy_type
operator|==
name|I40E_PHY_TYPE_40GBASE_CR4
operator|||
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|phy_type
operator|==
name|I40E_PHY_TYPE_40GBASE_CR4_CU
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Changing flow control mode unsupported"
literal|" on 40GBase-CR4 media.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Set fc ability for port */
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|requested_fc
expr_stmt|;
name|aq_error
operator|=
name|i40e_set_fc
argument_list|(
name|hw
argument_list|,
operator|&
name|fc_aq_err
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Error setting new fc mode %d; fc_err %#x\n"
argument_list|,
name|__func__
argument_list|,
name|aq_error
argument_list|,
name|fc_aq_err
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|pf
operator|->
name|fc
operator|=
name|requested_fc
expr_stmt|;
comment|/* Get new link state */
name|i40e_msec_delay
argument_list|(
literal|250
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|get_link_info
operator|=
name|TRUE
expr_stmt|;
name|i40e_get_link_status
argument_list|(
name|hw
argument_list|,
operator|&
name|pf
operator|->
name|link_up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_current_speed
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|speeds
index|[]
init|=
block|{
literal|"Unknown"
block|,
literal|"100M"
block|,
literal|"1G"
block|,
literal|"10G"
block|,
literal|"40G"
block|,
literal|"20G"
block|}
decl_stmt|;
name|ixl_update_link_status
argument_list|(
name|pf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|link_speed
condition|)
block|{
case|case
name|I40E_LINK_SPEED_100MB
case|:
name|index
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_1GB
case|:
name|index
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_10GB
case|:
name|index
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_40GB
case|:
name|index
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_20GB
case|:
name|index
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_UNKNOWN
case|:
default|default:
name|index
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|speeds
index|[
name|index
index|]
argument_list|,
name|strlen
argument_list|(
name|speeds
index|[
name|index
index|]
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_set_advertised_speeds
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|int
name|speeds
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities
decl_stmt|;
name|struct
name|i40e_aq_set_phy_config
name|config
decl_stmt|;
name|enum
name|i40e_status_code
name|aq_error
init|=
literal|0
decl_stmt|;
comment|/* Get current capability information */
name|aq_error
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|abilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Error getting phy capabilities %d,"
literal|" aq error: %d\n"
argument_list|,
name|__func__
argument_list|,
name|aq_error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
comment|/* Prepare new config */
name|bzero
argument_list|(
operator|&
name|config
argument_list|,
sizeof|sizeof
argument_list|(
name|config
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|.
name|phy_type
operator|=
name|abilities
operator|.
name|phy_type
expr_stmt|;
name|config
operator|.
name|abilities
operator|=
name|abilities
operator|.
name|abilities
operator||
name|I40E_AQ_PHY_ENABLE_ATOMIC_LINK
expr_stmt|;
name|config
operator|.
name|eee_capability
operator|=
name|abilities
operator|.
name|eee_capability
expr_stmt|;
name|config
operator|.
name|eeer
operator|=
name|abilities
operator|.
name|eeer_val
expr_stmt|;
name|config
operator|.
name|low_power_ctrl
operator|=
name|abilities
operator|.
name|d3_lpan
expr_stmt|;
comment|/* Translate into aq cmd link_speed */
if|if
condition|(
name|speeds
operator|&
literal|0x10
condition|)
name|config
operator|.
name|link_speed
operator||=
name|I40E_LINK_SPEED_40GB
expr_stmt|;
if|if
condition|(
name|speeds
operator|&
literal|0x8
condition|)
name|config
operator|.
name|link_speed
operator||=
name|I40E_LINK_SPEED_20GB
expr_stmt|;
if|if
condition|(
name|speeds
operator|&
literal|0x4
condition|)
name|config
operator|.
name|link_speed
operator||=
name|I40E_LINK_SPEED_10GB
expr_stmt|;
if|if
condition|(
name|speeds
operator|&
literal|0x2
condition|)
name|config
operator|.
name|link_speed
operator||=
name|I40E_LINK_SPEED_1GB
expr_stmt|;
if|if
condition|(
name|speeds
operator|&
literal|0x1
condition|)
name|config
operator|.
name|link_speed
operator||=
name|I40E_LINK_SPEED_100MB
expr_stmt|;
comment|/* Do aq command& restart link */
name|aq_error
operator|=
name|i40e_aq_set_phy_config
argument_list|(
name|hw
argument_list|,
operator|&
name|config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Error setting new phy config %d,"
literal|" aq error: %d\n"
argument_list|,
name|__func__
argument_list|,
name|aq_error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
comment|/* 	** This seems a bit heavy handed, but we 	** need to get a reinit on some devices 	*/
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_stop_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Control link advertise speed: **	Flags: **	 0x1 - advertise 100 Mb **	 0x2 - advertise 1G **	 0x4 - advertise 10G **	 0x8 - advertise 20G **	0x10 - advertise 40G ** **	Set to 0 to disable link */
end_comment

begin_function
specifier|static
name|int
name|ixl_set_advertise
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|requested_ls
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Read in new mode */
name|requested_ls
operator|=
name|pf
operator|->
name|advertised_speed
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|requested_ls
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Check for sane value */
if|if
condition|(
name|requested_ls
operator|>
literal|0x10
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid advertised speed; "
literal|"valid modes are 0x1 through 0x10\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Then check for validity based on adapter type */
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|I40E_DEV_ID_10G_BASE_T
case|:
case|case
name|I40E_DEV_ID_10G_BASE_T4
case|:
comment|/* BaseT */
if|if
condition|(
name|requested_ls
operator|&
operator|~
operator|(
literal|0x7
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Only 100M/1G/10G speeds supported on this device.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
name|I40E_DEV_ID_20G_KR2
case|:
case|case
name|I40E_DEV_ID_20G_KR2_A
case|:
comment|/* 20G */
if|if
condition|(
name|requested_ls
operator|&
operator|~
operator|(
literal|0xE
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Only 1G/10G/20G speeds supported on this device.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
name|I40E_DEV_ID_KX_B
case|:
case|case
name|I40E_DEV_ID_QSFP_A
case|:
case|case
name|I40E_DEV_ID_QSFP_B
case|:
comment|/* 40G */
if|if
condition|(
name|requested_ls
operator|&
operator|~
operator|(
literal|0x10
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Only 40G speeds supported on this device.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
default|default:
comment|/* 10G (1G) */
if|if
condition|(
name|requested_ls
operator|&
operator|~
operator|(
literal|0x6
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Only 1/10Gbs speeds are supported on this device.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
block|}
comment|/* Exit if no change */
if|if
condition|(
name|pf
operator|->
name|advertised_speed
operator|==
name|requested_ls
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|ixl_set_advertised_speeds
argument_list|(
name|pf
argument_list|,
name|requested_ls
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pf
operator|->
name|advertised_speed
operator|=
name|requested_ls
expr_stmt|;
name|ixl_update_link_status
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Get the width and transaction speed of ** the bus this adapter is plugged into. */
end_comment

begin_function
specifier|static
name|u16
name|ixl_get_bus_info
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|u16
name|link
decl_stmt|;
name|u32
name|offset
decl_stmt|;
comment|/* Get the PCI Express Capabilities offset */
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
comment|/* ...and read the Link Status Register */
name|link
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|offset
operator|+
name|PCIER_LINK_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|link
operator|&
name|I40E_PCI_LINK_WIDTH
condition|)
block|{
case|case
name|I40E_PCI_LINK_WIDTH_1
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|i40e_bus_width_pcie_x1
expr_stmt|;
break|break;
case|case
name|I40E_PCI_LINK_WIDTH_2
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|i40e_bus_width_pcie_x2
expr_stmt|;
break|break;
case|case
name|I40E_PCI_LINK_WIDTH_4
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|i40e_bus_width_pcie_x4
expr_stmt|;
break|break;
case|case
name|I40E_PCI_LINK_WIDTH_8
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|i40e_bus_width_pcie_x8
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|i40e_bus_width_unknown
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|link
operator|&
name|I40E_PCI_LINK_SPEED
condition|)
block|{
case|case
name|I40E_PCI_LINK_SPEED_2500
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|i40e_bus_speed_2500
expr_stmt|;
break|break;
case|case
name|I40E_PCI_LINK_SPEED_5000
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|i40e_bus_speed_5000
expr_stmt|;
break|break;
case|case
name|I40E_PCI_LINK_SPEED_8000
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|i40e_bus_speed_8000
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|i40e_bus_speed_unknown
expr_stmt|;
break|break;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI Express Bus: Speed %s %s\n"
argument_list|,
operator|(
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|i40e_bus_speed_8000
operator|)
condition|?
literal|"8.0GT/s"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|i40e_bus_speed_5000
operator|)
condition|?
literal|"5.0GT/s"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|i40e_bus_speed_2500
operator|)
condition|?
literal|"2.5GT/s"
else|:
literal|"Unknown"
operator|)
argument_list|,
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|i40e_bus_width_pcie_x8
operator|)
condition|?
literal|"Width x8"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|i40e_bus_width_pcie_x4
operator|)
condition|?
literal|"Width x4"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|i40e_bus_width_pcie_x1
operator|)
condition|?
literal|"Width x1"
else|:
operator|(
literal|"Unknown"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|<=
name|i40e_bus_width_pcie_x8
operator|)
operator|&&
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|<
name|i40e_bus_speed_8000
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI-Express bandwidth available"
literal|" for this device\n     may be insufficient for"
literal|" optimal performance.\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"For expected performance a x8 "
literal|"PCIE Gen3 slot is required.\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|link
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_show_fw
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sbuf
decl_stmt|;
name|sbuf
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|ixl_nvm_version_str
argument_list|(
name|hw
argument_list|,
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|inline
name|void
name|ixl_print_nvm_cmd
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|i40e_nvm_access
modifier|*
name|nvma
parameter_list|)
block|{
if|if
condition|(
operator|(
name|nvma
operator|->
name|command
operator|==
name|I40E_NVM_READ
operator|)
operator|&&
operator|(
operator|(
name|nvma
operator|->
name|config
operator|&
literal|0xFF
operator|)
operator|==
literal|0xF
operator|)
operator|&&
operator|(
operator|(
operator|(
name|nvma
operator|->
name|config
operator|&
literal|0xF00
operator|)
operator|>>
literal|8
operator|)
operator|==
literal|0xF
operator|)
operator|&&
operator|(
name|nvma
operator|->
name|offset
operator|==
literal|0
operator|)
operator|&&
operator|(
name|nvma
operator|->
name|data_size
operator|==
literal|1
operator|)
condition|)
block|{
comment|// device_printf(dev, "- Get Driver Status Command\n");
block|}
elseif|else
if|if
condition|(
name|nvma
operator|->
name|command
operator|==
name|I40E_NVM_READ
condition|)
block|{ 	 	}
else|else
block|{
switch|switch
condition|(
name|nvma
operator|->
name|command
condition|)
block|{
case|case
literal|0xB
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"- command: I40E_NVM_READ\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xC
case|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"- command: I40E_NVM_WRITE\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"- command: unknown 0x%08x\n"
argument_list|,
name|nvma
operator|->
name|command
argument_list|)
expr_stmt|;
break|break;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"- config (ptr)  : 0x%02x\n"
argument_list|,
name|nvma
operator|->
name|config
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"- config (flags): 0x%01x\n"
argument_list|,
operator|(
name|nvma
operator|->
name|config
operator|&
literal|0xF00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"- offset : 0x%08x\n"
argument_list|,
name|nvma
operator|->
name|offset
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"- data_s : 0x%08x\n"
argument_list|,
name|nvma
operator|->
name|data_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_handle_nvmupd_cmd
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ifdrv
modifier|*
name|ifd
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_nvm_access
modifier|*
name|nvma
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|enum
name|i40e_status_code
name|status
init|=
literal|0
decl_stmt|;
name|int
name|perrno
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixl_handle_nvmupd_cmd"
argument_list|)
expr_stmt|;
comment|/* Sanity checks */
if|if
condition|(
name|ifd
operator|->
name|ifd_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_nvm_access
argument_list|)
operator|||
name|ifd
operator|->
name|ifd_data
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: incorrect ifdrv length or data pointer\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: ifdrv length: %lu, sizeof(struct i40e_nvm_access): %lu\n"
argument_list|,
name|__func__
argument_list|,
name|ifd
operator|->
name|ifd_len
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_nvm_access
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: data pointer: %p\n"
argument_list|,
name|__func__
argument_list|,
name|ifd
operator|->
name|ifd_data
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|nvma
operator|=
operator|(
expr|struct
name|i40e_nvm_access
operator|*
operator|)
name|ifd
operator|->
name|ifd_data
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|ixl_print_nvm_cmd
argument_list|(
name|dev
argument_list|,
name|nvma
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pf
operator|->
name|state
operator|&
name|IXL_PF_STATE_EMPR_RESETTING
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|count
operator|++
operator|<
literal|100
condition|)
block|{
name|i40e_msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pf
operator|->
name|state
operator|&
name|IXL_PF_STATE_EMPR_RESETTING
operator|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|pf
operator|->
name|state
operator|&
name|IXL_PF_STATE_EMPR_RESETTING
operator|)
condition|)
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|status
operator|=
name|i40e_nvmupd_command
argument_list|(
name|hw
argument_list|,
name|nvma
argument_list|,
name|nvma
operator|->
name|data
argument_list|,
operator|&
name|perrno
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|perrno
operator|=
operator|-
name|EBUSY
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_nvmupd_command status %d, perrno %d\n"
argument_list|,
name|status
argument_list|,
name|perrno
argument_list|)
expr_stmt|;
comment|/* 	 * -EPERM is actually ERESTART, which the kernel interprets as it needing 	 * to run this ioctl again. So use -EACCES for -EPERM instead. 	 */
if|if
condition|(
name|perrno
operator|==
operator|-
name|EPERM
condition|)
return|return
operator|(
operator|-
name|EACCES
operator|)
return|;
else|else
return|return
operator|(
name|perrno
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_DEBUG_SYSCTL
end_ifdef

begin_function
specifier|static
name|int
name|ixl_sysctl_link_status
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_link_status
name|link_status
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|enum
name|i40e_status_code
name|aq_error
init|=
literal|0
decl_stmt|;
name|aq_error
operator|=
name|i40e_aq_get_link_info
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
operator|&
name|link_status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
name|printf
argument_list|(
literal|"i40e_aq_get_link_info() error %d\n"
argument_list|,
name|aq_error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n"
literal|"PHY Type : %#04x\n"
literal|"Speed    : %#04x\n"
literal|"Link info: %#04x\n"
literal|"AN info  : %#04x\n"
literal|"Ext info : %#04x\n"
literal|"Max Frame: %d\n"
literal|"Pacing   : %#04x\n"
literal|"CRC En?  : %d"
argument_list|,
name|link_status
operator|.
name|phy_type
argument_list|,
name|link_status
operator|.
name|link_speed
argument_list|,
name|link_status
operator|.
name|link_info
argument_list|,
name|link_status
operator|.
name|an_info
argument_list|,
name|link_status
operator|.
name|ext_info
argument_list|,
name|link_status
operator|.
name|max_frame_size
argument_list|,
name|link_status
operator|.
name|pacing
argument_list|,
name|link_status
operator|.
name|crc_enable
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_phy_abilities
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|enum
name|i40e_status_code
name|aq_error
init|=
literal|0
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities
decl_stmt|;
name|aq_error
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|abilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
name|printf
argument_list|(
literal|"i40e_aq_get_phy_capabilities() error %d\n"
argument_list|,
name|aq_error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n"
literal|"PHY Type : %#010x\n"
literal|"Speed    : %#04x\n"
literal|"Abilities: %#04x\n"
literal|"EEE cap  : %#06x\n"
literal|"EEER reg : %#010x\n"
literal|"D3 Lpan  : %#04x"
argument_list|,
name|abilities
operator|.
name|phy_type
argument_list|,
name|abilities
operator|.
name|link_speed
argument_list|,
name|abilities
operator|.
name|abilities
argument_list|,
name|abilities
operator|.
name|eee_capability
argument_list|,
name|abilities
operator|.
name|eeer_val
argument_list|,
name|abilities
operator|.
name|d3_lpan
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_sw_filter_list
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|buf_i
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|ftl_len
init|=
literal|0
decl_stmt|;
name|int
name|ftl_counter
init|=
literal|0
decl_stmt|;
name|int
name|buf_len
init|=
literal|0
decl_stmt|;
name|int
name|entry_len
init|=
literal|42
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
name|ftl_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ftl_len
operator|<
literal|1
condition|)
block|{
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
literal|"(none)"
argument_list|,
literal|6
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|buf_len
operator|=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|entry_len
operator|+
literal|1
operator|)
operator|*
name|ftl_len
operator|+
literal|2
expr_stmt|;
name|buf
operator|=
name|buf_i
operator|=
name|malloc
argument_list|(
name|buf_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf_i
operator|++
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
name|sprintf
argument_list|(
name|buf_i
argument_list|,
name|MAC_FORMAT
literal|", vlan %4d, flags %#06x"
argument_list|,
name|MAC_FORMAT_ARGS
argument_list|(
name|f
operator|->
name|macaddr
argument_list|)
argument_list|,
name|f
operator|->
name|vlan
argument_list|,
name|f
operator|->
name|flags
argument_list|)
expr_stmt|;
name|buf_i
operator|+=
name|entry_len
expr_stmt|;
comment|/* don't print '\n' for last entry */
if|if
condition|(
operator|++
name|ftl_counter
operator|!=
name|ftl_len
condition|)
block|{
name|sprintf
argument_list|(
name|buf_i
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|buf_i
operator|++
expr_stmt|;
block|}
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"sysctl error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IXL_SW_RES_SIZE
value|0x14
end_define

begin_function
specifier|static
name|int
name|ixl_res_alloc_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|i40e_aqc_switch_resource_alloc_element_resp
modifier|*
name|one
decl_stmt|,
modifier|*
name|two
decl_stmt|;
name|one
operator|=
operator|(
specifier|const
expr|struct
name|i40e_aqc_switch_resource_alloc_element_resp
operator|*
operator|)
name|a
expr_stmt|;
name|two
operator|=
operator|(
specifier|const
expr|struct
name|i40e_aqc_switch_resource_alloc_element_resp
operator|*
operator|)
name|b
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|one
operator|->
name|resource_type
operator|-
operator|(
name|int
operator|)
name|two
operator|->
name|resource_type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Longest string length: 25   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ixl_switch_res_type_string
parameter_list|(
name|u8
name|type
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|ixl_switch_res_type_strings
index|[
literal|0x14
index|]
init|=
block|{
literal|"VEB"
block|,
literal|"VSI"
block|,
literal|"Perfect Match MAC address"
block|,
literal|"S-tag"
block|,
literal|"(Reserved)"
block|,
literal|"Multicast hash entry"
block|,
literal|"Unicast hash entry"
block|,
literal|"VLAN"
block|,
literal|"VSI List entry"
block|,
literal|"(Reserved)"
block|,
literal|"VLAN Statistic Pool"
block|,
literal|"Mirror Rule"
block|,
literal|"Queue Set"
block|,
literal|"Inner VLAN Forward filter"
block|,
literal|"(Reserved)"
block|,
literal|"Inner MAC"
block|,
literal|"IP"
block|,
literal|"GRE/VN1 Key"
block|,
literal|"VN2 Key"
block|,
literal|"Tunneling Port"
block|}
decl_stmt|;
if|if
condition|(
name|type
operator|<
literal|0x14
condition|)
return|return
name|ixl_switch_res_type_strings
index|[
name|type
index|]
return|;
else|else
return|return
literal|"(Reserved)"
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_hw_res_alloc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|buf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u8
name|num_entries
decl_stmt|;
name|struct
name|i40e_aqc_switch_resource_alloc_element_resp
name|resp
index|[
name|IXL_SW_RES_SIZE
index|]
decl_stmt|;
name|buf
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for output.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_aq_get_switch_resource_alloc
argument_list|(
name|hw
argument_list|,
operator|&
name|num_entries
argument_list|,
name|resp
argument_list|,
name|IXL_SW_RES_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: get_switch_resource_alloc() error %d, aq error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Sort entries by type for display */
name|qsort
argument_list|(
name|resp
argument_list|,
name|num_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aqc_switch_resource_alloc_element_resp
argument_list|)
argument_list|,
operator|&
name|ixl_res_alloc_cmp
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"# of entries: %d\n"
argument_list|,
name|num_entries
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
if|#
directive|if
literal|0
argument_list|"Type | Guaranteed | Total | Used   | Un-allocated\n" 	    "     | (this)     | (all) | (this) | (all)       \n");
endif|#
directive|endif
literal|"                     Type | Guaranteed | Total | Used   | Un-allocated\n"
literal|"                          | (this)     | (all) | (this) | (all)       \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
if|#
directive|if
literal|0
argument_list|"%#4x | %10d   %5d   %6d   %12d", 		    resp[i].resource_type,
endif|#
directive|endif
literal|"%25s | %10d   %5d   %6d   %12d"
argument_list|,
name|ixl_switch_res_type_string
argument_list|(
name|resp
index|[
name|i
index|]
operator|.
name|resource_type
argument_list|)
argument_list|,
name|resp
index|[
name|i
index|]
operator|.
name|guaranteed
argument_list|,
name|resp
index|[
name|i
index|]
operator|.
name|total
argument_list|,
name|resp
index|[
name|i
index|]
operator|.
name|used
argument_list|,
name|resp
index|[
name|i
index|]
operator|.
name|total_unalloced
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|num_entries
operator|-
literal|1
condition|)
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sbuf_finish
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error finishing sbuf: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ** Caller must init and delete sbuf; this function will clear and ** finish it for caller. ** ** XXX: Cannot use the SEID for this, since there is no longer a  ** fixed mapping between SEID and element type. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ixl_switch_element_string
parameter_list|(
name|struct
name|sbuf
modifier|*
name|s
parameter_list|,
name|struct
name|i40e_aqc_switch_config_element_resp
modifier|*
name|element
parameter_list|)
block|{
name|sbuf_clear
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|element
operator|->
name|element_type
condition|)
block|{
case|case
name|I40E_AQ_SW_ELEM_TYPE_MAC
case|:
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"MAC %3d"
argument_list|,
name|element
operator|->
name|element_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_PF
case|:
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"PF  %3d"
argument_list|,
name|element
operator|->
name|element_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_VF
case|:
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"VF  %3d"
argument_list|,
name|element
operator|->
name|element_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_EMP
case|:
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"EMP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_BMC
case|:
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"BMC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_PV
case|:
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"PV"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_VEB
case|:
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"VEB"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_PA
case|:
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"PA"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_AQ_SW_ELEM_TYPE_VSI
case|:
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"VSI %3d"
argument_list|,
name|element
operator|->
name|element_info
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbuf_finish
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|sbuf_data
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_switch_config
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|buf
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|nmbuf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u16
name|next
init|=
literal|0
decl_stmt|;
name|u8
name|aq_buf
index|[
name|I40E_AQ_LARGE_BUF
index|]
decl_stmt|;
name|struct
name|i40e_aqc_get_switch_config_resp
modifier|*
name|sw_config
decl_stmt|;
name|sw_config
operator|=
operator|(
expr|struct
name|i40e_aqc_get_switch_config_resp
operator|*
operator|)
name|aq_buf
expr_stmt|;
name|buf
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for sysctl output.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|i40e_aq_get_switch_config
argument_list|(
name|hw
argument_list|,
name|sw_config
argument_list|,
sizeof|sizeof
argument_list|(
name|aq_buf
argument_list|)
argument_list|,
operator|&
name|next
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: aq_get_switch_config() error %d, aq error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|next
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: TODO: get more config with SEID %d\n"
argument_list|,
name|__func__
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|nmbuf
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nmbuf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for name output.\n"
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|// Assuming<= 255 elements in switch
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"# of reported elements: %d\n"
argument_list|,
name|sw_config
operator|->
name|header
operator|.
name|num_reported
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"total # of elements: %d\n"
argument_list|,
name|sw_config
operator|->
name|header
operator|.
name|num_total
argument_list|)
expr_stmt|;
comment|/* Exclude: 	** Revision -- all elements are revision 1 for now 	*/
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"SEID (  Name  ) |  Uplink  | Downlink | Conn Type\n"
literal|"                |          |          | (uplink)\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sw_config
operator|->
name|header
operator|.
name|num_reported
condition|;
name|i
operator|++
control|)
block|{
comment|// "%4d (%8s) | %8s   %8s   %#8x",
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%4d"
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|seid
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"(%8s)"
argument_list|,
name|ixl_switch_element_string
argument_list|(
name|nmbuf
argument_list|,
operator|&
name|sw_config
operator|->
name|element
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%8d"
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|uplink_seid
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%8d"
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|downlink_seid
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%#8x"
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|connection_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|sw_config
operator|->
name|header
operator|.
name|num_reported
operator|-
literal|1
condition|)
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sbuf_delete
argument_list|(
name|nmbuf
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error finishing sbuf: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_debug_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|input
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|input
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|input
operator|==
literal|1
condition|)
block|{
name|pf
operator|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
expr_stmt|;
name|ixl_print_debug_info
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_print_debug_info
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|printf
argument_list|(
literal|"Queue irqs = %jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|que
operator|->
name|irqs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"AdminQ irqs = %jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pf
operator|->
name|admin_irq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX next check = %x\n"
argument_list|,
name|rxr
operator|->
name|next_check
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX not ready = %jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rxr
operator|->
name|not_done
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX packets = %jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rxr
operator|->
name|rx_packets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TX desc avail = %x\n"
argument_list|,
name|txr
operator|->
name|avail
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_GORCL
argument_list|(
literal|0xc
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX Bytes = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_GORCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Port RX Bytes = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_RDPC
argument_list|(
literal|0xc
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX discard = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RDPC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Port RX discard = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_TEPC
argument_list|(
literal|0xc
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TX errors = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_GOTCL
argument_list|(
literal|0xc
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TX Bytes = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RUC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX undersize = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX fragments = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_ROC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX oversize = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RLEC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX length error = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MRFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mac remote fault = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MLFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mac local fault = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IXL_DEBUG_SYSCTL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_IOV
end_ifdef

begin_function
specifier|static
name|int
name|ixl_vf_alloc_vsi
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
decl_stmt|;
name|struct
name|i40e_vsi_context
name|vsi_ctx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|first_queue
decl_stmt|;
name|enum
name|i40e_status_code
name|code
decl_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|vsi
operator|=
operator|&
name|pf
operator|->
name|vsi
expr_stmt|;
name|vsi_ctx
operator|.
name|pf_num
operator|=
name|hw
operator|->
name|pf_id
expr_stmt|;
name|vsi_ctx
operator|.
name|uplink_seid
operator|=
name|pf
operator|->
name|veb_seid
expr_stmt|;
name|vsi_ctx
operator|.
name|connection_type
operator|=
name|IXL_VSI_DATA_PORT
expr_stmt|;
name|vsi_ctx
operator|.
name|vf_num
operator|=
name|hw
operator|->
name|func_caps
operator|.
name|vf_base_id
operator|+
name|vf
operator|->
name|vf_num
expr_stmt|;
name|vsi_ctx
operator|.
name|flags
operator|=
name|I40E_AQ_VSI_TYPE_VF
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|vsi_ctx
operator|.
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|vsi_ctx
operator|.
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|vsi_ctx
operator|.
name|info
operator|.
name|valid_sections
operator|=
name|htole16
argument_list|(
name|I40E_AQ_VSI_PROP_SWITCH_VALID
argument_list|)
expr_stmt|;
name|vsi_ctx
operator|.
name|info
operator|.
name|switch_id
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vsi_ctx
operator|.
name|info
operator|.
name|valid_sections
operator||=
name|htole16
argument_list|(
name|I40E_AQ_VSI_PROP_SECURITY_VALID
argument_list|)
expr_stmt|;
name|vsi_ctx
operator|.
name|info
operator|.
name|sec_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vf
operator|->
name|vf_flags
operator|&
name|VF_FLAG_MAC_ANTI_SPOOF
condition|)
name|vsi_ctx
operator|.
name|info
operator|.
name|sec_flags
operator||=
name|I40E_AQ_VSI_SEC_FLAG_ENABLE_MAC_CHK
expr_stmt|;
comment|/* TODO: If a port VLAN is set, then this needs to be changed */
name|vsi_ctx
operator|.
name|info
operator|.
name|valid_sections
operator||=
name|htole16
argument_list|(
name|I40E_AQ_VSI_PROP_VLAN_VALID
argument_list|)
expr_stmt|;
name|vsi_ctx
operator|.
name|info
operator|.
name|port_vlan_flags
operator|=
name|I40E_AQ_VSI_PVLAN_MODE_ALL
operator||
name|I40E_AQ_VSI_PVLAN_EMOD_NOTHING
expr_stmt|;
name|vsi_ctx
operator|.
name|info
operator|.
name|valid_sections
operator||=
name|htole16
argument_list|(
name|I40E_AQ_VSI_PROP_QUEUE_MAP_VALID
argument_list|)
expr_stmt|;
name|vsi_ctx
operator|.
name|info
operator|.
name|mapping_flags
operator|=
name|htole16
argument_list|(
name|I40E_AQ_VSI_QUE_MAP_NONCONTIG
argument_list|)
expr_stmt|;
name|first_queue
operator|=
name|vsi
operator|->
name|num_queues
operator|+
name|vf
operator|->
name|vf_num
operator|*
name|IXLV_MAX_QUEUES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXLV_MAX_QUEUES
condition|;
name|i
operator|++
control|)
name|vsi_ctx
operator|.
name|info
operator|.
name|queue_mapping
index|[
name|i
index|]
operator|=
name|htole16
argument_list|(
name|first_queue
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nitems
argument_list|(
name|vsi_ctx
operator|.
name|info
operator|.
name|queue_mapping
argument_list|)
condition|;
name|i
operator|++
control|)
name|vsi_ctx
operator|.
name|info
operator|.
name|queue_mapping
index|[
name|i
index|]
operator|=
name|htole16
argument_list|(
name|I40E_AQ_VSI_QUEUE_MASK
argument_list|)
expr_stmt|;
name|vsi_ctx
operator|.
name|info
operator|.
name|tc_mapping
index|[
literal|0
index|]
operator|=
name|htole16
argument_list|(
operator|(
literal|0
operator|<<
name|I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|i40e_aq_add_vsi
argument_list|(
name|hw
argument_list|,
operator|&
name|vsi_ctx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|I40E_SUCCESS
condition|)
return|return
operator|(
name|ixl_adminq_err_to_errno
argument_list|(
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
operator|)
return|;
name|vf
operator|->
name|vsi
operator|.
name|seid
operator|=
name|vsi_ctx
operator|.
name|seid
expr_stmt|;
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
operator|=
name|vsi_ctx
operator|.
name|vsi_number
expr_stmt|;
name|vf
operator|->
name|vsi
operator|.
name|first_queue
operator|=
name|first_queue
expr_stmt|;
name|vf
operator|->
name|vsi
operator|.
name|num_queues
operator|=
name|IXLV_MAX_QUEUES
expr_stmt|;
name|code
operator|=
name|i40e_aq_get_vsi_params
argument_list|(
name|hw
argument_list|,
operator|&
name|vsi_ctx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|I40E_SUCCESS
condition|)
return|return
operator|(
name|ixl_adminq_err_to_errno
argument_list|(
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
operator|)
return|;
name|code
operator|=
name|i40e_aq_config_vsi_bw_limit
argument_list|(
name|hw
argument_list|,
name|vf
operator|->
name|vsi
operator|.
name|seid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|I40E_SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Failed to disable BW limit: %d\n"
argument_list|,
name|ixl_adminq_err_to_errno
argument_list|(
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ixl_adminq_err_to_errno
argument_list|(
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|vf
operator|->
name|vsi
operator|.
name|info
argument_list|,
operator|&
name|vsi_ctx
operator|.
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|vf
operator|->
name|vsi
operator|.
name|info
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_vf_setup_vsi
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|int
name|error
decl_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|error
operator|=
name|ixl_vf_alloc_vsi
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vf
operator|->
name|vsi
operator|.
name|hw_filters_add
operator|=
literal|0
expr_stmt|;
name|vf
operator|->
name|vsi
operator|.
name|hw_filters_del
operator|=
literal|0
expr_stmt|;
name|ixl_add_filter
argument_list|(
operator|&
name|vf
operator|->
name|vsi
argument_list|,
name|ixl_bcast_addr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
name|ixl_reconfigure_filters
argument_list|(
operator|&
name|vf
operator|->
name|vsi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_map_vsi_queue
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|int
name|qnum
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint32_t
name|qtable
decl_stmt|;
name|int
name|index
decl_stmt|,
name|shift
decl_stmt|;
comment|/* 	 * Two queues are mapped in a single register, so we have to do some 	 * gymnastics to convert the queue number into a register index and 	 * shift. 	 */
name|index
operator|=
name|qnum
operator|/
literal|2
expr_stmt|;
name|shift
operator|=
operator|(
name|qnum
operator|%
literal|2
operator|)
operator|*
name|I40E_VSILAN_QTABLE_QINDEX_1_SHIFT
expr_stmt|;
name|qtable
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VSILAN_QTABLE
argument_list|(
name|index
argument_list|,
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
argument_list|)
argument_list|)
expr_stmt|;
name|qtable
operator|&=
operator|~
operator|(
name|I40E_VSILAN_QTABLE_QINDEX_0_MASK
operator|<<
name|shift
operator|)
expr_stmt|;
name|qtable
operator||=
name|val
operator|<<
name|shift
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VSILAN_QTABLE
argument_list|(
name|index
argument_list|,
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
argument_list|)
argument_list|,
name|qtable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_map_queues
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|uint32_t
name|qtable
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
comment|/* 	 * Contiguous mappings aren't actually supported by the hardware, 	 * so we have to use non-contiguous mappings. 	 */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VSILAN_QBASE
argument_list|(
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
argument_list|)
argument_list|,
name|I40E_VSILAN_QBASE_VSIQTABLE_ENA_MASK
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VPLAN_MAPENA
argument_list|(
name|vf
operator|->
name|vf_num
argument_list|)
argument_list|,
name|I40E_VPLAN_MAPENA_TXRX_ENA_MASK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vf
operator|->
name|vsi
operator|.
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|qtable
operator|=
operator|(
name|vf
operator|->
name|vsi
operator|.
name|first_queue
operator|+
name|i
operator|)
operator|<<
name|I40E_VPLAN_QTABLE_QINDEX_SHIFT
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VPLAN_QTABLE
argument_list|(
name|i
argument_list|,
name|vf
operator|->
name|vf_num
argument_list|)
argument_list|,
name|qtable
argument_list|)
expr_stmt|;
block|}
comment|/* Map queues allocated to VF to its VSI. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vf
operator|->
name|vsi
operator|.
name|num_queues
condition|;
name|i
operator|++
control|)
name|ixl_vf_map_vsi_queue
argument_list|(
name|hw
argument_list|,
name|vf
argument_list|,
name|i
argument_list|,
name|vf
operator|->
name|vsi
operator|.
name|first_queue
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* Set rest of VSI queues as unused. */
for|for
control|(
init|;
name|i
operator|<
name|IXL_MAX_VSI_QUEUES
condition|;
name|i
operator|++
control|)
name|ixl_vf_map_vsi_queue
argument_list|(
name|hw
argument_list|,
name|vf
argument_list|,
name|i
argument_list|,
name|I40E_VSILAN_QTABLE_QINDEX_0_MASK
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_vsi_release
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|seid
operator|==
literal|0
condition|)
return|return;
name|i40e_aq_delete_element
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_disable_queue_intr
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|vfint_reg
parameter_list|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|vfint_reg
argument_list|,
name|I40E_VFINT_DYN_CTLN_CLEARPBA_MASK
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_unregister_intr
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|uint32_t
name|vpint_reg
parameter_list|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|vpint_reg
argument_list|,
name|I40E_VPINT_LNKLSTN_FIRSTQ_TYPE_MASK
operator||
name|I40E_VPINT_LNKLSTN_FIRSTQ_INDX_MASK
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_release_resources
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|uint32_t
name|vfint_reg
decl_stmt|,
name|vpint_reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|ixl_vf_vsi_release
argument_list|(
name|pf
argument_list|,
operator|&
name|vf
operator|->
name|vsi
argument_list|)
expr_stmt|;
comment|/* Index 0 has a special register. */
name|ixl_vf_disable_queue_intr
argument_list|(
name|hw
argument_list|,
name|I40E_VFINT_DYN_CTL0
argument_list|(
name|vf
operator|->
name|vf_num
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|hw
operator|->
name|func_caps
operator|.
name|num_msix_vectors_vf
condition|;
name|i
operator|++
control|)
block|{
name|vfint_reg
operator|=
name|IXL_VFINT_DYN_CTLN_REG
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
name|vf
operator|->
name|vf_num
argument_list|)
expr_stmt|;
name|ixl_vf_disable_queue_intr
argument_list|(
name|hw
argument_list|,
name|vfint_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Index 0 has a special register. */
name|ixl_vf_unregister_intr
argument_list|(
name|hw
argument_list|,
name|I40E_VPINT_LNKLST0
argument_list|(
name|vf
operator|->
name|vf_num
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|hw
operator|->
name|func_caps
operator|.
name|num_msix_vectors_vf
condition|;
name|i
operator|++
control|)
block|{
name|vpint_reg
operator|=
name|IXL_VPINT_LNKLSTN_REG
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
name|vf
operator|->
name|vf_num
argument_list|)
expr_stmt|;
name|ixl_vf_unregister_intr
argument_list|(
name|hw
argument_list|,
name|vpint_reg
argument_list|)
expr_stmt|;
block|}
name|vf
operator|->
name|vsi
operator|.
name|num_queues
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_flush_pcie
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|global_vf_num
decl_stmt|;
name|uint32_t
name|ciad
decl_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|global_vf_num
operator|=
name|hw
operator|->
name|func_caps
operator|.
name|vf_base_id
operator|+
name|vf
operator|->
name|vf_num
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_PCI_CIAA
argument_list|,
name|IXL_PF_PCI_CIAA_VF_DEVICE_STATUS
operator||
operator|(
name|global_vf_num
operator|<<
name|I40E_PF_PCI_CIAA_VF_NUM_SHIFT
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXL_VF_RESET_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|ciad
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_PCI_CIAD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ciad
operator|&
name|IXL_PF_PCI_CIAD_VF_TRANS_PENDING_MASK
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_reset_vf
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|uint32_t
name|vfrtrig
decl_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|vfrtrig
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VPGEN_VFRTRIG
argument_list|(
name|vf
operator|->
name|vf_num
argument_list|)
argument_list|)
expr_stmt|;
name|vfrtrig
operator||=
name|I40E_VPGEN_VFRTRIG_VFSWR_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VPGEN_VFRTRIG
argument_list|(
name|vf
operator|->
name|vf_num
argument_list|)
argument_list|,
name|vfrtrig
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixl_reinit_vf
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_reinit_vf
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|uint32_t
name|vfrstat
decl_stmt|,
name|vfrtrig
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|error
operator|=
name|ixl_flush_pcie
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Timed out waiting for PCIe activity to stop on VF-%d\n"
argument_list|,
name|vf
operator|->
name|vf_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXL_VF_RESET_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|vfrstat
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VPGEN_VFRSTAT
argument_list|(
name|vf
operator|->
name|vf_num
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfrstat
operator|&
name|I40E_VPGEN_VFRSTAT_VFRD_MASK
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|IXL_VF_RESET_TIMEOUT
condition|)
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"VF %d failed to reset\n"
argument_list|,
name|vf
operator|->
name|vf_num
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFGEN_RSTAT1
argument_list|(
name|vf
operator|->
name|vf_num
argument_list|)
argument_list|,
name|I40E_VFR_COMPLETED
argument_list|)
expr_stmt|;
name|vfrtrig
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_VPGEN_VFRTRIG
argument_list|(
name|vf
operator|->
name|vf_num
argument_list|)
argument_list|)
expr_stmt|;
name|vfrtrig
operator|&=
operator|~
name|I40E_VPGEN_VFRTRIG_VFSWR_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VPGEN_VFRTRIG
argument_list|(
name|vf
operator|->
name|vf_num
argument_list|)
argument_list|,
name|vfrtrig
argument_list|)
expr_stmt|;
if|if
condition|(
name|vf
operator|->
name|vsi
operator|.
name|seid
operator|!=
literal|0
condition|)
name|ixl_disable_rings
argument_list|(
operator|&
name|vf
operator|->
name|vsi
argument_list|)
expr_stmt|;
name|ixl_vf_release_resources
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|)
expr_stmt|;
name|ixl_vf_setup_vsi
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|)
expr_stmt|;
name|ixl_vf_map_queues
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_VFGEN_RSTAT1
argument_list|(
name|vf
operator|->
name|vf_num
argument_list|)
argument_list|,
name|I40E_VFR_VFACTIVE
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ixl_vc_opcode_str
parameter_list|(
name|uint16_t
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|I40E_VIRTCHNL_OP_VERSION
case|:
return|return
operator|(
literal|"VERSION"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_RESET_VF
case|:
return|return
operator|(
literal|"RESET_VF"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_GET_VF_RESOURCES
case|:
return|return
operator|(
literal|"GET_VF_RESOURCES"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_CONFIG_TX_QUEUE
case|:
return|return
operator|(
literal|"CONFIG_TX_QUEUE"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_CONFIG_RX_QUEUE
case|:
return|return
operator|(
literal|"CONFIG_RX_QUEUE"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES
case|:
return|return
operator|(
literal|"CONFIG_VSI_QUEUES"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP
case|:
return|return
operator|(
literal|"CONFIG_IRQ_MAP"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_ENABLE_QUEUES
case|:
return|return
operator|(
literal|"ENABLE_QUEUES"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_DISABLE_QUEUES
case|:
return|return
operator|(
literal|"DISABLE_QUEUES"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS
case|:
return|return
operator|(
literal|"ADD_ETHER_ADDRESS"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_DEL_ETHER_ADDRESS
case|:
return|return
operator|(
literal|"DEL_ETHER_ADDRESS"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_ADD_VLAN
case|:
return|return
operator|(
literal|"ADD_VLAN"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_DEL_VLAN
case|:
return|return
operator|(
literal|"DEL_VLAN"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE
case|:
return|return
operator|(
literal|"CONFIG_PROMISCUOUS_MODE"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_GET_STATS
case|:
return|return
operator|(
literal|"GET_STATS"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_FCOE
case|:
return|return
operator|(
literal|"FCOE"
operator|)
return|;
case|case
name|I40E_VIRTCHNL_OP_EVENT
case|:
return|return
operator|(
literal|"EVENT"
operator|)
return|;
default|default:
return|return
operator|(
literal|"UNKNOWN"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_vc_opcode_level
parameter_list|(
name|uint16_t
name|opcode
parameter_list|)
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|I40E_VIRTCHNL_OP_GET_STATS
case|:
return|return
operator|(
literal|10
operator|)
return|;
default|default:
return|return
operator|(
literal|5
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_send_vf_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|uint16_t
name|op
parameter_list|,
name|enum
name|i40e_status_code
name|status
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|len
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|int
name|global_vf_id
decl_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|global_vf_id
operator|=
name|hw
operator|->
name|func_caps
operator|.
name|vf_base_id
operator|+
name|vf
operator|->
name|vf_num
expr_stmt|;
name|I40E_VC_DEBUG
argument_list|(
name|pf
argument_list|,
name|ixl_vc_opcode_level
argument_list|(
name|op
argument_list|)
argument_list|,
literal|"Sending msg (op=%s[%d], status=%d) to VF-%d\n"
argument_list|,
name|ixl_vc_opcode_str
argument_list|(
name|op
argument_list|)
argument_list|,
name|op
argument_list|,
name|status
argument_list|,
name|vf
operator|->
name|vf_num
argument_list|)
expr_stmt|;
name|i40e_aq_send_msg_to_vf
argument_list|(
name|hw
argument_list|,
name|global_vf_id
argument_list|,
name|op
argument_list|,
name|status
argument_list|,
name|msg
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_send_vf_ack
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|uint16_t
name|op
parameter_list|)
block|{
name|ixl_send_vf_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|op
argument_list|,
name|I40E_SUCCESS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_send_vf_nack_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|uint16_t
name|op
parameter_list|,
name|enum
name|i40e_status_code
name|status
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|I40E_VC_DEBUG
argument_list|(
name|pf
argument_list|,
literal|1
argument_list|,
literal|"Sending NACK (op=%s[%d], err=%d) to VF-%d from %s:%d\n"
argument_list|,
name|ixl_vc_opcode_str
argument_list|(
name|op
argument_list|)
argument_list|,
name|op
argument_list|,
name|status
argument_list|,
name|vf
operator|->
name|vf_num
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|ixl_send_vf_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|op
argument_list|,
name|status
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_version_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|msg_size
parameter_list|)
block|{
name|struct
name|i40e_virtchnl_version_info
name|reply
decl_stmt|;
if|if
condition|(
name|msg_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_virtchnl_version_info
argument_list|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_VERSION
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|vf
operator|->
name|version
operator|=
operator|(
operator|(
expr|struct
name|i40e_virtchnl_version_info
operator|*
operator|)
name|msg
operator|)
operator|->
name|minor
expr_stmt|;
name|reply
operator|.
name|major
operator|=
name|I40E_VIRTCHNL_VERSION_MAJOR
expr_stmt|;
name|reply
operator|.
name|minor
operator|=
name|I40E_VIRTCHNL_VERSION_MINOR
expr_stmt|;
name|ixl_send_vf_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_VERSION
argument_list|,
name|I40E_SUCCESS
argument_list|,
operator|&
name|reply
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_reset_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|msg_size
parameter_list|)
block|{
if|if
condition|(
name|msg_size
operator|!=
literal|0
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_RESET_VF
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|ixl_reset_vf
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|)
expr_stmt|;
comment|/* No response to a reset message. */
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_get_resources_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|msg_size
parameter_list|)
block|{
name|struct
name|i40e_virtchnl_vf_resource
name|reply
decl_stmt|;
if|if
condition|(
operator|(
name|vf
operator|->
name|version
operator|==
literal|0
operator|&&
name|msg_size
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vf
operator|->
name|version
operator|==
literal|1
operator|&&
name|msg_size
operator|!=
literal|4
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Invalid GET_VF_RESOURCES message size,"
literal|" for VF version %d.%d\n"
argument_list|,
name|I40E_VIRTCHNL_VERSION_MAJOR
argument_list|,
name|vf
operator|->
name|version
argument_list|)
expr_stmt|;
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_GET_VF_RESOURCES
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
operator|&
name|reply
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vf
operator|->
name|version
operator|==
name|I40E_VIRTCHNL_VERSION_MINOR_NO_VF_CAPS
condition|)
name|reply
operator|.
name|vf_offload_flags
operator|=
name|I40E_VIRTCHNL_VF_OFFLOAD_L2
operator||
name|I40E_VIRTCHNL_VF_OFFLOAD_RSS_REG
operator||
name|I40E_VIRTCHNL_VF_OFFLOAD_VLAN
expr_stmt|;
else|else
name|reply
operator|.
name|vf_offload_flags
operator|=
operator|*
operator|(
name|u32
operator|*
operator|)
name|msg
expr_stmt|;
name|reply
operator|.
name|num_vsis
operator|=
literal|1
expr_stmt|;
name|reply
operator|.
name|num_queue_pairs
operator|=
name|vf
operator|->
name|vsi
operator|.
name|num_queues
expr_stmt|;
name|reply
operator|.
name|max_vectors
operator|=
name|pf
operator|->
name|hw
operator|.
name|func_caps
operator|.
name|num_msix_vectors_vf
expr_stmt|;
name|reply
operator|.
name|vsi_res
index|[
literal|0
index|]
operator|.
name|vsi_id
operator|=
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
expr_stmt|;
name|reply
operator|.
name|vsi_res
index|[
literal|0
index|]
operator|.
name|vsi_type
operator|=
name|I40E_VSI_SRIOV
expr_stmt|;
name|reply
operator|.
name|vsi_res
index|[
literal|0
index|]
operator|.
name|num_queue_pairs
operator|=
name|vf
operator|->
name|vsi
operator|.
name|num_queues
expr_stmt|;
name|memcpy
argument_list|(
name|reply
operator|.
name|vsi_res
index|[
literal|0
index|]
operator|.
name|default_mac_addr
argument_list|,
name|vf
operator|->
name|mac
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|ixl_send_vf_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_GET_VF_RESOURCES
argument_list|,
name|I40E_SUCCESS
argument_list|,
operator|&
name|reply
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_vf_config_tx_queue
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|struct
name|i40e_virtchnl_txq_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|struct
name|i40e_hmc_obj_txq
name|txq
decl_stmt|;
name|uint16_t
name|global_queue_num
decl_stmt|,
name|global_vf_num
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|uint32_t
name|qtx_ctl
decl_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|global_queue_num
operator|=
name|vf
operator|->
name|vsi
operator|.
name|first_queue
operator|+
name|info
operator|->
name|queue_id
expr_stmt|;
name|global_vf_num
operator|=
name|hw
operator|->
name|func_caps
operator|.
name|vf_base_id
operator|+
name|vf
operator|->
name|vf_num
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|txq
argument_list|,
sizeof|sizeof
argument_list|(
name|txq
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|i40e_clear_lan_tx_queue_context
argument_list|(
name|hw
argument_list|,
name|global_queue_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|I40E_SUCCESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|txq
operator|.
name|base
operator|=
name|info
operator|->
name|dma_ring_addr
operator|/
name|IXL_TX_CTX_BASE_UNITS
expr_stmt|;
name|txq
operator|.
name|head_wb_ena
operator|=
name|info
operator|->
name|headwb_enabled
expr_stmt|;
name|txq
operator|.
name|head_wb_addr
operator|=
name|info
operator|->
name|dma_headwb_addr
expr_stmt|;
name|txq
operator|.
name|qlen
operator|=
name|info
operator|->
name|ring_len
expr_stmt|;
name|txq
operator|.
name|rdylist
operator|=
name|le16_to_cpu
argument_list|(
name|vf
operator|->
name|vsi
operator|.
name|info
operator|.
name|qs_handle
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|txq
operator|.
name|rdylist_act
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|i40e_set_lan_tx_queue_context
argument_list|(
name|hw
argument_list|,
name|global_queue_num
argument_list|,
operator|&
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|I40E_SUCCESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|qtx_ctl
operator|=
name|I40E_QTX_CTL_VF_QUEUE
operator||
operator|(
name|hw
operator|->
name|pf_id
operator|<<
name|I40E_QTX_CTL_PF_INDX_SHIFT
operator|)
operator||
operator|(
name|global_vf_num
operator|<<
name|I40E_QTX_CTL_VFVM_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_CTL
argument_list|(
name|global_queue_num
argument_list|)
argument_list|,
name|qtx_ctl
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_vf_config_rx_queue
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|struct
name|i40e_virtchnl_rxq_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|struct
name|i40e_hmc_obj_rxq
name|rxq
decl_stmt|;
name|uint16_t
name|global_queue_num
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|global_queue_num
operator|=
name|vf
operator|->
name|vsi
operator|.
name|first_queue
operator|+
name|info
operator|->
name|queue_id
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|rxq
argument_list|,
sizeof|sizeof
argument_list|(
name|rxq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|databuffer_size
operator|>
name|IXL_VF_MAX_BUFFER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|info
operator|->
name|max_pkt_size
operator|>
name|IXL_VF_MAX_FRAME
operator|||
name|info
operator|->
name|max_pkt_size
operator|<
name|ETHER_MIN_LEN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|info
operator|->
name|splithdr_enabled
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|hdr_size
operator|>
name|IXL_VF_MAX_HDR_BUFFER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rxq
operator|.
name|hsplit_0
operator|=
name|info
operator|->
name|rx_split_pos
operator|&
operator|(
name|I40E_HMC_OBJ_RX_HSPLIT_0_SPLIT_L2
operator||
name|I40E_HMC_OBJ_RX_HSPLIT_0_SPLIT_IP
operator||
name|I40E_HMC_OBJ_RX_HSPLIT_0_SPLIT_TCP_UDP
operator||
name|I40E_HMC_OBJ_RX_HSPLIT_0_SPLIT_SCTP
operator|)
expr_stmt|;
name|rxq
operator|.
name|hbuff
operator|=
name|info
operator|->
name|hdr_size
operator|>>
name|I40E_RXQ_CTX_HBUFF_SHIFT
expr_stmt|;
name|rxq
operator|.
name|dtype
operator|=
literal|2
expr_stmt|;
block|}
name|status
operator|=
name|i40e_clear_lan_rx_queue_context
argument_list|(
name|hw
argument_list|,
name|global_queue_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|I40E_SUCCESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rxq
operator|.
name|base
operator|=
name|info
operator|->
name|dma_ring_addr
operator|/
name|IXL_RX_CTX_BASE_UNITS
expr_stmt|;
name|rxq
operator|.
name|qlen
operator|=
name|info
operator|->
name|ring_len
expr_stmt|;
name|rxq
operator|.
name|dbuff
operator|=
name|info
operator|->
name|databuffer_size
operator|>>
name|I40E_RXQ_CTX_DBUFF_SHIFT
expr_stmt|;
name|rxq
operator|.
name|dsize
operator|=
literal|1
expr_stmt|;
name|rxq
operator|.
name|crcstrip
operator|=
literal|1
expr_stmt|;
name|rxq
operator|.
name|l2tsel
operator|=
literal|1
expr_stmt|;
name|rxq
operator|.
name|rxmax
operator|=
name|info
operator|->
name|max_pkt_size
expr_stmt|;
name|rxq
operator|.
name|tphrdesc_ena
operator|=
literal|1
expr_stmt|;
name|rxq
operator|.
name|tphwdesc_ena
operator|=
literal|1
expr_stmt|;
name|rxq
operator|.
name|tphdata_ena
operator|=
literal|1
expr_stmt|;
name|rxq
operator|.
name|tphhead_ena
operator|=
literal|1
expr_stmt|;
name|rxq
operator|.
name|lrxqthresh
operator|=
literal|2
expr_stmt|;
name|rxq
operator|.
name|prefena
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|i40e_set_lan_rx_queue_context
argument_list|(
name|hw
argument_list|,
name|global_queue_num
argument_list|,
operator|&
name|rxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|I40E_SUCCESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_config_vsi_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|msg_size
parameter_list|)
block|{
name|struct
name|i40e_virtchnl_vsi_queue_config_info
modifier|*
name|info
decl_stmt|;
name|struct
name|i40e_virtchnl_queue_pair_info
modifier|*
name|pair
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|msg_size
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|info
operator|=
name|msg
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|num_queue_pairs
operator|==
literal|0
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|msg_size
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
operator|+
name|info
operator|->
name|num_queue_pairs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|pair
argument_list|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|info
operator|->
name|vsi_id
operator|!=
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|num_queue_pairs
condition|;
name|i
operator|++
control|)
block|{
name|pair
operator|=
operator|&
name|info
operator|->
name|qpair
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pair
operator|->
name|txq
operator|.
name|vsi_id
operator|!=
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
operator|||
name|pair
operator|->
name|rxq
operator|.
name|vsi_id
operator|!=
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
operator|||
name|pair
operator|->
name|txq
operator|.
name|queue_id
operator|!=
name|pair
operator|->
name|rxq
operator|.
name|queue_id
operator|||
name|pair
operator|->
name|txq
operator|.
name|queue_id
operator|>=
name|vf
operator|->
name|vsi
operator|.
name|num_queues
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ixl_vf_config_tx_queue
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
operator|&
name|pair
operator|->
name|txq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ixl_vf_config_rx_queue
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
operator|&
name|pair
operator|->
name|rxq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ixl_send_vf_ack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_set_qctl
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
specifier|const
name|struct
name|i40e_virtchnl_vector_map
modifier|*
name|vector
parameter_list|,
name|enum
name|i40e_queue_type
name|cur_type
parameter_list|,
name|uint16_t
name|cur_queue
parameter_list|,
name|enum
name|i40e_queue_type
modifier|*
name|last_type
parameter_list|,
name|uint16_t
modifier|*
name|last_queue
parameter_list|)
block|{
name|uint32_t
name|offset
decl_stmt|,
name|qctl
decl_stmt|;
name|uint16_t
name|itr_indx
decl_stmt|;
if|if
condition|(
name|cur_type
operator|==
name|I40E_QUEUE_TYPE_RX
condition|)
block|{
name|offset
operator|=
name|I40E_QINT_RQCTL
argument_list|(
name|cur_queue
argument_list|)
expr_stmt|;
name|itr_indx
operator|=
name|vector
operator|->
name|rxitr_idx
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|I40E_QINT_TQCTL
argument_list|(
name|cur_queue
argument_list|)
expr_stmt|;
name|itr_indx
operator|=
name|vector
operator|->
name|txitr_idx
expr_stmt|;
block|}
name|qctl
operator|=
name|htole32
argument_list|(
operator|(
name|vector
operator|->
name|vector_id
operator|<<
name|I40E_QINT_RQCTL_MSIX_INDX_SHIFT
operator|)
operator||
operator|(
operator|*
name|last_type
operator|<<
name|I40E_QINT_RQCTL_NEXTQ_TYPE_SHIFT
operator|)
operator||
operator|(
operator|*
name|last_queue
operator|<<
name|I40E_QINT_RQCTL_NEXTQ_INDX_SHIFT
operator|)
operator||
name|I40E_QINT_RQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|itr_indx
operator|<<
name|I40E_QINT_RQCTL_ITR_INDX_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
name|offset
argument_list|,
name|qctl
argument_list|)
expr_stmt|;
operator|*
name|last_type
operator|=
name|cur_type
expr_stmt|;
operator|*
name|last_queue
operator|=
name|cur_queue
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_config_vector
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
specifier|const
name|struct
name|i40e_virtchnl_vector_map
modifier|*
name|vector
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|u_int
name|qindex
decl_stmt|;
name|enum
name|i40e_queue_type
name|type
decl_stmt|,
name|last_type
decl_stmt|;
name|uint32_t
name|lnklst_reg
decl_stmt|;
name|uint16_t
name|rxq_map
decl_stmt|,
name|txq_map
decl_stmt|,
name|cur_queue
decl_stmt|,
name|last_queue
decl_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|rxq_map
operator|=
name|vector
operator|->
name|rxq_map
expr_stmt|;
name|txq_map
operator|=
name|vector
operator|->
name|txq_map
expr_stmt|;
name|last_queue
operator|=
name|IXL_END_OF_INTR_LNKLST
expr_stmt|;
name|last_type
operator|=
name|I40E_QUEUE_TYPE_RX
expr_stmt|;
comment|/* 	 * The datasheet says to optimize performance, RX queues and TX queues 	 * should be interleaved in the interrupt linked list, so we process 	 * both at once here. 	 */
while|while
condition|(
operator|(
name|rxq_map
operator|!=
literal|0
operator|)
operator|||
operator|(
name|txq_map
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|txq_map
operator|!=
literal|0
condition|)
block|{
name|qindex
operator|=
name|ffs
argument_list|(
name|txq_map
argument_list|)
operator|-
literal|1
expr_stmt|;
name|type
operator|=
name|I40E_QUEUE_TYPE_TX
expr_stmt|;
name|cur_queue
operator|=
name|vf
operator|->
name|vsi
operator|.
name|first_queue
operator|+
name|qindex
expr_stmt|;
name|ixl_vf_set_qctl
argument_list|(
name|pf
argument_list|,
name|vector
argument_list|,
name|type
argument_list|,
name|cur_queue
argument_list|,
operator|&
name|last_type
argument_list|,
operator|&
name|last_queue
argument_list|)
expr_stmt|;
name|txq_map
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|qindex
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|rxq_map
operator|!=
literal|0
condition|)
block|{
name|qindex
operator|=
name|ffs
argument_list|(
name|rxq_map
argument_list|)
operator|-
literal|1
expr_stmt|;
name|type
operator|=
name|I40E_QUEUE_TYPE_RX
expr_stmt|;
name|cur_queue
operator|=
name|vf
operator|->
name|vsi
operator|.
name|first_queue
operator|+
name|qindex
expr_stmt|;
name|ixl_vf_set_qctl
argument_list|(
name|pf
argument_list|,
name|vector
argument_list|,
name|type
argument_list|,
name|cur_queue
argument_list|,
operator|&
name|last_type
argument_list|,
operator|&
name|last_queue
argument_list|)
expr_stmt|;
name|rxq_map
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|qindex
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vector
operator|->
name|vector_id
operator|==
literal|0
condition|)
name|lnklst_reg
operator|=
name|I40E_VPINT_LNKLST0
argument_list|(
name|vf
operator|->
name|vf_num
argument_list|)
expr_stmt|;
else|else
name|lnklst_reg
operator|=
name|IXL_VPINT_LNKLSTN_REG
argument_list|(
name|hw
argument_list|,
name|vector
operator|->
name|vector_id
argument_list|,
name|vf
operator|->
name|vf_num
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|lnklst_reg
argument_list|,
operator|(
name|last_queue
operator|<<
name|I40E_VPINT_LNKLST0_FIRSTQ_INDX_SHIFT
operator|)
operator||
operator|(
name|last_type
operator|<<
name|I40E_VPINT_LNKLST0_FIRSTQ_TYPE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_config_irq_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|msg_size
parameter_list|)
block|{
name|struct
name|i40e_virtchnl_irq_map_info
modifier|*
name|map
decl_stmt|;
name|struct
name|i40e_virtchnl_vector_map
modifier|*
name|vector
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|int
name|i
decl_stmt|,
name|largest_txq
decl_stmt|,
name|largest_rxq
decl_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
if|if
condition|(
name|msg_size
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|map
operator|=
name|msg
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|num_vectors
operator|==
literal|0
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|msg_size
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
operator|+
name|map
operator|->
name|num_vectors
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|vector
argument_list|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|map
operator|->
name|num_vectors
condition|;
name|i
operator|++
control|)
block|{
name|vector
operator|=
operator|&
name|map
operator|->
name|vecmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|vector
operator|->
name|vector_id
operator|>=
name|hw
operator|->
name|func_caps
operator|.
name|num_msix_vectors_vf
operator|)
operator|||
name|vector
operator|->
name|vsi_id
operator|!=
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vector
operator|->
name|rxq_map
operator|!=
literal|0
condition|)
block|{
name|largest_rxq
operator|=
name|fls
argument_list|(
name|vector
operator|->
name|rxq_map
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|largest_rxq
operator|>=
name|vf
operator|->
name|vsi
operator|.
name|num_queues
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|vector
operator|->
name|txq_map
operator|!=
literal|0
condition|)
block|{
name|largest_txq
operator|=
name|fls
argument_list|(
name|vector
operator|->
name|txq_map
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|largest_txq
operator|>=
name|vf
operator|->
name|vsi
operator|.
name|num_queues
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|vector
operator|->
name|rxitr_idx
operator|>
name|IXL_MAX_ITR_IDX
operator|||
name|vector
operator|->
name|txitr_idx
operator|>
name|IXL_MAX_ITR_IDX
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|ixl_vf_config_vector
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
name|ixl_send_vf_ack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_enable_queues_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|msg_size
parameter_list|)
block|{
name|struct
name|i40e_virtchnl_queue_select
modifier|*
name|select
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|msg_size
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|select
argument_list|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ENABLE_QUEUES
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|select
operator|=
name|msg
expr_stmt|;
if|if
condition|(
name|select
operator|->
name|vsi_id
operator|!=
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
operator|||
name|select
operator|->
name|rx_queues
operator|==
literal|0
operator|||
name|select
operator|->
name|tx_queues
operator|==
literal|0
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ENABLE_QUEUES
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|ixl_enable_rings
argument_list|(
operator|&
name|vf
operator|->
name|vsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ENABLE_QUEUES
argument_list|,
name|I40E_ERR_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|ixl_send_vf_ack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ENABLE_QUEUES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_disable_queues_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|msg_size
parameter_list|)
block|{
name|struct
name|i40e_virtchnl_queue_select
modifier|*
name|select
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|msg_size
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|select
argument_list|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_DISABLE_QUEUES
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|select
operator|=
name|msg
expr_stmt|;
if|if
condition|(
name|select
operator|->
name|vsi_id
operator|!=
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
operator|||
name|select
operator|->
name|rx_queues
operator|==
literal|0
operator|||
name|select
operator|->
name|tx_queues
operator|==
literal|0
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_DISABLE_QUEUES
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|ixl_disable_rings
argument_list|(
operator|&
name|vf
operator|->
name|vsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_DISABLE_QUEUES
argument_list|,
name|I40E_ERR_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|ixl_send_vf_ack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_DISABLE_QUEUES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|ixl_zero_mac
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint8_t
name|zero
index|[
name|ETHER_ADDR_LEN
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
return|return
operator|(
name|cmp_etheraddr
argument_list|(
name|addr
argument_list|,
name|zero
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|ixl_bcast_mac
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
return|return
operator|(
name|cmp_etheraddr
argument_list|(
name|addr
argument_list|,
name|ixl_bcast_addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_vf_mac_valid
parameter_list|(
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
if|if
condition|(
name|ixl_zero_mac
argument_list|(
name|addr
argument_list|)
operator|||
name|ixl_bcast_mac
argument_list|(
name|addr
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * If the VF is not allowed to change its MAC address, don't let it 	 * set a MAC filter for an address that is not a multicast address and 	 * is not its assigned MAC. 	 */
if|if
condition|(
operator|!
operator|(
name|vf
operator|->
name|vf_flags
operator|&
name|VF_FLAG_SET_MAC_CAP
operator|)
operator|&&
operator|!
operator|(
name|ETHER_IS_MULTICAST
argument_list|(
name|addr
argument_list|)
operator|||
name|cmp_etheraddr
argument_list|(
name|addr
argument_list|,
name|vf
operator|->
name|mac
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_add_mac_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|msg_size
parameter_list|)
block|{
name|struct
name|i40e_virtchnl_ether_addr_list
modifier|*
name|addr_list
decl_stmt|;
name|struct
name|i40e_virtchnl_ether_addr
modifier|*
name|addr
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|expected_size
decl_stmt|;
name|vsi
operator|=
operator|&
name|vf
operator|->
name|vsi
expr_stmt|;
if|if
condition|(
name|msg_size
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|addr_list
argument_list|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr_list
operator|=
name|msg
expr_stmt|;
name|expected_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|addr_list
argument_list|)
operator|+
name|addr_list
operator|->
name|num_elements
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_list
operator|->
name|num_elements
operator|==
literal|0
operator|||
name|addr_list
operator|->
name|vsi_id
operator|!=
name|vsi
operator|->
name|vsi_num
operator|||
name|msg_size
operator|!=
name|expected_size
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr_list
operator|->
name|num_elements
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ixl_vf_mac_valid
argument_list|(
name|vf
argument_list|,
name|addr_list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr_list
operator|->
name|num_elements
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
operator|&
name|addr_list
operator|->
name|list
index|[
name|i
index|]
expr_stmt|;
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|addr
operator|->
name|addr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
block|}
name|ixl_send_vf_ack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_del_mac_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|msg_size
parameter_list|)
block|{
name|struct
name|i40e_virtchnl_ether_addr_list
modifier|*
name|addr_list
decl_stmt|;
name|struct
name|i40e_virtchnl_ether_addr
modifier|*
name|addr
decl_stmt|;
name|size_t
name|expected_size
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|msg_size
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|addr_list
argument_list|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr_list
operator|=
name|msg
expr_stmt|;
name|expected_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|addr_list
argument_list|)
operator|+
name|addr_list
operator|->
name|num_elements
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_list
operator|->
name|num_elements
operator|==
literal|0
operator|||
name|addr_list
operator|->
name|vsi_id
operator|!=
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
operator|||
name|msg_size
operator|!=
name|expected_size
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr_list
operator|->
name|num_elements
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
operator|&
name|addr_list
operator|->
name|list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ixl_zero_mac
argument_list|(
name|addr
operator|->
name|addr
argument_list|)
operator|||
name|ixl_bcast_mac
argument_list|(
name|addr
operator|->
name|addr
argument_list|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr_list
operator|->
name|num_elements
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
operator|&
name|addr_list
operator|->
name|list
index|[
name|i
index|]
expr_stmt|;
name|ixl_del_filter
argument_list|(
operator|&
name|vf
operator|->
name|vsi
argument_list|,
name|addr
operator|->
name|addr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
block|}
name|ixl_send_vf_ack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_DEL_ETHER_ADDRESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|i40e_status_code
name|ixl_vf_enable_vlan_strip
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|)
block|{
name|struct
name|i40e_vsi_context
name|vsi_ctx
decl_stmt|;
name|vsi_ctx
operator|.
name|seid
operator|=
name|vf
operator|->
name|vsi
operator|.
name|seid
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|vsi_ctx
operator|.
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|vsi_ctx
operator|.
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|vsi_ctx
operator|.
name|info
operator|.
name|valid_sections
operator|=
name|htole16
argument_list|(
name|I40E_AQ_VSI_PROP_VLAN_VALID
argument_list|)
expr_stmt|;
name|vsi_ctx
operator|.
name|info
operator|.
name|port_vlan_flags
operator|=
name|I40E_AQ_VSI_PVLAN_MODE_ALL
operator||
name|I40E_AQ_VSI_PVLAN_EMOD_STR_BOTH
expr_stmt|;
return|return
operator|(
name|i40e_aq_update_vsi_params
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|vsi_ctx
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_add_vlan_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|msg_size
parameter_list|)
block|{
name|struct
name|i40e_virtchnl_vlan_filter_list
modifier|*
name|filter_list
decl_stmt|;
name|enum
name|i40e_status_code
name|code
decl_stmt|;
name|size_t
name|expected_size
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|msg_size
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|filter_list
argument_list|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_VLAN
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|filter_list
operator|=
name|msg
expr_stmt|;
name|expected_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|filter_list
argument_list|)
operator|+
name|filter_list
operator|->
name|num_elements
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter_list
operator|->
name|num_elements
operator|==
literal|0
operator|||
name|filter_list
operator|->
name|vsi_id
operator|!=
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
operator|||
name|msg_size
operator|!=
name|expected_size
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_VLAN
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|vf
operator|->
name|vf_flags
operator|&
name|VF_FLAG_VLAN_CAP
operator|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_VLAN
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|filter_list
operator|->
name|num_elements
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|filter_list
operator|->
name|vlan_id
index|[
name|i
index|]
operator|>
name|EVL_VLID_MASK
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_VLAN
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|code
operator|=
name|ixl_vf_enable_vlan_strip
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|I40E_SUCCESS
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_VLAN
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|filter_list
operator|->
name|num_elements
condition|;
name|i
operator|++
control|)
name|ixl_add_filter
argument_list|(
operator|&
name|vf
operator|->
name|vsi
argument_list|,
name|vf
operator|->
name|mac
argument_list|,
name|filter_list
operator|->
name|vlan_id
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ixl_send_vf_ack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_VLAN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_del_vlan_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|msg_size
parameter_list|)
block|{
name|struct
name|i40e_virtchnl_vlan_filter_list
modifier|*
name|filter_list
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|expected_size
decl_stmt|;
if|if
condition|(
name|msg_size
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|filter_list
argument_list|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_DEL_VLAN
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|filter_list
operator|=
name|msg
expr_stmt|;
name|expected_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|filter_list
argument_list|)
operator|+
name|filter_list
operator|->
name|num_elements
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter_list
operator|->
name|num_elements
operator|==
literal|0
operator|||
name|filter_list
operator|->
name|vsi_id
operator|!=
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
operator|||
name|msg_size
operator|!=
name|expected_size
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_DEL_VLAN
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|filter_list
operator|->
name|num_elements
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|filter_list
operator|->
name|vlan_id
index|[
name|i
index|]
operator|>
name|EVL_VLID_MASK
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_VLAN
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|vf
operator|->
name|vf_flags
operator|&
name|VF_FLAG_VLAN_CAP
operator|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_ADD_VLAN
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|filter_list
operator|->
name|num_elements
condition|;
name|i
operator|++
control|)
name|ixl_del_filter
argument_list|(
operator|&
name|vf
operator|->
name|vsi
argument_list|,
name|vf
operator|->
name|mac
argument_list|,
name|filter_list
operator|->
name|vlan_id
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ixl_send_vf_ack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_DEL_VLAN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_config_promisc_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|msg_size
parameter_list|)
block|{
name|struct
name|i40e_virtchnl_promisc_info
modifier|*
name|info
decl_stmt|;
name|enum
name|i40e_status_code
name|code
decl_stmt|;
if|if
condition|(
name|msg_size
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|vf
operator|->
name|vf_flags
operator|&
name|VF_FLAG_PROMISC_CAP
operator|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|info
operator|=
name|msg
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vsi_id
operator|!=
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
name|i40e_aq_set_vsi_unicast_promiscuous
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
name|info
operator|->
name|vsi_id
argument_list|,
name|info
operator|->
name|flags
operator|&
name|I40E_FLAG_VF_UNICAST_PROMISC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|I40E_SUCCESS
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
name|i40e_aq_set_vsi_multicast_promiscuous
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
name|info
operator|->
name|vsi_id
argument_list|,
name|info
operator|->
name|flags
operator|&
name|I40E_FLAG_VF_MULTICAST_PROMISC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|I40E_SUCCESS
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|ixl_send_vf_ack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_vf_get_stats_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|ixl_vf
modifier|*
name|vf
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|,
name|uint16_t
name|msg_size
parameter_list|)
block|{
name|struct
name|i40e_virtchnl_queue_select
modifier|*
name|queue
decl_stmt|;
if|if
condition|(
name|msg_size
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|queue
argument_list|)
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_GET_STATS
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|queue
operator|=
name|msg
expr_stmt|;
if|if
condition|(
name|queue
operator|->
name|vsi_id
operator|!=
name|vf
operator|->
name|vsi
operator|.
name|vsi_num
condition|)
block|{
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_GET_STATS
argument_list|,
name|I40E_ERR_PARAM
argument_list|)
expr_stmt|;
return|return;
block|}
name|ixl_update_eth_stats
argument_list|(
operator|&
name|vf
operator|->
name|vsi
argument_list|)
expr_stmt|;
name|ixl_send_vf_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|I40E_VIRTCHNL_OP_GET_STATS
argument_list|,
name|I40E_SUCCESS
argument_list|,
operator|&
name|vf
operator|->
name|vsi
operator|.
name|eth_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|vf
operator|->
name|vsi
operator|.
name|eth_stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_handle_vf_msg
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|struct
name|i40e_arq_event_info
modifier|*
name|event
parameter_list|)
block|{
name|struct
name|ixl_vf
modifier|*
name|vf
decl_stmt|;
name|void
modifier|*
name|msg
decl_stmt|;
name|uint16_t
name|vf_num
decl_stmt|,
name|msg_size
decl_stmt|;
name|uint32_t
name|opcode
decl_stmt|;
name|vf_num
operator|=
name|le16toh
argument_list|(
name|event
operator|->
name|desc
operator|.
name|retval
argument_list|)
operator|-
name|pf
operator|->
name|hw
operator|.
name|func_caps
operator|.
name|vf_base_id
expr_stmt|;
name|opcode
operator|=
name|le32toh
argument_list|(
name|event
operator|->
name|desc
operator|.
name|cookie_high
argument_list|)
expr_stmt|;
if|if
condition|(
name|vf_num
operator|>=
name|pf
operator|->
name|num_vfs
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Got msg from illegal VF: %d\n"
argument_list|,
name|vf_num
argument_list|)
expr_stmt|;
return|return;
block|}
name|vf
operator|=
operator|&
name|pf
operator|->
name|vfs
index|[
name|vf_num
index|]
expr_stmt|;
name|msg
operator|=
name|event
operator|->
name|msg_buf
expr_stmt|;
name|msg_size
operator|=
name|event
operator|->
name|msg_len
expr_stmt|;
name|I40E_VC_DEBUG
argument_list|(
name|pf
argument_list|,
name|ixl_vc_opcode_level
argument_list|(
name|opcode
argument_list|)
argument_list|,
literal|"Got msg %s(%d) from VF-%d of size %d\n"
argument_list|,
name|ixl_vc_opcode_str
argument_list|(
name|opcode
argument_list|)
argument_list|,
name|opcode
argument_list|,
name|vf_num
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|I40E_VIRTCHNL_OP_VERSION
case|:
name|ixl_vf_version_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_VIRTCHNL_OP_RESET_VF
case|:
name|ixl_vf_reset_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_VIRTCHNL_OP_GET_VF_RESOURCES
case|:
name|ixl_vf_get_resources_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES
case|:
name|ixl_vf_config_vsi_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP
case|:
name|ixl_vf_config_irq_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_VIRTCHNL_OP_ENABLE_QUEUES
case|:
name|ixl_vf_enable_queues_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_VIRTCHNL_OP_DISABLE_QUEUES
case|:
name|ixl_vf_disable_queues_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS
case|:
name|ixl_vf_add_mac_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_VIRTCHNL_OP_DEL_ETHER_ADDRESS
case|:
name|ixl_vf_del_mac_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_VIRTCHNL_OP_ADD_VLAN
case|:
name|ixl_vf_add_vlan_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_VIRTCHNL_OP_DEL_VLAN
case|:
name|ixl_vf_del_vlan_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE
case|:
name|ixl_vf_config_promisc_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_VIRTCHNL_OP_GET_STATS
case|:
name|ixl_vf_get_stats_msg
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|msg
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
break|break;
comment|/* These two opcodes have been superseded by CONFIG_VSI_QUEUES. */
case|case
name|I40E_VIRTCHNL_OP_CONFIG_TX_QUEUE
case|:
case|case
name|I40E_VIRTCHNL_OP_CONFIG_RX_QUEUE
case|:
default|default:
name|i40e_send_vf_nack
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|,
name|opcode
argument_list|,
name|I40E_ERR_NOT_IMPLEMENTED
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Handle any VFs that have reset themselves via a Function Level Reset(FLR). */
end_comment

begin_function
specifier|static
name|void
name|ixl_handle_vflr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|uint16_t
name|global_vf_num
decl_stmt|;
name|uint32_t
name|vflrstat_index
decl_stmt|,
name|vflrstat_mask
decl_stmt|,
name|vflrstat
decl_stmt|,
name|icr0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pf
operator|=
name|arg
expr_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pf
operator|->
name|num_vfs
condition|;
name|i
operator|++
control|)
block|{
name|global_vf_num
operator|=
name|hw
operator|->
name|func_caps
operator|.
name|vf_base_id
operator|+
name|i
expr_stmt|;
name|vflrstat_index
operator|=
name|IXL_GLGEN_VFLRSTAT_INDEX
argument_list|(
name|global_vf_num
argument_list|)
expr_stmt|;
name|vflrstat_mask
operator|=
name|IXL_GLGEN_VFLRSTAT_MASK
argument_list|(
name|global_vf_num
argument_list|)
expr_stmt|;
name|vflrstat
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLGEN_VFLRSTAT
argument_list|(
name|vflrstat_index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflrstat
operator|&
name|vflrstat_mask
condition|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GLGEN_VFLRSTAT
argument_list|(
name|vflrstat_index
argument_list|)
argument_list|,
name|vflrstat_mask
argument_list|)
expr_stmt|;
name|ixl_reinit_vf
argument_list|(
name|pf
argument_list|,
operator|&
name|pf
operator|->
name|vfs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|icr0
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|)
expr_stmt|;
name|icr0
operator||=
name|I40E_PFINT_ICR0_ENA_VFLR_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
name|icr0
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_adminq_err_to_errno
parameter_list|(
name|enum
name|i40e_admin_queue_err
name|err
parameter_list|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|I40E_AQ_RC_EPERM
case|:
return|return
operator|(
name|EPERM
operator|)
return|;
case|case
name|I40E_AQ_RC_ENOENT
case|:
return|return
operator|(
name|ENOENT
operator|)
return|;
case|case
name|I40E_AQ_RC_ESRCH
case|:
return|return
operator|(
name|ESRCH
operator|)
return|;
case|case
name|I40E_AQ_RC_EINTR
case|:
return|return
operator|(
name|EINTR
operator|)
return|;
case|case
name|I40E_AQ_RC_EIO
case|:
return|return
operator|(
name|EIO
operator|)
return|;
case|case
name|I40E_AQ_RC_ENXIO
case|:
return|return
operator|(
name|ENXIO
operator|)
return|;
case|case
name|I40E_AQ_RC_E2BIG
case|:
return|return
operator|(
name|E2BIG
operator|)
return|;
case|case
name|I40E_AQ_RC_EAGAIN
case|:
return|return
operator|(
name|EAGAIN
operator|)
return|;
case|case
name|I40E_AQ_RC_ENOMEM
case|:
return|return
operator|(
name|ENOMEM
operator|)
return|;
case|case
name|I40E_AQ_RC_EACCES
case|:
return|return
operator|(
name|EACCES
operator|)
return|;
case|case
name|I40E_AQ_RC_EFAULT
case|:
return|return
operator|(
name|EFAULT
operator|)
return|;
case|case
name|I40E_AQ_RC_EBUSY
case|:
return|return
operator|(
name|EBUSY
operator|)
return|;
case|case
name|I40E_AQ_RC_EEXIST
case|:
return|return
operator|(
name|EEXIST
operator|)
return|;
case|case
name|I40E_AQ_RC_EINVAL
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|I40E_AQ_RC_ENOTTY
case|:
return|return
operator|(
name|ENOTTY
operator|)
return|;
case|case
name|I40E_AQ_RC_ENOSPC
case|:
return|return
operator|(
name|ENOSPC
operator|)
return|;
case|case
name|I40E_AQ_RC_ENOSYS
case|:
return|return
operator|(
name|ENOSYS
operator|)
return|;
case|case
name|I40E_AQ_RC_ERANGE
case|:
return|return
operator|(
name|ERANGE
operator|)
return|;
case|case
name|I40E_AQ_RC_EFLUSHED
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* No exact equivalent in errno.h */
case|case
name|I40E_AQ_RC_BAD_ADDR
case|:
return|return
operator|(
name|EFAULT
operator|)
return|;
case|case
name|I40E_AQ_RC_EMODE
case|:
return|return
operator|(
name|EPERM
operator|)
return|;
case|case
name|I40E_AQ_RC_EFBIG
case|:
return|return
operator|(
name|EFBIG
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_iov_init
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint16_t
name|num_vfs
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|pf_vsi
decl_stmt|;
name|enum
name|i40e_status_code
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|pf
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|pf_vsi
operator|=
operator|&
name|pf
operator|->
name|vsi
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|pf
operator|->
name|vfs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_vf
argument_list|)
operator|*
name|num_vfs
argument_list|,
name|M_IXL
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|vfs
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vfs
condition|;
name|i
operator|++
control|)
name|sysctl_ctx_init
argument_list|(
operator|&
name|pf
operator|->
name|vfs
index|[
name|i
index|]
operator|.
name|ctx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i40e_aq_add_veb
argument_list|(
name|hw
argument_list|,
name|pf_vsi
operator|->
name|uplink_seid
argument_list|,
name|pf_vsi
operator|->
name|seid
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|,
operator|&
name|pf
operator|->
name|veb_seid
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|I40E_SUCCESS
condition|)
block|{
name|error
operator|=
name|ixl_adminq_err_to_errno
argument_list|(
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"add_veb failed; code=%d error=%d"
argument_list|,
name|ret
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|// TODO: [Configure MSI-X here]
name|ixl_enable_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|pf
operator|->
name|num_vfs
operator|=
name|num_vfs
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|free
argument_list|(
name|pf
operator|->
name|vfs
argument_list|,
name|M_IXL
argument_list|)
expr_stmt|;
name|pf
operator|->
name|vfs
operator|=
name|NULL
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_iov_uninit
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ixl_vf
modifier|*
name|vfs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|num_vfs
decl_stmt|;
name|pf
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|vsi
operator|=
operator|&
name|pf
operator|->
name|vsi
expr_stmt|;
name|ifp
operator|=
name|vsi
operator|->
name|ifp
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pf
operator|->
name|num_vfs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pf
operator|->
name|vfs
index|[
name|i
index|]
operator|.
name|vsi
operator|.
name|seid
operator|!=
literal|0
condition|)
name|i40e_aq_delete_element
argument_list|(
name|hw
argument_list|,
name|pf
operator|->
name|vfs
index|[
name|i
index|]
operator|.
name|vsi
operator|.
name|seid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|->
name|veb_seid
operator|!=
literal|0
condition|)
block|{
name|i40e_aq_delete_element
argument_list|(
name|hw
argument_list|,
name|pf
operator|->
name|veb_seid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pf
operator|->
name|veb_seid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
name|ixl_disable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|vfs
operator|=
name|pf
operator|->
name|vfs
expr_stmt|;
name|num_vfs
operator|=
name|pf
operator|->
name|num_vfs
expr_stmt|;
name|pf
operator|->
name|vfs
operator|=
name|NULL
expr_stmt|;
name|pf
operator|->
name|num_vfs
operator|=
literal|0
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Do this after the unlock as sysctl_ctx_free might sleep. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_vfs
condition|;
name|i
operator|++
control|)
name|sysctl_ctx_free
argument_list|(
operator|&
name|vfs
index|[
name|i
index|]
operator|.
name|ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vfs
argument_list|,
name|M_IXL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_add_vf
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint16_t
name|vfnum
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|params
parameter_list|)
block|{
name|char
name|sysctl_name
index|[
name|QUEUE_NAME_LEN
index|]
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|struct
name|ixl_vf
modifier|*
name|vf
decl_stmt|;
specifier|const
name|void
modifier|*
name|mac
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pf
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vf
operator|=
operator|&
name|pf
operator|->
name|vfs
index|[
name|vfnum
index|]
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|vf
operator|->
name|vf_num
operator|=
name|vfnum
expr_stmt|;
name|vf
operator|->
name|vsi
operator|.
name|back
operator|=
name|pf
expr_stmt|;
name|vf
operator|->
name|vf_flags
operator|=
name|VF_FLAG_ENABLED
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|vf
operator|->
name|vsi
operator|.
name|ftl
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixl_vf_setup_vsi
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|nvlist_exists_binary
argument_list|(
name|params
argument_list|,
literal|"mac-addr"
argument_list|)
condition|)
block|{
name|mac
operator|=
name|nvlist_get_binary
argument_list|(
name|params
argument_list|,
literal|"mac-addr"
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mac
argument_list|,
name|vf
operator|->
name|mac
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_get_bool
argument_list|(
name|params
argument_list|,
literal|"allow-set-mac"
argument_list|)
condition|)
name|vf
operator|->
name|vf_flags
operator||=
name|VF_FLAG_SET_MAC_CAP
expr_stmt|;
block|}
else|else
comment|/* 		 * If the administrator has not specified a MAC address then 		 * we must allow the VF to choose one. 		 */
name|vf
operator|->
name|vf_flags
operator||=
name|VF_FLAG_SET_MAC_CAP
expr_stmt|;
if|if
condition|(
name|nvlist_get_bool
argument_list|(
name|params
argument_list|,
literal|"mac-anti-spoof"
argument_list|)
condition|)
name|vf
operator|->
name|vf_flags
operator||=
name|VF_FLAG_MAC_ANTI_SPOOF
expr_stmt|;
if|if
condition|(
name|nvlist_get_bool
argument_list|(
name|params
argument_list|,
literal|"allow-promisc"
argument_list|)
condition|)
name|vf
operator|->
name|vf_flags
operator||=
name|VF_FLAG_PROMISC_CAP
expr_stmt|;
comment|/* TODO: Get VLAN that PF has set for the VF */
name|vf
operator|->
name|vf_flags
operator||=
name|VF_FLAG_VLAN_CAP
expr_stmt|;
name|ixl_reset_vf
argument_list|(
name|pf
argument_list|,
name|vf
argument_list|)
expr_stmt|;
name|out
label|:
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|sysctl_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sysctl_name
argument_list|)
argument_list|,
literal|"vf%d"
argument_list|,
name|vfnum
argument_list|)
expr_stmt|;
name|ixl_add_vsi_sysctls
argument_list|(
name|pf
argument_list|,
operator|&
name|vf
operator|->
name|vsi
argument_list|,
operator|&
name|vf
operator|->
name|ctx
argument_list|,
name|sysctl_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCI_IOV */
end_comment

end_unit

