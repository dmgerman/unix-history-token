begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2013-2014, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_rss.h"
end_include

begin_include
include|#
directive|include
file|"ixl.h"
end_include

begin_include
include|#
directive|include
file|"ixl_pf.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RSS
end_ifdef

begin_include
include|#
directive|include
file|<net/rss_config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*********************************************************************  *  Driver version  *********************************************************************/
end_comment

begin_decl_stmt
name|char
name|ixl_driver_version
index|[]
init|=
literal|"1.3.1"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  PCI Device ID Table  *  *  Used by probe to select devices to load on  *  Last field stores an index into ixl_strings  *  Last entry must be all 0s  *  *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|ixl_vendor_info_t
name|ixl_vendor_info_array
index|[]
init|=
block|{
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_SFP_XL710
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_KX_A
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_KX_B
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_KX_C
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_QSFP_A
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_QSFP_B
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_QSFP_C
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_10G_BASE_T
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* required last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Table of branding strings  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ixl_strings
index|[]
init|=
block|{
literal|"Intel(R) Ethernet Connection XL710 Driver"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|ixl_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_get_hw_capabilities
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_cap_txcsum_tso
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_init_locked
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_stop
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_update_link_status
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_allocate_pci_resources
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u16
name|ixl_get_bus_info
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|,
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_setup_stations
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_setup_vsi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_initialize_vsi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_assign_vsi_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_assign_vsi_legacy
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_init_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_configure_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_configure_itr
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_configure_legacy
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_free_pci_resources
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_local_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_setup_interface
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ixl_config_link
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_config_rss
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_set_queue_rx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_set_queue_tx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_set_advertised_speeds
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_enable_rings
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_disable_rings
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_enable_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_disable_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_enable_adminq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_disable_adminq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_enable_queue
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_disable_queue
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_enable_legacy
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_disable_legacy
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_set_promisc
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_add_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_del_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_register_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_unregister_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_setup_vlan_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_init_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_add_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|s16
name|vlan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_del_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|s16
name|vlan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_add_hw_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_del_hw_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ixl_mac_filter
modifier|*
name|ixl_find_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|u8
modifier|*
parameter_list|,
name|s16
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_add_mc_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|,
name|u8
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Sysctl debug interface */
end_comment

begin_function_decl
specifier|static
name|int
name|ixl_debug_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_print_debug_info
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The MSI/X Interrupt handlers */
end_comment

begin_function_decl
specifier|static
name|void
name|ixl_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_msix_que
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_msix_adminq
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_handle_mdd_event
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Deferred interrupt tasklets */
end_comment

begin_function_decl
specifier|static
name|void
name|ixl_do_adminq
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Sysctl handlers */
end_comment

begin_function_decl
specifier|static
name|int
name|ixl_set_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_set_advertise
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_current_speed
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_show_fw
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Statistics */
end_comment

begin_function_decl
specifier|static
name|void
name|ixl_add_hw_stats
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_add_sysctls_mac_stats
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
parameter_list|,
name|struct
name|i40e_hw_port_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_add_sysctls_eth_stats
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
parameter_list|,
name|struct
name|i40e_eth_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_update_stats_counters
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_update_eth_stats
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_pf_reset_stats
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_vsi_reset_stats
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_stat_update48
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|u32
parameter_list|,
name|bool
parameter_list|,
name|u64
modifier|*
parameter_list|,
name|u64
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixl_stat_update32
parameter_list|(
name|struct
name|i40e_hw
modifier|*
parameter_list|,
name|u32
parameter_list|,
name|bool
parameter_list|,
name|u64
modifier|*
parameter_list|,
name|u64
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_DEBUG_SYSCTL
end_ifdef

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_link_status
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_phy_abilities
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_sw_filter_list
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_hw_res_alloc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_switch_config
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_sysctl_dump_txd
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|ixl_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ixl_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ixl_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ixl_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ixl_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ixl_driver
init|=
block|{
literal|"ixl"
block|,
name|ixl_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_pf
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|ixl_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ixl
argument_list|,
name|pci
argument_list|,
name|ixl_driver
argument_list|,
name|ixl_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixl
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixl
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Global reset mutex */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ixl_reset_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** TUNEABLE PARAMETERS: */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ixl
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"IXL driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * MSIX should be the default for best performance,  * but this allows it to be forced off for testing.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixl_enable_msix
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.enable_msix"
argument_list|,
operator|&
name|ixl_enable_msix
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_msix
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_enable_msix
argument_list|,
literal|0
argument_list|,
literal|"Enable MSI-X interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Number of descriptors per ring: **   - TX and RX are the same size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixl_ringsz
init|=
name|DEFAULT_RING
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.ringsz"
argument_list|,
operator|&
name|ixl_ringsz
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|ring_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_ringsz
argument_list|,
literal|0
argument_list|,
literal|"Descriptor Ring Size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  ** This can be set manually, if left as 0 the ** number of queues will be calculated based ** on cpus and msix vectors available. */
end_comment

begin_decl_stmt
name|int
name|ixl_max_queues
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.max_queues"
argument_list|,
operator|&
name|ixl_max_queues
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|max_queues
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_max_queues
argument_list|,
literal|0
argument_list|,
literal|"Number of Queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Controls for Interrupt Throttling  **	- true/false for dynamic adjustment ** 	- default values for static ITR */
end_comment

begin_decl_stmt
name|int
name|ixl_dynamic_rx_itr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.dynamic_rx_itr"
argument_list|,
operator|&
name|ixl_dynamic_rx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|dynamic_rx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_dynamic_rx_itr
argument_list|,
literal|0
argument_list|,
literal|"Dynamic RX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ixl_dynamic_tx_itr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.dynamic_tx_itr"
argument_list|,
operator|&
name|ixl_dynamic_tx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|dynamic_tx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_dynamic_tx_itr
argument_list|,
literal|0
argument_list|,
literal|"Dynamic TX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ixl_rx_itr
init|=
name|IXL_ITR_8K
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.rx_itr"
argument_list|,
operator|&
name|ixl_rx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_rx_itr
argument_list|,
literal|0
argument_list|,
literal|"RX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ixl_tx_itr
init|=
name|IXL_ITR_4K
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.tx_itr"
argument_list|,
operator|&
name|ixl_tx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_tx_itr
argument_list|,
literal|0
argument_list|,
literal|"TX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_FDIR
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ixl_enable_fdir
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.enable_fdir"
argument_list|,
operator|&
name|ixl_enable_fdir
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Rate at which we sample */
end_comment

begin_decl_stmt
name|int
name|ixl_atr_rate
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.atr_rate"
argument_list|,
operator|&
name|ixl_atr_rate
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ixl_fc_string
index|[
literal|6
index|]
init|=
block|{
literal|"None"
block|,
literal|"Rx"
block|,
literal|"Tx"
block|,
literal|"Full"
block|,
literal|"Priority"
block|,
literal|"Default"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Device identification routine  *  *  ixl_probe determines if the driver should be loaded on  *  the hardware based on PCI vendor/device id of the device.  *  *  return BUS_PROBE_DEFAULT on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ixl_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|u16
name|pci_vendor_id
decl_stmt|,
name|pci_device_id
decl_stmt|;
name|u16
name|pci_subvendor_id
decl_stmt|,
name|pci_subdevice_id
decl_stmt|;
name|char
name|device_name
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|bool
name|lock_init
init|=
name|FALSE
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_probe: begin"
argument_list|)
expr_stmt|;
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_vendor_id
operator|!=
name|I40E_INTEL_VENDOR_ID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|ixl_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subvendor_id
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subdevice_id
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|device_name
argument_list|,
literal|"%s, Version - %s"
argument_list|,
name|ixl_strings
index|[
name|ent
operator|->
name|index
index|]
argument_list|,
name|ixl_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|device_name
argument_list|)
expr_stmt|;
comment|/* One shot mutex init */
if|if
condition|(
name|lock_init
operator|==
name|FALSE
condition|)
block|{
name|lock_init
operator|=
name|TRUE
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ixl_reset_mtx
argument_list|,
literal|"ixl_reset"
argument_list|,
literal|"IXL RESET Lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device initialization routine  *  *  The attach entry point is called when the driver is being loaded.  *  This routine identifies the type of hardware, allocates all resources  *  and initializes the hardware.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
decl_stmt|;
name|u16
name|bus
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_attach: begin"
argument_list|)
expr_stmt|;
comment|/* Allocate, clear, and link in our primary soft structure */
name|pf
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pf
operator|->
name|dev
operator|=
name|pf
operator|->
name|osdep
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
comment|/* 	** Note this assumes we have a single embedded VSI, 	** this could be enhanced later to allocate multiple 	*/
name|vsi
operator|=
operator|&
name|pf
operator|->
name|vsi
expr_stmt|;
name|vsi
operator|->
name|dev
operator|=
name|pf
operator|->
name|dev
expr_stmt|;
comment|/* Core Lock Init*/
name|IXL_PF_LOCK_INIT
argument_list|(
name|pf
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the timer callout */
name|callout_init_mtx
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|,
operator|&
name|pf
operator|->
name|pf_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up sysctls */
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fc"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_set_flowcntl
argument_list|,
literal|"I"
argument_list|,
literal|"Flow Control"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"advertise_speed"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_set_advertise
argument_list|,
literal|"I"
argument_list|,
literal|"Advertised Speed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"current_speed"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_current_speed
argument_list|,
literal|"A"
argument_list|,
literal|"Current Port Speed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fw_version"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_show_fw
argument_list|,
literal|"A"
argument_list|,
literal|"Firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_itr"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixl_rx_itr
argument_list|,
name|IXL_ITR_8K
argument_list|,
literal|"RX ITR"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dynamic_rx_itr"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixl_dynamic_rx_itr
argument_list|,
literal|0
argument_list|,
literal|"Dynamic RX ITR"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_itr"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixl_tx_itr
argument_list|,
name|IXL_ITR_4K
argument_list|,
literal|"TX ITR"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dynamic_tx_itr"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ixl_dynamic_tx_itr
argument_list|,
literal|0
argument_list|,
literal|"Dynamic TX ITR"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_DEBUG_SYSCTL
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"link_status"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_link_status
argument_list|,
literal|"A"
argument_list|,
literal|"Current Link Status"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"phy_abilities"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_phy_abilities
argument_list|,
literal|"A"
argument_list|,
literal|"PHY Abilities"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"filter_list"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_sw_filter_list
argument_list|,
literal|"A"
argument_list|,
literal|"SW Filter List"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_res_alloc"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_hw_res_alloc
argument_list|,
literal|"A"
argument_list|,
literal|"HW Resource Allocation"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"switch_config"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_switch_config
argument_list|,
literal|"A"
argument_list|,
literal|"HW Switch Configuration"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_desc"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_WR
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_sysctl_dump_txd
argument_list|,
literal|"I"
argument_list|,
literal|"Desc dump"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Save off the PCI information */
name|hw
operator|->
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|revision_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_vendor_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|subsystem_device_id
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|device
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hw
operator|->
name|bus
operator|.
name|func
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Do PCI setup - map BAR0, etc */
if|if
condition|(
name|ixl_allocate_pci_resources
argument_list|(
name|pf
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Allocation of PCI resources failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Create for initial debugging use */
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|pf
argument_list|,
literal|0
argument_list|,
name|ixl_debug_info
argument_list|,
literal|"I"
argument_list|,
literal|"Debug Information"
argument_list|)
expr_stmt|;
comment|/* Establish a clean starting point */
name|i40e_clear_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_pf_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PF reset failure %x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* For now always do an initial CORE reset on first device */
block|{
specifier|static
name|int
name|ixl_dev_count
decl_stmt|;
specifier|static
name|int
name|ixl_dev_track
index|[
literal|32
index|]
decl_stmt|;
name|u32
name|my_dev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
init|=
name|FALSE
decl_stmt|;
name|u16
name|bus
init|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ixl_reset_mtx
argument_list|)
expr_stmt|;
name|my_dev
operator|=
operator|(
name|bus
operator|<<
literal|8
operator|)
operator||
name|hw
operator|->
name|bus
operator|.
name|device
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ixl_dev_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ixl_dev_track
index|[
name|i
index|]
operator|==
name|my_dev
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|u32
name|reg
decl_stmt|;
name|ixl_dev_track
index|[
name|ixl_dev_count
index|]
operator|=
name|my_dev
expr_stmt|;
name|ixl_dev_count
operator|++
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"Initial CORE RESET\n"
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GLGEN_RTRIG
argument_list|,
name|I40E_GLGEN_RTRIG_CORER_MASK
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|i
operator|=
literal|50
expr_stmt|;
do|do
block|{
name|i40e_msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLGEN_RSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg
operator|&
name|I40E_GLGEN_RSTAT_DEVSTATE_MASK
operator|)
condition|)
break|break;
block|}
do|while
condition|(
name|i
operator|--
condition|)
do|;
comment|/* paranoia */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_ATQLEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_ATQBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_ATQBAH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i40e_clear_pxe_mode
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ixl_reset_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* Set admin queue parameters */
name|hw
operator|->
name|aq
operator|.
name|num_arq_entries
operator|=
name|IXL_AQ_LEN
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|num_asq_entries
operator|=
name|IXL_AQ_LEN
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|arq_buf_size
operator|=
name|IXL_AQ_BUFSZ
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|asq_buf_size
operator|=
name|IXL_AQ_BUFSZ
expr_stmt|;
comment|/* Initialize the shared code */
name|error
operator|=
name|i40e_init_shared_code
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize the shared code\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Set up the admin queue */
name|error
operator|=
name|i40e_init_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The driver for the device stopped "
literal|"because the NVM image is newer than expected.\n"
literal|"You must install the most recent version of "
literal|" the network driver.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s\n"
argument_list|,
name|ixl_fw_version_str
argument_list|(
name|hw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|aq
operator|.
name|api_maj_ver
operator|==
name|I40E_FW_API_VERSION_MAJOR
operator|&&
name|hw
operator|->
name|aq
operator|.
name|api_min_ver
operator|>
name|I40E_FW_API_VERSION_MINOR
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The driver for the device detected "
literal|"a newer version of the NVM image than expected.\n"
literal|"Please install the most recent version of the network driver.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hw
operator|->
name|aq
operator|.
name|api_maj_ver
operator|<
name|I40E_FW_API_VERSION_MAJOR
operator|||
name|hw
operator|->
name|aq
operator|.
name|api_min_ver
operator|<
operator|(
name|I40E_FW_API_VERSION_MINOR
operator|-
literal|1
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The driver for the device detected "
literal|"an older version of the NVM image than expected.\n"
literal|"Please update the NVM image.\n"
argument_list|)
expr_stmt|;
comment|/* Clear PXE mode */
name|i40e_clear_pxe_mode
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Get capabilities from the device */
name|error
operator|=
name|ixl_get_hw_capabilities
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"HW capabilities failure!\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_get_cap
goto|;
block|}
comment|/* Set up host memory cache */
name|error
operator|=
name|i40e_init_lan_hmc
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|num_queues
argument_list|,
name|vsi
operator|->
name|num_queues
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init_lan_hmc failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_get_cap
goto|;
block|}
name|error
operator|=
name|i40e_configure_lan_hmc
argument_list|(
name|hw
argument_list|,
name|I40E_HMC_MODEL_DIRECT_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"configure_lan_hmc failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_mac_hmc
goto|;
block|}
comment|/* Disable LLDP from the firmware */
name|i40e_aq_stop_lldp
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|i40e_get_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_validate_mac_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"validate_mac_addr failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_mac_hmc
goto|;
block|}
name|bcopy
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|perm_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|i40e_get_port_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|port_addr
argument_list|)
expr_stmt|;
comment|/* Set up VSI and queues */
if|if
condition|(
name|ixl_setup_stations
argument_list|(
name|pf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"setup stations failed!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_mac_hmc
goto|;
block|}
comment|/* Initialize mac filter list for VSI */
name|SLIST_INIT
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|)
expr_stmt|;
comment|/* Set up interrupt routing here */
if|if
condition|(
name|pf
operator|->
name|msix
operator|>
literal|1
condition|)
name|error
operator|=
name|ixl_assign_vsi_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ixl_assign_vsi_legacy
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_late
goto|;
name|i40e_msec_delay
argument_list|(
literal|75
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_aq_set_link_restart_an
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"link restart failed, aq_err=%d\n"
argument_list|,
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
comment|/* Determine link state */
name|vsi
operator|->
name|link_up
operator|=
name|ixl_config_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Report if Unqualified modules are found */
if|if
condition|(
operator|(
name|vsi
operator|->
name|link_up
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|pf
operator|->
name|hw
operator|.
name|phy
operator|.
name|link_info
operator|.
name|link_info
operator|&
name|I40E_AQ_MEDIA_AVAILABLE
operator|)
operator|&&
operator|(
operator|!
operator|(
name|pf
operator|->
name|hw
operator|.
name|phy
operator|.
name|link_info
operator|.
name|an_info
operator|&
name|I40E_AQ_QUALIFIED_MODULE
operator|)
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link failed because "
literal|"an unqualified module was detected\n"
argument_list|)
expr_stmt|;
comment|/* Setup OS specific network interface */
if|if
condition|(
name|ixl_setup_interface
argument_list|(
name|dev
argument_list|,
name|vsi
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"interface setup failed!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Get the bus configuration and set the shared code */
name|bus
operator|=
name|ixl_get_bus_info
argument_list|(
name|hw
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|i40e_set_pci_config_data
argument_list|(
name|hw
argument_list|,
name|bus
argument_list|)
expr_stmt|;
comment|/* Initialize statistics */
name|ixl_pf_reset_stats
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_update_stats_counters
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_add_hw_stats
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Reset port's advertised speeds */
if|if
condition|(
operator|!
name|i40e_is_40G_device
argument_list|(
name|hw
operator|->
name|device_id
argument_list|)
condition|)
block|{
name|pf
operator|->
name|advertised_speed
operator|=
operator|(
name|hw
operator|->
name|device_id
operator|==
name|I40E_DEV_ID_10G_BASE_T
operator|)
condition|?
literal|0x7
else|:
literal|0x6
expr_stmt|;
name|ixl_set_advertised_speeds
argument_list|(
name|pf
argument_list|,
name|pf
operator|->
name|advertised_speed
argument_list|)
expr_stmt|;
block|}
comment|/* Register for VLAN events */
name|vsi
operator|->
name|vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|ixl_register_vlan
argument_list|,
name|vsi
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|ixl_unregister_vlan
argument_list|,
name|vsi
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_attach: end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_late
label|:
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|err_mac_hmc
label|:
name|i40e_shutdown_lan_hmc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|err_get_cap
label|:
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|err_out
label|:
name|ixl_free_pci_resources
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_free_vsi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK_DESTROY
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device removal routine  *  *  The detach entry point is called when the driver is being removed.  *  This routine stops the adapter and deallocates all the resources  *  that were allocated for driver operation.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|i40e_status
name|status
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_detach: begin"
argument_list|)
expr_stmt|;
comment|/* Make sure VLANS are not using driver */
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Vlan in use, detach first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_stop
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
if|if
condition|(
name|que
operator|->
name|tq
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|tx_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Shutdown LAN HMC */
name|status
operator|=
name|i40e_shutdown_lan_hmc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Shutdown LAN HMC failed with code %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Shutdown admin queue */
name|status
operator|=
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Shutdown Admin queue failed with code %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Unregister VLAN events */
if|if
condition|(
name|vsi
operator|->
name|vlan_attach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|vsi
operator|->
name|vlan_attach
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|vlan_detach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|vsi
operator|->
name|vlan_detach
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|)
expr_stmt|;
name|ixl_free_pci_resources
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ixl_free_vsi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK_DESTROY
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Shutdown entry point  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_stop
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Get the hardware capabilities  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_get_hw_capabilities
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_aqc_list_capabilities_element_resp
modifier|*
name|buf
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
name|u16
name|needed
decl_stmt|;
name|bool
name|again
init|=
name|TRUE
decl_stmt|;
name|len
operator|=
literal|40
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aqc_list_capabilities_element_resp
argument_list|)
expr_stmt|;
name|retry
label|:
if|if
condition|(
operator|!
operator|(
name|buf
operator|=
operator|(
expr|struct
name|i40e_aqc_list_capabilities_element_resp
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate cap memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* This populates the hw struct */
name|error
operator|=
name|i40e_aq_discover_capabilities
argument_list|(
name|hw
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|needed
argument_list|,
name|i40e_aqc_opc_list_func_capabilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|asq_last_status
operator|==
name|I40E_AQ_RC_ENOMEM
operator|)
operator|&&
operator|(
name|again
operator|==
name|TRUE
operator|)
condition|)
block|{
comment|/* retry once with a larger buffer */
name|again
operator|=
name|FALSE
expr_stmt|;
name|len
operator|=
name|needed
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|asq_last_status
operator|!=
name|I40E_AQ_RC_OK
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"capability discovery failed: %d\n"
argument_list|,
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Capture this PF's starting queue pair */
name|pf
operator|->
name|qbase
operator|=
name|hw
operator|->
name|func_caps
operator|.
name|base_queue
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"pf_id=%d, num_vfs=%d, msix_pf=%d, "
literal|"msix_vf=%d, fd_g=%d, fd_b=%d, tx_qp=%d rx_qp=%d qbase=%d\n"
argument_list|,
name|hw
operator|->
name|pf_id
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_vfs
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_msix_vectors
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_msix_vectors_vf
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|fd_filters_guaranteed
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|fd_filters_best_effort
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_tx_qp
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_rx_qp
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|base_queue
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_cap_txcsum_tso
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
comment|/* Enable/disable TXCSUM/TSO4 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
comment|/* enable TXCSUM, restore TSO if previously enabled */
if|if
condition|(
name|vsi
operator|->
name|flags
operator|&
name|IXL_FLAGS_KEEP_TSO4
condition|)
block|{
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TSO4 requires txcsum, enabling both...\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TXCSUM
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|vsi
operator|->
name|flags
operator||=
name|IXL_FLAGS_KEEP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TSO4 requires txcsum, disabling both...\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
block|}
comment|/* Enable/disable TXCSUM_IPV6/TSO6 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|flags
operator|&
name|IXL_FLAGS_KEEP_TSO6
condition|)
block|{
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO6
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
operator|(
name|IFCAP_TXCSUM_IPV6
operator||
name|IFCAP_TSO6
operator|)
expr_stmt|;
name|vsi
operator|->
name|flags
operator|&=
operator|~
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TSO6 requires txcsum6, enabling both...\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|vsi
operator|->
name|flags
operator||=
name|IXL_FLAGS_KEEP_TSO6
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM_IPV6
operator||
name|IFCAP_TSO6
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TSO6 requires txcsum6, disabling both...\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO6
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Ioctl entry point  *  *  ixl_ioctl is called when the user wants to configure the  *  interface.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|bool
name|avoid_reset
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
comment|/* 		** Calling init results in link renegotiation, 		** so we avoid doing it when possible. 		*/
if|if
condition|(
name|avoid_reset
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|ixl_init
argument_list|(
name|pf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
operator|)
condition|)
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCSIFMTU
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFMTU (Set Interface MTU)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|IXL_MAX_FRAME
operator|-
name|ETHER_HDR_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|ETHER_VLAN_ENCAP_LEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|vsi
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFFLAGS (Set Interface Flags)"
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|pf
operator|->
name|if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
name|ixl_set_promisc
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixl_stop
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|pf
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCADDMULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_disable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_add_multi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_enable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCDELMULTI
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCDELMULTI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_disable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_del_multi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_enable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCxIFMEDIA (Get/Set Interface Media)"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|mask
init|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: SIOCSIFCAP (Set Capabilities)"
argument_list|)
expr_stmt|;
name|ixl_cap_txcsum_tso
argument_list|(
name|vsi
argument_list|,
name|ifp
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ioctl: UNKNOWN (0x%X)\n"
argument_list|,
operator|(
name|int
operator|)
name|command
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Init entry point  *  *  This routine is used in two ways. It is used by the stack as  *  init entry point in network interface structure. It is also used  *  by the driver as a hw/sw initialization routine to get to a  *  consistent state.  *  *  return 0 on success, positive on failure  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixl_init_locked
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_filter_control_settings
name|filter
decl_stmt|;
name|u8
name|tmpaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pf
operator|->
name|pf_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_init: begin"
argument_list|)
expr_stmt|;
name|ixl_stop
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Get the latest mac address... User might use a LAA */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
argument_list|,
name|tmpaddr
argument_list|,
name|I40E_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmp_etheraddr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|tmpaddr
argument_list|)
operator|&&
name|i40e_validate_mac_addr
argument_list|(
name|tmpaddr
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|tmpaddr
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|I40E_ETH_LENGTH_OF_ADDRESS
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i40e_aq_mac_address_write
argument_list|(
name|hw
argument_list|,
name|I40E_AQC_WRITE_TYPE_LAA_ONLY
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"LLA address"
literal|"change failed!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Set the various hardware offload abilities */
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP_IPV6
operator||
name|CSUM_UDP_IPV6
operator|)
expr_stmt|;
comment|/* Set up the device filtering */
name|bzero
argument_list|(
operator|&
name|filter
argument_list|,
sizeof|sizeof
argument_list|(
name|filter
argument_list|)
argument_list|)
expr_stmt|;
name|filter
operator|.
name|enable_ethtype
operator|=
name|TRUE
expr_stmt|;
name|filter
operator|.
name|enable_macvlan
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_FDIR
name|filter
operator|.
name|enable_fdir
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i40e_set_filter_control
argument_list|(
name|hw
argument_list|,
operator|&
name|filter
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"set_filter_control() failed\n"
argument_list|)
expr_stmt|;
comment|/* Set up RSS */
name|ixl_config_rss
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Setup the VSI */
name|ixl_setup_vsi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* 	** Prepare the rings, hmc contexts, etc... 	*/
if|if
condition|(
name|ixl_initialize_vsi
argument_list|(
name|vsi
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"initialize vsi failed!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Add protocol filters to list */
name|ixl_init_filters
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Setup vlan's if needed */
name|ixl_setup_vlan_filters
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Start the local timer */
name|callout_reset
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixl_local_timer
argument_list|,
name|pf
argument_list|)
expr_stmt|;
comment|/* Set up MSI/X routing and the ITR settings */
if|if
condition|(
name|ixl_enable_msix
condition|)
block|{
name|ixl_configure_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_configure_itr
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
else|else
name|ixl_configure_legacy
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_enable_rings
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|i40e_aq_set_default_vsi
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Set MTU in hardware*/
name|int
name|aq_error
init|=
name|i40e_aq_set_mac_config
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|max_frame_size
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|aq_error
condition|)
name|device_printf
argument_list|(
name|vsi
operator|->
name|dev
argument_list|,
literal|"aq_set_mac_config in init error, code %d\n"
argument_list|,
name|aq_error
argument_list|)
expr_stmt|;
comment|/* And now turn on interrupts */
name|ixl_enable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Now inform the stack we're ready */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|arg
decl_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** ** MSIX Interrupt Handlers and Tasklets ** */
end_comment

begin_function
specifier|static
name|void
name|ixl_handle_que
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|context
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|bool
name|more
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|more
operator|=
name|ixl_rxeof
argument_list|(
name|que
argument_list|,
name|IXL_RX_LIMIT
argument_list|)
expr_stmt|;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixl_txeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixl_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|task
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Reenable this interrupt - hmmm */
name|ixl_enable_queue
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Legacy Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|arg
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|icr0
decl_stmt|,
name|mask
decl_stmt|;
name|bool
name|more_tx
decl_stmt|,
name|more_rx
decl_stmt|;
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
comment|/* Protect against spurious interrupts */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|icr0
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|reg
operator||
name|I40E_PFINT_DYN_CTL0_CLEARPBA_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|mask
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|)
expr_stmt|;
if|if
condition|(
name|icr0
operator|&
name|I40E_PFINT_ICR0_ADMINQ_MASK
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|adminq
argument_list|)
expr_stmt|;
return|return;
block|}
name|more_rx
operator|=
name|ixl_rxeof
argument_list|(
name|que
argument_list|,
name|IXL_RX_LIMIT
argument_list|)
expr_stmt|;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|more_tx
operator|=
name|ixl_txeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|more_tx
operator|=
literal|1
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
comment|/* re-enable other interrupt causes */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* And now the queues */
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_RQCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_QINT_RQCTL_CAUSE_ENA_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_RQCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_TQCTL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_QINT_TQCTL_CAUSE_ENA_MASK
expr_stmt|;
name|reg
operator|&=
operator|~
name|I40E_PFINT_ICR0_INTEVENT_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_TQCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ixl_enable_legacy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX VSI Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_msix_que
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|arg
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|bool
name|more_tx
decl_stmt|,
name|more_rx
decl_stmt|;
comment|/* Protect against spurious interrupts */
if|if
condition|(
operator|!
operator|(
name|vsi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
operator|++
name|que
operator|->
name|irqs
expr_stmt|;
name|more_rx
operator|=
name|ixl_rxeof
argument_list|(
name|que
argument_list|,
name|IXL_RX_LIMIT
argument_list|)
expr_stmt|;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|more_tx
operator|=
name|ixl_txeof
argument_list|(
name|que
argument_list|)
expr_stmt|;
comment|/* 	** Make certain that if the stack  	** has anything queued the task gets 	** scheduled to handle it. 	*/
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|more_tx
operator|=
literal|1
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixl_set_queue_rx_itr
argument_list|(
name|que
argument_list|)
expr_stmt|;
name|ixl_set_queue_tx_itr
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|more_tx
operator|||
name|more_rx
condition|)
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|que
operator|->
name|task
argument_list|)
expr_stmt|;
else|else
name|ixl_enable_queue
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MSIX Admin Queue Interrupt Service routine  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixl_msix_adminq
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|arg
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|mask
decl_stmt|;
operator|++
name|pf
operator|->
name|admin_irq
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0
argument_list|)
expr_stmt|;
name|mask
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|)
expr_stmt|;
comment|/* Check on the cause */
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_ADMINQ_MASK
condition|)
name|mask
operator|&=
operator|~
name|I40E_PFINT_ICR0_ENA_ADMINQ_MASK
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_MAL_DETECT_MASK
condition|)
block|{
name|ixl_handle_mdd_event
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|mask
operator|&=
operator|~
name|I40E_PFINT_ICR0_ENA_MAL_DETECT_MASK
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_PFINT_ICR0_VFLR_MASK
condition|)
name|mask
operator|&=
operator|~
name|I40E_PFINT_ICR0_ENA_VFLR_MASK
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|reg
operator||
name|I40E_PFINT_DYN_CTL0_CLEARPBA_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|adminq
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called whenever the user queries the status of  *  the interface using ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixl_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_media_status: begin"
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_update_link_status
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|vsi
operator|->
name|link_up
condition|)
block|{
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
comment|/* Hardware is always full-duplex */
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|phy_type
condition|)
block|{
comment|/* 100 M */
case|case
name|I40E_PHY_TYPE_100BASE_TX
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
break|break;
comment|/* 1 G */
case|case
name|I40E_PHY_TYPE_1000BASE_T
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_1000BASE_SX
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_SX
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_1000BASE_LX
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_LX
expr_stmt|;
break|break;
comment|/* 10 G */
case|case
name|I40E_PHY_TYPE_10GBASE_CR1_CU
case|:
case|case
name|I40E_PHY_TYPE_10GBASE_SFPP_CU
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_TWINAX
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_KR
case|:
comment|/*  			** this is not technically correct 			** but FreeBSD does not have the media 			** type defined yet, so its a compromise. 			*/
case|case
name|I40E_PHY_TYPE_10GBASE_SR
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_SR
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_LR
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_LR
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_10GBASE_T
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_T
expr_stmt|;
break|break;
comment|/* 40 G */
case|case
name|I40E_PHY_TYPE_40GBASE_CR4
case|:
case|case
name|I40E_PHY_TYPE_40GBASE_CR4_CU
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_CR4
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_40GBASE_SR4
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_SR4
expr_stmt|;
break|break;
case|case
name|I40E_PHY_TYPE_40GBASE_LR4
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_40G_LR4
expr_stmt|;
break|break;
default|default:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_UNKNOWN
expr_stmt|;
break|break;
block|}
comment|/* Report flow control status as well */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|an_info
operator|&
name|I40E_AQ_LINK_PAUSE_TX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_ETH_TXPAUSE
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|an_info
operator|&
name|I40E_AQ_LINK_PAUSE_RX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_ETH_RXPAUSE
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Media Ioctl callback  *  *  This routine is called when the user changes speed/duplex using  *  media/mediopt option with ifconfig.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
init|=
operator|&
name|vsi
operator|->
name|media
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_media_change: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Media change is currently not supported.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_FDIR
end_ifdef

begin_comment
comment|/* ** ATR: Application Targetted Receive - creates a filter **	based on TX flow info that will keep the receive **	portion of the flow on the same queue. Based on the **	implementation this is only available for TCP connections */
end_comment

begin_function
name|void
name|ixl_atr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|int
name|etype
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|i40e_filter_program_desc
modifier|*
name|FDIR
decl_stmt|;
name|u32
name|ptype
decl_stmt|,
name|dtype
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* check if ATR is enabled and sample rate */
if|if
condition|(
operator|(
operator|!
name|ixl_enable_fdir
operator|)
operator|||
operator|(
operator|!
name|txr
operator|->
name|atr_rate
operator|)
condition|)
return|return;
comment|/* 	** We sample all TCP SYN/FIN packets, 	** or at the selected sample rate  	*/
name|txr
operator|->
name|atr_count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_FIN
operator||
name|TH_SYN
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|txr
operator|->
name|atr_count
operator|<
name|txr
operator|->
name|atr_rate
operator|)
condition|)
return|return;
name|txr
operator|->
name|atr_count
operator|=
literal|0
expr_stmt|;
comment|/* Get a descriptor to use */
name|idx
operator|=
name|txr
operator|->
name|next_avail
expr_stmt|;
name|FDIR
operator|=
operator|(
expr|struct
name|i40e_filter_program_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|base
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|idx
operator|==
name|que
operator|->
name|num_desc
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|avail
operator|--
expr_stmt|;
name|txr
operator|->
name|next_avail
operator|=
name|idx
expr_stmt|;
name|ptype
operator|=
operator|(
name|que
operator|->
name|me
operator|<<
name|I40E_TXD_FLTR_QW0_QINDEX_SHIFT
operator|)
operator|&
name|I40E_TXD_FLTR_QW0_QINDEX_MASK
expr_stmt|;
name|ptype
operator||=
operator|(
name|etype
operator|==
name|ETHERTYPE_IP
operator|)
condition|?
operator|(
name|I40E_FILTER_PCTYPE_NONF_IPV4_TCP
operator|<<
name|I40E_TXD_FLTR_QW0_PCTYPE_SHIFT
operator|)
else|:
operator|(
name|I40E_FILTER_PCTYPE_NONF_IPV6_TCP
operator|<<
name|I40E_TXD_FLTR_QW0_PCTYPE_SHIFT
operator|)
expr_stmt|;
name|ptype
operator||=
name|vsi
operator|->
name|id
operator|<<
name|I40E_TXD_FLTR_QW0_DEST_VSI_SHIFT
expr_stmt|;
name|dtype
operator|=
name|I40E_TX_DESC_DTYPE_FILTER_PROG
expr_stmt|;
comment|/* 	** We use the TCP TH_FIN as a trigger to remove 	** the filter, otherwise its an update. 	*/
name|dtype
operator||=
operator|(
name|th
operator|->
name|th_flags
operator|&
name|TH_FIN
operator|)
condition|?
operator|(
name|I40E_FILTER_PROGRAM_DESC_PCMD_REMOVE
operator|<<
name|I40E_TXD_FLTR_QW1_PCMD_SHIFT
operator|)
else|:
operator|(
name|I40E_FILTER_PROGRAM_DESC_PCMD_ADD_UPDATE
operator|<<
name|I40E_TXD_FLTR_QW1_PCMD_SHIFT
operator|)
expr_stmt|;
name|dtype
operator||=
name|I40E_FILTER_PROGRAM_DESC_DEST_DIRECT_PACKET_QINDEX
operator|<<
name|I40E_TXD_FLTR_QW1_DEST_SHIFT
expr_stmt|;
name|dtype
operator||=
name|I40E_FILTER_PROGRAM_DESC_FD_STATUS_FD_ID
operator|<<
name|I40E_TXD_FLTR_QW1_FD_STATUS_SHIFT
expr_stmt|;
name|FDIR
operator|->
name|qindex_flex_ptype_vsi
operator|=
name|htole32
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
name|FDIR
operator|->
name|dtype_cmd_cntindex
operator|=
name|htole32
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ixl_set_promisc
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|int
name|err
decl_stmt|,
name|mcnt
init|=
literal|0
decl_stmt|;
name|bool
name|uni
init|=
name|FALSE
decl_stmt|,
name|multi
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
name|multi
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
comment|/* Need to count the multicast addresses */
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|mcnt
operator|==
name|MAX_MULTICAST_ADDR
condition|)
break|break;
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mcnt
operator|>=
name|MAX_MULTICAST_ADDR
condition|)
name|multi
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|uni
operator|=
name|TRUE
expr_stmt|;
name|err
operator|=
name|i40e_aq_set_vsi_unicast_promiscuous
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|uni
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|i40e_aq_set_vsi_multicast_promiscuous
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|multi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  * 	Filter Routines  *  *	Routines for multicast and vlan filter management.  *  *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixl_add_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ixl_add_multi: begin"
argument_list|)
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	** First just get a count, to decide if we 	** we simply use multicast promiscuous. 	*/
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|mcnt
operator|>=
name|MAX_MULTICAST_ADDR
argument_list|)
condition|)
block|{
comment|/* delete existing MC filters */
name|ixl_del_hw_filters
argument_list|(
name|vsi
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
name|i40e_aq_set_vsi_multicast_promiscuous
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|mcnt
operator|=
literal|0
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|ixl_add_mc_filter
argument_list|(
name|vsi
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>
literal|0
condition|)
block|{
name|flags
operator|=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator||
name|IXL_FILTER_MC
operator|)
expr_stmt|;
name|ixl_add_hw_filters
argument_list|(
name|vsi
argument_list|,
name|flags
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
block|}
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ixl_add_multi: end"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_del_multi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
name|bool
name|match
init|=
name|FALSE
decl_stmt|;
name|IOCTL_DEBUGOUT
argument_list|(
literal|"ixl_del_multi: begin"
argument_list|)
expr_stmt|;
comment|/* Search for removed multicast addresses */
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_USED
operator|)
operator|&&
operator|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_MC
operator|)
condition|)
block|{
name|match
operator|=
name|FALSE
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|u8
modifier|*
name|mc_addr
init|=
operator|(
name|u8
operator|*
operator|)
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp_etheraddr
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|mc_addr
argument_list|)
condition|)
block|{
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|match
operator|==
name|FALSE
condition|)
block|{
name|f
operator|->
name|flags
operator||=
name|IXL_FILTER_DEL
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
block|}
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>
literal|0
condition|)
name|ixl_del_hw_filters
argument_list|(
name|vsi
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Timer routine  *  *  This routine checks for link status,updates statistics,  *  and runs the watchdog check.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixl_local_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|arg
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|hung
init|=
literal|0
decl_stmt|;
name|u32
name|mask
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pf
operator|->
name|pf_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Fire off the adminq task */
name|taskqueue_enqueue
argument_list|(
name|pf
operator|->
name|tq
argument_list|,
operator|&
name|pf
operator|->
name|adminq
argument_list|)
expr_stmt|;
comment|/* Update stats */
name|ixl_update_stats_counters
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* 	** Check status of the queues 	*/
name|mask
operator|=
operator|(
name|I40E_PFINT_DYN_CTLN_INTENA_MASK
operator||
name|I40E_PFINT_DYN_CTLN_SWINT_TRIG_MASK
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
comment|/* Any queues with outstanding work get a sw irq */
if|if
condition|(
name|que
operator|->
name|busy
condition|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTLN
argument_list|(
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* 		** Each time txeof runs without cleaning, but there 		** are uncleaned descriptors it increments busy. If 		** we get to 5 we declare it hung. 		*/
if|if
condition|(
name|que
operator|->
name|busy
operator|==
name|IXL_QUEUE_HUNG
condition|)
block|{
operator|++
name|hung
expr_stmt|;
comment|/* Mark the queue as inactive */
name|vsi
operator|->
name|active_queues
operator|&=
operator|~
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Check if we've come back from hung */
if|if
condition|(
operator|(
name|vsi
operator|->
name|active_queues
operator|&
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
operator|)
operator|==
literal|0
condition|)
name|vsi
operator|->
name|active_queues
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|que
operator|->
name|busy
operator|>=
name|IXL_MAX_TX_BUSY
condition|)
block|{
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Warning queue %d "
literal|"appears to be hung!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|que
operator|->
name|busy
operator|=
name|IXL_QUEUE_HUNG
expr_stmt|;
operator|++
name|hung
expr_stmt|;
block|}
block|}
comment|/* Only reinit if all queues show hung */
if|if
condition|(
name|hung
operator|==
name|vsi
operator|->
name|num_queues
condition|)
goto|goto
name|hung
goto|;
name|callout_reset
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ixl_local_timer
argument_list|,
name|pf
argument_list|)
expr_stmt|;
return|return;
name|hung
label|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Local Timer: HANG DETECT - Resetting!!\n"
argument_list|)
expr_stmt|;
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Note: this routine updates the OS on the link state **	the real check of the hardware only happens with **	a link interrupt. */
end_comment

begin_function
specifier|static
name|void
name|ixl_update_link_status
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|enum
name|i40e_fc_mode
name|fc
decl_stmt|;
if|if
condition|(
name|vsi
operator|->
name|link_up
condition|)
block|{
if|if
condition|(
name|vsi
operator|->
name|link_active
operator|==
name|FALSE
condition|)
block|{
name|i40e_aq_get_link_info
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|fc
operator|=
name|hw
operator|->
name|fc
operator|.
name|current_mode
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is up %d Gbps %s,"
literal|" Flow Control: %s\n"
argument_list|,
operator|(
operator|(
name|vsi
operator|->
name|link_speed
operator|==
name|I40E_LINK_SPEED_40GB
operator|)
condition|?
literal|40
else|:
literal|10
operator|)
argument_list|,
literal|"Full Duplex"
argument_list|,
name|ixl_fc_string
index|[
name|fc
index|]
argument_list|)
expr_stmt|;
block|}
name|vsi
operator|->
name|link_active
operator|=
name|TRUE
expr_stmt|;
comment|/* 			** Warn user if link speed on NPAR enabled 			** partition is not at least 10GB 			*/
if|if
condition|(
name|hw
operator|->
name|func_caps
operator|.
name|npar_enable
operator|&&
operator|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|link_speed
operator|==
name|I40E_LINK_SPEED_1GB
operator|||
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|link_speed
operator|==
name|I40E_LINK_SPEED_100MB
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The partition detected link"
literal|"speed that is less than 10Gbps\n"
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Link down */
if|if
condition|(
name|vsi
operator|->
name|link_active
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Link is Down\n"
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|link_active
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  This routine disables all traffic on the adapter by issuing a  *  global reset on the MAC and deallocates TX/RX buffers.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ixl_stop
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vsi
operator|->
name|ifp
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pf
operator|->
name|pf_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_stop: begin\n"
argument_list|)
expr_stmt|;
name|ixl_disable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_disable_rings
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is no longer active */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
comment|/* Stop the local timer */
name|callout_stop
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup MSIX Interrupt resources and handlers for the VSI  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_assign_vsi_legacy
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pf
operator|->
name|msix
operator|==
literal|1
condition|)
name|rid
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: vsi legacy/msi interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixl_intr
argument_list|,
name|pf
argument_list|,
operator|&
name|pf
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pf
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register legacy/msi handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|pf
operator|->
name|tag
argument_list|,
literal|"irq0"
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|tx_task
argument_list|,
literal|0
argument_list|,
name|ixl_deferred_mq_start
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|ixl_handle_que
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixl_que"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s que"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|pf
operator|->
name|adminq
argument_list|,
literal|0
argument_list|,
name|ixl_do_adminq
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|pf
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixl_adm"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|pf
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|pf
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s adminq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup MSIX Interrupt resources and handlers for the VSI  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_assign_vsi_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|,
name|vector
init|=
literal|0
decl_stmt|;
comment|/* Admin Que is vector 0*/
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|pf
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf
operator|->
name|res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: Adminq interrupt [%d]\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the adminq vector and handler */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixl_msix_adminq
argument_list|,
name|pf
argument_list|,
operator|&
name|pf
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pf
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register Admin que handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|pf
operator|->
name|tag
argument_list|,
literal|"aq"
argument_list|)
expr_stmt|;
name|pf
operator|->
name|admvec
operator|=
name|vector
expr_stmt|;
comment|/* Tasklet for Admin Queue */
name|TASK_INIT
argument_list|(
operator|&
name|pf
operator|->
name|adminq
argument_list|,
literal|0
argument_list|,
name|ixl_do_adminq
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|pf
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixl_adm"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|pf
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|pf
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s adminq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|pf
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|vector
expr_stmt|;
comment|/* Now set up the stations */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|int
name|cpu_id
init|=
name|i
decl_stmt|;
name|rid
operator|=
name|vector
operator|+
literal|1
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
name|que
operator|->
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|que
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate"
literal|" bus resource: que interrupt [%d]\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set the handler function */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixl_msix_que
argument_list|,
name|que
argument_list|,
operator|&
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|que
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to register que handler"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|,
literal|"q%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Bind the vector to a CPU */
ifdef|#
directive|ifdef
name|RSS
name|cpu_id
operator|=
name|rss_getcpu
argument_list|(
name|i
operator|%
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bus_bind_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
name|que
operator|->
name|msix
operator|=
name|vector
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|tx_task
argument_list|,
literal|0
argument_list|,
name|ixl_deferred_mq_start
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|que
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|ixl_handle_que
argument_list|,
name|que
argument_list|)
expr_stmt|;
name|que
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"ixl_que"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|que
operator|->
name|tq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|taskqueue_start_threads_pinned
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
name|cpu_id
argument_list|,
literal|"%s (bucket %d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
else|#
directive|else
name|taskqueue_start_threads
argument_list|(
operator|&
name|que
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s que"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate MSI/X vectors  */
end_comment

begin_function
specifier|static
name|int
name|ixl_init_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|want
decl_stmt|,
name|vectors
decl_stmt|,
name|queues
decl_stmt|,
name|available
decl_stmt|;
comment|/* Override by tuneable */
if|if
condition|(
name|ixl_enable_msix
operator|==
literal|0
condition|)
goto|goto
name|msi
goto|;
comment|/* 	** When used in a virtualized environment  	** PCI BUSMASTER capability may not be set 	** so explicity set it here and rewrite 	** the ENABLE in the MSIX control register 	** at this point to cause the host to 	** successfully initialize us. 	*/
block|{
name|u16
name|pci_cmd_word
decl_stmt|;
name|int
name|msix_ctrl
decl_stmt|;
name|pci_cmd_word
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_cmd_word
operator||=
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|pci_cmd_word
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_MSIX
argument_list|,
operator|&
name|rid
argument_list|)
expr_stmt|;
name|rid
operator|+=
name|PCIR_MSIX_CTRL
expr_stmt|;
name|msix_ctrl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|msix_ctrl
operator||=
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* First try MSI/X */
name|rid
operator|=
name|PCIR_BAR
argument_list|(
name|IXL_BAR
argument_list|)
expr_stmt|;
name|pf
operator|->
name|msix_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf
operator|->
name|msix_mem
condition|)
block|{
comment|/* May not be enabled */
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Unable to map MSIX table \n"
argument_list|)
expr_stmt|;
goto|goto
name|msi
goto|;
block|}
name|available
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|available
operator|==
literal|0
condition|)
block|{
comment|/* system has msix disabled */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|pf
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
name|pf
operator|->
name|msix_mem
operator|=
name|NULL
expr_stmt|;
goto|goto
name|msi
goto|;
block|}
comment|/* Figure out a reasonable auto config value */
name|queues
operator|=
operator|(
name|mp_ncpus
operator|>
operator|(
name|available
operator|-
literal|1
operator|)
operator|)
condition|?
operator|(
name|available
operator|-
literal|1
operator|)
else|:
name|mp_ncpus
expr_stmt|;
comment|/* Override with hardcoded value if sane */
if|if
condition|(
operator|(
name|ixl_max_queues
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ixl_max_queues
operator|<=
name|queues
operator|)
condition|)
name|queues
operator|=
name|ixl_max_queues
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* If we're doing RSS, clamp at the number of RSS buckets */
if|if
condition|(
name|queues
operator|>
name|rss_getnumbuckets
argument_list|()
condition|)
name|queues
operator|=
name|rss_getnumbuckets
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Want one vector (RX/TX pair) per queue 	** plus an additional for the admin queue. 	*/
name|want
operator|=
name|queues
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|want
operator|<=
name|available
condition|)
comment|/* Have enough */
name|vectors
operator|=
name|want
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"MSIX Configuration Problem, "
literal|"%d vectors available but %d wanted!\n"
argument_list|,
name|available
argument_list|,
name|want
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Will go to Legacy setup */
block|}
if|if
condition|(
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|vectors
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Using MSIX interrupts with %d vectors\n"
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
name|pf
operator|->
name|msix
operator|=
name|vectors
expr_stmt|;
name|pf
operator|->
name|vsi
operator|.
name|num_queues
operator|=
name|queues
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* 		 * If we're doing RSS, the number of queues needs to 		 * match the number of RSS buckets that are configured. 		 * 		 * + If there's more queues than RSS buckets, we'll end 		 *   up with queues that get no traffic. 		 * 		 * + If there's more RSS buckets than queues, we'll end 		 *   up having multiple RSS buckets map to the same queue, 		 *   so there'll be some contention. 		 */
if|if
condition|(
name|queues
operator|!=
name|rss_getnumbuckets
argument_list|()
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: queues (%d) != RSS buckets (%d)"
literal|"; performance will be impacted.\n"
argument_list|,
name|__func__
argument_list|,
name|queues
argument_list|,
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|vectors
operator|)
return|;
block|}
name|msi
label|:
name|vectors
operator|=
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pf
operator|->
name|vsi
operator|.
name|num_queues
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|msix
operator|=
literal|1
expr_stmt|;
name|ixl_max_queues
operator|=
literal|1
expr_stmt|;
name|ixl_enable_msix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vectors
operator|==
literal|1
operator|&&
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|vectors
argument_list|)
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Using an MSI interrupt\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|pf
operator|->
name|msix
operator|=
literal|0
expr_stmt|;
name|device_printf
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
literal|"Using a Legacy interrupt\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|vectors
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Plumb MSI/X vectors  */
end_comment

begin_function
specifier|static
name|void
name|ixl_configure_msix
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|u16
name|vector
init|=
literal|1
decl_stmt|;
comment|/* First set up the adminq - vector 0 */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable all */
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0
argument_list|)
expr_stmt|;
comment|/* read to clear */
name|reg
operator|=
name|I40E_PFINT_ICR0_ENA_ECC_ERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_GRST_MASK
operator||
name|I40E_PFINT_ICR0_HMC_ERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_ADMINQ_MASK
operator||
name|I40E_PFINT_ICR0_ENA_MAL_DETECT_MASK
operator||
name|I40E_PFINT_ICR0_ENA_VFLR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_PCI_EXCEPTION_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_LNKLST0
argument_list|,
literal|0x7FF
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITR0
argument_list|(
name|IXL_RX_ITR
argument_list|)
argument_list|,
literal|0x003E
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|I40E_PFINT_DYN_CTL0_SW_ITR_INDX_MASK
operator||
name|I40E_PFINT_DYN_CTL0_INTENA_MSK_MASK
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_STAT_CTL0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Next configure the queues */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|vector
operator|++
control|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTLN
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_LNKLSTN
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I40E_QINT_RQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|IXL_RX_ITR
operator|<<
name|I40E_QINT_RQCTL_ITR_INDX_SHIFT
operator|)
operator||
operator|(
name|vector
operator|<<
name|I40E_QINT_RQCTL_MSIX_INDX_SHIFT
operator|)
operator||
operator|(
name|i
operator|<<
name|I40E_QINT_RQCTL_NEXTQ_INDX_SHIFT
operator|)
operator||
operator|(
name|I40E_QUEUE_TYPE_TX
operator|<<
name|I40E_QINT_RQCTL_NEXTQ_TYPE_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_RQCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I40E_QINT_TQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|IXL_TX_ITR
operator|<<
name|I40E_QINT_TQCTL_ITR_INDX_SHIFT
operator|)
operator||
operator|(
name|vector
operator|<<
name|I40E_QINT_TQCTL_MSIX_INDX_SHIFT
operator|)
operator||
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|I40E_QINT_TQCTL_NEXTQ_INDX_SHIFT
operator|)
operator||
operator|(
name|I40E_QUEUE_TYPE_RX
operator|<<
name|I40E_QINT_TQCTL_NEXTQ_TYPE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|vsi
operator|->
name|num_queues
operator|-
literal|1
operator|)
condition|)
name|reg
operator||=
operator|(
name|IXL_QUEUE_EOL
operator|<<
name|I40E_QINT_TQCTL_NEXTQ_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_TQCTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Configure for MSI single vector operation   */
end_comment

begin_function
specifier|static
name|void
name|ixl_configure_legacy
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITR0
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITR0
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup "other" causes */
name|reg
operator|=
name|I40E_PFINT_ICR0_ENA_ECC_ERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_MAL_DETECT_MASK
operator||
name|I40E_PFINT_ICR0_ENA_GRST_MASK
operator||
name|I40E_PFINT_ICR0_ENA_PCI_EXCEPTION_MASK
operator||
name|I40E_PFINT_ICR0_ENA_GPIO_MASK
operator||
name|I40E_PFINT_ICR0_ENA_LINK_STAT_CHANGE_MASK
operator||
name|I40E_PFINT_ICR0_ENA_HMC_ERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_PE_CRITERR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_VFLR_MASK
operator||
name|I40E_PFINT_ICR0_ENA_ADMINQ_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* SW_ITR_IDX = 0, but don't change INTENA */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|I40E_PFINT_DYN_CTLN_SW_ITR_INDX_MASK
operator||
name|I40E_PFINT_DYN_CTLN_INTENA_MSK_MASK
argument_list|)
expr_stmt|;
comment|/* SW_ITR_IDX = 0, OTHER_ITR_IDX = 0 */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_STAT_CTL0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIRSTQ_INDX = 0, FIRSTQ_TYPE = 0 (rx) */
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_LNKLST0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Associate the queue pair to the vector and enable the q int */
name|reg
operator|=
name|I40E_QINT_RQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|IXL_RX_ITR
operator|<<
name|I40E_QINT_RQCTL_ITR_INDX_SHIFT
operator|)
operator||
operator|(
name|I40E_QUEUE_TYPE_TX
operator|<<
name|I40E_QINT_TQCTL_NEXTQ_TYPE_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_RQCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|I40E_QINT_TQCTL_CAUSE_ENA_MASK
operator||
operator|(
name|IXL_TX_ITR
operator|<<
name|I40E_QINT_TQCTL_ITR_INDX_SHIFT
operator|)
operator||
operator|(
name|IXL_QUEUE_EOL
operator|<<
name|I40E_QINT_TQCTL_NEXTQ_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QINT_TQCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Next enable the queue pair */
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_QTX_ENA_QENA_REQ_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_QRX_ENA_QENA_REQ_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the Initial ITR state  */
end_comment

begin_function
specifier|static
name|void
name|ixl_configure_itr
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|vsi
operator|->
name|rx_itr_setting
operator|=
name|ixl_rx_itr
expr_stmt|;
if|if
condition|(
name|ixl_dynamic_rx_itr
condition|)
name|vsi
operator|->
name|rx_itr_setting
operator||=
name|IXL_ITR_DYNAMIC
expr_stmt|;
name|vsi
operator|->
name|tx_itr_setting
operator|=
name|ixl_tx_itr
expr_stmt|;
if|if
condition|(
name|ixl_dynamic_tx_itr
condition|)
name|vsi
operator|->
name|tx_itr_setting
operator||=
name|IXL_ITR_DYNAMIC
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_RX_ITR
argument_list|,
name|i
argument_list|)
argument_list|,
name|vsi
operator|->
name|rx_itr_setting
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|rx_itr_setting
expr_stmt|;
name|rxr
operator|->
name|latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_TX_ITR
argument_list|,
name|i
argument_list|)
argument_list|,
name|vsi
operator|->
name|tx_itr_setting
argument_list|)
expr_stmt|;
name|txr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|tx_itr_setting
expr_stmt|;
name|txr
operator|->
name|latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_allocate_pci_resources
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pf
operator|->
name|pci_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pf
operator|->
name|pci_mem
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate bus resource: memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|pf
operator|->
name|osdep
operator|.
name|mem_bus_space_tag
operator|=
name|rman_get_bustag
argument_list|(
name|pf
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|pf
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|pf
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|pf
operator|->
name|osdep
operator|.
name|mem_bus_space_size
operator|=
name|rman_get_size
argument_list|(
name|pf
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
name|pf
operator|->
name|osdep
operator|.
name|flush_reg
operator|=
name|I40E_GLGEN_STAT
expr_stmt|;
name|pf
operator|->
name|hw
operator|.
name|hw_addr
operator|=
operator|(
name|u8
operator|*
operator|)
operator|&
name|pf
operator|->
name|osdep
operator|.
name|mem_bus_space_handle
expr_stmt|;
name|pf
operator|->
name|hw
operator|.
name|back
operator|=
operator|&
name|pf
operator|->
name|osdep
expr_stmt|;
comment|/* 	** Now setup MSI or MSI/X, should 	** return us the number of supported 	** vectors. (Will be 1 for MSI) 	*/
name|pf
operator|->
name|msix
operator|=
name|ixl_init_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_free_pci_resources
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|memrid
decl_stmt|;
name|memrid
operator|=
name|PCIR_BAR
argument_list|(
name|IXL_BAR
argument_list|)
expr_stmt|;
comment|/* We may get here before stations are setup */
if|if
condition|(
operator|(
operator|!
name|ixl_enable_msix
operator|)
operator|||
operator|(
name|que
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|early
goto|;
comment|/* 	**  Release all msix VSI resources: 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|rid
operator|=
name|que
operator|->
name|msix
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|que
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|que
operator|->
name|res
argument_list|,
name|que
operator|->
name|tag
argument_list|)
expr_stmt|;
name|que
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|que
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|que
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
name|early
label|:
comment|/* Clean the AdminQ interrupt last */
if|if
condition|(
name|pf
operator|->
name|admvec
condition|)
comment|/* we are doing MSIX */
name|rid
operator|=
name|pf
operator|->
name|admvec
operator|+
literal|1
expr_stmt|;
else|else
operator|(
name|pf
operator|->
name|msix
operator|!=
literal|0
operator|)
condition|?
operator|(
name|rid
operator|=
literal|1
operator|)
else|:
operator|(
name|rid
operator|=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|res
argument_list|,
name|pf
operator|->
name|tag
argument_list|)
expr_stmt|;
name|pf
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|->
name|res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|pf
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|msix
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|msix_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|memrid
argument_list|,
name|pf
operator|->
name|msix_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|pci_mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|pf
operator|->
name|pci_mem
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_add_ifmedia
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|u32
name|phy_type
parameter_list|)
block|{
comment|/* Display supported media types */
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_100BASE_TX
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_1000BASE_T
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_CR1_CU
operator|)
operator|||
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_SFPP_CU
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_TWINAX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_SR
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_SR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_LR
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_LR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_10GBASE_T
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_40GBASE_CR4_CU
operator|)
operator|||
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_40GBASE_CR4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_CR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_40GBASE_SR4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_SR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_type
operator|&
operator|(
literal|1
operator|<<
name|I40E_PHY_TYPE_40GBASE_LR4
operator|)
condition|)
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_40G_LR4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Setup networking device structure and register an interface.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_setup_interface
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities_resp
decl_stmt|;
name|enum
name|i40e_status_code
name|aq_error
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_setup_interface: begin"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|vsi
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|4000000000
expr_stmt|;
comment|// ??
name|ifp
operator|->
name|if_init
operator|=
name|ixl_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|vsi
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ixl_ioctl
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100036
name|if_setgetcounterfn
argument_list|(
name|ifp
argument_list|,
name|ixl_get_counter
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_transmit
operator|=
name|ixl_mq_start
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|ixl_qflush
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|que
operator|->
name|num_desc
operator|-
literal|2
expr_stmt|;
name|vsi
operator|->
name|max_frame_size
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_CRC_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
comment|/* 	 * Tell the upper layer(s) we support long frames. 	 */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM_IPV6
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_JUMBO_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_LRO
expr_stmt|;
comment|/* VLAN capabilties */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	** Don't turn this on by default, if vlans are 	** created on another pseudo device (eg. lagg) 	** then vlan events are not passed thru, breaking 	** operation, but with HW FILTER off it works. If 	** using vlans directly on the ixl driver you can 	** enable this and get full hardware tag filtering. 	*/
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
comment|/* 	 * Specify the media types supported by this adapter and register 	 * callbacks to update media and link information 	 */
name|ifmedia_init
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|ixl_media_change
argument_list|,
name|ixl_media_status
argument_list|)
expr_stmt|;
name|aq_error
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|&
name|abilities_resp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
operator|==
name|I40E_ERR_UNKNOWN_PHY
condition|)
block|{
comment|/* Need delay to detect fiber correctly */
name|i40e_msec_delay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|aq_error
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|&
name|abilities_resp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
operator|==
name|I40E_ERR_UNKNOWN_PHY
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unknown PHY type detected!\n"
argument_list|)
expr_stmt|;
else|else
name|ixl_add_ifmedia
argument_list|(
name|vsi
argument_list|,
name|abilities_resp
operator|.
name|phy_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aq_error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error getting supported media types, err %d,"
literal|" AQ error %d\n"
argument_list|,
name|aq_error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
else|else
name|ixl_add_ifmedia
argument_list|(
name|vsi
argument_list|,
name|abilities_resp
operator|.
name|phy_type
argument_list|)
expr_stmt|;
comment|/* Use autoselect media by default */
name|ifmedia_add
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|vsi
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ixl_config_link
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|bool
name|check
decl_stmt|;
name|i40e_aq_get_link_info
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|check
operator|=
name|i40e_get_link_status
argument_list|(
name|hw
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|printf
argument_list|(
literal|"Link is %s\n"
argument_list|,
name|check
condition|?
literal|"up"
else|:
literal|"down"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|check
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize this VSI   *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_setup_vsi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_aqc_get_switch_config_resp
modifier|*
name|sw_config
decl_stmt|;
name|struct
name|i40e_vsi_context
name|ctxt
decl_stmt|;
name|u8
name|aq_buf
index|[
name|I40E_AQ_LARGE_BUF
index|]
decl_stmt|;
name|int
name|ret
init|=
name|I40E_SUCCESS
decl_stmt|;
name|u16
name|next
init|=
literal|0
decl_stmt|;
name|sw_config
operator|=
operator|(
expr|struct
name|i40e_aqc_get_switch_config_resp
operator|*
operator|)
name|aq_buf
expr_stmt|;
name|ret
operator|=
name|i40e_aq_get_switch_config
argument_list|(
name|hw
argument_list|,
name|sw_config
argument_list|,
sizeof|sizeof
argument_list|(
name|aq_buf
argument_list|)
argument_list|,
operator|&
name|next
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"aq_get_switch_config failed!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|printf
argument_list|(
literal|"Switch config: header reported: %d in structure, %d total\n"
argument_list|,
name|sw_config
operator|->
name|header
operator|.
name|num_reported
argument_list|,
name|sw_config
operator|->
name|header
operator|.
name|num_total
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"type=%d seid=%d uplink=%d downlink=%d\n"
argument_list|,
name|sw_config
operator|->
name|element
index|[
literal|0
index|]
operator|.
name|element_type
argument_list|,
name|sw_config
operator|->
name|element
index|[
literal|0
index|]
operator|.
name|seid
argument_list|,
name|sw_config
operator|->
name|element
index|[
literal|0
index|]
operator|.
name|uplink_seid
argument_list|,
name|sw_config
operator|->
name|element
index|[
literal|0
index|]
operator|.
name|downlink_seid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Save off this important value */
name|vsi
operator|->
name|seid
operator|=
name|sw_config
operator|->
name|element
index|[
literal|0
index|]
operator|.
name|seid
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ctxt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctxt
argument_list|)
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|seid
operator|=
name|vsi
operator|->
name|seid
expr_stmt|;
name|ctxt
operator|.
name|pf_num
operator|=
name|hw
operator|->
name|pf_id
expr_stmt|;
name|ret
operator|=
name|i40e_aq_get_vsi_params
argument_list|(
name|hw
argument_list|,
operator|&
name|ctxt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"get vsi params failed %x!!\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|printf
argument_list|(
literal|"get_vsi_params: seid: %d, uplinkseid: %d, vsi_number: %d, "
literal|"vsis_allocated: %d, vsis_unallocated: %d, flags: 0x%x, "
literal|"pfnum: %d, vfnum: %d, stat idx: %d, enabled: %d\n"
argument_list|,
name|ctxt
operator|.
name|seid
argument_list|,
name|ctxt
operator|.
name|uplink_seid
argument_list|,
name|ctxt
operator|.
name|vsi_number
argument_list|,
name|ctxt
operator|.
name|vsis_allocated
argument_list|,
name|ctxt
operator|.
name|vsis_unallocated
argument_list|,
name|ctxt
operator|.
name|flags
argument_list|,
name|ctxt
operator|.
name|pf_num
argument_list|,
name|ctxt
operator|.
name|vf_num
argument_list|,
name|ctxt
operator|.
name|info
operator|.
name|stat_counter_idx
argument_list|,
name|ctxt
operator|.
name|info
operator|.
name|up_enable_bits
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	** Set the queue and traffic class bits 	**  - when multiple traffic classes are supported 	**    this will need to be more robust. 	*/
name|ctxt
operator|.
name|info
operator|.
name|valid_sections
operator|=
name|I40E_AQ_VSI_PROP_QUEUE_MAP_VALID
expr_stmt|;
name|ctxt
operator|.
name|info
operator|.
name|mapping_flags
operator||=
name|I40E_AQ_VSI_QUE_MAP_CONTIG
expr_stmt|;
name|ctxt
operator|.
name|info
operator|.
name|queue_mapping
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ctxt
operator|.
name|info
operator|.
name|tc_mapping
index|[
literal|0
index|]
operator|=
literal|0x0800
expr_stmt|;
comment|/* Set VLAN receive stripping mode */
name|ctxt
operator|.
name|info
operator|.
name|valid_sections
operator||=
name|I40E_AQ_VSI_PROP_VLAN_VALID
expr_stmt|;
name|ctxt
operator|.
name|info
operator|.
name|port_vlan_flags
operator|=
name|I40E_AQ_VSI_PVLAN_MODE_ALL
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ctxt
operator|.
name|info
operator|.
name|port_vlan_flags
operator||=
name|I40E_AQ_VSI_PVLAN_EMOD_STR_BOTH
expr_stmt|;
else|else
name|ctxt
operator|.
name|info
operator|.
name|port_vlan_flags
operator||=
name|I40E_AQ_VSI_PVLAN_EMOD_NOTHING
expr_stmt|;
comment|/* Keep copy of VSI info in VSI for statistic counters */
name|memcpy
argument_list|(
operator|&
name|vsi
operator|->
name|info
argument_list|,
operator|&
name|ctxt
operator|.
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|ctxt
operator|.
name|info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reset VSI statistics */
name|ixl_vsi_reset_stats
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|hw_filters_add
operator|=
literal|0
expr_stmt|;
name|vsi
operator|->
name|hw_filters_del
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|i40e_aq_update_vsi_params
argument_list|(
name|hw
argument_list|,
operator|&
name|ctxt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"update vsi params failed %x!!\n"
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize the VSI:  this handles contexts, which means things  *  			 like the number of descriptors, buffer size,  *			 plus we init the rings thru this function.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_initialize_vsi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|i40e_hmc_obj_txq
name|tctx
decl_stmt|;
name|struct
name|i40e_hmc_obj_rxq
name|rctx
decl_stmt|;
name|u32
name|txctl
decl_stmt|;
name|u16
name|size
decl_stmt|;
comment|/* Setup the HMC TX Context  */
name|size
operator|=
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_tx_desc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hmc_obj_txq
argument_list|)
argument_list|)
expr_stmt|;
name|tctx
operator|.
name|new_context
operator|=
literal|1
expr_stmt|;
name|tctx
operator|.
name|base
operator|=
operator|(
name|txr
operator|->
name|dma
operator|.
name|pa
operator|/
literal|128
operator|)
expr_stmt|;
name|tctx
operator|.
name|qlen
operator|=
name|que
operator|->
name|num_desc
expr_stmt|;
name|tctx
operator|.
name|fc_ena
operator|=
literal|0
expr_stmt|;
name|tctx
operator|.
name|rdylist
operator|=
name|vsi
operator|->
name|info
operator|.
name|qs_handle
index|[
literal|0
index|]
expr_stmt|;
comment|/* index is TC */
comment|/* Enable HEAD writeback */
name|tctx
operator|.
name|head_wb_ena
operator|=
literal|1
expr_stmt|;
name|tctx
operator|.
name|head_wb_addr
operator|=
name|txr
operator|->
name|dma
operator|.
name|pa
operator|+
operator|(
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_tx_desc
argument_list|)
operator|)
expr_stmt|;
name|tctx
operator|.
name|rdylist_act
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|i40e_clear_lan_tx_queue_context
argument_list|(
name|hw
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to clear TX context\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|i40e_set_lan_tx_queue_context
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|tctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to set TX context\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Associate the ring with this PF */
name|txctl
operator|=
name|I40E_QTX_CTL_PF_QUEUE
expr_stmt|;
name|txctl
operator||=
operator|(
operator|(
name|hw
operator|->
name|pf_id
operator|<<
name|I40E_QTX_CTL_PF_INDX_SHIFT
operator|)
operator|&
name|I40E_QTX_CTL_PF_INDX_MASK
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_CTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|txctl
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Do ring (re)init */
name|ixl_init_tx_ring
argument_list|(
name|que
argument_list|)
expr_stmt|;
comment|/* Next setup the HMC RX Context  */
if|if
condition|(
name|vsi
operator|->
name|max_frame_size
operator|<=
literal|2048
condition|)
name|rxr
operator|->
name|mbuf_sz
operator|=
name|MCLBYTES
expr_stmt|;
else|else
name|rxr
operator|->
name|mbuf_sz
operator|=
name|MJUMPAGESIZE
expr_stmt|;
name|u16
name|max_rxmax
init|=
name|rxr
operator|->
name|mbuf_sz
operator|*
name|hw
operator|->
name|func_caps
operator|.
name|rx_buf_chain_len
decl_stmt|;
comment|/* Set up an RX context for the HMC */
name|memset
argument_list|(
operator|&
name|rctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hmc_obj_rxq
argument_list|)
argument_list|)
expr_stmt|;
name|rctx
operator|.
name|dbuff
operator|=
name|rxr
operator|->
name|mbuf_sz
operator|>>
name|I40E_RXQ_CTX_DBUFF_SHIFT
expr_stmt|;
comment|/* ignore header split for now */
name|rctx
operator|.
name|hbuff
operator|=
literal|0
operator|>>
name|I40E_RXQ_CTX_HBUFF_SHIFT
expr_stmt|;
name|rctx
operator|.
name|rxmax
operator|=
operator|(
name|vsi
operator|->
name|max_frame_size
operator|<
name|max_rxmax
operator|)
condition|?
name|vsi
operator|->
name|max_frame_size
else|:
name|max_rxmax
expr_stmt|;
name|rctx
operator|.
name|dtype
operator|=
literal|0
expr_stmt|;
name|rctx
operator|.
name|dsize
operator|=
literal|1
expr_stmt|;
comment|/* do 32byte descriptors */
name|rctx
operator|.
name|hsplit_0
operator|=
literal|0
expr_stmt|;
comment|/* no HDR split initially */
name|rctx
operator|.
name|base
operator|=
operator|(
name|rxr
operator|->
name|dma
operator|.
name|pa
operator|/
literal|128
operator|)
expr_stmt|;
name|rctx
operator|.
name|qlen
operator|=
name|que
operator|->
name|num_desc
expr_stmt|;
name|rctx
operator|.
name|tphrdesc_ena
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|tphwdesc_ena
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|tphdata_ena
operator|=
literal|0
expr_stmt|;
name|rctx
operator|.
name|tphhead_ena
operator|=
literal|0
expr_stmt|;
name|rctx
operator|.
name|lrxqthresh
operator|=
literal|2
expr_stmt|;
name|rctx
operator|.
name|crcstrip
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|l2tsel
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|showiv
operator|=
literal|1
expr_stmt|;
name|rctx
operator|.
name|fc_ena
operator|=
literal|0
expr_stmt|;
name|rctx
operator|.
name|prefena
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|i40e_clear_lan_rx_queue_context
argument_list|(
name|hw
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to clear RX context %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|i40e_set_lan_rx_queue_context
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
operator|&
name|rctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to set RX context %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|ixl_init_rx_ring
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Fail in init_rx_ring %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|wr32
argument_list|(
name|vsi
operator|->
name|hw
argument_list|,
name|I40E_QRX_TAIL
argument_list|(
name|que
operator|->
name|me
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|vsi
operator|->
name|hw
argument_list|,
name|I40E_QRX_TAIL
argument_list|(
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|que
operator|->
name|num_desc
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free all VSI structs.  *  **********************************************************************/
end_comment

begin_function
name|void
name|ixl_free_vsi
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
comment|/* Free station queues */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|)
condition|)
comment|/* uninitialized */
continue|continue;
name|IXL_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixl_free_que_tx
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|)
expr_stmt|;
name|IXL_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|IXL_TX_LOCK_DESTROY
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|rxr
operator|->
name|mtx
argument_list|)
condition|)
comment|/* uninitialized */
continue|continue;
name|IXL_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|ixl_free_que_rx
argument_list|(
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|)
expr_stmt|;
name|IXL_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|IXL_RX_LOCK_DESTROY
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|vsi
operator|->
name|queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* Free VSI filter list */
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|)
condition|)
block|{
name|f
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for the VSI (virtual station interface) and their  *  associated queues, rings and the descriptors associated with each,  *  called only once at attach.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_setup_stations
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|tsize
decl_stmt|;
name|int
name|error
init|=
name|I40E_SUCCESS
decl_stmt|;
name|vsi
operator|=
operator|&
name|pf
operator|->
name|vsi
expr_stmt|;
name|vsi
operator|->
name|back
operator|=
operator|(
name|void
operator|*
operator|)
name|pf
expr_stmt|;
name|vsi
operator|->
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
name|vsi
operator|->
name|id
operator|=
literal|0
expr_stmt|;
name|vsi
operator|->
name|num_vlans
operator|=
literal|0
expr_stmt|;
comment|/* Get memory for the station queues */
if|if
condition|(
operator|!
operator|(
name|vsi
operator|->
name|queues
operator|=
operator|(
expr|struct
name|ixl_queue
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_queue
argument_list|)
operator|*
name|vsi
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate queue memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|early
goto|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|vsi
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|que
operator|->
name|num_desc
operator|=
name|ixl_ringsz
expr_stmt|;
name|que
operator|->
name|me
operator|=
name|i
expr_stmt|;
name|que
operator|->
name|vsi
operator|=
name|vsi
expr_stmt|;
comment|/* mark the queue as active */
name|vsi
operator|->
name|active_queues
operator||=
operator|(
name|u64
operator|)
literal|1
operator|<<
name|que
operator|->
name|me
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
name|txr
operator|->
name|que
operator|=
name|que
expr_stmt|;
name|txr
operator|->
name|tail
operator|=
name|I40E_QTX_TAIL
argument_list|(
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
comment|/* Initialize the TX lock */
name|snprintf
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:tx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|txr
operator|->
name|mtx
argument_list|,
name|txr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Create the TX descriptor ring */
name|tsize
operator|=
name|roundup2
argument_list|(
operator|(
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_tx_desc
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|i40e_allocate_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|,
name|i40e_mem_reserved
argument_list|,
name|tsize
argument_list|,
name|DBA_ALIGN
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|txr
operator|->
name|base
operator|=
operator|(
expr|struct
name|i40e_tx_desc
operator|*
operator|)
name|txr
operator|->
name|dma
operator|.
name|va
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|base
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
comment|/* Now allocate transmit soft structs for the ring */
if|if
condition|(
name|ixl_allocate_tx_data
argument_list|(
name|que
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up TX structures\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate a buf ring */
name|txr
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
literal|4096
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|txr
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|br
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up TX buf ring\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 		 * Next the RX queues... 		 */
name|rsize
operator|=
name|roundup2
argument_list|(
name|que
operator|->
name|num_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|i40e_rx_desc
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
name|rxr
operator|=
operator|&
name|que
operator|->
name|rxr
expr_stmt|;
name|rxr
operator|->
name|que
operator|=
name|que
expr_stmt|;
name|rxr
operator|->
name|tail
operator|=
name|I40E_QRX_TAIL
argument_list|(
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
comment|/* Initialize the RX side lock */
name|snprintf
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:rx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rxr
operator|->
name|mtx
argument_list|,
name|rxr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|i40e_allocate_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|,
name|i40e_mem_reserved
argument_list|,
name|rsize
argument_list|,
literal|4096
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rxr
operator|->
name|base
operator|=
operator|(
expr|union
name|i40e_rx_desc
operator|*
operator|)
name|rxr
operator|->
name|dma
operator|.
name|va
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* Allocate receive soft structs for the ring*/
if|if
condition|(
name|ixl_allocate_rx_data
argument_list|(
name|que
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up receive structs\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|vsi
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|rxr
operator|=
operator|&
name|que
operator|->
name|rxr
expr_stmt|;
name|txr
operator|=
operator|&
name|que
operator|->
name|txr
expr_stmt|;
if|if
condition|(
name|rxr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|rxr
operator|->
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|base
condition|)
name|i40e_free_dma_mem
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|,
operator|&
name|txr
operator|->
name|dma
argument_list|)
expr_stmt|;
block|}
name|early
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Provide a update to the queue RX ** interrupt moderation value. */
end_comment

begin_function
specifier|static
name|void
name|ixl_set_queue_rx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|u16
name|rx_itr
decl_stmt|;
name|u16
name|rx_latency
init|=
literal|0
decl_stmt|;
name|int
name|rx_bytes
decl_stmt|;
comment|/* Idle, do nothing */
if|if
condition|(
name|rxr
operator|->
name|bytes
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ixl_dynamic_rx_itr
condition|)
block|{
name|rx_bytes
operator|=
name|rxr
operator|->
name|bytes
operator|/
name|rxr
operator|->
name|itr
expr_stmt|;
name|rx_itr
operator|=
name|rxr
operator|->
name|itr
expr_stmt|;
comment|/* Adjust latency range */
switch|switch
condition|(
name|rxr
operator|->
name|latency
condition|)
block|{
case|case
name|IXL_LOW_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|>
literal|10
condition|)
block|{
name|rx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_AVE_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|>
literal|20
condition|)
block|{
name|rx_latency
operator|=
name|IXL_BULK_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_8K
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rx_bytes
operator|<=
literal|10
condition|)
block|{
name|rx_latency
operator|=
name|IXL_LOW_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_100K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_BULK_LATENCY
case|:
if|if
condition|(
name|rx_bytes
operator|<=
literal|20
condition|)
block|{
name|rx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|rx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
block|}
name|rxr
operator|->
name|latency
operator|=
name|rx_latency
expr_stmt|;
if|if
condition|(
name|rx_itr
operator|!=
name|rxr
operator|->
name|itr
condition|)
block|{
comment|/* do an exponential smoothing */
name|rx_itr
operator|=
operator|(
literal|10
operator|*
name|rx_itr
operator|*
name|rxr
operator|->
name|itr
operator|)
operator|/
operator|(
operator|(
literal|9
operator|*
name|rx_itr
operator|)
operator|+
name|rxr
operator|->
name|itr
operator|)
expr_stmt|;
name|rxr
operator|->
name|itr
operator|=
name|rx_itr
operator|&
name|IXL_MAX_ITR
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_RX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|rxr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have have toggled to non-dynamic */
if|if
condition|(
name|vsi
operator|->
name|rx_itr_setting
operator|&
name|IXL_ITR_DYNAMIC
condition|)
name|vsi
operator|->
name|rx_itr_setting
operator|=
name|ixl_rx_itr
expr_stmt|;
comment|/* Update the hardware if needed */
if|if
condition|(
name|rxr
operator|->
name|itr
operator|!=
name|vsi
operator|->
name|rx_itr_setting
condition|)
block|{
name|rxr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|rx_itr_setting
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_RX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|rxr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
name|rxr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Provide a update to the queue TX ** interrupt moderation value. */
end_comment

begin_function
specifier|static
name|void
name|ixl_set_queue_tx_itr
parameter_list|(
name|struct
name|ixl_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|que
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|u16
name|tx_itr
decl_stmt|;
name|u16
name|tx_latency
init|=
literal|0
decl_stmt|;
name|int
name|tx_bytes
decl_stmt|;
comment|/* Idle, do nothing */
if|if
condition|(
name|txr
operator|->
name|bytes
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ixl_dynamic_tx_itr
condition|)
block|{
name|tx_bytes
operator|=
name|txr
operator|->
name|bytes
operator|/
name|txr
operator|->
name|itr
expr_stmt|;
name|tx_itr
operator|=
name|txr
operator|->
name|itr
expr_stmt|;
switch|switch
condition|(
name|txr
operator|->
name|latency
condition|)
block|{
case|case
name|IXL_LOW_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|>
literal|10
condition|)
block|{
name|tx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_AVE_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|>
literal|20
condition|)
block|{
name|tx_latency
operator|=
name|IXL_BULK_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_8K
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tx_bytes
operator|<=
literal|10
condition|)
block|{
name|tx_latency
operator|=
name|IXL_LOW_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_100K
expr_stmt|;
block|}
break|break;
case|case
name|IXL_BULK_LATENCY
case|:
if|if
condition|(
name|tx_bytes
operator|<=
literal|20
condition|)
block|{
name|tx_latency
operator|=
name|IXL_AVE_LATENCY
expr_stmt|;
name|tx_itr
operator|=
name|IXL_ITR_20K
expr_stmt|;
block|}
break|break;
block|}
name|txr
operator|->
name|latency
operator|=
name|tx_latency
expr_stmt|;
if|if
condition|(
name|tx_itr
operator|!=
name|txr
operator|->
name|itr
condition|)
block|{
comment|/* do an exponential smoothing */
name|tx_itr
operator|=
operator|(
literal|10
operator|*
name|tx_itr
operator|*
name|txr
operator|->
name|itr
operator|)
operator|/
operator|(
operator|(
literal|9
operator|*
name|tx_itr
operator|)
operator|+
name|txr
operator|->
name|itr
operator|)
expr_stmt|;
name|txr
operator|->
name|itr
operator|=
name|tx_itr
operator|&
name|IXL_MAX_ITR
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_TX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|txr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have have toggled to non-dynamic */
if|if
condition|(
name|vsi
operator|->
name|tx_itr_setting
operator|&
name|IXL_ITR_DYNAMIC
condition|)
name|vsi
operator|->
name|tx_itr_setting
operator|=
name|ixl_tx_itr
expr_stmt|;
comment|/* Update the hardware if needed */
if|if
condition|(
name|txr
operator|->
name|itr
operator|!=
name|vsi
operator|->
name|tx_itr_setting
condition|)
block|{
name|txr
operator|->
name|itr
operator|=
name|vsi
operator|->
name|tx_itr_setting
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ITRN
argument_list|(
name|IXL_TX_ITR
argument_list|,
name|que
operator|->
name|me
argument_list|)
argument_list|,
name|txr
operator|->
name|itr
argument_list|)
expr_stmt|;
block|}
block|}
name|txr
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_add_hw_stats
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|queues
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|i40e_eth_stats
modifier|*
name|vsi_stats
init|=
operator|&
name|vsi
operator|->
name|eth_stats
decl_stmt|;
name|struct
name|i40e_hw_port_stats
modifier|*
name|pf_stats
init|=
operator|&
name|pf
operator|->
name|stats
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|vsi_node
decl_stmt|,
modifier|*
name|queue_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|vsi_list
decl_stmt|,
modifier|*
name|queue_list
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
comment|/* Driver statistics */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"watchdog_events"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pf
operator|->
name|watchdog_events
argument_list|,
literal|"Watchdog timeouts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"admin_irq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pf
operator|->
name|admin_irq
argument_list|,
literal|"Admin Queue IRQ Handled"
argument_list|)
expr_stmt|;
comment|/* VSI statistics */
define|#
directive|define
name|QUEUE_NAME_LEN
value|32
name|char
name|queue_namebuf
index|[
name|QUEUE_NAME_LEN
index|]
decl_stmt|;
comment|// ERJ: Only one vsi now, re-do when>1 VSI enabled
comment|// snprintf(vsi_namebuf, QUEUE_NAME_LEN, "vsi%d", vsi->info.stat_counter_idx);
name|vsi_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"vsi"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"VSI-specific stats"
argument_list|)
expr_stmt|;
name|vsi_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|vsi_node
argument_list|)
expr_stmt|;
name|ixl_add_sysctls_eth_stats
argument_list|(
name|ctx
argument_list|,
name|vsi_list
argument_list|,
name|vsi_stats
argument_list|)
expr_stmt|;
comment|/* Queue statistics */
for|for
control|(
name|int
name|q
init|=
literal|0
init|;
name|q
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|q
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|queue_namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"que%d"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|vsi_list
argument_list|,
name|OID_AUTO
argument_list|,
name|queue_namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue #"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
name|txr
operator|=
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|txr
operator|)
expr_stmt|;
name|rxr
operator|=
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|rxr
operator|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_defrag_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|mbuf_defrag_failed
operator|)
argument_list|,
literal|"m_defrag() failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|dropped_pkts
operator|)
argument_list|,
literal|"Driver dropped packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"irqs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|irqs
operator|)
argument_list|,
literal|"irqs on this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso_tx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|tso
operator|)
argument_list|,
literal|"TSO"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_dma_setup"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|queues
index|[
name|q
index|]
operator|.
name|tx_dma_setup
operator|)
argument_list|,
literal|"Driver tx dma failure in xmit"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_desc_avail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|no_desc
operator|)
argument_list|,
literal|"Queue No Descriptor Available"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|total_packets
operator|)
argument_list|,
literal|"Queue Packets Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|txr
operator|->
name|tx_bytes
operator|)
argument_list|,
literal|"Queue Bytes Transmitted"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_packets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|rx_packets
operator|)
argument_list|,
literal|"Queue Packets Received"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_bytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|rxr
operator|->
name|rx_bytes
operator|)
argument_list|,
literal|"Queue Bytes Received"
argument_list|)
expr_stmt|;
block|}
comment|/* MAC stats */
name|ixl_add_sysctls_mac_stats
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|pf_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_add_sysctls_eth_stats
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
name|child
parameter_list|,
name|struct
name|i40e_eth_stats
modifier|*
name|eth_stats
parameter_list|)
block|{
name|struct
name|ixl_sysctl_info
name|ctls
index|[]
init|=
block|{
block|{
operator|&
name|eth_stats
operator|->
name|rx_bytes
block|,
literal|"good_octets_rcvd"
block|,
literal|"Good Octets Received"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|rx_unicast
block|,
literal|"ucast_pkts_rcvd"
block|,
literal|"Unicast Packets Received"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|rx_multicast
block|,
literal|"mcast_pkts_rcvd"
block|,
literal|"Multicast Packets Received"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|rx_broadcast
block|,
literal|"bcast_pkts_rcvd"
block|,
literal|"Broadcast Packets Received"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|rx_discards
block|,
literal|"rx_discards"
block|,
literal|"Discarded RX packets"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|tx_bytes
block|,
literal|"good_octets_txd"
block|,
literal|"Good Octets Transmitted"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|tx_unicast
block|,
literal|"ucast_pkts_txd"
block|,
literal|"Unicast Packets Transmitted"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|tx_multicast
block|,
literal|"mcast_pkts_txd"
block|,
literal|"Multicast Packets Transmitted"
block|}
block|,
block|{
operator|&
name|eth_stats
operator|->
name|tx_broadcast
block|,
literal|"bcast_pkts_txd"
block|,
literal|"Broadcast Packets Transmitted"
block|}
block|,
comment|// end
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|struct
name|ixl_sysctl_info
modifier|*
name|entry
init|=
name|ctls
decl_stmt|;
while|while
condition|(
name|entry
operator|->
name|stat
operator|!=
literal|0
condition|)
block|{
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|entry
operator|->
name|stat
argument_list|,
name|entry
operator|->
name|description
argument_list|)
expr_stmt|;
name|entry
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_add_sysctls_mac_stats
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
name|child
parameter_list|,
name|struct
name|i40e_hw_port_stats
modifier|*
name|stats
parameter_list|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|stat_node
init|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mac"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Mac Statistics"
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|stat_list
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|stat_node
argument_list|)
decl_stmt|;
name|struct
name|i40e_eth_stats
modifier|*
name|eth_stats
init|=
operator|&
name|stats
operator|->
name|eth
decl_stmt|;
name|ixl_add_sysctls_eth_stats
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|eth_stats
argument_list|)
expr_stmt|;
name|struct
name|ixl_sysctl_info
name|ctls
index|[]
init|=
block|{
block|{
operator|&
name|stats
operator|->
name|crc_errors
block|,
literal|"crc_errors"
block|,
literal|"CRC Errors"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|illegal_bytes
block|,
literal|"illegal_bytes"
block|,
literal|"Illegal Byte Errors"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|mac_local_faults
block|,
literal|"local_faults"
block|,
literal|"MAC Local Faults"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|mac_remote_faults
block|,
literal|"remote_faults"
block|,
literal|"MAC Remote Faults"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_length_errors
block|,
literal|"rx_length_errors"
block|,
literal|"Receive Length Errors"
block|}
block|,
comment|/* Packet Reception Stats */
block|{
operator|&
name|stats
operator|->
name|rx_size_64
block|,
literal|"rx_frames_64"
block|,
literal|"64 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_127
block|,
literal|"rx_frames_65_127"
block|,
literal|"65-127 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_255
block|,
literal|"rx_frames_128_255"
block|,
literal|"128-255 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_511
block|,
literal|"rx_frames_256_511"
block|,
literal|"256-511 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_1023
block|,
literal|"rx_frames_512_1023"
block|,
literal|"512-1023 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_1522
block|,
literal|"rx_frames_1024_1522"
block|,
literal|"1024-1522 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_size_big
block|,
literal|"rx_frames_big"
block|,
literal|"1523-9522 byte frames received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_undersize
block|,
literal|"rx_undersize"
block|,
literal|"Undersized packets received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_fragments
block|,
literal|"rx_fragmented"
block|,
literal|"Fragmented packets received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_oversize
block|,
literal|"rx_oversized"
block|,
literal|"Oversized packets received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|rx_jabber
block|,
literal|"rx_jabber"
block|,
literal|"Received Jabber"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|checksum_error
block|,
literal|"checksum_errors"
block|,
literal|"Checksum Errors"
block|}
block|,
comment|/* Packet Transmission Stats */
block|{
operator|&
name|stats
operator|->
name|tx_size_64
block|,
literal|"tx_frames_64"
block|,
literal|"64 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_127
block|,
literal|"tx_frames_65_127"
block|,
literal|"65-127 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_255
block|,
literal|"tx_frames_128_255"
block|,
literal|"128-255 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_511
block|,
literal|"tx_frames_256_511"
block|,
literal|"256-511 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_1023
block|,
literal|"tx_frames_512_1023"
block|,
literal|"512-1023 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_1522
block|,
literal|"tx_frames_1024_1522"
block|,
literal|"1024-1522 byte frames transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|tx_size_big
block|,
literal|"tx_frames_big"
block|,
literal|"1523-9522 byte frames transmitted"
block|}
block|,
comment|/* Flow control */
block|{
operator|&
name|stats
operator|->
name|link_xon_tx
block|,
literal|"xon_txd"
block|,
literal|"Link XON transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|link_xon_rx
block|,
literal|"xon_recvd"
block|,
literal|"Link XON received"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|link_xoff_tx
block|,
literal|"xoff_txd"
block|,
literal|"Link XOFF transmitted"
block|}
block|,
block|{
operator|&
name|stats
operator|->
name|link_xoff_rx
block|,
literal|"xoff_recvd"
block|,
literal|"Link XOFF received"
block|}
block|,
comment|/* End */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|struct
name|ixl_sysctl_info
modifier|*
name|entry
init|=
name|ctls
decl_stmt|;
while|while
condition|(
name|entry
operator|->
name|stat
operator|!=
literal|0
condition|)
block|{
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|entry
operator|->
name|stat
argument_list|,
name|entry
operator|->
name|description
argument_list|)
expr_stmt|;
name|entry
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** ixl_config_rss - setup RSS  **  - note this is done for the single vsi */
end_comment

begin_function
specifier|static
name|void
name|ixl_config_rss
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|u32
name|lut
init|=
literal|0
decl_stmt|;
name|u64
name|set_hena
init|=
literal|0
decl_stmt|,
name|hena
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|que_id
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|u32
name|rss_hash_config
decl_stmt|;
name|u32
name|rss_seed
index|[
name|IXL_KEYSZ
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|rss_seed
index|[
name|IXL_KEYSZ
index|]
init|=
block|{
literal|0x41b01687
block|,
literal|0x183cfd8c
block|,
literal|0xce880440
block|,
literal|0x580cbc3c
block|,
literal|0x35897377
block|,
literal|0x328b25e1
block|,
literal|0x4fa98922
block|,
literal|0xb7d90c14
block|,
literal|0xd5bad70d
block|,
literal|0xcd15a2c1
block|}
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RSS
comment|/* Fetch the configured RSS key */
name|rss_getkey
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|rss_seed
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fill out hash function seed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXL_KEYSZ
condition|;
name|i
operator|++
control|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HKEY
argument_list|(
name|i
argument_list|)
argument_list|,
name|rss_seed
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Enable PCTYPES for RSS: */
ifdef|#
directive|ifdef
name|RSS
name|rss_hash_config
operator|=
name|rss_gethashconfig
argument_list|()
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV4
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_OTHER
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV4
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_TCP
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV4
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_UDP
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV6
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_OTHER
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_IPV6_EX
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_FRAG_IPV6
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV6
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_TCP
operator|)
expr_stmt|;
if|if
condition|(
name|rss_hash_config
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV6
condition|)
name|set_hena
operator||=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_UDP
operator|)
expr_stmt|;
else|#
directive|else
name|set_hena
operator|=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_UDP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_TCP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_SCTP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV4_OTHER
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_FRAG_IPV4
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_UDP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_TCP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_SCTP
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_NONF_IPV6_OTHER
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_FRAG_IPV6
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|I40E_FILTER_PCTYPE_L2_PAYLOAD
operator|)
expr_stmt|;
endif|#
directive|endif
name|hena
operator|=
operator|(
name|u64
operator|)
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HENA
argument_list|(
literal|0
argument_list|)
argument_list|)
operator||
operator|(
operator|(
name|u64
operator|)
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HENA
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|hena
operator||=
name|set_hena
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HENA
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|u32
operator|)
name|hena
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HENA
argument_list|(
literal|1
argument_list|)
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|hena
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Populate the LUT with max no. of queues in round robin fashion */
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|pf
operator|->
name|hw
operator|.
name|func_caps
operator|.
name|rss_table_size
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|vsi
operator|->
name|num_queues
condition|)
name|j
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* 		 * Fetch the RSS bucket id for the given indirection entry. 		 * Cap it at the number of configured buckets (which is 		 * num_queues.) 		 */
name|que_id
operator|=
name|rss_get_indirection_to_bucket
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|que_id
operator|=
name|que_id
operator|%
name|vsi
operator|->
name|num_queues
expr_stmt|;
else|#
directive|else
name|que_id
operator|=
name|j
expr_stmt|;
endif|#
directive|endif
comment|/* lut = 4-byte sliding window of 4 lut entries */
name|lut
operator|=
operator|(
name|lut
operator|<<
literal|8
operator|)
operator||
operator|(
name|que_id
operator|&
operator|(
operator|(
literal|0x1
operator|<<
name|pf
operator|->
name|hw
operator|.
name|func_caps
operator|.
name|rss_table_entry_width
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* On i = 3, we have 4 entries in lut; write to the register */
if|if
condition|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFQF_HLUT
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
argument_list|,
name|lut
argument_list|)
expr_stmt|;
block|}
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine is run via an vlan config EVENT, ** it enables us to use the HW Filter table since ** we can get the vlan id. This just creates the ** entry in the soft version of the VFTA, init will ** repopulate the real table. */
end_comment

begin_function
specifier|static
name|void
name|ixl_register_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
operator|++
name|vsi
operator|->
name|num_vlans
expr_stmt|;
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|vtag
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine is run via an vlan ** unconfig EVENT, remove our entry ** in the soft vfta. */
end_comment

begin_function
specifier|static
name|void
name|ixl_unregister_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u16
name|vtag
parameter_list|)
block|{
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
operator|--
name|vsi
operator|->
name|num_vlans
expr_stmt|;
name|ixl_del_filter
argument_list|(
name|vsi
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|vtag
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine updates vlan filters, called by init ** it scans the filter table and then updates the hw ** after a soft reset. */
end_comment

begin_function
specifier|static
name|void
name|ixl_setup_vlan_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|;
if|if
condition|(
name|vsi
operator|->
name|num_vlans
operator|==
literal|0
condition|)
return|return;
comment|/* 	** Scan the filter list for vlan entries, 	** mark them for addition and then call 	** for the AQ update. 	*/
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_VLAN
condition|)
block|{
name|f
operator|->
name|flags
operator||=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"setup vlan: no filters found!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|flags
operator|=
name|IXL_FILTER_VLAN
expr_stmt|;
name|flags
operator||=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator|)
expr_stmt|;
name|ixl_add_hw_filters
argument_list|(
name|vsi
argument_list|,
name|flags
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** Initialize filter list and add filters that the hardware ** needs to know about. */
end_comment

begin_function
specifier|static
name|void
name|ixl_init_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
comment|/* Add broadcast address */
name|u8
name|bc
index|[
literal|6
index|]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|bc
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** This routine adds mulicast filters */
end_comment

begin_function
specifier|static
name|void
name|ixl_add_mc_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
comment|/* Does one already exist */
name|f
operator|=
name|ixl_find_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
return|return;
name|f
operator|=
name|ixl_get_filter
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: no filter available!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|macaddr
argument_list|,
name|f
operator|->
name|macaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|f
operator|->
name|vlan
operator|=
name|IXL_VLAN_ANY
expr_stmt|;
name|f
operator|->
name|flags
operator||=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator||
name|IXL_FILTER_MC
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** This routine adds macvlan filters */
end_comment

begin_function
specifier|static
name|void
name|ixl_add_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|,
name|s16
name|vlan
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ixl_add_filter: begin"
argument_list|)
expr_stmt|;
comment|/* Does one already exist */
name|f
operator|=
name|ixl_find_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|vlan
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
return|return;
comment|/* 	** Is this the first vlan being registered, if so we 	** need to remove the ANY filter that indicates we are 	** not in a vlan, and replace that with a 0 filter. 	*/
if|if
condition|(
operator|(
name|vlan
operator|!=
name|IXL_VLAN_ANY
operator|)
operator|&&
operator|(
name|vsi
operator|->
name|num_vlans
operator|==
literal|1
operator|)
condition|)
block|{
name|tmp
operator|=
name|ixl_find_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|ixl_del_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|f
operator|=
name|ixl_get_filter
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING: no filter available!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|macaddr
argument_list|,
name|f
operator|->
name|macaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|f
operator|->
name|vlan
operator|=
name|vlan
expr_stmt|;
name|f
operator|->
name|flags
operator||=
operator|(
name|IXL_FILTER_ADD
operator||
name|IXL_FILTER_USED
operator|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|vlan
operator|!=
name|IXL_VLAN_ANY
condition|)
name|f
operator|->
name|flags
operator||=
name|IXL_FILTER_VLAN
expr_stmt|;
name|ixl_add_hw_filters
argument_list|(
name|vsi
argument_list|,
name|f
operator|->
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_del_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|,
name|s16
name|vlan
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|ixl_find_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|vlan
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return;
name|f
operator|->
name|flags
operator||=
name|IXL_FILTER_DEL
expr_stmt|;
name|ixl_del_hw_filters
argument_list|(
name|vsi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check if this is the last vlan removal */
if|if
condition|(
name|vlan
operator|!=
name|IXL_VLAN_ANY
operator|&&
name|vsi
operator|->
name|num_vlans
operator|==
literal|0
condition|)
block|{
comment|/* Switch back to a non-vlan filter */
name|ixl_del_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ixl_add_filter
argument_list|(
name|vsi
argument_list|,
name|macaddr
argument_list|,
name|IXL_VLAN_ANY
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ** Find the filter with both matching mac addr and vlan id */
end_comment

begin_function
specifier|static
name|struct
name|ixl_mac_filter
modifier|*
name|ixl_find_filter
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|u8
modifier|*
name|macaddr
parameter_list|,
name|s16
name|vlan
parameter_list|)
block|{
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|bool
name|match
init|=
name|FALSE
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
operator|!
name|cmp_etheraddr
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|macaddr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|f
operator|->
name|vlan
operator|==
name|vlan
condition|)
block|{
name|match
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
name|f
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** This routine takes additions to the vsi filter ** table and creates an Admin Queue call to create ** the filters in the hardware. */
end_comment

begin_function
specifier|static
name|void
name|ixl_add_hw_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|struct
name|i40e_aqc_add_macvlan_element_data
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|a
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aqc_add_macvlan_element_data
argument_list|)
operator|*
name|cnt
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"add_hw_filters failed to get memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	** Scan the filter list, each time we find one 	** we add it to the admin queue array and turn off 	** the add bit. 	*/
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|f
operator|->
name|flags
operator|==
name|flags
condition|)
block|{
name|b
operator|=
operator|&
name|a
index|[
name|j
index|]
expr_stmt|;
comment|// a pox on fvl long names :)
name|bcopy
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|b
operator|->
name|mac_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|b
operator|->
name|vlan_tag
operator|=
operator|(
name|f
operator|->
name|vlan
operator|==
name|IXL_VLAN_ANY
condition|?
literal|0
else|:
name|f
operator|->
name|vlan
operator|)
expr_stmt|;
name|b
operator|->
name|flags
operator|=
name|I40E_AQC_MACVLAN_ADD_PERFECT_MATCH
expr_stmt|;
name|f
operator|->
name|flags
operator|&=
operator|~
name|IXL_FILTER_ADD
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
name|cnt
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|err
operator|=
name|i40e_aq_add_macvlan
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|a
argument_list|,
name|j
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"aq_add_macvlan err %d, aq_error %d\n"
argument_list|,
name|err
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
else|else
name|vsi
operator|->
name|hw_filters_add
operator|+=
name|j
expr_stmt|;
block|}
name|free
argument_list|(
name|a
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** This routine takes removals in the vsi filter ** table and creates an Admin Queue call to delete ** the filters in the hardware. */
end_comment

begin_function
specifier|static
name|void
name|ixl_del_hw_filters
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|struct
name|i40e_aqc_remove_macvlan_element_data
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|vsi
operator|->
name|dev
decl_stmt|;
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|,
modifier|*
name|f_temp
decl_stmt|;
name|int
name|err
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ixl_del_hw_filters: begin\n"
argument_list|)
expr_stmt|;
name|d
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aqc_remove_macvlan_element_data
argument_list|)
operator|*
name|cnt
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"del hw filter failed to get memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|SLIST_FOREACH_SAFE
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|,
argument|f_temp
argument_list|)
block|{
if|if
condition|(
name|f
operator|->
name|flags
operator|&
name|IXL_FILTER_DEL
condition|)
block|{
name|e
operator|=
operator|&
name|d
index|[
name|j
index|]
expr_stmt|;
comment|// a pox on fvl long names :)
name|bcopy
argument_list|(
name|f
operator|->
name|macaddr
argument_list|,
name|e
operator|->
name|mac_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|e
operator|->
name|vlan_tag
operator|=
operator|(
name|f
operator|->
name|vlan
operator|==
name|IXL_VLAN_ANY
condition|?
literal|0
else|:
name|f
operator|->
name|vlan
operator|)
expr_stmt|;
name|e
operator|->
name|flags
operator|=
name|I40E_AQC_MACVLAN_DEL_PERFECT_MATCH
expr_stmt|;
comment|/* delete entry from vsi list */
name|SLIST_REMOVE
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|,
name|f
argument_list|,
name|ixl_mac_filter
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
name|cnt
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|err
operator|=
name|i40e_aq_remove_macvlan
argument_list|(
name|hw
argument_list|,
name|vsi
operator|->
name|seid
argument_list|,
name|d
argument_list|,
name|j
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* NOTE: returns ENOENT every time but seems to work fine, 		   so we'll ignore that specific error. */
comment|// TODO: Does this still occur on current firmwares?
if|if
condition|(
name|err
operator|&&
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
operator|!=
name|I40E_AQ_RC_ENOENT
condition|)
block|{
name|int
name|sc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
name|sc
operator|+=
operator|(
operator|!
name|d
index|[
name|i
index|]
operator|.
name|error_code
operator|)
expr_stmt|;
name|vsi
operator|->
name|hw_filters_del
operator|+=
name|sc
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to remove %d/%d filters, aq error %d\n"
argument_list|,
name|j
operator|-
name|sc
argument_list|,
name|j
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
block|}
else|else
name|vsi
operator|->
name|hw_filters_del
operator|+=
name|j
expr_stmt|;
block|}
name|free
argument_list|(
name|d
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"ixl_del_hw_filters: end\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_enable_rings
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|i40e_pre_tx_queue_cfg
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_QTX_ENA_QENA_REQ_MASK
operator||
name|I40E_QTX_ENA_QENA_STAT_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Verify the enable took */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_QTX_ENA_QENA_STAT_MASK
condition|)
break|break;
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reg
operator|&
name|I40E_QTX_ENA_QENA_STAT_MASK
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"TX queue %d disabled!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_QRX_ENA_QENA_REQ_MASK
operator||
name|I40E_QRX_ENA_QENA_STAT_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Verify the enable took */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_QRX_ENA_QENA_STAT_MASK
condition|)
break|break;
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reg
operator|&
name|I40E_QRX_ENA_QENA_STAT_MASK
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"RX queue %d disabled!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_disable_rings
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|u32
name|reg
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|i40e_pre_tx_queue_cfg
argument_list|(
name|hw
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|i40e_usec_delay
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|I40E_QTX_ENA_QENA_REQ_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Verify the disable took */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QTX_ENA
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg
operator|&
name|I40E_QTX_ENA_QENA_STAT_MASK
operator|)
condition|)
break|break;
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_QTX_ENA_QENA_STAT_MASK
condition|)
name|printf
argument_list|(
literal|"TX queue %d still enabled!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|I40E_QRX_ENA_QENA_REQ_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Verify the disable took */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_QRX_ENA
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg
operator|&
name|I40E_QRX_ENA_QENA_STAT_MASK
operator|)
condition|)
break|break;
name|i40e_msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|&
name|I40E_QRX_ENA_QENA_STAT_MASK
condition|)
name|printf
argument_list|(
literal|"RX queue %d still enabled!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * ixl_handle_mdd_event  *  * Called from interrupt handler to identify possibly malicious vfs  * (But also detects events from the PF, as well)  **/
end_comment

begin_function
specifier|static
name|void
name|ixl_handle_mdd_event
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|bool
name|mdd_detected
init|=
name|false
decl_stmt|;
name|bool
name|pf_mdd_detected
init|=
name|false
decl_stmt|;
name|u32
name|reg
decl_stmt|;
comment|/* find what triggered the MDD event */
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GL_MDET_TX
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_GL_MDET_TX_VALID_MASK
condition|)
block|{
name|u8
name|pf_num
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_TX_PF_NUM_MASK
operator|)
operator|>>
name|I40E_GL_MDET_TX_PF_NUM_SHIFT
decl_stmt|;
name|u8
name|event
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_TX_EVENT_MASK
operator|)
operator|>>
name|I40E_GL_MDET_TX_EVENT_SHIFT
decl_stmt|;
name|u8
name|queue
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_TX_QUEUE_MASK
operator|)
operator|>>
name|I40E_GL_MDET_TX_QUEUE_SHIFT
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Malicious Driver Detection event 0x%02x"
literal|" on TX queue %d pf number 0x%02x\n"
argument_list|,
name|event
argument_list|,
name|queue
argument_list|,
name|pf_num
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GL_MDET_TX
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|mdd_detected
operator|=
name|true
expr_stmt|;
block|}
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GL_MDET_RX
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_GL_MDET_RX_VALID_MASK
condition|)
block|{
name|u8
name|func
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_RX_FUNCTION_MASK
operator|)
operator|>>
name|I40E_GL_MDET_RX_FUNCTION_SHIFT
decl_stmt|;
name|u8
name|event
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_RX_EVENT_MASK
operator|)
operator|>>
name|I40E_GL_MDET_RX_EVENT_SHIFT
decl_stmt|;
name|u8
name|queue
init|=
operator|(
name|reg
operator|&
name|I40E_GL_MDET_RX_QUEUE_MASK
operator|)
operator|>>
name|I40E_GL_MDET_RX_QUEUE_SHIFT
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Malicious Driver Detection event 0x%02x"
literal|" on RX queue %d of function 0x%02x\n"
argument_list|,
name|event
argument_list|,
name|queue
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GL_MDET_RX
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|mdd_detected
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|mdd_detected
condition|)
block|{
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_MDET_TX
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_PF_MDET_TX_VALID_MASK
condition|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_MDET_TX
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MDD TX event is for this function 0x%08x"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|pf_mdd_detected
operator|=
name|true
expr_stmt|;
block|}
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_MDET_RX
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|I40E_PF_MDET_RX_VALID_MASK
condition|)
block|{
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PF_MDET_RX
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MDD RX event is for this function 0x%08x"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|pf_mdd_detected
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* re-enable mdd interrupt cause */
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_PFINT_ICR0_ENA_MAL_DETECT_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_enable_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
if|if
condition|(
name|ixl_enable_msix
condition|)
block|{
name|ixl_enable_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
name|ixl_enable_queue
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
block|}
else|else
name|ixl_enable_legacy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_disable_intr
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
name|vsi
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
if|if
condition|(
name|ixl_enable_msix
condition|)
block|{
name|ixl_disable_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|que
operator|++
control|)
name|ixl_disable_queue
argument_list|(
name|hw
argument_list|,
name|que
operator|->
name|me
argument_list|)
expr_stmt|;
block|}
else|else
name|ixl_disable_legacy
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_enable_adminq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|I40E_PFINT_DYN_CTL0_INTENA_MASK
operator||
name|I40E_PFINT_DYN_CTL0_CLEARPBA_MASK
operator||
operator|(
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTL0_ITR_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ixl_flush
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_disable_adminq
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTL0_ITR_INDX_SHIFT
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_enable_queue
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|I40E_PFINT_DYN_CTLN_INTENA_MASK
operator||
name|I40E_PFINT_DYN_CTLN_CLEARPBA_MASK
operator||
operator|(
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTLN_ITR_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTLN
argument_list|(
name|id
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_disable_queue
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTLN_ITR_INDX_SHIFT
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTLN
argument_list|(
name|id
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_enable_legacy
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|I40E_PFINT_DYN_CTL0_INTENA_MASK
operator||
name|I40E_PFINT_DYN_CTL0_CLEARPBA_MASK
operator||
operator|(
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTL0_ITR_INDX_SHIFT
operator|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_disable_legacy
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|reg
decl_stmt|;
name|reg
operator|=
name|IXL_ITR_NONE
operator|<<
name|I40E_PFINT_DYN_CTL0_ITR_INDX_SHIFT
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_DYN_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_update_stats_counters
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_hw_port_stats
modifier|*
name|nsd
init|=
operator|&
name|pf
operator|->
name|stats
decl_stmt|;
name|struct
name|i40e_hw_port_stats
modifier|*
name|osd
init|=
operator|&
name|pf
operator|->
name|stats_offsets
decl_stmt|;
comment|/* Update hw stats */
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_CRCERRS
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|crc_errors
argument_list|,
operator|&
name|nsd
operator|->
name|crc_errors
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_ILLERRC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|illegal_bytes
argument_list|,
operator|&
name|nsd
operator|->
name|illegal_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_GORCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_GORCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_bytes
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_GOTCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_GOTCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|tx_bytes
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|tx_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RDPC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_discards
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_discards
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_UPRCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_UPRCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_unicast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_unicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_UPTCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_UPTCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|tx_unicast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|tx_unicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MPRCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_MPRCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_multicast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_multicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MPTCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_MPTCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|tx_multicast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|tx_multicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_BPRCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_BPRCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|rx_broadcast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|rx_broadcast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_BPTCH
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_BPTCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|eth
operator|.
name|tx_broadcast
argument_list|,
operator|&
name|nsd
operator|->
name|eth
operator|.
name|tx_broadcast
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_TDOLD
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_dropped_link_down
argument_list|,
operator|&
name|nsd
operator|->
name|tx_dropped_link_down
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MLFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|mac_local_faults
argument_list|,
operator|&
name|nsd
operator|->
name|mac_local_faults
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MRFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|mac_remote_faults
argument_list|,
operator|&
name|nsd
operator|->
name|mac_remote_faults
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RLEC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_length_errors
argument_list|,
operator|&
name|nsd
operator|->
name|rx_length_errors
argument_list|)
expr_stmt|;
comment|/* Flow control (LFC) stats */
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_LXONRXC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|link_xon_rx
argument_list|,
operator|&
name|nsd
operator|->
name|link_xon_rx
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_LXONTXC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|link_xon_tx
argument_list|,
operator|&
name|nsd
operator|->
name|link_xon_tx
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_LXOFFRXC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|link_xoff_rx
argument_list|,
operator|&
name|nsd
operator|->
name|link_xoff_rx
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_LXOFFTXC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|link_xoff_tx
argument_list|,
operator|&
name|nsd
operator|->
name|link_xoff_tx
argument_list|)
expr_stmt|;
comment|/* Packet size stats rx */
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC64H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC64L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_64
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_64
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC127H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC127L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_127
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_127
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC255H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC255L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_255
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_255
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC511H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC511L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_511
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_511
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC1023H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC1023L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_1023
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_1023
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC1522H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC1522L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_1522
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_1522
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PRC9522H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PRC9522L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_size_big
argument_list|,
operator|&
name|nsd
operator|->
name|rx_size_big
argument_list|)
expr_stmt|;
comment|/* Packet size stats tx */
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC64H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC64L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_64
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_64
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC127H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC127L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_127
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_127
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC255H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC255L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_255
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_255
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC511H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC511L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_511
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_511
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC1023H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC1023L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_1023
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_1023
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC1522H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC1522L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_1522
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_1522
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_PTC9522H
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|I40E_GLPRT_PTC9522L
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|tx_size_big
argument_list|,
operator|&
name|nsd
operator|->
name|tx_size_big
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RUC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_undersize
argument_list|,
operator|&
name|nsd
operator|->
name|rx_undersize
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_fragments
argument_list|,
operator|&
name|nsd
operator|->
name|rx_fragments
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_ROC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_oversize
argument_list|,
operator|&
name|nsd
operator|->
name|rx_oversize
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RJC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|,
name|pf
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|osd
operator|->
name|rx_jabber
argument_list|,
operator|&
name|nsd
operator|->
name|rx_jabber
argument_list|)
expr_stmt|;
name|pf
operator|->
name|stat_offsets_loaded
operator|=
name|true
expr_stmt|;
comment|/* End hw stats */
comment|/* Update vsi stats */
name|ixl_update_eth_stats
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* OS statistics */
comment|// ERJ - these are per-port, update all vsis?
name|IXL_SET_IERRORS
argument_list|(
name|vsi
argument_list|,
name|nsd
operator|->
name|crc_errors
operator|+
name|nsd
operator|->
name|illegal_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Tasklet handler for MSIX Adminq interrupts **  - do outside interrupt since it might sleep */
end_comment

begin_function
specifier|static
name|void
name|ixl_do_adminq
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|context
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|i40e_arq_event_info
name|event
decl_stmt|;
name|i40e_status
name|ret
decl_stmt|;
name|u32
name|reg
decl_stmt|,
name|loop
init|=
literal|0
decl_stmt|;
name|u16
name|opcode
decl_stmt|,
name|result
decl_stmt|;
name|event
operator|.
name|buf_len
operator|=
name|IXL_AQ_BUF_SZ
expr_stmt|;
name|event
operator|.
name|msg_buf
operator|=
name|malloc
argument_list|(
name|event
operator|.
name|buf_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event
operator|.
name|msg_buf
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to allocate adminq memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* clean and process any events */
do|do
block|{
name|ret
operator|=
name|i40e_clean_arq_element
argument_list|(
name|hw
argument_list|,
operator|&
name|event
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
name|opcode
operator|=
name|LE16_TO_CPU
argument_list|(
name|event
operator|.
name|desc
operator|.
name|opcode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|i40e_aqc_opc_get_link_status
case|:
name|vsi
operator|->
name|link_up
operator|=
name|ixl_config_link
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixl_update_link_status
argument_list|(
name|pf
argument_list|)
expr_stmt|;
break|break;
case|case
name|i40e_aqc_opc_send_msg_to_pf
case|:
comment|/* process pf/vf communication here */
break|break;
case|case
name|i40e_aqc_opc_event_lan_overflow
case|:
break|break;
default|default:
ifdef|#
directive|ifdef
name|IXL_DEBUG
name|printf
argument_list|(
literal|"AdminQ unknown event %x\n"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
do|while
condition|(
name|result
operator|&&
operator|(
name|loop
operator|++
operator|<
name|IXL_ADM_LIMIT
operator|)
condition|)
do|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|)
expr_stmt|;
name|reg
operator||=
name|I40E_PFINT_ICR0_ENA_ADMINQ_MASK
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_PFINT_ICR0_ENA
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|event
operator|.
name|msg_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|msix
operator|>
literal|1
condition|)
name|ixl_enable_adminq
argument_list|(
operator|&
name|pf
operator|->
name|hw
argument_list|)
expr_stmt|;
else|else
name|ixl_enable_intr
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_debug_info
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|input
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|input
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|input
operator|==
literal|1
condition|)
block|{
name|pf
operator|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
expr_stmt|;
name|ixl_print_debug_info
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixl_print_debug_info
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|vsi
operator|->
name|queues
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
operator|&
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
name|que
operator|->
name|txr
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|printf
argument_list|(
literal|"Queue irqs = %jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|que
operator|->
name|irqs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"AdminQ irqs = %jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pf
operator|->
name|admin_irq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX next check = %x\n"
argument_list|,
name|rxr
operator|->
name|next_check
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX not ready = %jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rxr
operator|->
name|not_done
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX packets = %jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rxr
operator|->
name|rx_packets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TX desc avail = %x\n"
argument_list|,
name|txr
operator|->
name|avail
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_GORCL
argument_list|(
literal|0xc
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX Bytes = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_GORCL
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Port RX Bytes = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_RDPC
argument_list|(
literal|0xc
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX discard = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RDPC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Port RX discard = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_TEPC
argument_list|(
literal|0xc
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TX errors = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_GOTCL
argument_list|(
literal|0xc
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TX Bytes = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RUC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX undersize = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX fragments = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_ROC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX oversize = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_RLEC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RX length error = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MRFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mac remote fault = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLPRT_MLFC
argument_list|(
name|hw
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mac local fault = %x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Update VSI-specific ethernet statistics counters.  **/
end_comment

begin_function
name|void
name|ixl_update_eth_stats
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|vsi
operator|->
name|back
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_eth_stats
modifier|*
name|es
decl_stmt|;
name|struct
name|i40e_eth_stats
modifier|*
name|oes
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|tx_discards
decl_stmt|;
name|struct
name|i40e_hw_port_stats
modifier|*
name|nsd
decl_stmt|;
name|u16
name|stat_idx
init|=
name|vsi
operator|->
name|info
operator|.
name|stat_counter_idx
decl_stmt|;
name|es
operator|=
operator|&
name|vsi
operator|->
name|eth_stats
expr_stmt|;
name|oes
operator|=
operator|&
name|vsi
operator|->
name|eth_stats_offsets
expr_stmt|;
name|nsd
operator|=
operator|&
name|pf
operator|->
name|stats
expr_stmt|;
comment|/* Gather up the stats that the hw collects */
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_TEPC
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_errors
argument_list|,
operator|&
name|es
operator|->
name|tx_errors
argument_list|)
expr_stmt|;
name|ixl_stat_update32
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_RDPC
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_discards
argument_list|,
operator|&
name|es
operator|->
name|rx_discards
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_GORCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_GORCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_bytes
argument_list|,
operator|&
name|es
operator|->
name|rx_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_UPRCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_UPRCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_unicast
argument_list|,
operator|&
name|es
operator|->
name|rx_unicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_MPRCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_MPRCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_multicast
argument_list|,
operator|&
name|es
operator|->
name|rx_multicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_BPRCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_BPRCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|rx_broadcast
argument_list|,
operator|&
name|es
operator|->
name|rx_broadcast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_GOTCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_GOTCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_bytes
argument_list|,
operator|&
name|es
operator|->
name|tx_bytes
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_UPTCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_UPTCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_unicast
argument_list|,
operator|&
name|es
operator|->
name|tx_unicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_MPTCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_MPTCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_multicast
argument_list|,
operator|&
name|es
operator|->
name|tx_multicast
argument_list|)
expr_stmt|;
name|ixl_stat_update48
argument_list|(
name|hw
argument_list|,
name|I40E_GLV_BPTCH
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|I40E_GLV_BPTCL
argument_list|(
name|stat_idx
argument_list|)
argument_list|,
name|vsi
operator|->
name|stat_offsets_loaded
argument_list|,
operator|&
name|oes
operator|->
name|tx_broadcast
argument_list|,
operator|&
name|es
operator|->
name|tx_broadcast
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|stat_offsets_loaded
operator|=
name|true
expr_stmt|;
name|tx_discards
operator|=
name|es
operator|->
name|tx_discards
operator|+
name|nsd
operator|->
name|tx_dropped_link_down
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vsi
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|tx_discards
operator|+=
name|vsi
operator|->
name|queues
index|[
name|i
index|]
operator|.
name|txr
operator|.
name|br
operator|->
name|br_drops
expr_stmt|;
comment|/* Update ifnet stats */
name|IXL_SET_IPACKETS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_unicast
operator|+
name|es
operator|->
name|rx_multicast
operator|+
name|es
operator|->
name|rx_broadcast
argument_list|)
expr_stmt|;
name|IXL_SET_OPACKETS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|tx_unicast
operator|+
name|es
operator|->
name|tx_multicast
operator|+
name|es
operator|->
name|tx_broadcast
argument_list|)
expr_stmt|;
name|IXL_SET_IBYTES
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_bytes
argument_list|)
expr_stmt|;
name|IXL_SET_OBYTES
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|tx_bytes
argument_list|)
expr_stmt|;
name|IXL_SET_IMCASTS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_multicast
argument_list|)
expr_stmt|;
name|IXL_SET_OMCASTS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|tx_multicast
argument_list|)
expr_stmt|;
name|IXL_SET_OERRORS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|tx_errors
argument_list|)
expr_stmt|;
name|IXL_SET_IQDROPS
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_discards
operator|+
name|nsd
operator|->
name|eth
operator|.
name|rx_discards
argument_list|)
expr_stmt|;
name|IXL_SET_OQDROPS
argument_list|(
name|vsi
argument_list|,
name|tx_discards
argument_list|)
expr_stmt|;
name|IXL_SET_NOPROTO
argument_list|(
name|vsi
argument_list|,
name|es
operator|->
name|rx_unknown_protocol
argument_list|)
expr_stmt|;
name|IXL_SET_COLLISIONS
argument_list|(
name|vsi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Reset all of the stats for the given pf  **/
end_comment

begin_function
name|void
name|ixl_pf_reset_stats
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|pf
operator|->
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hw_port_stats
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pf
operator|->
name|stats_offsets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hw_port_stats
argument_list|)
argument_list|)
expr_stmt|;
name|pf
operator|->
name|stat_offsets_loaded
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Resets all stats of the given vsi  **/
end_comment

begin_function
name|void
name|ixl_vsi_reset_stats
parameter_list|(
name|struct
name|ixl_vsi
modifier|*
name|vsi
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|vsi
operator|->
name|eth_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_eth_stats
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|vsi
operator|->
name|eth_stats_offsets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_eth_stats
argument_list|)
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|stat_offsets_loaded
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read and update a 48 bit stat from the hw  *  * Since the device stats are not reset at PFReset, they likely will not  * be zeroed when the driver starts.  We'll save the first values read  * and use them as offsets to be subtracted from the raw values in order  * to report stats that count from zero.  **/
end_comment

begin_function
specifier|static
name|void
name|ixl_stat_update48
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|hireg
parameter_list|,
name|u32
name|loreg
parameter_list|,
name|bool
name|offset_loaded
parameter_list|,
name|u64
modifier|*
name|offset
parameter_list|,
name|u64
modifier|*
name|stat
parameter_list|)
block|{
name|u64
name|new_data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|>=
literal|1000000
operator|)
operator|&&
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|new_data
operator|=
name|rd64
argument_list|(
name|hw
argument_list|,
name|loreg
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Use two rd32's instead of one rd64; FreeBSD versions before 	 * 10 don't support 8 byte bus reads/writes. 	 */
name|new_data
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|loreg
argument_list|)
expr_stmt|;
name|new_data
operator||=
operator|(
call|(
name|u64
call|)
argument_list|(
name|rd32
argument_list|(
name|hw
argument_list|,
name|hireg
argument_list|)
operator|&
literal|0xFFFF
argument_list|)
operator|)
operator|<<
literal|32
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|offset_loaded
condition|)
operator|*
name|offset
operator|=
name|new_data
expr_stmt|;
if|if
condition|(
name|new_data
operator|>=
operator|*
name|offset
condition|)
operator|*
name|stat
operator|=
name|new_data
operator|-
operator|*
name|offset
expr_stmt|;
else|else
operator|*
name|stat
operator|=
operator|(
name|new_data
operator|+
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
literal|48
operator|)
operator|)
operator|-
operator|*
name|offset
expr_stmt|;
operator|*
name|stat
operator|&=
literal|0xFFFFFFFFFFFFULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read and update a 32 bit stat from the hw  **/
end_comment

begin_function
specifier|static
name|void
name|ixl_stat_update32
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|bool
name|offset_loaded
parameter_list|,
name|u64
modifier|*
name|offset
parameter_list|,
name|u64
modifier|*
name|stat
parameter_list|)
block|{
name|u32
name|new_data
decl_stmt|;
name|new_data
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|offset_loaded
condition|)
operator|*
name|offset
operator|=
name|new_data
expr_stmt|;
if|if
condition|(
name|new_data
operator|>=
operator|*
name|offset
condition|)
operator|*
name|stat
operator|=
call|(
name|u32
call|)
argument_list|(
name|new_data
operator|-
operator|*
name|offset
argument_list|)
expr_stmt|;
else|else
operator|*
name|stat
operator|=
call|(
name|u32
call|)
argument_list|(
operator|(
name|new_data
operator|+
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
literal|32
operator|)
operator|)
operator|-
operator|*
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Set flow control using sysctl: ** 	0 - off **	1 - rx pause **	2 - tx pause **	3 - full */
end_comment

begin_function
specifier|static
name|int
name|ixl_set_flowcntl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
comment|/* 	 * TODO: ensure flow control is disabled if 	 * priority flow control is enabled 	 * 	 * TODO: ensure tx CRC by hardware should be enabled 	 * if tx flow control is enabled. 	 */
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|requested_fc
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|enum
name|i40e_status_code
name|aq_error
init|=
literal|0
decl_stmt|;
name|u8
name|fc_aq_err
init|=
literal|0
decl_stmt|;
name|aq_error
operator|=
name|i40e_aq_get_link_info
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Error retrieving link info from aq, %d\n"
argument_list|,
name|__func__
argument_list|,
name|aq_error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
comment|/* Read in new mode */
name|requested_fc
operator|=
name|hw
operator|->
name|fc
operator|.
name|current_mode
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|requested_fc
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|requested_fc
operator|<
literal|0
operator|||
name|requested_fc
operator|>
literal|3
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid fc mode; valid modes are 0 through 3\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	** Changing flow control mode currently does not work on 	** 40GBASE-CR4 PHYs 	*/
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|phy_type
operator|==
name|I40E_PHY_TYPE_40GBASE_CR4
operator|||
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|phy_type
operator|==
name|I40E_PHY_TYPE_40GBASE_CR4_CU
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Changing flow control mode unsupported"
literal|" on 40GBase-CR4 media.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Set fc ability for port */
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|requested_fc
expr_stmt|;
name|aq_error
operator|=
name|i40e_set_fc
argument_list|(
name|hw
argument_list|,
operator|&
name|fc_aq_err
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Error setting new fc mode %d; fc_err %#x\n"
argument_list|,
name|__func__
argument_list|,
name|aq_error
argument_list|,
name|fc_aq_err
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
if|if
condition|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|!=
name|hw
operator|->
name|fc
operator|.
name|requested_mode
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: FC set failure:\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Current: %s / Requested: %s\n"
argument_list|,
name|__func__
argument_list|,
name|ixl_fc_string
index|[
name|hw
operator|->
name|fc
operator|.
name|current_mode
index|]
argument_list|,
name|ixl_fc_string
index|[
name|hw
operator|->
name|fc
operator|.
name|requested_mode
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_current_speed
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|speeds
index|[]
init|=
block|{
literal|"Unknown"
block|,
literal|"100M"
block|,
literal|"1G"
block|,
literal|"10G"
block|,
literal|"40G"
block|,
literal|"20G"
block|}
decl_stmt|;
name|ixl_update_link_status
argument_list|(
name|pf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|link_info
operator|.
name|link_speed
condition|)
block|{
case|case
name|I40E_LINK_SPEED_100MB
case|:
name|index
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_1GB
case|:
name|index
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_10GB
case|:
name|index
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_40GB
case|:
name|index
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_20GB
case|:
name|index
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|I40E_LINK_SPEED_UNKNOWN
case|:
default|default:
name|index
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|speeds
index|[
name|index
index|]
argument_list|,
name|strlen
argument_list|(
name|speeds
index|[
name|index
index|]
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_set_advertised_speeds
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|,
name|int
name|speeds
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities
decl_stmt|;
name|struct
name|i40e_aq_set_phy_config
name|config
decl_stmt|;
name|enum
name|i40e_status_code
name|aq_error
init|=
literal|0
decl_stmt|;
comment|/* Get current capability information */
name|aq_error
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|abilities
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Error getting phy capabilities %d,"
literal|" aq error: %d\n"
argument_list|,
name|__func__
argument_list|,
name|aq_error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
comment|/* Prepare new config */
name|bzero
argument_list|(
operator|&
name|config
argument_list|,
sizeof|sizeof
argument_list|(
name|config
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|.
name|phy_type
operator|=
name|abilities
operator|.
name|phy_type
expr_stmt|;
name|config
operator|.
name|abilities
operator|=
name|abilities
operator|.
name|abilities
operator||
name|I40E_AQ_PHY_ENABLE_ATOMIC_LINK
expr_stmt|;
name|config
operator|.
name|eee_capability
operator|=
name|abilities
operator|.
name|eee_capability
expr_stmt|;
name|config
operator|.
name|eeer
operator|=
name|abilities
operator|.
name|eeer_val
expr_stmt|;
name|config
operator|.
name|low_power_ctrl
operator|=
name|abilities
operator|.
name|d3_lpan
expr_stmt|;
comment|/* Translate into aq cmd link_speed */
if|if
condition|(
name|speeds
operator|&
literal|0x4
condition|)
name|config
operator|.
name|link_speed
operator||=
name|I40E_LINK_SPEED_10GB
expr_stmt|;
if|if
condition|(
name|speeds
operator|&
literal|0x2
condition|)
name|config
operator|.
name|link_speed
operator||=
name|I40E_LINK_SPEED_1GB
expr_stmt|;
if|if
condition|(
name|speeds
operator|&
literal|0x1
condition|)
name|config
operator|.
name|link_speed
operator||=
name|I40E_LINK_SPEED_100MB
expr_stmt|;
comment|/* Do aq command& restart link */
name|aq_error
operator|=
name|i40e_aq_set_phy_config
argument_list|(
name|hw
argument_list|,
operator|&
name|config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: Error setting new phy config %d,"
literal|" aq error: %d\n"
argument_list|,
name|__func__
argument_list|,
name|aq_error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
comment|/* 	** This seems a bit heavy handed, but we 	** need to get a reinit on some devices 	*/
name|IXL_PF_LOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_stop
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_init_locked
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|IXL_PF_UNLOCK
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Control link advertise speed: **	Flags: **	0x1 - advertise 100 Mb **	0x2 - advertise 1G **	0x4 - advertise 10G ** ** Does not work on 40G devices. */
end_comment

begin_function
specifier|static
name|int
name|ixl_set_advertise
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|requested_ls
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	** FW doesn't support changing advertised speed 	** for 40G devices; speed is always 40G. 	*/
if|if
condition|(
name|i40e_is_40G_device
argument_list|(
name|hw
operator|->
name|device_id
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Read in new mode */
name|requested_ls
operator|=
name|pf
operator|->
name|advertised_speed
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|requested_ls
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|requested_ls
operator|<
literal|1
operator|||
name|requested_ls
operator|>
literal|7
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid advertised speed; valid modes are 0x1 through 0x7\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Exit if no change */
if|if
condition|(
name|pf
operator|->
name|advertised_speed
operator|==
name|requested_ls
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|ixl_set_advertised_speeds
argument_list|(
name|pf
argument_list|,
name|requested_ls
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pf
operator|->
name|advertised_speed
operator|=
name|requested_ls
expr_stmt|;
name|ixl_update_link_status
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Get the width and transaction speed of ** the bus this adapter is plugged into. */
end_comment

begin_function
specifier|static
name|u16
name|ixl_get_bus_info
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|u16
name|link
decl_stmt|;
name|u32
name|offset
decl_stmt|;
comment|/* Get the PCI Express Capabilities offset */
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
comment|/* ...and read the Link Status Register */
name|link
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|offset
operator|+
name|PCIER_LINK_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|link
operator|&
name|I40E_PCI_LINK_WIDTH
condition|)
block|{
case|case
name|I40E_PCI_LINK_WIDTH_1
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|i40e_bus_width_pcie_x1
expr_stmt|;
break|break;
case|case
name|I40E_PCI_LINK_WIDTH_2
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|i40e_bus_width_pcie_x2
expr_stmt|;
break|break;
case|case
name|I40E_PCI_LINK_WIDTH_4
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|i40e_bus_width_pcie_x4
expr_stmt|;
break|break;
case|case
name|I40E_PCI_LINK_WIDTH_8
case|:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|i40e_bus_width_pcie_x8
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus
operator|.
name|width
operator|=
name|i40e_bus_width_unknown
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|link
operator|&
name|I40E_PCI_LINK_SPEED
condition|)
block|{
case|case
name|I40E_PCI_LINK_SPEED_2500
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|i40e_bus_speed_2500
expr_stmt|;
break|break;
case|case
name|I40E_PCI_LINK_SPEED_5000
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|i40e_bus_speed_5000
expr_stmt|;
break|break;
case|case
name|I40E_PCI_LINK_SPEED_8000
case|:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|i40e_bus_speed_8000
expr_stmt|;
break|break;
default|default:
name|hw
operator|->
name|bus
operator|.
name|speed
operator|=
name|i40e_bus_speed_unknown
expr_stmt|;
break|break;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI Express Bus: Speed %s %s\n"
argument_list|,
operator|(
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|i40e_bus_speed_8000
operator|)
condition|?
literal|"8.0GT/s"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|i40e_bus_speed_5000
operator|)
condition|?
literal|"5.0GT/s"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|==
name|i40e_bus_speed_2500
operator|)
condition|?
literal|"2.5GT/s"
else|:
literal|"Unknown"
operator|)
argument_list|,
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|i40e_bus_width_pcie_x8
operator|)
condition|?
literal|"Width x8"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|i40e_bus_width_pcie_x4
operator|)
condition|?
literal|"Width x4"
else|:
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|==
name|i40e_bus_width_pcie_x1
operator|)
condition|?
literal|"Width x1"
else|:
operator|(
literal|"Unknown"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|bus
operator|.
name|width
operator|<=
name|i40e_bus_width_pcie_x8
operator|)
operator|&&
operator|(
name|hw
operator|->
name|bus
operator|.
name|speed
operator|<
name|i40e_bus_speed_8000
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI-Express bandwidth available"
literal|" for this device\n     is not sufficient for"
literal|" normal operation.\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"For expected performance a x8 "
literal|"PCIE Gen3 slot is required.\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|link
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_show_fw
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"f%d.%d a%d.%d n%02x.%02x e%08x"
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|fw_maj_ver
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|fw_min_ver
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|api_maj_ver
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|api_min_ver
argument_list|,
operator|(
name|hw
operator|->
name|nvm
operator|.
name|version
operator|&
name|IXL_NVM_VERSION_HI_MASK
operator|)
operator|>>
name|IXL_NVM_VERSION_HI_SHIFT
argument_list|,
operator|(
name|hw
operator|->
name|nvm
operator|.
name|version
operator|&
name|IXL_NVM_VERSION_LO_MASK
operator|)
operator|>>
name|IXL_NVM_VERSION_LO_SHIFT
argument_list|,
name|hw
operator|->
name|nvm
operator|.
name|eetrack
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_DEBUG_SYSCTL
end_ifdef

begin_function
specifier|static
name|int
name|ixl_sysctl_link_status
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_link_status
name|link_status
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|enum
name|i40e_status_code
name|aq_error
init|=
literal|0
decl_stmt|;
name|aq_error
operator|=
name|i40e_aq_get_link_info
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
operator|&
name|link_status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
name|printf
argument_list|(
literal|"i40e_aq_get_link_info() error %d\n"
argument_list|,
name|aq_error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n"
literal|"PHY Type : %#04x\n"
literal|"Speed    : %#04x\n"
literal|"Link info: %#04x\n"
literal|"AN info  : %#04x\n"
literal|"Ext info : %#04x"
argument_list|,
name|link_status
operator|.
name|phy_type
argument_list|,
name|link_status
operator|.
name|link_speed
argument_list|,
name|link_status
operator|.
name|link_info
argument_list|,
name|link_status
operator|.
name|an_info
argument_list|,
name|link_status
operator|.
name|ext_info
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_phy_abilities
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|i40e_aq_get_phy_abilities_resp
name|abilities_resp
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|enum
name|i40e_status_code
name|aq_error
init|=
literal|0
decl_stmt|;
comment|// TODO: Print out list of qualified modules as well?
name|aq_error
operator|=
name|i40e_aq_get_phy_capabilities
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|abilities_resp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aq_error
condition|)
block|{
name|printf
argument_list|(
literal|"i40e_aq_get_phy_capabilities() error %d\n"
argument_list|,
name|aq_error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n"
literal|"PHY Type : %#010x\n"
literal|"Speed    : %#04x\n"
literal|"Abilities: %#04x\n"
literal|"EEE cap  : %#06x\n"
literal|"EEER reg : %#010x\n"
literal|"D3 Lpan  : %#04x"
argument_list|,
name|abilities_resp
operator|.
name|phy_type
argument_list|,
name|abilities_resp
operator|.
name|link_speed
argument_list|,
name|abilities_resp
operator|.
name|abilities
argument_list|,
name|abilities_resp
operator|.
name|eee_capability
argument_list|,
name|abilities_resp
operator|.
name|eeer_val
argument_list|,
name|abilities_resp
operator|.
name|d3_lpan
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_sw_filter_list
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|struct
name|ixl_mac_filter
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|buf_i
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|ftl_len
init|=
literal|0
decl_stmt|;
name|int
name|ftl_counter
init|=
literal|0
decl_stmt|;
name|int
name|buf_len
init|=
literal|0
decl_stmt|;
name|int
name|entry_len
init|=
literal|42
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
name|ftl_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ftl_len
operator|<
literal|1
condition|)
block|{
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
literal|"(none)"
argument_list|,
literal|6
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|buf_len
operator|=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|entry_len
operator|+
literal|1
operator|)
operator|*
name|ftl_len
operator|+
literal|2
expr_stmt|;
name|buf
operator|=
name|buf_i
operator|=
name|malloc
argument_list|(
name|buf_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf_i
operator|++
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&vsi->ftl
argument_list|,
argument|next
argument_list|)
block|{
name|sprintf
argument_list|(
name|buf_i
argument_list|,
name|MAC_FORMAT
literal|", vlan %4d, flags %#06x"
argument_list|,
name|MAC_FORMAT_ARGS
argument_list|(
name|f
operator|->
name|macaddr
argument_list|)
argument_list|,
name|f
operator|->
name|vlan
argument_list|,
name|f
operator|->
name|flags
argument_list|)
expr_stmt|;
name|buf_i
operator|+=
name|entry_len
expr_stmt|;
comment|/* don't print '\n' for last entry */
if|if
condition|(
operator|++
name|ftl_counter
operator|!=
name|ftl_len
condition|)
block|{
name|sprintf
argument_list|(
name|buf_i
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|buf_i
operator|++
expr_stmt|;
block|}
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"sysctl error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IXL_SW_RES_SIZE
value|0x14
end_define

begin_function
specifier|static
name|int
name|ixl_res_alloc_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|i40e_aqc_switch_resource_alloc_element_resp
modifier|*
name|one
decl_stmt|,
modifier|*
name|two
decl_stmt|;
name|one
operator|=
operator|(
expr|struct
name|i40e_aqc_switch_resource_alloc_element_resp
operator|*
operator|)
name|a
expr_stmt|;
name|two
operator|=
operator|(
expr|struct
name|i40e_aqc_switch_resource_alloc_element_resp
operator|*
operator|)
name|b
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|one
operator|->
name|resource_type
operator|-
operator|(
name|int
operator|)
name|two
operator|->
name|resource_type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_hw_res_alloc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|buf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u8
name|num_entries
decl_stmt|;
name|struct
name|i40e_aqc_switch_resource_alloc_element_resp
name|resp
index|[
name|IXL_SW_RES_SIZE
index|]
decl_stmt|;
name|buf
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for output.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_aq_get_switch_resource_alloc
argument_list|(
name|hw
argument_list|,
operator|&
name|num_entries
argument_list|,
name|resp
argument_list|,
name|IXL_SW_RES_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: get_switch_resource_alloc() error %d, aq error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Sort entries by type for display */
name|qsort
argument_list|(
name|resp
argument_list|,
name|num_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_aqc_switch_resource_alloc_element_resp
argument_list|)
argument_list|,
operator|&
name|ixl_res_alloc_cmp
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"# of entries: %d\n"
argument_list|,
name|num_entries
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"Type | Guaranteed | Total | Used   | Un-allocated\n"
literal|"     | (this)     | (all) | (this) | (all)       \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%#4x | %10d   %5d   %6d   %12d"
argument_list|,
name|resp
index|[
name|i
index|]
operator|.
name|resource_type
argument_list|,
name|resp
index|[
name|i
index|]
operator|.
name|guaranteed
argument_list|,
name|resp
index|[
name|i
index|]
operator|.
name|total
argument_list|,
name|resp
index|[
name|i
index|]
operator|.
name|used
argument_list|,
name|resp
index|[
name|i
index|]
operator|.
name|total_unalloced
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|num_entries
operator|-
literal|1
condition|)
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sbuf_finish
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error finishing sbuf: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sbuf_data
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sysctl error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ** Caller must init and delete sbuf; this function will clear and ** finish it for caller. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ixl_switch_element_string
parameter_list|(
name|struct
name|sbuf
modifier|*
name|s
parameter_list|,
name|u16
name|seid
parameter_list|,
name|bool
name|uplink
parameter_list|)
block|{
name|sbuf_clear
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|seid
operator|==
literal|0
operator|&&
name|uplink
condition|)
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"Network"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|seid
operator|==
literal|0
condition|)
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"Host"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|seid
operator|==
literal|1
condition|)
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"EMP"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|seid
operator|<=
literal|5
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"MAC %d"
argument_list|,
name|seid
operator|-
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|seid
operator|<=
literal|15
condition|)
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"Reserved"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|seid
operator|<=
literal|31
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"PF %d"
argument_list|,
name|seid
operator|-
literal|16
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|seid
operator|<=
literal|159
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"VF %d"
argument_list|,
name|seid
operator|-
literal|32
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|seid
operator|<=
literal|287
condition|)
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"Reserved"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|seid
operator|<=
literal|511
condition|)
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"Other"
argument_list|)
expr_stmt|;
comment|// for other structures
elseif|else
if|if
condition|(
name|seid
operator|<=
literal|895
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"VSI %d"
argument_list|,
name|seid
operator|-
literal|512
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|seid
operator|<=
literal|1023
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"Reserved"
argument_list|)
expr_stmt|;
else|else
name|sbuf_cat
argument_list|(
name|s
argument_list|,
literal|"Invalid"
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|sbuf_data
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_sysctl_switch_config
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|buf
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|nmbuf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u8
name|aq_buf
index|[
name|I40E_AQ_LARGE_BUF
index|]
decl_stmt|;
name|u16
name|next
init|=
literal|0
decl_stmt|;
name|struct
name|i40e_aqc_get_switch_config_resp
modifier|*
name|sw_config
decl_stmt|;
name|sw_config
operator|=
operator|(
expr|struct
name|i40e_aqc_get_switch_config_resp
operator|*
operator|)
name|aq_buf
expr_stmt|;
name|buf
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for sysctl output.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|i40e_aq_get_switch_config
argument_list|(
name|hw
argument_list|,
name|sw_config
argument_list|,
sizeof|sizeof
argument_list|(
name|aq_buf
argument_list|)
argument_list|,
operator|&
name|next
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: aq_get_switch_config() error %d, aq error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|nmbuf
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nmbuf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for name output.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|// Assuming<= 255 elements in switch
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"# of elements: %d\n"
argument_list|,
name|sw_config
operator|->
name|header
operator|.
name|num_reported
argument_list|)
expr_stmt|;
comment|/* Exclude: 	** Revision -- all elements are revision 1 for now 	*/
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"SEID (  Name  ) |  Uplink  | Downlink | Conn Type\n"
literal|"                |          |          | (uplink)\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sw_config
operator|->
name|header
operator|.
name|num_reported
condition|;
name|i
operator|++
control|)
block|{
comment|// "%4d (%8s) | %8s   %8s   %#8x",
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%4d"
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|seid
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"(%8s)"
argument_list|,
name|ixl_switch_element_string
argument_list|(
name|nmbuf
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|seid
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%8s"
argument_list|,
name|ixl_switch_element_string
argument_list|(
name|nmbuf
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|uplink_seid
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%8s"
argument_list|,
name|ixl_switch_element_string
argument_list|(
name|nmbuf
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|downlink_seid
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%#8x"
argument_list|,
name|sw_config
operator|->
name|element
index|[
name|i
index|]
operator|.
name|connection_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|sw_config
operator|->
name|header
operator|.
name|num_reported
operator|-
literal|1
condition|)
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sbuf_delete
argument_list|(
name|nmbuf
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error finishing sbuf: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sbuf_data
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sysctl error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Dump TX desc given index. ** Doesn't work; don't use. ** TODO: Also needs a queue index input! **/
end_comment

begin_function
specifier|static
name|int
name|ixl_sysctl_dump_txd
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
operator|(
expr|struct
name|ixl_pf
operator|*
operator|)
name|arg1
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|buf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u16
name|desc_idx
init|=
literal|0
decl_stmt|;
name|buf
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate sbuf for output.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Read in index */
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|desc_idx
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|// fix
if|if
condition|(
name|desc_idx
operator|>
literal|1024
condition|)
block|{
comment|// fix
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid descriptor index, needs to be< 1024\n"
argument_list|)
expr_stmt|;
comment|// fix
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|// Don't use this sysctl yet
if|if
condition|(
name|TRUE
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|sbuf_cat
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|// set to queue 1?
name|struct
name|ixl_queue
modifier|*
name|que
init|=
name|pf
operator|->
name|vsi
operator|.
name|queues
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
operator|&
operator|(
name|que
index|[
literal|1
index|]
operator|.
name|txr
operator|)
decl_stmt|;
name|struct
name|i40e_tx_desc
modifier|*
name|txd
init|=
operator|&
name|txr
operator|->
name|base
index|[
name|desc_idx
index|]
decl_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"Que: %d, Desc: %d\n"
argument_list|,
name|que
operator|->
name|me
argument_list|,
name|desc_idx
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"Addr: %#18lx\n"
argument_list|,
name|txd
operator|->
name|buffer_addr
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|buf
argument_list|,
literal|"Opts: %#18lx\n"
argument_list|,
name|txd
operator|->
name|cmd_type_offset_bsz
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error finishing sbuf: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sbuf_data
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sysctl error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IXL_DEBUG_SYSCTL */
end_comment

end_unit

