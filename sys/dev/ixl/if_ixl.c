begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2013-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixl.h"
end_include

begin_include
include|#
directive|include
file|"ixl_pf.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_IW
end_ifdef

begin_include
include|#
directive|include
file|"ixl_iw.h"
end_include

begin_include
include|#
directive|include
file|"ixl_iw_int.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PCI_IOV
end_ifdef

begin_include
include|#
directive|include
file|"ixl_pf_iov.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*********************************************************************  *  Driver version  *********************************************************************/
end_comment

begin_decl_stmt
name|char
name|ixl_driver_version
index|[]
init|=
literal|"1.7.12-k"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  PCI Device ID Table  *  *  Used by probe to select devices to load on  *  Last field stores an index into ixl_strings  *  Last entry must be all 0s  *  *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|ixl_vendor_info_t
name|ixl_vendor_info_array
index|[]
init|=
block|{
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_SFP_XL710
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_KX_B
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_KX_C
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_QSFP_A
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_QSFP_B
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_QSFP_C
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_10G_BASE_T
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_10G_BASE_T4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_KX_X722
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_QSFP_X722
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_SFP_X722
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_1G_BASE_T_X722
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_10G_BASE_T_X722
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_SFP_I_X722
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_25G_B
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|I40E_INTEL_VENDOR_ID
block|,
name|I40E_DEV_ID_25G_SFP28
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* required last entry */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Table of branding strings  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ixl_strings
index|[]
init|=
block|{
literal|"Intel(R) Ethernet Connection XL710/X722 Driver"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************  *  Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|ixl_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_save_pf_tunables
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixl_attach_get_link_status
parameter_list|(
name|struct
name|ixl_pf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  *********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|ixl_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ixl_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ixl_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ixl_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|ixl_shutdown
argument_list|)
block|,
ifdef|#
directive|ifdef
name|PCI_IOV
name|DEVMETHOD
argument_list|(
name|pci_iov_init
argument_list|,
name|ixl_iov_init
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_iov_uninit
argument_list|,
name|ixl_iov_uninit
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pci_iov_add_vf
argument_list|,
name|ixl_add_vf
argument_list|)
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ixl_driver
init|=
block|{
literal|"ixl"
block|,
name|ixl_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixl_pf
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|ixl_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ixl
argument_list|,
name|pci
argument_list|,
name|ixl_driver
argument_list|,
name|ixl_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ixl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixl
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixl
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEV_NETMAP
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|1100000
end_if

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ixl
argument_list|,
name|netmap
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_comment
comment|/* ** TUNEABLE PARAMETERS: */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ixl
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"IXL driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * MSIX should be the default for best performance,  * but this allows it to be forced off for testing.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixl_enable_msix
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.enable_msix"
argument_list|,
operator|&
name|ixl_enable_msix
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_msix
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_enable_msix
argument_list|,
literal|0
argument_list|,
literal|"Enable MSI-X interrupts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Number of descriptors per ring: **   - TX and RX are the same size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixl_ring_size
init|=
name|IXL_DEFAULT_RING
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.ring_size"
argument_list|,
operator|&
name|ixl_ring_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|ring_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_ring_size
argument_list|,
literal|0
argument_list|,
literal|"Descriptor Ring Size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  ** This can be set manually, if left as 0 the ** number of queues will be calculated based ** on cpus and msix vectors available. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixl_max_queues
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.max_queues"
argument_list|,
operator|&
name|ixl_max_queues
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|max_queues
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_max_queues
argument_list|,
literal|0
argument_list|,
literal|"Number of Queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ixl_enable_tx_fc_filter
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.enable_tx_fc_filter"
argument_list|,
operator|&
name|ixl_enable_tx_fc_filter
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_tx_fc_filter
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_enable_tx_fc_filter
argument_list|,
literal|0
argument_list|,
literal|"Filter out packets with Ethertype 0x8808 from being sent out by non-HW sources"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ixl_core_debug_mask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.core_debug_mask"
argument_list|,
operator|&
name|ixl_core_debug_mask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|core_debug_mask
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_core_debug_mask
argument_list|,
literal|0
argument_list|,
literal|"Display debug statements that are printed in non-shared code"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ixl_shared_debug_mask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.shared_debug_mask"
argument_list|,
operator|&
name|ixl_shared_debug_mask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|shared_debug_mask
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_shared_debug_mask
argument_list|,
literal|0
argument_list|,
literal|"Display debug statements that are printed in shared code"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ** Controls for Interrupt Throttling  **	- true/false for dynamic adjustment ** 	- default values for static ITR */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ixl_dynamic_rx_itr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.dynamic_rx_itr"
argument_list|,
operator|&
name|ixl_dynamic_rx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|dynamic_rx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_dynamic_rx_itr
argument_list|,
literal|0
argument_list|,
literal|"Dynamic RX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ixl_dynamic_tx_itr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.dynamic_tx_itr"
argument_list|,
operator|&
name|ixl_dynamic_tx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|dynamic_tx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_dynamic_tx_itr
argument_list|,
literal|0
argument_list|,
literal|"Dynamic TX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ixl_rx_itr
init|=
name|IXL_ITR_8K
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.rx_itr"
argument_list|,
operator|&
name|ixl_rx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_rx_itr
argument_list|,
literal|0
argument_list|,
literal|"RX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ixl_tx_itr
init|=
name|IXL_ITR_4K
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.tx_itr"
argument_list|,
operator|&
name|ixl_tx_itr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ixl
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_itr
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ixl_tx_itr
argument_list|,
literal|0
argument_list|,
literal|"TX Interrupt Rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IXL_IW
end_ifdef

begin_decl_stmt
name|int
name|ixl_enable_iwarp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ixl.enable_iwarp"
argument_list|,
operator|&
name|ixl_enable_iwarp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_define
define|#
directive|define
name|NETMAP_IXL_MAIN
end_define

begin_comment
comment|/* only bring in one part of the netmap code */
end_comment

begin_include
include|#
directive|include
file|<dev/netmap/if_ixl_netmap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_comment
comment|/*********************************************************************  *  Device identification routine  *  *  ixl_probe determines if the driver should be loaded on  *  the hardware based on PCI vendor/device id of the device.  *  *  return BUS_PROBE_DEFAULT on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ixl_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|u16
name|pci_vendor_id
decl_stmt|,
name|pci_device_id
decl_stmt|;
name|u16
name|pci_subvendor_id
decl_stmt|,
name|pci_subdevice_id
decl_stmt|;
name|char
name|device_name
index|[
literal|256
index|]
decl_stmt|;
if|#
directive|if
literal|0
block|INIT_DEBUGOUT("ixl_probe: begin");
endif|#
directive|endif
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_vendor_id
operator|!=
name|I40E_INTEL_VENDOR_ID
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ent
operator|=
name|ixl_vendor_info_array
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pci_vendor_id
operator|==
name|ent
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subvendor_id
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|subdevice_id
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|device_name
argument_list|,
literal|"%s, Version - %s"
argument_list|,
name|ixl_strings
index|[
name|ent
operator|->
name|index
index|]
argument_list|,
name|ixl_driver_version
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|device_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixl_attach_get_link_status
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|hw
operator|->
name|aq
operator|.
name|fw_maj_ver
operator|==
literal|4
operator|)
operator|&&
operator|(
name|hw
operator|->
name|aq
operator|.
name|fw_min_ver
operator|<
literal|33
operator|)
operator|)
operator|||
operator|(
name|hw
operator|->
name|aq
operator|.
name|fw_maj_ver
operator|<
literal|4
operator|)
condition|)
block|{
name|i40e_msec_delay
argument_list|(
literal|75
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_aq_set_link_restart_an
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"link restart failed, aq_err=%d\n"
argument_list|,
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|asq_last_status
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|/* Determine link state */
name|hw
operator|->
name|phy
operator|.
name|get_link_info
operator|=
name|TRUE
expr_stmt|;
name|i40e_get_link_status
argument_list|(
name|hw
argument_list|,
operator|&
name|pf
operator|->
name|link_up
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sanity check and save off tunable values.  */
end_comment

begin_function
specifier|static
name|int
name|ixl_save_pf_tunables
parameter_list|(
name|struct
name|ixl_pf
modifier|*
name|pf
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|pf
operator|->
name|dev
decl_stmt|;
comment|/* Save tunable information */
name|pf
operator|->
name|enable_msix
operator|=
name|ixl_enable_msix
expr_stmt|;
name|pf
operator|->
name|max_queues
operator|=
name|ixl_max_queues
expr_stmt|;
name|pf
operator|->
name|enable_tx_fc_filter
operator|=
name|ixl_enable_tx_fc_filter
expr_stmt|;
name|pf
operator|->
name|dynamic_rx_itr
operator|=
name|ixl_dynamic_rx_itr
expr_stmt|;
name|pf
operator|->
name|dynamic_tx_itr
operator|=
name|ixl_dynamic_tx_itr
expr_stmt|;
name|pf
operator|->
name|dbg_mask
operator|=
name|ixl_core_debug_mask
expr_stmt|;
name|pf
operator|->
name|hw
operator|.
name|debug_mask
operator|=
name|ixl_shared_debug_mask
expr_stmt|;
if|if
condition|(
name|ixl_ring_size
operator|<
name|IXL_MIN_RING
operator|||
name|ixl_ring_size
operator|>
name|IXL_MAX_RING
operator|||
name|ixl_ring_size
operator|%
name|IXL_RING_INCREMENT
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid ring_size value of %d set!\n"
argument_list|,
name|ixl_ring_size
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ring_size must be between %d and %d, "
literal|"inclusive, and must be a multiple of %d\n"
argument_list|,
name|IXL_MIN_RING
argument_list|,
name|IXL_MAX_RING
argument_list|,
name|IXL_RING_INCREMENT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using default value of %d instead\n"
argument_list|,
name|IXL_DEFAULT_RING
argument_list|)
expr_stmt|;
name|pf
operator|->
name|ringsz
operator|=
name|IXL_DEFAULT_RING
expr_stmt|;
block|}
else|else
name|pf
operator|->
name|ringsz
operator|=
name|ixl_ring_size
expr_stmt|;
if|if
condition|(
name|ixl_tx_itr
operator|<
literal|0
operator|||
name|ixl_tx_itr
operator|>
name|IXL_MAX_ITR
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid tx_itr value of %d set!\n"
argument_list|,
name|ixl_tx_itr
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"tx_itr must be between %d and %d, "
literal|"inclusive\n"
argument_list|,
literal|0
argument_list|,
name|IXL_MAX_ITR
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using default value of %d instead\n"
argument_list|,
name|IXL_ITR_4K
argument_list|)
expr_stmt|;
name|pf
operator|->
name|tx_itr
operator|=
name|IXL_ITR_4K
expr_stmt|;
block|}
else|else
name|pf
operator|->
name|tx_itr
operator|=
name|ixl_tx_itr
expr_stmt|;
if|if
condition|(
name|ixl_rx_itr
operator|<
literal|0
operator|||
name|ixl_rx_itr
operator|>
name|IXL_MAX_ITR
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid rx_itr value of %d set!\n"
argument_list|,
name|ixl_rx_itr
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"rx_itr must be between %d and %d, "
literal|"inclusive\n"
argument_list|,
literal|0
argument_list|,
name|IXL_MAX_ITR
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using default value of %d instead\n"
argument_list|,
name|IXL_ITR_8K
argument_list|)
expr_stmt|;
name|pf
operator|->
name|rx_itr
operator|=
name|IXL_ITR_8K
expr_stmt|;
block|}
else|else
name|pf
operator|->
name|rx_itr
operator|=
name|ixl_rx_itr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device initialization routine  *  *  The attach entry point is called when the driver is being loaded.  *  This routine identifies the type of hardware, allocates all resources  *  and initializes the hardware.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_attach: begin"
argument_list|)
expr_stmt|;
comment|/* Allocate, clear, and link in our primary soft structure */
name|pf
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pf
operator|->
name|dev
operator|=
name|pf
operator|->
name|osdep
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|hw
operator|=
operator|&
name|pf
operator|->
name|hw
expr_stmt|;
comment|/* 	** Note this assumes we have a single embedded VSI, 	** this could be enhanced later to allocate multiple 	*/
name|vsi
operator|=
operator|&
name|pf
operator|->
name|vsi
expr_stmt|;
name|vsi
operator|->
name|dev
operator|=
name|pf
operator|->
name|dev
expr_stmt|;
comment|/* Save tunable values */
name|error
operator|=
name|ixl_save_pf_tunables
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Core Lock Init*/
name|IXL_PF_LOCK_INIT
argument_list|(
name|pf
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the timer callout */
name|callout_init_mtx
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|,
operator|&
name|pf
operator|->
name|pf_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do PCI setup - map BAR0, etc */
if|if
condition|(
name|ixl_allocate_pci_resources
argument_list|(
name|pf
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Allocation of PCI resources failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Establish a clean starting point */
name|i40e_clear_hw
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|status
operator|=
name|i40e_pf_reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PF reset failure %s\n"
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Initialize the shared code */
name|status
operator|=
name|i40e_init_shared_code
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize shared code, error %s\n"
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* 	 * Allocate interrupts and figure out number of queues to use 	 * for PF interface 	 */
name|pf
operator|->
name|msix
operator|=
name|ixl_init_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Set up the admin queue */
name|hw
operator|->
name|aq
operator|.
name|num_arq_entries
operator|=
name|IXL_AQ_LEN
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|num_asq_entries
operator|=
name|IXL_AQ_LEN
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|arq_buf_size
operator|=
name|IXL_AQ_BUF_SZ
expr_stmt|;
name|hw
operator|->
name|aq
operator|.
name|asq_buf_size
operator|=
name|IXL_AQ_BUF_SZ
expr_stmt|;
name|status
operator|=
name|i40e_init_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|status
operator|!=
name|I40E_ERR_FIRMWARE_API_VERSION
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to initialize Admin Queue, error %s\n"
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|ixl_print_nvm_version
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|I40E_ERR_FIRMWARE_API_VERSION
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The driver for the device stopped "
literal|"because the NVM image is newer than expected.\n"
literal|"You must install the most recent version of "
literal|"the network driver.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
if|if
condition|(
name|hw
operator|->
name|aq
operator|.
name|api_maj_ver
operator|==
name|I40E_FW_API_VERSION_MAJOR
operator|&&
name|hw
operator|->
name|aq
operator|.
name|api_min_ver
operator|>
name|I40E_FW_API_VERSION_MINOR
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The driver for the device detected "
literal|"a newer version of the NVM image than expected.\n"
literal|"Please install the most recent version of the network driver.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hw
operator|->
name|aq
operator|.
name|api_maj_ver
operator|<
name|I40E_FW_API_VERSION_MAJOR
operator|||
name|hw
operator|->
name|aq
operator|.
name|api_min_ver
operator|<
operator|(
name|I40E_FW_API_VERSION_MINOR
operator|-
literal|1
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The driver for the device detected "
literal|"an older version of the NVM image than expected.\n"
literal|"Please update the NVM image.\n"
argument_list|)
expr_stmt|;
comment|/* Clear PXE mode */
name|i40e_clear_pxe_mode
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Get capabilities from the device */
name|error
operator|=
name|ixl_get_hw_capabilities
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"HW capabilities failure!\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_get_cap
goto|;
block|}
comment|/* Set up host memory cache */
name|status
operator|=
name|i40e_init_lan_hmc
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_tx_qp
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_rx_qp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"init_lan_hmc failed: %s\n"
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err_get_cap
goto|;
block|}
name|status
operator|=
name|i40e_configure_lan_hmc
argument_list|(
name|hw
argument_list|,
name|I40E_HMC_MODEL_DIRECT_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"configure_lan_hmc failed: %s\n"
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err_mac_hmc
goto|;
block|}
comment|/* Init queue allocation manager */
name|error
operator|=
name|ixl_pf_qmgr_init
argument_list|(
operator|&
name|pf
operator|->
name|qmgr
argument_list|,
name|hw
operator|->
name|func_caps
operator|.
name|num_tx_qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to init queue manager for PF queues, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_mac_hmc
goto|;
block|}
comment|/* reserve a contiguous allocation for the PF's VSI */
name|error
operator|=
name|ixl_pf_qmgr_alloc_contiguous
argument_list|(
operator|&
name|pf
operator|->
name|qmgr
argument_list|,
name|vsi
operator|->
name|num_queues
argument_list|,
operator|&
name|pf
operator|->
name|qtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Failed to reserve queues for PF LAN VSI, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_mac_hmc
goto|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Allocating %d queues for PF LAN VSI; %d queues active\n"
argument_list|,
name|pf
operator|->
name|qtag
operator|.
name|num_allocated
argument_list|,
name|pf
operator|->
name|qtag
operator|.
name|num_active
argument_list|)
expr_stmt|;
comment|/* Disable LLDP from the firmware for certain NVM versions */
if|if
condition|(
operator|(
operator|(
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|fw_maj_ver
operator|==
literal|4
operator|)
operator|&&
operator|(
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|fw_min_ver
operator|<
literal|3
operator|)
operator|)
operator|||
operator|(
name|pf
operator|->
name|hw
operator|.
name|aq
operator|.
name|fw_maj_ver
operator|<
literal|4
operator|)
condition|)
name|i40e_aq_stop_lldp
argument_list|(
name|hw
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get MAC addresses from hardware */
name|i40e_get_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
name|error
operator|=
name|i40e_validate_mac_addr
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"validate_mac_addr failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_mac_hmc
goto|;
block|}
name|bcopy
argument_list|(
name|hw
operator|->
name|mac
operator|.
name|addr
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|perm_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|i40e_get_port_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|port_addr
argument_list|)
expr_stmt|;
comment|/* Initialize mac filter list for VSI */
name|SLIST_INIT
argument_list|(
operator|&
name|vsi
operator|->
name|ftl
argument_list|)
expr_stmt|;
comment|/* Set up SW VSI and allocate queue memory and rings */
if|if
condition|(
name|ixl_setup_stations
argument_list|(
name|pf
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"setup stations failed!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_mac_hmc
goto|;
block|}
comment|/* Setup OS network interface / ifnet */
if|if
condition|(
name|ixl_setup_interface
argument_list|(
name|dev
argument_list|,
name|vsi
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"interface setup failed!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Determine link state */
if|if
condition|(
name|ixl_attach_get_link_status
argument_list|(
name|pf
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
name|error
operator|=
name|ixl_switch_config
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Initial ixl_switch_config() failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Limit PHY interrupts to link, autoneg, and modules failure */
name|status
operator|=
name|i40e_aq_set_phy_int_mask
argument_list|(
name|hw
argument_list|,
name|IXL_DEFAULT_PHY_INT_MASK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"i40e_aq_set_phy_mask() failed: err %s,"
literal|" aq_err %s\n"
argument_list|,
name|i40e_stat_str
argument_list|(
name|hw
argument_list|,
name|status
argument_list|)
argument_list|,
name|i40e_aq_str
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|aq
operator|.
name|asq_last_status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
comment|/* Get the bus configuration and set the shared code's config */
name|ixl_get_bus_info
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* 	 * In MSI-X mode, initialize the Admin Queue interrupt, 	 * so userland tools can communicate with the adapter regardless of 	 * the ifnet interface's status. 	 */
if|if
condition|(
name|pf
operator|->
name|msix
operator|>
literal|1
condition|)
block|{
name|error
operator|=
name|ixl_setup_adminq_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixl_setup_adminq_msix() error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
name|error
operator|=
name|ixl_setup_adminq_tq
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixl_setup_adminq_tq() error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
name|ixl_configure_intr0_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_enable_intr0
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixl_setup_queue_msix
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixl_setup_queue_msix() error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixl_setup_queue_tqs
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixl_setup_queue_tqs() error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ixl_setup_legacy
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|error
operator|=
name|ixl_setup_adminq_tq
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixl_setup_adminq_tq() error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
name|error
operator|=
name|ixl_setup_queue_tqs
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixl_setup_queue_tqs() error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"interrupt setup error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Set initial advertised speed sysctl value */
name|ixl_get_initial_advertised_speeds
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Initialize statistics& add sysctls */
name|ixl_add_device_sysctls
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_pf_reset_stats
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_update_stats_counters
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_add_hw_stats
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Register for VLAN events */
name|vsi
operator|->
name|vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|ixl_register_vlan
argument_list|,
name|vsi
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|vsi
operator|->
name|vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|ixl_unregister_vlan
argument_list|,
name|vsi
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCI_IOV
name|ixl_initialize_sriov
argument_list|(
name|pf
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|ixl_netmap_attach
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
ifdef|#
directive|ifdef
name|IXL_IW
if|if
condition|(
name|hw
operator|->
name|func_caps
operator|.
name|iwarp
operator|&&
name|ixl_enable_iwarp
condition|)
block|{
name|pf
operator|->
name|iw_enabled
operator|=
operator|(
name|pf
operator|->
name|iw_msix
operator|>
literal|0
operator|)
condition|?
name|true
else|:
name|false
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|iw_enabled
condition|)
block|{
name|error
operator|=
name|ixl_iw_pf_attach
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"interfacing to iwarp driver failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err_late
goto|;
block|}
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"iwarp disabled on this device (no msix vectors)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pf
operator|->
name|iw_enabled
operator|=
name|false
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"The device is not iWARP enabled\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_attach: end"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_late
label|:
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
name|err_mac_hmc
label|:
name|i40e_shutdown_lan_hmc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|err_get_cap
label|:
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|err_out
label|:
name|ixl_free_pci_resources
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_free_vsi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK_DESTROY
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Device removal routine  *  *  The detach entry point is called when the driver is being removed.  *  This routine stops the adapter and deallocates all the resources  *  that were allocated for driver operation.  *  *  return 0 on success, positive on failure  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|i40e_hw
modifier|*
name|hw
init|=
operator|&
name|pf
operator|->
name|hw
decl_stmt|;
name|struct
name|ixl_vsi
modifier|*
name|vsi
init|=
operator|&
name|pf
operator|->
name|vsi
decl_stmt|;
name|enum
name|i40e_status_code
name|status
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PCI_IOV
argument_list|)
operator|||
name|defined
argument_list|(
name|IXL_IW
argument_list|)
name|int
name|error
decl_stmt|;
endif|#
directive|endif
name|INIT_DEBUGOUT
argument_list|(
literal|"ixl_detach: begin"
argument_list|)
expr_stmt|;
comment|/* Make sure VLANS are not using driver */
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Vlan in use, detach first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|PCI_IOV
name|error
operator|=
name|pci_iov_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SR-IOV in use; detach first.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
name|ether_ifdetach
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ixl_stop
argument_list|(
name|pf
argument_list|)
expr_stmt|;
comment|/* Shutdown LAN HMC */
name|status
operator|=
name|i40e_shutdown_lan_hmc
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Shutdown LAN HMC failed with code %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Teardown LAN queue resources */
name|ixl_teardown_queue_msix
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|ixl_free_queue_tqs
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
comment|/* Shutdown admin queue */
name|ixl_disable_intr0
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ixl_teardown_adminq_msix
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|ixl_free_adminq_tq
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|status
operator|=
name|i40e_shutdown_adminq
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Shutdown Admin queue failed with code %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Unregister VLAN events */
if|if
condition|(
name|vsi
operator|->
name|vlan_attach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|vsi
operator|->
name|vlan_attach
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsi
operator|->
name|vlan_detach
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|vsi
operator|->
name|vlan_detach
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|pf
operator|->
name|timer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXL_IW
if|if
condition|(
name|ixl_enable_iwarp
operator|&&
name|pf
operator|->
name|iw_enabled
condition|)
block|{
name|error
operator|=
name|ixl_iw_pf_detach
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EBUSY
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"iwarp in use; stop it first.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|netmap_detach
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|ixl_pf_qmgr_destroy
argument_list|(
operator|&
name|pf
operator|->
name|qmgr
argument_list|)
expr_stmt|;
name|ixl_free_pci_resources
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|vsi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ixl_free_vsi
argument_list|(
name|vsi
argument_list|)
expr_stmt|;
name|IXL_PF_LOCK_DESTROY
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Shutdown entry point  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ixl_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixl_pf
modifier|*
name|pf
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ixl_stop
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

