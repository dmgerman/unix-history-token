begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2013-2015, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"i40e_osdep.h"
end_include

begin_include
include|#
directive|include
file|"i40e_register.h"
end_include

begin_include
include|#
directive|include
file|"i40e_type.h"
end_include

begin_include
include|#
directive|include
file|"i40e_hmc.h"
end_include

begin_include
include|#
directive|include
file|"i40e_lan_hmc.h"
end_include

begin_include
include|#
directive|include
file|"i40e_prototype.h"
end_include

begin_comment
comment|/* lan specific interface functions */
end_comment

begin_comment
comment|/**  * i40e_align_l2obj_base - aligns base object pointer to 512 bytes  * @offset: base address offset needing alignment  *  * Aligns the layer 2 function private memory so it's 512-byte aligned.  **/
end_comment

begin_function
specifier|static
name|u64
name|i40e_align_l2obj_base
parameter_list|(
name|u64
name|offset
parameter_list|)
block|{
name|u64
name|aligned_offset
init|=
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|offset
operator|%
name|I40E_HMC_L2OBJ_BASE_ALIGNMENT
operator|)
operator|>
literal|0
condition|)
name|aligned_offset
operator|+=
operator|(
name|I40E_HMC_L2OBJ_BASE_ALIGNMENT
operator|-
operator|(
name|offset
operator|%
name|I40E_HMC_L2OBJ_BASE_ALIGNMENT
operator|)
operator|)
expr_stmt|;
return|return
name|aligned_offset
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_calculate_l2fpm_size - calculates layer 2 FPM memory size  * @txq_num: number of Tx queues needing backing context  * @rxq_num: number of Rx queues needing backing context  * @fcoe_cntx_num: amount of FCoE statefull contexts needing backing context  * @fcoe_filt_num: number of FCoE filters needing backing context  *  * Calculates the maximum amount of memory for the function required, based  * on the number of resources it must provide context for.  **/
end_comment

begin_function
name|u64
name|i40e_calculate_l2fpm_size
parameter_list|(
name|u32
name|txq_num
parameter_list|,
name|u32
name|rxq_num
parameter_list|,
name|u32
name|fcoe_cntx_num
parameter_list|,
name|u32
name|fcoe_filt_num
parameter_list|)
block|{
name|u64
name|fpm_size
init|=
literal|0
decl_stmt|;
name|fpm_size
operator|=
name|txq_num
operator|*
name|I40E_HMC_OBJ_SIZE_TXQ
expr_stmt|;
name|fpm_size
operator|=
name|i40e_align_l2obj_base
argument_list|(
name|fpm_size
argument_list|)
expr_stmt|;
name|fpm_size
operator|+=
operator|(
name|rxq_num
operator|*
name|I40E_HMC_OBJ_SIZE_RXQ
operator|)
expr_stmt|;
name|fpm_size
operator|=
name|i40e_align_l2obj_base
argument_list|(
name|fpm_size
argument_list|)
expr_stmt|;
name|fpm_size
operator|+=
operator|(
name|fcoe_cntx_num
operator|*
name|I40E_HMC_OBJ_SIZE_FCOE_CNTX
operator|)
expr_stmt|;
name|fpm_size
operator|=
name|i40e_align_l2obj_base
argument_list|(
name|fpm_size
argument_list|)
expr_stmt|;
name|fpm_size
operator|+=
operator|(
name|fcoe_filt_num
operator|*
name|I40E_HMC_OBJ_SIZE_FCOE_FILT
operator|)
expr_stmt|;
name|fpm_size
operator|=
name|i40e_align_l2obj_base
argument_list|(
name|fpm_size
argument_list|)
expr_stmt|;
return|return
name|fpm_size
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_init_lan_hmc - initialize i40e_hmc_info struct  * @hw: pointer to the HW structure  * @txq_num: number of Tx queues needing backing context  * @rxq_num: number of Rx queues needing backing context  * @fcoe_cntx_num: amount of FCoE statefull contexts needing backing context  * @fcoe_filt_num: number of FCoE filters needing backing context  *  * This function will be called once per physical function initialization.  * It will fill out the i40e_hmc_obj_info structure for LAN objects based on  * the driver's provided input, as well as information from the HMC itself  * loaded from NVRAM.  *  * Assumptions:  *   - HMC Resource Profile has been selected before calling this function.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_init_lan_hmc
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|txq_num
parameter_list|,
name|u32
name|rxq_num
parameter_list|,
name|u32
name|fcoe_cntx_num
parameter_list|,
name|u32
name|fcoe_filt_num
parameter_list|)
block|{
name|struct
name|i40e_hmc_obj_info
modifier|*
name|obj
decl_stmt|,
modifier|*
name|full_obj
decl_stmt|;
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|u64
name|l2fpm_size
decl_stmt|;
name|u32
name|size_exp
decl_stmt|;
name|hw
operator|->
name|hmc
operator|.
name|signature
operator|=
name|I40E_HMC_INFO_SIGNATURE
expr_stmt|;
name|hw
operator|->
name|hmc
operator|.
name|hmc_fn_id
operator|=
name|hw
operator|->
name|pf_id
expr_stmt|;
comment|/* allocate memory for hmc_obj */
name|ret_code
operator|=
name|i40e_allocate_virt_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj_virt_mem
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hmc_obj_info
argument_list|)
operator|*
name|I40E_HMC_LAN_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
condition|)
goto|goto
name|init_lan_hmc_out
goto|;
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
operator|=
operator|(
expr|struct
name|i40e_hmc_obj_info
operator|*
operator|)
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj_virt_mem
operator|.
name|va
expr_stmt|;
comment|/* The full object will be used to create the LAN HMC SD */
name|full_obj
operator|=
operator|&
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_LAN_FULL
index|]
expr_stmt|;
name|full_obj
operator|->
name|max_cnt
operator|=
literal|0
expr_stmt|;
name|full_obj
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
name|full_obj
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|full_obj
operator|->
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Tx queue context information */
name|obj
operator|=
operator|&
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_LAN_TX
index|]
expr_stmt|;
name|obj
operator|->
name|max_cnt
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_LANQMAX
argument_list|)
expr_stmt|;
name|obj
operator|->
name|cnt
operator|=
name|txq_num
expr_stmt|;
name|obj
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|size_exp
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_LANTXOBJSZ
argument_list|)
expr_stmt|;
name|obj
operator|->
name|size
operator|=
name|BIT_ULL
argument_list|(
name|size_exp
argument_list|)
expr_stmt|;
comment|/* validate values requested by driver don't exceed HMC capacity */
if|if
condition|(
name|txq_num
operator|>
name|obj
operator|->
name|max_cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_INVALID_HMC_OBJ_COUNT
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"i40e_init_lan_hmc: Tx context: asks for 0x%x but max allowed is 0x%x, returns error %d\n"
argument_list|,
name|txq_num
argument_list|,
name|obj
operator|->
name|max_cnt
argument_list|,
name|ret_code
argument_list|)
expr_stmt|;
goto|goto
name|init_lan_hmc_out
goto|;
block|}
comment|/* aggregate values into the full LAN object for later */
name|full_obj
operator|->
name|max_cnt
operator|+=
name|obj
operator|->
name|max_cnt
expr_stmt|;
name|full_obj
operator|->
name|cnt
operator|+=
name|obj
operator|->
name|cnt
expr_stmt|;
comment|/* Rx queue context information */
name|obj
operator|=
operator|&
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_LAN_RX
index|]
expr_stmt|;
name|obj
operator|->
name|max_cnt
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_LANQMAX
argument_list|)
expr_stmt|;
name|obj
operator|->
name|cnt
operator|=
name|rxq_num
expr_stmt|;
name|obj
operator|->
name|base
operator|=
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_LAN_TX
index|]
operator|.
name|base
operator|+
operator|(
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_LAN_TX
index|]
operator|.
name|cnt
operator|*
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_LAN_TX
index|]
operator|.
name|size
operator|)
expr_stmt|;
name|obj
operator|->
name|base
operator|=
name|i40e_align_l2obj_base
argument_list|(
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_LANRXOBJSZ
argument_list|)
expr_stmt|;
name|obj
operator|->
name|size
operator|=
name|BIT_ULL
argument_list|(
name|size_exp
argument_list|)
expr_stmt|;
comment|/* validate values requested by driver don't exceed HMC capacity */
if|if
condition|(
name|rxq_num
operator|>
name|obj
operator|->
name|max_cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_INVALID_HMC_OBJ_COUNT
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"i40e_init_lan_hmc: Rx context: asks for 0x%x but max allowed is 0x%x, returns error %d\n"
argument_list|,
name|rxq_num
argument_list|,
name|obj
operator|->
name|max_cnt
argument_list|,
name|ret_code
argument_list|)
expr_stmt|;
goto|goto
name|init_lan_hmc_out
goto|;
block|}
comment|/* aggregate values into the full LAN object for later */
name|full_obj
operator|->
name|max_cnt
operator|+=
name|obj
operator|->
name|max_cnt
expr_stmt|;
name|full_obj
operator|->
name|cnt
operator|+=
name|obj
operator|->
name|cnt
expr_stmt|;
comment|/* FCoE context information */
name|obj
operator|=
operator|&
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_FCOE_CTX
index|]
expr_stmt|;
name|obj
operator|->
name|max_cnt
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_FCOEMAX
argument_list|)
expr_stmt|;
name|obj
operator|->
name|cnt
operator|=
name|fcoe_cntx_num
expr_stmt|;
name|obj
operator|->
name|base
operator|=
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_LAN_RX
index|]
operator|.
name|base
operator|+
operator|(
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_LAN_RX
index|]
operator|.
name|cnt
operator|*
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_LAN_RX
index|]
operator|.
name|size
operator|)
expr_stmt|;
name|obj
operator|->
name|base
operator|=
name|i40e_align_l2obj_base
argument_list|(
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_FCOEDDPOBJSZ
argument_list|)
expr_stmt|;
name|obj
operator|->
name|size
operator|=
name|BIT_ULL
argument_list|(
name|size_exp
argument_list|)
expr_stmt|;
comment|/* validate values requested by driver don't exceed HMC capacity */
if|if
condition|(
name|fcoe_cntx_num
operator|>
name|obj
operator|->
name|max_cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_INVALID_HMC_OBJ_COUNT
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"i40e_init_lan_hmc: FCoE context: asks for 0x%x but max allowed is 0x%x, returns error %d\n"
argument_list|,
name|fcoe_cntx_num
argument_list|,
name|obj
operator|->
name|max_cnt
argument_list|,
name|ret_code
argument_list|)
expr_stmt|;
goto|goto
name|init_lan_hmc_out
goto|;
block|}
comment|/* aggregate values into the full LAN object for later */
name|full_obj
operator|->
name|max_cnt
operator|+=
name|obj
operator|->
name|max_cnt
expr_stmt|;
name|full_obj
operator|->
name|cnt
operator|+=
name|obj
operator|->
name|cnt
expr_stmt|;
comment|/* FCoE filter information */
name|obj
operator|=
operator|&
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_FCOE_FILT
index|]
expr_stmt|;
name|obj
operator|->
name|max_cnt
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_FCOEFMAX
argument_list|)
expr_stmt|;
name|obj
operator|->
name|cnt
operator|=
name|fcoe_filt_num
expr_stmt|;
name|obj
operator|->
name|base
operator|=
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_FCOE_CTX
index|]
operator|.
name|base
operator|+
operator|(
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_FCOE_CTX
index|]
operator|.
name|cnt
operator|*
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_FCOE_CTX
index|]
operator|.
name|size
operator|)
expr_stmt|;
name|obj
operator|->
name|base
operator|=
name|i40e_align_l2obj_base
argument_list|(
name|obj
operator|->
name|base
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|rd32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_FCOEFOBJSZ
argument_list|)
expr_stmt|;
name|obj
operator|->
name|size
operator|=
name|BIT_ULL
argument_list|(
name|size_exp
argument_list|)
expr_stmt|;
comment|/* validate values requested by driver don't exceed HMC capacity */
if|if
condition|(
name|fcoe_filt_num
operator|>
name|obj
operator|->
name|max_cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_INVALID_HMC_OBJ_COUNT
expr_stmt|;
name|DEBUGOUT3
argument_list|(
literal|"i40e_init_lan_hmc: FCoE filter: asks for 0x%x but max allowed is 0x%x, returns error %d\n"
argument_list|,
name|fcoe_filt_num
argument_list|,
name|obj
operator|->
name|max_cnt
argument_list|,
name|ret_code
argument_list|)
expr_stmt|;
goto|goto
name|init_lan_hmc_out
goto|;
block|}
comment|/* aggregate values into the full LAN object for later */
name|full_obj
operator|->
name|max_cnt
operator|+=
name|obj
operator|->
name|max_cnt
expr_stmt|;
name|full_obj
operator|->
name|cnt
operator|+=
name|obj
operator|->
name|cnt
expr_stmt|;
name|hw
operator|->
name|hmc
operator|.
name|first_sd_index
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|hmc
operator|.
name|sd_table
operator|.
name|ref_cnt
operator|=
literal|0
expr_stmt|;
name|l2fpm_size
operator|=
name|i40e_calculate_l2fpm_size
argument_list|(
name|txq_num
argument_list|,
name|rxq_num
argument_list|,
name|fcoe_cntx_num
argument_list|,
name|fcoe_filt_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|hw
operator|->
name|hmc
operator|.
name|sd_table
operator|.
name|sd_entry
condition|)
block|{
name|hw
operator|->
name|hmc
operator|.
name|sd_table
operator|.
name|sd_cnt
operator|=
call|(
name|u32
call|)
argument_list|(
name|l2fpm_size
operator|+
name|I40E_HMC_DIRECT_BP_SIZE
operator|-
literal|1
argument_list|)
operator|/
name|I40E_HMC_DIRECT_BP_SIZE
expr_stmt|;
comment|/* allocate the sd_entry members in the sd_table */
name|ret_code
operator|=
name|i40e_allocate_virt_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|hw
operator|->
name|hmc
operator|.
name|sd_table
operator|.
name|addr
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|i40e_hmc_sd_entry
argument_list|)
operator|*
name|hw
operator|->
name|hmc
operator|.
name|sd_table
operator|.
name|sd_cnt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
condition|)
goto|goto
name|init_lan_hmc_out
goto|;
name|hw
operator|->
name|hmc
operator|.
name|sd_table
operator|.
name|sd_entry
operator|=
operator|(
expr|struct
name|i40e_hmc_sd_entry
operator|*
operator|)
name|hw
operator|->
name|hmc
operator|.
name|sd_table
operator|.
name|addr
operator|.
name|va
expr_stmt|;
block|}
comment|/* store in the LAN full object for later */
name|full_obj
operator|->
name|size
operator|=
name|l2fpm_size
expr_stmt|;
name|init_lan_hmc_out
label|:
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_remove_pd_page - Remove a page from the page descriptor table  * @hw: pointer to the HW structure  * @hmc_info: pointer to the HMC configuration information structure  * @idx: segment descriptor index to find the relevant page descriptor  *  * This function:  *	1. Marks the entry in pd table (for paged address mode) invalid  *	2. write to register PMPDINV to invalidate the backing page in FV cache  *	3. Decrement the ref count for  pd_entry  * assumptions:  *	1. caller can deallocate the memory used by pd after this function  *	   returns.  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_remove_pd_page
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_hmc_info
modifier|*
name|hmc_info
parameter_list|,
name|u32
name|idx
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
if|if
condition|(
name|i40e_prep_remove_pd_page
argument_list|(
name|hmc_info
argument_list|,
name|idx
argument_list|)
operator|==
name|I40E_SUCCESS
condition|)
name|ret_code
operator|=
name|i40e_remove_pd_page_new
argument_list|(
name|hw
argument_list|,
name|hmc_info
argument_list|,
name|idx
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_remove_sd_bp - remove a backing page from a segment descriptor  * @hw: pointer to our HW structure  * @hmc_info: pointer to the HMC configuration information structure  * @idx: the page index  *  * This function:  *	1. Marks the entry in sd table (for direct address mode) invalid  *	2. write to register PMSDCMD, PMSDDATALOW(PMSDDATALOW.PMSDVALID set  *	   to 0) and PMSDDATAHIGH to invalidate the sd page  *	3. Decrement the ref count for the sd_entry  * assumptions:  *	1. caller can deallocate the memory used by backing storage after this  *	   function returns.  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_remove_sd_bp
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_hmc_info
modifier|*
name|hmc_info
parameter_list|,
name|u32
name|idx
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
if|if
condition|(
name|i40e_prep_remove_sd_bp
argument_list|(
name|hmc_info
argument_list|,
name|idx
argument_list|)
operator|==
name|I40E_SUCCESS
condition|)
name|ret_code
operator|=
name|i40e_remove_sd_bp_new
argument_list|(
name|hw
argument_list|,
name|hmc_info
argument_list|,
name|idx
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_create_lan_hmc_object - allocate backing store for hmc objects  * @hw: pointer to the HW structure  * @info: pointer to i40e_hmc_create_obj_info struct  *  * This will allocate memory for PDs and backing pages and populate  * the sd and pd entries.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_create_lan_hmc_object
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_hmc_lan_create_obj_info
modifier|*
name|info
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|struct
name|i40e_hmc_sd_entry
modifier|*
name|sd_entry
decl_stmt|;
name|u32
name|pd_idx1
init|=
literal|0
decl_stmt|,
name|pd_lmt1
init|=
literal|0
decl_stmt|;
name|u32
name|pd_idx
init|=
literal|0
decl_stmt|,
name|pd_lmt
init|=
literal|0
decl_stmt|;
name|bool
name|pd_error
init|=
name|FALSE
decl_stmt|;
name|u32
name|sd_idx
decl_stmt|,
name|sd_lmt
decl_stmt|;
name|u64
name|sd_size
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|info
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_BAD_PTR
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_create_lan_hmc_object: bad info ptr\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|NULL
operator|==
name|info
operator|->
name|hmc_info
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_BAD_PTR
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_create_lan_hmc_object: bad hmc_info ptr\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|I40E_HMC_INFO_SIGNATURE
operator|!=
name|info
operator|->
name|hmc_info
operator|->
name|signature
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_BAD_PTR
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_create_lan_hmc_object: bad signature\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|info
operator|->
name|start_idx
operator|>=
name|info
operator|->
name|hmc_info
operator|->
name|hmc_obj
index|[
name|info
operator|->
name|rsrc_type
index|]
operator|.
name|cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_INVALID_HMC_OBJ_INDEX
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"i40e_create_lan_hmc_object: returns error %d\n"
argument_list|,
name|ret_code
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|start_idx
operator|+
name|info
operator|->
name|count
operator|)
operator|>
name|info
operator|->
name|hmc_info
operator|->
name|hmc_obj
index|[
name|info
operator|->
name|rsrc_type
index|]
operator|.
name|cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_INVALID_HMC_OBJ_COUNT
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"i40e_create_lan_hmc_object: returns error %d\n"
argument_list|,
name|ret_code
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* find sd index and limit */
name|I40E_FIND_SD_INDEX_LIMIT
argument_list|(
name|info
operator|->
name|hmc_info
argument_list|,
name|info
operator|->
name|rsrc_type
argument_list|,
name|info
operator|->
name|start_idx
argument_list|,
name|info
operator|->
name|count
argument_list|,
operator|&
name|sd_idx
argument_list|,
operator|&
name|sd_lmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd_idx
operator|>=
name|info
operator|->
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_cnt
operator|||
name|sd_lmt
operator|>
name|info
operator|->
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_INVALID_SD_INDEX
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* find pd index */
name|I40E_FIND_PD_INDEX_LIMIT
argument_list|(
name|info
operator|->
name|hmc_info
argument_list|,
name|info
operator|->
name|rsrc_type
argument_list|,
name|info
operator|->
name|start_idx
argument_list|,
name|info
operator|->
name|count
argument_list|,
operator|&
name|pd_idx
argument_list|,
operator|&
name|pd_lmt
argument_list|)
expr_stmt|;
comment|/* This is to cover for cases where you may not want to have an SD with 	 * the full 2M memory but something smaller. By not filling out any 	 * size, the function will default the SD size to be 2M. 	 */
if|if
condition|(
name|info
operator|->
name|direct_mode_sz
operator|==
literal|0
condition|)
name|sd_size
operator|=
name|I40E_HMC_DIRECT_BP_SIZE
expr_stmt|;
else|else
name|sd_size
operator|=
name|info
operator|->
name|direct_mode_sz
expr_stmt|;
comment|/* check if all the sds are valid. If not, allocate a page and 	 * initialize it. 	 */
for|for
control|(
name|j
operator|=
name|sd_idx
init|;
name|j
operator|<
name|sd_lmt
condition|;
name|j
operator|++
control|)
block|{
comment|/* update the sd table entry */
name|ret_code
operator|=
name|i40e_add_sd_table_entry
argument_list|(
name|hw
argument_list|,
name|info
operator|->
name|hmc_info
argument_list|,
name|j
argument_list|,
name|info
operator|->
name|entry_type
argument_list|,
name|sd_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|I40E_SUCCESS
operator|!=
name|ret_code
condition|)
goto|goto
name|exit_sd_error
goto|;
name|sd_entry
operator|=
operator|&
name|info
operator|->
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|I40E_SD_TYPE_PAGED
operator|==
name|sd_entry
operator|->
name|entry_type
condition|)
block|{
comment|/* check if all the pds in this sd are valid. If not, 			 * allocate a page and initialize it. 			 */
comment|/* find pd_idx and pd_lmt in this sd */
name|pd_idx1
operator|=
name|max
argument_list|(
name|pd_idx
argument_list|,
operator|(
name|j
operator|*
name|I40E_HMC_MAX_BP_COUNT
operator|)
argument_list|)
expr_stmt|;
name|pd_lmt1
operator|=
name|min
argument_list|(
name|pd_lmt
argument_list|,
operator|(
operator|(
name|j
operator|+
literal|1
operator|)
operator|*
name|I40E_HMC_MAX_BP_COUNT
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|pd_idx1
init|;
name|i
operator|<
name|pd_lmt1
condition|;
name|i
operator|++
control|)
block|{
comment|/* update the pd table entry */
name|ret_code
operator|=
name|i40e_add_pd_table_entry
argument_list|(
name|hw
argument_list|,
name|info
operator|->
name|hmc_info
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|I40E_SUCCESS
operator|!=
name|ret_code
condition|)
block|{
name|pd_error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pd_error
condition|)
block|{
comment|/* remove the backing pages from pd_idx1 to i */
while|while
condition|(
name|i
operator|&&
operator|(
name|i
operator|>
name|pd_idx1
operator|)
condition|)
block|{
name|i40e_remove_pd_bp
argument_list|(
name|hw
argument_list|,
name|info
operator|->
name|hmc_info
argument_list|,
operator|(
name|i
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|sd_entry
operator|->
name|valid
condition|)
block|{
name|sd_entry
operator|->
name|valid
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|sd_entry
operator|->
name|entry_type
condition|)
block|{
case|case
name|I40E_SD_TYPE_PAGED
case|:
name|I40E_SET_PF_SD_ENTRY
argument_list|(
name|hw
argument_list|,
name|sd_entry
operator|->
name|u
operator|.
name|pd_table
operator|.
name|pd_page_addr
operator|.
name|pa
argument_list|,
name|j
argument_list|,
name|sd_entry
operator|->
name|entry_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_SD_TYPE_DIRECT
case|:
name|I40E_SET_PF_SD_ENTRY
argument_list|(
name|hw
argument_list|,
name|sd_entry
operator|->
name|u
operator|.
name|bp
operator|.
name|addr
operator|.
name|pa
argument_list|,
name|j
argument_list|,
name|sd_entry
operator|->
name|entry_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret_code
operator|=
name|I40E_ERR_INVALID_SD_TYPE
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
block|}
block|}
goto|goto
name|exit
goto|;
name|exit_sd_error
label|:
comment|/* cleanup for sd entries from j to sd_idx */
while|while
condition|(
name|j
operator|&&
operator|(
name|j
operator|>
name|sd_idx
operator|)
condition|)
block|{
name|sd_entry
operator|=
operator|&
name|info
operator|->
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|sd_entry
operator|->
name|entry_type
condition|)
block|{
case|case
name|I40E_SD_TYPE_PAGED
case|:
name|pd_idx1
operator|=
name|max
argument_list|(
name|pd_idx
argument_list|,
operator|(
operator|(
name|j
operator|-
literal|1
operator|)
operator|*
name|I40E_HMC_MAX_BP_COUNT
operator|)
argument_list|)
expr_stmt|;
name|pd_lmt1
operator|=
name|min
argument_list|(
name|pd_lmt
argument_list|,
operator|(
name|j
operator|*
name|I40E_HMC_MAX_BP_COUNT
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|pd_idx1
init|;
name|i
operator|<
name|pd_lmt1
condition|;
name|i
operator|++
control|)
name|i40e_remove_pd_bp
argument_list|(
name|hw
argument_list|,
name|info
operator|->
name|hmc_info
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i40e_remove_pd_page
argument_list|(
name|hw
argument_list|,
name|info
operator|->
name|hmc_info
argument_list|,
operator|(
name|j
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|I40E_SD_TYPE_DIRECT
case|:
name|i40e_remove_sd_bp
argument_list|(
name|hw
argument_list|,
name|info
operator|->
name|hmc_info
argument_list|,
operator|(
name|j
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret_code
operator|=
name|I40E_ERR_INVALID_SD_TYPE
expr_stmt|;
break|break;
block|}
name|j
operator|--
expr_stmt|;
block|}
name|exit
label|:
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_configure_lan_hmc - prepare the HMC backing store  * @hw: pointer to the hw structure  * @model: the model for the layout of the SD/PD tables  *  * - This function will be called once per physical function initialization.  * - This function will be called after i40e_init_lan_hmc() and before  *   any LAN/FCoE HMC objects can be created.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_configure_lan_hmc
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|enum
name|i40e_hmc_model
name|model
parameter_list|)
block|{
name|struct
name|i40e_hmc_lan_create_obj_info
name|info
decl_stmt|;
name|u8
name|hmc_fn_id
init|=
name|hw
operator|->
name|hmc
operator|.
name|hmc_fn_id
decl_stmt|;
name|struct
name|i40e_hmc_obj_info
modifier|*
name|obj
decl_stmt|;
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
comment|/* Initialize part of the create object info struct */
name|info
operator|.
name|hmc_info
operator|=
operator|&
name|hw
operator|->
name|hmc
expr_stmt|;
name|info
operator|.
name|rsrc_type
operator|=
name|I40E_HMC_LAN_FULL
expr_stmt|;
name|info
operator|.
name|start_idx
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|direct_mode_sz
operator|=
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_LAN_FULL
index|]
operator|.
name|size
expr_stmt|;
comment|/* Build the SD entry for the LAN objects */
switch|switch
condition|(
name|model
condition|)
block|{
case|case
name|I40E_HMC_MODEL_DIRECT_PREFERRED
case|:
case|case
name|I40E_HMC_MODEL_DIRECT_ONLY
case|:
name|info
operator|.
name|entry_type
operator|=
name|I40E_SD_TYPE_DIRECT
expr_stmt|;
comment|/* Make one big object, a single SD */
name|info
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|ret_code
operator|=
name|i40e_create_lan_hmc_object
argument_list|(
name|hw
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_code
operator|!=
name|I40E_SUCCESS
operator|)
operator|&&
operator|(
name|model
operator|==
name|I40E_HMC_MODEL_DIRECT_PREFERRED
operator|)
condition|)
goto|goto
name|try_type_paged
goto|;
elseif|else
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
goto|goto
name|configure_lan_hmc_out
goto|;
comment|/* else clause falls through the break */
break|break;
case|case
name|I40E_HMC_MODEL_PAGED_ONLY
case|:
name|try_type_paged
label|:
name|info
operator|.
name|entry_type
operator|=
name|I40E_SD_TYPE_PAGED
expr_stmt|;
comment|/* Make one big object in the PD table */
name|info
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|ret_code
operator|=
name|i40e_create_lan_hmc_object
argument_list|(
name|hw
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_code
operator|!=
name|I40E_SUCCESS
condition|)
goto|goto
name|configure_lan_hmc_out
goto|;
break|break;
default|default:
comment|/* unsupported type */
name|ret_code
operator|=
name|I40E_ERR_INVALID_SD_TYPE
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"i40e_configure_lan_hmc: Unknown SD type: %d\n"
argument_list|,
name|ret_code
argument_list|)
expr_stmt|;
goto|goto
name|configure_lan_hmc_out
goto|;
block|}
comment|/* Configure and program the FPM registers so objects can be created */
comment|/* Tx contexts */
name|obj
operator|=
operator|&
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_LAN_TX
index|]
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_LANTXBASE
argument_list|(
name|hmc_fn_id
argument_list|)
argument_list|,
call|(
name|u32
call|)
argument_list|(
operator|(
name|obj
operator|->
name|base
operator|&
name|I40E_GLHMC_LANTXBASE_FPMLANTXBASE_MASK
operator|)
operator|/
literal|512
argument_list|)
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_LANTXCNT
argument_list|(
name|hmc_fn_id
argument_list|)
argument_list|,
name|obj
operator|->
name|cnt
argument_list|)
expr_stmt|;
comment|/* Rx contexts */
name|obj
operator|=
operator|&
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_LAN_RX
index|]
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_LANRXBASE
argument_list|(
name|hmc_fn_id
argument_list|)
argument_list|,
call|(
name|u32
call|)
argument_list|(
operator|(
name|obj
operator|->
name|base
operator|&
name|I40E_GLHMC_LANRXBASE_FPMLANRXBASE_MASK
operator|)
operator|/
literal|512
argument_list|)
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_LANRXCNT
argument_list|(
name|hmc_fn_id
argument_list|)
argument_list|,
name|obj
operator|->
name|cnt
argument_list|)
expr_stmt|;
comment|/* FCoE contexts */
name|obj
operator|=
operator|&
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_FCOE_CTX
index|]
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_FCOEDDPBASE
argument_list|(
name|hmc_fn_id
argument_list|)
argument_list|,
call|(
name|u32
call|)
argument_list|(
operator|(
name|obj
operator|->
name|base
operator|&
name|I40E_GLHMC_FCOEDDPBASE_FPMFCOEDDPBASE_MASK
operator|)
operator|/
literal|512
argument_list|)
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_FCOEDDPCNT
argument_list|(
name|hmc_fn_id
argument_list|)
argument_list|,
name|obj
operator|->
name|cnt
argument_list|)
expr_stmt|;
comment|/* FCoE filters */
name|obj
operator|=
operator|&
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|I40E_HMC_FCOE_FILT
index|]
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_FCOEFBASE
argument_list|(
name|hmc_fn_id
argument_list|)
argument_list|,
call|(
name|u32
call|)
argument_list|(
operator|(
name|obj
operator|->
name|base
operator|&
name|I40E_GLHMC_FCOEFBASE_FPMFCOEFBASE_MASK
operator|)
operator|/
literal|512
argument_list|)
argument_list|)
expr_stmt|;
name|wr32
argument_list|(
name|hw
argument_list|,
name|I40E_GLHMC_FCOEFCNT
argument_list|(
name|hmc_fn_id
argument_list|)
argument_list|,
name|obj
operator|->
name|cnt
argument_list|)
expr_stmt|;
name|configure_lan_hmc_out
label|:
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_delete_hmc_object - remove hmc objects  * @hw: pointer to the HW structure  * @info: pointer to i40e_hmc_delete_obj_info struct  *  * This will de-populate the SDs and PDs.  It frees  * the memory for PDS and backing storage.  After this function is returned,  * caller should deallocate memory allocated previously for  * book-keeping information about PDs and backing storage.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_delete_lan_hmc_object
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|struct
name|i40e_hmc_lan_delete_obj_info
modifier|*
name|info
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|struct
name|i40e_hmc_pd_table
modifier|*
name|pd_table
decl_stmt|;
name|u32
name|pd_idx
decl_stmt|,
name|pd_lmt
decl_stmt|,
name|rel_pd_idx
decl_stmt|;
name|u32
name|sd_idx
decl_stmt|,
name|sd_lmt
decl_stmt|;
name|u32
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|info
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_BAD_PTR
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_delete_hmc_object: bad info ptr\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|NULL
operator|==
name|info
operator|->
name|hmc_info
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_BAD_PTR
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_delete_hmc_object: bad info->hmc_info ptr\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|I40E_HMC_INFO_SIGNATURE
operator|!=
name|info
operator|->
name|hmc_info
operator|->
name|signature
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_BAD_PTR
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_delete_hmc_object: bad hmc_info->signature\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|NULL
operator|==
name|info
operator|->
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_BAD_PTR
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_delete_hmc_object: bad sd_entry\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|NULL
operator|==
name|info
operator|->
name|hmc_info
operator|->
name|hmc_obj
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_BAD_PTR
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_delete_hmc_object: bad hmc_info->hmc_obj\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|info
operator|->
name|start_idx
operator|>=
name|info
operator|->
name|hmc_info
operator|->
name|hmc_obj
index|[
name|info
operator|->
name|rsrc_type
index|]
operator|.
name|cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_INVALID_HMC_OBJ_INDEX
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"i40e_delete_hmc_object: returns error %d\n"
argument_list|,
name|ret_code
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|start_idx
operator|+
name|info
operator|->
name|count
operator|)
operator|>
name|info
operator|->
name|hmc_info
operator|->
name|hmc_obj
index|[
name|info
operator|->
name|rsrc_type
index|]
operator|.
name|cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_INVALID_HMC_OBJ_COUNT
expr_stmt|;
name|DEBUGOUT1
argument_list|(
literal|"i40e_delete_hmc_object: returns error %d\n"
argument_list|,
name|ret_code
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|I40E_FIND_PD_INDEX_LIMIT
argument_list|(
name|info
operator|->
name|hmc_info
argument_list|,
name|info
operator|->
name|rsrc_type
argument_list|,
name|info
operator|->
name|start_idx
argument_list|,
name|info
operator|->
name|count
argument_list|,
operator|&
name|pd_idx
argument_list|,
operator|&
name|pd_lmt
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|pd_idx
init|;
name|j
operator|<
name|pd_lmt
condition|;
name|j
operator|++
control|)
block|{
name|sd_idx
operator|=
name|j
operator|/
name|I40E_HMC_PD_CNT_IN_SD
expr_stmt|;
if|if
condition|(
name|I40E_SD_TYPE_PAGED
operator|!=
name|info
operator|->
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|sd_idx
index|]
operator|.
name|entry_type
condition|)
continue|continue;
name|rel_pd_idx
operator|=
name|j
operator|%
name|I40E_HMC_PD_CNT_IN_SD
expr_stmt|;
name|pd_table
operator|=
operator|&
name|info
operator|->
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|sd_idx
index|]
operator|.
name|u
operator|.
name|pd_table
expr_stmt|;
if|if
condition|(
name|pd_table
operator|->
name|pd_entry
index|[
name|rel_pd_idx
index|]
operator|.
name|valid
condition|)
block|{
name|ret_code
operator|=
name|i40e_remove_pd_bp
argument_list|(
name|hw
argument_list|,
name|info
operator|->
name|hmc_info
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|I40E_SUCCESS
operator|!=
name|ret_code
condition|)
goto|goto
name|exit
goto|;
block|}
block|}
comment|/* find sd index and limit */
name|I40E_FIND_SD_INDEX_LIMIT
argument_list|(
name|info
operator|->
name|hmc_info
argument_list|,
name|info
operator|->
name|rsrc_type
argument_list|,
name|info
operator|->
name|start_idx
argument_list|,
name|info
operator|->
name|count
argument_list|,
operator|&
name|sd_idx
argument_list|,
operator|&
name|sd_lmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd_idx
operator|>=
name|info
operator|->
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_cnt
operator|||
name|sd_lmt
operator|>
name|info
operator|->
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_cnt
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_INVALID_SD_INDEX
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
for|for
control|(
name|i
operator|=
name|sd_idx
init|;
name|i
operator|<
name|sd_lmt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|i
index|]
operator|.
name|valid
condition|)
continue|continue;
switch|switch
condition|(
name|info
operator|->
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|i
index|]
operator|.
name|entry_type
condition|)
block|{
case|case
name|I40E_SD_TYPE_DIRECT
case|:
name|ret_code
operator|=
name|i40e_remove_sd_bp
argument_list|(
name|hw
argument_list|,
name|info
operator|->
name|hmc_info
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|I40E_SUCCESS
operator|!=
name|ret_code
condition|)
goto|goto
name|exit
goto|;
break|break;
case|case
name|I40E_SD_TYPE_PAGED
case|:
name|ret_code
operator|=
name|i40e_remove_pd_page
argument_list|(
name|hw
argument_list|,
name|info
operator|->
name|hmc_info
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|I40E_SUCCESS
operator|!=
name|ret_code
condition|)
goto|goto
name|exit
goto|;
break|break;
default|default:
break|break;
block|}
block|}
name|exit
label|:
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_shutdown_lan_hmc - Remove HMC backing store, free allocated memory  * @hw: pointer to the hw structure  *  * This must be called by drivers as they are shutting down and being  * removed from the OS.  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_shutdown_lan_hmc
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|i40e_hmc_lan_delete_obj_info
name|info
decl_stmt|;
name|enum
name|i40e_status_code
name|ret_code
decl_stmt|;
name|info
operator|.
name|hmc_info
operator|=
operator|&
name|hw
operator|->
name|hmc
expr_stmt|;
name|info
operator|.
name|rsrc_type
operator|=
name|I40E_HMC_LAN_FULL
expr_stmt|;
name|info
operator|.
name|start_idx
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|count
operator|=
literal|1
expr_stmt|;
comment|/* delete the object */
name|ret_code
operator|=
name|i40e_delete_lan_hmc_object
argument_list|(
name|hw
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
comment|/* free the SD table entry for LAN */
name|i40e_free_virt_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|hw
operator|->
name|hmc
operator|.
name|sd_table
operator|.
name|addr
argument_list|)
expr_stmt|;
name|hw
operator|->
name|hmc
operator|.
name|sd_table
operator|.
name|sd_cnt
operator|=
literal|0
expr_stmt|;
name|hw
operator|->
name|hmc
operator|.
name|sd_table
operator|.
name|sd_entry
operator|=
name|NULL
expr_stmt|;
comment|/* free memory used for hmc_obj */
name|i40e_free_virt_mem
argument_list|(
name|hw
argument_list|,
operator|&
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj_virt_mem
argument_list|)
expr_stmt|;
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
operator|=
name|NULL
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_define
define|#
directive|define
name|I40E_HMC_STORE
parameter_list|(
name|_struct
parameter_list|,
name|_ele
parameter_list|)
define|\
value|offsetof(struct _struct, _ele),		\ 	FIELD_SIZEOF(struct _struct, _ele)
end_define

begin_struct
struct|struct
name|i40e_context_ele
block|{
name|u16
name|offset
decl_stmt|;
name|u16
name|size_of
decl_stmt|;
name|u16
name|width
decl_stmt|;
name|u16
name|lsb
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* LAN Tx Queue Context */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|i40e_context_ele
name|i40e_hmc_txq_ce_info
index|[]
init|=
block|{
comment|/* Field      Width    LSB */
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|head
argument_list|)
block|,
literal|13
block|,
literal|0
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|new_context
argument_list|)
block|,
literal|1
block|,
literal|30
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|base
argument_list|)
block|,
literal|57
block|,
literal|32
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|fc_ena
argument_list|)
block|,
literal|1
block|,
literal|89
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|timesync_ena
argument_list|)
block|,
literal|1
block|,
literal|90
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|fd_ena
argument_list|)
block|,
literal|1
block|,
literal|91
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|alt_vlan_ena
argument_list|)
block|,
literal|1
block|,
literal|92
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|cpuid
argument_list|)
block|,
literal|8
block|,
literal|96
block|}
block|,
comment|/* line 1 */
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|thead_wb
argument_list|)
block|,
literal|13
block|,
literal|0
operator|+
literal|128
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|head_wb_ena
argument_list|)
block|,
literal|1
block|,
literal|32
operator|+
literal|128
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|qlen
argument_list|)
block|,
literal|13
block|,
literal|33
operator|+
literal|128
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|tphrdesc_ena
argument_list|)
block|,
literal|1
block|,
literal|46
operator|+
literal|128
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|tphrpacket_ena
argument_list|)
block|,
literal|1
block|,
literal|47
operator|+
literal|128
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|tphwdesc_ena
argument_list|)
block|,
literal|1
block|,
literal|48
operator|+
literal|128
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|head_wb_addr
argument_list|)
block|,
literal|64
block|,
literal|64
operator|+
literal|128
block|}
block|,
comment|/* line 7 */
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|crc
argument_list|)
block|,
literal|32
block|,
literal|0
operator|+
operator|(
literal|7
operator|*
literal|128
operator|)
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|rdylist
argument_list|)
block|,
literal|10
block|,
literal|84
operator|+
operator|(
literal|7
operator|*
literal|128
operator|)
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_txq
argument_list|,
name|rdylist_act
argument_list|)
block|,
literal|1
block|,
literal|94
operator|+
operator|(
literal|7
operator|*
literal|128
operator|)
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LAN Rx Queue Context */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|i40e_context_ele
name|i40e_hmc_rxq_ce_info
index|[]
init|=
block|{
comment|/* Field      Width    LSB */
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|head
argument_list|)
block|,
literal|13
block|,
literal|0
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|cpuid
argument_list|)
block|,
literal|8
block|,
literal|13
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|base
argument_list|)
block|,
literal|57
block|,
literal|32
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|qlen
argument_list|)
block|,
literal|13
block|,
literal|89
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|dbuff
argument_list|)
block|,
literal|7
block|,
literal|102
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|hbuff
argument_list|)
block|,
literal|5
block|,
literal|109
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|dtype
argument_list|)
block|,
literal|2
block|,
literal|114
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|dsize
argument_list|)
block|,
literal|1
block|,
literal|116
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|crcstrip
argument_list|)
block|,
literal|1
block|,
literal|117
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|fc_ena
argument_list|)
block|,
literal|1
block|,
literal|118
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|l2tsel
argument_list|)
block|,
literal|1
block|,
literal|119
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|hsplit_0
argument_list|)
block|,
literal|4
block|,
literal|120
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|hsplit_1
argument_list|)
block|,
literal|2
block|,
literal|124
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|showiv
argument_list|)
block|,
literal|1
block|,
literal|127
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|rxmax
argument_list|)
block|,
literal|14
block|,
literal|174
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|tphrdesc_ena
argument_list|)
block|,
literal|1
block|,
literal|193
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|tphwdesc_ena
argument_list|)
block|,
literal|1
block|,
literal|194
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|tphdata_ena
argument_list|)
block|,
literal|1
block|,
literal|195
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|tphhead_ena
argument_list|)
block|,
literal|1
block|,
literal|196
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|lrxqthresh
argument_list|)
block|,
literal|3
block|,
literal|198
block|}
block|,
block|{
name|I40E_HMC_STORE
argument_list|(
name|i40e_hmc_obj_rxq
argument_list|,
name|prefena
argument_list|)
block|,
literal|1
block|,
literal|201
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * i40e_write_byte - replace HMC context byte  * @hmc_bits: pointer to the HMC memory  * @ce_info: a description of the struct to be read from  * @src: the struct to be read from  **/
end_comment

begin_function
specifier|static
name|void
name|i40e_write_byte
parameter_list|(
name|u8
modifier|*
name|hmc_bits
parameter_list|,
name|struct
name|i40e_context_ele
modifier|*
name|ce_info
parameter_list|,
name|u8
modifier|*
name|src
parameter_list|)
block|{
name|u8
name|src_byte
decl_stmt|,
name|dest_byte
decl_stmt|,
name|mask
decl_stmt|;
name|u8
modifier|*
name|from
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|u16
name|shift_width
decl_stmt|;
comment|/* copy from the next struct field */
name|from
operator|=
name|src
operator|+
name|ce_info
operator|->
name|offset
expr_stmt|;
comment|/* prepare the bits and mask */
name|shift_width
operator|=
name|ce_info
operator|->
name|lsb
operator|%
literal|8
expr_stmt|;
name|mask
operator|=
call|(
name|u8
call|)
argument_list|(
name|BIT
argument_list|(
name|ce_info
operator|->
name|width
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|src_byte
operator|=
operator|*
name|from
expr_stmt|;
name|src_byte
operator|&=
name|mask
expr_stmt|;
comment|/* shift to correct alignment */
name|mask
operator|<<=
name|shift_width
expr_stmt|;
name|src_byte
operator|<<=
name|shift_width
expr_stmt|;
comment|/* get the current bits from the target bit string */
name|dest
operator|=
name|hmc_bits
operator|+
operator|(
name|ce_info
operator|->
name|lsb
operator|/
literal|8
operator|)
expr_stmt|;
name|i40e_memcpy
argument_list|(
operator|&
name|dest_byte
argument_list|,
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|dest_byte
argument_list|)
argument_list|,
name|I40E_DMA_TO_NONDMA
argument_list|)
expr_stmt|;
name|dest_byte
operator|&=
operator|~
name|mask
expr_stmt|;
comment|/* get the bits not changing */
name|dest_byte
operator||=
name|src_byte
expr_stmt|;
comment|/* add in the new bits */
comment|/* put it all back */
name|i40e_memcpy
argument_list|(
name|dest
argument_list|,
operator|&
name|dest_byte
argument_list|,
sizeof|sizeof
argument_list|(
name|dest_byte
argument_list|)
argument_list|,
name|I40E_NONDMA_TO_DMA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * i40e_write_word - replace HMC context word  * @hmc_bits: pointer to the HMC memory  * @ce_info: a description of the struct to be read from  * @src: the struct to be read from  **/
end_comment

begin_function
specifier|static
name|void
name|i40e_write_word
parameter_list|(
name|u8
modifier|*
name|hmc_bits
parameter_list|,
name|struct
name|i40e_context_ele
modifier|*
name|ce_info
parameter_list|,
name|u8
modifier|*
name|src
parameter_list|)
block|{
name|u16
name|src_word
decl_stmt|,
name|mask
decl_stmt|;
name|u8
modifier|*
name|from
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|u16
name|shift_width
decl_stmt|;
name|__le16
name|dest_word
decl_stmt|;
comment|/* copy from the next struct field */
name|from
operator|=
name|src
operator|+
name|ce_info
operator|->
name|offset
expr_stmt|;
comment|/* prepare the bits and mask */
name|shift_width
operator|=
name|ce_info
operator|->
name|lsb
operator|%
literal|8
expr_stmt|;
name|mask
operator|=
name|BIT
argument_list|(
name|ce_info
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* don't swizzle the bits until after the mask because the mask bits 	 * will be in a different bit position on big endian machines 	 */
name|src_word
operator|=
operator|*
operator|(
name|u16
operator|*
operator|)
name|from
expr_stmt|;
name|src_word
operator|&=
name|mask
expr_stmt|;
comment|/* shift to correct alignment */
name|mask
operator|<<=
name|shift_width
expr_stmt|;
name|src_word
operator|<<=
name|shift_width
expr_stmt|;
comment|/* get the current bits from the target bit string */
name|dest
operator|=
name|hmc_bits
operator|+
operator|(
name|ce_info
operator|->
name|lsb
operator|/
literal|8
operator|)
expr_stmt|;
name|i40e_memcpy
argument_list|(
operator|&
name|dest_word
argument_list|,
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|dest_word
argument_list|)
argument_list|,
name|I40E_DMA_TO_NONDMA
argument_list|)
expr_stmt|;
name|dest_word
operator|&=
operator|~
operator|(
name|CPU_TO_LE16
argument_list|(
name|mask
argument_list|)
operator|)
expr_stmt|;
comment|/* get the bits not changing */
name|dest_word
operator||=
name|CPU_TO_LE16
argument_list|(
name|src_word
argument_list|)
expr_stmt|;
comment|/* add in the new bits */
comment|/* put it all back */
name|i40e_memcpy
argument_list|(
name|dest
argument_list|,
operator|&
name|dest_word
argument_list|,
sizeof|sizeof
argument_list|(
name|dest_word
argument_list|)
argument_list|,
name|I40E_NONDMA_TO_DMA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * i40e_write_dword - replace HMC context dword  * @hmc_bits: pointer to the HMC memory  * @ce_info: a description of the struct to be read from  * @src: the struct to be read from  **/
end_comment

begin_function
specifier|static
name|void
name|i40e_write_dword
parameter_list|(
name|u8
modifier|*
name|hmc_bits
parameter_list|,
name|struct
name|i40e_context_ele
modifier|*
name|ce_info
parameter_list|,
name|u8
modifier|*
name|src
parameter_list|)
block|{
name|u32
name|src_dword
decl_stmt|,
name|mask
decl_stmt|;
name|u8
modifier|*
name|from
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|u16
name|shift_width
decl_stmt|;
name|__le32
name|dest_dword
decl_stmt|;
comment|/* copy from the next struct field */
name|from
operator|=
name|src
operator|+
name|ce_info
operator|->
name|offset
expr_stmt|;
comment|/* prepare the bits and mask */
name|shift_width
operator|=
name|ce_info
operator|->
name|lsb
operator|%
literal|8
expr_stmt|;
comment|/* if the field width is exactly 32 on an x86 machine, then the shift 	 * operation will not work because the SHL instructions count is masked 	 * to 5 bits so the shift will do nothing 	 */
if|if
condition|(
name|ce_info
operator|->
name|width
operator|<
literal|32
condition|)
name|mask
operator|=
name|BIT
argument_list|(
name|ce_info
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|mask
operator|=
operator|~
operator|(
name|u32
operator|)
literal|0
expr_stmt|;
comment|/* don't swizzle the bits until after the mask because the mask bits 	 * will be in a different bit position on big endian machines 	 */
name|src_dword
operator|=
operator|*
operator|(
name|u32
operator|*
operator|)
name|from
expr_stmt|;
name|src_dword
operator|&=
name|mask
expr_stmt|;
comment|/* shift to correct alignment */
name|mask
operator|<<=
name|shift_width
expr_stmt|;
name|src_dword
operator|<<=
name|shift_width
expr_stmt|;
comment|/* get the current bits from the target bit string */
name|dest
operator|=
name|hmc_bits
operator|+
operator|(
name|ce_info
operator|->
name|lsb
operator|/
literal|8
operator|)
expr_stmt|;
name|i40e_memcpy
argument_list|(
operator|&
name|dest_dword
argument_list|,
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|dest_dword
argument_list|)
argument_list|,
name|I40E_DMA_TO_NONDMA
argument_list|)
expr_stmt|;
name|dest_dword
operator|&=
operator|~
operator|(
name|CPU_TO_LE32
argument_list|(
name|mask
argument_list|)
operator|)
expr_stmt|;
comment|/* get the bits not changing */
name|dest_dword
operator||=
name|CPU_TO_LE32
argument_list|(
name|src_dword
argument_list|)
expr_stmt|;
comment|/* add in the new bits */
comment|/* put it all back */
name|i40e_memcpy
argument_list|(
name|dest
argument_list|,
operator|&
name|dest_dword
argument_list|,
sizeof|sizeof
argument_list|(
name|dest_dword
argument_list|)
argument_list|,
name|I40E_NONDMA_TO_DMA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * i40e_write_qword - replace HMC context qword  * @hmc_bits: pointer to the HMC memory  * @ce_info: a description of the struct to be read from  * @src: the struct to be read from  **/
end_comment

begin_function
specifier|static
name|void
name|i40e_write_qword
parameter_list|(
name|u8
modifier|*
name|hmc_bits
parameter_list|,
name|struct
name|i40e_context_ele
modifier|*
name|ce_info
parameter_list|,
name|u8
modifier|*
name|src
parameter_list|)
block|{
name|u64
name|src_qword
decl_stmt|,
name|mask
decl_stmt|;
name|u8
modifier|*
name|from
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|u16
name|shift_width
decl_stmt|;
name|__le64
name|dest_qword
decl_stmt|;
comment|/* copy from the next struct field */
name|from
operator|=
name|src
operator|+
name|ce_info
operator|->
name|offset
expr_stmt|;
comment|/* prepare the bits and mask */
name|shift_width
operator|=
name|ce_info
operator|->
name|lsb
operator|%
literal|8
expr_stmt|;
comment|/* if the field width is exactly 64 on an x86 machine, then the shift 	 * operation will not work because the SHL instructions count is masked 	 * to 6 bits so the shift will do nothing 	 */
if|if
condition|(
name|ce_info
operator|->
name|width
operator|<
literal|64
condition|)
name|mask
operator|=
name|BIT_ULL
argument_list|(
name|ce_info
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|mask
operator|=
operator|~
operator|(
name|u64
operator|)
literal|0
expr_stmt|;
comment|/* don't swizzle the bits until after the mask because the mask bits 	 * will be in a different bit position on big endian machines 	 */
name|src_qword
operator|=
operator|*
operator|(
name|u64
operator|*
operator|)
name|from
expr_stmt|;
name|src_qword
operator|&=
name|mask
expr_stmt|;
comment|/* shift to correct alignment */
name|mask
operator|<<=
name|shift_width
expr_stmt|;
name|src_qword
operator|<<=
name|shift_width
expr_stmt|;
comment|/* get the current bits from the target bit string */
name|dest
operator|=
name|hmc_bits
operator|+
operator|(
name|ce_info
operator|->
name|lsb
operator|/
literal|8
operator|)
expr_stmt|;
name|i40e_memcpy
argument_list|(
operator|&
name|dest_qword
argument_list|,
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|dest_qword
argument_list|)
argument_list|,
name|I40E_DMA_TO_NONDMA
argument_list|)
expr_stmt|;
name|dest_qword
operator|&=
operator|~
operator|(
name|CPU_TO_LE64
argument_list|(
name|mask
argument_list|)
operator|)
expr_stmt|;
comment|/* get the bits not changing */
name|dest_qword
operator||=
name|CPU_TO_LE64
argument_list|(
name|src_qword
argument_list|)
expr_stmt|;
comment|/* add in the new bits */
comment|/* put it all back */
name|i40e_memcpy
argument_list|(
name|dest
argument_list|,
operator|&
name|dest_qword
argument_list|,
sizeof|sizeof
argument_list|(
name|dest_qword
argument_list|)
argument_list|,
name|I40E_NONDMA_TO_DMA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_byte - read HMC context byte into struct  * @hmc_bits: pointer to the HMC memory  * @ce_info: a description of the struct to be filled  * @dest: the struct to be filled  **/
end_comment

begin_function
specifier|static
name|void
name|i40e_read_byte
parameter_list|(
name|u8
modifier|*
name|hmc_bits
parameter_list|,
name|struct
name|i40e_context_ele
modifier|*
name|ce_info
parameter_list|,
name|u8
modifier|*
name|dest
parameter_list|)
block|{
name|u8
name|dest_byte
decl_stmt|,
name|mask
decl_stmt|;
name|u8
modifier|*
name|src
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|u16
name|shift_width
decl_stmt|;
comment|/* prepare the bits and mask */
name|shift_width
operator|=
name|ce_info
operator|->
name|lsb
operator|%
literal|8
expr_stmt|;
name|mask
operator|=
call|(
name|u8
call|)
argument_list|(
name|BIT
argument_list|(
name|ce_info
operator|->
name|width
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* shift to correct alignment */
name|mask
operator|<<=
name|shift_width
expr_stmt|;
comment|/* get the current bits from the src bit string */
name|src
operator|=
name|hmc_bits
operator|+
operator|(
name|ce_info
operator|->
name|lsb
operator|/
literal|8
operator|)
expr_stmt|;
name|i40e_memcpy
argument_list|(
operator|&
name|dest_byte
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|dest_byte
argument_list|)
argument_list|,
name|I40E_DMA_TO_NONDMA
argument_list|)
expr_stmt|;
name|dest_byte
operator|&=
operator|~
operator|(
name|mask
operator|)
expr_stmt|;
name|dest_byte
operator|>>=
name|shift_width
expr_stmt|;
comment|/* get the address from the struct field */
name|target
operator|=
name|dest
operator|+
name|ce_info
operator|->
name|offset
expr_stmt|;
comment|/* put it back in the struct */
name|i40e_memcpy
argument_list|(
name|target
argument_list|,
operator|&
name|dest_byte
argument_list|,
sizeof|sizeof
argument_list|(
name|dest_byte
argument_list|)
argument_list|,
name|I40E_NONDMA_TO_DMA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_word - read HMC context word into struct  * @hmc_bits: pointer to the HMC memory  * @ce_info: a description of the struct to be filled  * @dest: the struct to be filled  **/
end_comment

begin_function
specifier|static
name|void
name|i40e_read_word
parameter_list|(
name|u8
modifier|*
name|hmc_bits
parameter_list|,
name|struct
name|i40e_context_ele
modifier|*
name|ce_info
parameter_list|,
name|u8
modifier|*
name|dest
parameter_list|)
block|{
name|u16
name|dest_word
decl_stmt|,
name|mask
decl_stmt|;
name|u8
modifier|*
name|src
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|u16
name|shift_width
decl_stmt|;
name|__le16
name|src_word
decl_stmt|;
comment|/* prepare the bits and mask */
name|shift_width
operator|=
name|ce_info
operator|->
name|lsb
operator|%
literal|8
expr_stmt|;
name|mask
operator|=
name|BIT
argument_list|(
name|ce_info
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* shift to correct alignment */
name|mask
operator|<<=
name|shift_width
expr_stmt|;
comment|/* get the current bits from the src bit string */
name|src
operator|=
name|hmc_bits
operator|+
operator|(
name|ce_info
operator|->
name|lsb
operator|/
literal|8
operator|)
expr_stmt|;
name|i40e_memcpy
argument_list|(
operator|&
name|src_word
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|src_word
argument_list|)
argument_list|,
name|I40E_DMA_TO_NONDMA
argument_list|)
expr_stmt|;
comment|/* the data in the memory is stored as little endian so mask it 	 * correctly 	 */
name|src_word
operator|&=
operator|~
operator|(
name|CPU_TO_LE16
argument_list|(
name|mask
argument_list|)
operator|)
expr_stmt|;
comment|/* get the data back into host order before shifting */
name|dest_word
operator|=
name|LE16_TO_CPU
argument_list|(
name|src_word
argument_list|)
expr_stmt|;
name|dest_word
operator|>>=
name|shift_width
expr_stmt|;
comment|/* get the address from the struct field */
name|target
operator|=
name|dest
operator|+
name|ce_info
operator|->
name|offset
expr_stmt|;
comment|/* put it back in the struct */
name|i40e_memcpy
argument_list|(
name|target
argument_list|,
operator|&
name|dest_word
argument_list|,
sizeof|sizeof
argument_list|(
name|dest_word
argument_list|)
argument_list|,
name|I40E_NONDMA_TO_DMA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_dword - read HMC context dword into struct  * @hmc_bits: pointer to the HMC memory  * @ce_info: a description of the struct to be filled  * @dest: the struct to be filled  **/
end_comment

begin_function
specifier|static
name|void
name|i40e_read_dword
parameter_list|(
name|u8
modifier|*
name|hmc_bits
parameter_list|,
name|struct
name|i40e_context_ele
modifier|*
name|ce_info
parameter_list|,
name|u8
modifier|*
name|dest
parameter_list|)
block|{
name|u32
name|dest_dword
decl_stmt|,
name|mask
decl_stmt|;
name|u8
modifier|*
name|src
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|u16
name|shift_width
decl_stmt|;
name|__le32
name|src_dword
decl_stmt|;
comment|/* prepare the bits and mask */
name|shift_width
operator|=
name|ce_info
operator|->
name|lsb
operator|%
literal|8
expr_stmt|;
comment|/* if the field width is exactly 32 on an x86 machine, then the shift 	 * operation will not work because the SHL instructions count is masked 	 * to 5 bits so the shift will do nothing 	 */
if|if
condition|(
name|ce_info
operator|->
name|width
operator|<
literal|32
condition|)
name|mask
operator|=
name|BIT
argument_list|(
name|ce_info
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|mask
operator|=
operator|~
operator|(
name|u32
operator|)
literal|0
expr_stmt|;
comment|/* shift to correct alignment */
name|mask
operator|<<=
name|shift_width
expr_stmt|;
comment|/* get the current bits from the src bit string */
name|src
operator|=
name|hmc_bits
operator|+
operator|(
name|ce_info
operator|->
name|lsb
operator|/
literal|8
operator|)
expr_stmt|;
name|i40e_memcpy
argument_list|(
operator|&
name|src_dword
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|src_dword
argument_list|)
argument_list|,
name|I40E_DMA_TO_NONDMA
argument_list|)
expr_stmt|;
comment|/* the data in the memory is stored as little endian so mask it 	 * correctly 	 */
name|src_dword
operator|&=
operator|~
operator|(
name|CPU_TO_LE32
argument_list|(
name|mask
argument_list|)
operator|)
expr_stmt|;
comment|/* get the data back into host order before shifting */
name|dest_dword
operator|=
name|LE32_TO_CPU
argument_list|(
name|src_dword
argument_list|)
expr_stmt|;
name|dest_dword
operator|>>=
name|shift_width
expr_stmt|;
comment|/* get the address from the struct field */
name|target
operator|=
name|dest
operator|+
name|ce_info
operator|->
name|offset
expr_stmt|;
comment|/* put it back in the struct */
name|i40e_memcpy
argument_list|(
name|target
argument_list|,
operator|&
name|dest_dword
argument_list|,
sizeof|sizeof
argument_list|(
name|dest_dword
argument_list|)
argument_list|,
name|I40E_NONDMA_TO_DMA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * i40e_read_qword - read HMC context qword into struct  * @hmc_bits: pointer to the HMC memory  * @ce_info: a description of the struct to be filled  * @dest: the struct to be filled  **/
end_comment

begin_function
specifier|static
name|void
name|i40e_read_qword
parameter_list|(
name|u8
modifier|*
name|hmc_bits
parameter_list|,
name|struct
name|i40e_context_ele
modifier|*
name|ce_info
parameter_list|,
name|u8
modifier|*
name|dest
parameter_list|)
block|{
name|u64
name|dest_qword
decl_stmt|,
name|mask
decl_stmt|;
name|u8
modifier|*
name|src
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|u16
name|shift_width
decl_stmt|;
name|__le64
name|src_qword
decl_stmt|;
comment|/* prepare the bits and mask */
name|shift_width
operator|=
name|ce_info
operator|->
name|lsb
operator|%
literal|8
expr_stmt|;
comment|/* if the field width is exactly 64 on an x86 machine, then the shift 	 * operation will not work because the SHL instructions count is masked 	 * to 6 bits so the shift will do nothing 	 */
if|if
condition|(
name|ce_info
operator|->
name|width
operator|<
literal|64
condition|)
name|mask
operator|=
name|BIT_ULL
argument_list|(
name|ce_info
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|mask
operator|=
operator|~
operator|(
name|u64
operator|)
literal|0
expr_stmt|;
comment|/* shift to correct alignment */
name|mask
operator|<<=
name|shift_width
expr_stmt|;
comment|/* get the current bits from the src bit string */
name|src
operator|=
name|hmc_bits
operator|+
operator|(
name|ce_info
operator|->
name|lsb
operator|/
literal|8
operator|)
expr_stmt|;
name|i40e_memcpy
argument_list|(
operator|&
name|src_qword
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|src_qword
argument_list|)
argument_list|,
name|I40E_DMA_TO_NONDMA
argument_list|)
expr_stmt|;
comment|/* the data in the memory is stored as little endian so mask it 	 * correctly 	 */
name|src_qword
operator|&=
operator|~
operator|(
name|CPU_TO_LE64
argument_list|(
name|mask
argument_list|)
operator|)
expr_stmt|;
comment|/* get the data back into host order before shifting */
name|dest_qword
operator|=
name|LE64_TO_CPU
argument_list|(
name|src_qword
argument_list|)
expr_stmt|;
name|dest_qword
operator|>>=
name|shift_width
expr_stmt|;
comment|/* get the address from the struct field */
name|target
operator|=
name|dest
operator|+
name|ce_info
operator|->
name|offset
expr_stmt|;
comment|/* put it back in the struct */
name|i40e_memcpy
argument_list|(
name|target
argument_list|,
operator|&
name|dest_qword
argument_list|,
sizeof|sizeof
argument_list|(
name|dest_qword
argument_list|)
argument_list|,
name|I40E_NONDMA_TO_DMA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * i40e_get_hmc_context - extract HMC context bits  * @context_bytes: pointer to the context bit array  * @ce_info: a description of the struct to be filled  * @dest: the struct to be filled  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_get_hmc_context
parameter_list|(
name|u8
modifier|*
name|context_bytes
parameter_list|,
name|struct
name|i40e_context_ele
modifier|*
name|ce_info
parameter_list|,
name|u8
modifier|*
name|dest
parameter_list|)
block|{
name|int
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|ce_info
index|[
name|f
index|]
operator|.
name|width
operator|!=
literal|0
condition|;
name|f
operator|++
control|)
block|{
switch|switch
condition|(
name|ce_info
index|[
name|f
index|]
operator|.
name|size_of
condition|)
block|{
case|case
literal|1
case|:
name|i40e_read_byte
argument_list|(
name|context_bytes
argument_list|,
operator|&
name|ce_info
index|[
name|f
index|]
argument_list|,
name|dest
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i40e_read_word
argument_list|(
name|context_bytes
argument_list|,
operator|&
name|ce_info
index|[
name|f
index|]
argument_list|,
name|dest
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i40e_read_dword
argument_list|(
name|context_bytes
argument_list|,
operator|&
name|ce_info
index|[
name|f
index|]
argument_list|,
name|dest
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|i40e_read_qword
argument_list|(
name|context_bytes
argument_list|,
operator|&
name|ce_info
index|[
name|f
index|]
argument_list|,
name|dest
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* nothing to do, just keep going */
break|break;
block|}
block|}
return|return
name|I40E_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_clear_hmc_context - zero out the HMC context bits  * @hw:       the hardware struct  * @context_bytes: pointer to the context bit array (DMA memory)  * @hmc_type: the type of HMC resource  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_clear_hmc_context
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
name|context_bytes
parameter_list|,
name|enum
name|i40e_hmc_lan_rsrc_type
name|hmc_type
parameter_list|)
block|{
comment|/* clean the bit array */
name|i40e_memset
argument_list|(
name|context_bytes
argument_list|,
literal|0
argument_list|,
operator|(
name|u32
operator|)
name|hw
operator|->
name|hmc
operator|.
name|hmc_obj
index|[
name|hmc_type
index|]
operator|.
name|size
argument_list|,
name|I40E_DMA_MEM
argument_list|)
expr_stmt|;
return|return
name|I40E_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_set_hmc_context - replace HMC context bits  * @context_bytes: pointer to the context bit array  * @ce_info:  a description of the struct to be filled  * @dest:     the struct to be filled  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_set_hmc_context
parameter_list|(
name|u8
modifier|*
name|context_bytes
parameter_list|,
name|struct
name|i40e_context_ele
modifier|*
name|ce_info
parameter_list|,
name|u8
modifier|*
name|dest
parameter_list|)
block|{
name|int
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|ce_info
index|[
name|f
index|]
operator|.
name|width
operator|!=
literal|0
condition|;
name|f
operator|++
control|)
block|{
comment|/* we have to deal with each element of the HMC using the 		 * correct size so that we are correct regardless of the 		 * endianness of the machine 		 */
switch|switch
condition|(
name|ce_info
index|[
name|f
index|]
operator|.
name|size_of
condition|)
block|{
case|case
literal|1
case|:
name|i40e_write_byte
argument_list|(
name|context_bytes
argument_list|,
operator|&
name|ce_info
index|[
name|f
index|]
argument_list|,
name|dest
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i40e_write_word
argument_list|(
name|context_bytes
argument_list|,
operator|&
name|ce_info
index|[
name|f
index|]
argument_list|,
name|dest
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i40e_write_dword
argument_list|(
name|context_bytes
argument_list|,
operator|&
name|ce_info
index|[
name|f
index|]
argument_list|,
name|dest
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|i40e_write_qword
argument_list|(
name|context_bytes
argument_list|,
operator|&
name|ce_info
index|[
name|f
index|]
argument_list|,
name|dest
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|I40E_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_hmc_get_object_va - retrieves an object's virtual address  * @hw: pointer to the hw structure  * @object_base: pointer to u64 to get the va  * @rsrc_type: the hmc resource type  * @obj_idx: hmc object index  *  * This function retrieves the object's virtual address from the object  * base pointer.  This function is used for LAN Queue contexts.  **/
end_comment

begin_function
specifier|static
name|enum
name|i40e_status_code
name|i40e_hmc_get_object_va
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u8
modifier|*
modifier|*
name|object_base
parameter_list|,
name|enum
name|i40e_hmc_lan_rsrc_type
name|rsrc_type
parameter_list|,
name|u32
name|obj_idx
parameter_list|)
block|{
name|u32
name|obj_offset_in_sd
decl_stmt|,
name|obj_offset_in_pd
decl_stmt|;
name|struct
name|i40e_hmc_info
modifier|*
name|hmc_info
init|=
operator|&
name|hw
operator|->
name|hmc
decl_stmt|;
name|struct
name|i40e_hmc_sd_entry
modifier|*
name|sd_entry
decl_stmt|;
name|struct
name|i40e_hmc_pd_entry
modifier|*
name|pd_entry
decl_stmt|;
name|u32
name|pd_idx
decl_stmt|,
name|pd_lmt
decl_stmt|,
name|rel_pd_idx
decl_stmt|;
name|enum
name|i40e_status_code
name|ret_code
init|=
name|I40E_SUCCESS
decl_stmt|;
name|u64
name|obj_offset_in_fpm
decl_stmt|;
name|u32
name|sd_idx
decl_stmt|,
name|sd_lmt
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|hmc_info
operator|->
name|hmc_obj
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_BAD_PTR
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_hmc_get_object_va: bad hmc_info->hmc_obj ptr\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|NULL
operator|==
name|object_base
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_BAD_PTR
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_hmc_get_object_va: bad object_base ptr\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|I40E_HMC_INFO_SIGNATURE
operator|!=
name|hmc_info
operator|->
name|signature
condition|)
block|{
name|ret_code
operator|=
name|I40E_ERR_BAD_PTR
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"i40e_hmc_get_object_va: bad hmc_info->signature\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|obj_idx
operator|>=
name|hmc_info
operator|->
name|hmc_obj
index|[
name|rsrc_type
index|]
operator|.
name|cnt
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"i40e_hmc_get_object_va: returns error %d\n"
argument_list|,
name|ret_code
argument_list|)
expr_stmt|;
name|ret_code
operator|=
name|I40E_ERR_INVALID_HMC_OBJ_INDEX
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* find sd index and limit */
name|I40E_FIND_SD_INDEX_LIMIT
argument_list|(
name|hmc_info
argument_list|,
name|rsrc_type
argument_list|,
name|obj_idx
argument_list|,
literal|1
argument_list|,
operator|&
name|sd_idx
argument_list|,
operator|&
name|sd_lmt
argument_list|)
expr_stmt|;
name|sd_entry
operator|=
operator|&
name|hmc_info
operator|->
name|sd_table
operator|.
name|sd_entry
index|[
name|sd_idx
index|]
expr_stmt|;
name|obj_offset_in_fpm
operator|=
name|hmc_info
operator|->
name|hmc_obj
index|[
name|rsrc_type
index|]
operator|.
name|base
operator|+
name|hmc_info
operator|->
name|hmc_obj
index|[
name|rsrc_type
index|]
operator|.
name|size
operator|*
name|obj_idx
expr_stmt|;
if|if
condition|(
name|I40E_SD_TYPE_PAGED
operator|==
name|sd_entry
operator|->
name|entry_type
condition|)
block|{
name|I40E_FIND_PD_INDEX_LIMIT
argument_list|(
name|hmc_info
argument_list|,
name|rsrc_type
argument_list|,
name|obj_idx
argument_list|,
literal|1
argument_list|,
operator|&
name|pd_idx
argument_list|,
operator|&
name|pd_lmt
argument_list|)
expr_stmt|;
name|rel_pd_idx
operator|=
name|pd_idx
operator|%
name|I40E_HMC_PD_CNT_IN_SD
expr_stmt|;
name|pd_entry
operator|=
operator|&
name|sd_entry
operator|->
name|u
operator|.
name|pd_table
operator|.
name|pd_entry
index|[
name|rel_pd_idx
index|]
expr_stmt|;
name|obj_offset_in_pd
operator|=
call|(
name|u32
call|)
argument_list|(
name|obj_offset_in_fpm
operator|%
name|I40E_HMC_PAGED_BP_SIZE
argument_list|)
expr_stmt|;
operator|*
name|object_base
operator|=
operator|(
name|u8
operator|*
operator|)
name|pd_entry
operator|->
name|bp
operator|.
name|addr
operator|.
name|va
operator|+
name|obj_offset_in_pd
expr_stmt|;
block|}
else|else
block|{
name|obj_offset_in_sd
operator|=
call|(
name|u32
call|)
argument_list|(
name|obj_offset_in_fpm
operator|%
name|I40E_HMC_DIRECT_BP_SIZE
argument_list|)
expr_stmt|;
operator|*
name|object_base
operator|=
operator|(
name|u8
operator|*
operator|)
name|sd_entry
operator|->
name|u
operator|.
name|bp
operator|.
name|addr
operator|.
name|va
operator|+
name|obj_offset_in_sd
expr_stmt|;
block|}
name|exit
label|:
return|return
name|ret_code
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_get_lan_tx_queue_context - return the HMC context for the queue  * @hw:    the hardware struct  * @queue: the queue we care about  * @s:     the struct to be filled  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_get_lan_tx_queue_context
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|queue
parameter_list|,
name|struct
name|i40e_hmc_obj_txq
modifier|*
name|s
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|err
decl_stmt|;
name|u8
modifier|*
name|context_bytes
decl_stmt|;
name|err
operator|=
name|i40e_hmc_get_object_va
argument_list|(
name|hw
argument_list|,
operator|&
name|context_bytes
argument_list|,
name|I40E_HMC_LAN_TX
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
name|err
return|;
return|return
name|i40e_get_hmc_context
argument_list|(
name|context_bytes
argument_list|,
name|i40e_hmc_txq_ce_info
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_clear_lan_tx_queue_context - clear the HMC context for the queue  * @hw:    the hardware struct  * @queue: the queue we care about  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_clear_lan_tx_queue_context
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|queue
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|err
decl_stmt|;
name|u8
modifier|*
name|context_bytes
decl_stmt|;
name|err
operator|=
name|i40e_hmc_get_object_va
argument_list|(
name|hw
argument_list|,
operator|&
name|context_bytes
argument_list|,
name|I40E_HMC_LAN_TX
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
name|err
return|;
return|return
name|i40e_clear_hmc_context
argument_list|(
name|hw
argument_list|,
name|context_bytes
argument_list|,
name|I40E_HMC_LAN_TX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_set_lan_tx_queue_context - set the HMC context for the queue  * @hw:    the hardware struct  * @queue: the queue we care about  * @s:     the struct to be filled  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_set_lan_tx_queue_context
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|queue
parameter_list|,
name|struct
name|i40e_hmc_obj_txq
modifier|*
name|s
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|err
decl_stmt|;
name|u8
modifier|*
name|context_bytes
decl_stmt|;
name|err
operator|=
name|i40e_hmc_get_object_va
argument_list|(
name|hw
argument_list|,
operator|&
name|context_bytes
argument_list|,
name|I40E_HMC_LAN_TX
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
name|err
return|;
return|return
name|i40e_set_hmc_context
argument_list|(
name|context_bytes
argument_list|,
name|i40e_hmc_txq_ce_info
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_get_lan_rx_queue_context - return the HMC context for the queue  * @hw:    the hardware struct  * @queue: the queue we care about  * @s:     the struct to be filled  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_get_lan_rx_queue_context
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|queue
parameter_list|,
name|struct
name|i40e_hmc_obj_rxq
modifier|*
name|s
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|err
decl_stmt|;
name|u8
modifier|*
name|context_bytes
decl_stmt|;
name|err
operator|=
name|i40e_hmc_get_object_va
argument_list|(
name|hw
argument_list|,
operator|&
name|context_bytes
argument_list|,
name|I40E_HMC_LAN_RX
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
name|err
return|;
return|return
name|i40e_get_hmc_context
argument_list|(
name|context_bytes
argument_list|,
name|i40e_hmc_rxq_ce_info
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_clear_lan_rx_queue_context - clear the HMC context for the queue  * @hw:    the hardware struct  * @queue: the queue we care about  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_clear_lan_rx_queue_context
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|queue
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|err
decl_stmt|;
name|u8
modifier|*
name|context_bytes
decl_stmt|;
name|err
operator|=
name|i40e_hmc_get_object_va
argument_list|(
name|hw
argument_list|,
operator|&
name|context_bytes
argument_list|,
name|I40E_HMC_LAN_RX
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
name|err
return|;
return|return
name|i40e_clear_hmc_context
argument_list|(
name|hw
argument_list|,
name|context_bytes
argument_list|,
name|I40E_HMC_LAN_RX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * i40e_set_lan_rx_queue_context - set the HMC context for the queue  * @hw:    the hardware struct  * @queue: the queue we care about  * @s:     the struct to be filled  **/
end_comment

begin_function
name|enum
name|i40e_status_code
name|i40e_set_lan_rx_queue_context
parameter_list|(
name|struct
name|i40e_hw
modifier|*
name|hw
parameter_list|,
name|u16
name|queue
parameter_list|,
name|struct
name|i40e_hmc_obj_rxq
modifier|*
name|s
parameter_list|)
block|{
name|enum
name|i40e_status_code
name|err
decl_stmt|;
name|u8
modifier|*
name|context_bytes
decl_stmt|;
name|err
operator|=
name|i40e_hmc_get_object_va
argument_list|(
name|hw
argument_list|,
operator|&
name|context_bytes
argument_list|,
name|I40E_HMC_LAN_RX
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
name|err
return|;
return|return
name|i40e_set_hmc_context
argument_list|(
name|context_bytes
argument_list|,
name|i40e_hmc_rxq_ce_info
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|s
argument_list|)
return|;
block|}
end_function

end_unit

